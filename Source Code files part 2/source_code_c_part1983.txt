     }
                }

                [CompoundCase("Version 130", 130, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE)]
                [CompoundCase("Version 140", 140, HResult.XONLINE_E_LOGON_UNKNOWN_TITLE)]
                [CompoundCase("Version 141", 141, (uint)0)]
                [TestTag("Platform=Xbox360")]
                [TestCase, Description("Title beta group that starts in the future.")]
                public class Machine_0T7: TestNode
                {
                    public override void Run()
                    {
                        uint titleVersion=(uint)(int)MyValues[0];
                        uint expectedHr=(uint)MyValues[1];
                        MakeRequestAndVerify(MachineEditor.FromName("XE.133700960009"), 34, 0x1337FF00, titleVersion, expectedHr, 0, true);
                    }
                }
            };
        };
    }

} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xkdctest_none_12.4.56.0_none_1d4d6bae9a97d513
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkdctest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7.manifest
XP_MANIFEST_PATH=manifests\msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7.cat
XP_CATALOG_PATH=manifests\msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7.cat
XP_PAYLOAD_PATH=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkdctest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XkdcUserTgtMismatchHack.cs ===
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;
using ServerTestFramework.Utilities;

namespace XkdcTest
{
    [TestGroup, Description("Tests to verify bug 176947.  These will be merged into another group soon.")]
    public class XkdcUserTgtMismatchHack: TestNode
    {
        public static void ExecuteXkdcExpectingKerbError(KdcClient client)
        {
            try
            {
                client.ExecuteXkdc(true);
            }
            catch (KerberosErrorException kee)
            {
                Global.RO.Debug("Got Kerberos Error:\n"+kee);
                return;
            }

            throw new UnexpectedTestResultException("Request unexpectedly succeeded");
        }

        //Xbox360 Console Software - Bug 176947.  The problem here was that user puids in the xkdc requset were being put in the authdata even if they didn't match the tgt.  We changed the behaviour to completely block the request with a kerberos error: KDC_ERR_SERVICE_UNAVAILABLE.  If we ever change the behaviour again we MUST also update these tests to verify that the user puid in the authdata is at least zero'd out in this case.

        [TestCase]
        public void Tgt1User_Req1Different()
        {
            //make users
            KdcUser userA=new KdcUser();
            userA.CreateUser();
            Global.RO.Debug("Created UserA: 0x{0:X}", userA.UserID);

            KdcUser userB=new KdcUser();
            userB.CreateUser();
            Global.RO.Debug("Created UserB: 0x{0:X}", userB.UserID);

            //xmacs + askdc for user A and their machine
            KdcClientXbox360 client=new KdcClientXbox360();
            client.ExecuteXmacs(true);
            client.CreateAskdcUserRequest(userA);
            client.ExecuteAskdc(true);
            client.CreateAskdcMachineRequest();
            client.ExecuteAskdc(true);

            //xkdc with user B in request
            client.CreateXkdcRequest();
            client.XkdcRequest.Input.UserIDs[0]=userB.UserID;

            ExecuteXkdcExpectingKerbError(client);
        }

        [TestCase]
        public void Tgt4User_Req1Different()
        {
            //make users
            KdcUser []userA=new KdcUser[4];
            for (int i=0; i<4; ++i)
            {
                userA[i]=new KdcUser();
                userA[i].CreateUser();
                Global.RO.Debug("Created UserA"+i+": 0x{0:X}", userA[i].UserID);
            }

            KdcUser userB=new KdcUser();
            userB.CreateUser();
            Global.RO.Debug("Created UserB: 0x{0:X}", userB.UserID);

            //xmacs + askdc for user A and their machine
            KdcClientXbox360 client=new KdcClientXbox360();
            client.ExecuteXmacs(true);

            for (int i=0; i<4; ++i)
            {
                client.CreateAskdcUserRequest(userA[i]);
                client.ExecuteAskdc(true);
            }

            client.CreateAskdcMachineRequest();
            client.ExecuteAskdc(true);

            //xkdc with user B in request and the 3 other users from A
            client.CreateXkdcRequest();
            client.XkdcRequest.Input.UserIDs[2]=userB.UserID;

            ExecuteXkdcExpectingKerbError(client);
        }

        [TestCase]
        public void Tgt0User_Req1()
        {
            //make users
            KdcUser user=new KdcUser();
            user.CreateUser();
            Global.RO.Debug("Created User: 0x{0:X}", user.UserID);

            //xmacs + askdc for only a machine
            KdcClientXbox360 client=new KdcClientXbox360();
            client.ExecuteXmacs(true);
            client.CreateAskdcMachineRequest();
            client.ExecuteAskdc(true);

            //xkdc with the user in the request
            client.CreateXkdcRequest();
            client.XkdcRequest.Input.UserIDs=new ulong[1]{user.UserID};

            ExecuteXkdcExpectingKerbError(client);
        }

        [TestCase]
        public void Tgt0User_Req4()
        {
            //make users
            KdcUser []user=new KdcUser[4];
            for (int i=0; i<4; ++i)
            {
                user[i]=new KdcUser();
                user[i].CreateUser();
                Global.RO.Debug("Created User"+i+": 0x{0:X}", user[i].UserID);
            }

            //xmacs + askdc for only a machine
            KdcClientXbox360 client=new KdcClientXbox360();
            client.ExecuteXmacs(true);
            client.CreateAskdcMachineRequest();
            client.ExecuteAskdc(true);

            //xkdc with the users in the request
            client.CreateXkdcRequest();
            client.XkdcRequest.Input.UserIDs=new ulong[4]{user[0].UserID, user[1].UserID, user[2].UserID, user[3].UserID};

            ExecuteXkdcExpectingKerbError(client);
        }

        [TestCase]
        public void Tgt2User_Req1Same()
        {
            //make users
            KdcUser userA=new KdcUser();
            userA.CreateUser();
            Global.RO.Debug("Created UserA: 0x{0:X}", userA.UserID);

            KdcUser userB=new KdcUser();
            userB.CreateUser();
            Global.RO.Debug("Created UserB: 0x{0:X}", userB.UserID);

            //xmacs + askdc for user A and user B and their machine
            KdcClientXbox360 client=new KdcClientXbox360();
            client.ExecuteXmacs(true);
            client.CreateAskdcUserRequest(userA);
            client.ExecuteAskdc(true);
            client.CreateAskdcUserRequest(userB);
            client.ExecuteAskdc(true);
            client.CreateAskdcMachineRequest();
            client.ExecuteAskdc(true);

            //xkdc with user B in request.  It's OK to request only 1 user even though there's 2 in the TGT.
            client.CreateXkdcRequest();
            client.XkdcRequest.Input.UserIDs=new ulong[]{userB.UserID};

            client.ExecuteXkdc(true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\trace\xkdctrace.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include <ctype.h>
#include <wchar.h>
#include <windows.h>
#include <wmistr.h>
#include <Evntrace.h>
#include "TraceInterface.hxx"

#pragma once

BOOL    WINAPI InitializeTrace();

VOID    WINAPI ShutdownTrace();

ULONG   WINAPI TraceString(IN DWORD Level, IN LPCWSTR Buffer);

DWORD   WINAPI GetTlsIndex();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\XkdcUtilities.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.Vortex;
using xonline.common.config;

namespace XkdcTest
{
    public class XkdcUtilities
    {
       
        public static int[] RemoveFromArray(ref uint[] array, uint[] elements)
        {
            if (elements == null)
                return null;

            ArrayList indices = new ArrayList(elements.Length);
            if (array == null) 
            {
                for (int i = 0; i < elements.Length; i++)
                    indices.Add(i);
                return (int[])indices.ToArray(typeof(int));
            }
            ArrayList list = new ArrayList(array);
            for (int i = 0; i < elements.Length; i++)
            {
                list.Remove(elements[i]);
                indices.Add(i);
            }
            array = (uint[])list.ToArray(typeof(uint));
            return (int[])indices.ToArray(typeof(int));
        }

        public static int[] AddToArray(ref uint[] array, uint[] elements)
        {
            if (elements == null)
                return null;

            ArrayList indices= new ArrayList(elements.Length);
            if (array == null) 
            {
                array  = elements;
                for (int i = 0; i < elements.Length; i++)
                    indices.Add(i);
                return (int[])indices.ToArray(typeof(int));
            }
            ArrayList list = new ArrayList(array);
            for (int i = 0; i < elements.Length; i++)
            {
                // Add unique items only
                if (list.IndexOf(elements[i]) == -1)
                {
                    list.Add(elements[i]);
                    indices.Add(i);
                }
            }
            array = (uint[])list.ToArray(typeof(uint));
            return (int[])indices.ToArray(typeof(int));
        }

        public static void AddToArrayNonunique(ref uint[] array, uint[] elements)
        {
            if (elements == null)
                return;

            if (array == null) 
            {
                array  = elements;
                return;
            }
            ArrayList list = new ArrayList(array);
            for (int i = 0; i < elements.Length; i++)
            {
                list.Add(elements[i]);
            }
            array = (uint[])list.ToArray(typeof(uint));
        }

        public static void AddToArrayNonunique(ref uint[] array, uint[] elements, int[] elementIndices)
        {
            if (elements == null)
                return;

            ArrayList list;
            if (array == null)
                list = new ArrayList(elements.Length);
            else
                list = new ArrayList(array);
            for (int i = 0; i < elementIndices.Length; i++)
            {
                list.Add(elements[elementIndices[i]]);
            }
            array = (uint[])list.ToArray(typeof(uint));
        }

        public static uint[] ArrayIntersection(uint[] a1, uint[] a2)
        {
            if (a1 == null && a2 == null)
                return null;
            else if (a1 == null)
                return a2;
            else if (a2 == null)
                return a1;

            ArrayList list = new ArrayList(a1);
            ArrayList returnList = new ArrayList(a1.Length);
            for (int i = 0; i < a2.Length; i++)
            {
                if (list.Contains(a2[i]))
                {
                    returnList.Add(a2[i]);
                }
            }
            return (uint[])returnList.ToArray(typeof(uint));
        }


#if false
        public static uint[] ArrayIntersection(uint[] a1, uint[] a2)
        {
            // TODO: slow slow slow.  these are pretty small though, so OK for now.
            
            if (a1 == null && a2 == null)
                return null;
            else if (a1 == null)
                return a2;
            else if (a2 == null)
                return a1;

            ArrayList returnList = new ArrayList(Math.Max(a1.Length, a2.Length));
            ArrayList a2list = new ArrayList(a2);
            for (int i = 0; i < a1.Length; i++)
            {
                if (a2list.IndexOf(a1[i]) != -1)
                {
                    returnList.Add(a1[i]);
                }
            }
            return (uint[])returnList.ToArray(typeof(uint));
        }

        public static void MergeTierServices(uint[] services1, uint[] hrs1, uint[] services2, uint[] hrs2, out uint[] retServices, out uint[] retHrs)
        {
            // TODO: slow slow slow.  these are pretty small though, so OK for now.
            
            Debug.Assert(services1.Length == hrs1.Length);
            Debug.Assert(services2.Length == hrs2.Length);
            int len1 = services1.Length;
            int len2 = services2.Length;

            // Outputs
            //ArrayList listRetServices = new ArrayList(Math.Max(len1, len2));
            //ArrayList listRetHrs = new ArrayList(Math.Max(len1, len2));

            // Helpers
            ArrayList listServices1 = new ArrayList(services1);
            ArrayList listHrs1 = new ArrayList(hrs1);
            ArrayList listServices2 = new ArrayList(services2);
            ArrayList listHrs2 = new ArrayList(hrs2);

            // Never remove.  If not in both, then set as NOT_AUTHORIZED.
            for (int i = 0; i < len1; i++)
            {
                // No match? Do stuff.
                if (!listServices2.Contains(services1[i]))
                {
                    // Add it, but change HR
                    listServices2.Add(services1[i]);
                    // don't even care about original HR
                    listHrs2.Add(HResult.XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED);
                    
                }
            }
            return (uint[])returnList.ToArray(typeof(uint));
        }
#endif



    }    

    public class XkdcListener : BaseXomListener
    {
        public void StartXkdcListener()
        {
            XkdcListener.StartXomListener("xkdc", "log", Interface.kdcsvc);
        }

        public void StopXkdcListener()
        {
            XkdcListener.StopXomListener("xkdc", "log", Interface.kdcsvc);
        }

        public void ValidatePresent(ulong flowToken)
        {
            for (int k = 0; k < 5; k++)
            {
                try
                {
                    foreach (string s in IncomingXomLogs)
                    {
                        if (s.Contains(String.Format("$FT{0}$", flowToken.ToString("X16"))))
                            return;
                    }
                    Thread.Sleep(1000); //Give it some time...
                }
                catch (Exception)
                {
                }
            }

            Global.RO.Error("Flowtoken:" + flowToken.ToString("X16"));
            Global.RO.Error("Contents of the listener loglines");
            Global.RO.Error("--------------");
            foreach (string s in IncomingXomLogs)
                Global.RO.Error(s);
            Global.RO.Error("--------------");            

            throw new Exception("Could not find the expected xkdc logline.");
        }

    }

    public class MappingListener : BaseXomListener
    {
        public void StartMappingListener()
        {
            MappingListener.StartXomListener("xkdc", "FlokenMap", Interface.kdcsvc);
        }

        public void StopMappingListener()
        {
            MappingListener.StopXomListener("xkdc", "FlokenMap", Interface.kdcsvc);
        }

        private string GenerateMappingLogline(ulong[] userIds, ulong machineId, ulong flowToken)
        {
            ulong[] outArr = new ulong[4];
            userIds.CopyTo(outArr, 0);

            return String.Format("FLOWMAPU|{0:X16}|{1:X}|{2:X}|{3:X}|{4:X}|0", machineId, outArr[0], outArr[1], outArr[2], outArr[3]);
        }

        public void ValidateMap(ulong[] userIds, ulong machineId, ulong flowToken)
        {
            for (int k = 0; k < 5; k++)
            {
                try
                {
                    string expectedVal = GenerateMappingLogline(userIds, machineId, flowToken);
                    Global.RO.Debug("Looking for logline " + expectedVal);

                    foreach (string s in IncomingXomLogs)
                    {
                        //Strip out the timestamp
                        string logLine = s.Substring(s.LastIndexOf("$") + 1);
                        //If the logline is the same and the string contains the flowtoken.
                        if (logLine == expectedVal && s.Contains(flowToken.ToString("X16")))
                            return;

                    }
                    Thread.Sleep(1000); //Give it some time...
                }
                catch (Exception)
                {
                }
            }

            Global.RO.Error("Flowtoken:" + flowToken.ToString("X16"));
            Global.RO.Error("Contents of the listener loglines");
            Global.RO.Error("--------------");
            foreach (string s in IncomingXomLogs)
                Global.RO.Error(s);
            Global.RO.Error("--------------");

            throw new Exception("Could not find the expected logline.");
        }

        public void ValidateNoMap(ulong[] userIds, ulong machineId, ulong flowToken)
        {
            Thread.Sleep(1000); //Let it happen.
            string expectedVal = GenerateMappingLogline(userIds, machineId, flowToken);
            Global.RO.Debug("Looking for logline " + expectedVal);

            foreach (string s in IncomingXomLogs)
            {
                //Strip out the time stamp
                string logLine = s.Substring(s.LastIndexOf("$") + 1);
                //If the logline is the same and the string contains the flowtoken.
                if (logLine == expectedVal && s.Contains(flowToken.ToString("X16")))
                    throw new Exception("Found the logline we didn't want!");

            }
        }
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xkdctest_none_12.4.56.0_none_1d4d6bae9a97d513
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkdctest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7.manifest
XP_MANIFEST_PATH=manifests\msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7.cat
XP_CATALOG_PATH=manifests\msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7.cat
XP_PAYLOAD_PATH=msil_xkdctest_no-public-key_12.4.56.0_x-ww_72e910e7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkdctest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\trace\xkdctrace.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
#include "tracep.h"


XomDefineArea(KdcCore);

TRACE_INFO_BLOCK    g_tlsBlock;
PTRACE_INFO_BLOCK   g_ptlsBlock     = NULL;
DWORD               g_TraceTlsIndex = TLS_OUT_OF_INDEXES;


BOOL
InitializeTrace()
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwCategories = 255;
    CXomSetting *pSetting = NULL;
    HRESULT hr = S_OK;

    g_xomcentral.Init("KdcCore");

    hr = g_xomcentral.GetSetting("KdcCore.TraceCategories", &pSetting);
    if ( SUCCEEDED(hr) )
    {
        dwCategories = pSetting->GetDw();
    }

    g_TraceTlsIndex = TlsAlloc();
    if ( TLS_OUT_OF_INDEXES == g_TraceTlsIndex )
    {
        dwErr = GetLastError();
        goto Error;
    }

    g_ptlsBlock              = &g_tlsBlock;
    g_ptlsBlock->Categories  = dwCategories;
    g_ptlsBlock->pfnTrace    = (TRACE_STRING)TraceString;
    g_ptlsBlock->pfnShutdown  = (SHUTDOWN_TRACE)ShutdownTrace;
    g_ptlsBlock->Buffer[0]   = L'\0';

    if ( !TlsSetValue(g_TraceTlsIndex, (LPVOID)g_ptlsBlock) )
    {
        dwErr = GetLastError();
        goto Error;
    }

Cleanup:

    return ( dwErr == ERROR_SUCCESS );

Error:

    goto Cleanup;

}


void
ShutdownTrace()
{
    g_tlsBlock.pfnTrace = NULL;
    g_tlsBlock.Categories = 0;
    TlsFree(g_TraceTlsIndex);
    g_xomcentral.Term();
}


ULONG TraceString(IN DWORD Level, IN const LPCWSTR Buffer)
{
    switch (Level)
    {
    case TRACE_ERR:
        XomTrace(KdcCore, L_ERROR, "%S", Buffer);
        break;
    case TRACE_RAW:
        XomTrace(KdcCore, L_HIGH, "%S", Buffer);
        break;
    case TRACE_FUNC:
        XomTrace(KdcCore, L_NORMAL, "%S", Buffer);
        break;
    case TRACE_VERB:
        XomTrace(KdcCore, L_LOW, "%S", Buffer);
        break;
    }
    return 0;
}


DWORD WINAPI GetTlsIndex()
{
    return g_TraceTlsIndex;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\trace\tracep.h ===
#pragma once

#include <stdlib.h>
#include "TraceInterface.hxx"
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
#include "xmgmt.h"
#include "xkdctrace.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\trace\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xkdctrace_none_12.4.56.0_none_73dce8884c4f94c3
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkdctrace
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49.manifest
XP_MANIFEST_PATH=manifests\x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49.cat
XP_CATALOG_PATH=manifests\x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49.cat
XP_PAYLOAD_PATH=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkdctrace,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\trace\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xkdctrace_none_12.4.56.0_none_73dce8884c4f94c3
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkdctrace
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49.manifest
XP_MANIFEST_PATH=manifests\x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49.cat
XP_CATALOG_PATH=manifests\x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49.cat
XP_PAYLOAD_PATH=x86_xkdctrace_no-public-key_12.4.56.0_x-ww_cc560b49
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkdctrace,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcAuthData.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "xkdc.h"

CXboxADHandler:: CXboxADHandler(CXkdcProvider *pXkdc) :
    m_pXkdc(pXkdc)
{
}

KERBERR __stdcall
CXboxADHandler::AddCAuthData2ToTicket(
    IN  IKerbRequest                *piReq,
    IN  XKDC_POLICY_DATA            *pPolicyData,
    IN  PIKerbPrincipal              piSitePrinc,
    OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
    OUT PKERB_EXT_ERROR              pExtendedError
    )
{
    KERBERR                        KerbErr = KDC_ERR_NONE;
    NTSTATUS                       status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA       pAuthData = NULL;
    PXKERB_AD_XBOX2                pXboxAD = NULL;
    PXKERB_AD_XBOX_WITH_SIGNATURE2 pXboxADWithSig = NULL;
    ULONG ulChecksumSize = 0;
    ULONG ulSignatureSize = 0;
    ULONG ulXboxADSize = 0;

    XOMASSERT( piReq );
    XOMASSERT( pPolicyData );
    XOMASSERT( ppAuthData );
    XOMASSERT( pExtendedError );

    // allocate space for our Xbox-specific authdata
    pXboxADWithSig = (PXKERB_AD_XBOX_WITH_SIGNATURE2) m_pXkdc->KdcAllocMemory(sizeof(*pXboxADWithSig));
    if ( pXboxADWithSig == NULL )
    {
        XomNtEvent( XEVENT_XKDC_NO_MEMORY_1,
            "(%s:%d) AddCAuthData2ToTicket: failed to allocate %d bytes for XKERB_AD_XBOX_WITH_SIGNATURE.",
            __FILE__,
            __LINE__,
            sizeof(*pXboxADWithSig)
            );

        status  = STATUS_NO_MEMORY;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }
    ZeroMemory(pXboxADWithSig, sizeof(*pXboxADWithSig));

    // allocate space for the authdata envelope
    pAuthData = (PKERB_AUTHORIZATION_DATA) m_pXkdc->KdcAllocMemory(sizeof(*pAuthData));
    if ( pAuthData == NULL )
    {
        XomNtEvent(XEVENT_KDC_CODE_99,
            "(%s:%d) AddCAuthData2ToTicket: failed to allocate %d bytes for KERB_AUTHORIZATION_DATA.",
            __FILE__,
            __LINE__,
            sizeof(*pAuthData)
            );
        status  = STATUS_NO_MEMORY;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }
    ZeroMemory(pAuthData, sizeof(*pAuthData));

    // For internal errors such as memory allocation problems, we fail the
    // entire request and do not return a ticket.
    if ( KERB_SUCCESS(pPolicyData->KerbErr) && !NT_SUCCESS(pPolicyData->policyStatus) )
    {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // copy the authdata from the policy data
    pXboxAD = &(pXboxADWithSig->authData);
    pXboxAD->wAuthDataVersion = XONLINE_AUTHDATA_VERSION;
    pXboxAD->wAuthDataSize    = sizeof(*pXboxAD);
    pXboxAD->clientVersion    = pPolicyData->clientVersion;
    pXboxAD->dwTitleID        = pPolicyData->dwTitleID;
    pXboxAD->dwTitleVersion   = pPolicyData->dwTitleVersion;
    pXboxAD->dwTitleRegion    = pPolicyData->dwTitleRegion;
    pXboxAD->qwXboxID         = pPolicyData->qwXboxID;
    pXboxAD->dwNumServices    = pPolicyData->dwXboxNumServices;
    for (DWORD u = 0; u < XONLINE_MAX_LOGON_USERS; ++u)
    {
        if ( 0 == pPolicyData->users[u].qwUserID)
        {
            continue;
        }
        pXboxAD->users[u].qwUserID    = pPolicyData->users[u].qwUserID;
        pXboxAD->users[u].dwUserFlags = pPolicyData->users[u].dwUserFlags;
        pXboxAD->afltTrustFactor[u]   = pPolicyData->afltTrustFactor[u];
    }
    memcpy( pXboxAD->dwServiceID,  pPolicyData->dwXboxServiceID, sizeof(pXboxAD->dwServiceID) );
    memcpy( pXboxAD->dwAltTitleID, pPolicyData->dwAltTitleID,    sizeof(pXboxAD->dwAltTitleID) );

    // copy signing key to Xbox authdata
    C_ASSERT(sizeof(pXboxAD->abKey) == sizeof(pPolicyData->abKey));
    memcpy(pXboxAD->abKey, pPolicyData->abKey, sizeof(pXboxAD->abKey));

    // find the size of the signature buffer
    ulSignatureSize = sizeof(pXboxADWithSig->ServerSignature);

    // get the checksum size
    status = piSitePrinc->GetChecksumSize(
        KERB_CHECKSUM_HMAC_MD5,
        &ulChecksumSize
        );
    if ( !NT_SUCCESS(status) )
    {
        XomTrace(Xkdc, L_ERROR, "(%s:%d) AddCAuthData2ToTicket: GetChecksumSize failed with status %d.", __FILE__, __LINE__, status);
        goto Cleanup;
    }

    // the checksum size must fit into our authdata struct
    XOMASSERT( ulChecksumSize <= ulSignatureSize );

    if ( ulChecksumSize > ulSignatureSize )
    {
        XomNtEvent(XEVENT_XKDC_CHECKSUM_OVERFLOW,
            "(%s:%d) AddCAuthData2ToTicket: HMAC_MD5 checksum (%d bytes) too large for structure (%d bytes).",
            __FILE__,
            __LINE__,
            ulChecksumSize,
            ulSignatureSize);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // Grab the size that we will be signing
    ulXboxADSize = sizeof(*pXboxAD);

    // sign the authdata using the site key
    status = piSitePrinc->Checksum(
        KERB_CHECKSUM_HMAC_MD5,
        KERB_PA_XBOX_SERVICE_ADDRESS_SALT,
        piReq->GetEncryptionTypes(),
        (PBYTE*) &pXboxAD,
        &ulXboxADSize,
        1,
        NULL,
        0,
        pXboxADWithSig->ServerSignature,
        &ulSignatureSize,
        NULL,
        pExtendedError
        );
    if ( !NT_SUCCESS(status) )
    {
        XomTrace(Xkdc,
            L_ERROR,
            "(%s:%d) AddCAuthData2ToTicket: Checksum failed with error %d.",
            __FILE__,
            __LINE__,
            status
            );
        goto Cleanup;
    }

    // update perfcounters
    if ( pPolicyData->bUseValidSite )
    {
        if ( pPolicyData->bMachineOnly )
        {
            g_Counters.IncrementValue32(XKDCPERF_SERVER_MACHINE_TICKETS, 1);
            g_Counters.IncrementValue32(XKDCPERF_SERVER_MACHINE_TICKETS_RATE, 1);
        }
        else
        {
            XOMASSERT( pXboxAD->users[0].qwUserID
                    || pXboxAD->users[1].qwUserID
                    || pXboxAD->users[2].qwUserID
                    || pXboxAD->users[3].qwUserID );

            XOMASSERT(
                   pXboxAD->users[0].qwUserID == pPolicyData->users[0].qwUserID
                && pXboxAD->users[1].qwUserID == pPolicyData->users[1].qwUserID
                && pXboxAD->users[2].qwUserID == pPolicyData->users[2].qwUserID
                && pXboxAD->users[3].qwUserID == pPolicyData->users[3].qwUserID );

            g_Counters.IncrementValue32(XKDCPERF_SERVER_USER_TICKETS, 1);
            g_Counters.IncrementValue32(XKDCPERF_SERVER_USER_TICKETS_RATE, 1);

            g_Counters.IncrementValue32(XKDCPERF_SERVER_USER_TICKETS_TOTAL_USERS, pPolicyData->dwUsers);
            g_Counters.IncrementValue64(XKDCPERF_SERVER_USERS_PER_TICKET_AVERAGE, pPolicyData->dwUsers);
            g_Counters.IncrementValue32(XKDCPERF_SERVER_USERS_PER_TICKET_BASE, 1);
        }
    }
    else
    {
        g_Counters.IncrementValue32(XKDCPERF_SERVER_INVALID_TICKETS, 1);
        g_Counters.IncrementValue32(XKDCPERF_SERVER_INVALID_TICKETS_RATE, 1);
    }

    // copy the signed Xbox authdata to the authdata return envelope
    pAuthData->next = *ppAuthData;
    //pAuthData->value.auth_data_type = GetADType();

    pAuthData->value.auth_data_type   = KERB_AUTH_DATA_XBOX;
    pAuthData->value.auth_data.length = sizeof(*pXboxADWithSig);
    pAuthData->value.auth_data.value  = (PUCHAR) pXboxADWithSig;
    pXboxADWithSig = NULL;

    XomTrace(Xkdc,
        L_LOW,
        "(%s:%d) AddCAuthData2ToTicket: added Xbox authdata (%d bytes) to ticket.",
        __FILE__,
        __LINE__,
        pAuthData->value.auth_data.length
        );

    *ppAuthData = pAuthData;
    pAuthData = NULL;

Cleanup:
    if ( pAuthData )
    {
        m_pXkdc->KdcFreeMemory(pAuthData);
    }
    if ( pXboxADWithSig )
    {
        m_pXkdc->KdcFreeMemory(pXboxADWithSig);
    }
    pExtendedError->status = status;
    return KerbErr;
}

KERBERR __stdcall
CXboxADHandler::AddCAuthData3ToTicket(
    IN  IKerbRequest                *piReq,
    IN  XKDC_POLICY_DATA            *pPolicyData,
    IN  PIKerbPrincipal              piSitePrinc,
    OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
    OUT PKERB_EXT_ERROR              pExtendedError
    )
{
    KERBERR                        KerbErr = KDC_ERR_NONE;
    NTSTATUS                       status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA       pAuthData = NULL;
    PXKERB_AD_XENON                pXenonAD = NULL;
    PXKERB_AD_XENON_WITH_SIGNATURE pXenonADWithSig = NULL;
    ULONG ulChecksumSize = 0;
    ULONG ulSignatureSize = 0;
    ULONG ulXenonADSize = 0;

    XOMASSERT( piReq );
    XOMASSERT( pPolicyData );
    XOMASSERT( ppAuthData );
    XOMASSERT( pExtendedError );

    // allocate space for our Xenon-specific authdata
    pXenonADWithSig = (PXKERB_AD_XENON_WITH_SIGNATURE) m_pXkdc->KdcAllocMemory(sizeof(*pXenonADWithSig));
    if ( pXenonADWithSig == NULL )
    {
        XomNtEvent( XEVENT_KDC_CODE_96,
            "(%s:%d) AddCAuthData3ToTicket: failed to allocate %d bytes for XKERB_AD_XENON_WITH_SIGNATURE.",
            __FILE__,
            __LINE__,
            sizeof(*pXenonADWithSig)
            );

        status  = STATUS_NO_MEMORY;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }
    ZeroMemory(pXenonADWithSig, sizeof(*pXenonADWithSig));

    // allocate space for the authdata envelope
    pAuthData = (PKERB_AUTHORIZATION_DATA) m_pXkdc->KdcAllocMemory(sizeof(*pAuthData));
    if ( pAuthData == NULL )
    {
        XomNtEvent( XEVENT_XKDC_NO_MEMORY,
            "(%s:%d) AddCAuthData3ToTicket: failed to allocate %d bytes for KERB_AUTHORIZATION_DATA.",
            __FILE__,
            __LINE__,
            sizeof(*pAuthData)
            );

        status  = STATUS_NO_MEMORY;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }
    ZeroMemory(pAuthData, sizeof(*pAuthData));

    // For internal errors such as memory allocation problems, we fail the
    // entire request and do not return a ticket.
    if ( KERB_SUCCESS(pPolicyData->KerbErr) && !NT_SUCCESS(pPolicyData->policyStatus) )
    {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // copy the authdata from the policy data
    pXenonAD = &(pXenonADWithSig->authData);
    pXenonAD->wAuthDataVersion  = XONLINE_XENON_AUTHDATA_VERSION;
    pXenonAD->wAuthDataSize     = sizeof(*pXenonAD);
    pXenonAD->clientVersion     = pPolicyData->clientVersion;
    pXenonAD->dwTitleID         = pPolicyData->dwTitleID;
    pXenonAD->dwTitleVersion    = pPolicyData->dwTitleVersion;
    pXenonAD->dwTitleRegion     = pPolicyData->dwTitleRegion;
    pXenonAD->dwConsoleRegion   = pPolicyData->dwConsoleRegion;
    pXenonAD->dwMediaID         = pPolicyData->dwMediaID;
    pXenonAD->wLanguageID       = pPolicyData->wLanguageID;
    pXenonAD->dwAuthDataFlags   = pPolicyData->dwAuthDataFlags;
    pXenonAD->wNumPrivileges    = pPolicyData->wXenonNumPrivileges;
    memcpy( pXenonAD->dwPrivileges, pPolicyData->dwXenonPrivileges, sizeof( pXenonAD->dwPrivileges ) );
    pXenonAD->qwXboxID          = pPolicyData->qwXboxID;
    for (DWORD u = 0; u < XONLINE_MAX_LOGON_USERS; ++u)
    {
        if ( 0 == pPolicyData->users[u].qwUserID)
        {
            continue;
        }
        pXenonAD->users[u].qwUserID    = pPolicyData->users[u].qwUserID;
        pXenonAD->users[u].dwUserFlags = pPolicyData->users[u].dwUserFlags;
        pXenonAD->afltTrustFactor[u]   = pPolicyData->afltTrustFactor[u];
    }
    pXenonAD->wNumDwordServices = pPolicyData->wXenonNumDwordServices;
    memcpy( pXenonAD->dwServiceID,  pPolicyData->dwXenonServiceID, sizeof(pXenonAD->dwServiceID) );
    memcpy( pXenonAD->dwAltTitleID, pPolicyData->dwAltTitleID,     sizeof(pXenonAD->dwAltTitleID) );

    // copy signing key to Xenon authdata
    C_ASSERT(sizeof(pXenonAD->abKey) == sizeof(pPolicyData->abKey));
    memcpy(pXenonAD->abKey, pPolicyData->abKey, sizeof(pXenonAD->abKey));

    // find the size of the signature buffer
    ulSignatureSize = sizeof(pXenonADWithSig->ServerSignature);

    // get the checksum size
    status = piSitePrinc->GetChecksumSize(
        KERB_CHECKSUM_HMAC_MD5,
        &ulChecksumSize
        );
    if ( !NT_SUCCESS(status) )
    {
        XomTrace( Xkdc,
            L_ERROR,
            "(%s:%d) AddCAuthData3ToTicket: GetChecksumSize failed with status %d.",
            __FILE__,
            __LINE__,
            status
            );
        goto Cleanup;
    }

    // the checksum size must fit into our authdata struct
    XOMASSERT( ulChecksumSize <= ulSignatureSize );

    if ( ulChecksumSize > ulSignatureSize )
    {
        XomNtEvent( XEVENT_XKDC_CHECKSUM_OVERFLOW,
            "(%s:%d) AddCAuthData3ToTicket: HMAC_MD5 checksum (%d bytes) too large for structure (%d bytes).",
            __FILE__,
            __LINE__,
            ulChecksumSize,
            ulSignatureSize);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // Grab the size that we will be signing
    ulXenonADSize = sizeof(*pXenonAD);

    // sign the authdata using the site key
    status = piSitePrinc->Checksum(
        KERB_CHECKSUM_HMAC_MD5,
        KERB_PA_XBOX_SERVICE_ADDRESS_SALT,
        piReq->GetEncryptionTypes(),
        (PBYTE*) &pXenonAD,
        &ulXenonADSize,
        1,
        NULL,
        0,
        pXenonADWithSig->ServerSignature,
        &ulSignatureSize,
        NULL,
        pExtendedError
        );
    if ( !NT_SUCCESS(status) )
    {
        XomTrace(Xkdc,
            L_ERROR,
            "(%s:%d) AddCAuthData3ToTicket: Checksum failed with error %d.",
            __FILE__,
            __LINE__,
            status
            );
        goto Cleanup;
    }

    // update perfcounters
    if ( pPolicyData->bUseValidSite )
    {
        if ( pPolicyData->bMachineOnly )
        {
            g_Counters.IncrementValue32(XKDCPERF_SERVER_MACHINE_TICKETS, 1);
            g_Counters.IncrementValue32(XKDCPERF_SERVER_MACHINE_TICKETS_RATE, 1);
        }
        else
        {
            XOMASSERT( pXenonAD->users[0].qwUserID
                    || pXenonAD->users[1].qwUserID
                    || pXenonAD->users[2].qwUserID
                    || pXenonAD->users[3].qwUserID );

            XOMASSERT(
                   pPolicyData->users[0].qwUserID == pXenonAD->users[0].qwUserID
                && pPolicyData->users[1].qwUserID == pXenonAD->users[1].qwUserID
                && pPolicyData->users[2].qwUserID == pXenonAD->users[2].qwUserID
                && pPolicyData->users[3].qwUserID == pXenonAD->users[3].qwUserID );

            g_Counters.IncrementValue32(XKDCPERF_SERVER_USER_TICKETS, 1);
            g_Counters.IncrementValue32(XKDCPERF_SERVER_USER_TICKETS_RATE, 1);

            g_Counters.IncrementValue32(XKDCPERF_SERVER_USER_TICKETS_TOTAL_USERS, pPolicyData->dwUsers);
            g_Counters.IncrementValue64(XKDCPERF_SERVER_USERS_PER_TICKET_AVERAGE, pPolicyData->dwUsers);
            g_Counters.IncrementValue32(XKDCPERF_SERVER_USERS_PER_TICKET_BASE, 1);
        }
    }
    else
    {
        g_Counters.IncrementValue32(XKDCPERF_SERVER_INVALID_TICKETS, 1);
        g_Counters.IncrementValue32(XKDCPERF_SERVER_INVALID_TICKETS_RATE, 1);
    }

    // copy the signed Xbox authdata to the authdata return envelope
    pAuthData->next = *ppAuthData;
    //pAuthData->value.auth_data_type = GetADType();

    pAuthData->value.auth_data_type   = KERB_AUTH_DATA_XENON;
    pAuthData->value.auth_data.length = sizeof(*pXenonADWithSig);
    pAuthData->value.auth_data.value  = (PUCHAR) pXenonADWithSig;
    pXenonADWithSig = NULL;

    XomTrace( Xkdc,
        L_LOW,
        "(%s:%d) AddCAuthData3ToTicket: added Xenon authdata (%d bytes) to ticket.",
        __FILE__,
        __LINE__,
        pAuthData->value.auth_data.length
        );

    *ppAuthData = pAuthData;
    pAuthData = NULL;

Cleanup:
    if ( pAuthData )
    {
        m_pXkdc->KdcFreeMemory(pAuthData);
    }
    if ( pXenonADWithSig )
    {
        m_pXkdc->KdcFreeMemory(pXenonADWithSig);
    }
    pExtendedError->status = status;
    return KerbErr;
}

KERBERR __stdcall
CXboxADHandler::AddCAuthData4ToTicket(
    IN  IKerbRequest                *piReq,
    IN  XKDC_POLICY_DATA            *pPolicyData,
    IN  PIKerbPrincipal              piSitePrinc,
    OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
    OUT PKERB_EXT_ERROR              pExtendedError
    )
{
    KERBERR                         KerbErr = KDC_ERR_NONE;
    NTSTATUS                        status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA        pAuthData = NULL;
    PXKERB_AD_XENON2                pXenonAD2 = NULL;
    PXKERB_AD_XENON_WITH_SIGNATURE2 pXenonADWithSig2 = NULL;
    ULONG ulChecksumSize = 0;
    ULONG ulSignatureSize = 0;
    ULONG ulXenonADSize2 = 0;

    XOMASSERT( piReq );
    XOMASSERT( pPolicyData );
    XOMASSERT( ppAuthData );
    XOMASSERT( pExtendedError );

    // allocate space for our Xenon2-specific authdata
    pXenonADWithSig2 = (PXKERB_AD_XENON_WITH_SIGNATURE2) m_pXkdc->KdcAllocMemory(sizeof(*pXenonADWithSig2));
    if ( pXenonADWithSig2 == NULL )
    {
        XomNtEvent( XEVENT_XKDC_NO_MEMORY,
            "(%s:%d) AddCAuthData4ToTicket: failed to allocate %d bytes for XKERB_AD_XENON_WITH_SIGNATURE2.",
            __FILE__,
            __LINE__,
            sizeof(*pXenonADWithSig2)
            );

        status  = STATUS_NO_MEMORY;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }
    ZeroMemory(pXenonADWithSig2, sizeof(*pXenonADWithSig2));

    // allocate space for the authdata envelope
    pAuthData = (PKERB_AUTHORIZATION_DATA) m_pXkdc->KdcAllocMemory(sizeof(*pAuthData));
    if ( pAuthData == NULL )
    {
        XomNtEvent(XEVENT_XKDC_NO_MEMORY,
            "(%s:%d) AddCAuthData4ToTicket: failed to allocate %d bytes for KERB_AUTHORIZATION_DATA.",
            __FILE__,
            __LINE__,
            sizeof(*pAuthData)
            );

        status  = STATUS_NO_MEMORY;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }
    ZeroMemory(pAuthData, sizeof(*pAuthData));

    // TODO: make sure none of the policy check functions return a failure
    // status if a ticket still needs to be returned to the client

    // For internal errors such as memory allocation problems, we fail the
    // entire request and do not return a ticket.
    if ( KERB_SUCCESS(pPolicyData->KerbErr) && !NT_SUCCESS(pPolicyData->policyStatus) )
    {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // copy the authdata constructed by the service principal
    pXenonAD2 = &(pXenonADWithSig2->authData);
    pXenonAD2->wAuthDataVersion      = XONLINE_XENON2_AUTHDATA_VERSION;
    pXenonAD2->wAuthDataSize         = sizeof(*pXenonAD2);
    pXenonAD2->clientVersion         = pPolicyData->clientVersion;
    pXenonAD2->dwAuthDataFlags       = pPolicyData->dwAuthDataFlags;
    pXenonAD2->qwXboxID              = pPolicyData->qwXboxID;
    pXenonAD2->fltConsoleTrustFactor = pPolicyData->fltConsoleTrustFactor;
    pXenonAD2->dwTitleID             = pPolicyData->dwTitleID;
    pXenonAD2->dwTitleVersion        = pPolicyData->dwTitleVersion;
    pXenonAD2->dwTitleRegion         = pPolicyData->dwTitleRegion;
    pXenonAD2->dwConsoleRegion       = pPolicyData->dwConsoleRegion;
    pXenonAD2->dwMediaID             = pPolicyData->dwMediaID;
    pXenonAD2->wLanguageID           = pPolicyData->wLanguageID;
    pXenonAD2->wNumExtendedServices  = pPolicyData->wXenonNumDwordServices;
    memcpy(
        pXenonAD2->dwExtendedServices,
        pPolicyData->dwXenonServiceID,
        sizeof(pXenonAD2->dwExtendedServices)
        );

    for (DWORD u = 0; u < XONLINE_MAX_LOGON_USERS; ++u)
    {
        if ( 0 == pPolicyData->users[u].qwUserID)
        {
            continue;
        }
        pXenonAD2->users[u].qwUserID    = pPolicyData->users[u].qwUserID;
        pXenonAD2->users[u].dwUserFlags = pPolicyData->users[u].dwUserFlags;
        pXenonAD2->afltTrustFactor[u]   = pPolicyData->afltTrustFactor[u];
        memcpy(
            pXenonAD2->dwUserPrivileges[u],
            &pPolicyData->dwXenon2UserPrivileges[u][5],
            sizeof( pXenonAD2->dwUserPrivileges[u] )
            );
    }
    memcpy(
        pXenonAD2->dwBaseServices,
        pPolicyData->dwXenonPrivileges,
        sizeof(pXenonAD2->dwBaseServices)
        );
    memcpy(
        pXenonAD2->dwMachinePrivileges,
        &pPolicyData->dwXenonPrivileges[4],
        sizeof(pXenonAD2->dwMachinePrivileges)
        );
    memcpy(
        pXenonAD2->dwAltTitleID,
        pPolicyData->dwAltTitleID,
        sizeof(pXenonAD2->dwAltTitleID)
        );

    pXenonAD2->flowToken = pPolicyData->flowToken;

    // copy signing key to Xenon authdata
    C_ASSERT(sizeof(pXenonAD2->abKey) == sizeof(pPolicyData->abKey));
    memcpy(pXenonAD2->abKey, pPolicyData->abKey, sizeof(pXenonAD2->abKey));

    // find the size of the signature buffer
    ulSignatureSize = sizeof(pXenonADWithSig2->ServerSignature);

    // get the checksum size
    status = piSitePrinc->GetChecksumSize(
        KERB_CHECKSUM_HMAC_MD5,
        &ulChecksumSize
        );
    if ( !NT_SUCCESS(status) )
    {
        XomTrace(Xkdc,
            L_ERROR,
            "(%s:%d) AddCAuthData4ToTicket: GetChecksumSize failed with status %d.",
            __FILE__,
            __LINE__,
            status
            );
        goto Cleanup;
    }

    // the checksum size must fit into our authdata struct
    XOMASSERT( ulChecksumSize <= ulSignatureSize );

    if ( ulChecksumSize > ulSignatureSize )
    {
        XomNtEvent( XEVENT_XKDC_CHECKSUM_OVERFLOW,
            "(%s:%d) AddCAuthData4ToTicket: HMAC_MD5 checksum (%d bytes) too large for structure (%d bytes).",
            __FILE__,
            __LINE__,
            ulChecksumSize,
            ulSignatureSize);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // Grab the size that we will be signing
    ulXenonADSize2 = sizeof(*pXenonAD2);

    // sign the authdata using the site key
    status = piSitePrinc->Checksum(
        KERB_CHECKSUM_HMAC_MD5,
        KERB_PA_XBOX_SERVICE_ADDRESS_SALT,
        piReq->GetEncryptionTypes(),
        (PBYTE*) &pXenonAD2,
        &ulXenonADSize2,
        1,
        NULL,
        0,
        pXenonADWithSig2->ServerSignature,
        &ulSignatureSize,
        NULL,
        pExtendedError
        );
    if ( !NT_SUCCESS(status) )
    {
        XomTrace(Xkdc,
            L_ERROR,
            "(%s:%d) AddCAuthData4ToTicket: Checksum failed with error %d.",
            __FILE__,
            __LINE__,
            status
            );
        goto Cleanup;
    }

    // update perfcounters
    if ( pPolicyData->bUseValidSite )
    {
        if ( pPolicyData->bMachineOnly )
        {
            g_Counters.IncrementValue32(XKDCPERF_SERVER_MACHINE_TICKETS, 1);
            g_Counters.IncrementValue32(XKDCPERF_SERVER_MACHINE_TICKETS_RATE, 1);
        }
        else
        {
            XOMASSERT( pXenonAD2->users[0].qwUserID
                    || pXenonAD2->users[1].qwUserID
                    || pXenonAD2->users[2].qwUserID
                    || pXenonAD2->users[3].qwUserID );

            XOMASSERT(
                   pPolicyData->users[0].qwUserID == pXenonAD2->users[0].qwUserID
                && pPolicyData->users[1].qwUserID == pXenonAD2->users[1].qwUserID
                && pPolicyData->users[2].qwUserID == pXenonAD2->users[2].qwUserID
                && pPolicyData->users[3].qwUserID == pXenonAD2->users[3].qwUserID );

            g_Counters.IncrementValue32(XKDCPERF_SERVER_USER_TICKETS, 1);
            g_Counters.IncrementValue32(XKDCPERF_SERVER_USER_TICKETS_RATE, 1);

            g_Counters.IncrementValue32(XKDCPERF_SERVER_USER_TICKETS_TOTAL_USERS, pPolicyData->dwUsers);
            g_Counters.IncrementValue64(XKDCPERF_SERVER_USERS_PER_TICKET_AVERAGE, pPolicyData->dwUsers);
            g_Counters.IncrementValue32(XKDCPERF_SERVER_USERS_PER_TICKET_BASE, 1);
        }
    }
    else
    {
        g_Counters.IncrementValue32(XKDCPERF_SERVER_INVALID_TICKETS, 1);
        g_Counters.IncrementValue32(XKDCPERF_SERVER_INVALID_TICKETS_RATE, 1);
    }

    // copy the signed Xbox authdata to the authdata return envelope
    pAuthData->next = *ppAuthData;
    //pAuthData->value.auth_data_type = GetADType();

    pAuthData->value.auth_data_type = KERB_AUTH_DATA_XENON2;
    pAuthData->value.auth_data.length = sizeof(*pXenonADWithSig2);
    pAuthData->value.auth_data.value = (PUCHAR) pXenonADWithSig2;
    pXenonADWithSig2 = NULL;

    XomTrace(Xkdc,
        L_LOW,
        "(%s:%d) AddCAuthData4ToTicket: added Xenon2 authdata (%d bytes) to ticket.",
        __FILE__,
        __LINE__,
        pAuthData->value.auth_data.length
        );

    *ppAuthData = pAuthData;
    pAuthData = NULL;


Cleanup:
    if ( pAuthData )
    {
        m_pXkdc->KdcFreeMemory(pAuthData);
    }
    if ( pXenonADWithSig2 )
    {
        m_pXkdc->KdcFreeMemory(pXenonADWithSig2);
    }
    pExtendedError->status = status;
    return KerbErr;

}

KERBERR __stdcall
CXboxADHandler::AddToTicket(
    IN  IKerbRequest                *piReq,
    OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
    OUT PKERB_EXT_ERROR              pExtendedError)
{
    XOMASSERT( piReq );
    XOMASSERT( ppAuthData );
    XOMASSERT( pExtendedError );

    // validate all parameters
    if ( NULL == piReq ||
         NULL == ppAuthData ||
         NULL == pExtendedError )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER,
            "(%s:%d) AddToTicket: invalid parameter.",
            __FILE__,
            __LINE__
            );

        return KDC_ERR_SVC_UNAVAILABLE;
    }

    NTSTATUS status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;

    // only return authdata for requests in the XBOX.COM realm
    const KERB_KDC_REQUEST *pKdcReq = piReq->GetKdcRequest();
    if ( 0 != _stricmp( pKdcReq->request_body.realm, XBOX_KERBEROS_REALM ) )
    {
        return KerbErr;
    }

    if ( KerbAs == piReq->GetServId() )
    {
        // TODO: XBOX.COM should never get AS requests.  Log an event here?
        return KerbErr;
    }

    // used to access auth data and policy data generated during policy checks
    IPAXboxRequest           *piXboxReq = NULL;
    PKERB_AUTHORIZATION_DATA  pAuthData = NULL;
    XKDC_POLICY_DATA         *pPolicyData = NULL;
    PIKerbPrincipal           piSitePrinc = NULL;

    // find our Xbox-specific preauth data handler
    status = piReq->GetPAHandler(IID_IPAXboxRequest, (PVOID*)&piXboxReq);
    if ( !NT_SUCCESS(status) || (NULL == piXboxReq) )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_1,
            "(%s:%d) AddToTicket: failed to acquire valid IPAXboxRequest interface.",
            __FILE__,
            __LINE__
            );

        status  = STATUS_INVALID_PARAMETER;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // find the data generated by the policy checks
    status = piXboxReq->GetPolicyData(&pPolicyData);
    if ( !NT_SUCCESS(status) || (NULL == pPolicyData) )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_2,
            "(%s:%d) AddToTicket: no XKDC_POLICY_DATA found.",
            __FILE__,
            __LINE__
            );

        status  = STATUS_INVALID_PARAMETER;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // if we get a version other than 2 or 3, or 4, default to 3 but raise an event
    if ( pPolicyData->wAuthDataVersion != XONLINE_AUTHDATA_VERSION &&
         pPolicyData->wAuthDataVersion != XONLINE_XENON_AUTHDATA_VERSION &&
         pPolicyData->wAuthDataVersion != XONLINE_XENON2_AUTHDATA_VERSION)
    {
        if (pPolicyData->bUseValidSite)
        {
            XomNtEvent( XEVENT_KDC_CONFIG_32,
                "(%s:%d) AddToTicket: unexpected authdata version: %d specified for siteid. Using version %d instead.",
                __FILE__,
                __LINE__,
                pPolicyData->wAuthDataVersion,
                XONLINE_XENON_AUTHDATA_VERSION);
        }

        // It's important to default to version 3 and not version 4 -- this is the case 
        // for every service being invalid and the KDC returning a "bogus" ticket -- 
        // because of the packet size constraints with authdata v4 and the older preauth 
        // (v4, it has been called).  
        pPolicyData->wAuthDataVersion = XONLINE_XENON_AUTHDATA_VERSION;
    }

    // spew some authdata information
    XomTrace( Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: wAuthDataVersion: %d",
        __FILE__, __LINE__,
        pPolicyData->wAuthDataVersion
        );
    XomTrace(  Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: dwTitleID: 0x%08X",
        __FILE__, __LINE__,
        pPolicyData->dwTitleID
        );
    XomTrace( Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: dwTitleVersion: 0x%08X",
        __FILE__, __LINE__,
        pPolicyData->dwTitleVersion
        );
    XomTrace(
        Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: dwTitleRegion: 0x%08X",
        __FILE__, __LINE__,
        pPolicyData->dwTitleRegion
        );
    XomTrace(
        Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: dwConsoleRegion: 0x%08X",
        __FILE__, __LINE__,
        pPolicyData->dwConsoleRegion
        );
    XomTrace(
        Xkdc, L_LOW,
        "(%s:%d) AddToTicket: dwMediaID: 0x%08X",
        __FILE__, __LINE__,
        pPolicyData->dwMediaID
        );
    XomTrace(
        Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: wLanguageID: %d",
        __FILE__, __LINE__,
        pPolicyData->wLanguageID
        );
    XomTrace(
        Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: dwAuthDataFlags: 0x%08X",
        __FILE__, __LINE__,
        pPolicyData->dwAuthDataFlags
        );
    XomTrace(
        Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: wNumPrivileges: %d",
        __FILE__, __LINE__,
        pPolicyData->wNumPrivileges
        );
    XomTrace(
        Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: dwBaseServices[]: 0x%08X %08X %08X %08X ",
        __FILE__, __LINE__,
        pPolicyData->dwXenonPrivileges[0],
        pPolicyData->dwXenonPrivileges[1],
        pPolicyData->dwXenonPrivileges[2],
        pPolicyData->dwXenonPrivileges[3]
        );
    XomTrace(
        Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: dwMachinePrivileges[]: 0x%08X",
        __FILE__, __LINE__,
        pPolicyData->dwXenonPrivileges[4]
        );
    XomTrace(
        Xkdc,
        L_LOW,
        "(%s:%d) AddToTicket: qwXboxID: 0x%016I64X",
        __FILE__, __LINE__,
        pPolicyData->qwXboxID
        );
    if (pPolicyData->users[0].qwUserID != 0)
    {
        XomTrace(
            Xkdc,
            L_LOW,
            "(%s:%d) AddToTicket: users[0]: 0x%016I64X 0x%08X %08X %08X %08X",
            __FILE__, __LINE__,
            pPolicyData->users[0].qwUserID,
            pPolicyData->users[0].dwUserFlags,
            pPolicyData->dwXenon2UserPrivileges[0][5],
            pPolicyData->dwXenon2UserPrivileges[0][6],
            pPolicyData->dwXenon2UserPrivileges[0][7]
            );
    }
    if (pPolicyData->users[1].qwUserID != 0)
    {
        XomTrace(
            Xkdc,
            L_LOW,
            "(%s:%d) AddToTicket: users[1]: 0x%016I64X 0x%08X %08X %08X %08X",
            __FILE__, __LINE__,
            pPolicyData->users[1].qwUserID,
            pPolicyData->users[1].dwUserFlags,
            pPolicyData->dwXenon2UserPrivileges[1][5],
            pPolicyData->dwXenon2UserPrivileges[1][6],
            pPolicyData->dwXenon2UserPrivileges[1][7]
            );
    }
    if (pPolicyData->users[2].qwUserID != 0)
    {
        XomTrace(
            Xkdc,
            L_LOW,
            "(%s:%d) AddToTicket: users[2]: 0x%016I64X 0x%08X %08X %08X %08X",
            __FILE__, __LINE__,
            pPolicyData->users[2].qwUserID,
            pPolicyData->users[2].dwUserFlags,
            pPolicyData->dwXenon2UserPrivileges[2][5],
            pPolicyData->dwXenon2UserPrivileges[2][6],
            pPolicyData->dwXenon2UserPrivileges[2][7]
            );
    }
    if (pPolicyData->users[3].qwUserID != 0)
    {
        XomTrace(
            Xkdc,
            L_LOW,
            "(%s:%d) AddToTicket: users[3]: 0x%016I64X 0x%08X %08X %08X %08X",
            __FILE__, __LINE__,
            pPolicyData->users[3].qwUserID,
            pPolicyData->users[3].dwUserFlags,
            pPolicyData->dwXenon2UserPrivileges[3][5],
            pPolicyData->dwXenon2UserPrivileges[3][6],
            pPolicyData->dwXenon2UserPrivileges[3][7]
            );
    }

    // get the site principal
    piSitePrinc = piReq->GetIPrincService();
    XOMASSERT( piSitePrinc );
    if ( NULL == piSitePrinc )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_4, "(%s:%d) AddToTicket: failed to get service principal from IKerbRequest.", __FILE__, __LINE__);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // Call the correct worker function
    if ( pPolicyData->wAuthDataVersion == XONLINE_AUTHDATA_VERSION)
    {
        return AddCAuthData2ToTicket(
            piReq,
            pPolicyData,
            piSitePrinc,
            ppAuthData,
            pExtendedError
            );
    }
    if ( pPolicyData->wAuthDataVersion == XONLINE_XENON_AUTHDATA_VERSION)
    {
        return AddCAuthData3ToTicket(
            piReq,
            pPolicyData,
            piSitePrinc,
            ppAuthData,
            pExtendedError
            );
    }
    if ( pPolicyData->wAuthDataVersion == XONLINE_XENON2_AUTHDATA_VERSION)
    {
        return AddCAuthData4ToTicket(
            piReq,
            pPolicyData,
            piSitePrinc,
            ppAuthData,
            pExtendedError
            );
    }

Cleanup:

    pExtendedError->status = status;
    return KerbErr;
};


CXboxADHandlerFactory::CXboxADHandlerFactory(IN CXkdcProvider *pXkdc) :
    m_ADHandler(pXkdc)
{
}


NTSTATUS
CXboxADHandlerFactory::CreateInstance(
    IN  IKerbRequest    *piReq,
    OUT IADHandler      **ppIADHandler)
{
    XOMASSERT( ppIADHandler );
    if ( NULL == ppIADHandler )
    {
        return STATUS_INVALID_PARAMETER_2;
    }

    *ppIADHandler = static_cast<IADHandler*>(&m_ADHandler);
    return STATUS_SUCCESS;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcDb.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// XkdcDb.cpp
//
// Database stuff for Xkdc. This is a lightweight class that wraps the database
// functionality for the Xkdc. It will feed the DB data into a lovely intermediate
// structure, XKDCDB_AUTHORIZATION_DATA, which should help simplify interdependencies.
//
// Usage:
//
// CXkdcDb db(_pXkdc);
// XKDCDB_AUTHORIZATION_DATA dbData;
// dbData.Reset();
// db.GetMachineAuthorization(...);
// db.GetXenonUserAuthorization(...);
//
// I've tried to minimize the number of input parameters. It could still be better.
// --------------------------------------------------------------------------------------

#include "xkdc.h"
#include "XkdcDb.h"

#include "ManagedProxyMemory.h"

XomImportArea(Policy);
XomImportArea(Xkdc);

#define CHECK_HR(x) \
    if(FAILED(hr = (x))) { \
        if (perror) { \
            perror->Format("%s failed at %s:%u. Hr=0x%08X, Operation:\n%s", __FUNCTION__, __FILE__, __LINE__, hr, #x ); \
        } \
        XomTrace( Policy, L_ERROR, "%s failed at %s:%u. Hr=0x%08X, Operation:\n%s", __FUNCTION__, __FILE__, __LINE__, hr, #x ); \
        status = GetAuthorizationFailed; \
        goto Exit; \
    }

// the number of interval values to determine the trust star rating.
#define XKDC_NUMBER_TITLE_TRUST_RATIOS 8

// local function used to calculate ratings
void CalculateRating( float fUserAvg, float fCumulativeAvg, BYTE *pabIntervals, DWORD *pdwRating );


BOOL
XKDCDB_USER_AUTHORIZATION_DATA::AddPrivilege(DWORD dwPrivilegeId)
{
    if (dwPrivilegeId >= XONLINE_MAX_PRIVILEGE_ID)
    {
        return FALSE;
    }

    DWORD dwordIndex = dwPrivilegeId / 32;
    DWORD bitIndex = dwPrivilegeId % 32;
    DWORD dwMask = 1L << bitIndex;

    Privileges[dwordIndex] |= dwMask;
    return TRUE;
}

BOOL
XKDCDB_AUTHORIZATION_DATA::FindByteService(
    BYTE bServiceId,
    XKDCDB_BYTE_SERVICE **ppSvc)
{
    XOMASSERT(ppSvc);
    XOMASSERT(bServiceId < 256);

    DWORD dwMaxSvc = ARRAYSIZE(ByteServices);
    for (DWORD i = 0; i < dwMaxSvc; i++)
    {
        if (ByteServices[i].bServiceId == bServiceId)
        {
            *ppSvc = &ByteServices[i];
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
XKDCDB_AUTHORIZATION_DATA::FindDwordService(
    DWORD dwServiceId,
    XKDCDB_DWORD_SERVICE **ppSvc)
{
    XOMASSERT(ppSvc);
    XOMASSERT(dwServiceId >= XONLINE_MAX_PRIVILEGE_ID);

    DWORD dwMaxSvc = ARRAYSIZE(DwordServices);
    for (DWORD i = 0; i < dwMaxSvc; i++)
    {
        if (DwordServices[i].dwServiceId == dwServiceId)
        {
            *ppSvc = &DwordServices[i];
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
XKDCDB_AUTHORIZATION_DATA::AddService(
    DWORD dwServiceId,
    DWORD dwSubscriptionStatusID)
{
    // Divide into single-byte service ids and DWORD service ids
    if (dwServiceId < XONLINE_MAX_PRIVILEGE_ID)
    {
        XOMASSERT(dwServiceId < 256);
        XKDCDB_BYTE_SERVICE *pSvc = NULL;
        if (FindByteService((BYTE)dwServiceId, &pSvc))
        {
            // Already exists. If some other user didn't get authorized for the
            // service, then we can't mark this one. And we only mark this one if
            // the user actually is subscribed (1).
            XOMASSERT(pSvc != NULL);
            if (dwSubscriptionStatusID == 1)
            {
                pSvc->bNumSubscriptions++;
            }
        }
        else
        {
            // New service. Gets subscription if status is 1 (APPROVED).
            if (NumByteServices >= ARRAYSIZE(ByteServices))
            {
                return FALSE;
            }
            pSvc = &ByteServices[NumByteServices];
            pSvc->bServiceId = (BYTE)dwServiceId;
            if (dwSubscriptionStatusID == 1)
            {
                pSvc->bNumSubscriptions++;
            }
            NumByteServices++;
        }
    }
    else
    {
        // This is a DWORD service
        XOMASSERT(dwServiceId >= XONLINE_MAX_PRIVILEGE_ID);
        XKDCDB_DWORD_SERVICE *pSvc = NULL;
        if (FindDwordService(dwServiceId, &pSvc))
        {
            // Already exists. If some other user didn't get authorized for the
            // service, then we can't mark this one. And we only mark this one if
            // the user actually is subscribed (1).
            XOMASSERT(pSvc != NULL);
            if (dwSubscriptionStatusID == 1)
            {
                pSvc->bNumSubscriptions++;
            }
        }
        else
        {
            // New service. Gets subscription if status is 1 (APPROVED).
            if (NumDwordServices == ARRAYSIZE(DwordServices))
            {
                return FALSE;
            }
            pSvc = &DwordServices[NumDwordServices];
            pSvc->dwServiceId = dwServiceId;
            if (dwSubscriptionStatusID == 1)
            {
                pSvc->bNumSubscriptions++;
            }
            NumDwordServices++;
        }
    }
    return TRUE;
}

BOOL
XKDCDB_AUTHORIZATION_DATA::FindServiceByIdx(
    DWORD dwIdx,
    OUT DWORD* pdwServiceId,
    OUT DWORD* pdwNumSubscriptions)
{
    XOMASSERT(pdwServiceId);
    XOMASSERT(pdwNumSubscriptions);

    if (dwIdx < NumByteServices)
    {
        *pdwServiceId = ByteServices[dwIdx].bServiceId;
        *pdwNumSubscriptions = ByteServices[dwIdx].bNumSubscriptions;
    }
    else if ((dwIdx - NumByteServices) < NumDwordServices)
    {
        DWORD dwDwordIdx = (dwIdx - NumByteServices);
        XOMASSERT(NumDwordServices <= ARRAYSIZE(DwordServices));
        XOMASSERT(dwDwordIdx < NumDwordServices);
        *pdwServiceId = DwordServices[dwDwordIdx].dwServiceId;
        *pdwNumSubscriptions = DwordServices[dwDwordIdx].bNumSubscriptions;
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

DWORD
XKDCDB_AUTHORIZATION_DATA::GetNumSubscriptionsToService(
    DWORD dwServiceId)
{
    if (dwServiceId < XONLINE_MAX_PRIVILEGE_ID)
    {
        XKDCDB_BYTE_SERVICE *pSvc = NULL;
        if (FindByteService((BYTE)dwServiceId, &pSvc))
        {
            XOMASSERT(pSvc != NULL);
            return pSvc->bNumSubscriptions;
        }
    }
    else
    {
        XKDCDB_DWORD_SERVICE *pSvc = NULL;
        if (FindDwordService(dwServiceId, &pSvc))
        {
            XOMASSERT(pSvc != NULL);
            return pSvc->bNumSubscriptions;
        }
    }
    return 0;
}

BOOL
XKDCDB_AUTHORIZATION_DATA::IsServicePresent(
    DWORD dwServiceId)
{
    if (dwServiceId < XONLINE_MAX_PRIVILEGE_ID)
    {
        XKDCDB_BYTE_SERVICE *pSvc = NULL;
        return FindByteService((BYTE)dwServiceId, &pSvc);
    }
    else
    {
        XKDCDB_DWORD_SERVICE *pSvc = NULL;
        return FindDwordService(dwServiceId, &pSvc);
    }
}

BOOL
XKDCDB_AUTHORIZATION_DATA::FindUserDataByIdx(
    DWORD dwUserIndex,
    OUT XKDCDB_USER_AUTHORIZATION_DATA** ppUserData)
{
    XOMASSERT(ppUserData);

    if (dwUserIndex >= ARRAYSIZE(UserData))
        return FALSE;

    *ppUserData = &UserData[dwUserIndex];
    return TRUE;
}

BOOL
XKDCDB_AUTHORIZATION_DATA::HasExpired(
    DWORD dwLifetimeInSeconds)
{
    UINT64 ftnow;
    C_ASSERT(sizeof(LastRefreshTime) == sizeof(FILETIME));
    GetSystemTimeAsFileTime((FILETIME*)&ftnow);

    // FILETIME contains 100-nano-seconds
    UINT64 diffsec = (ftnow - LastRefreshTime) / 10000000;

    return dwLifetimeInSeconds < diffsec;
}

BOOL
XKDCDB_AUTHORIZATION_DATA::StillValid(
    DWORD dwLifetimeInSeconds,
    DWORD dwTitleId,
    ULONGLONG qwMachineId,
    ULONGLONG qwUserId1,
    ULONGLONG qwUserId2,
    ULONGLONG qwUserId3,
    ULONGLONG qwUserId4,
    DWORD *adwServiceID,
    DWORD dwNumServices)
{
    XKDCDB_USER_AUTHORIZATION_DATA *pUserData;
    BOOL fOk = TRUE;

    fOk = fOk && !HasExpired(dwLifetimeInSeconds);
    fOk = fOk && (TitleId == dwTitleId);
    fOk = fOk && (MachineData.MachineId == qwMachineId);

    fOk = fOk && FindUserDataByIdx(0, &pUserData);
    fOk = fOk && (pUserData->UserId == qwUserId1);
    fOk = fOk && FindUserDataByIdx(1, &pUserData);
    fOk = fOk && (pUserData->UserId == qwUserId2);
    fOk = fOk && FindUserDataByIdx(2, &pUserData);
    fOk = fOk && (pUserData->UserId == qwUserId3);
    fOk = fOk && FindUserDataByIdx(3, &pUserData);
    fOk = fOk && (pUserData->UserId == qwUserId4);

    //
    // Special case note: if the user makes a request for some services, then makes a
    // subsequent request for services that aren't part of the original set, then our
    // cache data is invalid. Imagine a client asking for service 1. Then it asks for
    // service 6. This would fail normally, because service 6 isn't in our cache data at
    // all. The solution is to detect when a client requests services that aren't even
    // present in the cache data, and if so, mark the cache as invalid.
    //
    // This is a very special case and *should* only apply in negative test scenarios. If
    // we ever see this in production, there is something odd going on.
    //

    // Bail out early
    if (!fOk)
        return fOk;

    for (DWORD svcIndex = 0; svcIndex < dwNumServices; svcIndex++)
    {
        DWORD dwServiceID = adwServiceID[svcIndex];
        if (!IsServicePresent(dwServiceID))
        {
            fOk = FALSE;
            break;
        }
    }

    return fOk;
}

// ------------------------------------------------------------
// CXkdcDb class
//
// Handles retrieving data from the database and funneling it into an intermediary object.
// ------------------------------------------------------------

typedef CKdcAutoPtr<XkdcUserAuthorizationAndPrivileges_2> CXkdcUserAuthorizationAndPrivileges_2AutoPtr;
CXkdcDb::GetAuthorizationStatus
CXkdcDb::GetXenonUserAuthorization(
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    IN DWORD dwUserIndex,
    IN ULONGLONG qwMachineId,
    IN DWORD dwTitleId,
    IN BOOL fCheckLimitedMac,
    IN DWORD dwPlatformType,
    OUT XKDCDB_AUTHORIZATION_DATA* dbData,
    OUT CStr* perror)
{
    XOMASSERT(pServiceRequest && dbData && perror);
    UNREFERENCED_PARAMETER(qwMachineId);

    HRESULT                 hr;
    GetAuthorizationStatus  status = GetAuthorizationFailed;
    XKDCDB_USER_AUTHORIZATION_DATA* dbUserData;


    XkdcUserAuthorizationAndPrivileges_1 userAuthorizationAndPrivileges_1 = {0};

    XkdcUserAuthorizationAndPrivileges_2 * pUserAuthorizationAndPrivileges_2 = NULL;
    unsigned long cUserAuthorizationAndPrivileges_2 = 0;
    CXkdcUserAuthorizationAndPrivileges_2AutoPtr autoPtrUserAuthorizationAndPrivileges_2(&pUserAuthorizationAndPrivileges_2, &cUserAuthorizationAndPrivileges_2);
    XkdcUserAuthorizationAndPrivileges_3 userAuthorizationAndPrivileges_3 = {0};
    CComSafeArray<DWORD> saSvcIds(XONLINE_MAX_BASE_SERVICES_ID + XONLINE_MAX_DWORD_SERVICEIDS);

    FILETIME PasswordResetTime = {0};
    FILETIME AccountResumeDate = {0};
    FILETIME LastSignoutDate   = {0};

    if (!dbData->FindUserDataByIdx(dwUserIndex, &dbUserData))
    {
        perror->Format("Unable to find XKDCDB_USER_AUTHORIZATION_DATA in dbData");
        goto Exit;
    }

    //
    // Do the database call
    //
    ZeroMemory(saSvcIds.m_psa->pvData, sizeof(DWORD)*saSvcIds.GetCount());
    memcpy(saSvcIds.m_psa->pvData, pServiceRequest->dwServiceID, sizeof(DWORD)*__min(pServiceRequest->dwNumServices, saSvcIds.GetCount()));

    hr = _pXkdc->GetManagedProxy()->XkdcGetUserAuthorizationAndPrivileges(
        pServiceRequest->qwUserID[dwUserIndex],
        qwMachineId,
        dwTitleId,
        pServiceRequest->wAutoDiscoverServices != 0,
        saSvcIds,
        fCheckLimitedMac ? 1 : 0,
        dwPlatformType,
        &userAuthorizationAndPrivileges_1,
        &pUserAuthorizationAndPrivileges_2,
        &cUserAuthorizationAndPrivileges_2,
        &userAuthorizationAndPrivileges_3);

    if (FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            status = GetAuthorizationBusy;
        }

        perror->Format("GetXenonUserAuthorization, hr=0x%08X", hr);
        goto Exit;
    }

    if (!userAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.IsDataPresent)
    {
        perror->Format("GetXenonUserAuthorization returned no results for user 0x%016I64X.",  pServiceRequest->qwUserID[dwUserIndex]);
        status = GetAuthorizationNotFound;
        goto Exit;
    }


    //
    // Rowset 1
    //
    // The first rowset contains the ticket flags, and country id, and more. The stored
    // proc returns things as 'int' (DWORD) for the most part, and our intermediary class
    // tries to save bytes. This is why we can't load directly into it.
    //

    // Rowset 1 temp fields
    DWORD dwCountryID = userAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.CountryId;
    
    DWORD dwTierID = userAuthorizationAndPrivileges_1.TierId;

    if (dwTierID > XONLINE_USER_TIER_MAXIMUM) 
    {
        perror->Format("GetXenonUserAuthorization returned invalid tier id, %d", dwTierID);
        status = GetAuthorizationFailed;
        goto Exit;
    }
    
    DWORD dwTicketFlags = userAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.TicketFlags;
    DWORD dwAcceptedTOS = userAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.AcceptedTos;
    DWORD dwBillingAcctStatus = userAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.BillingAccountStatus;
    DWORD dwVoiceBanned = userAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.VoiceBanned;
    DWORD dwAcctSuspended = userAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.AccountSuspended;
    DWORD dwNameChangeRequired = userAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.NameChangeRequired;
    DATE datePasswordResetTime = userAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.PasswordResetTime;
    CHECK_HR(GetFILETIMEFromDATE( datePasswordResetTime, &PasswordResetTime ));
    DWORD dwIsLimitedMachine = userAuthorizationAndPrivileges_1.LimitedMachine;
    DWORD dwIsInvalidUserPassport = IS_XENON_MACHINE_PUID(qwMachineId) ? userAuthorizationAndPrivileges_1.InvalidUserPassport : 0;
    DWORD dwIsInvalidOwnerPassport = IS_XENON_MACHINE_PUID(qwMachineId) ? userAuthorizationAndPrivileges_1.InvalidOwnerPassport : 0;
    DWORD dwActivationRequired = userAuthorizationAndPrivileges_1.ActivationRequired;
    DATE dateAccountResumeDate = userAuthorizationAndPrivileges_1.AccountResumeDate;
    CHECK_HR(GetFILETIMEFromDATE( dateAccountResumeDate, &AccountResumeDate ));
    DWORD dwUserMachineTrustLevel = userAuthorizationAndPrivileges_1.UserMachineTrustLevel;
    DATE dateLastSignoutDate = userAuthorizationAndPrivileges_1.LastSignoutDate;
    DWORD dwMaxTicketLifetimeSecs = userAuthorizationAndPrivileges_1.MaxTicketLifetimeSecs;
    DWORD dwBlockedByCurfew = userAuthorizationAndPrivileges_1.BlockedByCurfew;
    CHECK_HR(GetFILETIMEFromDATE( dateLastSignoutDate, &LastSignoutDate ));

    XomTrace(Policy, L_LOW, "GetXenonUserAuthorization: dwTicketFlags=0x%08X, dwCountryID=%d, dwAcceptedTOS=%d, dwVoiceBanned=%d, dwAcctSuspended=%d, dwBillingAcctStatus=%d, dwNameChangeRequired=%d, dwTierID=%d, dwIsLimitedMachine=%d, dwIsInvalidUserPassport=%d, dwIsInvalidOwnerPassport=%d, Activation=%d UserMachineTrustLevel=%d dwMaxTicketLifetimeSecs=%d dwBlockedByCurfew=%d",
        dwTicketFlags,
        dwCountryID,
        dwAcceptedTOS,
        dwVoiceBanned,
        dwAcctSuspended,
        dwBillingAcctStatus,
        dwNameChangeRequired,
        dwTierID,
        dwIsLimitedMachine,
        dwIsInvalidUserPassport,
        dwIsInvalidOwnerPassport,
        dwActivationRequired,
        dwUserMachineTrustLevel,
        dwMaxTicketLifetimeSecs,
        dwBlockedByCurfew
        );

    // funnel into dbData
    dbUserData->UserId = pServiceRequest->qwUserID[dwUserIndex];
    dbUserData->TicketFlags = (WORD)dwTicketFlags;
    dbUserData->CountryID = (BYTE)dwCountryID;
    dbUserData->AcceptedTOS = dwAcceptedTOS;
    dbUserData->VoiceBanned = dwVoiceBanned;
    dbUserData->AcctSuspended = dwAcctSuspended;
    dbUserData->BillingAcctStatusFailed = FAILED(dwBillingAcctStatus);
    dbUserData->NameChangeRequired = dwNameChangeRequired;
    dbUserData->PasswordResetDate = PasswordResetTime;
    dbUserData->TierID = dwTierID & 0xF;  // only low 4 bits used
    dbUserData->LimitedMachine = dwIsLimitedMachine;
    dbUserData->InvalidUserPassport = dwIsInvalidUserPassport;
    dbUserData->InvalidOwnerPassport = dwIsInvalidOwnerPassport;
    dbUserData->ActivationRequired = dwActivationRequired;
    dbUserData->AccountResumeDate = AccountResumeDate;
    dbUserData->UserMachineTrustLevel = dwUserMachineTrustLevel;
    dbUserData->LastSignoutDate = LastSignoutDate;
    dbUserData->MaxTicketLifetimeSecs = dwMaxTicketLifetimeSecs;
    dbUserData->BlockedByCurfew = dwBlockedByCurfew;

    //
    // Rowset 2
    //
    // The second result set contains a list of requested services
    // and a status flag indicating whether the user has a valid
    // subscription to an offer providing that service.

    if (cUserAuthorizationAndPrivileges_2 == 0)
    {
        perror->Format("Second result set is not present, this is fatal.");
        goto Exit;
    }

    for (unsigned int idx = 0; idx < cUserAuthorizationAndPrivileges_2; ++idx)
    {
        DWORD dwServiceID = pUserAuthorizationAndPrivileges_2[idx].UserAuthorizationXbox1_2.ServiceId;
        DWORD dwSubscriptionStatusID = pUserAuthorizationAndPrivileges_2[idx].UserAuthorizationXbox1_2.SubscriptionStatusId;
        DWORD fIsService = pUserAuthorizationAndPrivileges_2[idx].IsService;

        // Do some sanity checks
        // Same order as request?
        // Too many dword services?

        if (fIsService && !pServiceRequest->wAutoDiscoverServices )
        {
            // the service ids should come back in the order they were sent
            XOMASSERT( dwServiceID == pServiceRequest->dwServiceID[idx] );
            if ( dwServiceID != pServiceRequest->dwServiceID[idx] )
            {
                perror->Format("Service id mismatch from p_signin_get_user_authorization. "
                               "Result-index: %u, Returned: 0x%x, Expected: 0x%x. ",
                               idx, dwServiceID, pServiceRequest->dwServiceID[idx]);
                goto Exit;
            }
        }

        if (fIsService)
        {
            // This is a service. It may be a single byte service or a DWORD service. This
            // helper function will abstract that away for us.
            if (!dbData->AddService(dwServiceID, dwSubscriptionStatusID))
            {
                perror->Format("Too many services returned from p_signin_get_user_authorization. "
                               "Failed to add service id %u", dwServiceID);
                goto Exit;
            }
        }
        else
        {
            // This is a privilege. Set the appropriate bit.
            if (!dbUserData->AddPrivilege(dwServiceID))
            {
                perror->Format("Invalid privilege returned from p_signin_get_user_authorization. "
                               "Failed to add privilege id %u", dwServiceID);
                goto Exit;
            }
        }
    }


    //
    // Rowset 3
    //
    // This should be a single row containing the trust rating factor for the user. The
    // row may be empty, which is ok.
    //

    FLOAT fTrustFactor = 0.0;
    DWORD dwDiscntRating = 0;
    DWORD dwNoShwRating = 0;

    FLOAT fCollectiveSessionDiscnntAvg = 0.0;
    FLOAT fSessionDisconntAvg = 0.0;
    FLOAT fCollectiveNoShowAvg = 0.0;
    FLOAT fNoShowAvg = 0.0;
    BYTE  abytTitleSessionDiscntRatios[XKDC_NUMBER_TITLE_TRUST_RATIOS];


    //userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3

    if (!userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3.IsDataSetPresent)
    {
        perror->Format("Third result set is not present, this is fatal.");
        goto Exit;
    }

    if (!userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3.IsDataPresent)
    {
        XomTrace(
            Xkdc,
            L_WARNING,
            "(%s:%d) GetXenonUserAuthorization:  Could not find trust factor for this user.  PUID=0x%I64X, Title ID = 0x%X",
            __FILE__,
            __LINE__,
            pServiceRequest->qwUserID[dwUserIndex],
            pServiceRequest->dwTitleID);

        // this isn't a problem... assign a default trust factor of 0 and the neutral
        // ratings of 3.
        fTrustFactor = 0.0;
        dwNoShwRating = 3;
        dwDiscntRating = 3;
    }
    else
    {
        // Rowset was present, let's do it

        fTrustFactor = userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3.TrustRatingFactor;
        fCollectiveSessionDiscnntAvg = userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3.CollectiveSessionDisconnectsAvg;
        fSessionDisconntAvg = userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3.SessionDisconnectsAvg;
        fCollectiveNoShowAvg = userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3.CollectiveNoShowAvg;
        fNoShowAvg = userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3.NoShowAvg;

        // read the intervals to session disconnects.
        C_ASSERT (sizeof(abytTitleSessionDiscntRatios) == sizeof(userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3.TitleSessionDisconnectRatios));
        memcpy(abytTitleSessionDiscntRatios, userAuthorizationAndPrivileges_3.UserAuthorizationXbox1_3.TitleSessionDisconnectRatios, sizeof(abytTitleSessionDiscntRatios));

        // ------------------------------------------------------------
        // calculate the ratings for our DisconnectRating and NoShowRating
        //
        // ensure we're not trying to calculate with invalid data.  A zero collective
        // average is not valid... just set a default value of 3.
        CalculateRating( fSessionDisconntAvg,
                         fCollectiveSessionDiscnntAvg,
                         abytTitleSessionDiscntRatios,
                         &dwDiscntRating );

        CalculateRating( fNoShowAvg,
                         fCollectiveNoShowAvg,
                         abytTitleSessionDiscntRatios,
                         &dwNoShwRating );
    }

    dbUserData->TrustFactor = fTrustFactor;
    dbUserData->DisconnectRating = dwDiscntRating;
    dbUserData->NoShowRating = dwNoShwRating;

    // Done!
    status = GetAuthorizationSucceeded;

Exit:
    return status;
}

CXkdcDb::GetAuthorizationStatus
CXkdcDb::GetMachineAuthorization(
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    IN ULONGLONG qwMachineId,
    IN DWORD dwPlatformType,
    IN DWORD dwTitleId,
    OUT XKDCDB_AUTHORIZATION_DATA* dbData,
    OUT CStr* perror)
{
    XOMASSERT(pServiceRequest && dbData && perror);

    HRESULT                 hr;
    GetAuthorizationStatus  status = GetAuthorizationFailed;
    XKDCDB_MACHINE_AUTHORIZATION_DATA* dbMachineData;
    XkdcMachineAuthorization machineAuthorization = {0};
    CComBSTR bstrFlashVersionUodb;
    SAFEARRAY * psaServiceIds = NULL;
    SAFEARRAY * psaGroupIds = NULL;
    CComSafeArray<int> saServiceIds;

    FILETIME    PasswordResetTime = {0};
    FILETIME    BlockEndTime = {0};

    dbMachineData = &dbData->MachineData;

    //
    // Do the database call
    //
    hr = _pXkdc->GetManagedProxy()->XkdcGetMachineAuthorization(
        qwMachineId,
        pServiceRequest->qwUserID[0],
        pServiceRequest->qwUserID[1],
        pServiceRequest->qwUserID[2],
        pServiceRequest->qwUserID[3],
        pServiceRequest->wAutoDiscoverServices != 0,
        dwTitleId,
        dwPlatformType,
        &machineAuthorization,
        &psaServiceIds,
        &psaGroupIds);

    if ( FAILED(hr) )
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            status = GetAuthorizationBusy;
        }

        perror->Format("p_xkdc_get_machine_authorization failed. hr=0x%08X", hr);
        goto Exit;
    }
    saServiceIds.Attach(psaServiceIds);

    // read the next result.
    if (!machineAuthorization.IsDataPresent)
    {
        perror->Format("p_xkdc_get_machine_authorization returned no results for machine 0x%016I64X.", qwMachineId);
        status = GetAuthorizationNotFound;
        goto Exit;
    }


    //
    // Rowset 1
    //
    // Info about the machine. 1 row.
    //

    ULONGLONG   qwUODBMachinePUID     = machineAuthorization.MachinePuid;
    DATE        datePasswordResetTime = machineAuthorization.ResetDate;
    CHECK_HR(GetFILETIMEFromDATE( datePasswordResetTime, &PasswordResetTime ));
    DWORD       dwBetaTitleMask       = machineAuthorization.BetaTitleId;
    DWORD       dwCertConsoleType     = machineAuthorization.CertConsoleType;
    bstrFlashVersionUodb.Attach(machineAuthorization.FlashVersion);
    BOOL        fActivationRequired   = machineAuthorization.ActivationRequired;
    BOOL        fActivatedOtherTitle  = machineAuthorization.ActivatedOtherTitle;
    DWORD       dwConsoleRegion       = machineAuthorization.ConsoleRegion;
    DATE        dateBlockEndTime      = machineAuthorization.BlockEndTime;
    CHECK_HR(GetFILETIMEFromDATE( dateBlockEndTime, &BlockEndTime ));
    NTSTATUS    ntBlockStatus         = machineAuthorization.BlockStatusCode;

    // BetaTitleMask notes
    //
    // 0x00000000: normal machine. all title version checks reference the 'update' version
    // column.
    //
    // 0xnnnn0000: machine participates in betas for all titles by publisher 'nnnn'. title
    // version checks reference the 'beta' version column instead of the 'update' version.
    //
    // 0xnnnnnnnn: machine participates in betas for only title 'nnnnnnnn'. title version
    // checks reference the 'beta' version column instead of the 'update' version.
    //

    if (qwUODBMachinePUID != qwMachineId)
    {
        perror->Format("Call to p_xkdc_get_machine_authorization for Xbox id 0x%016I64X returned data "
                       "for Xbox id 0x%016I64X",
                       qwMachineId,
                       qwUODBMachinePUID);
        goto Exit;
    }

    // @@@ How do we output DATE and FILETIME in meaningful ways?
    // @@@ We use GetDateFormat and GetTimeFormat.
    UINT64 ftnow;
    GetSystemTimeAsFileTime((FILETIME*)&ftnow);

    // FILETIME contains 100-nano-seconds
    UINT64 ageInSec = (ftnow - dbData->LastRefreshTime) / 10000000;

    XomTrace(Policy, L_LOW, "GetMachineAuthorization: MachineId=0x%016I64X, BetaTitleMask=0x%08X, CertConsoleType=0x%08X, ntBlockStatus=0x%08X, DbDataRecordAge=%u sec",
        qwMachineId,
        dwBetaTitleMask,
        dwCertConsoleType,
        ntBlockStatus,
        ageInSec);

    // Marshal locals into structure. This also serves as the point of timestamping - we
    // *always* have to update the machine authorization, but there may be 0-4 users
    // present.
    C_ASSERT(sizeof(dbData->LastRefreshTime) == sizeof(FILETIME));
    GetSystemTimeAsFileTime((FILETIME*)&dbData->LastRefreshTime);
    dbMachineData->MachineId = qwMachineId;
    dbMachineData->MachineResetDate = PasswordResetTime;
    dbMachineData->BetaTitleMask = dwBetaTitleMask;
    dbMachineData->CertConsoleType = dwCertConsoleType;
    dbMachineData->FlashVersion = XboxClientVersionBSTRToDword(bstrFlashVersionUodb);
    dbMachineData->ActivationRequired = fActivationRequired > 0;
    dbMachineData->ActivatedOtherTitle = fActivatedOtherTitle > 0;
    dbMachineData->ConsoleRegion = dwConsoleRegion;
    dbMachineData->BlockStatus = ntBlockStatus;
    dbMachineData->MachineBlockEndDate = BlockEndTime;

    //
    // Rowset 2
    //
    // Machine-only services (but only for autodiscover)
    //
    //
    if (pServiceRequest->wAutoDiscoverServices)
    {
        if (saServiceIds.GetCount() == 0)
        {
            perror->Format("Second result set is not present despite requesting autodiscover, this is fatal.");
            goto Exit;
        }

        for (unsigned long idx = 0; idx < saServiceIds.GetCount(); ++idx)
        {
            // Machines automatically get authorized for machine-only services
            DWORD const dwServiceID = saServiceIds[static_cast<long>(idx)];
            if (!dbData->AddService(dwServiceID, 1))
            {
                perror->Format("Too many services returned from "
                               "p_xkdc_get_machine_authorization. Failed to add "
                               "service id %u", dwServiceID);
                goto Exit;
            }
        }
    }

    //
    // Rowset 3
    //
    // All the groups the machine is currently a member of.  This is represented
    // as a list of guids.
    //
    // I wish we could do this in the same pattern as up above with the CComSafeArray,
    // but that only supports certain Com types.  That's why I'm using the generic
    // safe array APIs here.
    //

    dbMachineData->NumMachineGroups = psaGroupIds->rgsabound[0].cElements;

    XOMASSERT(dbMachineData->NumMachineGroups <= BETA_GROUP_LIMIT );

    if( dbMachineData->NumMachineGroups > 0)
    {
        unsigned long groupCount = __min( BETA_GROUP_LIMIT, dbMachineData->NumMachineGroups );
        for(unsigned long idx = 0; idx < groupCount ; ++idx)
        {
            hr = SafeArrayGetElement(psaGroupIds, (long*)&idx, &(dbMachineData->MachineGroups[idx]));
            if( FAILED(hr) )
            {
                perror->Format("SafeArrayGetElement returned hr=[%08x] while querying psaGroupIds",hr);
                goto Exit;
            }
        }
    }

    // Done!
    status = GetAuthorizationSucceeded;

Exit:

    if(psaGroupIds)
    {
        SafeArrayDestroy(psaGroupIds);
    }

    return status;
}


// ----------------------------------------------------------------------------------------------
//  CalculateRating:  determines the 0-7 rating
// ----------------------------------------------------------------------------------------------
void CalculateRating( float fUserAvg, float fCumulativeAvg, BYTE *pabIntervals, DWORD *pdwRating )
{
    DWORD dwX = 0;
    BYTE bTotal = 0;
    BYTE bRatio = 0;
    BYTE baRatio[ XKDC_NUMBER_TITLE_TRUST_RATIOS / 2 ];    // used to handle the cumulative values that define the intervals.
    DWORD dwNumberOfElements = ARRAYSIZE(baRatio);

    // we can't handle the zero case.
    if ( fCumulativeAvg == 0 )
    {
        *pdwRating = (XKDC_NUMBER_TITLE_TRUST_RATIOS / 2) - 1;
        return;
    }

    // ------------------------------------------------------------
    // determine the rating.
    if ( fUserAvg < fCumulativeAvg )
    {
        for ( dwX = 0 ; dwX < dwNumberOfElements; dwX++ )
        {
            DWORD dwPos = dwNumberOfElements - 1 - dwX;
            bTotal += pabIntervals[dwPos];
            if ( dwPos == dwNumberOfElements - 1 )
            {
                baRatio[dwPos] = pabIntervals[dwPos];
            }
            else
            {
                // the next value is equal to the next interval plus the value of the previous ratio value.
                baRatio[ dwPos ] =
                            baRatio[ dwPos + 1 ] + pabIntervals[dwPos];
            }
        }

        bRatio = (BYTE)( ( (fCumulativeAvg - fUserAvg) / fCumulativeAvg ) * bTotal );

        // check the boundry intervals... then check the middle.
        if ( bRatio < baRatio[ dwNumberOfElements - 1 ] )
        {
            *pdwRating = dwNumberOfElements - 1;
        }
        else if ( bRatio >= baRatio[ 0 ] )
        {
            *pdwRating = 0;
        }
        else
        {
            // check to see which interval this is under
            for ( dwX = 0 ; dwX < dwNumberOfElements - 1 ; dwX++ )
            {
                // determine the correct interval.
                if ( bRatio < ( baRatio[dwX] ) && bRatio >= ( baRatio[dwX + 1] ) )
                {
                    *pdwRating = dwX;
                    break;
                }
            }
        }

    }
    else if ( fUserAvg > fCumulativeAvg )
    {
        for ( dwX = 0; dwX < dwNumberOfElements; dwX++ )
        {
            bTotal += pabIntervals[ dwX + dwNumberOfElements ];
            if ( dwX == 0 )
            {
                baRatio[dwX] = pabIntervals[dwNumberOfElements];
            }
            else
            {
                // the next value is equal to the next interval plus the value of the previous ratio value.
                baRatio[ dwX ] =
                            baRatio[ dwX - 1 ] + pabIntervals[dwX + dwNumberOfElements];
            }
        }

        bRatio = (BYTE)( ( (fUserAvg - fCumulativeAvg) / fCumulativeAvg ) * bTotal );

        if ( bRatio < baRatio[0] )
        {
            *pdwRating = dwNumberOfElements;
        }
        else if ( bRatio >= baRatio[ dwNumberOfElements - 1 ] )
        {
            *pdwRating = XKDC_NUMBER_TITLE_TRUST_RATIOS - 1;
        }
        else
        {
            // determine the ratio where this belongs.
            for ( dwX = 0 ; dwX < dwNumberOfElements - 1; dwX++ )
            {
                if ( bRatio >= ( baRatio[dwX] ) &&
                     bRatio < ( baRatio[dwX+1] ) )
                {
                    *pdwRating = dwX + dwNumberOfElements;
                    break;
                }
            }
        }

    }
    else
    {
        *pdwRating = 3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcDos.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "xkdc.h"
#include "XkdcMachineCache.h"

// ----------------------------------------------------------------------------
// CTgsDos
// ----------------------------------------------------------------------------

struct CTgsDos
{
    LIST_ENTRY      Hash;
    LARGE_INTEGER   Puid;
    LARGE_INTEGER   LastAuthTime;
    LIST_ENTRY      Lru;
};


DECLARE_HASH_TABLE(TgsDos);

CTgsDosHash  *g_pTgsDosHash = NULL; // Hash table mapping PUID to CTgsDos
CTgsDos      *g_pTgsDos = NULL;     // Vector of all CTgsDos structures
UINT          g_cTgsDos = 0;        // Number of CTgsDos structures allocated
UINT          g_cTgsDosInUse = 0;   // Number of CTgsDos structures in use
LIST_ENTRY    g_leTgsDosLru = {0};  // Queue of CTgsDos structures in use in LRU order
CRITICAL_SECTION g_cs;              // Synchronizes access to TgsDos data

DWORD KdcTgsDosHashCompute(CTgsDos *pTgsDos)
{
    XOMASSERT( pTgsDos );
    return ( pTgsDos->Puid.HighPart ^ pTgsDos->Puid.LowPart ^ pTgsDos->LastAuthTime.HighPart ^ pTgsDos->LastAuthTime.LowPart );
}

BOOL KdcTgsDosHashCompare(CTgsDos *pTgsDos1, CTgsDos *pTgsDos2)
{
    XOMASSERT( pTgsDos1 );
    XOMASSERT( pTgsDos2 );
    return ( pTgsDos1->Puid.QuadPart == pTgsDos2->Puid.QuadPart && pTgsDos1->LastAuthTime.QuadPart == pTgsDos2->LastAuthTime.QuadPart );
}

BOOL XkdcTgsDosInit()
{
    XOMASSERT( NULL == g_pTgsDos );
    XOMASSERT( 0 == g_cTgsDos );
    XOMASSERT( 0 == g_cTgsDosInUse );
    XOMASSERT( NULL == g_pTgsDosHash );
    XOMASSERT( NULL == g_leTgsDosLru.Flink );
    XOMASSERT( NULL == g_leTgsDosLru.Blink );
    InitializeCriticalSection(&g_cs);
    InitializeListHead(&g_leTgsDosLru);
    return TRUE;
}

void XkdcTgsDosTerm()
{
    if ( g_pTgsDos )
    {
        g_pXkdcProvider->KdcFreeMemory(g_pTgsDos);
        g_pTgsDos = NULL;
    }
    
    delete g_pTgsDosHash;
    g_pTgsDosHash = NULL;
    
    g_cTgsDos = 0;
    g_cTgsDosInUse = 0;
    ZeroMemory(&g_leTgsDosLru, sizeof(g_leTgsDosLru));
    DeleteCriticalSection(&g_cs);
}

BOOL XkdcTgsDosConfig(UINT cTgsDos)
{    
    // allocate and zero-fill TgsDos nodes
    g_pTgsDos = (CTgsDos *) g_pXkdcProvider->KdcAllocMemory(cTgsDos * sizeof(CTgsDos));
    if ( NULL == g_pTgsDos )
    {
        XomNtEvent(XEVENT_XKDC_NO_MEMORY_2, "XkdcTgsDosConfig: failed to allocate %d bytes for CTgsDos entries.", cTgsDos*sizeof(CTgsDos));
        return FALSE;
    }
    ZeroMemory(g_pTgsDos, cTgsDos * sizeof(CTgsDos));
    
    g_pTgsDosHash = new CTgsDosHash;
    if ( NULL == g_pTgsDosHash || !g_pTgsDosHash->Init(cTgsDos) )
    {
        XomNtEvent(XEVENT_XKDC_NO_MEMORY_3, "XkdcTgsDosConfig: failed to allocate hash table.");
        return FALSE;
    }

    g_cTgsDos = cTgsDos;
    g_cTgsDosInUse = 0;

    XomTrace(Xkdc, L_NORMAL, "XkdcTgsDosConfig: configured TGS DOS table with %d entries in %d hash buckets.", g_cTgsDos, g_pTgsDosHash->GetBucketCount());
    
    return TRUE;
}

CTgsDos * XkdcTgsDosLookup(LARGE_INTEGER liPuid, LARGE_INTEGER liTime)
{
    CTgsDos TgsDos;
    TgsDos.Puid = liPuid;
    TgsDos.LastAuthTime = liTime;
    return g_pTgsDosHash->Lookup(&TgsDos);
}

CTgsDos * XkdcTgsDosFromLruLink(LIST_ENTRY *ple)
{
    return (CTgsDos*)(((BYTE*)ple) - offsetof(CTgsDos, Lru));
}

CTgsDos *XkdcTgsDosAlloc(LARGE_INTEGER liPuid, LARGE_INTEGER liTime)
{
    CTgsDos *pTgsDos = NULL;

    if ( g_cTgsDosInUse < g_cTgsDos )
    {
        pTgsDos = &g_pTgsDos[g_cTgsDosInUse++];
        g_Counters.IncrementValue32(XKDCPERF_SERVER_DOS_ENTRIES_IN_USE, 1);
    }
    else if ( IsListEmpty(&g_leTgsDosLru) )
    {
        XOMASSERT(0);
        XomNtEvent(XEVENT_XKDC_DOS_CACHE_TOO_SMALL, "XkdcTgsDosAlloc: all DoS cache entries currently allocated.  Increase DoS.NumDosEntries in XKDC.INI higher than %d.", g_cTgsDos);
        return NULL;
    }
    else
    {
        LIST_ENTRY *pleLru = RemoveHeadList(&g_leTgsDosLru);
        pTgsDos = XkdcTgsDosFromLruLink(pleLru);
        g_pTgsDosHash->Delete(pTgsDos);
    }

    pTgsDos->Hash.Flink = NULL;
    pTgsDos->Lru.Flink = NULL;
    pTgsDos->Puid = liPuid;
    pTgsDos->LastAuthTime = liTime;
    g_pTgsDosHash->Insert(pTgsDos);
    return pTgsDos;
}


BOOL XkdcTgsDosCheckAuthenticator(LARGE_INTEGER liPuid, LARGE_INTEGER liTime)
{
    XOMASSERT( g_pTgsDos );
    XOMASSERT( g_cTgsDos > 0 );
    XOMASSERT( g_leTgsDosLru.Flink );
    XOMASSERT( g_leTgsDosLru.Blink );
    
    BOOL bFoundAuthenticator = FALSE;
    
    EnterCriticalSection(&g_cs);
    
    CTgsDos *pTgsDos = XkdcTgsDosLookup(liPuid, liTime);

    // if the authenticator has been seen already, it is a replay
    if ( pTgsDos )
    {
        // remove from the LRU list and reinsert at the tail
        RemoveEntryList(&pTgsDos->Lru);
        pTgsDos->Lru.Flink = NULL;
        InsertTailList(&g_leTgsDosLru, &pTgsDos->Lru);
        bFoundAuthenticator = TRUE;
    }
    else
    {
        // the authenticator has not been seen, it is not a replay (or 
        // at least not a recent one)
        pTgsDos = XkdcTgsDosAlloc(liPuid, liTime);
        XOMASSERT ( pTgsDos );
        if ( NULL == pTgsDos )
        {
            XomNtEvent(XEVENT_XKDC_DOS_CACHE_TOO_SMALL_1,
                "XkdcTgsDosCheckAuthenticator: unable to allocate DoS cache entry. puid: 0x%016I64X, timestamp: 0x%016I64X not added to DoS cache.  Increase DoS.NumDosEntries in XKDC.INI higher than %d.",
                liPuid.QuadPart,
                liTime.QuadPart,
                g_cTgsDos);
            
            XomTrace(Xkdc, L_HIGH,
                "XkdcTgsDosCheckAuthenticator: unable to allocate DoS cache entry. puid: 0x%016I64X, timestamp: 0x%016I64X not added to DoS cache.  Increase DoS.NumDosEntries in XKDC.INI higher than %d.",
                liPuid.QuadPart,
                liTime.QuadPart,
                g_cTgsDos);
            
            goto Cleanup;
        }
        XOMASSERT( NULL == pTgsDos->Lru.Flink );
        InsertTailList(&g_leTgsDosLru, &pTgsDos->Lru);
        bFoundAuthenticator = FALSE;
    }
    
Cleanup:    
    LeaveCriticalSection(&g_cs);

    return bFoundAuthenticator;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcDb.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// XkdcDb.h
//
// Database stuff for xkdc
// --------------------------------------------------------------------------------------

#pragma once

// Forward declarations
class CXkdcProvider;
struct XKDC_PA_SERVICE_REQUEST;

struct XKDCDB_BYTE_SERVICE
{
    BYTE  bServiceId;
    BYTE  bNumSubscriptions;
};

struct XKDCDB_DWORD_SERVICE
{
    DWORD dwServiceId;
    BYTE  bNumSubscriptions;
};

//
// Dynamic allocation is more complicated than we were thinking. For now
// we have a limit of 1 group due to database constraints
//
#define BETA_GROUP_LIMIT 1

struct XKDCDB_MACHINE_AUTHORIZATION_DATA
{
    ULONGLONG   MachineId;
    FILETIME    MachineResetDate;
    DWORD       BetaTitleMask; // To remove
    GUID        MachineGroups[BETA_GROUP_LIMIT];
    DWORD       NumMachineGroups;
    DWORD       CertConsoleType;
    DWORD       FlashVersion;
    DWORD       ConsoleRegion;
    NTSTATUS    BlockStatus;
    FILETIME    MachineBlockEndDate;
    BYTE        ActivationRequired  : 1;
    BYTE        ActivatedOtherTitle : 1;  // only relevant for PCs
    // 6 more bits available!

    void Reset() { ZeroMemory(this, sizeof(*this)); }

    void WriteToString(CStr* pstr) const
    {
        SYSTEMTIME systemTime;

#define W(field, fmt)\
        pstr->Format("  " #field ":" fmt "\n", field);

        W(MachineId,                    "0x%016I64x");
        W(BetaTitleMask,                "0x%x");
        W(CertConsoleType,              "0x%x");
        W(FlashVersion,                 "0x%x");
        W(ConsoleRegion,                "0x%x");
        W(BlockStatus,                  "0x%x");
        W(ActivationRequired,           "%u");
        W(ActivatedOtherTitle,          "%u");

#undef W
#define W(field)\
        if (FileTimeToSystemTime(&field, &systemTime) == TRUE) \
        { \
           pstr->Format("  " #field ":%02d/%02d/%04d %02d:%02d:%02d\n", \
               systemTime.wMonth, \
               systemTime.wDay,   \
               systemTime.wYear,  \
               systemTime.wHour,  \
               systemTime.wMinute,\
               systemTime.wSecond \
               ); \
        }

        W(MachineResetDate);
        W(MachineBlockEndDate);

#undef W
    }

    typedef TToString<XKDCDB_MACHINE_AUTHORIZATION_DATA, 512> ToString;

};

struct XKDCDB_USER_AUTHORIZATION_DATA
{
    ULONGLONG   UserId;
    DWORD       Privileges[XONLINE_NUM_PRIVILEGE_DWORDS];
    FILETIME    PasswordResetDate;
    FILETIME    AccountResumeDate;
    FILETIME    LastSignoutDate;
    FLOAT       TrustFactor;
    DWORD       DisconnectRating;
    DWORD       NoShowRating;
    DWORD       UserMachineTrustLevel;
    DWORD       MaxTicketLifetimeSecs;
    WORD        TicketFlags;
    BYTE        CountryID;
    BYTE        AcceptedTOS             : 1;
    BYTE        VoiceBanned             : 1;
    BYTE        AcctSuspended           : 1;
    BYTE        NameChangeRequired      : 1;
    BYTE        TierID                  : 4; // only low 4 bits are set anyway
    BYTE        BillingAcctStatusFailed : 1;
    BYTE        LimitedMachine          : 1;
    BYTE        InvalidUserPassport     : 1;
    BYTE        InvalidOwnerPassport    : 1;
    BYTE        ActivationRequired      : 1;
    BYTE        BlockedByCurfew         : 1;
    // 2 extra bits here for sale!

    // Helper functions to aid adding services/privileges.
    BOOL AddPrivilege(DWORD dwPrivilegeId);

    void Reset() { ZeroMemory(this, sizeof(*this)); }

    void WriteToString(CStr* pstr) const
    {
        SYSTEMTIME systemTime;

#define W(field, fmt)\
        pstr->Format("  " #field ":" fmt "\n", field);

        W(UserId,                       "0x%016I64x");
        W(TicketFlags,                  "0x%x");
        W(CountryID,                    "%u");
        W(AcceptedTOS,                  "%u");
        W(VoiceBanned,                  "%u");
        W(AcctSuspended,                "%u");
        W(NameChangeRequired,           "%u");
        W(TierID,                       "%u");
        W(BillingAcctStatusFailed,      "%u");
        W(TrustFactor,                  "%f");
        W(DisconnectRating,             "%u");
        W(NoShowRating,                 "%u");
        W(LimitedMachine,               "%u");
        W(InvalidUserPassport,          "%u");
        W(InvalidOwnerPassport,         "%u");
        W(ActivationRequired,           "%u");
        W(BlockedByCurfew,              "%u");
        W(UserMachineTrustLevel,        "%d");
#undef W

#define W(field)\
        if (FileTimeToSystemTime(&field, &systemTime) == TRUE) \
        { \
           pstr->Format("  " #field ":%02d/%02d/%04d %02d:%02d:%02d\n", \
               systemTime.wMonth, \
               systemTime.wDay,   \
               systemTime.wYear,  \
               systemTime.wHour,  \
               systemTime.wMinute,\
               systemTime.wSecond \
               ); \
        }

        W(PasswordResetDate);
        W(AccountResumeDate);
#undef W

        pstr->Format("  Privileges: ");
        for(UINT32 i=0; i < XONLINE_NUM_PRIVILEGE_DWORDS; i++)
        {
            pstr->Format("%08x ", Privileges[i]);
        }
        pstr->Format("\n");


    }

    typedef TToString<XKDCDB_USER_AUTHORIZATION_DATA, 1024> ToString;
};

struct XKDCDB_AUTHORIZATION_DATA
{
    XKDCDB_MACHINE_AUTHORIZATION_DATA MachineData;
    XKDCDB_USER_AUTHORIZATION_DATA    UserData[4];

    UINT64               LastRefreshTime;
    DWORD                TitleId;  // this is the request's TitleId, NOT LiveTitleId
    XKDCDB_BYTE_SERVICE  ByteServices[XONLINE_XE_MAX_BYTE_SERVICEIDS_2];
    XKDCDB_DWORD_SERVICE DwordServices[XONLINE_MAX_DWORD_SERVICEIDS];
    BYTE                 NumByteServices;
    BYTE                 NumDwordServices;

    BYTE                 IsValid;

    // Helper functions to aid adding services/privileges.
    BOOL AddService(
        DWORD dwServiceId,
        DWORD dwSubscriptionStatusID);

    // Helper functions to aid finding a service id.
    BOOL FindByteService(
        BYTE bServiceId,
        XKDCDB_BYTE_SERVICE **ppSvc);

    // Helper functions to aid finding a service id.
    BOOL FindDwordService(
        DWORD dwServiceId,
        XKDCDB_DWORD_SERVICE **ppSvc);

    // Helper functions to aid accessing services. Essentially lets us treat the BYTE and
    // DWORD services as one big array.
    BOOL FindServiceByIdx(
        DWORD dwIdx,
        OUT DWORD* pdwServiceId,
        OUT DWORD* pdwNumSubscriptions);

    // How many people in this request have access to the service?
    DWORD GetNumSubscriptionsToService(
        DWORD dwServiceId);

    // Is this service present or not?
    BOOL IsServicePresent(
        DWORD dwServiceId);

    // Retrieve a pointer to the user authorization data. This would be a handy wrapper if
    // we move to a dynamically allocated user auth data model.
    BOOL FindUserDataByIdx(
        DWORD dwUserIndex,
        OUT XKDCDB_USER_AUTHORIZATION_DATA** ppUserData);

    // Given the input timespan, has this entry expired?
    BOOL HasExpired(DWORD dwLifetimeInSeconds);

    // Calculate whether the data stored here is still fresh or if it has expired, or if
    // something 'important' has changed. Don't forget about the title id. Due to some..
    // ugliness.. in the policy checks, it has to be verified in the middle.
    BOOL StillValid(
        DWORD dwLifetimeInSeconds,
        DWORD dwTitleId,
        ULONGLONG qwMachineId,
        ULONGLONG qwUserId1,
        ULONGLONG qwUserId2,
        ULONGLONG qwUserId3,
        ULONGLONG qwUserId4,
        DWORD *adwServiceID,
        DWORD dwNumServices);

    void Reset() { ZeroMemory(this, sizeof(*this)); }

    void WriteToString(CStr* pstr) const
    {
#define W(field, fmt)\
        pstr->Format("  " #field ":" fmt "\n", field);

        if (MachineData.MachineId != 0)
        {
            pstr->Format("MACHINE:\n");
            MachineData.WriteToString(pstr);
        }

        for (int i = 0; i < ARRAYSIZE(UserData); i++)
        {
            if (UserData[i].UserId != 0)
            {
                pstr->Format("USER %u:\n", i);
                UserData[i].WriteToString(pstr);
            }
        }

        pstr->Format("SERVICES:\n");
        pstr->Format("  ByteServices (%u): ", NumByteServices);
        for(UINT32 i=0; i < NumByteServices; i++)
        {
            pstr->Format("%u:%u ", ByteServices[i].bServiceId, ByteServices[i].bNumSubscriptions);
        }
        pstr->Format("\n");

        pstr->Format("  DwordServices (%u): ", NumDwordServices);
        for(UINT32 i=0; i < NumDwordServices; i++)
        {
            pstr->Format("0x%x:%u ", DwordServices[i].dwServiceId, DwordServices[i].bNumSubscriptions);
        }
        pstr->Format("\n");

        W(IsValid, "%u");
#undef W
    }

    typedef TToString<XKDCDB_AUTHORIZATION_DATA, 1024> ToString;

};




class CXkdcDb
{
public:

    CXkdcDb(CXkdcProvider* pXkdc) :
        _pXkdc(pXkdc)
    {
    }

    // Return values for the Get*Authorization DB functions
    enum GetAuthorizationStatus
    {
        GetAuthorizationSucceeded       = 0,
        GetAuthorizationNotFound        = 1,
        GetAuthorizationFailed          = 2,
        GetAuthorizationBusy            = 3
    };

    // Get authorization data for the machine. Fills out the dbData parameter. This talks
    // to the UODB. Any errors, as indicated by the return status, will be detailed in
    // perror.
    GetAuthorizationStatus GetMachineAuthorization(
        IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
        IN ULONGLONG qwMachineId,
        IN DWORD dwPlatformType,
        IN DWORD dwTitleId,
        OUT XKDCDB_AUTHORIZATION_DATA* dbData,
        OUT CStr* perror);

    // Get authorization data for the Xbox360/PC user. Fills out the dbData parameter.
    // This talks to the UODB. Any errors, as indicated by the return status, will be
    // detailed in perror.
    GetAuthorizationStatus GetXenonUserAuthorization(
        IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
        IN DWORD dwUserIndex,
        IN ULONGLONG qwMachineId,
        IN DWORD dwTitleId,
        IN BOOL fCheckLimitedMac,
        IN DWORD dwPlatformType,
        OUT XKDCDB_AUTHORIZATION_DATA* dbData,
        OUT CStr* perror);

protected:

    CXkdcProvider*         _pXkdc;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\xkdc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#ifndef __XKDC_H__
#define __XKDC_H__

#pragma once

#include <stddef.h>     // for offsetof macro
#include "BaseProvider.h"
#include "BasePrincipal.h"
#include "BaseLog.h"
#include <kdcdos.h>

#include "perfapi.h"
#include "xkdcperf.h"
#include "BasePerfCtrs.h"

#include "tbckhash.h"   // template hash table used for title/version table
#include <wincrypt.h>
#include "xeventids.h"
#include "xkdcdb.h"


// While there is a definition for XONLINE_MAX_SERVICE in xonline.x, it
// only represents what the maximum service id currently is, not the
// maximum it could ever be.  It should be possible to add new base services
// without rebuilding the XKDC.
//
// Note that currently, the maximum service id is 31 because the SG has
// a DWORD mask that uses a bit per service id to represent service
// authorization.  If that mask is ever increased from a DWORD to a QWORD,
// the maximum service id could be raised to 63.
#define XKDC_MAX_SERVICE_ID                 XONLINE_XE_MAX_BYTE_SERVICEIDS_2-1

// ----------------------------------------------------------------------------
// typedefs to make life cleaner
// ----------------------------------------------------------------------------
typedef CKdcDosCache<XKDCDB_AUTHORIZATION_DATA> CKdcDosForXkdc;

// ----------------------------------------------------------------------------
// kludgy bits
// ----------------------------------------------------------------------------

#ifndef INLINE
#define INLINE  FORCEINLINE
#endif

#if 0 // TODO: fix build problems that arise from including this
#include "pac.hxx"
#else
# ifndef PAC_CLIENT_IDENTITY
#  define PAC_CLIENT_IDENTITY   0x0D
# endif
# ifndef PAC_COMPOUND_IDENTITY
#  define PAC_COMPOUND_IDENTITY 0x0E
# endif
# ifndef PAC_XBOX_IDENTITY
#  define PAC_XBOX_IDENTITY     0x58
# endif
#endif

// ----------------------------------------------------------------------------
// import management areas for log and trace messages
// ----------------------------------------------------------------------------

XomImportArea(Xkdc);
XomImportArea(XkdcTicketLog);
XomImportArea(Policy);


// ----------------------------------------------------------------------------
// Define bit settings of user accounts for logging information
// ----------------------------------------------------------------------------
#define XKDC_USERSTATUS_ACCEPTEDTOS                 (1 << 0)      // 0x00000001
#define XKDC_USERSTATUS_NAMECHANGEREQ               (1 << 1)      // 0x00000002
#define XKDC_USERSTATUS_ACCTSUSPENDED               (1 << 2)      // 0x00000004
#define XKDC_USERSTATUS_VOICEBAN                    (1 << 3)      // 0x00000008
#define XKDC_USERSTATUS_BILLINGFAILED               (1 << 4)      // 0x00000010
#define XKDC_USERSTATUS_INTERNALERROR               (1 << 5)      // 0x00000020
#define XKDC_USERSTATUS_INVALIDUSERPASSPORT         (1 << 6)      // 0x00000040
#define XKDC_USERSTATUS_INVALIDOWNERPASSPORT        (1 << 7)      // 0x00000080
#define XKDC_USERSTATUS_UNKNOWNTRUST                (1 << 8)      // 0x00000100
#define XKDC_USERSTATUS_TGT_PRIOR_TO_SIGNOUT_DATE   (1 << 9)      // 0x00000200
#define XKDC_USERSTATUS_USER_MACHINE_TRUST_FAILURE  (1 << 10)     // 0x00000400
#define XKDC_USERSTATUS_USER_MACHINE_NOT_TRUSTED    (1 << 11)     // 0x00000800
#define XKDC_USERSTATUS_TGT_UNKNOWN_CREDENTIALS     (1 << 12)     // 0x00001000
#define XKDC_USERSTATUS_CLEARED_UNKNOWN_TRUST_HR    (1 << 13)     // 0x00002000
#define XKDC_USERSTATUS_CLEARED_MANAGEMENT_HR       (1 << 14)     // 0x00004000
#define XKDC_USERSTATUS_BLOCKED_BY_CURFEW           (1 << 15)     // 0x00008000
#define XKDC_USERSTATUS_REQUIRESMAINTENANCE         (1 << 31)     // 0x80000000


// ----------------------------------------------------------------------------
// Define bit settings of request status for logging information.
// ----------------------------------------------------------------------------
#define XKDC_REQSTATUS_NO_SERVICE_IDS               (1ULL << 0)   // 0x00000001
#define XKDC_REQSTATUS_SUCCESS_COMPLETE_CHECK       (1ULL << 1)   // 0x00000002
#define XKDC_REQSTATUS_INVALIDNAME                  (1ULL << 2)   // 0x00000004
#define XKDC_REQSTATUS_LOADEDSERVICEPRINC           (1ULL << 3)   // 0x00000008
#define XKDC_REQSTATUS_INVALIDSERVID                (1ULL << 4)   // 0x00000010
#define XKDC_REQSTATUS_ISKRBTGT                     (1ULL << 5)   // 0x00000020
#define XKDC_REQSTATUS_ISSG                         (1ULL << 6)   // 0x00000040
#define XKDC_REQSTATUS_ATTAINED_SVCPRINC            (1ULL << 7)   // 0x00000080
#define XKDC_REQSTATUS_CHECKING_DOS                 (1ULL << 8)   // 0x00000100
#define XKDC_REQSTATUS_DOS_ATTACK                   (1ULL << 9)   // 0x00000200
#define XKDC_REQSTATUS_PASSED_DOS                   (1ULL << 10)  // 0x00000400
#define XKDC_REQSTATUS_FAILED_MAC_POLICY_CHECK      (1ULL << 11)  // 0x00000800
#define XKDC_REQSTATUS_FAILED_TITLEID_POLICY_CHECK  (1ULL << 12)  // 0x00001000
#define XKDC_REQSTATUS_FAILED_USER_POLICY_CHECK     (1ULL << 13)  // 0x00002000
#define XKDC_REQSTATUS_FAILED_SERVICES_POLICY_CHECK (1ULL << 14)  // 0x00004000
#define XKDC_REQSTATUS_PASSED_POLICY_CHECK          (1ULL << 15)  // 0x00008000
#define XKDC_REQSTATUS_SUCCESSFUL_PRINC             (1ULL << 16)  // 0x00010000
#define XKDC_REQSTATUS_INVALID_REALM                (1ULL << 17)  // 0x00020000
#define XKDC_REQSTATUS_SUCCESSFUL_TICKET            (1ULL << 18)  // 0x00040000
#define XKDC_REQSTATUS_TGT_PRIOR_TO_PASSWORD_RESET  (1ULL << 19)  // 0x00080000
#define XKDC_REQSTATUS_TITLE_PLATFORM_FALLBACK      (1ULL << 20)  // 0x00100000
#define XKDC_REQSTATUS_TEMPORARILY_BANNED           (1ULL << 21)  // 0x00200000
                                                                  // 0x00400000
                                                                  // 0x00800000
                                                                  // 0x01000000
#define XKDC_REQSTATUS_MACHINE_ACCOUNT_BANNED       (1ULL << 25)  // 0x02000000
#define XKDC_REQSTATUS_NO_MACHINE_ACCOUNT_IN_UODB   (1ULL << 26)  // 0x04000000
#define XKDC_REQSTATUS_INVALID_REQUEST              (1ULL << 27)  // 0x08000000
#define XKDC_REQSTATUS_USING_INVALID_SITE           (1ULL << 28)  // 0x10000000
#define XKDC_REQSTATUS_CONNECTION_FAILURE           (1ULL << 29)  // 0x20000000
#define XKDC_REQSTATUS_NO_REQ_DATA                  (1ULL << 30)  // 0x40000000
#define XKDC_REQSTATUS_GENERALERROR                 (1ULL << 31)  // 0x80000000
#define XKDC_REQSTATUS_VERIFIED_PRE_AUTH_LIST       (1ULL << 32)  // 0x00000001 00000000
#define XKDC_REQSTATUS_MISMATCHED_CLIENT_VERSION    (1ULL << 33)  // 0x00000002 00000000
#define XKDC_REQSTATUS_USING_DOSCACHE_DATA          (1ULL << 34)  // 0x00000004 00000000
#define XKDC_REQSTATUS_INVALID_PARAM                (1ULL << 35)  // 0x00000008 00000000
#define XKDC_REQSTATUS_DOSCACHE_INUSE               (1ULL << 36)  // 0x00000010 00000000
#define XKDC_REQSTATUS_ACTIVATION_REQUIRED          (1ULL << 37)  // 0x00000020 00000000
#define XKDC_REQSTATUS_OTHER_TITLE_ACTIVATED        (1ULL << 38)  // 0x00000040 00000000
#define XKDC_REQSTATUS_XBOX1_DECOMMISSION           (1ULL << 39)  // 0x00000080 00000000
#define XKDC_REQSTATUS_USER_MACHINE_TRUST_FAILURE   (1ULL << 40)  // 0x00000100 00000000
                                                                  // 0x00000200 00000000
#define XKDC_REQSTATUS_TGT_PC_CREDENTIALS           (1ULL << 42)  // 0x00000400 00000000
#define XKDC_REQSTATUS_TGT_PRIOR_TO_SIGNOUT_DATE    (1ULL << 43)  // 0x00000800 00000000
#define XKDC_REQSTATUS_TGT_UNKNOWN_CREDENTIALS      (1ULL << 44)  // 0x00001000 00000000
#define XKDC_REQSTATUS_BLOCKED_BY_CURFEW            (1ULL << 45)  // 0x00002000 00000000

// ----------------------------------------------------------------------------
// Define the possible values for Setting_kdcsvc_enableUserMachineTrust
// ----------------------------------------------------------------------------

#define XKDC_USER_MACHINE_TRUST_DEFAULT             0
#define XKDC_USER_MACHINE_TRUST_ENABLE              1
#define XKDC_USER_MACHINE_TRUST_DISABLE             2
#define XKDC_USER_MACHINE_TRUST_MAXIMUM             2

// Store an alternate live title id for a specific service
struct ALTERNATE_LIVE_TITLE
{
    DWORD dwServiceId;
    DWORD dwTitleId;
};

// Key to access title information (TITLE_VERSION)
struct TITLE_KEY
{
    DWORD dwTitleID;
    DWORD dwPlatformType;
    DWORD dwTitleRegion;
    DWORD dwMediaID;
    DWORD dwBaseVersion;
    GUID  guidGroupID;

    static DWORD Hash(const TITLE_KEY& key, DWORD dwTableSize, DWORD dwParam)
    {
        UNREFERENCED_PARAMETER( dwParam );
        return (key.dwTitleID + key.dwTitleRegion + key.dwMediaID + key.dwPlatformType) % dwTableSize;
    }
};

inline bool operator == (const TITLE_KEY& key1, const TITLE_KEY& key2)
{
    return key1.dwTitleID      == key2.dwTitleID &&
           key1.dwPlatformType == key2.dwPlatformType &&
           key1.dwTitleRegion  == key2.dwTitleRegion &&
           key1.dwMediaID      == key2.dwMediaID &&
           key1.dwBaseVersion  == key2.dwBaseVersion &&
           key1.guidGroupID    == key2.guidGroupID;
}


// This structure is used to keep track of all valid title id and versions.
// If the title is current, the base, update, and beta versions will all
// match.  If an update is available, either the update or beta version will
// differ from the base version depending if the update is generally available
// or only available to beta users.
typedef struct tagTITLE_VERSION
{
    DWORD dwBaseVersion;
    DWORD dwUpdateVersion;
    DWORD dwBetaVersion;
    DWORD dwAlternateTitleIds[XONLINE_MAX_ALTERNATE_TITLE_ID];
    DWORD dwLiveTitleId;
    FILETIME ftStartTime;
    FILETIME ftEndTime;
    ALTERNATE_LIVE_TITLE aAltLiveTitleIds[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];
} TITLE_VERSION;

// This struct is used to hold data from either the XBOX_SERVICE_REQUEST,
// the XBOX_SERVICE_REQUEST2, or the XENON_SERVICE_REQUEST.  This struct
// can be passed around to all of the policy check functions and allow
// them to operate without needing to know whether the request is from
// a Xenon title
struct XKDC_PA_SERVICE_REQUEST
{
    XBOX_LIBRARY_VERSION    clientVersion;
    DWORD                   dwFlashVersion;
    DWORD                   dwTitleID;
    DWORD                   dwTitleVersion;
    DWORD                   dwTitleRegion;
    DWORD                   dwConsoleRegion;
    DWORD                   dwMediaID;
    WORD                    wLanguageID;
    WORD                    wAutoDiscoverServices;
    ULONGLONG               qwUserID[XONLINE_MAX_LOGON_USERS];
    DWORD                   dwNumServices;
    DWORD                   dwServiceID[XONLINE_MAX_PRIVILEGE_ID];
    FLOKEN                  flowToken;
    BOOL                    bAllowServiceAddressFailed;

    void WriteToString(CStr* pstr) const
    {
#define W(field, fmt)\
        pstr->Format("  " #field ":" fmt "\n", field);

        WCHAR ClientVersion[16];
        WCHAR FlashVersion[16];

        XboxClientVersionDwordToWCHARString(CLIENTVERSION_TO_DWORD(clientVersion), ClientVersion, ARRAYSIZE(ClientVersion), FALSE);
        XboxClientVersionDwordToWCHARString(dwFlashVersion, FlashVersion, ARRAYSIZE(FlashVersion), FALSE);

        W(ClientVersion,                "%S");
        W(FlashVersion,                 "%S");
        W(dwTitleID,                    "0x%x");
        W(dwTitleVersion,               "0x%x");
        W(dwTitleRegion,                "0x%x");
        W(dwConsoleRegion,              "0x%x");
        W(dwMediaID,                    "0x%x");
        W(wLanguageID,                  "0x%x");
        W(wAutoDiscoverServices,        "%u");
        W(qwUserID[0],                  "0x%I64x");
        W(qwUserID[1],                  "0x%I64x");
        W(qwUserID[2],                  "0x%I64x");
        W(qwUserID[3],                  "0x%I64x");
        W(dwNumServices,                "%u");
        W(flowToken.flowToken,          "0x%I64x");
        W(bAllowServiceAddressFailed,   "%u");

        pstr->Format("  dwServiceID: ");
        for(UINT32 i=0; i < ARRAY_SIZE(dwServiceID); i++)
        {
            if(dwServiceID[i] != 0)
            {
                if(dwServiceID[i] < 256)
                {
                    pstr->Format("%u ", dwServiceID[i]);
                }
                else
                {
                    pstr->Format("0x%x ", dwServiceID[i]);
                }
            }
        }
        pstr->Format("\n");

#undef W
    }

    typedef TToString<XKDC_PA_SERVICE_REQUEST, 512> ToString;
};

struct XKDC_PA_SERVICE_ADDRESS
{
    HRESULT     hr;
    HRESULT     hrUser[XONLINE_MAX_LOGON_USERS];
    // The high 16 bits of dwUserFlags should come from the UODB User Table.
    DWORD       dwUserFlags[XONLINE_MAX_LOGON_USERS];
    DWORD       dwBwLimit;
    DWORD       dwUserPrivileges[XONLINE_MAX_LOGON_USERS][XONLINE_NUM_PRIVILEGE_DWORDS];
    DWORD       dwPrivileges[XONLINE_NUM_PRIVILEGE_DWORDS];
    IN_ADDR     siteIPAddress;
    DWORD       dwNumServices;
    XKERB_PA_XENON_SERVICE_RESULT     ServiceResult[XONLINE_XE_MAX_BYTE_SERVICEIDS_2 + XONLINE_MAX_DWORD_SERVICEIDS];
    DWORD       dwLiveTitleId;
    XKERB_PA_XBOX_SERVICE_ALTERNATE_TITLE_ID altLiveTitleIds[XONLINE_MAX_SERVICE_ALTERNATE_TITLE_ID];
    FLOKEN      flowToken;
    BOOL        bUseFailedAddress;
    FILETIME    ftXboxConsoleResumeDate;
    FILETIME    ftUserAccountResumeDate[XONLINE_MAX_LOGON_USERS];
};

struct XKDCDB_AUTHORIZATION_DATA;

// This struct is used by the policy checks to keep track of useful data
// and intermediate results needed to successfully build the ticket and
// returned preauth data.
struct XKDC_POLICY_DATA {
    DWORD       dwPlatformType;
    DWORD       dwTitleID;
    DWORD       dwTitleVersion;
    DWORD       dwTitleRegion;
    DWORD       dwConsoleRegion;
    DWORD       dwMediaID;
    WORD        wLanguageID;
    DWORD       dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID];

    // CAuthData2 Services/Privileges
    WORD        wXboxNumPrivileges;
    WORD        dwXboxNumServices;
    DWORD       dwXboxServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];

    // CAuthData3 Services/Privileges
    WORD        wXenonNumPrivileges;
    WORD        wXenonNumDwordServices;
    DWORD       dwXenonPrivileges[XONLINE_NUM_PRIVILEGE_DWORDS];
    DWORD       dwXenonServiceID[XONLINE_MAX_DWORD_SERVICEIDS];

    // CAuthData4 Services/Privileges
    DWORD       dwXenon2UserPrivileges[XONLINE_MAX_LOGON_USERS][XONLINE_NUM_PRIVILEGE_DWORDS];

    // Signing key
    BYTE        abKey[XONLINE_KEY_LENGTH];

    // Xbox Library Version
    XBOX_LIBRARY_VERSION clientVersion;


    // Console Data
    ULONGLONG   qwXboxID;
    FLOAT       fltConsoleTrustFactor;
    HRESULT     hrXbox;
    FILETIME    ftXboxConsoleResumeDate;
    DWORD       dwBetaTitleMask;
    WORD        wNumPrivileges;

    // User Data
    DWORD       dwUsers;
    XUID        users[XONLINE_MAX_LOGON_USERS];
    FLOAT       afltTrustFactor[XONLINE_MAX_LOGON_USERS];
    HRESULT     hrUser[XONLINE_MAX_LOGON_USERS];
    FILETIME    ftUserAccountResumeDate[XONLINE_MAX_LOGON_USERS];
    DWORD       dwUserCredentialIdType[XONLINE_MAX_LOGON_USERS];

    // State Data
    NTSTATUS    policyStatus;
    BOOL        bContinueChecks;
    BOOL        bUseValidSite;
    BOOL        bMachineOnly;
    BOOL        bUserRequiresMaintenance;
    BOOL        bUserAccountSuspended;
    WORD        wAuthDataVersion;
    DWORD       dwAuthDataFlags;
    FLOKEN      flowToken;
    DWORD       dwMaxTicketLifetimeSecs;
    KERBERR     KerbErr;

    XKDCDB_AUTHORIZATION_DATA* pXkdcDbData;

    void WriteToString(CStr* pstr) const
    {
        SYSTEMTIME systemTime;

#define W(field, fmt)\
        pstr->Format("  " #field ":" fmt "\n", field);

        W(dwPlatformType,       "%u");
        W(qwXboxID,             "0x%I64x");
        W(hrXbox,               "0x%x");
        W(dwBetaTitleMask,      "0x%x");
        W(policyStatus,         "0x%x");
        W(wNumPrivileges,       "%u");
        W(users[0],             "0x%I64x");
        W(users[1],             "0x%I64x");
        W(users[2],             "0x%I64x");
        W(users[3],             "0x%I64x");
        W(hrUser[0],            "0x%x");
        W(hrUser[1],            "0x%x");
        W(hrUser[2],            "0x%x");
        W(hrUser[3],            "0x%x");
        W(dwUsers,              "%u");
        W(bContinueChecks,      "%u");
        W(bUseValidSite,        "%u");
        W(bMachineOnly,         "%u");
        W(bUserRequiresMaintenance, "%u");
        W(bUserAccountSuspended,    "%u");
        W(wAuthDataVersion,     "%u");
        W(flowToken.flowToken,  "0x%I64x");
        W(dwMaxTicketLifetimeSecs,  "0x%x");
        W(KerbErr,              "0x%x");
#undef W
#define W(field)\
        if (FileTimeToSystemTime(&field, &systemTime) == TRUE) \
        { \
           pstr->Format("  " #field ":%02d/%02d/%04d %02d:%02d:%02d\n", \
               systemTime.wMonth, \
               systemTime.wDay,   \
               systemTime.wYear,  \
               systemTime.wHour,  \
               systemTime.wMinute,\
               systemTime.wSecond \
               ); \
        }
        W(ftXboxConsoleResumeDate);
        W(ftUserAccountResumeDate[0]);
        W(ftUserAccountResumeDate[1]);
        W(ftUserAccountResumeDate[2]);
        W(ftUserAccountResumeDate[3]);
#undef W
    }

    typedef TToString<XKDC_POLICY_DATA, 1024> ToString;
};


// ----------------------------------------------------------------------------
// Logging structure
// ----------------------------------------------------------------------------
#define XKDC_LOGGING_MAX_STRING_SIZE 512
typedef struct _XKDC_LOGGINGDATA
{
    DWORD                   m_dwIP;
    XBOX_LIBRARY_VERSION    m_clientVersion;
    DWORD                   m_dwTitleId;
    DWORD                   m_dwTitleVersion;
    DWORD                   m_dwTitleRegion;
    DWORD                   m_dwFlashVersion;
    ULONGLONG               m_qwMachinePUID;
    DWORD                   m_dwTicketLifeTime;
    DWORD                   m_dwNumberOfRequestedServices;

    char                    m_szSiteGranted[XKDC_LOGGING_MAX_STRING_SIZE];
    ULONGLONG               m_qwUserPUID[XONLINE_MAX_LOGON_USERS];
    DWORD                   m_dwUserStatus[XONLINE_MAX_LOGON_USERS];
    DWORD                   m_dwUserFlags[XONLINE_MAX_LOGON_USERS];
    FLOAT                   m_afltUserTrustFactor[XONLINE_MAX_LOGON_USERS];
    char                    m_szServicesRequested[XKDC_LOGGING_MAX_STRING_SIZE];
    char                    m_szServicesAttain[XKDC_LOGGING_MAX_STRING_SIZE];

    ULONGLONG               m_qwReqStatus;
} XKDC_LOGGINGDATA;


// TODO: this should be pulled in from a header file
typedef ULONG_PTR HCRYPTPROV;

// ----------------------------------------------------------------------------
// XkdcProvider class
// ----------------------------------------------------------------------------
class CXkdcPrincipal;
class CXkdcMachineCache;

class CXkdcProvider : public CXBaseProvider
{
public:
    CXkdcProvider(IKdcCore *pIKdcCore);
    virtual ~CXkdcProvider();

    // Although most of the functionality is present in the base class,
    // for the Xkdc a check is performed to make sure we aren't being
    // fed AS requests as part of some attack.
    virtual KERBERR __stdcall GetPrincipal(
            IN  GET_PRINC_FLAGS         getprincflags,
            IN  PKERB_INTERNAL_NAME     pkinName,
            IN  LPCWSTR                 pcwszRealm,
            IN  IKerbRequest            *piReq,
            OUT PIKerbPrincipal         *ppIPrincipal,
            OUT PKERB_EXT_ERROR          pExtendedError,
            OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm);

    // Find the XkdcPrincipal in the cache with the given service ID.
    // The PreAuth handler uses this to find info for requested services.
    virtual CXkdcPrincipal * GetServicePrincipal(
            IN  DWORD dwServiceID,
            IN  DWORD dwTitleID,
            IN  DWORD dwTitleVersion,
            IN  DWORD dwTitleRegion);

    virtual const TITLE_VERSION * GetTitleInfo(
            IN  DWORD dwTitleID,
            IN  DWORD dwPlatformType,
            IN  DWORD dwTitleRegion,
            IN  DWORD dwMediaID,
            IN  DWORD dwBaseVersion,
            IN  GUID  guidGroupID);

    virtual DWORD GetLoadBalancingIpAddress(
            IN CXkdcPrincipal *pPrinc,
            IN ULONGLONG qwHashKey);

    // Finish up work synchronously because the provider is getting unloaded.
    virtual void __stdcall Unload();

    // Perform required provider-specific initialization
    virtual NTSTATUS Initialize();

    // Perform any provider-specific cleanup required
    virtual NTSTATUS Uninitialize();

    // Uninitialize and reinitialize in an atomic manner
    virtual NTSTATUS Reinitialize();

    // handler for reloading a specific setting
    virtual VALIDATE_SETTING_RESULT CALLBACK ValidateSetting(CComBSTR &SettingChange);
    virtual void CALLBACK ApplySetting(CComBSTR &SettingChange, CComBSTR &bsValueNew);
    virtual void CALLBACK ApplyMultiSetting(CComBSTR &SettingChange, CComSafeArray<BSTR> &saValues);

    // Implement health checks
    virtual HRESULT HealthCheck(IN DWORD dwRequestId,IN CXomControlResponseInterface *pResponseInterface);

    virtual BOOL IsXkdc()
        { return TRUE; }

    virtual CXkdcMachineCache* GetMachineCache()
        { return m_pMachineCache; }

    virtual NTSTATUS GetSigningKey( IN DWORD dwTitleID,
                                   IN DWORD dwTitleVersion,
                                   IN ULONGLONG qwXboxID,
                                   IN DWORD cSigningKey,
                                   OUT BYTE* abSigningKey );

    virtual const KDC_POLICY_VALUES* __stdcall GetKdcPolicy();

    // return global DoS detection object
    CKdcDosForXkdc* GetKdcDos() { return &m_Dos2; }

    // Should we enforce the flash & client version to match?
    BOOL GetEnforceClientVersion() { return m_bEnforceClientVersion; }

    // XKDC request caching enabled?
    BOOL GetRequestCacheEnabled() { return m_bRequestCacheEnabled; }

    // Cache entry lifetime before becoming invalid
    DWORD GetRequestCacheLifetimeInSeconds() { return m_dwRequestCacheLifetime; }

    // Do we ignore future requests when one is already in progress?
    BOOL GetIgnoreDuplicateRequests() { return m_bIgnoreDuplicateRequests; }

    // Do we force enable user machine trust level checks?
    BOOL GetEnableUserMachineTrust() { return (m_dwEnableUserMachineTrust == XKDC_USER_MACHINE_TRUST_ENABLE); }

    // Do we force disable user machine trust level checks?
    BOOL GetDisableUserMachineTrust() { return (m_dwEnableUserMachineTrust == XKDC_USER_MACHINE_TRUST_DISABLE); }

    // Do we remove privileges on requires management?
    BOOL GetRemoveUserPrivilegesOnRequiresManagement() { return m_bRemoveUserPrivilegesOnRequiresManagement; }

    // Helper function for determining whether a principal is on site1 or not.
    BOOL IsPrincipalSite1(CXkdcPrincipal *pPrinc);

    BOOL IsLegacyPcTitle(DWORD dwTitleId);

protected:
    typedef CTBucketHash<TITLE_KEY, TITLE_VERSION*> CTitleVersionTable;

    virtual NTSTATUS InitializeExtensionHandlers();

    virtual NTSTATUS InitializePrincipalStore();

    virtual NTSTATUS LoadServicePrincipals(
            OUT INT *pcPrinc,
            OUT CXkdcPrincipal ***pppPrinc);

    virtual NTSTATUS ReplaceServicePrincipals(
            IN  INT cPrinc,
            IN  CXkdcPrincipal **ppPrinc,
            OUT INT *pcOldPrinc,
            OUT CXkdcPrincipal ***pppOldPrinc);

    virtual void FreeServicePrincipals(
            IN  INT cPrinc,
            IN  CXkdcPrincipal **ppPrinc);

    virtual NTSTATUS LoadTitleVersions(
            OUT INT *pcTitleVersions,
            OUT CTitleVersionTable **ppTitleVersions);

    virtual NTSTATUS BuildTitleVersions(
            IN XkdcTitleVersionInfo const * const pTitleVersionInfos,
            IN unsigned long const cTitleVersionInfos,
            OUT CTitleVersionTable * const pTitleVersions);

    virtual NTSTATUS ReplaceTitleVersions(
            IN  INT cTitleVersions,
            IN  CTitleVersionTable *pTitleVersions,
            OUT INT *pcOldTitleVersions,
            OUT CTitleVersionTable **pOldTitleVersions);

    virtual void FreeTitleVersions(
            IN  CTitleVersionTable *pTitleVersions);

    virtual BOOL ParseSite1LoadBalancingIps(
            IN  CComSafeArray<BSTR> &saValues,
            OUT DWORD *pcIps,
            OUT DWORD **ppdwIps);

    virtual void ReplaceSite1LoadBalancingIps(
            IN DWORD cNewIps,
            IN DWORD *pdwNewIps,
            OUT DWORD **ppdwOldIps);

    virtual BOOL ParseHexNumberArray(
            IN  CComSafeArray<BSTR> &saValues,
            OUT DWORD *pcValues,
            OUT DWORD **ppdwValues);

    virtual void ReplaceLegacyPcTitles(
            IN DWORD cNewTitles,
            IN DWORD *pdwNewTitles);

    virtual void LogLoadBalancingIps();

    virtual NTSTATUS LoadConfig();

    virtual KERBERR CheckForDos(
            IN  IKerbRequest    *piReq,
            IN OUT XKDC_LOGGINGDATA *pLogData );

    virtual KERBERR VerifyPreAuthWhitelist(
            IN  IKerbRequest    *piReq,
            IN OUT XKDC_LOGGINGDATA *pLogData );

    // Overriding CBaseAudit (which overrides IAudit)
    virtual NTSTATUS __stdcall Audit(
        IN KDC_AUDIT_EVENT      AuditId,
        IN PIKerbRequest        pIKerbRequest,
        IN PSOCKADDR            ClientAddress,
        IN PKERBERR             pExtError,
        IN PULONG               pKdcOptions,
        IN PKERB_CRYPT_LIST     EncryptionType,
        IN PULONG               pulPreauthType
    );

private:

    // Helper function for calculating time constraints.
    TITLE_VERSION* VerifyTitleTimeConstraints(
        IN  const FILETIME ftNow,
        IN  TITLE_VERSION* tv
    );

    // list of principals
    CXkdcPrincipal **m_ppPrinc;
    INT m_cPrinc;

    // title update info
    CTitleVersionTable *m_pTitleVersions;
    INT m_cTitleVersions;

    CXkdcMachineCache *m_pMachineCache;
    DWORD m_dwCacheSize;
    DWORD m_dwHashSize;
    DWORD m_dwEntryLifeTime;

    XKDC_KEY m_signingKey;                       // signing key

    // denial of service config settings
    BOOL m_bCheckForDos;
    DWORD m_cDosEntries;

    // Yet another DoS detection object. This one also provides the UODB request cache,
    // though. Use it to detect bad clients, and also use it to cache results from the
    // UODB.
    CKdcDosForXkdc m_Dos2;

    // Enforce a match between clientVersion and flashVersion?
    BOOL m_bEnforceClientVersion;

    // Do we strip out user privileges if we are about to return REQUIRES_MANAGEMENT?
    BOOL m_bRemoveUserPrivilegesOnRequiresManagement;

    // Request caching variables from configdb
    BOOL m_bRequestCacheEnabled;
    DWORD m_dwRequestCacheLifetime;
    BOOL m_bIgnoreDuplicateRequests;

    // Decommissioning Xbox 1
    KERBERR m_kerbErrXbox1DecommissionFailure;
    HRESULT m_hrXbox1DecommissionFailure;

    // Load balancing
    PKERB_INTERNAL_NAME m_pkinSite1Name;
    DWORD m_cSite1LoadBalancingIps;
    DWORD *m_pdwSite1LoadBalancingIps;

    DWORD m_cLegacyPcTitles;
    DWORD *m_pdwLegacyPcTitles;

    // Enable User Machine Trust levels checks?
    DWORD m_dwEnableUserMachineTrust;

    // Enable unique signin keys
    BOOL m_bUseUniqueSigninKey;
};

// must define this for the hash table to work properly
inline bool operator ==(const ULARGE_INTEGER &a, const ULARGE_INTEGER &b)
{
    return a.QuadPart == b.QuadPart;
}

// ----------------------------------------------------------------------------
// XkdcPrincipal class
// ----------------------------------------------------------------------------

class CXkdcPrincipal : public CXBasePrincipal
{
public:
    CXkdcPrincipal();
    virtual ~CXkdcPrincipal();

    //
    //    IKerbPrincipal methods
    //
    void __stdcall Release(void);

    const KERB_INTERNAL_NAME * __stdcall GetName();
    PKERB_INTERNAL_NAME  __stdcall GetCanonicalName();

    // non-IKerbPrincipal methods
    PKERB_INTERNAL_NAME GetServiceName()
    {
        return m_pkinServiceName;
    }

    DWORD GetSiteIPAddress()
    {
        return m_dwSiteIPAddress;
    }

    DWORD GetServiceID()
    {
        return m_dwServiceID;
    }

    DWORD GetTitleID()
    {
        return m_dwTitleID;
    }

    DWORD GetTitleVersion()
    {
        return m_dwTitleVersion;
    }

    DWORD GetTitleRegion()
    {
        return m_dwTitleRegion;
    }

    WORD GetServicePort()
    {
        return m_wServicePort;
    }

    BOOL IsMachineOnly()
    {
        return m_bMachineOnly;
    }

    BOOL IsServiceAvailable()
    {
        return m_bServiceAvailable;
    }

    DWORD GetAuthdataVersion()
    {
        return m_dwAuthdataVersion;
    }

    NTSTATUS __stdcall Initialize(
        IN    IKdbProvider             *pIKdbProvider,
        IN    IKdcCore                 *pIKdcCore,
        IN    PUNICODE_STRING           pustrRealm,
        IN    XKDC_PRINCIPAL           *pKdbPrinc,
        IN    XkdcCredential           *pCred,
        IN    LPCWSTR                   pwszServiceName,
        IN    LPCWSTR                   pwszDomainName,
        IN    DWORD                     dwSiteIPAddress,
        IN    DWORD                     dwServiceID,
        IN    DWORD                     dwTitleID,
        IN    DWORD                     dwTitleVersion,
        IN    DWORD                     dwTitleRegion,
        IN    WORD                      wServicePort,
        IN    BOOL                      bMachineOnly,
        IN    BOOL                      bServiceAvailable,
        IN    DWORD                     dwAuthdataVersion,
        IN    LARGE_INTEGER             MaxLifeTime,
        IN    LARGE_INTEGER             MaxRenewTime,
        IN    INT                       LastModified,
        IN    INT                       Expiration,
        IN    PRINC_DATA_FLAGS          PrincDataFlags
    );

    virtual void AddRef()
        { InterlockedIncrement((LONG*)&m_dwRefCount); }

    // keep a reference count so we can cache these service principals and
    // have them survive a reload
    DWORD       m_dwRefCount;

protected:
    // the name of the service provided by this principal, e.g. "sg/S2"
    PKERB_INTERNAL_NAME m_pkinServiceName;

    // the ID of this service
    DWORD m_dwServiceID;

    // the title ID specific to this service (if any)
    DWORD m_dwTitleID;

    // the title version specific to this service (if any)
    DWORD m_dwTitleVersion;

    // the title region specific to this service (if any)
    DWORD m_dwTitleRegion;

    // the IP address and port used by this service
    DWORD m_dwSiteIPAddress;
    WORD  m_wServicePort;

    // indicates if this service only requires a valid machine account or if
    // it additionally requires a valid user account.
    BOOL  m_bMachineOnly;

    // indicates if this service instance is available.  Individual service
    // instances may be marked unavailable in the event of planned downtime,
    // etc.
    BOOL m_bServiceAvailable;

    // indicates what version of authdata to return.  A version of 2 will
    // result in Tsunami authdata being added to the ticket.  A version of 3
    // will result in Xenon authdata being added to the ticket.  Etc...
    DWORD m_dwAuthdataVersion;
};


// ----------------------------------------------------------------------------
// XkdcServicePrincipal class
// ----------------------------------------------------------------------------

class CXkdcServicePrincipal : public CXBasePrincipal
{
 public:
    CXkdcServicePrincipal(CXkdcPrincipal *pPrinc, IKerbRequest *piReq, CXkdcProvider *pXkdc);
    virtual ~CXkdcServicePrincipal();

    // non-IKerbPrincipal methods
    NTSTATUS __stdcall Initialize();
    const XKDC_POLICY_DATA *GetPolicyData();

    //
    //    IKerbPrincipal methods
    //
    void __stdcall Release(void);

    const KERB_INTERNAL_NAME * __stdcall GetName();
    PKERB_INTERNAL_NAME  __stdcall GetCanonicalName();
    virtual LARGE_INTEGER __stdcall MaxLifeTime();

    IKdbProvider * __stdcall GetIKdbProvider(void);

    NTSTATUS __stdcall Encrypt(
        IN PKERB_CRYPT_LIST         pEtypes,    //types preferred
        IN  SALTFLAGS               saltflags,  //salt flags
        IN  PBYTE                   pbIn,       //buffer to encrypt
        IN  ULONG                   cbIn,       //size of buffer to encrypt
        OUT PKERB_ENCRYPTED_DATA    pData,      //encrypted data
        OUT PKERB_EXT_ERROR         pExtendedError);

    NTSTATUS __stdcall Decrypt(
        IN  const KERB_CRYPT_LIST *      pEtypes,
        IN  SALTFLAGS               saltflags,
        IN  const KERB_ENCRYPTED_DATA *   pData,
        OUT PBYTE                   pbOut,
        OUT PULONG                  pcbOut,
        OUT OPTIONAL PETYPE         pEtype,
        OUT PKERB_EXT_ERROR         pExtendedError);


    NTSTATUS __stdcall GetChecksumSize(
                IN  CTYPE                Ctype,
                OUT PULONG               pcbOut);

    NTSTATUS __stdcall Checksum(
                IN  CTYPE                Ctype,
                IN  SALTFLAGS            saltflags,
                IN  PKERB_CRYPT_LIST     pEtypes,
                IN  PBYTE               *rgpbBuffers,
                IN  ULONG               *rgcbBuffers,
                IN  ULONG                cBuffers,
                IN  PBYTE                pbVerify,     // OPTIONAL
                IN  ULONG                cbVerify,     // OPTIONAL
                OUT PBYTE                pbChecksum,   // OPTIONAL
                OUT PULONG               pcbChecksum,  // OPTIONAL
                OUT PBOOLEAN             pfVerified,   // OPTIONAL
                OUT PKERB_EXT_ERROR      pExtendedError);

    NTSTATUS __stdcall GetEtypes(
                OUT const ETYPE **ppEtypes,
                OUT PULONG      pcEtypes
    );

    KERBERR __stdcall GetEtypeMatch(
        IN  PKERB_CRYPT_LIST pEtypes,
        OUT PKERB_ETYPE_INFO *ppEtypeInfo
    );

 protected:
    NTSTATUS PolicyCheck();

 private:
    PKERB_INTERNAL_NAME m_pkinInvalidName;
    BOOL            m_bUseValidSite;
    CXkdcPrincipal  *m_piPrinc;
    IKerbRequest    *m_piReq;
    CXkdcProvider   *m_pXkdc;
    IADPacSection   *m_piPacSect;
    LARGE_INTEGER    m_liMaxLifeTime;
};


// ----------------------------------------------------------------------------
// Xkdc Preauth interface, handler, and handler factory classes
// ----------------------------------------------------------------------------

DEFINE_KDC_GUID(IID_IPAXboxRequest,
    0x41c1df86,
    0x12ed,
    0x4ef4,
    0xb0, 0x4c, 0x68, 0xe0, 0x61, 0xac, 0xf1, 0xc8);


DEFINE_KDC_GUID(IID_IPAXboxLogData,
    0x5354fcee,
    0x56d4,
    0x456e,
    0x80, 0x9e, 0x81, 0x57, 0xeb, 0x7e, 0xe5, 0x32);


struct IPAXboxLogData
{
    virtual NTSTATUS __stdcall GetLogData(
        OUT XKDC_LOGGINGDATA **pLogData) = 0;
};

struct IPAXboxRequest
{
    virtual NTSTATUS __stdcall GetServiceRequest(
        OUT XKDC_PA_SERVICE_REQUEST **pServiceRequest) = 0;

    virtual NTSTATUS __stdcall GetServiceAddress(
        OUT XKDC_PA_SERVICE_ADDRESS **pServiceAddress) = 0;

    virtual NTSTATUS __stdcall GetPolicyData(
        OUT XKDC_POLICY_DATA **pPolicyData) = 0;
};

class CPAXboxRequestHandler : public IPAHandler, public IPAXboxRequest, public IPAXboxLogData
{
public:
    CPAXboxRequestHandler(CXkdcProvider *pXKdc, ULONG ulPaType);
    ~CPAXboxRequestHandler();

    //  get PA datatype value
    ULONG GetPAType(void)
    {
        return m_ulPaType;
    }

    virtual void __stdcall Release(void);

    virtual KERBERR __stdcall Check(
        IN  IKerbRequest                *piReq,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR             pExtendedError);

    virtual KERBERR __stdcall ReturnToClient(
        IN  IKerbRequest        *piReq,
        OUT PKERB_PA_DATA_LIST  *ppOutPadata);

    // we support the IPAXboxRequest interface
    virtual HRESULT __stdcall QueryInterface(
        IN  REFIID intf,
        OUT PVOID *ppv);

    // IPAXboxRequest interface methods

    virtual NTSTATUS __stdcall GetServiceRequest(
        OUT XKDC_PA_SERVICE_REQUEST **pServiceRequest);

    virtual NTSTATUS __stdcall GetServiceAddress(
        OUT XKDC_PA_SERVICE_ADDRESS **pServiceAddress);

    virtual NTSTATUS __stdcall GetPolicyData(
        OUT XKDC_POLICY_DATA **pPolicyData);

    // IPAXboxLogData interface methods

    virtual NTSTATUS __stdcall GetLogData(
        OUT XKDC_LOGGINGDATA **pLogData);

protected:
    KERBERR GetXenonServiceRequest2(
        IN PKERB_PA_DATA_LIST PreAuthData,
        IN PKERB_ENCRYPTION_KEY SessionKey,
        IN IKerbRequest  *piReq,
        OUT PXKERB_PA_XENON_SERVICE_REQUEST2* ppServiceRequest);

    KERBERR ReturnXenonServiceAddress2(
        IN XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
        IN PKERB_ENCRYPTION_KEY SessionKey,
        IN IKerbRequest  *piReq,
        OUT PKERB_PA_DATA_LIST *ppOutPadata);

    KERBERR ReturnXenonServiceAddress3(
        IN XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
        IN PKERB_ENCRYPTION_KEY SessionKey,
        IN IKerbRequest  *piReq,
        OUT PKERB_PA_DATA_LIST *ppOutPadata);

    KERBERR ReturnXenonServiceAddressFailed(
        IN XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
        IN PKERB_ENCRYPTION_KEY SessionKey,
        IN IKerbRequest  *piReq,
        OUT PKERB_PA_DATA_LIST *ppOutPadata);

    KERBERR ReturnServiceAddress(
        IN PVOID pPreauthData,
        IN size_t dwPreauthDataSize,
        IN DWORD dwPreauthType,
        IN PKERB_ENCRYPTION_KEY SessionKey,
        IN IKerbRequest  *piReq,
        OUT PKERB_PA_DATA_LIST *ppOutPadata);

    KERBERR GetXenonServiceRequest3(
        IN PKERB_PA_DATA_LIST PreAuthData,
        IN PKERB_ENCRYPTION_KEY SessionKey,
        IN IKerbRequest  *piReq,
        OUT PXKERB_PA_XENON_SERVICE_REQUEST3* ppServiceRequest);


    KERBERR ProcessXboxServiceRequest(
        IN  IKerbRequest                     *piReq,
        IN  PKERB_PA_DATA_LIST                pPreAuthData,
        IN  XKDC_LOGGINGDATA                 *pLogData,
        OUT PKERB_EXT_ERROR                   pExtendedError);

    KERBERR ProcessXenonServiceRequest2(
        IN  IKerbRequest                     *piReq,
        IN  PKERB_PA_DATA_LIST                pPreAuthData,
        IN  XKDC_LOGGINGDATA                 *pLogData,
        OUT PKERB_EXT_ERROR                   pExtendedError);

    KERBERR ProcessXenonServiceRequest3(
        IN  IKerbRequest                     *piReq,
        IN  PKERB_PA_DATA_LIST                pPreAuthData,
        IN  XKDC_LOGGINGDATA                 *pLogData,
        OUT PKERB_EXT_ERROR                   pExtendedError);

private:
    CXkdcProvider *m_pXkdc;
    PXKERB_PA_XENON_SERVICE_ADDRESS2 m_pXenonServiceAddress2;
    PXKERB_PA_XENON_SERVICE_ADDRESS3 m_pXenonServiceAddress3;
    PXKERB_PA_XENON_SERVICE_ADDRESS_FAILED m_pXenonServiceAddressFailed;
    XKDC_PA_SERVICE_REQUEST *m_pServiceRequest;
    XKDC_PA_SERVICE_ADDRESS *m_pServiceAddress;
    XKDC_POLICY_DATA m_policyData;
    XKDC_LOGGINGDATA m_objLogData;

    // This class handles different pa-types according to the console type.
    // Currently supported are: KRB5_PADATA_XBOX_SERVICE_REQUEST,
    // KRB5_PADATA_XENON_SERVICE_REQUEST, KRB5_PADATA_XENON_SERVICE_REQUEST2
    ULONG m_ulPaType;
};


class CPAXboxRequestHandlerFactory : public IPAHandlerFactory
{
public:
    CPAXboxRequestHandlerFactory(CXkdcProvider *pXkdc);

    NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *piReq,
        OUT IPAHandler      **ppIPAHandler);

private:
    CXkdcProvider *m_pXkdc;
};

class CPAXenonRequest2HandlerFactory : public IPAHandlerFactory
{
public:
    CPAXenonRequest2HandlerFactory(CXkdcProvider *pXkdc);

    NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *piReq,
        OUT IPAHandler      **ppIPAHandler);

private:
    CXkdcProvider *m_pXkdc;
};

class CPAXenonRequest3HandlerFactory : public IPAHandlerFactory
{
public:
    CPAXenonRequest3HandlerFactory(CXkdcProvider *pXkdc);

    NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *piReq,
        OUT IPAHandler      **ppIPAHandler);

private:
    CXkdcProvider *m_pXkdc;
};

// global reference to Xkdc provider object
extern CXkdcProvider *g_pXkdcProvider;


// ----------------------------------------------------------------------------
// Xkdc AuthData handler and handler factory classes
// ----------------------------------------------------------------------------

class CXboxADHandler : public IADHandler
{
public:
    CXboxADHandler(CXkdcProvider *pXkdc);

    //  get AD datatype value
    virtual ULONG __stdcall GetADType(void)
    {
        return KERB_AUTH_DATA_XBOX;
    }

    virtual KERBERR __stdcall AddToTicket(
        IN  IKerbRequest                *piReq,
        OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR              pExtendedError);

    KERBERR __stdcall
    CXboxADHandler::AddCAuthData2ToTicket(
        IN  IKerbRequest                *piReq,
        IN  XKDC_POLICY_DATA            *pPolicyData,
        IN  PIKerbPrincipal              piSitePrinc,
        OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR              pExtendedError);

    KERBERR __stdcall
    CXboxADHandler::AddCAuthData3ToTicket(
        IN  IKerbRequest                *piReq,
        IN  XKDC_POLICY_DATA            *pPolicyData,
        IN  PIKerbPrincipal              piSitePrinc,
        OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR              pExtendedError);

    KERBERR __stdcall
    CXboxADHandler::AddCAuthData4ToTicket(
        IN  IKerbRequest                *piReq,
        IN  XKDC_POLICY_DATA            *pPolicyData,
        IN  PIKerbPrincipal              piSitePrinc,
        OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR              pExtendedError);

private:
    CXkdcProvider *m_pXkdc;
};


class CXboxADHandlerFactory : public IADHandlerFactory
{
public:
    CXboxADHandlerFactory(CXkdcProvider *pXkdc);

    NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *piReq,
        OUT IADHandler      **ppIADHandler);

private:
    CXboxADHandler m_ADHandler;
};

// ----------------------------------------------------------------------------
// Policy-related structures and functions
// ----------------------------------------------------------------------------

NTSTATUS PolicyCheckMachine(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData);

NTSTATUS PolicyCheckUsers(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData);

NTSTATUS PolicyCheckTitleID(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData);

NTSTATUS PolicyCheckServices(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData);

// ----------------------------------------------------------------------------
// Denial of Service detection functions
// ----------------------------------------------------------------------------

BOOL XkdcTgsDosInit();
void XkdcTgsDosTerm();
BOOL XkdcTgsDosConfig(IN UINT cTgsDos);

// returns true if this puid and timestamp have been seen previously
BOOL XkdcTgsDosCheckAuthenticator(
    IN  LARGE_INTEGER uliPuid,
    IN  LARGE_INTEGER uliTime);

// ----------------------------------------------------------------------------
// various utility functions
// ----------------------------------------------------------------------------

// core functions that should have been exposed but arent'
VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN const KERB_TIME * ClientTime,
    IN int ClientUsec
    );

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN const TimeStamp * TimeStamp
    );

// check that ticket issued after last password reset
BOOLEAN
CheckTicketAndResetTime(
    IN const TimeStamp * TicketStartTime,
    IN const TimeStamp * PasswdResetTime,
    IN const TimeStamp * AllowedSkew);

// changes array of service id DWords to a string.
VOID
GetServiceIdsIntoString(
    IN DWORD dwReqServiceList[],
    IN DWORD dwNumOfServices,
    IN OUT char *szString,
    IN DWORD dwStringSize );

NTSTATUS
PacGetMachinePuid(
    IN  IADPacSection *piPacSection,
    OUT ULONGLONG     *pXboxId
    );

NTSTATUS
PacGetUserIdentity(
    IN  IADPacSection *piPacSection,
    IN  ULONGLONG      qwUserId,
    OUT ULONG         *pCredentialType
    );

VOID
PacGetIdentitiesAsString(
    IN  IADPacSection *piPacSection,
    IN  CStr          *pStr
    );

// -------------------------------------------------------------------------------------
// CStrPolicyData
// Utility to string format contents of XKDC_POLICY_DATA
//
// Usage:
//
// printf("Service-list: %s\n", CStrPolicyData(pPolicyData).FormatServices());
//
// -------------------------------------------------------------------------------------
class CStrPolicyData : public TLocalStr<1024>
{
public:

    CStrPolicyData(const XKDC_POLICY_DATA* pPolicyData) :
        _pPolicyData(pPolicyData)
    {
    }

    // FormatServices
    // Format service list as a comma-separated string
    LPCSTR FormatServices(BOOL fIncludePrivileges);

protected:

    const XKDC_POLICY_DATA* _pPolicyData;     // Pointer to policydata
};

#endif //__XKDC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcMachineCache.cpp ===
//--------------------------------------------------------------------
//  XkdcMachineCache.cpp
//--------------------------------------------------------------------

//--------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------
#include "xkdc.h"
#include "XkdcMachineCache.h"

//--------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------

//--------------------------------------------------------------------
// CONSTANTS
//--------------------------------------------------------------------
const UINT c_iHashTableOverheadPct = 100;   // percent overhead to add to hash tables

/*// Use the same heap as the KDC for allocating memory
static PVOID (WINAPI *KdcAllocMemory)(IN size_t cSize) = 0;
static void (WINAPI *KdcFreeMemory)(IN PVOID pAddress) = 0;
*/

//--------------------------------------------------------------------
//  HashTable -- definitions.
//--------------------------------------------------------------------

DECLARE_HASH_TABLE(MachineCache);

DWORD KdcMachineCacheHashCompute(CMachineCache *pMCNode )
{
    XOMASSERT( pMCNode );
    return ( pMCNode->Puid.HighPart ^ pMCNode->Puid.LowPart  );
}

BOOL KdcMachineCacheHashCompare(CMachineCache *pMCNode1, CMachineCache *pMCNode2)
{
    XOMASSERT( pMCNode1 );
    XOMASSERT( pMCNode2 );
    return ( pMCNode1->Puid.QuadPart == pMCNode2->Puid.QuadPart );
}


//--------------------------------------------------------------------
//  Local Function Declarations
//--------------------------------------------------------------------
DWORD GetCurrentTimeInSeconds();

//--------------------------------------------------------------------
// Class:  CHashTable
//--------------------------------------------------------------------

//--------------------------------------------------------------------
// Class:  CHashTable
//--------------------------------------------------------------------
BOOL CHashTable::Init(UINT cEnt, PFNHCOMPUTE pfnCompute, PFNHCOMPARE pfnCompare)
{
    // Base the number of buckets we allocate on the maximum number of entries, scaled
    // up by a constant factor and then rounded up to the next highest prime number.
    // The idea is to keep hash collisions to a minimum at the cost of additional memory.

    UINT cBucket = cEnt * (100 + c_iHashTableOverheadPct) / 100;

    static DWORD s_adwPrimes[] = { 37,59,89,139,227,359,577,929,1499,2423,3919,6337,10253,16573,
        26821,43391,70207,113591,183797,297377,481171,778541,1259701,2038217,3297913,5336129,
        8633983,13970093,22604069,36574151,59178199,95752333,154930511,250682837,405613333,
        656296153,1061909479,1718205583,2780115059,0xFFFFFFFF};

    DWORD * pdwPrime = s_adwPrimes;
    for (; cBucket > *pdwPrime; pdwPrime++) ;
    cBucket = *pdwPrime;

    _ple = new LIST_ENTRY[cBucket];

    if (_ple == NULL)
    {
        return(FALSE);
    }

    ZeroMemory(_ple, cBucket * sizeof(LIST_ENTRY));

    _cBucket    = cBucket;
    _cEnt       = 0;
    _pfnCompute = pfnCompute;
    _pfnCompare = pfnCompare;

    for (LIST_ENTRY * ple = _ple; cBucket > 0; --cBucket, ++ple)
    {
        InitializeListHead(ple);
    }

    return(TRUE);
}

//--------------------------------------------------------------------
// CHashTable::Term
//--------------------------------------------------------------------
void CHashTable::Term()
{
    delete _ple;
    _ple = NULL;
}

//--------------------------------------------------------------------
// CHashTable::Lookup
//--------------------------------------------------------------------
LIST_ENTRY * CHashTable::Lookup(LIST_ENTRY * pleLok)
{
    LIST_ENTRY * pleHead = &_ple[_pfnCompute(pleLok) % _cBucket];

    for (LIST_ENTRY * ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        if (_pfnCompare(pleLok, ple))
        {
            return(ple);
        }
    }

    return(NULL);
}

//--------------------------------------------------------------------
// CHashTable::Insert
//--------------------------------------------------------------------
void CHashTable::Insert(LIST_ENTRY * pleIns)
{
    XOMASSERT( NULL == pleIns->Flink );
    LIST_ENTRY * pleHead = &_ple[_pfnCompute(pleIns) % _cBucket];
    InsertTailList(pleHead, pleIns);
    _cEnt += 1;
}

//--------------------------------------------------------------------
// CHashTable::Delete
//--------------------------------------------------------------------
void CHashTable::Delete(LIST_ENTRY * pleDel)
{
    XOMASSERT( pleDel->Flink );
    XOMASSERT( pleDel == Lookup(pleDel) );
    RemoveEntryList(pleDel);
    pleDel->Flink = NULL;

    XOMASSERT(_cEnt > 0);
    _cEnt -= 1;
}


//--------------------------------------------------------------------
// Class:  CXkdcMachineCache
//--------------------------------------------------------------------

CXkdcMachineCache::CXkdcMachineCache( )
{
    m_pMCHash       = NULL;
    m_pMCList       = NULL;
    m_cCacheSize    = 0;
    ZeroMemory( &m_leMCLru, sizeof( m_leMCLru ) );
    m_cEntryLifeTime = 0;
}

CXkdcMachineCache::~CXkdcMachineCache()
{
    // if the hash still exists... call terminate.
    if ( m_pMCHash )
    {
        Term();
    }
}

HRESULT CXkdcMachineCache::Init( DWORD dwEntryLifeInSeconds, DWORD cCacheSize, DWORD cHashSize )
{
    HRESULT hr = S_OK;

    // save the entry life time.
    m_cEntryLifeTime = dwEntryLifeInSeconds;

    // save the cache size
    m_cCacheSize = cCacheSize;

    InitializeListHead( &m_leMCLru );

    m_rwMCListLock.WriteLock();

    // allocate and zero-fill machine cache nodes
    m_pMCList = (CMachineCache*)(g_pXkdcProvider->KdcAllocMemory( cCacheSize * sizeof(CMachineCache)));
    if ( NULL == m_pMCList )
    {
        XomNtEvent(XEVENT_XKDC_NO_MEMORY_4, "CXkdcMachineCache::Init(): failed to allocate %d bytes for Machine Cache Nodes entries.", cCacheSize*sizeof(CMachineCache));
        hr = E_FAIL;
        goto Exit;
    }

    // Make sure that the list is zero'ed out
    ZeroMemory(m_pMCList, cCacheSize * sizeof(CMachineCache));

    // initialize the list.
    for ( DWORD dwX = 0; dwX < cCacheSize; dwX ++ )
    {
        InsertHeadList( &m_leMCLru, &(m_pMCList[dwX].Lru) );
    }

    // create the hash table.
    m_pMCHash = new CMachineCacheHash;
    if ( NULL == m_pMCHash || !m_pMCHash->Init(cHashSize) )
    {
        XomNtEvent(XEVENT_XKDC_NO_MEMORY_5, "CXkdcMachineCache::Init(): failed to allocate hash table.");
        hr = E_FAIL;
        goto Exit;
    }

    XomTrace(Xkdc, L_NORMAL, "CXkdcMachineCache::Init(): configured machine cache hash table with %d entries in %d hash buckets.", cHashSize, m_pMCHash->GetBucketCount());

Exit:

    m_rwMCListLock.WriteUnlock();

    return hr;

}

void CXkdcMachineCache::Term()
{
    m_rwMCListLock.WriteLock();
    delete m_pMCHash;
    g_pXkdcProvider->KdcFreeMemory( m_pMCList );

    m_pMCHash = NULL;
    m_pMCList = NULL;

    m_rwMCListLock.WriteUnlock();

    m_cCacheSize = 0;
    ZeroMemory( &m_leMCLru, sizeof( m_leMCLru ) );
    m_cEntryLifeTime = 0;

}

DWORD CXkdcMachineCache::SetEntryLifeTime( DWORD dwEntryLifeTime )
{
    // save the entry life time.
    m_cEntryLifeTime = dwEntryLifeTime;
    return m_cEntryLifeTime;
}

HRESULT CXkdcMachineCache::AddMachine( ULONGLONG qwMachinePuid, NTSTATUS machineStatus, FILETIME *pBlockEndDate )
{
    HRESULT hr = S_OK;
    CMachineCache *pNewNode = NULL;
    CMachineCache mcDummy = {0};

    m_rwMCListLock.WriteLock();

    // ensure we have objects.
    if ( m_pMCList == NULL )
    {
        // no lists... so just let it do the regular path.
        hr = S_OK;
        goto Exit;
    }

    // see if this entry already exists... if it does... just update it.
    mcDummy.Puid.QuadPart = qwMachinePuid;
    pNewNode = m_pMCHash->Lookup( &mcDummy );
    if ( pNewNode != NULL )
    {
        // update the time.
        pNewNode->FirstAccess = GetCurrentTimeInSeconds();
        pNewNode->Status      = machineStatus;
        if ( pBlockEndDate != NULL ) 
        {
            pNewNode->BlockEndDate = *pBlockEndDate;
        }

        // put at the head of the list again...
        RemoveEntryList( &(pNewNode->Lru) );
        InsertHeadList( &m_leMCLru, &(pNewNode->Lru) );
        goto Exit;
    }

    // get the last entry in the list.
    LIST_ENTRY* ple = RemoveTailList( &m_leMCLru );
    pNewNode = CONTAINING_RECORD( ple, CMachineCache, Lru );
    XOMASSERT( pNewNode != NULL );

    if ( pNewNode->Hash.Blink != NULL )
    {
        m_pMCHash->Delete( pNewNode );
    }

    // setup the new node.
    pNewNode->Puid.QuadPart = qwMachinePuid;
    pNewNode->Status        = machineStatus;
    if ( pBlockEndDate != NULL ) 
    {
        pNewNode->BlockEndDate = *pBlockEndDate;
    }
    pNewNode->FirstAccess   = GetCurrentTimeInSeconds();

    // insert in the hash table and front of the lru list.
    m_pMCHash->Insert( pNewNode );
    InsertHeadList( &m_leMCLru, &(pNewNode->Lru) );

Exit:

    // put the node at the front of the list.
    m_rwMCListLock.WriteUnlock();

    pNewNode = NULL;

    return hr;

}

BOOL CXkdcMachineCache::Find( ULONGLONG qwMachinePuid, OUT NTSTATUS *pMachineStatus, FILETIME *pBlockEndDate )
{
    CMachineCache *pNewNode = NULL;
    CMachineCache mcItem = {0};
    BOOL bRes = TRUE;
    DWORD dwTimeDiff = 0;
    DWORD dwCurrentTimeInSecs = 0;

    m_rwMCListLock.ReadLock();

    // ensure we have objects.
    if ( m_pMCList == NULL )
    {
        // no lists... so just let it do the regular path.
        bRes = FALSE;
        goto Exit;
    }

    // look for the entry
    mcItem.Puid.QuadPart = qwMachinePuid;
    pNewNode = m_pMCHash->Lookup( &mcItem );
    if ( pNewNode == NULL )
    {
        // doesn't exist... return false.
        bRes = FALSE;
        goto Exit;
    }

    // check the time...
    dwCurrentTimeInSecs = GetCurrentTimeInSeconds();
    dwTimeDiff = dwCurrentTimeInSecs - pNewNode->FirstAccess;

    // see if the difference is greater than the interval.
    if ( m_cEntryLifeTime < dwTimeDiff )
    {
        bRes = FALSE;
        goto Exit;
    }

    // Copy over the result
    if ( pMachineStatus != NULL) 
    {
        *pMachineStatus = pNewNode->Status;
    }
    if ( pBlockEndDate != NULL) 
    {
        *pBlockEndDate = pNewNode->BlockEndDate;
    }

Exit:
    m_rwMCListLock.ReadUnlock();

    return bRes;
}

//--------------------------------------------------------------------
//  Local Functions
//--------------------------------------------------------------------

DWORD GetCurrentTimeInSeconds()
{
    time_t curtime = {0};
    curtime = time( &curtime );
    return (DWORD)curtime;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcMachineCache.h ===
//--------------------------------------------------------------------
// XkdcMachineCache.h:  
//--------------------------------------------------------------------

#ifndef __XKDCMACHINECACHE_H__
#define __XKDCMACHINECACHE_H__

#pragma once

//--------------------------------------------------------------------
//  Includes
//--------------------------------------------------------------------
#include <time.h>

#include "xlocks.h"
#include "xkdc.h"

//--------------------------------------------------------------------
//  Definitions
//--------------------------------------------------------------------
#ifndef INLINE
#define INLINE __forceinline
#endif

#define DECLARE_NEW_DELETE(class) \
   INLINE void * operator new(size_t cb) { return(g_pXkdcProvider->KdcAllocMemory(cb)); } \
   INLINE void operator delete(void * pv) { g_pXkdcProvider->KdcFreeMemory(pv); }

#define DECLARE_HASH_TABLE(_type) \
    DWORD Kdc##_type##HashCompute(C##_type *); \
    BOOL  Kdc##_type##HashCompare(C##_type *, C##_type *); \
    class C##_type##Hash : public CHashTable { public: DECLARE_NEW_DELETE(C##_type); \
    INLINE BOOL Init(UINT cEnt) { return(CHashTable::Init(cEnt, (PFNHCOMPUTE)Kdc##_type##HashCompute, (PFNHCOMPARE)Kdc##_type##HashCompare)); } \
    INLINE C##_type * Lookup(C##_type * pvEnt) { return((C##_type *)CHashTable::Lookup((LIST_ENTRY *)pvEnt)); } \
    INLINE void  Insert(C##_type * pvEnt) { CHashTable::Insert((LIST_ENTRY *)pvEnt); } \
    INLINE void  Delete(C##_type * pvEnt) { CHashTable::Delete((LIST_ENTRY *)pvEnt); } \
    }; \


//--------------------------------------------------------------------
//  Constants
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  TYPES/STRUCTURES
//--------------------------------------------------------------------
typedef DWORD (*PFNHCOMPUTE)(LIST_ENTRY * ple);
typedef BOOL  (*PFNHCOMPARE)(LIST_ENTRY * ple1, void * ple2);

//--------------------------------------------------------------------
//  Global functions.
//--------------------------------------------------------------------

/*// Use the same heap as the KDC for allocating memory
static PVOID (WINAPI *KdcAllocMemory)(IN size_t cSize) = 0;
static void (WINAPI *KdcFreeMemory)(IN PVOID pAddress) = 0;
*/

// This code is a slight variation on dinartem's hash code for
// the security gateways in sgstate.cpp.  Anyone wishing to reuse
// this code should first look at sgstate.cpp.

// ----------------------------------------------------------------------------
// CHashTable
// ----------------------------------------------------------------------------

class CHashTable
{

public:
    
    INLINE          CHashTable() { _ple = NULL; }
    INLINE         ~CHashTable() { Term(); }
    BOOL            Init(UINT cBucket, PFNHCOMPUTE pfnCompute, PFNHCOMPARE pfnCompare);
    void            Term();
    LIST_ENTRY *    Lookup(LIST_ENTRY * pleLok);
    void            Insert(LIST_ENTRY * pleIns);
    void            Delete(LIST_ENTRY * pleDel);
    INLINE UINT     GetCount() const                { return(_cEnt); }
    INLINE UINT     GetBucketCount() const          { return(_cBucket); }

private:

    LIST_ENTRY *    _ple;               // Vector of hash buckets
    UINT            _cBucket;           // Number of buckets in the table
    UINT            _cEnt;              // Number of entries in the table
    PFNHCOMPUTE     _pfnCompute;        // Function to compute a 32-bit hash from an entry
    PFNHCOMPARE     _pfnCompare;        // Function to compare two entries for equality

};

//--------------------------------------------------------------------
//  Machine Cache hash implementation.
//--------------------------------------------------------------------

struct CMachineCache
{
    LIST_ENTRY      Hash;
    LARGE_INTEGER   Puid;
    NTSTATUS        Status;
    FILETIME        BlockEndDate;
    DWORD           FirstAccess;
    LIST_ENTRY      Lru;
};

class CMachineCacheHash;

//--------------------------------------------------------------------
//  Class:  CXkdcMachineCache
//--------------------------------------------------------------------

class CXkdcMachineCache  
{
public:
    CXkdcMachineCache();
    virtual ~CXkdcMachineCache();

    HRESULT Init( DWORD dwEntryLifeInSeconds, DWORD cCacheSize, DWORD cHashSize );
    void    Term();
    
    HRESULT AddMachine( ULONGLONG qwMachinePuid, NTSTATUS machineStatus = XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED, FILETIME *pBlockEndDate = NULL);
    BOOL    Find( ULONGLONG qwMachinePuid, OUT NTSTATUS *pMachineStatus = NULL, FILETIME *pBlockEndDate = NULL );

    DWORD   SetEntryLifeTime( DWORD dwEntryLifeInSeconds );
    DWORD   GetEntryLifeTime( ) { return m_cEntryLifeTime; }

protected:

    CMachineCacheHash*          m_pMCHash;         // Hash table mapping PUID to CMachineCache
    CMachineCache*              m_pMCList;         // Vector of all CMachineCache structures
    UINT                        m_cCacheSize;       // Number of CMachineCache structures allocated
    LIST_ENTRY                  m_leMCLru;          // Queue of CMachineCache structures in use in LRU order
    xlocks::CReaderWriterLock3  m_rwMCListLock;     // reader writer lock for list protection.
    UINT                        m_cEntryLifeTime;   // lifetime of nodes.

};

#endif // __XKDCMACHINECACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcPreAuth.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "xkdc.h"

// get the area.
XomImportArea(log);


//-------------------------------------------------------------------
//  Local Function Declaration.
//-------------------------------------------------------------------
void BubbleSort( DWORD *paArray, DWORD dwSize );


//-------------------------------------------------------------------
//  CPAXboxRequestHandler:  Implementation
//-------------------------------------------------------------------

CPAXboxRequestHandler::CPAXboxRequestHandler(CXkdcProvider *pXkdc, ULONG ulPaType) :
    m_pXkdc(pXkdc),
    m_pXenonServiceAddress2(NULL),
    m_pXenonServiceAddress3(NULL),
    m_pXenonServiceAddressFailed(NULL),
    m_pServiceRequest(NULL),
    m_pServiceAddress(NULL),
    m_ulPaType(ulPaType)
{
    ZeroMemory(&m_policyData, sizeof(m_policyData));
    ZeroMemory(&m_objLogData, sizeof(m_objLogData));
}


CPAXboxRequestHandler::~CPAXboxRequestHandler()
{
    XOMASSERT( m_pXkdc );
    XOMASSERT( m_pXkdc->KdcFreeMemory );
    if ( m_pXkdc && m_pXkdc->KdcFreeMemory )
    {
        if ( m_pXenonServiceAddress2 )
        {
            m_pXkdc->KdcFreeMemory(m_pXenonServiceAddress2);
            m_pXenonServiceAddress2 = NULL;
        }

        if ( m_pXenonServiceAddress3 )
        {
            m_pXkdc->KdcFreeMemory(m_pXenonServiceAddress3);
            m_pXenonServiceAddress3 = NULL;
        }

        if ( m_pXenonServiceAddressFailed ) 
        {
            m_pXkdc->KdcFreeMemory(m_pXenonServiceAddressFailed);
            m_pXenonServiceAddressFailed = NULL;
        }

        if ( m_pServiceRequest )
        {
            m_pXkdc->KdcFreeMemory(m_pServiceRequest);
            m_pServiceRequest = NULL;
        }

        if ( m_pServiceAddress )
        {
            m_pXkdc->KdcFreeMemory(m_pServiceAddress);
            m_pServiceAddress = NULL;
        }
    }

    m_pXkdc = NULL;
}


void __stdcall
CPAXboxRequestHandler::Release(void)
{
    delete this;
}

KERBERR
CPAXboxRequestHandler::ProcessXenonServiceRequest2(
    IN  IKerbRequest                     *piReq,
    IN  PKERB_PA_DATA_LIST                pPreAuthData,
    IN  XKDC_LOGGINGDATA                 *pLogData,
    OUT PKERB_EXT_ERROR                   pExtendedError
    )
{
    NTSTATUS                          status = STATUS_SUCCESS;
    KERBERR                           KerbErr = KDC_ERR_NONE;
    PXKERB_PA_XENON_SERVICE_REQUEST2  pXenonSvcRequest2 = NULL;

    KerbErr = GetXenonServiceRequest2(
        pPreAuthData,
        (PKERB_ENCRYPTION_KEY) piReq->GetSessionKey(),
        piReq,
        &pXenonSvcRequest2
        );
    if ( !KERB_SUCCESS(KerbErr) )
    {
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_NO_REQ_DATA;
        goto Cleanup;
    }

    XOMASSERT( pXenonSvcRequest2 );

    //
    // If no services were requested, this is a bogus request and should
    // be failed.  Also log an error since this may be an indication of
    // an attempted hack.
    //
    if ( 0 ==   pXenonSvcRequest2->wAutoDiscoverServices &&
         0 == ( pXenonSvcRequest2->wNumByteServices + pXenonSvcRequest2->wNumDwordServices ) )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        XomNtEvent(
            XEVENT_XKDC_NO_SERVICES,
            "(%s:%d) CPAXboxRequestHandler::Check: no services requested by client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr)
            );
        XomTrace(
            Xkdc, L_ERROR,
            "(%s:%d) CPAXboxRequestHandler::Check: no services requested by client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_NO_SERVICE_IDS;
        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;

    }
    //
    // wAutoDiscoverServices can only be 0 or 1
    //
    else if (pXenonSvcRequest2->wAutoDiscoverServices > 1)
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        XomNtEvent(
            XEVENT_XKDC_REQUEST_INVALID_1,
            "CPAXboxRequestHandler::Check: wAutoDiscoverServices was %d; it is "
            "expected to be 0 or 1. Please investigate. IP %s.",
            pXenonSvcRequest2->wAutoDiscoverServices,
            inet_ntoa(*pInAddr)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_INVALID_PARAM;
        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    //
    // Copy the field over
    //
    m_pServiceRequest->clientVersion   = pXenonSvcRequest2->clientVersion;
    m_pServiceRequest->dwFlashVersion  = pXenonSvcRequest2->dwFlashVersion;
    m_pServiceRequest->dwTitleID       = pXenonSvcRequest2->dwTitleID;
    m_pServiceRequest->dwTitleVersion  = pXenonSvcRequest2->dwTitleVersion;
    m_pServiceRequest->dwTitleRegion   = pXenonSvcRequest2->dwTitleRegion;
    m_pServiceRequest->dwConsoleRegion = pXenonSvcRequest2->dwConsoleRegion;
    m_pServiceRequest->dwMediaID       = pXenonSvcRequest2->dwMediaID;
    m_pServiceRequest->wLanguageID     = pXenonSvcRequest2->wLanguageID;
    m_pServiceRequest->wAutoDiscoverServices = pXenonSvcRequest2->wAutoDiscoverServices;

    m_pServiceRequest->qwUserID[0]     = pXenonSvcRequest2->qwUserID[0];
    m_pServiceRequest->qwUserID[1]     = pXenonSvcRequest2->qwUserID[1];
    m_pServiceRequest->qwUserID[2]     = pXenonSvcRequest2->qwUserID[2];
    m_pServiceRequest->qwUserID[3]     = pXenonSvcRequest2->qwUserID[3];

    DWORD dwNumServices = 0;
    DWORD i;

    for ( i = 0; i < pXenonSvcRequest2->wNumByteServices; i++ )
    {
        // ignore requests for service id 0
        if ( 0 == pXenonSvcRequest2->bServiceID[i] )
        {
            XomTrace(
                Xkdc,
                L_HIGH,
                "(%s:%d) CPAXboxRequestHandler::Check: service id 0 found in list of requested services.",
                __FILE__,
                __LINE__
                );
            continue;
        }

        m_pServiceRequest->dwServiceID[dwNumServices] = pXenonSvcRequest2->bServiceID[i];
        dwNumServices++;
    }

    for ( i = 0; i < pXenonSvcRequest2->wNumDwordServices; i++ )
    {
        // ignore requests for service id 0
        if ( 0 == pXenonSvcRequest2->dwServiceID[i] )
        {
            XomTrace(
                Xkdc,
                L_HIGH,
                "(%s:%d) CPAXboxRequestHandler::Check: service id 0 found in list of requested services.",
                __FILE__,
                __LINE__
                );
            continue;
        }

        m_pServiceRequest->dwServiceID[dwNumServices] = pXenonSvcRequest2->dwServiceID[i];
        dwNumServices++;
    }

    m_pServiceRequest->dwNumServices = dwNumServices;

Cleanup:

    if ( pXenonSvcRequest2 )
    {
        m_pXkdc->KdcFreeMemory(pXenonSvcRequest2);
    }

    if ( pExtendedError )
    {
        pExtendedError->status = status;
    }

    return KerbErr;
}

class ServiceCounter
{
public:
    // Sigh. We don't really allow for CII because of our error handling strategy.
    void Init(XKERB_PA_XENON_SERVICE_REQUEST3 const * const pXenonSvcRequest3)
    {
        m_cByteServices = CountByteServices(pXenonSvcRequest3);
        m_cDwordServices = CountDwordServices(pXenonSvcRequest3);
    }

    WORD GetByteServiceCount() const
    {
        return m_cByteServices;
    }

    WORD GetDwordServiceCount() const
    {
        return m_cDwordServices;
    }

    WORD GetTotalServiceCount() const
    {
        return GetByteServiceCount() + GetDwordServiceCount();
    }

private:
    static WORD CountByteServices(XKERB_PA_XENON_SERVICE_REQUEST3 const * const pXenonSvcRequest3)
    {
        WORD count = 0;
        for (int idx = 0; idx < _countof(pXenonSvcRequest3->bServiceIDBits); ++idx)
        {
            count += CountBits(pXenonSvcRequest3->bServiceIDBits[idx]);
        }
        return count;
    }

    static WORD CountDwordServices(XKERB_PA_XENON_SERVICE_REQUEST3 const * const pXenonSvcRequest3)
    {
        WORD count = 0;
        for (int idx = 0; idx < _countof(pXenonSvcRequest3->dwServiceID); ++idx)
        {
            if (pXenonSvcRequest3->dwServiceID[idx] == 0)
            {
                break;
            }
            ++count;
        }
        return count;
    }

    static BYTE CountBits(BYTE const b)
    {
        static BYTE const s_table[256]={
            0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,
            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
            3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
            3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
            3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
            3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
            4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8
        };

        return s_table[b];
    }

    WORD m_cByteServices;
    WORD m_cDwordServices;
};

static BOOL IsBitSet(BYTE const byte, int const bit)
{
    BYTE const checkFor = (1 << bit);
    return (byte & checkFor) == checkFor;
}


KERBERR
CPAXboxRequestHandler::ProcessXenonServiceRequest3(
    IN  IKerbRequest                     *piReq,
    IN  PKERB_PA_DATA_LIST                pPreAuthData,
    IN  XKDC_LOGGINGDATA                 *pLogData,
    OUT PKERB_EXT_ERROR                   pExtendedError
    )
{
    NTSTATUS                          status = STATUS_SUCCESS;
    KERBERR                           KerbErr = KDC_ERR_NONE;
    PXKERB_PA_XENON_SERVICE_REQUEST3  pXenonSvcRequest3 = NULL;
    ServiceCounter counter;

    KerbErr = GetXenonServiceRequest3(
        pPreAuthData,
        (PKERB_ENCRYPTION_KEY) piReq->GetSessionKey(),
        piReq,
        &pXenonSvcRequest3
        );
    if ( !KERB_SUCCESS(KerbErr) )
    {
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_NO_REQ_DATA;
        goto Cleanup;
    }

    XOMASSERT( pXenonSvcRequest3 );

    counter.Init(pXenonSvcRequest3);

    //
    // If no services were requested, this is a bogus request and should
    // be failed.  Also log an error since this may be an indication of
    // an attempted hack.
    //
    if ( 0 ==   pXenonSvcRequest3->wAutoDiscoverServices && 0 == counter.GetTotalServiceCount())
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        XomNtEvent(
            XEVENT_XKDC_NO_SERVICES,
            "(%s:%d) CPAXboxRequestHandler::ProcessXenonServiceRequest3: no services requested by client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr)
            );
        XomTrace(
            Xkdc, L_ERROR,
            "(%s:%d) CPAXboxRequestHandler::ProcessXenonServiceRequest3: no services requested by client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_NO_SERVICE_IDS;
        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;

    }
    //
    // wAutoDiscoverServices can only be 0 or 1
    //
    else if (pXenonSvcRequest3->wAutoDiscoverServices > 1)
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        XomNtEvent(
            XEVENT_XKDC_REQUEST_INVALID_1,
            "CPAXboxRequestHandler::ProcessXenonServiceRequest3: wAutoDiscoverServices was %d; it is "
            "expected to be 0 or 1. Please investigate. IP %s.",
            pXenonSvcRequest3->wAutoDiscoverServices,
            inet_ntoa(*pInAddr)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_INVALID_PARAM;
        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    //
    // Copy the field over
    //
    m_pServiceRequest->clientVersion   = pXenonSvcRequest3->clientVersion;
    m_pServiceRequest->dwFlashVersion  = pXenonSvcRequest3->dwFlashVersion;
    m_pServiceRequest->dwTitleID       = pXenonSvcRequest3->dwTitleID;
    m_pServiceRequest->dwTitleVersion  = pXenonSvcRequest3->dwTitleVersion;
    m_pServiceRequest->dwTitleRegion   = pXenonSvcRequest3->dwTitleRegion;
    m_pServiceRequest->dwConsoleRegion = pXenonSvcRequest3->dwConsoleRegion;
    m_pServiceRequest->dwMediaID       = pXenonSvcRequest3->dwMediaID;
    m_pServiceRequest->wLanguageID     = pXenonSvcRequest3->wLanguageID;
    m_pServiceRequest->wAutoDiscoverServices = pXenonSvcRequest3->wAutoDiscoverServices;

    m_pServiceRequest->qwUserID[0]     = pXenonSvcRequest3->qwUserID[0];
    m_pServiceRequest->qwUserID[1]     = pXenonSvcRequest3->qwUserID[1];
    m_pServiceRequest->qwUserID[2]     = pXenonSvcRequest3->qwUserID[2];
    m_pServiceRequest->qwUserID[3]     = pXenonSvcRequest3->qwUserID[3];

    m_pServiceRequest->flowToken       = pXenonSvcRequest3->flowToken;

    DWORD dwNumServices = 0;
    DWORD i;

    for (int whichByte = 0; whichByte < _countof(pXenonSvcRequest3->bServiceIDBits); ++whichByte)
    {
        for (int whichBit = 0; whichBit < 8 /*bits in a byte*/; ++whichBit)
        {
            if (IsBitSet(pXenonSvcRequest3->bServiceIDBits[whichByte], whichBit))
            {
                DWORD const serviceId = whichByte * 8 /*bits in a byte*/ + whichBit;

                // We can't handle service id 0, and it's invalid. So in that case, trace an derror and move on.
                if (serviceId == 0)
                {
                    XomTrace(Xkdc, L_HIGH, "(%s:%d) CPAXboxRequestHandler::ProcessXenonServiceRequest3: service id 0 found in list of requested services.", __FILE__, __LINE__);
                    continue;
                }

                m_pServiceRequest->dwServiceID[dwNumServices] = serviceId;
                ++dwNumServices;
            }
        }
    }

    for ( i = 0; i < counter.GetDwordServiceCount(); i++ )
    {
        m_pServiceRequest->dwServiceID[dwNumServices] = pXenonSvcRequest3->dwServiceID[i];
        dwNumServices++;
    }

    m_pServiceRequest->dwNumServices = dwNumServices;

    // Determine if we can return the _XKERB_PA_XENON_SERVICE_ADDRESS_FAILED
    // pre-auth based upon whether or not the version field in the service request
    // is greater than 5
    if (pXenonSvcRequest3->wServiceRequestVersion >= XONLINE_SERVICE_REQUEST3_ROAMING_PROFILES_VERSION) 
    {
        m_pServiceRequest->bAllowServiceAddressFailed = TRUE;
    }

Cleanup:

    if ( pXenonSvcRequest3 )
    {
        m_pXkdc->KdcFreeMemory(pXenonSvcRequest3);
    }

    if ( pExtendedError )
    {
        pExtendedError->status = status;
    }

    return KerbErr;
}

KERBERR __stdcall
CPAXboxRequestHandler::Check(
    IN  IKerbRequest                *piReq,
    IN  PKERB_PA_DATA_LIST           pPreAuthData,
    OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
    OUT PKERB_PA_DATA_LIST          *ppOutPadata,
    OUT BOOLEAN*                    pbSufficient,
    OUT PKERB_EXT_ERROR             pExtendedError
)
{
    XOMASSERT( piReq );
    XOMASSERT( pPreAuthData );
    //XOMASSERT( pEncryptionKey );
    XOMASSERT( ppOutPadata );
    XOMASSERT( pExtendedError );

    // these should be initialized to NULL here
    XOMASSERT( NULL == m_pServiceRequest );
    XOMASSERT( NULL == m_pServiceAddress );
    XOMASSERT( NULL == m_pXenonServiceAddress2 );
    XOMASSERT( NULL == m_pXenonServiceAddress3 );
    XOMASSERT( NULL == m_pXenonServiceAddressFailed );

    IPAXboxLogData   *piXboxLog = NULL;
    XKDC_LOGGINGDATA *pLogData = NULL;

    if (!NT_SUCCESS(piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog)) ||
        !NT_SUCCESS(piXboxLog->GetLogData( &pLogData )))
    {
        XomNtEvent(XEVENT_KDC_CODE_198, "Failed to get logging interface");
        return KDC_ERR_SVC_UNAVAILABLE;
    }

    // validate all parameters
    if ( NULL == piReq ||
         NULL == piReq->GetSessionKey() ||
         NULL == pPreAuthData||
         NULL == ppOutPadata ||
         NULL == pExtendedError )
    {
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        XomNtEvent(
            XEVENT_XKDC_BAD_PARAMETER_16,
            "(%s:%d) CPAXboxRequestHandler::Check: invalid parameter.",
            __FILE__,
            __LINE__
            );
        return KDC_ERR_SVC_UNAVAILABLE;
    }

    NTSTATUS                                status = STATUS_SUCCESS;
    KERBERR                                 KerbErr = KDC_ERR_NONE;
    PXKERB_PA_XENON_SERVICE_ADDRESS2        pXenonSvcAddress2 = NULL;
    PXKERB_PA_XENON_SERVICE_ADDRESS3        pXenonSvcAddress3 = NULL;
    PXKERB_PA_XENON_SERVICE_ADDRESS_FAILED  pXenonSvcAddressFailed = NULL;
    XKDC_PA_SERVICE_REQUEST                *pServiceRequest = NULL;
    XKDC_PA_SERVICE_ADDRESS                *pServiceAddress = NULL;

    // no output preauth data at this point
    *ppOutPadata = NULL;
    memcpy(
        &(pLogData->m_dwIP),
        &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr.s_addr),
        sizeof(DWORD)
        );

    //
    // Allocate memory to hold the XKDC_PA_SERVICE_REQUEST console-neutral
    // preauth request.
    //
    pServiceRequest = (XKDC_PA_SERVICE_REQUEST*) m_pXkdc->KdcAllocMemory(sizeof(XKDC_PA_SERVICE_REQUEST));
    if ( NULL == pServiceRequest )
    {
        XomNtEvent(
            XEVENT_KDC_CODE_200,
            "(%s:%d) CPAXboxRequestHandler::Check: failed to allocate %d bytes "
            "for XKDC_PA_SERVICE_REQUEST.",
            __FILE__,
            __LINE__,
            sizeof(XKDC_PA_SERVICE_REQUEST)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    ZeroMemory( pServiceRequest, sizeof(*pServiceRequest) );
    m_pServiceRequest = pServiceRequest;
    pServiceRequest = NULL;

    //
    // Depending on the version number of the client request, build our
    // internal version appropriately
    //
    if ( m_ulPaType == KRB5_PADATA_XENON_SERVICE_REQUEST3 )
    {
        KerbErr = ProcessXenonServiceRequest3(
            piReq,
            pPreAuthData,
            pLogData,
            pExtendedError
            );
    }
    else if ( m_ulPaType == KRB5_PADATA_XENON_SERVICE_REQUEST2 )
    {
        KerbErr = ProcessXenonServiceRequest2(
            piReq,
            pPreAuthData,
            pLogData,
            pExtendedError
            );
    }
    else
    {
        KerbErr = KDC_ERR_POLICY;
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_XBOX1_DECOMMISSION;
        goto Cleanup;
    }

    //
    // Could we successfully convert the client's request into our own private
    // format?
    //
    if ( !KERB_SUCCESS(KerbErr) )
    {
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_NO_REQ_DATA;
        goto Cleanup;
    }

    //
    // If no non-zero services were requested, this is a bogus request and
    // should be failed.  Also log an error since this may be an indication
    // of an attempted hack.
    //
    if ( 0 == m_pServiceRequest->wAutoDiscoverServices &&
         0 == m_pServiceRequest->dwNumServices )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
        XomNtEvent(
            XEVENT_KDC_HACK_16,
            "(%s:%d) CPAXboxRequestHandler::Check: no non-zero services requested by client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr)
            );
        XomTrace(
            Xkdc,
            L_ERROR,
            "(%s:%d) CPAXboxRequestHandler::Check: no non-zero services requested by client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_NO_SERVICE_IDS;
        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    //
    // Allocate memory to hold the XKDC_PA_SERVICE_ADDRESS console-neutral
    // return preauth and associate it with the request.  This allows this
    // Check method and the AddToTicket authdata handler to access it
    // before it is finally returned in the ReturnToClient method.
    //
    pServiceAddress = (XKDC_PA_SERVICE_ADDRESS*) m_pXkdc->KdcAllocMemory(sizeof(XKDC_PA_SERVICE_ADDRESS));
    if ( NULL == pServiceAddress )
    {
        XomNtEvent(
            XEVENT_KDC_CODE_201,
            "(%s:%d) CPAXboxRequestHandler::Check: failed to allocate %d bytes "
            "for XKDC_PA_SERVICE_ADDRESS.",
            __FILE__,
            __LINE__,
            sizeof(XKDC_PA_SERVICE_ADDRESS)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    ZeroMemory( pServiceAddress, sizeof(*pServiceAddress) );
    m_pServiceAddress = pServiceAddress;
    pServiceAddress = NULL;

    //
    // Allocate memory to hold the PA_XENON_SERVICE_ADDRESS2 return preauth and
    // associate it with the request.  This allows this Check method and the
    // AddToTicket authdata handler to access it before it is finally returned
    // in the ReturnToClient method.
    //
    pXenonSvcAddress2 = (PXKERB_PA_XENON_SERVICE_ADDRESS2) m_pXkdc->KdcAllocMemory(sizeof(XKERB_PA_XENON_SERVICE_ADDRESS2));
    if ( NULL == pXenonSvcAddress2 )
    {
        XomNtEvent(
            XEVENT_KDC_CODE_203,
            "(%s:%d) CPAXboxRequestHandler::Check: failed to allocate %d bytes "
            "for PA_XENON_SERVICE_ADDRESS2.",
            __FILE__,
            __LINE__,
            sizeof(XKERB_PA_XENON_SERVICE_ADDRESS2)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    ZeroMemory( pXenonSvcAddress2, sizeof(*pXenonSvcAddress2) );
    m_pXenonServiceAddress2 = pXenonSvcAddress2;
    pXenonSvcAddress2 = NULL;

    //
    // Allocate memory to hold the PA_XENON_SERVICE_ADDRESS3 return preauth and
    // associate it with the request.  This allows this Check method and the
    // AddToTicket authdata handler to access it before it is finally returned
    // in the ReturnToClient method.
    //
    pXenonSvcAddress3 = (PXKERB_PA_XENON_SERVICE_ADDRESS3) m_pXkdc->KdcAllocMemory(sizeof(XKERB_PA_XENON_SERVICE_ADDRESS3));
    if ( NULL == pXenonSvcAddress3 )
    {
        XomNtEvent(
            XEVENT_KDC_CODE_203,
            "(%s:%d) CPAXboxRequestHandler::Check: failed to allocate %d bytes "
            "for PA_XENON_SERVICE_ADDRESS3.",
            __FILE__,
            __LINE__,
            sizeof(XKERB_PA_XENON_SERVICE_ADDRESS3)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    ZeroMemory( pXenonSvcAddress3, sizeof(*pXenonSvcAddress3) );
    m_pXenonServiceAddress3 = pXenonSvcAddress3;
    pXenonSvcAddress3 = NULL;

    //
    // Allocate memory to hold the PA_XENON_SERVICE_ADDRESS_BANNED return preauth and
    // associate it with the request.  This allows this Check method and the
    // AddToTicket authdata handler to access it before it is finally returned
    // in the ReturnToClient method.
    //
    pXenonSvcAddressFailed = (PXKERB_PA_XENON_SERVICE_ADDRESS_FAILED) m_pXkdc->KdcAllocMemory(sizeof(XKERB_PA_XENON_SERVICE_ADDRESS_FAILED));
    if ( NULL == pXenonSvcAddressFailed )
    {
        XomNtEvent(
            XEVENT_KDC_CODE_203,
            "(%s:%d) CPAXboxRequestHandler::Check: failed to allocate %d bytes "
            "for PA_XENON_SERVICE_ADDRESS_FAILED.",
            __FILE__,
            __LINE__,
            sizeof(XKERB_PA_XENON_SERVICE_ADDRESS_FAILED)
            );

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    ZeroMemory( pXenonSvcAddressFailed, sizeof(*pXenonSvcAddressFailed) );
    m_pXenonServiceAddressFailed = pXenonSvcAddressFailed;
    pXenonSvcAddressFailed = NULL;

    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_SUCCESS_COMPLETE_CHECK;

    XomTrace(Xkdc, L_LOW, "CPAXboxRequestHandler::Check completed successfully.");

Cleanup:

    if ( pExtendedError )
    {
        pExtendedError->status = status;
    }

    return KerbErr;
}


KERBERR __stdcall
CPAXboxRequestHandler::ReturnToClient(
    IN  IKerbRequest        *piReq,
    OUT PKERB_PA_DATA_LIST  *ppOutPadata)
{
    NTSTATUS status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST pPAData = NULL;
    const KERB_KDC_REQUEST *pKdcReq = NULL;
    IPAXboxLogData *piXboxLog = NULL;
    XKDC_LOGGINGDATA *pLogData = NULL;

    XOMASSERT( ppOutPadata );

    if (!NT_SUCCESS(piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog)) ||
         !NT_SUCCESS(piXboxLog->GetLogData( &pLogData )))
    {
        XomNtEvent(XEVENT_KDC_CODE_204, "Failed to get logging interface");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // only return preauth data for requests in the XBOX.COM realm
    pKdcReq = piReq->GetKdcRequest();
    if ( 0 != _stricmp( pKdcReq->request_body.realm, XBOX_KERBEROS_REALM ) )
    {
        return KerbErr;
    }

    if ( KerbAs == piReq->GetServId() )
    {
        // XBOX.COM should never get AS requests.
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        XomNtEvent(XEVENT_XKDC_AS_REQUEST,
                "(%s:%d) CPAXboxRequestHandler::ReturnToClient: invalid AS request to %s realm from client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) CPAXboxRequestHandler::ReturnToClient: invalid AS request to %s realm from client %s.  Possible hack attempt.",
                 __FILE__,
                 __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_INVALIDSERVID;
        return KerbErr;
    }

    XOMASSERT( KerbTgs == piReq->GetServId() );

    XomTrace(Xkdc, L_LOW, "(%s:%d) CPAXboxRequestHandler::ReturnToClient entered: m_ulPaType=%u.", __FILE__, __LINE__, m_ulPaType);

    // If ReturnToClient is being called without having had the Check
    // method called, don't do anything.  This means that either this
    // is the Xbox handler and the request was from a Xenon client or
    // vice-versa.
    if ( m_pServiceRequest == NULL && m_pServiceAddress == NULL )
    {
        XomTrace(Xkdc, L_LOW, "(%s:%d) CPAXboxRequestHandler::ReturnToClient leaving without returning preauth data: m_ulPaType=%u.", __FILE__, __LINE__, m_ulPaType);
        return KerbErr;
    }

    XOMASSERT( m_pServiceRequest );
    XOMASSERT( m_pServiceAddress );
    XOMASSERT( m_pXenonServiceAddress2 );
    XOMASSERT( m_pXenonServiceAddress3 );
    XOMASSERT( m_pXenonServiceAddressFailed );

    // validate parameter
    if ( NULL == ppOutPadata )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_17, "(%s:%d) CPAXboxRequestHandler::ReturnToClient: invalid parameter.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        goto Cleanup;
    }

    if (m_ulPaType == KRB5_PADATA_XENON_SERVICE_REQUEST3)
    {
        // PolicyCheck should have decided that this console/user is banned
        // and that we should return a different pre-auth instead
        if (m_pServiceAddress->bUseFailedAddress) 
        {
            KerbErr = ReturnXenonServiceAddressFailed(
                        m_pServiceAddress,
                        (PKERB_ENCRYPTION_KEY) piReq->GetSessionKey(),
                        piReq,
                        &pPAData);
        }
        else
        {
            KerbErr = ReturnXenonServiceAddress3(
                        m_pServiceAddress,
                        (PKERB_ENCRYPTION_KEY) piReq->GetSessionKey(),
                        piReq,
                        &pPAData);
        }
        if ( !KERB_SUCCESS(KerbErr) )
        {
            XomTrace(Xkdc, L_ERROR, "(%s:%d) CPAXboxRequestHandler::ReturnToClient ReturnXenonServiceAddress3 failed with kerb error %S (0x%02X).",
                    __FILE__,
                    __LINE__,
                    m_pXkdc->KerbErrToString(KerbErr),
                    KerbErr);
            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
            goto Cleanup;
        }
    }
    else if ( m_ulPaType == KRB5_PADATA_XENON_SERVICE_REQUEST2)
    {
        KerbErr = ReturnXenonServiceAddress2(
                    m_pServiceAddress,
                    (PKERB_ENCRYPTION_KEY) piReq->GetSessionKey(),
                    piReq,
                    &pPAData);
        if ( !KERB_SUCCESS(KerbErr) )
        {
            XomTrace(Xkdc, L_ERROR, "(%s:%d) CPAXboxRequestHandler::ReturnToClient ReturnXenonServiceAddress2 failed with kerb error %S (0x%02X).",
                    __FILE__,
                    __LINE__,
                    m_pXkdc->KerbErrToString(KerbErr),
                    KerbErr);
            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
            goto Cleanup;
        }
    }

    XOMASSERT( pPAData );
    if ( NULL == pPAData )
    {
        XomTrace(Xkdc, L_ERROR, "(%s:%d) CPAXboxRequestHandler::ReturnToClient missing return preauth data.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        goto Cleanup;
    }

    *ppOutPadata = pPAData;
    pPAData = NULL;
    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_SUCCESSFUL_TICKET;
    XomTrace(Xkdc, L_LOW, "CPAXboxRequestHandler::ReturnToClient completed successfully.");

Cleanup:

    return KerbErr;
}


HRESULT __stdcall
CPAXboxRequestHandler::QueryInterface(
    IN  REFIID intf,
    OUT PVOID *ppv
)
{
    // validate parameter
    if ( NULL == ppv )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_18, "(%s:%d) QueryInterface: invalid parameter.", __FILE__, __LINE__);
        return E_INVALIDARG;
    }

    if (IsEqualIID(intf, IID_IPAXboxLogData))
    {
        *ppv = (PVOID)(IPAXboxLogData*)this;
        return S_OK;
    }

    // Either the Xbox or Xenon service request preauth handler will have a
    // valid service request
    if (IsEqualIID(intf, IID_IPAXboxRequest) && m_pServiceRequest != NULL)
    {
        *ppv = (PVOID)(IPAXboxRequest*)this;
        return  S_OK;
    }

    return  E_NOINTERFACE;
}


// IPAXboxRequest methods
NTSTATUS __stdcall
CPAXboxRequestHandler::GetServiceRequest(OUT XKDC_PA_SERVICE_REQUEST **pServiceRequest)
{
    // TODO: Removed the assert that was here because if a failure
    // occurs in the Check method, this method will still be called as
    // part of the request cycle.  Look into this at some point...
    // XOMASSERT( m_pServiceRequest );
    if ( NULL == m_pServiceRequest )
    {
        XomTrace(Xkdc, L_ERROR, "CPAXboxRequestHandler::GetServiceRequest: Check failed to allocate incoming service request.");
        return STATUS_INVALID_SERVER_STATE;
    }

    XOMASSERT( pServiceRequest );
    if ( NULL == pServiceRequest )
    {
        XomTrace(Xkdc, L_ERROR, "CPAXboxRequestHandler::GetServiceRequest: invalid parameter.");
        return STATUS_INVALID_PARAMETER;
    }

    *pServiceRequest = m_pServiceRequest;

    return STATUS_SUCCESS;
}


NTSTATUS __stdcall
CPAXboxRequestHandler::GetServiceAddress(OUT XKDC_PA_SERVICE_ADDRESS **pServiceAddress)
{
    // TODO: Removed the assert that was here because if a failure
    // occurs in the Check method, this method will still be called as
    // part of the request cycle.  Look into this at some point...
    // XOMASSERT( m_pServiceAddress );
    if ( NULL == m_pServiceAddress )
    {
        XomTrace(Xkdc, L_ERROR, "CPAXboxRequestHandler::GetServiceAddress: Check failed to allocate incoming service request.");
        return STATUS_INVALID_SERVER_STATE;
    }

    XOMASSERT( pServiceAddress );
    if ( NULL == pServiceAddress )
    {
        XomTrace(Xkdc, L_ERROR, "CPAXboxRequestHandler::GetServiceAddress: invalid parameter.");
        return STATUS_INVALID_PARAMETER;
    }

    *pServiceAddress = m_pServiceAddress;

    return STATUS_SUCCESS;
}


NTSTATUS __stdcall
CPAXboxRequestHandler::GetPolicyData(OUT XKDC_POLICY_DATA **pPolicyData)
{
    XOMASSERT( pPolicyData );
    if ( NULL == pPolicyData )
    {
        XomTrace(Xkdc, L_ERROR, "CPAXboxRequestHandler::GetPolicyData: invalid parameter.");
        return STATUS_INVALID_PARAMETER;
    }
    *pPolicyData = &m_policyData;
    return STATUS_SUCCESS;
}

NTSTATUS __stdcall
CPAXboxRequestHandler::GetLogData(OUT XKDC_LOGGINGDATA **pLogData)
{
    XOMASSERT( pLogData );
    if ( NULL == pLogData )
    {
        XomTrace(Xkdc, L_ERROR, "CPAXboxRequestHandler::GetLogData: invalid parameter.");
        return STATUS_INVALID_PARAMETER;
    }
    *pLogData = &m_objLogData;

    return STATUS_SUCCESS;
}

KERBERR
CPAXboxRequestHandler::GetXenonServiceRequest2(
    IN PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN IKerbRequest *piReq,
    OUT PXKERB_PA_XENON_SERVICE_REQUEST2* ppServiceRequest
)
{
    NTSTATUS status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    IKerbCrypt *pIKerbCrypt = NULL;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    PBYTE pChecksumBuffer = NULL;
    ULONG ulChecksumSize = 0;
    PBYTE pbNonce = NULL;
    ULONG cbNonce = 0;
    KERB_ENCRYPTION_KEY key = {0};
    PXKERB_PA_XENON_SERVICE_REQUEST2 pServiceRequest = NULL;
    IPAXboxLogData *piXboxLog = NULL;
    XKDC_LOGGINGDATA *pLogData = NULL;

    XOMASSERT( PreAuthData );
    XOMASSERT( SessionKey );
    XOMASSERT( ppServiceRequest );

    if (!NT_SUCCESS(piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog)) ||
         !NT_SUCCESS(piXboxLog->GetLogData( &pLogData )))
    {
        XomNtEvent(XEVENT_KDC_CODE_215, "Failed to get logging interface");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // validate all parameters
    if ( NULL == PreAuthData || NULL == SessionKey || NULL == piReq || NULL == ppServiceRequest  )
    {
        XomNtEvent(XEVENT_KDC_CODE_216, "(%s:%d) GetXenonServiceRequest: invalid parameter.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // get the crypto provider
    status = m_pXkdc->GetIKerbCrypt(&pIKerbCrypt);
    if ( !NT_SUCCESS(status) || pIKerbCrypt == NULL )
    {
        XomNtEvent(XEVENT_KDC_CODE_217, "(%s:%d) GetXenonServiceRequest: failed to get crypto provider.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // unpack the encrypted data
    KerbErr = m_pXkdc->GetKdcCore()->pfnKerbUnpackData(
                PreAuthData->value.preauth_data.value,
                PreAuthData->value.preauth_data.length,
                KERB_ENCRYPTED_DATA_PDU,
                (PVOID*) &EncryptedData
                );

    if ( !KERB_SUCCESS(KerbErr) ) {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        XomNtEvent(XEVENT_KDC_HACK_21,
            "(%s:%d) GetXenonServiceRequest: KerbUnpackData failed with KerbErr %S (0x%02X) from client %s.  Possible hack attempt.",
            __FILE__,
            __LINE__,
            m_pXkdc->KerbErrToString(KerbErr),
            KerbErr,
            inet_ntoa(*pInAddr));

        XomTrace(Xkdc, L_ERROR,
            "(%s:%d) GetXenonServiceRequest: KerbUnpackData failed with KerbErr %S (0x%02X) from client %s.  Possible hack attempt.",
            __FILE__,
            __LINE__,
            m_pXkdc->KerbErrToString(KerbErr),
            KerbErr,
            inet_ntoa(*pInAddr));

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    status = pIKerbCrypt->GetChecksumSize(
              KERB_CHECKSUM_HMAC_MD5,
              &ulChecksumSize
              );

    if ( !NT_SUCCESS(status) )
    {
        XomNtEvent(XEVENT_KDC_CODE_218,
            "(%s:%d) GetXenonServiceRequest: GetChecksumSize failed with status (0x%08X).",
            __FILE__,
            __LINE__,
            status);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    pChecksumBuffer = (BYTE*) m_pXkdc->GetKdcCore()->pfnKdcAllocMemory(ulChecksumSize);
    if ( NULL == pChecksumBuffer )
    {
        XomNtEvent(XEVENT_KDC_CODE_219,
            "(%s:%d) GetXenonServiceRequest: failed to allocate %d bytes for checksum.",
            __FILE__,
            __LINE__,
            ulChecksumSize);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    pbNonce = (PBYTE)&(piReq->GetKdcRequest()->request_body.nonce);
    cbNonce = sizeof(ASN1int32_t);

    status = pIKerbCrypt->Checksum(
                KERB_CHECKSUM_HMAC_MD5,
                KERB_KDC_REQ_NONCE_CKSUM_SALT,
                SessionKey,
                &pbNonce,
                &cbNonce,
                1,
                NULL,
                0,
                pChecksumBuffer,
                &ulChecksumSize,
                NULL
                );

    if ( !NT_SUCCESS(status) ) {
        XomNtEvent(XEVENT_KDC_CODE_220,
                "(%s:%d) GetXenonServiceRequest: Checksum failed with status 0x%08X.",
                __FILE__,
                __LINE__,
                status);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    key.keytype = KERB_ETYPE_RC4_HMAC_NT;
    key.keyvalue.value = pChecksumBuffer;
    key.keyvalue.length = ulChecksumSize;

    // decrypt the preauth data
    KerbErr = pIKerbCrypt->Decrypt(
                EncryptedData,
                &key,
                KERB_PA_XBOX_SERVICE_REQUEST_SALT,
                EncryptedData->cipher_text.value,
                (PULONG) &EncryptedData->cipher_text.length
                );

    if ( !KERB_SUCCESS(KerbErr) ) {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        XomNtEvent( XEVENT_KDC_HACK_22,
                "(%s:%d) GetXenonServiceRequest: Decrypt of preauth data failed with KerbErr %S (0x%02X) from client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                m_pXkdc->KerbErrToString(KerbErr),
                KerbErr,
                inet_ntoa(*pInAddr));

        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) GetXenonServiceRequest: Decrypt of preauth data failed with KerbErr %S (0x%02X) from client %s.  Possible hack attempt",
                __FILE__,
                __LINE__,
                m_pXkdc->KerbErrToString(KerbErr),
                KerbErr,
                inet_ntoa(*pInAddr));

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
        goto Cleanup;
    }

    if (EncryptedData->cipher_text.length != sizeof(XKERB_PA_XENON_SERVICE_REQUEST2))
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
        XomNtEvent(XEVENT_KDC_CODE_221,
                "(%s:%d) GetXenonServiceRequest: XKERB_PA_XENON_SERVICE_REQUEST2 size mismatch; expected %d bytes, received %d bytes from client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                sizeof(XKERB_PA_XENON_SERVICE_REQUEST2),
                EncryptedData->cipher_text.length,
                inet_ntoa(*pInAddr));

        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) GetXenonServiceRequest: XKERB_PA_XENON_SERVICE_REQUEST2 size mismatch; expected %d bytes, received %d bytes from client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                sizeof(XKERB_PA_XENON_SERVICE_REQUEST2),
                EncryptedData->cipher_text.length,
                inet_ntoa(*pInAddr));

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
        goto Cleanup;
    }

    // create the service request...
    pServiceRequest = (PXKERB_PA_XENON_SERVICE_REQUEST2)m_pXkdc->KdcAllocMemory(sizeof(*pServiceRequest));
    if ( pServiceRequest == NULL )
    {
        XomNtEvent(XEVENT_KDC_CODE_222, "(%s:%d) GetXenonServiceRequest: failed to allocate %d bytes.", __FILE__, __LINE__, sizeof(*pServiceRequest));

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    *ppServiceRequest = pServiceRequest;

    memcpy( pServiceRequest, EncryptedData->cipher_text.value, sizeof(*pServiceRequest) );

    if ( pServiceRequest->wServiceRequestVersion < XONLINE_SERVICE_REQUEST2_MIN_VERSION ||
         pServiceRequest->wServiceRequestVersion > XONLINE_SERVICE_REQUEST2_MAX_VERSION)
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
        XomNtEvent(XEVENT_XKDC_INVALID_SERVICE_REQUEST_VERSION,
                "(%s:%d) CPAXboxRequestHandler::GetXenonServiceRequest2: %d wServiceRequestVersion requested by client %s.",
                __FILE__,
                __LINE__,
                pServiceRequest->wServiceRequestVersion,
                inet_ntoa(*pInAddr)
                );

        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) CPAXboxRequestHandler::GetXenonServiceRequest2: %d wServiceRequestVersion requested by client %s.",
                __FILE__,
                __LINE__,
                pServiceRequest->wServiceRequestVersion,
                inet_ntoa(*pInAddr)
                );

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    if ( pServiceRequest->wNumByteServices > XONLINE_XE_MAX_BYTE_SERVICEIDS )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
        XomNtEvent(XEVENT_KDC_HACK_23,
                "(%s:%d) CPAXboxRequestHandler::GetXenonServiceRequest: %d byte services requested by client %s, maximum allowed is %d.",
                __FILE__,
                __LINE__,
                pServiceRequest->wNumByteServices,
                inet_ntoa(*pInAddr),
                XONLINE_XE_MAX_BYTE_SERVICEIDS
                );

        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) CPAXboxRequestHandler::GetXenonServiceRequest: %d byte services requested by client %s, maximum allowed is %d.",
                __FILE__,
                __LINE__,
                pServiceRequest->wNumByteServices,
                inet_ntoa(*pInAddr),
                XONLINE_XE_MAX_BYTE_SERVICEIDS
                );

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    if ( pServiceRequest->wNumDwordServices > XONLINE_MAX_DWORD_SERVICEIDS )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
        XomNtEvent(XEVENT_KDC_HACK_24,
                "(%s:%d) CPAXboxRequestHandler::GetXenonServiceRequest: %d DWORD services requested by client %s, maximum allowed is %d.",
                __FILE__,
                __LINE__,
                pServiceRequest->wNumDwordServices,
                inet_ntoa(*pInAddr),
                XONLINE_MAX_DWORD_SERVICEIDS
                );

        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) CPAXboxRequestHandler::GetXenonServiceRequest: %d DWORD services requested by client %s, maximum allowed is %d.",
                __FILE__,
                __LINE__,
                pServiceRequest->wNumDwordServices,
                inet_ntoa(*pInAddr),
                XONLINE_MAX_DWORD_SERVICEIDS
                );

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    pLogData->m_dwNumberOfRequestedServices = pServiceRequest->wNumByteServices + pServiceRequest->wNumDwordServices;

    //
    // Bubble sort the services by service ID number
    //
    BubbleSort( pServiceRequest->dwServiceID, pServiceRequest->wNumDwordServices );


    XomTrace(Xkdc, L_LOW, "GetXenonServiceRequest2: version %d completed successfully.", pServiceRequest->wServiceRequestVersion);

 Cleanup:
    if ( pChecksumBuffer != NULL )
    {
        m_pXkdc->GetKdcCore()->pfnKdcFreeMemory(pChecksumBuffer);
        pChecksumBuffer = NULL;
    }

    if ( EncryptedData != NULL )
    {
        if ( EncryptedData->cipher_text.value )
        {
            LocalFree(EncryptedData->cipher_text.value);
            EncryptedData->cipher_text.value = NULL;
        }
        //TODO: we should be calling ASN1Free but it is not exposed by the core
        LocalFree(EncryptedData);
        EncryptedData = NULL;
    }

    return KerbErr;
}

KERBERR
CPAXboxRequestHandler::GetXenonServiceRequest3(
    IN PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN IKerbRequest *piReq,
    OUT PXKERB_PA_XENON_SERVICE_REQUEST3* ppServiceRequest
)
{
    NTSTATUS status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    IKerbCrypt *pIKerbCrypt = NULL;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    PBYTE pChecksumBuffer = NULL;
    ULONG ulChecksumSize = 0;
    PBYTE pbNonce = NULL;
    ULONG cbNonce = 0;
    KERB_ENCRYPTION_KEY key = {0};
    PXKERB_PA_XENON_SERVICE_REQUEST3 pServiceRequest = NULL;
    IPAXboxLogData *piXboxLog = NULL;
    XKDC_LOGGINGDATA *pLogData = NULL;
    ServiceCounter counter;

    XOMASSERT( PreAuthData );
    XOMASSERT( SessionKey );
    XOMASSERT( ppServiceRequest );

    if (!NT_SUCCESS(piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog)) ||
        !NT_SUCCESS(piXboxLog->GetLogData( &pLogData )))
    {
        XomNtEvent(XEVENT_KDC_CODE_215, "Failed to get logging interface");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // validate all parameters
    if ( NULL == PreAuthData ||
         NULL == SessionKey  ||
         NULL == piReq       ||
         NULL == ppServiceRequest )
    {
        XomNtEvent( XEVENT_KDC_CODE_216,
            "(%s:%d) GetXenonServiceRequest3: invalid parameter.",
            __FILE__,
            __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // get the crypto provider
    status = m_pXkdc->GetIKerbCrypt(&pIKerbCrypt);
    if ( !NT_SUCCESS(status) || pIKerbCrypt == NULL )
    {
        XomNtEvent( XEVENT_KDC_CODE_217,
            "(%s:%d) GetXenonServiceRequest3: failed to get crypto provider.",
            __FILE__,
            __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // unpack the encrypted data
    KerbErr = m_pXkdc->GetKdcCore()->pfnKerbUnpackData(
        PreAuthData->value.preauth_data.value,
        PreAuthData->value.preauth_data.length,
        KERB_ENCRYPTED_DATA_PDU,
        (PVOID*) &EncryptedData
        );

    if ( !KERB_SUCCESS(KerbErr) )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        XomNtEvent(XEVENT_KDC_HACK_21,
            "GetXenonServiceRequest3: KerbUnpackData failed with KerbErr %S (0x%02X) from client %s.  Possible hack attempt.",
            m_pXkdc->KerbErrToString(KerbErr),
            KerbErr,
            inet_ntoa(*pInAddr));

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    status = pIKerbCrypt->GetChecksumSize(
        KERB_CHECKSUM_HMAC_MD5,
        &ulChecksumSize
        );

    if ( !NT_SUCCESS(status) )
    {
        XomNtEvent(XEVENT_KDC_CODE_218,
            "(%s:%d) GetXenonServiceRequest3: GetChecksumSize failed with status (0x%08X).",
            __FILE__,
            __LINE__,
            status);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    pChecksumBuffer = (BYTE*) m_pXkdc->GetKdcCore()->pfnKdcAllocMemory(ulChecksumSize);
    if ( NULL == pChecksumBuffer )
    {
        XomNtEvent(XEVENT_KDC_CODE_219,
            "(%s:%d) GetXenonServiceRequest3: failed to allocate %d bytes for checksum.",
            __FILE__,
            __LINE__,
            ulChecksumSize);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    pbNonce = (PBYTE)&(piReq->GetKdcRequest()->request_body.nonce);
    cbNonce = sizeof(ASN1int32_t);

    status = pIKerbCrypt->Checksum(
        KERB_CHECKSUM_HMAC_MD5,
        KERB_KDC_REQ_NONCE_CKSUM_SALT,
        SessionKey,
        &pbNonce,
        &cbNonce,
        1,
        NULL,
        0,
        pChecksumBuffer,
        &ulChecksumSize,
        NULL
        );

    if ( !NT_SUCCESS(status) )
    {
        XomNtEvent(XEVENT_KDC_CODE_220,
            "(%s:%d) GetXenonServiceRequest3: Checksum failed with status 0x%08X.",
            __FILE__,
            __LINE__,
            status);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    key.keytype = KERB_ETYPE_RC4_HMAC_NT;
    key.keyvalue.value = pChecksumBuffer;
    key.keyvalue.length = ulChecksumSize;

    // decrypt the preauth data
    KerbErr = pIKerbCrypt->Decrypt(
        EncryptedData,
        &key,
        KERB_PA_XBOX_SERVICE_REQUEST_SALT,
        EncryptedData->cipher_text.value,
        (PULONG) &EncryptedData->cipher_text.length
        );

    if ( !KERB_SUCCESS(KerbErr) )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        XomNtEvent( XEVENT_KDC_HACK_22,
            "GetXenonServiceRequest3: Decrypt of preauth data failed with KerbErr %S (0x%02X) from client %s.  Possible hack attempt.",
            m_pXkdc->KerbErrToString(KerbErr),
            KerbErr,
            inet_ntoa(*pInAddr));

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
        goto Cleanup;
    }

    if (EncryptedData->cipher_text.length != sizeof(XKERB_PA_XENON_SERVICE_REQUEST3))
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
        XomNtEvent(XEVENT_KDC_CODE_221,
            "GetXenonServiceRequest3: XKERB_PA_XENON_SERVICE_REQUEST3 size mismatch; expected %d bytes, received %d bytes from client %s.  Possible hack attempt.",
            sizeof(XKERB_PA_XENON_SERVICE_REQUEST3),
            EncryptedData->cipher_text.length,
            inet_ntoa(*pInAddr));

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
        goto Cleanup;
    }

    // create the service request...
    pServiceRequest = (PXKERB_PA_XENON_SERVICE_REQUEST3)m_pXkdc->KdcAllocMemory(sizeof(*pServiceRequest));
    if ( pServiceRequest == NULL )
    {
        XomNtEvent(XEVENT_KDC_CODE_222,
            "(%s:%d) GetXenonServiceRequest: failed to allocate %d bytes.",
            __FILE__,
            __LINE__,
            sizeof(*pServiceRequest));

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    *ppServiceRequest = pServiceRequest;

    memcpy( pServiceRequest, EncryptedData->cipher_text.value, sizeof(*pServiceRequest) );

    if ( pServiceRequest->wServiceRequestVersion < XONLINE_SERVICE_REQUEST3_MIN_VERSION ||
         pServiceRequest->wServiceRequestVersion > XONLINE_SERVICE_REQUEST3_MAX_VERSION)
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
        XomNtEvent(XEVENT_XKDC_INVALID_SERVICE_REQUEST_VERSION,
                "(%s:%d) CPAXboxRequestHandler::GetXenonServiceRequest3: %d wServiceRequestVersion requested by client %s.",
                __FILE__,
                __LINE__,
                pServiceRequest->wServiceRequestVersion,
                inet_ntoa(*pInAddr)
                );

        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) CPAXboxRequestHandler::GetXenonServiceRequest3: %d wServiceRequestVersion requested by client %s.",
                __FILE__,
                __LINE__,
                pServiceRequest->wServiceRequestVersion,
                inet_ntoa(*pInAddr)
                );

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    counter.Init(pServiceRequest);

    if ( counter.GetByteServiceCount() > XONLINE_XE_MAX_BYTE_SERVICEIDS_2 )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
        XomNtEvent(XEVENT_KDC_HACK_23,
            "CPAXboxRequestHandler::GetXenonServiceRequest: %d byte services requested by client %s, maximum allowed is %d.",
            counter.GetByteServiceCount(),
            inet_ntoa(*pInAddr),
            XONLINE_XE_MAX_BYTE_SERVICEIDS
            );

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    if ( counter.GetDwordServiceCount() > XONLINE_MAX_DWORD_SERVICEIDS )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
        XomNtEvent(XEVENT_KDC_HACK_24,
            "CPAXboxRequestHandler::GetXenonServiceRequest: %d DWORD services requested by client %s, maximum allowed is %d.",
            counter.GetDwordServiceCount(),
            inet_ntoa(*pInAddr),
            XONLINE_MAX_DWORD_SERVICEIDS
            );

        KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    pLogData->m_dwNumberOfRequestedServices = counter.GetTotalServiceCount();

    //
    // Bubble sort the services by service ID number
    //
    BubbleSort( pServiceRequest->dwServiceID, counter.GetDwordServiceCount() );

    XomTrace(Xkdc, L_LOW, "GetXenonServiceRequest3: version %d completed successfully.", pServiceRequest->wServiceRequestVersion);

Cleanup:
    if ( pChecksumBuffer != NULL )
    {
        m_pXkdc->GetKdcCore()->pfnKdcFreeMemory(pChecksumBuffer);
        pChecksumBuffer = NULL;
    }

    if ( EncryptedData != NULL )
    {
        if ( EncryptedData->cipher_text.value )
        {
            LocalFree(EncryptedData->cipher_text.value);
            EncryptedData->cipher_text.value = NULL;
        }
        //TODO: we should be calling ASN1Free but it is not exposed by the core
        LocalFree(EncryptedData);
        EncryptedData = NULL;
    }

    return KerbErr;
}

KERBERR
CPAXboxRequestHandler::ReturnXenonServiceAddress2(
    IN XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN IKerbRequest *piReq,
    OUT PKERB_PA_DATA_LIST *ppOutPadata
)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS status = STATUS_SUCCESS;
    IKerbCrypt *pIKerbCrypt = NULL;
    KERB_ENCRYPTED_DATA EncryptedData = {0};
    PKERB_PA_DATA_LIST ListElement = NULL;
    PBYTE pChecksumBuffer = NULL;
    ULONG ulChecksumSize = 0;
    PBYTE pbNonce;
    ULONG cbNonce;
    KERB_ENCRYPTION_KEY key;

    DWORD dwNumByteServices = 0;
    DWORD dwNumDwordServices = 0;

    XOMASSERT( pServiceAddress );
    XOMASSERT( SessionKey );
    XOMASSERT( piReq );
    XOMASSERT( ppOutPadata );
    if ( NULL == pServiceAddress || NULL == SessionKey || NULL == piReq || NULL == ppOutPadata )
    {
        XomNtEvent(XEVENT_KDC_CODE_226, "(%s:%d) ReturnXenonServiceAddress2: invalid parameter", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    XomTrace(Xkdc, L_LOW, "(%s:%d) CPAXboxRequestHandler::ReturnXenonServiceAddress2 entered.", __FILE__, __LINE__);

    XOMASSERT( m_pXenonServiceAddress2 );
    if ( NULL == m_pXenonServiceAddress2 )
    {
        XomNtEvent(XEVENT_KDC_CODE_227, "(%s:%d) ReturnXenonServiceAddress2: no XKERB_PA_XENON_SERVICE_ADDRESS struct allocated.  Is this an Xbox1 request?", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // fill out XKERB_PA_XENON_SERVICE_ADDRESS2 struct
    m_pXenonServiceAddress2->hr = pServiceAddress->hr;
    for (int i=0; i < XONLINE_MAX_LOGON_USERS; i++)
    {
        m_pXenonServiceAddress2->hrUser[i] = pServiceAddress->hrUser[i];
        m_pXenonServiceAddress2->dwUserFlags[i] = pServiceAddress->dwUserFlags[i];
        for (int j=0; j < XONLINE_NUM_PRIVILEGE_DWORDS; j++)
        {
            m_pXenonServiceAddress2->dwUserPrivileges[i][j] = pServiceAddress->dwUserPrivileges[i][j];
        }
    }
    m_pXenonServiceAddress2->dwBwLimit = pServiceAddress->dwBwLimit;
    m_pXenonServiceAddress2->siteIPAddress = pServiceAddress->siteIPAddress;

    m_pXenonServiceAddress2->wNumServices = (WORD) pServiceAddress->dwNumServices;

    // byte and dword service results
    for (DWORD i=0; i < pServiceAddress->dwNumServices; i++)
    {
        DWORD dwServiceID = pServiceAddress->ServiceResult[i].dwServiceID;

        if ( dwServiceID < XONLINE_MAX_PRIVILEGE_ID )
        {
            if(dwNumByteServices >= XONLINE_XE_MAX_BYTE_SERVICEIDS)
            {
                XomNtEvent(XEVENT_KDC_CODE_228, "ReturnXenonServiceAddress: too many BYTE services for user 0x%I64x, title 0x%x", m_policyData.users[0].qwUserID, pServiceAddress->dwLiveTitleId);
                KerbErr = KDC_ERR_SVC_UNAVAILABLE;
                goto Cleanup;
            }

            m_pXenonServiceAddress2->byteServiceResult[dwNumByteServices].bServiceID   = (BYTE) dwServiceID;
            m_pXenonServiceAddress2->byteServiceResult[dwNumByteServices].wServicePort = pServiceAddress->ServiceResult[i].wServicePort;
            m_pXenonServiceAddress2->byteServiceResult[dwNumByteServices].bResult      = pServiceAddress->ServiceResult[i].bResult;

            dwNumByteServices++;
        }
        else
        {
            if(dwNumDwordServices >= XONLINE_MAX_DWORD_SERVICEIDS)
            {
                XomNtEvent(XEVENT_KDC_CODE_229, "ReturnXenonServiceAddress: too many DWORD services for user 0x%I64x, title 0x%x", m_policyData.users[0].qwUserID, pServiceAddress->dwLiveTitleId);
                KerbErr = KDC_ERR_SVC_UNAVAILABLE;
                goto Cleanup;
            }

            m_pXenonServiceAddress2->dwordServiceResult[dwNumDwordServices].dwServiceID  = dwServiceID;
            m_pXenonServiceAddress2->dwordServiceResult[dwNumDwordServices].wServicePort = pServiceAddress->ServiceResult[i].wServicePort;
            m_pXenonServiceAddress2->dwordServiceResult[dwNumDwordServices].bResult      = pServiceAddress->ServiceResult[i].bResult;

            dwNumDwordServices++;
        }
    }
    XOMASSERT( dwNumByteServices <= XONLINE_XE_MAX_BYTE_SERVICEIDS );
    XOMASSERT( dwNumDwordServices <= XONLINE_MAX_DWORD_SERVICEIDS );

    // Live title-id
    m_pXenonServiceAddress2->dwLiveTitleId = pServiceAddress->dwLiveTitleId;

    // per-service title id remapping
    for (DWORD i=0; i < XONLINE_MAX_SERVICE_ALTERNATE_TITLE_ID; i++)
    {
        m_pXenonServiceAddress2->altLiveTitleIds[i] = pServiceAddress->altLiveTitleIds[i];
    }

    XOMASSERT( m_pXkdc && m_pXkdc->GetKdcCore() );
    if ( NULL == m_pXkdc || NULL == m_pXkdc->GetKdcCore() )
    {
        XomNtEvent(XEVENT_KDC_CODE_230, "(%s:%d) ReturnXenonServiceAddress2: invalid provider handle.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    XomTrace(Xkdc, L_LOW, "(%s:%d) ReturnXenonServiceAddress2: hr: 0x%08X", __FILE__, __LINE__, m_pXenonServiceAddress2->hr);

    for(DWORD i=0; i < ARRAYSIZE(m_pXenonServiceAddress2->hrUser); i++)
    {
        XomTrace(Xkdc, L_LOW, "ReturnXenonServiceAddress2: hrUser[%u]: 0x%08X dwUserPrivileges[%u][]: 0x%08X %08X %08X %08X %08X %08X %08X %08X",
            i,
            m_pXenonServiceAddress2->hrUser[i],
            i,
            m_pXenonServiceAddress2->dwUserPrivileges[i][0],
            m_pXenonServiceAddress2->dwUserPrivileges[i][1],
            m_pXenonServiceAddress2->dwUserPrivileges[i][2],
            m_pXenonServiceAddress2->dwUserPrivileges[i][3],
            m_pXenonServiceAddress2->dwUserPrivileges[i][4],
            m_pXenonServiceAddress2->dwUserPrivileges[i][5],
            m_pXenonServiceAddress2->dwUserPrivileges[i][6],
            m_pXenonServiceAddress2->dwUserPrivileges[i][7] );
    }

    XomTrace(Xkdc, L_LOW, "(%s:%d) ReturnXenonServiceAddress2: dwBwLimit: %d", __FILE__, __LINE__, m_pXenonServiceAddress2->dwBwLimit);
    {
        CHAR szSiteAddr[16] = {0};
        lstrcpynA(szSiteAddr, inet_ntoa(m_pXenonServiceAddress2->siteIPAddress), ARRAYSIZE(szSiteAddr));
        XomTrace(Xkdc, L_LOW, "(%s:%d) ReturnXenonServiceAddress: siteIPAddress: %s", __FILE__, __LINE__, szSiteAddr);
    }
    XomTrace(Xkdc, L_LOW, "(%s:%d) ReturnXenonServiceAddress2: wNumServices: %d", __FILE__, __LINE__, m_pXenonServiceAddress2->wNumServices);

    KerbErr = ReturnServiceAddress(
        (PVOID) m_pXenonServiceAddress2,
        sizeof(*m_pXenonServiceAddress2),
        KRB5_PADATA_XENON_SERVICE_ADDRESS2,
        SessionKey,
        piReq,
        ppOutPadata);

    XomTrace(Xkdc, L_LOW, "(%s:%d) CPAXboxRequestHandler::ReturnXenonServiceAddress2 completed.", __FILE__, __LINE__);

 Cleanup:
    return KerbErr;
}

//
// Helpers for the new byte service layout. We can now represent 128 services (0 -127).
// Each service is always passed back to the client as a two-bit value.
// These helpers make it easier to deal with them. In general, you will only
// call SetServiceStatus and GetServiceStatus directly.
//

const size_t BITS_PER_SERVICE = 2;
const size_t SERVICES_PER_BYTE = 8 / BITS_PER_SERVICE;
const BYTE SERVICE_BIT_MASK = 0x03;

static inline size_t GetByteIndex(size_t pos)
{
    return pos / SERVICES_PER_BYTE;
}

static inline size_t GetNibblePosition(size_t pos)
{
    return pos % SERVICES_PER_BYTE;
}

static inline size_t ShiftAmountFromNibble(size_t nibble)
{
    return nibble * BITS_PER_SERVICE;
}

static inline BYTE SetNthNibble(BYTE b, size_t nibble, BYTE value)
{
    size_t const shift = ShiftAmountFromNibble(nibble);
    return (b & ~(SERVICE_BIT_MASK << shift)) | (value << shift);
}

static inline BYTE GetNthNibble(BYTE b, size_t nibble)
{
    size_t const shift = ShiftAmountFromNibble(nibble);
    return b & (SERVICE_BIT_MASK << shift) << shift;
}

template<size_t N>
static inline void SetServiceStatus(BYTE (&rgServices)[N], size_t const serviceId, BYTE const status)
{
    C_ASSERT( N == XONLINE_XE_NUM_BYTES_FOR_BYTE_SERVICES_ADDRESS );
    XOMASSERT( serviceId < XONLINE_XE_MAX_BYTE_SERVICEIDS_2);
    XOMASSERT( status <= SERVICE_BIT_MASK ); // BYTE is unsigned, so status can't be less than 0.

    size_t const byteIndex = GetByteIndex(serviceId);
    BYTE const byteOrig = rgServices[byteIndex];
    rgServices[byteIndex] = SetNthNibble(byteOrig, GetNibblePosition(serviceId), status);
}

template<size_t N>
static inline BYTE GetServiceStatus(BYTE (&rgServices)[N], size_t const serviceId)
{
    return GetNthNibble(rgServices[GetByteIndex(serviceId)], GetNibblePosition(serviceId));
}


KERBERR
CPAXboxRequestHandler::ReturnXenonServiceAddress3(
    IN XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN IKerbRequest *piReq,
    OUT PKERB_PA_DATA_LIST *ppOutPadata
)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS status = STATUS_SUCCESS;
    IKerbCrypt *pIKerbCrypt = NULL;
    KERB_ENCRYPTED_DATA EncryptedData = {0};
    PKERB_PA_DATA_LIST ListElement = NULL;
    PBYTE pChecksumBuffer = NULL;
    ULONG ulChecksumSize = 0;
    PBYTE pbNonce;
    ULONG cbNonce;
    KERB_ENCRYPTION_KEY key;

    DWORD dwNumDwordServices = 0;

    XOMASSERT( pServiceAddress );
    XOMASSERT( SessionKey );
    XOMASSERT( piReq );
    XOMASSERT( ppOutPadata );
    if ( NULL == pServiceAddress || NULL == SessionKey || NULL == piReq || NULL == ppOutPadata )
    {
        XomNtEvent(XEVENT_KDC_CODE_226, "(%s:%d) ReturnXenonServiceAddress3: invalid parameter", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    XomTrace(Xkdc, L_LOW, "(%s:%d) CPAXboxRequestHandler::ReturnXenonServiceAddress3 entered.", __FILE__, __LINE__);

    XOMASSERT( m_pXenonServiceAddress3 );
    if ( NULL == m_pXenonServiceAddress3 )
    {
        XomNtEvent(XEVENT_KDC_CODE_227, "(%s:%d) ReturnXenonServiceAddress3: no XKERB_PA_XENON_SERVICE_ADDRESS struct allocated.  Is this an Xbox1 request?", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // fill out XKERB_PA_XENON_SERVICE_ADDRESS3 struct
    m_pXenonServiceAddress3->hr = pServiceAddress->hr;
    for (int i=0; i < XONLINE_MAX_LOGON_USERS; i++)
    {
        m_pXenonServiceAddress3->hrUser[i] = pServiceAddress->hrUser[i];
        m_pXenonServiceAddress3->dwUserFlags[i] = pServiceAddress->dwUserFlags[i];

        // The fifth DWORD of all the users is actually the machine privileges, which
        // must be all the same (it's the same machine, after all). So we only actually
        // return the last three DWORDs for user privileges, and the first is a seperate
        // field.
        XOMASSERT(pServiceAddress->dwUserPrivileges[i][XONLINE_NUM_BASE_SERVICES_DWORDS] == pServiceAddress->dwUserPrivileges[0][XONLINE_NUM_BASE_SERVICES_DWORDS]);

        for (int j=0; j < XONLINE_NUM_USER_PRIVILEGES_DWORDS; j++)
        {
            m_pXenonServiceAddress3->dwUserPrivileges[i][j] = pServiceAddress->dwUserPrivileges[i][j+XONLINE_FIRST_USER_PRIVILEGE_DWORD_INDEX];
        }
    }
    m_pXenonServiceAddress3->dwMachinePrivileges = pServiceAddress->dwUserPrivileges[0][XONLINE_NUM_BASE_SERVICES_DWORDS];

    m_pXenonServiceAddress3->siteIPAddress = pServiceAddress->siteIPAddress;

    // byte and dword service results
    FillMemory(m_pXenonServiceAddress3->byteServiceResult, _countof(m_pXenonServiceAddress3->byteServiceResult), 0xFF);
    for (DWORD i=0; i < pServiceAddress->dwNumServices; i++)
    {
        DWORD dwServiceID = pServiceAddress->ServiceResult[i].dwServiceID;

        if ( dwServiceID < XONLINE_XE_MAX_BYTE_SERVICEIDS_2 )
        {
            SetServiceStatus(m_pXenonServiceAddress3->byteServiceResult, dwServiceID, pServiceAddress->ServiceResult[i].bResult);
        }
        else
        {
            if(dwNumDwordServices >= _countof(m_pXenonServiceAddress3->dwordServiceResult))
            {
                XomNtEvent(XEVENT_KDC_CODE_229, "ReturnXenonServiceAddress: too many DWORD services for user 0x%I64x, title 0x%x", m_policyData.users[0].qwUserID, pServiceAddress->dwLiveTitleId);
                KerbErr = KDC_ERR_SVC_UNAVAILABLE;
                goto Cleanup;
            }

            m_pXenonServiceAddress3->dwordServiceResult[dwNumDwordServices].dwServiceID  = dwServiceID;
            m_pXenonServiceAddress3->dwordServiceResult[dwNumDwordServices].wServicePort = pServiceAddress->ServiceResult[i].wServicePort;
            m_pXenonServiceAddress3->dwordServiceResult[dwNumDwordServices].bResult      = pServiceAddress->ServiceResult[i].bResult;

            dwNumDwordServices++;
        }
    }
    XOMASSERT( dwNumDwordServices <= _countof(m_pXenonServiceAddress3->dwordServiceResult) );

    // Live title-id
    m_pXenonServiceAddress3->dwLiveTitleId = pServiceAddress->dwLiveTitleId;

    // per-service title id remapping
    for (DWORD i=0; i < XONLINE_MAX_SERVICE_ALTERNATE_TITLE_ID; i++)
    {
        m_pXenonServiceAddress3->altLiveTitleIds[i] = pServiceAddress->altLiveTitleIds[i];
    }

    // flow token
    m_pXenonServiceAddress3->flowToken = pServiceAddress->flowToken;

    XOMASSERT( m_pXkdc && m_pXkdc->GetKdcCore() );
    if ( NULL == m_pXkdc || NULL == m_pXkdc->GetKdcCore() )
    {
        XomNtEvent(XEVENT_KDC_CODE_230, "(%s:%d) ReturnXenonServiceAddress3: invalid provider handle.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    XomTrace(Xkdc, L_LOW, "ReturnXenonServiceAddress3: hr: 0x%08X dwMachinePrivileges: 0x%08X", 
        m_pXenonServiceAddress3->hr, 
        m_pXenonServiceAddress3->dwMachinePrivileges
        );

    for(DWORD i=0; i < ARRAYSIZE(m_pXenonServiceAddress3->hrUser); i++)
    {
        XomTrace(Xkdc, L_LOW, "ReturnXenonServiceAddress3: hrUser[%u]: 0x%08X dwUserPrivileges[%u][]: 0x%08X %08X %08X",
            i,
            m_pXenonServiceAddress3->hrUser[i],
            i,
            m_pXenonServiceAddress3->dwUserPrivileges[i][0],
            m_pXenonServiceAddress3->dwUserPrivileges[i][1],
            m_pXenonServiceAddress3->dwUserPrivileges[i][2]
            );
    }

    {
        CHAR szSiteAddr[16] = {0};
        lstrcpynA(szSiteAddr, inet_ntoa(m_pXenonServiceAddress3->siteIPAddress), ARRAYSIZE(szSiteAddr));
        XomTrace(Xkdc, L_LOW, "(%s:%d) ReturnXenonServiceAddress: siteIPAddress: %s", __FILE__, __LINE__, szSiteAddr);
    }

    KerbErr = ReturnServiceAddress(
        (PVOID) m_pXenonServiceAddress3,
        sizeof(*m_pXenonServiceAddress3),
        KRB5_PADATA_XENON_SERVICE_ADDRESS3,
        SessionKey,
        piReq,
        ppOutPadata);

    XomTrace(Xkdc, L_LOW, "(%s:%d) CPAXboxRequestHandler::ReturnXenonServiceAddress3 completed.", __FILE__, __LINE__);

 Cleanup:
    return KerbErr;
}

KERBERR
CPAXboxRequestHandler::ReturnXenonServiceAddressFailed(
    IN XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN IKerbRequest *piReq,
    OUT PKERB_PA_DATA_LIST *ppOutPadata
)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS status = STATUS_SUCCESS;
    IKerbCrypt *pIKerbCrypt = NULL;
    KERB_ENCRYPTED_DATA EncryptedData = {0};
    PKERB_PA_DATA_LIST ListElement = NULL;
    PBYTE pChecksumBuffer = NULL;
    ULONG ulChecksumSize = 0;
    PBYTE pbNonce;
    ULONG cbNonce;
    KERB_ENCRYPTION_KEY key;

    DWORD dwNumDwordServices = 0;

    XOMASSERT( pServiceAddress );
    XOMASSERT( SessionKey );
    XOMASSERT( piReq );
    XOMASSERT( ppOutPadata );
    if ( NULL == pServiceAddress || NULL == SessionKey || NULL == piReq || NULL == ppOutPadata )
    {
        XomNtEvent(XEVENT_KDC_CODE_226, "(%s:%d) ReturnXenonServiceAddressFailed: invalid parameter", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    XomTrace(Xkdc, L_LOW, "(%s:%d) CPAXboxRequestHandler::ReturnXenonServiceAddressFailed entered.", __FILE__, __LINE__);

    XOMASSERT( m_pXenonServiceAddressFailed );
    if ( NULL == m_pXenonServiceAddressFailed )
    {
        XomNtEvent(XEVENT_KDC_CODE_227, "(%s:%d) ReturnXenonServiceAddressFailed: no XKERB_PA_XENON_SERVICE_ADDRESS_FAILED struct allocated.  Is this an Xbox1 request?", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // fill out XKERB_PA_XENON_SERVICE_ADDRESS_FAILED struct
    m_pXenonServiceAddressFailed->hrConsole = pServiceAddress->hr;
    m_pXenonServiceAddressFailed->ftConsoleBanExpireTime = pServiceAddress->ftXboxConsoleResumeDate;

    for (int i=0; i < XONLINE_MAX_LOGON_USERS; i++)
    {
        m_pXenonServiceAddressFailed->hrUser[i] = pServiceAddress->hrUser[i];
        m_pXenonServiceAddressFailed->ftUserBanExpireTime[i] = pServiceAddress->ftUserAccountResumeDate[i];
    }

    XOMASSERT( m_pXkdc && m_pXkdc->GetKdcCore() );
    if ( NULL == m_pXkdc || NULL == m_pXkdc->GetKdcCore() )
    {
        XomNtEvent(XEVENT_KDC_CODE_230, "(%s:%d) ReturnXenonServiceAddressFailed: invalid provider handle.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    XomTrace(Xkdc, L_LOW, "(%s:%d) ReturnXenonServiceAddressFailed: hr: 0x%08X", __FILE__, __LINE__, m_pXenonServiceAddressFailed->hrConsole);

    for(DWORD i=0; i < ARRAYSIZE(m_pXenonServiceAddressFailed->hrUser); i++)
    {
        XomTrace(Xkdc, L_LOW, "ReturnXenonServiceAddressFailed: hrUser[%u]: 0x%08X",
            i,
            m_pXenonServiceAddressFailed->hrUser[i]
            );
    }

    KerbErr = ReturnServiceAddress(
        (PVOID) m_pXenonServiceAddressFailed,
        sizeof(*m_pXenonServiceAddressFailed),
        KRB5_PADATA_XENON_SERVICE_ADDRESS_FAILED,
        SessionKey,
        piReq,
        ppOutPadata);

    XomTrace(Xkdc, L_LOW, "(%s:%d) CPAXboxRequestHandler::ReturnXenonServiceAddressFailed completed.", __FILE__, __LINE__);

 Cleanup:
    return KerbErr;
}

KERBERR
CPAXboxRequestHandler::ReturnServiceAddress(
    IN PVOID pPreAuthData,
    IN size_t dwPreauthDataSize,
    IN DWORD dwPreauthType,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN IKerbRequest *piReq,
    OUT PKERB_PA_DATA_LIST *ppOutPadata
)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS status = STATUS_SUCCESS;
    IKerbCrypt *pIKerbCrypt = NULL;
    KERB_ENCRYPTED_DATA EncryptedData = {0};
    PKERB_PA_DATA_LIST ListElement = NULL;
    PBYTE pChecksumBuffer = NULL;
    ULONG ulChecksumSize = 0;
    PBYTE pbNonce;
    ULONG cbNonce;
    KERB_ENCRYPTION_KEY key;

    XOMASSERT( pPreAuthData );
    XOMASSERT( dwPreauthDataSize > 0 );
    XOMASSERT( SessionKey );
    XOMASSERT( piReq );
    XOMASSERT( ppOutPadata );
    if ( NULL == pPreAuthData || 0 == dwPreauthDataSize || NULL == SessionKey || NULL == piReq || NULL == ppOutPadata )
    {
        XomNtEvent(XEVENT_KDC_CODE_231, "(%s:%d) ReturnServiceAddress: invalid parameter", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    XOMASSERT( m_pXkdc && m_pXkdc->GetKdcCore() );
    if ( NULL == m_pXkdc || NULL == m_pXkdc->GetKdcCore() )
    {
        XomNtEvent(XEVENT_KDC_CODE_232, "(%s:%d) ReturnServiceAddress: invalid provider handle.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // get the crypto provider
    status = m_pXkdc->GetIKerbCrypt(&pIKerbCrypt);
    if ( !NT_SUCCESS(status) || pIKerbCrypt == NULL )
    {
        XomNtEvent(XEVENT_KDC_CODE_233, "(%s:%d) ReturnServiceAddress: invalid crypto provider.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    KerbErr = pIKerbCrypt->GetCiphertextSize(
                KERB_ETYPE_RC4_HMAC_NT,
                dwPreauthDataSize,
                &EncryptedData.cipher_text.length
                );

    if ( !KERB_SUCCESS(KerbErr) )
    {
        XomTrace(Xkdc, L_ERROR, "(%s:%d) ReturnServiceAddress: GetCiphertextSize failed with KerbErr %d.", __FILE__, __LINE__, KerbErr);
        goto Cleanup;
    }

    EncryptedData.cipher_text.value = (ASN1octet_t*) m_pXkdc->KdcAllocMemory( EncryptedData.cipher_text.length );
    if ( NULL == EncryptedData.cipher_text.value )
    {
        XomNtEvent(XEVENT_KDC_CODE_234, "(%s:%d) ReturnServiceAddress: failed to allocate %d bytes for EncryptedData wrapper.", __FILE__, __LINE__, EncryptedData.cipher_text.length);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
    }

    status = pIKerbCrypt->GetChecksumSize(
              KERB_CHECKSUM_HMAC_MD5,
              &ulChecksumSize
              );
    if ( !NT_SUCCESS(status) )
    {
        XomTrace(Xkdc, L_ERROR, "(%s:%d) ReturnServiceAddress: GetChecksumSize failed with status %d.", __FILE__, __LINE__, status);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    pChecksumBuffer = (BYTE*) m_pXkdc->GetKdcCore()->pfnKdcAllocMemory(ulChecksumSize);
    if ( NULL == pChecksumBuffer )
    {
        XomNtEvent(XEVENT_KDC_CODE_235, "(%s:%d) ReturnServiceAddress: failed to allocate %d bytes for checksum.", __FILE__, __LINE__, ulChecksumSize);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    pbNonce = (PBYTE)&(piReq->GetKdcRequest()->request_body.nonce);
    cbNonce = sizeof(ASN1int32_t);

    status = pIKerbCrypt->Checksum(
              KERB_CHECKSUM_HMAC_MD5,
              KERB_KDC_REQ_NONCE_CKSUM_SALT,
                SessionKey,
                &pbNonce,
                &cbNonce,
                1,
                NULL,
                0,
                pChecksumBuffer,
                &ulChecksumSize,
                NULL
                );
    if ( !NT_SUCCESS(status) )
    {
        XomTrace(Xkdc, L_ERROR, "(%s:%d) ReturnServiceAddress: Checksum failed with error %d.", __FILE__, __LINE__, status);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    key.keytype = KERB_ETYPE_RC4_HMAC_NT;
    key.keyvalue.value = pChecksumBuffer;
    key.keyvalue.length = ulChecksumSize;

    KerbErr = pIKerbCrypt->Encrypt(
                &key,
                1, // TODO: key version??? what should I really use here???
                KERB_PA_XBOX_SERVICE_ADDRESS_SALT,
                (PUCHAR) pPreAuthData,
                dwPreauthDataSize,
                &EncryptedData
                );
    if ( !KERB_SUCCESS(KerbErr) )
    {
        XomTrace(Xkdc, L_ERROR, "(%s:%d) ReturnServiceAddress: Encrypt failed with error %d.", __FILE__, __LINE__, KerbErr);
        goto Cleanup;
    }

    ListElement = (PKERB_PA_DATA_LIST) m_pXkdc->KdcAllocMemory(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        XomNtEvent(XEVENT_KDC_CODE_236, "(%s:%d) ReturnServiceAddress: failed to allocate %d bytes.", __FILE__, __LINE__, sizeof(KERB_PA_DATA_LIST));
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    KerbErr = m_pXkdc->GetKdcCore()->pfnKerbPackData(
                (PVOID) &EncryptedData,
                KERB_ENCRYPTED_DATA_PDU,
                (PULONG) &ListElement->value.preauth_data.length,
                (PUCHAR *) &ListElement->value.preauth_data.value
                );
    if ( !KERB_SUCCESS(KerbErr) )
    {
        XomTrace(Xkdc, L_ERROR, "(%s:%d) ReturnServiceAddress: KerbPackData failed with error %d.", __FILE__, __LINE__, KerbErr);
        goto Cleanup;
    }

    ListElement->value.preauth_data_type = dwPreauthType;
    ListElement->next = *ppOutPadata;
    *ppOutPadata = ListElement;
    ListElement = NULL;

    XomTrace(Xkdc, L_LOW, "(%s:%d) ReturnServiceAddress: completed successfully.  Added %d bytes to return preauth list.", __FILE__, __LINE__, dwPreauthDataSize);

 Cleanup:
    if ( pChecksumBuffer != NULL )
    {
        m_pXkdc->GetKdcCore()->pfnKdcFreeMemory(pChecksumBuffer);
        pChecksumBuffer = NULL;
    }

    if ( ListElement != NULL )
    {
        m_pXkdc->KdcFreeMemory(ListElement);
        ListElement = NULL;
    }

    if ( EncryptedData.cipher_text.value )
    {
        m_pXkdc->KdcFreeMemory(EncryptedData.cipher_text.value);
        EncryptedData.cipher_text.value = NULL;
        EncryptedData.cipher_text.length = 0;
    }

    return KerbErr;
}


CPAXboxRequestHandlerFactory::CPAXboxRequestHandlerFactory(IN CXkdcProvider *pXkdc) :
    m_pXkdc(pXkdc)
{
}


NTSTATUS __stdcall
CPAXboxRequestHandlerFactory::CreateInstance(
    IN  IKerbRequest    *piReq,
    OUT IPAHandler      **ppIPAHandler
)
{
    XOMASSERT( ppIPAHandler );
    if ( NULL == ppIPAHandler )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_22, "(%s:%d) CreateInstance: invalid parameter.", __FILE__, __LINE__);
        return STATUS_INVALID_PARAMETER_2;
    }
    *ppIPAHandler = NULL;

    XOMASSERT( piReq );
    XOMASSERT( m_pXkdc );

    *ppIPAHandler = new CPAXboxRequestHandler(m_pXkdc, KRB5_PADATA_XBOX_SERVICE_REQUEST_DEPRACATED);
    if ( *ppIPAHandler == NULL )
    {
        XomNtEvent(XEVENT_XKDC_NO_MEMORY_11, "(%s:%d) CreateInstance: failed to instantiate CPAXboxRequestHandler.", __FILE__, __LINE__);
        return STATUS_NO_MEMORY;
    }

    XomTrace(Xkdc, L_LOW, "(%s:%d) CreateInstance: completed successfully.", __FILE__, __LINE__);

    return STATUS_SUCCESS;
}


CPAXenonRequest2HandlerFactory::CPAXenonRequest2HandlerFactory(IN CXkdcProvider *pXkdc) :
    m_pXkdc(pXkdc)
{
}


NTSTATUS __stdcall
CPAXenonRequest2HandlerFactory::CreateInstance(
    IN  IKerbRequest    *piReq,
    OUT IPAHandler      **ppIPAHandler
)
{
    XOMASSERT( ppIPAHandler );
    if ( NULL == ppIPAHandler )
    {
        XomNtEvent(XEVENT_KDC_CODE_239, "(%s:%d) CreateInstance: invalid parameter.", __FILE__, __LINE__);
        return STATUS_INVALID_PARAMETER_2;
    }
    *ppIPAHandler = NULL;

    XOMASSERT( piReq );
    XOMASSERT( m_pXkdc );

    *ppIPAHandler = new CPAXboxRequestHandler(m_pXkdc, KRB5_PADATA_XENON_SERVICE_REQUEST2);
    if ( *ppIPAHandler == NULL )
    {
        XomNtEvent(XEVENT_KDC_CODE_240, "(%s:%d) CreateInstance: failed to instantiate CPAXboxRequestHandler.", __FILE__, __LINE__);
        return STATUS_NO_MEMORY;
    }

    XomTrace(Xkdc, L_LOW, "(%s:%d) CreateInstance: completed successfully.", __FILE__, __LINE__);

    return STATUS_SUCCESS;
}

CPAXenonRequest3HandlerFactory::CPAXenonRequest3HandlerFactory(IN CXkdcProvider *pXkdc) :
    m_pXkdc(pXkdc)
{
}


NTSTATUS __stdcall
CPAXenonRequest3HandlerFactory::CreateInstance(
    IN  IKerbRequest    *piReq,
    OUT IPAHandler      **ppIPAHandler
)
{
    XOMASSERT( ppIPAHandler );
    if ( NULL == ppIPAHandler )
    {
        XomNtEvent(XEVENT_KDC_CODE_239, "(%s:%d) CreateInstance: invalid parameter.", __FILE__, __LINE__);
        return STATUS_INVALID_PARAMETER_2;
    }
    *ppIPAHandler = NULL;

    XOMASSERT( piReq );
    XOMASSERT( m_pXkdc );

    *ppIPAHandler = new CPAXboxRequestHandler(m_pXkdc, KRB5_PADATA_XENON_SERVICE_REQUEST3);
    if ( *ppIPAHandler == NULL )
    {
        XomNtEvent(XEVENT_KDC_CODE_240, "(%s:%d) CreateInstance: failed to instantiate CPAXboxRequestHandler.", __FILE__, __LINE__);
        return STATUS_NO_MEMORY;
    }

    XomTrace(Xkdc, L_LOW, "(%s:%d) CreateInstance: completed successfully.", __FILE__, __LINE__);

    return STATUS_SUCCESS;
}



//-------------------------------------------------------------------


//-------------------------------------------------------------------
//  Local Functions.
//-------------------------------------------------------------------

//
// Bubble sort a given array
//
void BubbleSort( DWORD *paArray, DWORD dwSize )
{
    DWORD i = 0;
    DWORD j = 0;

    XOMASSERT( paArray != NULL );

    if ( 0 == dwSize )
    {
        return;
    }

    //
    // Bubble sort the services by service ID number
    //
    for ( i = 0; i < ( dwSize - 1 ); ++i )
    {
        for ( j = i + 1 ; j < dwSize ; ++j )
        {
            if ( paArray[i] > paArray[j] )
            {
                DWORD dwTempServiceID = paArray[i];
                paArray[i] = paArray[j];
                paArray[j] = dwTempServiceID;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcPrincipal.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "xkdc.h"

CXkdcPrincipal::CXkdcPrincipal()
    : CXBasePrincipal(),
      m_pkinServiceName(NULL),
      m_dwRefCount(0),
      m_dwSiteIPAddress(0),
      m_dwServiceID(0),
      m_dwTitleID(0),
      m_dwTitleVersion(0),
      m_dwTitleRegion(0),
      m_wServicePort(0),
      m_bMachineOnly(FALSE),
      m_bServiceAvailable(FALSE),
      m_dwAuthdataVersion(XONLINE_XENON_AUTHDATA_VERSION)
{
}

CXkdcPrincipal::~CXkdcPrincipal()
{
    if ( m_pkinServiceName )
    {
        KdcFreeMemory(m_pkinServiceName);
        m_pkinServiceName = NULL;
    }
}

void
__stdcall
CXkdcPrincipal::Release(void)
{
    XOMASSERT( m_dwRefCount > 0 );
    const KERB_INTERNAL_NAME *pName = this->GetName();
    XOMASSERT( 2 == pName->NameCount );
    if ( 0 == InterlockedDecrement((LONG*) &m_dwRefCount) )
    {
        XomTrace(Xkdc, L_LOW, "CXkdcPrincipal::Release: destroying principal '%S/%S'.", pName->Names[0].Buffer, pName->Names[1].Buffer);
        delete this;
    }
    else
    {
        XomTrace(Xkdc, L_LOW, "CXkdcPrincipal::Release: not destroying cached principal '%S/%S'. (outstanding refs: %d)", pName->Names[0].Buffer, pName->Names[1].Buffer, m_dwRefCount);
    }
}

const KERB_INTERNAL_NAME *
__stdcall
CXkdcPrincipal::GetName()
{
    return CXBasePrincipal::GetName();
}

PKERB_INTERNAL_NAME
__stdcall
CXkdcPrincipal::GetCanonicalName()
{
    return CXBasePrincipal::GetCanonicalName();
}

NTSTATUS
__stdcall
CXkdcPrincipal::Initialize(
    IN    IKdbProvider             *pIKdbProvider,
    IN    IKdcCore                 *pIKdcCore,
    IN    PUNICODE_STRING           pustrRealm,
    IN    XKDC_PRINCIPAL           *pKdbPrinc,
    IN    XkdcCredential           *pCred,
    IN    LPCWSTR                   pwszServiceName,
    IN    LPCWSTR                   pwszDomainName,
    IN    DWORD                     dwSiteIPAddress,
    IN    DWORD                     dwServiceID,
    IN    DWORD                     dwTitleID,
    IN    DWORD                     dwTitleVersion,
    IN    DWORD                     dwTitleRegion,
    IN    WORD                      wServicePort,
    IN    BOOL                      bMachineOnly,
    IN    BOOL                      bServiceAvailable,
    IN    DWORD                     dwAuthdataVersion,
    IN    LARGE_INTEGER             MaxLifeTime,
    IN    LARGE_INTEGER             MaxRenewTime,
    IN    INT                       LastModified,
    IN    INT                       Expiration,
    IN    PRINC_DATA_FLAGS          PrincDataFlags
)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING ServiceName = {0};
    UNICODE_STRING DomainName = {0};

    // initialize all components of base principal
    status = CXBasePrincipal::Initialize(
                pIKdbProvider,
                pIKdcCore,
                pustrRealm,
                pKdbPrinc,
                pCred,
                MaxLifeTime,
                MaxRenewTime,
                LastModified,
                Expiration,
                PrincDataFlags);
    if ( !NT_SUCCESS(status) )
    {
        goto Cleanup;
    }

    // initialize the Xbox service name, site IP address, and port
    RtlInitUnicodeString(&ServiceName, pwszServiceName);
    RtlInitUnicodeString(&DomainName, pwszDomainName);

    status = m_pIKdcCore->pfnKerbBuildFullServiceKdcName(
                &DomainName,
                &ServiceName,
                KRB_NT_SRV_INST,
                &m_pkinServiceName
                );
    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    m_dwSiteIPAddress = dwSiteIPAddress;
    m_dwServiceID = dwServiceID;
    m_dwTitleID = dwTitleID;
    m_dwTitleVersion = dwTitleVersion;
    m_dwTitleRegion = dwTitleRegion;
    m_wServicePort = wServicePort;
    m_bMachineOnly = bMachineOnly;
    m_bServiceAvailable = bServiceAvailable;
    m_dwAuthdataVersion = dwAuthdataVersion;

    // now add a reference
    XOMASSERT( 0 == m_dwRefCount );
    AddRef();
    XOMASSERT( 1 == m_dwRefCount );

Cleanup:
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcProvider.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
//------------------------------------------------------------------------------------
#define DEPRECATE_SUPPORTED

#include "xkdc.h"
#include "XkdcMachineCache.h"
#include "ManagedProxyMemory.h"

void xlog5(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}


#include <wincrypt.h>
#include <crypto/modes.h>

// management output areas
XomDefineArea(log);
XomDefineArea(KdcBase);
XomDefineArea(Policy);
XomDefineArea(Xkdc);
XomDefineArea(XkdcTicketLog);

//------------------------------------------------------------------------------------
// global reference to Xkdc provider object
//------------------------------------------------------------------------------------
CXkdcProvider *g_pXkdcProvider = NULL;

//------------------------------------------------------------------------------------
// global reference to extension handler objects
//------------------------------------------------------------------------------------
CPAXboxRequestHandlerFactory *gPAXboxFactory = NULL;
CPAXenonRequest2HandlerFactory *gPAXenonFactory2 = NULL;
CPAXenonRequest3HandlerFactory *gPAXenonFactory3 = NULL;
CXboxADHandlerFactory *g_pADFactory = NULL;

//------------------------------------------------------------------------------------
// XKDC performance counters
//------------------------------------------------------------------------------------
PERFCOUNTER g_XkdcPerfCtrs[] =
{
    DWORD_COUNTER( XKDCPERF_SERVER_AS_REQ_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_AS_REQ_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_TGS_REQ_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_TGS_REQ_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_AS_SUCCESS_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_AS_SUCCESS_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_AS_FAILURE_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_AS_FAILURE_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_TGS_SUCCESS_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_TGS_SUCCESS_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_TGS_FAILURE_COUNTER, -1 ),
    DWORD_RATE( XKDCPERF_SERVER_TGS_FAILURE_RATE, 1 ),
    DWORD_COUNTER( XKDCPERF_SERVER_TIMESKEW_COUNTER, -2 ),
    DWORD_RATE( XKDCPERF_SERVER_TIMESKEW_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_SILENT_FAILURE_COUNTER, -1 ),
    DWORD_RATE( XKDCPERF_SERVER_SILENT_FAILURE_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_HTTP_REQ_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_HTTP_REQ_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_HTTP_REQ_CURRENT, 0 ),
    QWORD_AVERAGE( XKDCPERF_SERVER_HTTP_REQ_TIME_AVERAGE, -1 ),
    DWORD_BASE( XKDCPERF_SERVER_HTTP_REQ_TIME_BASE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_HTTP_REQ_500_COUNTER, -1 ),
    DWORD_RATE( XKDCPERF_SERVER_HTTP_REQ_500_RATE, 1 ),
    DWORD_COUNTER( XKDCPERF_SERVER_HTTP_REQ_TIMEOUT_COUNTER, -1 ),
    DWORD_RATE( XKDCPERF_SERVER_HTTP_REQ_TIMEOUT_RATE, 1 ),
    DWORD_COUNTER( XKDCPERF_SERVER_HTTP_REQ_RETRY_COUNTER, -1 ),
    DWORD_RATE( XKDCPERF_SERVER_HTTP_REQ_RETRY_RATE, 1 ),
    DWORD_COUNTER( XKDCPERF_SERVER_GETPRINCIPAL_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_GETPRINCIPAL_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_GETPRINCIPAL_CURRENT, 1 ),
    QWORD_AVERAGE( XKDCPERF_SERVER_GETPRINCIPAL_TIME_AVERAGE, -1 ),
    DWORD_BASE( XKDCPERF_SERVER_GETPRINCIPAL_TIME_BASE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_DOS_ENTRIES_IN_USE, -1 ),
    DWORD_COUNTER( XKDCPERF_SERVER_DOS_REPLAYS, 1 ),
    DWORD_RATE( XKDCPERF_SERVER_DOS_REPLAYS_RATE, 1 ),
    DWORD_COUNTER( XKDCPERF_SERVER_MACHINE_TICKETS, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_MACHINE_TICKETS_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_USER_TICKETS, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_USER_TICKETS_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_USER_TICKETS_TOTAL_USERS, -3 ),
    QWORD_AVERAGE( XKDCPERF_SERVER_USERS_PER_TICKET_AVERAGE, 1 ),
    DWORD_BASE( XKDCPERF_SERVER_USERS_PER_TICKET_BASE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_INVALID_TICKETS, 0 ),
    DWORD_RATE( XKDCPERF_SERVER_INVALID_TICKETS_RATE, 0 ),
    DWORD_RATE( XKDCPERF_SERVER_XBOX_REQUESTS_RATE, 0),
    DWORD_RATE( XKDCPERF_SERVER_XBOX_FAILURES_RATE, 0),
    DWORD_RATE( XKDCPERF_SERVER_XBOX360_REQUESTS_RATE, 0),
    DWORD_RATE( XKDCPERF_SERVER_XBOX360_FAILURES_RATE, 0),
    DWORD_RATE( XKDCPERF_SERVER_PC_REQUESTS_RATE, 0),
    DWORD_RATE( XKDCPERF_SERVER_PC_FAILURES_RATE, 0),
    DWORD_COUNTER( XKDCPERF_SERVER_CACHE_INUSE_FAILURE_COUNTER, 0),
    DWORD_RATE( XKDCPERF_SERVER_CACHE_INUSE_FAILURE_RATE, 0),
    DWORD_COUNTER( XKDCPERF_SERVER_CACHE_NORECORD_FAILURE_COUNTER, 0),
    DWORD_RATE( XKDCPERF_SERVER_CACHE_NORECORD_FAILURE_RATE, 0),
    DWORD_RATE( XKDCPERF_SERVER_CACHE_MISS_INITIALREQ_RATE, 0),
    DWORD_RATE( XKDCPERF_SERVER_CACHE_MISS_NOTFOUND_RATE, 0),
    DWORD_RATE( XKDCPERF_SERVER_CACHE_MISS_INVALID_RATE, 0),
    DWORD_RATE( XKDCPERF_SERVER_CACHE_HIT_RATE, 0),
    DWORD_COUNTER( XKDCPERF_SERVER_FLASH_VERSION_UPDATE_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_FLASH_VERSION_UPDATE_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_FLASH_VERSION_UPDATE_FAILED_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_FLASH_VERSION_UPDATE_FAILED_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_FLASH_VERSION_ROLLBACK_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_FLASH_VERSION_ROLLBACK_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_CONSOLE_REGION_SET_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_CONSOLE_REGION_SET_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_CONSOLE_REGION_SET_FAILED_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_CONSOLE_REGION_SET_FAILED_RATE, 0 ),
    DWORD_COUNTER( XKDCPERF_SERVER_CONSOLE_REGION_OVERWRITTEN_COUNTER, -3 ),
    DWORD_RATE( XKDCPERF_SERVER_CONSOLE_REGION_OVERWRITTEN_RATE, 0 )
};

DWORD g_cXkdcPerfCtrs = sizeof(g_XkdcPerfCtrs) / sizeof(g_XkdcPerfCtrs[0]);


//------------------------------------------------------------------------------------
// config defaults
//------------------------------------------------------------------------------------
const DWORD c_dwDefaultMachineCacheSize         = 10000;
const DWORD c_dwDefaultMachineCacheHashSize     = 20000;
const DWORD c_dwDefaultMachineCacheEntryLifetime = 3600;

const char  c_szPerfDllName[]                   = "xkdcperf.dll";
const char  c_szServiceName[]                   = "XKDCP";

//------------------------------------------------------------------------------------
// local function declaration.
//------------------------------------------------------------------------------------
static HRESULT FillKeysFromXkdcPrincipals(
    IN unsigned int const idx,
    IN DWORD const dwItem,
    IN XKDC_PRINCIPAL const * const psPrinc,
    IN OUT XkdcCredential * const pCred,
    IN DWORD const cCred,
    IN DWORD * const pdwKeyVersion,
    IN DWORD * const pdwKeyLen,
    IN XkdcServicePrincipal const * const pServicePrincipals,
    IN unsigned int const cPrincipals,
    OUT DWORD * const pdwTicketLifetimeSecs );

void XcHMAC3(
                IN PBYTE pbKeyMaterial,
                IN ULONG cbKeyMaterial,
                IN PBYTE pbData,
                IN ULONG cbData,
                IN PBYTE pbData2,
                IN ULONG cbData2,
                IN PBYTE pbData3,
                IN ULONG cbData3,
                OUT PBYTE HmacData );

DWORD ConvertConsoleToPlatformType(DWORD dwConsoleType);

//------------------------------------------------------------------------------------
// size of hash table for looking up title ids and versions
//------------------------------------------------------------------------------------
const DWORD dwTitleHashTableSize = 10253;

//
//  Exported entry point for dll registration.
//
static HMODULE g_hDll = 0;
BOOL APIENTRY DllMain( HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved )
{
    g_hDll = (HMODULE)hModule;

    return 1;
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;

    // set the kdc registry value.
    hr = SetKDCRegistry( TRUE , g_hDll );
    if ( FAILED(hr))
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log",  "XKDC:(ERROR) Failed to register XKDC.dll provider information.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_XKDC_REGISTER_FAILURE, "XKDC:(ERROR) Failed to register XKDC.dll provider information.  RESULT=0x%X", hr);
        goto Exit;
    }

    UninstallCounters((char*)c_szServiceName);

    // install this providers performance counters.
    hr = InstallCounters( (char*)c_szPerfDllName );
    if ( hr != ERROR_SUCCESS )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","XKDC:(ERROR) Failed to register XKDCperf.dll.  Performance coutner information was not properly setup.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_XKDC_REGISTER_FAILURE_1, "XKDC:(ERROR) Failed to register XKDCperf.dll.  Performance coutner information was not properly setup.  RESULT=0x%X", hr);
        goto Exit;
    }
	xlog5("c:\\xkdc-XkdcProvider-cpp.log","XKDC:  Successfully registered XKDC provider.");
    XomNtEvent( XEVENT_XKDC_REGISTER_SUCCESS, "XKDC:  Successfully registered XKDC provider.");

Exit:
    return hr;

}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;

    // set the kdc registry value.
    hr = SetKDCRegistry( FALSE, g_hDll );
    if ( FAILED(hr) )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","XKDC:(ERROR) Failed to unregister XKDC.dll provider information.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_XKDC_REGISTER_FAILURE_2, "XKDC:(ERROR) Failed to unregister XKDC.dll provider information.  RESULT=0x%X", hr);
        goto Exit;
    }

    // install this providers performance counters.
    hr = UninstallCounters( (char*)c_szServiceName );
    if ( hr != ERROR_SUCCESS )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","XKDC:(ERROR) Failed to unregister xkdcperf.dll.  Performance counter information was not cleaned up.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_XKDC_REGISTER_FAILURE_3, "XKDC:(ERROR) Failed to unregister xkdcperf.dll.  Performance counter information was not cleaned up.  RESULT=0x%X", hr);
        goto Exit;
    }

	xlog5("c:\\xkdc-XkdcProvider-cpp.log","XKDC:  Successfully unregistered XKDC provider.");
    XomNtEvent( XEVENT_XKDC_REGISTER_SUCCESS_1, "XKDC:  Successfully unregistered XKDC provider.");

Exit:
    return hr;

}

void logtofile22(char* file, char* fmt, ...)
{

	va_list argptr;

	char buffer[512];
	va_start(argptr, fmt);
	
	vsprintf(buffer, fmt, argptr);

	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" ); 
	fprintf( Log2, buffer);  
	fclose( Log2 ); 
}


//
//    Exported entry point into provider dll.  When the dll is loaded or unloaded by the service,
//    this function is called.
//
//    Purpose:
//        instantiates the provider
//
extern "C" NTSTATUS
KdcExtMain (
    IN DWORD dwReason,
    IN IKdcCore *piKdcCoreInterface
    )
{
	xlog5("c:\\xkdc-XkdcProvider-cpp.log","XkdcProvider: entering KdcExtMain...\n");
    XomTrace(Xkdc, L_NORMAL, "XkdcProvider: entering KdcExtMain...\n");

    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    CXkdcProvider *pXkdcProvider = NULL;

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        // initialize COM before g_xomcentral has a chance.
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if ( FAILED(hr) ) {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log", "XkdcProvider: Failed CoInitializeEx.  Stopping XKDC.  Hresult = 0xX", hr );
            // error time!!!! --- something bad happened... make note and do what you can.
            XomNtEvent( XEVENT_KDC_CONFIG_45, "XkdcProvider: Failed CoInitializeEx.  Stopping XKDC.  Hresult = 0xX", hr );

            return STATUS_INTERNAL_ERROR;
        }

        g_xomcentral.Init("Xkdc", NULL, "kdcsvc");

		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "XkdcProvider: KdcExtMain attaching...");
        XomTrace(Xkdc, L_NORMAL, "XkdcProvider: KdcExtMain attaching...");

        //  the core must provide an interface
        if (!piKdcCoreInterface)
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log", "XkdcProvider: KDC core interface was NULL.");
            XomNtEvent(XEVENT_XKDC_INIT_FAILURE, "XkdcProvider: KDC core interface was NULL.");
            return  STATUS_INVALID_PARAMETER_2;
        }

        //
        //    Initialize global objects that the provider is serving up
        //
        pXkdcProvider = new CXkdcProvider(piKdcCoreInterface);
        if (NULL == pXkdcProvider)
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log", "XkdcProvider: failed to instantiate CXkdcProvider object.");
            XomNtEvent(XEVENT_XKDC_INIT_FAILURE_1, "XkdcProvider: failed to instantiate CXkdcProvider object.");
            status = STATUS_NO_MEMORY;
            goto Error;
        }

        // set the global Xkdc provider object
        g_pXkdcProvider = pXkdcProvider;

        // initialize the performance counters
 //       hr = g_Counters.Init(XKDCPERF_SERVER_OBJECT, g_XkdcPerfCtrs, g_cXkdcPerfCtrs);
 //       if ( FAILED(hr) )
  //      {
//			logtofile22("c:\\kdc\\kdc-xkdc.log", "XkdcProvider: perf counter initialization failed with hr 0x%08X.", hr);
  //          XomNtEvent(XEVENT_KDC_CONFIG_48, "XkdcProvider: perf counter initialization failed with hr 0x%08X.", hr);
 //           XomTrace(Xkdc, L_ERROR, "XkdcProvider: perf counter initialization failed with hr 0x%08X.", hr);
 //           status = STATUS_UNSUCCESSFUL;
 //           goto Error;
 //       }
 //       else
 //       {
//			logtofile22("c:\\kdc\\kdc-xkdc.log","XkdcProvider: perf counters successfully initialized.");
 //           XomTrace(Xkdc, L_NORMAL, "XkdcProvider: perf counters successfully initialized.");
 //       }

        //
        //    Bringing up the provider
        //
        status = pXkdcProvider->Initialize();
       // if (!NT_SUCCESS(status))
       // {
		//	logtofile22("c:\\kdc\\kdc-xkdc.log","XkdcProvider: CXkdcProvider initialization failed with status = 0x%08X. "
        //               "Please check event log for previous events with more information.",
        //               status);
        //    XomNtEvent(XEVENT_XKDC_INIT_FAILURE_2,
        //               "XkdcProvider: CXkdcProvider initialization failed with status = 0x%08X. "
       //                "Please check event log for previous events with more information.",
       //                status);
       //     goto Error;
        //}

        //
        //    Let the core know about this provider
        //
        status = piKdcCoreInterface->pfnKdcRegisterProvider(pXkdcProvider);
        if (!NT_SUCCESS(status))
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","XkdcProvider: failed to register CXkdcProvider with core, status = 0x%08X.", status);
            XomNtEvent(XEVENT_XKDC_INIT_FAILURE_3, "XkdcProvider: failed to register CXkdcProvider with core, status = 0x%08X.", status);
            goto Error;
        }

        //
        //    ownership belongs to g_pXkdcProvider
        //
        pXkdcProvider = NULL;

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","XkdcProvider: successfully loaded and initialized.");
        XomNtEvent(XEVENT_XKDC_INIT_SUCCESS, "XkdcProvider: successfully loaded and initialized.");
        XomTrace(Xkdc, L_NORMAL, "XkdcProvider: KdcExtMain successfully loaded and initialized.");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","XkdcProvider: KdcExtMain detaching...");
        XomTrace(Xkdc, L_NORMAL, "XkdcProvider: KdcExtMain detaching...");

        if (g_pXkdcProvider)
        {
            g_pXkdcProvider->Unload();

            delete g_pXkdcProvider;

            g_pXkdcProvider = NULL;
        }

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","XkdcProvider: KdcExtMain successfully unloaded.");
        XomNtEvent(XEVENT_XKDC_TERM_SUCCESS, "XkdcProvider: KdcExtMain successfully unloaded.");
        XomTrace(Xkdc, L_NORMAL, "XkdcProvider: KdcExtMain successfully unloaded.");
        g_xomcentral.Term();
        CoUninitialize();

    }

Error:

    return status;
}

//------------------------------------------------------------------------------------
//                        IKdbProvider
//------------------------------------------------------------------------------------
CXkdcProvider::CXkdcProvider(IKdcCore *pIKdcCore) :
    CXBaseProvider(pIKdcCore, L"Xbox KDC", XBOX_KERBEROS_REALM_L),
    m_ppPrinc(NULL),
    m_cPrinc(0),
    m_pTitleVersions(NULL),
    m_cTitleVersions(-1),
    m_bCheckForDos(TRUE),
    m_cDosEntries(1000),
    m_pMachineCache(NULL),
    m_bEnforceClientVersion(TRUE),
    m_bRequestCacheEnabled(TRUE),
    m_dwRequestCacheLifetime(10),
    m_bIgnoreDuplicateRequests(FALSE),
    m_pkinSite1Name(NULL),
    m_cSite1LoadBalancingIps(0),
    m_pdwSite1LoadBalancingIps(NULL),
    m_cLegacyPcTitles(0),
    m_pdwLegacyPcTitles(NULL),
    m_bUseUniqueSigninKey(TRUE),
    m_bRemoveUserPrivilegesOnRequiresManagement(TRUE)
{
}


CXkdcProvider::~CXkdcProvider()
{
}


void __stdcall
CXkdcProvider::Unload()
{
    Uninitialize();

    CXBaseProvider::Unload();

    delete gPAXboxFactory;
    gPAXboxFactory = NULL;

    delete gPAXenonFactory2;
    gPAXenonFactory2 = NULL;

    delete gPAXenonFactory3;
    gPAXenonFactory3 = NULL;

    delete g_pADFactory;
    g_pADFactory = NULL;

    XomTrace(Xkdc, L_NORMAL, "CXkdcProvider::Unload: completed.");
}


KERBERR __stdcall
CXkdcProvider::GetPrincipal(
    IN  GET_PRINC_FLAGS      flags,
    IN  PKERB_INTERNAL_NAME  pName,
    IN  LPCWSTR              pcwszRealm,
    IN  IKerbRequest        *piReq,
    OUT PIKerbPrincipal     *ppIPrincipal,
    OUT PKERB_EXT_ERROR      pExtendedError,
    OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm
    )
{
    UNREFERENCED_PARAMETER( pcwszRealm );
    CXkdcPrincipal *piPrinc = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS status = STATUS_SUCCESS;
    QWORD qwStartTime = 0;
    QWORD qwEndTime = 0;
    QWORD qwElapsedMs = 0;
    XKDC_LOGGINGDATA *pLogData = NULL;
    IPAXboxRequest *piXboxReq = NULL;
    IPAXboxLogData *piXboxLog = NULL;
    in_addr *pInAddr = NULL;

    XOMASSERT( ppIPrincipal );
    *ppIPrincipal = NULL;

    //g_Counters.IncrementValue32(XKDCPERF_SERVER_GETPRINCIPAL_CURRENT, 1);

    GetSystemTimeAsFileTime((FILETIME*)&qwStartTime);

    ConfigReadLock();

    XOMASSERT( piReq );
    if ( NULL == piReq )
    {
        status = STATUS_INVALID_PARAMETER;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // get the Xkdc log interface from the preauth handler
    status = piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog);
    if ( !NT_SUCCESS(status) || NULL == piXboxLog )
    {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CXkdcProvider::GetPrincipal: no IID_IPAXboxLogData interface found.",
                __FILE__,
                __LINE__);
        XomTrace(Xkdc, L_HIGH,
                "(%s:%d) CXkdcProvider::GetPrincipal: no IID_IPAXboxLogData interface found.",
                __FILE__,
                __LINE__);

        goto Cleanup;
    }

    // get the current logging data.
    status = piXboxLog->GetLogData( &pLogData );
    if ( !NT_SUCCESS(status) || (NULL == pLogData) )
    {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CXkdcProvider::GetPrincipal: No logging data found.",
                __FILE__,
                __LINE__);
        XomTrace(Xkdc, L_HIGH,
                "(%s:%d) CXkdcProvider::GetPrincipal: No logging data found.",
                __FILE__,
                __LINE__);

        goto Cleanup;
    }

    // set the IP pointer.
    pInAddr = (in_addr*)&(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr.s_addr);

    // XBOX.COM should never receive AS requests from valid Xbox clients
    if ( KerbAs == piReq->GetServId() )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CXkdcProvider::GetPrincipal: invalid AS request to %s realm from client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

        XomNtEvent(XEVENT_XKDC_AS_REQUEST_1,
                "(%s:%d) CXkdcProvider::GetPrincipal: invalid AS request to %s realm from client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CXkdcProvider::GetPrincipal: invalid AS request to %s realm from client %s.  Possible hack attempt.",
                 __FILE__,
                 __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) CXkdcProvider::GetPrincipal: invalid AS request to %s realm from client %s.  Possible hack attempt.",
                 __FILE__,
                 __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

        KerbErr = SilentKerbErr(KDC_ERR_POLICY);
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_INVALIDSERVID;
        status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    if ( (NULL == pName) || (pName->NameCount <= 1) )
    {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        status = STATUS_INVALID_PARAMETER_2;
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::GetPrincipal: invalid name parameter.");
        XomTrace(Xkdc, L_NORMAL, "CXkdcProvider::GetPrincipal: invalid name parameter.");
        goto Cleanup;
    }

    // Check for valid pre-auths in request. This function will take care of logging
    // events. This GetPrincipal() function is called twice. The first time uses the
    // name "krbtgt/xbox.com" and occurs near the beginning of processing the request.
    // The second time uses the name "sg/S0" and occurs after all the preauths have
    // run Check(), after processing the request preauth, after decrypting the ticket,
    // etc. So we want to detect bad requests early on in the first GetPrincipal()
    // call.
    // Covers first call (krbtgt) and bad calls by avoiding the second call (sg).
    if (!IsSG(pName))
    {
        KerbErr = VerifyPreAuthWhitelist(piReq, pLogData);
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    // make sure the principal cache has been loaded. we shouldn't even be running if it
    // hasn't, but who know.
    if ( NULL == m_ppPrinc )
    {
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

	xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::GetPrincipal: Name=%S/%S, Flags=%d",
              pName->Names[0].Buffer,
              pName->Names[1].Buffer,
              flags);
    XomTrace(Xkdc, L_LOW, "CXkdcProvider::GetPrincipal: Name=%S/%S, Flags=%d",
              pName->Names[0].Buffer,
              pName->Names[1].Buffer,
              flags);

    // For krbtgt principals (e.g. krbtgt/XBOX.COM), the name components must
    // match.  For XBOX service principals, ignore the name components and
    // match strictly against the service ID in the preauth data.
    if ( IsKrbTgt(pName) )
    {
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_ISKRBTGT;
        for ( INT i=0; i < m_cPrinc; i++ )
        {
            if ( GetKdcCore()->pfnKerbEqualKdcNames(pName, m_ppPrinc[i]->GetServiceName()) )
            {
                piPrinc = m_ppPrinc[i];
                piPrinc->AddRef();
                break;
            }
        }
    }
    else if ( IsSG(pName) )
    {
        XKDC_PA_SERVICE_REQUEST *pServiceRequest = NULL;

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_ISSG;

        // get the Xkdc-specific interface from the preauth handler
        status = piReq->GetPAHandler(IID_IPAXboxRequest, (PVOID*)&piXboxReq);
        if ( !NT_SUCCESS(status) || (NULL == piXboxReq) )
        {
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CXkdcProvider::GetPrincipal: no IID_IPAXboxRequest interface found.",
                    __FILE__,
                    __LINE__);
            XomTrace(Xkdc, L_HIGH,
                    "(%s:%d) CXkdcProvider::GetPrincipal: no IID_IPAXboxRequest interface found.",
                    __FILE__,
                    __LINE__);

            goto Cleanup;
        }

        // get the service request data to find service id, title id, etc.
        status = piXboxReq->GetServiceRequest(&pServiceRequest);
        if ( !NT_SUCCESS(status) || NULL == pServiceRequest )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CXkdcProvider::GetPrincipal: unable to retrieve XKDC_PA_SERVICE_REQUEST.",
                __FILE__,
                __LINE__);
            XomTrace(Xkdc, L_HIGH,
                "(%s:%d) CXkdcProvider::GetPrincipal: unable to retrieve XKDC_PA_SERVICE_REQUEST.",
                __FILE__,
                __LINE__);

            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_NO_REQ_DATA;

            goto Cleanup;
        }

        XOMASSERT( pServiceRequest );
        XOMASSERT( pServiceRequest->wAutoDiscoverServices || pServiceRequest->dwNumServices > 0 );

        // gather the title id and title version for logging.
        pLogData->m_dwFlashVersion = pServiceRequest->dwFlashVersion;
        pLogData->m_dwTitleId      = pServiceRequest->dwTitleID;
        pLogData->m_dwTitleRegion  = pServiceRequest->dwTitleRegion;
        pLogData->m_dwTitleVersion = pServiceRequest->dwTitleVersion;
        GetServiceIdsIntoString( pServiceRequest->dwServiceID, pServiceRequest->dwNumServices, pLogData->m_szServicesRequested , ARRAYSIZE(pLogData->m_szServicesRequested));

        // If services are being auto-discovered, fetch the principal
        // associated with the string service since it is a known base
        // service that only requires a machine account and everyone
        // will be authorized for access to it.
        piPrinc = GetServicePrincipal(
                    pServiceRequest->wAutoDiscoverServices ?
                        XONLINE_STRING_SERVICE :
                        pServiceRequest->dwServiceID[0],
                    pServiceRequest->dwTitleID,
                    pServiceRequest->dwTitleVersion,
                    pServiceRequest->dwTitleRegion);

        if ( piPrinc )
        {
            XOMASSERT( piPrinc->GetServiceID() > 0 );

            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_ATTAINED_SVCPRINC;
            pLogData->m_dwTicketLifeTime = (DWORD)((piPrinc->MaxLifeTime()).QuadPart / 10000);

			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CXkdcProvider::GetPrincipal: using '%S/%S' for service id 0x%08X, title id 0x%08X, title version 0x%08X, title region 0x%08X.",
                __FILE__,
                __LINE__,
                piPrinc->GetName()->Names[0].Buffer,
                piPrinc->GetName()->Names[1].Buffer,
                pServiceRequest->dwServiceID[0],
                pServiceRequest->dwTitleID,
                pServiceRequest->dwTitleVersion,
                pServiceRequest->dwTitleRegion);

            XomTrace(Xkdc, L_LOW,
                "(%s:%d) CXkdcProvider::GetPrincipal: using '%S/%S' for service id 0x%08X, title id 0x%08X, title version 0x%08X, title region 0x%08X.",
                __FILE__,
                __LINE__,
                piPrinc->GetName()->Names[0].Buffer,
                piPrinc->GetName()->Names[1].Buffer,
                pServiceRequest->dwServiceID[0],
                pServiceRequest->dwTitleID,
                pServiceRequest->dwTitleVersion,
                pServiceRequest->dwTitleRegion);

            piPrinc->AddRef();
        }
    }

    // If the service name wasn't found, don't return a kerb err yet.
    // If the first requested service (the incoming name parameter)
    // is invalid, we want to handle the error the same way we would if
    // the first requested service was valid and a subsequent service
    // was invalid -- a ticket to a bogus site is returned with detailed
    // error codes in the return preauth.
    //
    // To accomplish this, find the first site principal and use it to
    // instantiate a new instance of an XkdcServicePrincipal.  The principal
    // class will perform necessary policy checking to determine whether
    // a valid ticket needs to be returned (other services requested were
    // valid and authorized) or a ticket to a bogus site needs to be
    // returned (none of the services requested were valid or authorized).
    if ( NULL == piPrinc && IsSG(pName) )
    {
        for (INT i=0; i < m_cPrinc; i++)
        {
            if ( m_ppPrinc[i]->GetServiceID() > 0 )
            {
                piPrinc = m_ppPrinc[i];
                piPrinc->AddRef();
                break;
            }
        }
    }

    // With the change to make unrecognized services return invalid tickets
    // rather than a KerbErr, this code should not ever be reached.
    if ( NULL == piPrinc )
    {
        if ( flags & KDC_KDB_GET_PRINC_CLIENT )
        {
            KerbErr = SilentKerbErr(KDC_ERR_C_PRINCIPAL_UNKNOWN);
        }
        else if ( flags & KDC_KDB_GET_PRINC_SERVER )
        {
            KerbErr = SilentKerbErr(KDC_ERR_S_PRINCIPAL_UNKNOWN);
        }
        else
        {
            KerbErr = SilentKerbErr(KDC_ERR_POLICY);
        }

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CXkdcProvider::GetPrincipal: request for unknown service '%S/%S' by client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                pName->Names[0].Buffer,
                pName->Names[1].Buffer,
                inet_ntoa(*pInAddr));
        XomNtEvent(XEVENT_KDC_HACK_26,
                "(%s:%d) CXkdcProvider::GetPrincipal: request for unknown service '%S/%S' by client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                pName->Names[0].Buffer,
                pName->Names[1].Buffer,
                inet_ntoa(*pInAddr));

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CXkdcProvider::GetPrincipal: request for unknown service '%S/%S' by client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                pName->Names[0].Buffer,
                pName->Names[1].Buffer,
                inet_ntoa(*pInAddr));
        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) CXkdcProvider::GetPrincipal: request for unknown service '%S/%S' by client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                pName->Names[0].Buffer,
                pName->Names[1].Buffer,
                inet_ntoa(*pInAddr));

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_INVALID_REQUEST;

        goto Cleanup;
    }

    XOMASSERT( piPrinc );

    if ( IsSG(pName) )
    {
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_CHECKING_DOS;
        KerbErr = CheckForDos( piReq, pLogData );
        if ( !KERB_SUCCESS(KerbErr) )
        {
            goto Cleanup;
        }

        CXkdcServicePrincipal *pSvcPrinc = new CXkdcServicePrincipal(piPrinc, piReq, this);
        if ( NULL == pSvcPrinc )
        {
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::GetPrincipal: failed to instantiate service principal for '%S/%S'.",
                      pName->Names[0].Buffer,
                      pName->Names[1].Buffer);
            XomTrace(Xkdc, L_ERROR, "CXkdcProvider::GetPrincipal: failed to instantiate service principal for '%S/%S'.",
                      pName->Names[0].Buffer,
                      pName->Names[1].Buffer);
        }
        else
        {
            const XKDC_POLICY_DATA *pPolicyData = NULL;

            //
            // Initializing the CXkdcServicePrincipal ends up calling PolicyCheck(), which
            // calls all of the PolicyCheck* functions. These are the heavyweight
            // functions that do the actual authorization, talk to the UODB, etc. It looks
            // innocent, but beware.
            //
            pSvcPrinc->Initialize();

            // see if the policy checks resulted in a KerbErr
            pPolicyData = pSvcPrinc->GetPolicyData();
            if ( pPolicyData && !KERB_SUCCESS(pPolicyData->KerbErr) )
            {
                pSvcPrinc->Release();
                pSvcPrinc = NULL;
                KerbErr = pPolicyData->KerbErr;
                XOMASSERT( NULL == *ppIPrincipal );
				xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::GetPrincipal: PolicyCheck resulted in  KerbErr 0x%02X", pPolicyData->KerbErr);
                XomTrace(Xkdc, L_ERROR, "CXkdcProvider::GetPrincipal: PolicyCheck resulted in  KerbErr 0x%02X", pPolicyData->KerbErr);
                pSvcPrinc->Release();
                pSvcPrinc = NULL;
                KerbErr = pPolicyData->KerbErr;
                XOMASSERT( NULL == *ppIPrincipal );
                goto Cleanup;
            }

            XOMASSERT( NULL == *ppIPrincipal );
            *ppIPrincipal = static_cast<IKerbPrincipal*>(pSvcPrinc);
            piPrinc = NULL;
            pSvcPrinc = NULL;
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::GetPrincipal: successfully instantiated service principal for '%S/%S'.",
                      pName->Names[0].Buffer,
                      pName->Names[1].Buffer);
            XomTrace(Xkdc, L_LOW, "CXkdcProvider::GetPrincipal: successfully instantiated service principal for '%S/%S'.",
                      pName->Names[0].Buffer,
                      pName->Names[1].Buffer);
        }
    }
    else
    {
        XOMASSERT( IsKrbTgt(pName) );
        XOMASSERT( NULL == *ppIPrincipal );
        *ppIPrincipal = static_cast<IKerbPrincipal*>(piPrinc);
        piPrinc = NULL;

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::GetPrincipal: successfully instantiated principal for '%S/%S'.",
                  pName->Names[0].Buffer,
                  pName->Names[1].Buffer);

        XomTrace(Xkdc, L_LOW, "CXkdcProvider::GetPrincipal: successfully instantiated principal for '%S/%S'.",
                  pName->Names[0].Buffer,
                  pName->Names[1].Buffer);
    }

    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_SUCCESSFUL_PRINC;


Cleanup:

    pExtendedError->status = status;

    ConfigReadUnlock();

    // Only increment on server principal calls, aka "IsSG(pName)" calls, since this is
    // the heavyweight one that makes us hit the database.
    if (IsSG(pName) &&
        KERB_SUCCESS(KerbErr))
    {
        GetSystemTimeAsFileTime((FILETIME*)&qwEndTime);
        qwElapsedMs = ( qwEndTime - qwStartTime ) / 10000;
        //g_Counters.IncrementValue32(XKDCPERF_SERVER_GETPRINCIPAL_COUNTER, 1);
        //g_Counters.IncrementValue32(XKDCPERF_SERVER_GETPRINCIPAL_RATE, 1);
        //g_Counters.IncrementValue64(XKDCPERF_SERVER_GETPRINCIPAL_TIME_AVERAGE, qwElapsedMs);
        //g_Counters.IncrementValue32(XKDCPERF_SERVER_GETPRINCIPAL_TIME_BASE, 1);
    }

    //g_Counters.IncrementValue32(XKDCPERF_SERVER_GETPRINCIPAL_CURRENT, -1);

    return KerbErr;
}


//
//    Non-IKdbProvider methods for CXkdcProvider
//
CXkdcPrincipal*
CXkdcProvider::GetServicePrincipal(
    IN  DWORD dwServiceID,
    IN  DWORD dwTitleID,
    IN  DWORD dwTitleVersion,
    IN  DWORD dwTitleRegion)
{
    CXkdcPrincipal *pZeroPrinc = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    // There are two principals that we can match on:
    // * ZeroPrincipal --- This is the 'default' principal for the Service.
    //                     This is the one that gets sent back unless there 
    //                     is a title specific override
    // * TitlePrincipal -- This is the principal that matches the exact
    //                     title for the given service id
    // 
    // The code below will attempt to find both principals and then
    // will return the title principal over the zero principal
    for (INT i=0; i < m_cPrinc; i++)
    {
        if ( dwServiceID == m_ppPrinc[i]->GetServiceID() )
        {
            if ( 0 == m_ppPrinc[i]->GetTitleID() )
            {
                pZeroPrinc = m_ppPrinc[i];
                continue;
            }

            if ( dwTitleID == m_ppPrinc[i]->GetTitleID() )
            {
                if ( (dwTitleVersion == m_ppPrinc[i]->GetTitleVersion()
                      || 0 == m_ppPrinc[i]->GetTitleVersion())
                     && (dwTitleRegion == m_ppPrinc[i]->GetTitleRegion()
                         || 0 == m_ppPrinc[i]->GetTitleRegion()) )
                {
                    return m_ppPrinc[i];
                }
            }
        }
    }
    return pZeroPrinc;
}

TITLE_VERSION*
CXkdcProvider::VerifyTitleTimeConstraints(
    IN  const FILETIME ftNow,
    IN  TITLE_VERSION* pTV
)
{
    if( pTV != NULL &&
        CompareFileTime(&ftNow, &pTV->ftStartTime) == 1 &&
        CompareFileTime(&pTV->ftEndTime, &ftNow) == 1 )
    {
        return pTV;
    }

    return NULL;
}

const TITLE_VERSION*
CXkdcProvider::GetTitleInfo(
    IN  DWORD dwTitleID,
    IN  DWORD dwPlatformType,
    IN  DWORD dwTitleRegion,
    IN  DWORD dwMediaID,
    IN  DWORD dwBaseVersion,
    IN  GUID  guidGroupID
)
{
    TITLE_KEY Key = {0};
    TITLE_VERSION *pTitle = NULL;
    HRESULT hr = S_OK;
    FILETIME ftNow;

    // make sure the title information has been loaded. we shouldn't even be running if it
    // isn't, but who knows.
    if ( -1 == m_cTitleVersions )
    {
        return NULL;
    }

    XOMASSERT( m_cTitleVersions >= 0 );
    XOMASSERT( m_pTitleVersions );

    Key.dwTitleID      = dwTitleID;
    Key.dwPlatformType = dwPlatformType;
    Key.dwTitleRegion  = dwTitleRegion;
    Key.dwMediaID      = dwMediaID;
    Key.dwBaseVersion  = dwBaseVersion;
    Key.guidGroupID    = guidGroupID;

    hr = m_pTitleVersions->Find(Key, pTitle);

    // Check if we're between the start and end time.
    GetSystemTimeAsFileTime(&ftNow);
    pTitle = VerifyTitleTimeConstraints(ftNow, pTitle);

    if(NULL == pTitle)
    {
        // If not found, try searching for region and media = 0
        TITLE_KEY key2 = Key;
        key2.dwTitleRegion = 0;
        key2.dwMediaID     = 0;
        hr = m_pTitleVersions->Find(key2, pTitle);
        pTitle = VerifyTitleTimeConstraints(ftNow, pTitle);
    }

    // If unknown versions are allowed, look for a wildcard entry
    // for this title id.
    if ( NULL == pTitle && (BOOL)(GetDWORDSetting( Setting_kdcsvc_xkdc_allowUnknownVersion, 0)) )
    {
        Key.dwBaseVersion = 0;
        hr = m_pTitleVersions->Find(Key, pTitle);
        pTitle = VerifyTitleTimeConstraints(ftNow, pTitle);

        if(NULL == pTitle)
        {
            // If not found, try searching for region and media = 0
            TITLE_KEY key2 = Key;
            key2.dwTitleRegion = 0;
            key2.dwMediaID     = 0;
            hr = m_pTitleVersions->Find(key2, pTitle);
            pTitle = VerifyTitleTimeConstraints(ftNow, pTitle);
        }

        if ( pTitle )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","GetTitleInfo: title id 0x%08X, allowing unknown version %d.", dwTitleID, dwBaseVersion);
			XomNtEvent(XEVENT_XKDC_TITLE_MULTIPLE_GROUPS,"GetTitleInfo: title id 0x%08X, allowing unknown version %d.", dwTitleID, dwBaseVersion);
            XomTrace(Xkdc, L_LOW, "GetTitleInfo: title id 0x%08X, allowing unknown version %d.", dwTitleID, dwBaseVersion);
        }
    }

    return pTitle;
}

DWORD
CXkdcProvider::GetLoadBalancingIpAddress(
    IN CXkdcPrincipal *pPrinc,
    IN ULONGLONG qwHashKey)
{
    XOMASSERT(pPrinc);

    // If we have an override and this principal is for site1, then we'll use the
    // override. Otherwise go with the old behavior and use the site ip from the principal
    // (uodb..t_sites).

    if (m_pdwSite1LoadBalancingIps != NULL &&
        m_cSite1LoadBalancingIps > 0 &&
        IsPrincipalSite1(pPrinc))
    {
        DWORD dwIndex = (DWORD)(qwHashKey % m_cSite1LoadBalancingIps);
        return m_pdwSite1LoadBalancingIps[dwIndex];
    }
    else
    {
        return pPrinc->GetSiteIPAddress();
    }
}

//
//    Non-IKdbProvider methods for CXkdcProvider
//
NTSTATUS
CXkdcProvider::Initialize()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    BOOL success;

    // Service principals

    INT cPrinc = 0;
    CXkdcPrincipal **ppPrinc = NULL;

    INT cOldPrinc = 0;
    CXkdcPrincipal **ppOldPrinc = NULL;

    // Titles

    INT cTitleVersions = 0;
    CTitleVersionTable *pTitleVersions = NULL;

    INT cOldTitleVersions = 0;
    CTitleVersionTable *pOldTitleVersions = NULL;

    // Load balancing ips

    CComSafeArray<BSTR> saValues;
    DWORD dwCountIps = 0;

    DWORD cNewSite1LoadBalancingIps = 0;
    DWORD *pdwNewSite1LoadBalancingIps = NULL;

    DWORD cOldSite1LoadBalancingIps = 0;
    DWORD *pdwOldSite1LoadBalancingIps = NULL;

    UNICODE_STRING ustrDomainName = {0};
    UNICODE_STRING ustrServiceName = {0};

    DWORD cNewLegacyTitles = 0;
    DWORD *pdwNewLegacyTitles = NULL;

    ConfigWriteLock();

    status = CXBaseProvider::Initialize();
    if ( !NT_SUCCESS(status) )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) Intialize: CXBaseProvider::Initialize() failed with status: 0x%08X.", __FILE__, __LINE__, status);
        XomNtEvent(XEVENT_KDC_CONFIG_53, "(%s:%d) Intialize: CXBaseProvider::Initialize() failed with status: 0x%08X.", __FILE__, __LINE__, status);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::Initialize: base class initialization failed with status %d.", status);
        XomTrace(Xkdc, L_ERROR, "CXkdcProvider::Initialize: base class initialization failed with status %d.", status);
        goto Cleanup;
    }

    status = LoadServicePrincipals(&cPrinc, &ppPrinc);
    if ( !NT_SUCCESS(status) )
    {
        goto Cleanup;
    }

    if ( ppPrinc && cPrinc > 0 )
    {
        status = ReplaceServicePrincipals(cPrinc, ppPrinc, &cOldPrinc, &ppOldPrinc);
        if ( !NT_SUCCESS(status) )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::Initialize: ReplaceServicePrincipals failed with status 0x%08X.", status);
            // log an error message but continue (not that an error will ever happen)
            XomNtEvent(XEVENT_XKDC_INIT_WARNING, "CXkdcProvider::Initialize: ReplaceServicePrincipals failed with status 0x%08X.", status);
            status = STATUS_SUCCESS;
        }
    }

    status = LoadTitleVersions(&cTitleVersions, &pTitleVersions);
    if ( !NT_SUCCESS(status) )
    {
        goto Cleanup;
    }

    if ( pTitleVersions && cTitleVersions > 0 )
    {
        status = ReplaceTitleVersions(cTitleVersions, pTitleVersions, &cOldTitleVersions, &pOldTitleVersions);
        if ( !NT_SUCCESS(status) )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::Initialize: ReplaceTitleVersions failed with status 0x%08X.", status);
            // log an error message but continue (not that an error will ever happen)
            XomNtEvent(XEVENT_XKDC_INIT_WARNING_1, "CXkdcProvider::Initialize: ReplaceTitleVersions failed with status 0x%08X.", status);
            status = STATUS_SUCCESS;
        }
    }

    //
    // The principals, and thus the tickets, don't have a numeric site id. It's
    // represented by the name, which is of the form "sg/site1". So we need to build up
    // that const name for comparisons in the future.
    //
    RtlInitUnicodeString(&ustrServiceName, L"sg");
    RtlInitUnicodeString(&ustrDomainName, L"site1");

    status = GetKdcCore()->pfnKerbBuildFullServiceKdcName(
        &ustrDomainName,
        &ustrServiceName,
        KRB_NT_SRV_INST,
        &m_pkinSite1Name
        );
    if ( !NT_SUCCESS(status) )
    {
        goto Cleanup;
    }

    //
    // Load balancing IP addresses for site 1
    //

    GetMultiSetting(MultiSetting_kdcsvc_xkdc_sgSite1Ips, saValues);

    success = ParseSite1LoadBalancingIps(
        saValues,
        &cNewSite1LoadBalancingIps,
        &pdwNewSite1LoadBalancingIps);

    if (success)
    {
        ReplaceSite1LoadBalancingIps(
            cNewSite1LoadBalancingIps,
            pdwNewSite1LoadBalancingIps,
            &pdwOldSite1LoadBalancingIps);
    }

    LogLoadBalancingIps();

    if (pdwOldSite1LoadBalancingIps)
    {
        delete [] pdwOldSite1LoadBalancingIps;
    }

    //
    // Legacy PC titles
    //

    GetMultiSetting(MultiSetting_kdcsvc_xkdc_legacyPcTitles, saValues);

    success = ParseHexNumberArray(
        saValues,
        &cNewLegacyTitles,
        &pdwNewLegacyTitles);

    if (success)
    {
        ReplaceLegacyPcTitles(
            cNewLegacyTitles,
            pdwNewLegacyTitles);
    }

    if ( m_bCheckForDos )
    {
        if ( !XkdcTgsDosInit() )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::Initialize: XkdcTgsDosInit failed.");
            XomTrace(Xkdc, L_ERROR, "CXkdcProvider::Initialize: XkdcTgsDosInit failed.");
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !XkdcTgsDosConfig(m_cDosEntries) )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::Initialize: XkdcTgsDosConfig failed.");
            XomTrace(Xkdc, L_ERROR, "CXkdcProvider::Initialize: XkdcTgsDosConfig failed.");
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
    }

    // initialize the machine cache.
    m_pMachineCache = new CXkdcMachineCache;
    if ( m_pMachineCache == NULL )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::Initialize: CXkdcMachineCache failed.");
        XomTrace(Xkdc, L_ERROR, "CXkdcProvider::Initialize: CXkdcMachineCache failed.");
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    hr = m_pMachineCache->Init( m_dwEntryLifeTime, m_dwCacheSize, m_dwHashSize );
    if (FAILED(hr) )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::Initialize: CXkdcMachineCache Init() failed.");
        XomTrace(Xkdc, L_ERROR, "CXkdcProvider::Initialize: CXkdcMachineCache Init() failed.");
        status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    // Configure Dos2

    BOOL   enabled      = GetDWORDSetting(Setting_kdcsvc_xkdc_DoS2_enabled, 0);
    UINT32 maxRecords   = GetDWORDSetting(Setting_kdcsvc_xkdc_DoS2_cacheSize, 0);
    double sizeRatio    = 0.5;
    UINT32 maxRequests  = GetDWORDSetting(Setting_kdcsvc_xkdc_DoS2_maxRequests, 0);
    UINT32 interval     = GetDWORDSetting(Setting_kdcsvc_xkdc_DoS2_interval, 0);
    UINT32 blockingTime = GetDWORDSetting(Setting_kdcsvc_xkdc_DoS2_blockingTime, 0);

    success = m_Dos2.Init(
        enabled,
        maxRecords,
        sizeRatio,
        maxRequests,
        interval,
        blockingTime);

    if(!success)
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to initialize DoS detection. Verify that the following settings "
            "contain valid parameters: \n"
            " kdcsvc_xkdc_DoS2_enabled: %u \n"
            " kdcsvc_xkdc_DoS2_cacheSize: %u \n"
            " kdcsvc_xkdc_DoS2_maxRequests: %u \n"
            " kdcsvc_xkdc_DoS2_interval: %u \n"
            " kdcsvc_xkdc_DoS2_blockingTime: %u \n",
            enabled,
            maxRecords,
            maxRequests,
            interval,
            blockingTime);
			
        XomNtEvent(
            XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
            "Failed to initialize DoS detection. Verify that the following settings "
            "contain valid parameters: \n"
            " kdcsvc_xkdc_DoS2_enabled: %u \n"
            " kdcsvc_xkdc_DoS2_cacheSize: %u \n"
            " kdcsvc_xkdc_DoS2_maxRequests: %u \n"
            " kdcsvc_xkdc_DoS2_interval: %u \n"
            " kdcsvc_xkdc_DoS2_blockingTime: %u \n",
            enabled,
            maxRecords,
            maxRequests,
            interval,
            blockingTime);

        status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

Cleanup:
    ConfigWriteUnlock();

    if ( cOldPrinc > 0 && ppOldPrinc )
    {
        FreeServicePrincipals(cOldPrinc, ppOldPrinc);
        cOldPrinc = 0;
        ppOldPrinc = NULL;
    }

    if ( pOldTitleVersions )
    {
        FreeTitleVersions(pOldTitleVersions);
        cOldTitleVersions = 0;
        pOldTitleVersions = NULL;
    }

    return status;
}


NTSTATUS
CXkdcProvider::Uninitialize()
{
    NTSTATUS status = STATUS_SUCCESS;

    // clear the DoS cache
    if ( m_bCheckForDos )
    {
        XkdcTgsDosTerm();
    }

    // free the cached service principals
    FreeServicePrincipals(m_cPrinc, m_ppPrinc);
    m_cPrinc = 0;
    m_ppPrinc = NULL;

    // free the title/version hash table
    FreeTitleVersions(m_pTitleVersions);
    m_pTitleVersions = NULL;
    m_cTitleVersions = -1;

    // base provider needs to free up WinHttp handles
    status = CXBaseProvider::Uninitialize();

    if (m_pMachineCache)
    {
        m_pMachineCache->Term();
        delete m_pMachineCache;
        m_pMachineCache = NULL;
    }

    return status;
}


NTSTATUS
CXkdcProvider::Reinitialize()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    INT cPrinc = 0;
    CXkdcPrincipal **ppPrinc = NULL;

    INT cOldPrinc = 0;
    CXkdcPrincipal **ppOldPrinc = NULL;

    INT cTitleVersions = 0;
    CTitleVersionTable *pTitleVersions = NULL;

    INT cOldTitleVersions = 0;
    CTitleVersionTable *pOldTitleVersions = NULL;

	xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) Reinitialize: starting reinitialization.", __FILE__, __LINE__);
    XomTrace(Xkdc, L_NORMAL, "(%s:%d) Reinitialize: starting reinitialization.", __FILE__, __LINE__);

    status = LoadServicePrincipals(&cPrinc, &ppPrinc);
    if ( !NT_SUCCESS(status) )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) Reinitialize: LoadServicePrincipals returned status 0x%08X.", __FILE__, __LINE__, status);
        XomTrace(Xkdc, L_ERROR, "(%s:%d) Reinitialize: LoadServicePrincipals returned status 0x%08X.", __FILE__, __LINE__, status);
        goto Cleanup;
    }

    status = LoadTitleVersions(&cTitleVersions, &pTitleVersions);
    if ( !NT_SUCCESS(status) )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) Reinitialize: LoadTitleVersions returned status 0x%08X.", __FILE__, __LINE__, status);
        XomTrace(Xkdc, L_ERROR, "(%s:%d) Reinitialize: LoadTitleVersions returned status 0x%08X.", __FILE__, __LINE__, status);
        goto Cleanup;
    }

    ConfigWriteLock();

    if ( ppPrinc && cPrinc > 0 )
    {
        status = ReplaceServicePrincipals(cPrinc, ppPrinc, &cOldPrinc, &ppOldPrinc);
        if ( !NT_SUCCESS(status) )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log", "(%s:%d) Reinitialize: ReplaceServicePrincipals returned status 0x%08X.", __FILE__, __LINE__, status);
            XomTrace(Xkdc, L_ERROR, "(%s:%d) Reinitialize: ReplaceServicePrincipals returned status 0x%08X.", __FILE__, __LINE__, status);
        }
        else
        {
            ppPrinc = NULL;
            cPrinc = 0;
        }
    }

    if ( pTitleVersions && cTitleVersions > 0 )
    {
        status = ReplaceTitleVersions(cTitleVersions, pTitleVersions, &cOldTitleVersions, &pOldTitleVersions);
        if ( !NT_SUCCESS(status) )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) Reinitialize: ReplaceTitleVersions returned status 0x%08X.", __FILE__, __LINE__, status);
            XomTrace(Xkdc, L_ERROR, "(%s:%d) Reinitialize: ReplaceTitleVersions returned status 0x%08X.", __FILE__, __LINE__, status);
        }
        else
        {
            pTitleVersions = NULL;
            cTitleVersions = 0;
        }
    }

    ConfigWriteUnlock();


 Cleanup:

    if (NT_SUCCESS(status))
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","Reinitialize: completed reinitialization.");
        XomNtEvent(XEVENT_XKDC_RELOAD_SUCCESS, "Reinitialize: completed reinitialization.");
    }
    else
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","Reinitialize: failed reinitialization. A previous event(s) will have more information.");
        XomNtEvent(XEVENT_XKDC_RELOAD_FAIL, "Reinitialize: failed reinitialization. A previous event(s) will have more information.");
    }

    if ( cPrinc > 0 && ppPrinc )
    {
        FreeServicePrincipals(cPrinc, ppPrinc);
        cPrinc = 0;
        ppPrinc = NULL;
    }

    if ( cOldPrinc > 0 && ppOldPrinc )
    {
        FreeServicePrincipals(cOldPrinc, ppOldPrinc);
        cOldPrinc = 0;
        ppOldPrinc = NULL;
    }

    if ( pTitleVersions )
    {
        FreeTitleVersions(pTitleVersions);
        pTitleVersions = NULL;
        cTitleVersions = 0;
    }

    if ( pOldTitleVersions )
    {
        FreeTitleVersions(pOldTitleVersions);
        pOldTitleVersions = NULL;
        cOldTitleVersions = 0;
    }

    return status;
}


NTSTATUS
CXkdcProvider::InitializePrincipalStore()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    status = CXBaseProvider::InitializePrincipalStore();
    if ( !NT_SUCCESS(status) )
    {
        goto Cleanup;
    }

Cleanup:
    return STATUS_SUCCESS;
}


struct FreeXkdcServicePrincipal
{
    static void Free(XkdcServicePrincipal * const pPrincipal)
    {
        SysFreeString(pPrincipal->CanonicalServiceName);
        SysFreeString(pPrincipal->CanonicalDomainName);
        SysFreeString(pPrincipal->Ip);
        SysFreeString(pPrincipal->KerbServiceName);
        SysFreeString(pPrincipal->KerbDomainName);
        SafeArrayDestroy(pPrincipal->Key);
    }
};
typedef CKdcAutoPtr<XkdcServicePrincipal, FreeXkdcServicePrincipal> CXkdcServicePrincipalsAutoPtr;

NTSTATUS
CXkdcProvider::LoadServicePrincipals(
    OUT INT *pcPrinc,
    OUT CXkdcPrincipal ***pppPrinc)
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    BOOL fOk = FALSE;
    INT cActualPrinc = 0;
    INT cActualRows = 0;
    CXkdcPrincipal **ppPrinc = NULL;
    XkdcCredential *pCred = NULL;

    XkdcServicePrincipal * pServicePrincipals = NULL;
    unsigned long cServicePrincipals = 0;
    CXkdcServicePrincipalsAutoPtr autoPtrServicePrincipals(&pServicePrincipals, &cServicePrincipals);


    XOMASSERT( pcPrinc );
    XOMASSERT( pppPrinc );

    if ( NULL == pcPrinc || NULL == pppPrinc )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "(%s:%d) LoadServicePrincipals: invalid NULL parameter.",
            __FILE__,
            __LINE__);
        XomNtEvent(XEVENT_KDC_CODE_241,
            "(%s:%d) LoadServicePrincipals: invalid NULL parameter.",
            __FILE__,
            __LINE__);
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    *pcPrinc = 0;
    *pppPrinc = NULL;

    // execute command on UODB
    hr = m_pManagedProxy->XkdcGetServicePrincipal(&pServicePrincipals, &cServicePrincipals);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // reset the signing key.
    ZeroMemory( &m_signingKey, sizeof( m_signingKey ) );

    // get out if the number of principals is zero. this is not valid, leave "status" as
    // an error.
    if ( cServicePrincipals == 0 || pServicePrincipals == NULL)
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","%s: The sproc p_xkdc_get_service_principals returned 0 principals. "
                   "This is invalid and indicates UODB has not been correctly populated.",
                   __FUNCTION__);
        XomNtEvent(XEVENT_XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_NONE,
                   "%s: The sproc p_xkdc_get_service_principals returned 0 principals. "
                   "This is invalid and indicates UODB has not been correctly populated.",
                   __FUNCTION__);
        goto Cleanup;
    }

    size_t const sizePpPrinc = cServicePrincipals * sizeof(CXkdcPrincipal*);
    ppPrinc = (CXkdcPrincipal**) KdcAllocMemory(sizePpPrinc);
    if ( NULL == ppPrinc )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","LoadServicePrincipals: failed to allocate %d bytes.",
            sizePpPrinc);
        XomNtEvent(XEVENT_XKDC_NO_MEMORY_12,
            "LoadServicePrincipals: failed to allocate %d bytes.",
            sizePpPrinc);

        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    ZeroMemory( ppPrinc, sizePpPrinc );

    for (unsigned long i=0; i < cServicePrincipals; i++ )
    {
        XkdcServicePrincipal const * const pCur = &pServicePrincipals[i];

        DWORD dwNumKeys = pCur->KeyCount;
        DWORD dwCredSize = sizeof(XkdcCredential) + dwNumKeys * (sizeof(XkdcKey) + XKDC_KEYSIZE);

        DWORD dwServiceID = pCur->ServiceId;
        DWORD dwTitleID = pCur->TitleId;
        DWORD dwTitleVersion = pCur->TitleVersion;
        DWORD dwTitleRegion = pCur->TitleRegion;
        WORD  wPort = pCur->Port;
        DWORD dwMachineOnly = pCur->MachineOnly;
        DWORD dwServiceAvailable = pCur->ServiceAvailable;
        DWORD dwAuthdataVersion = pCur->AuthDataVersion;

        XKDC_PRINCIPAL sPrinc = {0};
        lstrcpynW(sPrinc.wszServiceName, pCur->CanonicalServiceName, _countof(sPrinc.wszServiceName));
        lstrcpynW(sPrinc.wszDomainName, pCur->CanonicalDomainName, _countof(sPrinc.wszDomainName));
        sPrinc.iType = pCur->PrincipalType;
        sPrinc.iFlags = pCur->PrincipalFlags;

        WCHAR wszIPAddr[16] = {0};
        lstrcpynW(wszIPAddr, pCur->Ip, _countof(wszIPAddr));
        CHAR szIPAddr[16] = {0};
        WCHAR wszServiceName[31] = {0};
        lstrcpynW(wszServiceName, pCur->KerbServiceName, _countof(wszServiceName));
        WCHAR wszDomainName[31] = {0};
        lstrcpynW(wszDomainName, pCur->KerbDomainName, _countof(wszDomainName));

        DWORD dwTicketLifetimeSecs = 0;
        DWORD dwIPAddr = 0;
        LARGE_INTEGER liTicketLifetime = {0};
        LARGE_INTEGER liMaxRenewalTime = {0};
        DWORD dwActualNumKeys = 0;

        cActualPrinc++;

        pCred = (XkdcCredential*) KdcAllocMemory(dwCredSize);
        if ( NULL == pCred )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","LoadServicePrincipals: failed to allocate %d bytes for keys.",
                dwCredSize);
            XomNtEvent(XEVENT_XKDC_NO_MEMORY_13,
                "LoadServicePrincipals: failed to allocate %d bytes for keys.",
                dwCredSize);

            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        ZeroMemory(pCred, dwCredSize);

        pCred->dwKeyCount = dwNumKeys;

        // read all of the keys into the credential array
        for (DWORD k=0; k<dwNumKeys; k++)
        {
            DWORD dwMasterKeyVersion = 0;
            DWORD dwKeyVersion = 0;
            DWORD dwKeyLen = 0;

            dwActualNumKeys++;
            cActualRows++;

            // read this key from the database.
            hr = FillKeysFromXkdcPrincipals(i, k, &sPrinc, pCred, dwCredSize, &dwKeyVersion, &dwKeyLen, pServicePrincipals, cServicePrincipals, &dwTicketLifetimeSecs);
            if ( SUCCEEDED(hr) )
            {
                // NOTE:  The Signing key is actually the krbtgt/Xbox.Com key...
                //  if we see that key go by... then set the key.  Make sure it's also the latest key version.
                if ( wcscmp( sPrinc.wszServiceName, L"krbtgt" ) == 0 &&
                     wcscmp( sPrinc.wszDomainName, L"XBOX.COM" ) == 0 &&
                     m_signingKey.lKeyVersion < (LONG)dwKeyVersion )
                {
					xlog5("c:\\xkdc-XkdcProvider-cpp.log", "(%s:%d) LoadServicePrincipals: Attained signing key from %S/%S.",
                              __FILE__,
                              __LINE__,
                              sPrinc.wszServiceName,
                              sPrinc.wszDomainName );
                    XomTrace(Xkdc, L_LOW,
                              "(%s:%d) LoadServicePrincipals: Attained signing key from %S/%S.",
                              __FILE__,
                              __LINE__,
                              sPrinc.wszServiceName,
                              sPrinc.wszDomainName );
                    m_signingKey.lKeyVersion = dwKeyVersion;
                    memcpy( (void*)(m_signingKey.binKey), pCred->Key[k].Key.keyvalue.value, XKDC_KEYSIZE );
                }
            }

			xlog5("c:\\xkdc-XkdcProvider-cpp.log","SVP|%d|%X|%S/%S|%d|%d|%S|%d|%S/%S|0x%X|0x%08X|%X|%X|%d|%d|%d|%d|%d|%d|%d",
                cActualRows,
                hr,
                sPrinc.wszServiceName,
                sPrinc.wszDomainName,
                sPrinc.iType,
                sPrinc.iFlags,
                wszIPAddr,
                dwAuthdataVersion,
                wszServiceName,
                wszDomainName,
                dwServiceID,
                dwTitleID,
                dwTitleVersion,
                dwTitleRegion,
                (DWORD)wPort,
                dwMachineOnly,
                dwServiceAvailable,
                dwTicketLifetimeSecs,
                dwMasterKeyVersion,
                dwKeyVersion,
                dwKeyLen
                );
            XomLog( log, "SVP|%d|%X|%S/%S|%d|%d|%S|%d|%S/%S|0x%X|0x%08X|%X|%X|%d|%d|%d|%d|%d|%d|%d",
                cActualRows,
                hr,
                sPrinc.wszServiceName,
                sPrinc.wszDomainName,
                sPrinc.iType,
                sPrinc.iFlags,
                wszIPAddr,
                dwAuthdataVersion,
                wszServiceName,
                wszDomainName,
                dwServiceID,
                dwTitleID,
                dwTitleVersion,
                dwTitleRegion,
                (DWORD)wPort,
                dwMachineOnly,
                dwServiceAvailable,
                dwTicketLifetimeSecs,
                dwMasterKeyVersion,
                dwKeyVersion,
                dwKeyLen
                );

            // check if we're done reading (hr is S_FALSE)...
            if ( hr == S_FALSE )
            {
                if ( ( cServicePrincipals != cActualPrinc ) || ( dwNumKeys != dwActualNumKeys ) )
                {
					xlog5("c:\\xkdc-XkdcProvider-cpp.log", "LoadServicePrincipals: Missing principal data. Read %d principals, but expected %d principals. "
                               "Please investigate the p_xkdc_get_principals sproc for integrity.",
                               cActualPrinc, cServicePrincipals);

                    XomNtEvent(XEVENT_XKDC_UODB_MISMATCH_2,
                               "LoadServicePrincipals: Missing principal data. Read %d principals, but expected %d principals. "
                               "Please investigate the p_xkdc_get_principals sproc for integrity.",
                               cActualPrinc, cServicePrincipals);

                    goto Cleanup;
                }
                break;
            }
            else if (FAILED(hr))
            {
                goto Cleanup;
            }

        }

        // convert the IP address string from Unicode to ANSI
        if ( 0 == WideCharToMultiByte(CP_ACP, 0, wszIPAddr, -1, szIPAddr, ARRAYSIZE(szIPAddr), NULL, NULL) )
        {
            DWORD dwError = GetLastError();
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to load principal %S/%S for service id %d (0x%X). This should be fixed immediately. Detailed info:\n\n"
                       "Failed to convert IP address from WCHAR to MULTIBYTE. GetLastError = %d",
                       sPrinc.wszServiceName, sPrinc.wszDomainName, dwServiceID, dwServiceID,
                       dwError);
            XomNtEvent(XEVENT_XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_IPSTR,
                       "Failed to load principal %S/%S for service id %d (0x%X). This should be fixed immediately. Detailed info:\n\n"
                       "Failed to convert IP address from WCHAR to MULTIBYTE. GetLastError = %d",
                       sPrinc.wszServiceName, sPrinc.wszDomainName, dwServiceID, dwServiceID,
                       dwError);
            goto Cleanup;
        }

        // convert the ANSI IP address string to a DWORD
        dwIPAddr = inet_addr(szIPAddr);
        if ( INADDR_NONE == dwIPAddr )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to load principal %S/%S for service id %d (0x%X). This should be fixed immediately. Detailed info:\n\n"
                       "Failed to convert IP string \"%s\" to a real IP address.",
                       sPrinc.wszServiceName, sPrinc.wszDomainName, dwServiceID, dwServiceID,
                       szIPAddr);
            XomNtEvent(XEVENT_XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_IP,
                       "Failed to load principal %S/%S for service id %d (0x%X). This should be fixed immediately. Detailed info:\n\n"
                       "Failed to convert IP string \"%s\" to a real IP address.",
                       sPrinc.wszServiceName, sPrinc.wszDomainName, dwServiceID, dwServiceID,
                       szIPAddr);
            goto Cleanup;
        }

        // make ticket lifetime usable by KDC core
        liTicketLifetime.QuadPart = (LONGLONG) 10000000 * dwTicketLifetimeSecs;

        // build a new principal from this data
        CXkdcPrincipal *piPrinc = new CXkdcPrincipal();
        if ( NULL == piPrinc )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to allocate memory for a new CXkdcPrincipal (%d bytes).",
                       sizeof(CXkdcPrincipal));
            XomNtEvent(XEVENT_XKDC_NO_MEMORY_18,
                       "Failed to allocate memory for a new CXkdcPrincipal (%d bytes).",
                       sizeof(CXkdcPrincipal));
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        // Xbox 360 Console Software : Bug 48050
        // Do not allow any service in the range 128 - 255 since those are
        // reserved for user privileges and machine privileges
        if (dwServiceID >= XONLINE_MAX_BASE_SERVICES_ID && dwServiceID < XONLINE_MAX_PRIVILEGE_ID)
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log", "Illegal service id %d (0x%X) for principal %S/%S. This should be fixed immediately.\n",
                       dwServiceID, dwServiceID, sPrinc.wszServiceName, sPrinc.wszDomainName
                       );

            XomNtEvent(XEVENT_XKDC_SERVICE_ID_INVALID,
                       "Illegal service id %d (0x%X) for principal %S/%S. This should be fixed immediately.\n",
                       dwServiceID, dwServiceID, sPrinc.wszServiceName, sPrinc.wszDomainName
                       );
            goto Cleanup;
        }

        status = piPrinc->Initialize(
                    this,
                    GetKdcCore(),
                    &m_ustrRealmName,
                    &sPrinc,
                    pCred,
                    wszServiceName,
                    wszDomainName,
                    dwIPAddr,
                    dwServiceID,
                    dwTitleID,
                    dwTitleVersion,
                    dwTitleRegion,
                    wPort,
                    dwMachineOnly,
                    dwServiceAvailable,
                    dwAuthdataVersion,
                    liTicketLifetime,
                    liMaxRenewalTime,
                    KERB_KDB_TIME_NEVER,
                    KERB_KDB_TIME_NEVER,
                    KERB_KDB_DATA_ALL);

        if ( !NT_SUCCESS(status) )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) LoadServicePrincipals: principal failed to initialize.", __FILE__, __LINE__);
            XomTrace(Xkdc, L_ERROR, "(%s:%d) LoadServicePrincipals: principal failed to initialize.", __FILE__, __LINE__);
            goto Cleanup;
        }

        // if we've made it this far, the principal is valid
        ppPrinc[i] = piPrinc;

        // piPrinc aka ppPrinc[i] owns this memory now
        pCred = NULL;

        // send some debug spew indicating that principals are loading
        if ( 0 == piPrinc->GetTitleID() )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) LoadServicePrincipals: loaded principal site='%S/%S', service='%S/%S', service id=%d, port=%d.",
                __FILE__,
                __LINE__,
                piPrinc->GetName()->Names[0].Buffer,
                piPrinc->GetName()->Names[1].Buffer,
                piPrinc->GetServiceName()->Names[0].Buffer,
                piPrinc->GetServiceName()->Names[1].Buffer,
                piPrinc->GetServiceID(),
                (DWORD) piPrinc->GetServicePort()
                );

            XomTrace(Xkdc, L_NORMAL,
                "(%s:%d) LoadServicePrincipals: loaded principal site='%S/%S', service='%S/%S', service id=%d, port=%d.",
                __FILE__,
                __LINE__,
                piPrinc->GetName()->Names[0].Buffer,
                piPrinc->GetName()->Names[1].Buffer,
                piPrinc->GetServiceName()->Names[0].Buffer,
                piPrinc->GetServiceName()->Names[1].Buffer,
                piPrinc->GetServiceID(),
                (DWORD) piPrinc->GetServicePort()
                );
        }
        else
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) LoadServicePrincipals: loaded principal site='%S/%S', service='%S/%S', service id=%d, port=%d, title id=0x%08X, version=%d, region=%d.",
                __FILE__,
                __LINE__,
                piPrinc->GetName()->Names[0].Buffer,
                piPrinc->GetName()->Names[1].Buffer,
                piPrinc->GetServiceName()->Names[0].Buffer,
                piPrinc->GetServiceName()->Names[1].Buffer,
                piPrinc->GetServiceID(),
                (DWORD) piPrinc->GetServicePort(),
                piPrinc->GetTitleID(),
                piPrinc->GetTitleVersion(),
                piPrinc->GetTitleRegion()
                );
            XomTrace(Xkdc, L_NORMAL,
                "(%s:%d) LoadServicePrincipals: loaded principal site='%S/%S', service='%S/%S', service id=%d, port=%d, title id=0x%08X, version=%d, region=%d.",
                __FILE__,
                __LINE__,
                piPrinc->GetName()->Names[0].Buffer,
                piPrinc->GetName()->Names[1].Buffer,
                piPrinc->GetServiceName()->Names[0].Buffer,
                piPrinc->GetServiceName()->Names[1].Buffer,
                piPrinc->GetServiceID(),
                (DWORD) piPrinc->GetServicePort(),
                piPrinc->GetTitleID(),
                piPrinc->GetTitleVersion(),
                piPrinc->GetTitleRegion()
                );
        }
    }

    // everything was successful so return the new principals
    *pcPrinc = cServicePrincipals;
    *pppPrinc = ppPrinc;

    // don't set cServicePrincipals to 0, the auto-ptr has a ptr to it
    ppPrinc = NULL;

    fOk = TRUE;

Cleanup:
    if ( ppPrinc )
    {
        FreeServicePrincipals(cServicePrincipals, ppPrinc);
        ppPrinc = NULL;
    }

    if (pCred)
    {
        KdcFreeMemory(pCred);
        pCred = NULL;
    }

    return fOk
        ? S_OK                                              // success
        : status == S_OK ? STATUS_UNSUCCESSFUL : status;    // failure
}


NTSTATUS
CXkdcProvider::ReplaceServicePrincipals(
    IN  INT cPrinc,
    IN  CXkdcPrincipal **ppPrinc,
    OUT INT *pcOldPrinc,
    OUT CXkdcPrincipal ***pppOldPrinc)
{
    NTSTATUS status = STATUS_SUCCESS;
    INT cOldPrinc = 0;
    CXkdcPrincipal **ppOldPrinc = NULL;

    XOMASSERT( cPrinc > 0 );
    XOMASSERT( ppPrinc );
    XOMASSERT( pcOldPrinc );
    XOMASSERT( pppOldPrinc );

    // save the old service principals (if any)
    *pcOldPrinc = m_cPrinc;
    *pppOldPrinc = m_ppPrinc;

    // install the new service principals
    m_cPrinc = cPrinc;
    m_ppPrinc = ppPrinc;

    cPrinc = 0;
    ppPrinc = NULL;

    return status;
}


void
CXkdcProvider::FreeServicePrincipals(
    IN INT cPrinc,
    IN CXkdcPrincipal **ppPrinc)
{
    if ( ppPrinc )
    {
        if ( cPrinc > 0 )
        {
            for (int i=0; i < cPrinc; i++)
            {
                if ( ppPrinc[i] )
                {
                    ppPrinc[i]->Release();
                    ppPrinc[i] = NULL;
                }
            }
        }

        KdcFreeMemory(ppPrinc);
    }
}


typedef CKdcAutoPtr<XkdcTitleVersionInfo> CXkdcXkdcTitleVersionInfoAutoPtr;
NTSTATUS
CXkdcProvider::LoadTitleVersions(
    OUT INT *pcTitleVersions,
    OUT CTitleVersionTable **ppTitleVersions)
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    BSTR bstrName = NULL;
    CTitleVersionTable *pTitleVersions = NULL;
    XkdcTitleVersionInfo * pTitleVersionInfos = NULL;
    unsigned long cTitleVersionInfos = 0;
    CXkdcXkdcTitleVersionInfoAutoPtr autoPtrTitleVersionInfo(&pTitleVersionInfos, &cTitleVersionInfos);

    XOMASSERT( pcTitleVersions );
    XOMASSERT( ppTitleVersions );

    if ( NULL == pcTitleVersions || NULL == ppTitleVersions )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "(%s:%d) LoadTitleVersions: invalid NULL parameter.",
            __FILE__,
            __LINE__);

        XomNtEvent(XEVENT_KDC_CODE_250,
            "(%s:%d) LoadTitleVersions: invalid NULL parameter.",
            __FILE__,
            __LINE__);
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    *pcTitleVersions = 0;
    *ppTitleVersions = NULL;

    pTitleVersions = new CTitleVersionTable;
    if ( NULL == pTitleVersions )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) LoadTitleVersions: failed to instantiate title version hash table.",
            __FILE__,
            __LINE__);

        XomNtEvent(XEVENT_KDC_CODE_251,
            "(%s:%d) LoadTitleVersions: failed to instantiate title version hash table.",
            __FILE__,
            __LINE__);
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    hr = pTitleVersions->Initialize(dwTitleHashTableSize, TITLE_KEY::Hash, NULL);
    if ( FAILED(hr) )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "CXkdcProvider::Initialize: pTitleVersions->Initialize failed, hr = 0x%08X", hr);
        XomTrace(Xkdc, L_ERROR, "CXkdcProvider::Initialize: pTitleVersions->Initialize failed, hr = 0x%08X", hr);
        status = STATUS_SERVER_DISABLED;
        goto Cleanup;
    }

    hr = m_pManagedProxy->XkdcGetTitleVersionInfo(&pTitleVersionInfos, &cTitleVersionInfos);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // if no title updates are present, leave now
    if ( 0 == cTitleVersionInfos )
    {
        goto Cleanup;
    }

    // load each title version tuple into the title hash table
    status = BuildTitleVersions(pTitleVersionInfos, cTitleVersionInfos, pTitleVersions);
    if ( !NT_SUCCESS(status) )
    {
        goto Cleanup;
    }

    // everything was successful so return the new title versions
    *pcTitleVersions = cTitleVersionInfos;
    *ppTitleVersions = pTitleVersions;

    // don't set cTitleVersionInfos to 0, the auto-ptr has a ptr to it
    pTitleVersions = NULL;

Cleanup:
    if ( pTitleVersions )
    {
        FreeTitleVersions(pTitleVersions);
        pTitleVersions = NULL;
    }

    return status;
}


NTSTATUS
CXkdcProvider::BuildTitleVersions(
    IN XkdcTitleVersionInfo const * const pTitleVersionInfos,
    IN unsigned long const cTitleVersionInfos,
    OUT CTitleVersionTable * const pTitleVersions)
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    CHAR szLogEntry[2048];
    WCHAR wszStartTime[32];
    WCHAR wszStartDate[32];
    WCHAR wszEndTime[32];
    WCHAR wszEndDate[32];
    WCHAR wszGuid[39]; // size of a string'd out GUID
    DWORD dwConsoleType = 999;

    BOOL bConvertedTime;
    SYSTEMTIME stStartTime, stEndTime;

    for (unsigned long i=0; i < cTitleVersionInfos; i++)
    {
        XkdcTitleVersionInfo const * const pCur = &pTitleVersionInfos[i];
        TITLE_KEY Key = {0};
        TITLE_VERSION *pTitle = (TITLE_VERSION*) KdcAllocMemory(sizeof(TITLE_VERSION));
        if ( NULL == pTitle )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) BuildTitleVersions: failed to allocate %d bytes.", __FILE__, __LINE__, sizeof(TITLE_VERSION));
            XomNtEvent(XEVENT_XKDC_NO_MEMORY_14, "(%s:%d) BuildTitleVersions: failed to allocate %d bytes.", __FILE__, __LINE__, sizeof(TITLE_VERSION));
            XomTrace(Xkdc, L_ERROR, "(%s:%d) BuildTitleVersions: failed to allocate %d bytes.", __FILE__, __LINE__, sizeof(TITLE_VERSION));
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        C_ASSERT(ARRAYSIZE(pTitle->dwAlternateTitleIds) == 4);
        C_ASSERT(ARRAYSIZE(pTitle->aAltLiveTitleIds) == 4);

        StringFromGUID2(pCur->GroupGuid, wszGuid, sizeof(wszGuid)/sizeof(wszGuid[0]));

        Key.dwTitleID = pCur->TitleId;
        Key.dwTitleRegion = pCur->TitleRegion;
        Key.dwMediaID = pCur->MediaId;
        Key.dwBaseVersion = pCur->BaseVersion;
        Key.guidGroupID = pCur->GroupGuid;
        pTitle->dwUpdateVersion = pCur->UpdateVersion;
        pTitle->dwBetaVersion = pCur->BetaVersion;
        pTitle->dwLiveTitleId = pCur->LiveTitleId;
        pTitle->dwAlternateTitleIds[0] = pCur->AlternateId1;
        pTitle->dwAlternateTitleIds[1] = pCur->AlternateId2;
        pTitle->dwAlternateTitleIds[2] = pCur->AlternateId3;
        pTitle->dwAlternateTitleIds[3] = pCur->AlternateId4;
        pTitle->aAltLiveTitleIds[0].dwServiceId = pCur->Service1;
        pTitle->aAltLiveTitleIds[0].dwTitleId = pCur->Service1AltId;
        pTitle->aAltLiveTitleIds[1].dwServiceId = pCur->Service2;
        pTitle->aAltLiveTitleIds[1].dwTitleId = pCur->Service2AltId;
        pTitle->aAltLiveTitleIds[2].dwServiceId = pCur->Service3;
        pTitle->aAltLiveTitleIds[2].dwTitleId = pCur->Service3AltId;
        pTitle->aAltLiveTitleIds[3].dwServiceId = pCur->Service4;
        pTitle->aAltLiveTitleIds[3].dwTitleId = pCur->Service4AltId;

        // Pull out the start time from the marshalled .NET object and make a human
        // readable string. The only time that FileTimeToSystemTime should fail is if the 64 bit 
        // filetime is more than 0x8000000000000000, so the start time should always pass.
        //
        hr = GetFILETIMEFromDATE(pCur->StartTime, &pTitle->ftStartTime);
        bConvertedTime = FileTimeToSystemTime(&pTitle->ftStartTime, &stStartTime);
        if(hr != S_OK || !bConvertedTime)
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) BuildTitleVersions: GetFILETIMEFromDATE or FileTimeToSystemTime failed converting start DATE %d for Title ID %08x, hr = 0x%08lx",
                __FILE__,
                __LINE__,
                pCur->StartTime,
                pCur->TitleId,
                hr);

            XomTrace(Xkdc, L_ERROR,
                "(%s:%d) BuildTitleVersions: GetFILETIMEFromDATE or FileTimeToSystemTime failed converting start DATE %d for Title ID %08x, hr = 0x%08lx",
                __FILE__,
                __LINE__,
                pCur->StartTime,
                pCur->TitleId,
                hr);

			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) BuildTitleVersions: GetFILETIMEFromDATE or FileTimeToSystemTime failed converting start DATE %d for Title ID %08x, hr = 0x%08lx",
                __FILE__,
                __LINE__,
                pCur->StartTime,
                pCur->TitleId,
                hr);

            XomNtEvent(XEVENT_XKDC_TITLE_BAD_START_END_TIME,
                "(%s:%d) BuildTitleVersions: GetFILETIMEFromDATE or FileTimeToSystemTime failed converting start DATE %d for Title ID %08x, hr = 0x%08lx",
                __FILE__,
                __LINE__,
                pCur->StartTime,
                pCur->TitleId,
                hr);

            status = ERROR_INVALID_PARAMETER;
        }

        GetTimeFormatEx( LOCALE_NAME_INVARIANT,
                TIME_NOSECONDS | TIME_FORCE24HOURFORMAT,
                &stStartTime,
                NULL,
                wszStartTime,
                _countof(wszStartTime));

        GetDateFormatEx( LOCALE_NAME_INVARIANT,
                0,
                &stStartTime,
                L"yyyy'-'MM'-'dd",
                wszStartDate,
                _countof(wszStartDate),
                NULL);

        // Now do the end date.
        //
        hr = GetFILETIMEFromDATE(pCur->EndTime, &pTitle->ftEndTime);
        bConvertedTime = FileTimeToSystemTime(&pTitle->ftEndTime, &stEndTime);
        if(hr != S_OK || !bConvertedTime)
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) BuildTitleVersions: GetFILETIMEFromDATE or FileTimeToSystemTime failed converting end DATE %d for Title ID %08x, hr = 0x%08lx",
                __FILE__,
                __LINE__,
                pCur->EndTime,
                pCur->TitleId,
                hr);

            XomTrace(Xkdc, L_ERROR,
                "(%s:%d) BuildTitleVersions: GetFILETIMEFromDATE or FileTimeToSystemTime failed converting end DATE %d for Title ID %08x, hr = 0x%08lx",
                __FILE__,
                __LINE__,
                pCur->EndTime,
                pCur->TitleId,
                hr);

			xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) BuildTitleVersions: GetFILETIMEFromDATE or FileTimeToSystemTime failed converting end DATE %d for Title ID %08x, hr = 0x%08lx",
                __FILE__,
                __LINE__,
                pCur->EndTime,
                pCur->TitleId,
                hr);

            XomNtEvent(XEVENT_XKDC_TITLE_BAD_START_END_TIME,
                "(%s:%d) BuildTitleVersions: GetFILETIMEFromDATE or FileTimeToSystemTime failed converting end DATE %d for Title ID %08x, hr = 0x%08lx",
                __FILE__,
                __LINE__,
                pCur->EndTime,
                pCur->TitleId,
                hr);

            status = ERROR_INVALID_PARAMETER;
        }

        GetTimeFormatEx( LOCALE_NAME_INVARIANT,
                TIME_NOSECONDS | TIME_FORCE24HOURFORMAT,
                &stEndTime,
                NULL,
                wszEndTime,
                _countof(wszEndTime));

        GetDateFormatEx( LOCALE_NAME_INVARIANT,
                0,
                &stEndTime,
                L"yyyy'-'MM'-'dd",
                wszEndDate,
                _countof(wszEndDate),
                NULL);

        dwConsoleType = pCur->ConsoleTypeId;

        // Convert console type, a value from uodb..t_console_types into platform type, a
        // value from the XPLT_* constants declared in xonline.x.
        Key.dwPlatformType = ConvertConsoleToPlatformType(dwConsoleType);

        pTitle->dwBaseVersion = Key.dwBaseVersion;

        // If live-title-id is zero, meaning that it was not explicitly
        // configured in the database, use dwTitleId as the live-title-id
        if(pTitle->dwLiveTitleId == 0)
        {
            pTitle->dwLiveTitleId = Key.dwTitleID;
        }

        // Add to title-version struct to hash-table
        pTitleVersions->Insert(Key, pTitle);

        // Trace:
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","BuildTitleVersions:");
        XomTrace(Xkdc, L_NORMAL, "BuildTitleVersions:");
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","Key.dwTitleID=0x%08x", Key.dwTitleID);
        XomTrace(Xkdc, L_NORMAL, "Key.dwTitleID=0x%08x", Key.dwTitleID);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","Key.dwPlatformType=0x%08x", Key.dwPlatformType);
        XomTrace(Xkdc, L_NORMAL, "Key.dwPlatformType=0x%08x", Key.dwPlatformType);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "Key.dwTitleRegion=0x%08x", Key.dwTitleRegion);
        XomTrace(Xkdc, L_NORMAL, "Key.dwTitleRegion=0x%08x", Key.dwTitleRegion);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "Key.dwMediaID=0x%08x", Key.dwMediaID);
        XomTrace(Xkdc, L_NORMAL, "Key.dwMediaID=0x%08x", Key.dwMediaID);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "Key.dwBaseVersion=0x%08x", Key.dwBaseVersion);
        XomTrace(Xkdc, L_NORMAL, "Key.dwBaseVersion=0x%08x", Key.dwBaseVersion);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "Key.guidGroupId=%S", wszGuid);
        XomTrace(Xkdc, L_NORMAL, "Key.guidGroupId=%S", wszGuid);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "pTitle->dwUpdateVersion=0x%08x", pTitle->dwUpdateVersion);
        XomTrace(Xkdc, L_NORMAL, "pTitle->dwUpdateVersion=0x%08x", pTitle->dwUpdateVersion);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "pTitle->dwBetaVersion=0x%08x", pTitle->dwBetaVersion);
        XomTrace(Xkdc, L_NORMAL, "pTitle->dwBetaVersion=0x%08x", pTitle->dwBetaVersion);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","pTitle->dwLiveTitleId=0x%08x", pTitle->dwLiveTitleId);
        XomTrace(Xkdc, L_NORMAL, "pTitle->dwLiveTitleId=0x%08x", pTitle->dwLiveTitleId);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","pTitle->ftStartTime=%S %S", wszStartTime, wszStartDate);
        XomTrace(Xkdc, L_NORMAL, "pTitle->ftStartTime=%S %S", wszStartTime, wszStartDate);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "pTitle->ftEndTime=%S %S", wszEndTime, wszEndDate);
        XomTrace(Xkdc, L_NORMAL, "pTitle->ftEndTime=%S %S", wszEndTime, wszEndDate);

		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "pTitle->dwAlternateTitleIds[%u]=0x%08x", i, pTitle->dwAlternateTitleIds[i]);
        for(DWORD i=0; i < ARRAYSIZE(pTitle->dwAlternateTitleIds); i++)
            XomTrace(Xkdc, L_NORMAL, "pTitle->dwAlternateTitleIds[%u]=0x%08x", i, pTitle->dwAlternateTitleIds[i]);

        for(DWORD i=0; i < ARRAYSIZE(pTitle->aAltLiveTitleIds); i++)
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","pTitle->aAltLiveTitleIds[%u].dwServiceId =0x%08x", i, pTitle->aAltLiveTitleIds[i].dwServiceId );
            XomTrace(Xkdc, L_NORMAL, "pTitle->aAltLiveTitleIds[%u].dwServiceId =0x%08x", i, pTitle->aAltLiveTitleIds[i].dwServiceId );
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","pTitle->aAltLiveTitleIds[%u].dwTitleId=0x%08x", i, pTitle->aAltLiveTitleIds[i].dwTitleId);
            XomTrace(Xkdc, L_NORMAL, "pTitle->aAltLiveTitleIds[%u].dwTitleId=0x%08x", i, pTitle->aAltLiveTitleIds[i].dwTitleId);
        }

        // Log:
        szLogEntry[0] = '\0';
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","TUV|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|%S|%ST%S|%ST%S",
            Key.dwTitleID,
            Key.dwTitleRegion,
            Key.dwMediaID,
            pTitle->dwBaseVersion,
            pTitle->dwUpdateVersion,
            pTitle->dwBetaVersion,
            pTitle->dwLiveTitleId,
            pTitle->dwAlternateTitleIds[0],
            pTitle->dwAlternateTitleIds[1],
            pTitle->dwAlternateTitleIds[2],
            pTitle->dwAlternateTitleIds[3],
            pTitle->aAltLiveTitleIds[0].dwServiceId,
            pTitle->aAltLiveTitleIds[0].dwTitleId,
            pTitle->aAltLiveTitleIds[1].dwServiceId,
            pTitle->aAltLiveTitleIds[1].dwTitleId,
            pTitle->aAltLiveTitleIds[2].dwServiceId,
            pTitle->aAltLiveTitleIds[2].dwTitleId,
            pTitle->aAltLiveTitleIds[3].dwServiceId,
            pTitle->aAltLiveTitleIds[3].dwTitleId,
            Key.dwPlatformType,
            wszGuid,
            wszStartDate,
            wszStartTime,
            wszEndDate,
            wszEndTime);

        _snprintf(szLogEntry, ARRAYSIZE(szLogEntry), "TUV|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|0x%x|%S|%ST%S|%ST%S",
            Key.dwTitleID,
            Key.dwTitleRegion,
            Key.dwMediaID,
            pTitle->dwBaseVersion,
            pTitle->dwUpdateVersion,
            pTitle->dwBetaVersion,
            pTitle->dwLiveTitleId,
            pTitle->dwAlternateTitleIds[0],
            pTitle->dwAlternateTitleIds[1],
            pTitle->dwAlternateTitleIds[2],
            pTitle->dwAlternateTitleIds[3],
            pTitle->aAltLiveTitleIds[0].dwServiceId,
            pTitle->aAltLiveTitleIds[0].dwTitleId,
            pTitle->aAltLiveTitleIds[1].dwServiceId,
            pTitle->aAltLiveTitleIds[1].dwTitleId,
            pTitle->aAltLiveTitleIds[2].dwServiceId,
            pTitle->aAltLiveTitleIds[2].dwTitleId,
            pTitle->aAltLiveTitleIds[3].dwServiceId,
            pTitle->aAltLiveTitleIds[3].dwTitleId,
            Key.dwPlatformType,
            wszGuid,
            wszStartDate,
            wszStartTime,
            wszEndDate,
            wszEndTime);

        szLogEntry[ARRAYSIZE(szLogEntry)-1] = '\0';
        XomLog( log, "%s", szLogEntry);

        // If unknown title versions are allowed, add version 0 wildcard
        // entries for any title id that did not have an entry with base
        // version 0 in UODB.
        //
        // This doesn't work the same for groups though.  A row with a group
        // should not have a wildcard entry unless specified through the tool.
        // Too risky.
        if ( (BOOL)(GetDWORDSetting( Setting_kdcsvc_xkdc_allowUnknownVersion, 0)) )
        {
            TITLE_VERSION *pWildcard = NULL;

            TITLE_KEY WildKey = Key;
            WildKey.dwTitleRegion = 0;
            WildKey.dwMediaID     = 0;
            WildKey.dwBaseVersion = 0;
            memset(&WildKey.guidGroupID, 0, sizeof(WildKey.guidGroupID));

            // look for this entry... if it exists... don't do it again.
            HRESULT hr = pTitleVersions->Find(WildKey, pWildcard);
            if ( FAILED(hr) || NULL == pWildcard )
            {
                pWildcard = (TITLE_VERSION*) KdcAllocMemory(sizeof(TITLE_VERSION));
                if ( NULL == pWildcard )
                {
					xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) BuildTitleVersions: failed to allocate %d bytes.",
                        __FILE__,
                        __LINE__,
                        sizeof(TITLE_VERSION));

                    XomNtEvent(XEVENT_XKDC_NO_MEMORY_15,
                        "(%s:%d) BuildTitleVersions: failed to allocate %d bytes.",
                        __FILE__,
                        __LINE__,
                        sizeof(TITLE_VERSION));

					xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) BuildTitleVersions: failed to allocate %d bytes.",
                        __FILE__,
                        __LINE__,
                        sizeof(TITLE_VERSION));

                    XomTrace(Xkdc, L_ERROR,
                        "(%s:%d) BuildTitleVersions: failed to allocate %d bytes.",
                        __FILE__,
                        __LINE__,
                        sizeof(TITLE_VERSION));

                    status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                // make base, update, and beta versions all 0
                *pWildcard = *pTitle;
                pWildcard->dwBaseVersion   = 0;
                pWildcard->dwUpdateVersion = 0;
                pWildcard->dwBetaVersion   = 0;

                pTitleVersions->Insert(WildKey, pWildcard);

				xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) BuildTitleVersions: title ID 0x%08X, version 0 wildcard added.",
                    __FILE__,
                    __LINE__,
                    WildKey.dwTitleID);

                XomTrace(Xkdc, L_NORMAL,
                    "(%s:%d) BuildTitleVersions: title ID 0x%08X, version 0 wildcard added.",
                    __FILE__,
                    __LINE__,
                    WildKey.dwTitleID);
            }
        }
    }

Cleanup:
    return status;
}


NTSTATUS
CXkdcProvider::ReplaceTitleVersions(
    IN  INT cTitleVersions,
    IN  CTitleVersionTable *pTitleVersions,
    OUT INT *pcOldTitleVersions,
    OUT CTitleVersionTable **ppOldTitleVersions)
{
    NTSTATUS status = STATUS_SUCCESS;

    XOMASSERT( cTitleVersions > 0 );
    XOMASSERT( pTitleVersions );
    XOMASSERT( pcOldTitleVersions );
    XOMASSERT( ppOldTitleVersions );

    // save the old service principals (if any)
    *pcOldTitleVersions = m_cTitleVersions;
    *ppOldTitleVersions = m_pTitleVersions;

    // install the new service principals
    m_cTitleVersions = cTitleVersions;
    m_pTitleVersions = pTitleVersions;

    return status;
}


void
CXkdcProvider::FreeTitleVersions(
    IN CTitleVersionTable *pTitleVersions)
{
    if ( pTitleVersions )
    {
        TITLE_KEY Key = {0};
        TITLE_VERSION *pTitleVal = NULL;

        while ( pTitleVersions->GetFirst(Key, pTitleVal) )
        {
            TITLE_VERSION *pRemove = NULL;
            pTitleVersions->Remove(Key, pRemove);
            KdcFreeMemory(pRemove);
            pRemove = NULL;
            pTitleVal = NULL;
        }

        pTitleVersions->RemoveAll();

        delete pTitleVersions;
    }
}

BOOL
CXkdcProvider::ParseSite1LoadBalancingIps(
    IN  CComSafeArray<BSTR> &saValues,
    OUT DWORD *pcNewIps,
    OUT DWORD **ppdwNewIps)
{

    XOMASSERT(ppdwNewIps);
    XOMASSERT(pcNewIps);

    *ppdwNewIps = NULL;
    *pcNewIps = 0;

    BOOL    bRetVal = FALSE;
    BSTR    bstrValue;
    CHAR    szIpAddr[16] = {0};
    DWORD   dwIpAddr     = 0;
    DWORD*  pdwIps       = NULL;
    DWORD   dwCount      = saValues.GetCount();

    if (dwCount == 0)
    {
        // Return nothing. This means we'll fall back to the old behavior of using the
        // UODB..t_sites ip address.

        bRetVal = TRUE;
        goto Cleanup;
    }

    pdwIps = new DWORD[dwCount];
    if (pdwIps == NULL)
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "Out of memory allocating an array of %u IP addresses (%u bytes) "
                   "for the kdcsvc_xkdc_sgSite1Ips setting. This means the SG site1 "
                   "load balancing feature won't work, which should be investigated "
                   "immediately.",
                   dwCount, dwCount * sizeof(DWORD));
        XomNtEvent(XEVENT_XKDC_NO_MEMORY_SITE1_IPS,
                   "Out of memory allocating an array of %u IP addresses (%u bytes) "
                   "for the kdcsvc_xkdc_sgSite1Ips setting. This means the SG site1 "
                   "load balancing feature won't work, which should be investigated "
                   "immediately.",
                   dwCount, dwCount * sizeof(DWORD));
        goto Cleanup;
    }

    // Start the parsing

    for (DWORD i = 0; i < dwCount; i++)
    {
        bstrValue = saValues.GetAt(i);

        // convert the IP address string from Unicode to ANSI
        if ( 0 == WideCharToMultiByte(CP_ACP, 0, bstrValue, -1, szIpAddr, ARRAYSIZE(szIpAddr), NULL, NULL) )
        {
            DWORD dwError = GetLastError();
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to convert kdcsvc_xkdc_sgSite1Ips IP address \"%S\" from "
                       "WCHAR to MULTIBYTE. This should be investigated immediately. "
                       "GetLastError = %d",
                       bstrValue, dwError); 
            XomNtEvent(XEVENT_XKDC_FAILED_TO_PARSE_SITE1_IPSTR,
                       "Failed to convert kdcsvc_xkdc_sgSite1Ips IP address \"%S\" from "
                       "WCHAR to MULTIBYTE. This should be investigated immediately. "
                       "GetLastError = %d",
                       bstrValue, dwError);
            goto Cleanup;
        }

        // convert the ANSI IP address string to a DWORD
        dwIpAddr = inet_addr(szIpAddr);
        if ( INADDR_NONE == dwIpAddr )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log", "Failed to convert kdcsvc_xkdc_sgSite1Ips IP string \"%s\" to a "
                       "real IP address. This should be investigated immediately.",
                       szIpAddr);
            XomNtEvent(XEVENT_XKDC_FAILED_TO_PARSE_SITE1_IP,
                       "Failed to convert kdcsvc_xkdc_sgSite1Ips IP string \"%s\" to a "
                       "real IP address. This should be investigated immediately.",
                       szIpAddr);
            goto Cleanup;
        }

        pdwIps[i] = dwIpAddr;
    }

    // Set return vars
    *ppdwNewIps = pdwIps;
    *pcNewIps = dwCount;

    pdwIps = NULL;

    bRetVal = TRUE;

Cleanup:

    if (pdwIps != NULL)
    {
        delete [] pdwIps;
    }

    return bRetVal;
}

void
CXkdcProvider::ReplaceSite1LoadBalancingIps(
    IN DWORD cNewIps,
    IN DWORD *pdwNewIps,
    OUT DWORD **ppdwOldIps)
{
    *ppdwOldIps = m_pdwSite1LoadBalancingIps;

    m_pdwSite1LoadBalancingIps = pdwNewIps;
    m_cSite1LoadBalancingIps = cNewIps;
}

BOOL
CXkdcProvider::ParseHexNumberArray(
    IN  CComSafeArray<BSTR> &saValues,
    OUT DWORD *pcValues,
    OUT DWORD **ppdwValues)
{

    XOMASSERT(ppdwValues);
    XOMASSERT(pcValues);

    *ppdwValues = NULL;
    *pcValues = 0;

    BOOL    bRetVal = FALSE;
    DWORD*  pdwValues    = NULL;
    DWORD   dwCount      = saValues.GetCount();

    if (dwCount == 0)
    {
        bRetVal = TRUE;
        goto Cleanup;
    }

    pdwValues = new DWORD[dwCount];
    if (pdwValues == NULL)
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","Out of memory allocating an array of %u dword values (%u bytes). ",
                   dwCount, dwCount * sizeof(DWORD));
        XomNtEvent(XEVENT_XKDC_NO_MEMORY_PARSE_HEX_VALUES,
                   "Out of memory allocating an array of %u dword values (%u bytes). ",
                   dwCount, dwCount * sizeof(DWORD));
        goto Cleanup;
    }

    // Start the parsing
    for (DWORD i = 0; i < dwCount; i++)
    {
        BSTR bstrValue = saValues.GetAt(i);
        if (NULL == bstrValue)
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to parse hex string offset %u of %u hex string dword values due to NULL value. ",
                   i, dwCount);
            XomNtEvent(XEVENT_XKDC_FAILURE_PARSE_LEGACY_PC_TITLES,
                   "Failed to parse hex string offset %u of %u hex string dword values due to NULL value. ",
                   i, dwCount);
            goto Cleanup;
        }

        // The number may or may not have a leading "0x" on it. Take care of that.  
        // Otherwise, we know this is in hex format and is a DWORD.
        LPWSTR pEndPtr = NULL; //stop at NULL
        DWORD dwValue = wcstoul(bstrValue,&pEndPtr,16);
        if (dwValue == ULONG_MAX) // Overflow
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to parse hex string offset %u of %u hex string dword values due to errno %i. ",
                   i, dwCount, ERANGE);
            XomNtEvent(XEVENT_XKDC_FAILURE_PARSE_LEGACY_PC_TITLES,
                   "Failed to parse hex string offset %u of %u hex string dword values due to errno %i. ",
                   i, dwCount, ERANGE);
            goto Cleanup;
        }
        else if (dwValue == 0) // 0 return -> all zeros (not legal token) or a failure.
        {
            int err;
            if (!_get_errno(&err))
            {
				xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to parse hex string offset %u of %u hex string dword values; can't retrieve errno for details. ",
                       i, dwCount);
                XomNtEvent(XEVENT_XKDC_FAILURE_PARSE_LEGACY_PC_TITLES,
                       "Failed to parse hex string offset %u of %u hex string dword values; can't retrieve errno for details. ",
                       i, dwCount);
                goto Cleanup;
            }
            else
            {
			   xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to parse hex string offset %u of %u hex string dword values due to errno %i. ",
                       i, dwCount, err);
               XomNtEvent(XEVENT_XKDC_FAILURE_PARSE_LEGACY_PC_TITLES,
                       "Failed to parse hex string offset %u of %u hex string dword values due to errno %i. ",
                       i, dwCount, err);
                goto Cleanup;

            }
        }
        // Parse failed before end of string.  pEndPtr should be set according to docs, but make sure rather than crash
        else if (pEndPtr != NULL && *pEndPtr != NULL)
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to parse hex string offset %u of %u hex string dword values due to part of string is unparseable. ",
                   i, dwCount);
            XomNtEvent(XEVENT_XKDC_FAILURE_PARSE_LEGACY_PC_TITLES,
                   "Failed to parse hex string offset %u of %u hex string dword values due to part of string is unparseable. ",
                   i, dwCount);
            goto Cleanup;
        }
        else
        {
            pdwValues[i] = dwValue;
        }
    }

    // Set return vars
    *ppdwValues = pdwValues;
    *pcValues = dwCount;

    pdwValues = NULL;

    bRetVal = TRUE;

Cleanup:

    delete [] pdwValues;

    return bRetVal;
}

void
CXkdcProvider::ReplaceLegacyPcTitles(
    IN DWORD cNewTitles,
    IN DWORD *pdwNewTitles)
{
    DWORD* pdwOldTitles = m_pdwLegacyPcTitles;

    m_pdwLegacyPcTitles = pdwNewTitles;
    m_cLegacyPcTitles = cNewTitles;

    if (pdwOldTitles != NULL)
    {
        delete [] pdwOldTitles;
    }
}
BOOL CXkdcProvider::IsLegacyPcTitle(DWORD dwTitleId)
{
    if (m_pdwLegacyPcTitles != NULL)
    {
        for(DWORD i = 0; i < m_cLegacyPcTitles;i++)
        {
            if (m_pdwLegacyPcTitles[i] == dwTitleId)
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}

void
CXkdcProvider::LogLoadBalancingIps()
{
    // Log info event for audit trail

    CLargeStr strIps;
    if (m_cSite1LoadBalancingIps == 0)
    {
        // Look up presence (service id 1) for its IP address.
        CXkdcPrincipal *pPrinc = GetServicePrincipal(1, 0, 0, 0);
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(no overrides configured, using uodb..t_sites)\n");
        strIps.Format("(no overrides configured, using uodb..t_sites)\n");
        if (pPrinc)
        {
            DWORD dwIp = pPrinc->GetSiteIPAddress();
            strIps.Format("%s", inet_ntoa(*(in_addr*)&dwIp));
        }
    }
    else
    {
        DWORD dwLastIp = 0;
        DWORD dwWeight = 0;
        for (DWORD i = 0; i < m_cSite1LoadBalancingIps; i++)
        {
            DWORD dwIp = m_pdwSite1LoadBalancingIps[i];
            if (dwIp != dwLastIp && dwLastIp > 0)
            {
				xlog5("c:\\xkdc-XkdcProvider-cpp.log","%s (weight %u)\n", inet_ntoa(*(in_addr*)&dwLastIp), dwWeight);
                strIps.Format("%s (weight %u)\n", inet_ntoa(*(in_addr*)&dwLastIp), dwWeight);
                dwWeight = 0;
            }
            dwWeight++;
            dwLastIp = dwIp;
        }
        // Catch the last one
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","%s (weight %u)", inet_ntoa(*(in_addr*)&dwLastIp), dwWeight);
        strIps.Format("%s (weight %u)", inet_ntoa(*(in_addr*)&dwLastIp), dwWeight);
    }

	xlog5("c:\\xkdc-XkdcProvider-cpp.log","The XKDC is using the following IP address(es) for the site1 SGs:\n%s",
               strIps.cstr());
    XomNtEvent(XEVENT_XKDC_INFO_SITE1_IPS,
               "The XKDC is using the following IP address(es) for the site1 SGs:\n%s",
               strIps.cstr());
}

NTSTATUS
CXkdcProvider::LoadConfig()
{
    NTSTATUS status = STATUS_SUCCESS;

    m_bEnforceClientVersion = GetDWORDSetting( Setting_kdcsvc_xkdc_enforceClientVersion, 1);
    if (m_bEnforceClientVersion != FALSE)
    {
        m_bEnforceClientVersion = TRUE;
    }

    m_bCheckForDos          = GetDWORDSetting( Setting_kdcsvc_xkdc_DoS_checkForDos, 1);
    m_cDosEntries           = GetDWORDSetting( Setting_kdcsvc_xkdc_DoS_numEntries, 5000);
    m_dwCacheSize           = GetDWORDSetting( Setting_kdcsvc_xkdc_cacheTableSize, c_dwDefaultMachineCacheSize);
    m_dwHashSize            = GetDWORDSetting( Setting_kdcsvc_xkdc_hashTableSize, c_dwDefaultMachineCacheHashSize);
    m_dwEntryLifeTime       = GetDWORDSetting( Setting_kdcsvc_xkdc_cacheLifeTimeInSeconds, c_dwDefaultMachineCacheEntryLifetime);

    m_bUseUniqueSigninKey  = GetDWORDSetting( Setting_kdcsvc_xkdc_useUniqueSigninKey, TRUE);
    if (m_bUseUniqueSigninKey != FALSE) 
    {
        m_bUseUniqueSigninKey = TRUE;
    }

    m_bRemoveUserPrivilegesOnRequiresManagement = GetDWORDSetting( Setting_kdcsvc_xkdc_removeUserPrivilegesOnRequiresManagement, TRUE );
    if (m_bRemoveUserPrivilegesOnRequiresManagement != FALSE) 
    {
        m_bRemoveUserPrivilegesOnRequiresManagement = TRUE;
    }

    m_bRequestCacheEnabled  = GetDWORDSetting( Setting_kdcsvc_xkdc_RequestCache_enabled, 1);
    if (m_bRequestCacheEnabled != FALSE)
    {
        m_bRequestCacheEnabled = TRUE;
    }

    m_dwRequestCacheLifetime= GetDWORDSetting( Setting_kdcsvc_xkdc_RequestCache_lifetimeInSeconds, 10);

    m_bIgnoreDuplicateRequests = GetDWORDSetting( Setting_kdcsvc_xkdc_ignoreDuplicateRequests, 0);
    if (m_bIgnoreDuplicateRequests != FALSE)
    {
        m_bIgnoreDuplicateRequests = TRUE;
    }

    m_dwEnableUserMachineTrust = GetDWORDSetting( Setting_kdcsvc_xkdc_enableUserMachineTrust, 0);
    if (m_dwEnableUserMachineTrust >= XKDC_USER_MACHINE_TRUST_MAXIMUM ) 
    {
        m_dwEnableUserMachineTrust = XKDC_USER_MACHINE_TRUST_MAXIMUM;
    }

    m_KdcPolicy.TimeSkew.QuadPart = (LONGLONG)10000000 * GetDWORDSetting( Setting_kdcsvc_xkdc_timeSkewSeconds, 120);

    return status;
}

CXBaseProvider::VALIDATE_SETTING_RESULT
CALLBACK
CXkdcProvider::ValidateSetting(
    CComBSTR &SettingChange
    )
{
    static const CComBSTR aValidSettings[] = {
        Setting_kdcsvc_xkdc_enforceClientVersion,
        Setting_kdcsvc_xkdc_timeSkewSeconds,
        Setting_kdcsvc_xkdc_cacheLifeTimeInSeconds,
        Setting_kdcsvc_xkdc_DoS2_enabled,
        Setting_kdcsvc_xkdc_DoS2_maxRequests,
        Setting_kdcsvc_xkdc_DoS2_interval,
        Setting_kdcsvc_xkdc_DoS2_blockingTime,
        Setting_kdcsvc_xkdc_RequestCache_enabled,
        Setting_kdcsvc_xkdc_RequestCache_lifetimeInSeconds,
        Setting_kdcsvc_xkdc_ignoreDuplicateRequests,
        Setting_kdcsvc_xkdc_allowUnknownVersion,
        Setting_kdcsvc_xkdc_enableUserMachineTrust,
        Setting_kdcsvc_xkdc_removeUserPrivilegesOnRequiresManagement,
        Setting_kdcsvc_xkdc_useUniqueSigninKey,
        MultiSetting_kdcsvc_xkdc_legacyPcTitles,
        MultiSetting_kdcsvc_xkdc_sgSite1Ips,
    };

    VALIDATE_SETTING_RESULT result = SETTING_DONT_CARE;

    for(int i=0; i < ARRAYSIZE(aValidSettings); i++)
    {
        if(SettingChange == aValidSettings[i])
        {
            result = SETTING_ACCEPTED;
        }
    }

    return result;
}

void
CALLBACK
CXkdcProvider::ApplySetting(
    CComBSTR &SettingChange,
    CComBSTR &bsValueNew
    )
{
    HRESULT hr = S_OK;

	xlog5("c:\\xkdc-XkdcProvider-cpp.log", "CXkdcProvider::ApplySetting(%ws) => (%ws) called.",
        static_cast<wchar_t *> (SettingChange),
        static_cast<wchar_t *> (bsValueNew)
        );
    XomNtEvent(
        XEVENT_KDC_INFO_15,
        "CXkdcProvider::ApplySetting(%ws) => (%ws) called.",
        static_cast<wchar_t *> (SettingChange),
        static_cast<wchar_t *> (bsValueNew)
        );

    ConfigWriteLock();

    //
    // Take action based upon which setting we are asked to change
    //
    if (SettingChange == Setting_kdcsvc_xkdc_timeSkewSeconds)
    {
        //
        // Update the global variable attached to this setting
        //
        m_KdcPolicy.TimeSkew.QuadPart =
            (LONGLONG)10000000 *
            _wtoi( bsValueNew );
    }
    else if (SettingChange == Setting_kdcsvc_xkdc_cacheLifeTimeInSeconds)
    {
        //
        // Update the internal state
        //
        m_dwEntryLifeTime = _wtoi( bsValueNew );

        //
        // Apply it
        //
        if (m_pMachineCache)
        {
            m_pMachineCache->SetEntryLifeTime( m_dwEntryLifeTime );
        }
    }

    ConfigWriteUnlock();

    // The following don't require the ConfigWriteLock

    if(SettingChange == Setting_kdcsvc_xkdc_DoS2_enabled)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetEnabled(value))
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xkdc_DoS2_enabled: %u \n",
                value);
            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xkdc_DoS2_enabled: %u \n",
                value);
        }

    }
    else if(SettingChange == Setting_kdcsvc_xkdc_DoS2_maxRequests)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetMaxRequests(value))
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xkdc_DoS2_maxRequests: %u \n",
                value);

            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xkdc_DoS2_maxRequests: %u \n",
                value);
        }
    }
    else if(SettingChange == Setting_kdcsvc_xkdc_DoS2_interval)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetInterval(value))
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xkdc_DoS2_interval: %u \n",
                value);

            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xkdc_DoS2_interval: %u \n",
                value);
        }
    }
    else if(SettingChange == Setting_kdcsvc_xkdc_DoS2_blockingTime)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetBlockingTime(value))
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xkdc_DoS2_blockingTime: %u \n",
                value);

            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xkdc_DoS2_blockingTime: %u \n",
                value);
        }
    }
    else if(SettingChange == Setting_kdcsvc_xkdc_enforceClientVersion)
    {
        m_bEnforceClientVersion = wcstoul(bsValueNew, NULL, 0);
        if (m_bEnforceClientVersion != FALSE)
        {
            m_bEnforceClientVersion = TRUE;
        }
    }
    else if (SettingChange == Setting_kdcsvc_xkdc_RequestCache_enabled)
    {
        m_bRequestCacheEnabled  = wcstoul(bsValueNew, NULL, 0);
        if (m_bRequestCacheEnabled != FALSE)
        {
            m_bRequestCacheEnabled = TRUE;
        }
    }
    else if (SettingChange == Setting_kdcsvc_xkdc_RequestCache_lifetimeInSeconds)
    {
        m_dwRequestCacheLifetime  = wcstoul(bsValueNew, NULL, 0);
    }
    else if (SettingChange == Setting_kdcsvc_xkdc_ignoreDuplicateRequests)
    {
        m_bIgnoreDuplicateRequests = wcstoul(bsValueNew, NULL, 0);
        if (m_bIgnoreDuplicateRequests != FALSE)
        {
            m_bIgnoreDuplicateRequests = TRUE;
        }
    }
    else if (SettingChange == Setting_kdcsvc_xkdc_enableUserMachineTrust) 
    {
        m_dwEnableUserMachineTrust = wcstoul(bsValueNew, NULL, 0);
        if (m_dwEnableUserMachineTrust >= XKDC_USER_MACHINE_TRUST_MAXIMUM ) 
        {
            m_dwEnableUserMachineTrust = XKDC_USER_MACHINE_TRUST_MAXIMUM;
        }
    }
    else if (SettingChange == Setting_kdcsvc_xkdc_useUniqueSigninKey) 
    {
        m_bUseUniqueSigninKey = wcstoul(bsValueNew, NULL, 0);
        if (m_bUseUniqueSigninKey != FALSE) 
        {
            m_bUseUniqueSigninKey = TRUE;
        }
    }
    else if (SettingChange == Setting_kdcsvc_xkdc_removeUserPrivilegesOnRequiresManagement) 
    {
        m_bRemoveUserPrivilegesOnRequiresManagement = wcstoul(bsValueNew, NULL, 0);
        if (m_bRemoveUserPrivilegesOnRequiresManagement != FALSE) 
        {
            m_bRemoveUserPrivilegesOnRequiresManagement = TRUE;
        }
    }

    //
    // Done
    //
    return;
}

void
CALLBACK
CXkdcProvider::ApplyMultiSetting(
    CComBSTR &SettingChange,
    CComSafeArray<BSTR> &saValues
    )
{
	xlog5("c:\\xkdc-XkdcProvider-cpp.log","CXkdcProvider::ApplyMultiSetting(%ws) called.",
        static_cast<wchar_t *> (SettingChange)
        );

    XomNtEvent(
        XEVENT_KDC_INFO_15,
        "CXkdcProvider::ApplyMultiSetting(%ws) called.",
        static_cast<wchar_t *> (SettingChange)
        );


    // Note: remember to take the config write lock if needed

    //
    // Take action based upon which setting we are asked to change
    //
    if (SettingChange == MultiSetting_kdcsvc_xkdc_sgSite1Ips)
    {
        // Note: if all rows are removed, then we *will* get this callback and saValues
        // will have a count of 0.
        DWORD *pdwOldIps = NULL;
        DWORD *pdwNewIps = NULL;
        DWORD cNewIps = 0;
        BOOL fOk = ParseSite1LoadBalancingIps(saValues, &cNewIps, &pdwNewIps);
        if (fOk)
        {
            ConfigWriteLock();
            ReplaceSite1LoadBalancingIps(cNewIps, pdwNewIps, &pdwOldIps);
            ConfigWriteUnlock();
        }

        LogLoadBalancingIps();

        // Clear out old memory
        if (pdwOldIps != NULL)
        {
            delete [] pdwOldIps;
            pdwOldIps = NULL;
        }
    }
    else if (SettingChange == MultiSetting_kdcsvc_xkdc_legacyPcTitles)
    {
        // Note: if all rows are removed, then we *will* get this callback and saValues
        // will have a count of 0.
        DWORD *pdwNewTitles = NULL;
        DWORD cNewTitles = 0;
        BOOL fOk = ParseHexNumberArray(saValues, &cNewTitles, &pdwNewTitles);
        if (fOk)
        {
            ConfigWriteLock();
            ReplaceLegacyPcTitles(cNewTitles, pdwNewTitles);
            ConfigWriteUnlock();
                
        }

    }

    // done
}

NTSTATUS
CXkdcProvider::InitializeExtensionHandlers()
{
    NTSTATUS status = STATUS_SUCCESS;

    // Register factory class for Xbox 1 preauth handler
    CPAXboxRequestHandlerFactory *pPAXbox = new CPAXboxRequestHandlerFactory(this);
    if ( NULL == pPAXbox )
    {
        status = STATUS_SERVER_DISABLED;
        goto Cleanup;
    }

    // save a reference so it can be deleted on unload
    gPAXboxFactory = pPAXbox;

    IPAHandlerFactory *pIPAFac = static_cast<IPAHandlerFactory*>(pPAXbox);
    pPAXbox = NULL;
    KdcRegisterPAHandlerFactory(pIPAFac);

    // Register factory class for Xenon preauth handler 2
    CPAXenonRequest2HandlerFactory *pPAXenon2 = new CPAXenonRequest2HandlerFactory(this);
    if ( NULL == pPAXenon2 )
    {
        status = STATUS_SERVER_DISABLED;
        goto Cleanup;
    }

    // save a reference so it can be deleted on unload
    gPAXenonFactory2 = pPAXenon2;

    pIPAFac = static_cast<IPAHandlerFactory*>(pPAXenon2);
    pPAXenon2 = NULL;
    KdcRegisterPAHandlerFactory(pIPAFac);

    // Register factory class for Xenon preauth handler 2
    CPAXenonRequest3HandlerFactory *pPAXenon3 = new CPAXenonRequest3HandlerFactory(this);
    if ( NULL == pPAXenon3 )
    {
        status = STATUS_SERVER_DISABLED;
        goto Cleanup;
    }

    // save a reference so it can be deleted on unload
    gPAXenonFactory3 = pPAXenon3;

    pIPAFac = static_cast<IPAHandlerFactory*>(pPAXenon3);
    pPAXenon3 = NULL;
    KdcRegisterPAHandlerFactory(pIPAFac);

    // Register factory class for authdata handler
    CXboxADHandlerFactory *pAD = new CXboxADHandlerFactory(this);
    if ( NULL == pAD )
    {
        status = STATUS_SERVER_DISABLED;
        goto Cleanup;
    }

    // save a reference so it can be deleted on unload
    g_pADFactory = pAD;

    IADHandlerFactory *pIADFac = static_cast<IADHandlerFactory*>(pAD);
    pAD = NULL;
    KdcRegisterADHandlerFactory(pIADFac);

Cleanup:
    return status;
}

// Implement health checks
HRESULT CXkdcProvider::HealthCheck(IN DWORD dwRequestId,IN CXomControlResponseInterface *pResponseInterface)
{
    BOOL     bFailed = FALSE;
    CHAR     szResponse[MAX_MGMT_RESPONSE_SIZE];
    CComBSTR bstrSetting;
    CComBSTR bstrEnum[] = {
        Setting_kdcsvc_xkdc_allowUnknownVersion,
        Setting_kdcsvc_xkdc_DoS_checkForDos,
        Setting_kdcsvc_xkdc_DoS_numEntries,
        Setting_kdcsvc_xkdc_cacheTableSize,
        Setting_kdcsvc_xkdc_hashTableSize,
        Setting_kdcsvc_xkdc_cacheLifeTimeInSeconds,
        Setting_kdcsvc_xkdc_timeSkewSeconds
        };
    HRESULT  hr = S_OK;
    int      dwOffset = 0;
    int      i;

    for (i = 0; i < ARRAYSIZE(bstrEnum); i++)
    {
        hr = m_pConfig->GetSetting( bstrEnum[i], &bstrSetting );
        if (FAILED(hr))
        {
            bFailed = TRUE;

            dwOffset += _snprintf(
                szResponse + dwOffset,
                sizeof(szResponse) - dwOffset,
                "XKDC: GetSetting( %ws ) = 0x%08lx",
                static_cast<wchar_t *>(bstrEnum[i]),
                hr
                );
        }
    }

    if (!bFailed)
    {
        dwOffset += _snprintf(
            szResponse + dwOffset,
            sizeof(szResponse) - dwOffset,
            "XKDC: All Settings Read.\r\n"
            );
    }

    // display the response
    pResponseInterface->WriteResponse(
        dwRequestId,
        (BYTE*) szResponse,
        (DWORD) -1
        );
    return S_OK;
}

KERBERR
CXkdcProvider::CheckForDos(
    IN  IKerbRequest    *piReq,
    IN OUT XKDC_LOGGINGDATA *pLogData)
{
    const KERB_AUTHENTICATOR *pAuthenticator = NULL;
    LARGE_INTEGER liPuid = {0,0};
    LARGE_INTEGER liAuthTime = {0,0};
    IADPacSection *piPacSect = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;

    if ( !m_bCheckForDos )
    {
        goto Cleanup;
    }

    XOMASSERT( piReq );
    XOMASSERT( piReq->GetAuthenticator() );

    if ( NULL == piReq )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CheckForDos: invalid parameter.", __FILE__, __LINE__);
        XomTrace(Xkdc, L_ERROR, "(%s:%d) CheckForDos: invalid parameter.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        goto Cleanup;
    }

    pAuthenticator = piReq->GetAuthenticator();
    if ( NULL == pAuthenticator )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CheckForDos: missing authenticator from client %s.",
                __FILE__,
                __LINE__,
                inet_ntoa(*pInAddr));

        XomNtEvent(XEVENT_KDC_HACK_27,
                "(%s:%d) CheckForDos: missing authenticator from client %s.",
                __FILE__,
                __LINE__,
                inet_ntoa(*pInAddr));

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CheckForDos: missing authenticator from client %s.",
                __FILE__,
                __LINE__,
                inet_ntoa(*pInAddr));

        XomTrace(Xkdc, L_ERROR,
                "(%s:%d) CheckForDos: missing authenticator from client %s.",
                __FILE__,
                __LINE__,
                inet_ntoa(*pInAddr));

        KerbErr = SilentKerbErr(KDC_ERR_POLICY);
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_INVALID_REQUEST;
        goto Cleanup;
    }

    KerbConvertGeneralizedTimeToLargeInt(
        (PTimeStamp)&liAuthTime,
        &pAuthenticator->client_time,
        pAuthenticator->client_usec);

    // no milliseconds present in authenticator
    //XOMASSERT( 0 == pAuthenticator->client_time.millisecond );

    //
    // Now get the PAC and retrieve the Xbox machine account puid from
    // PAC_CLIENT_IDENTITY section.
    //

    // find the PAC_CLIENT_IDENTITY section of the PAC in the incoming TGT
    status = piReq->GetADHandler(IID_IADPacSection, (PVOID*)&piPacSect);
    if ( !NT_SUCCESS(status) || NULL == piPacSect )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CheckForDos: failed to acquire valid IADPacSection interface.",
            __FILE__,
            __LINE__);
        XomNtEvent(XEVENT_KDC_CODE_259,
            "(%s:%d) CheckForDos: failed to acquire valid IADPacSection interface.",
            __FILE__,
            __LINE__);

		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "(%s:%d) CheckForDos: failed to acquire valid IADPacSection interface.",
            __FILE__,
            __LINE__);

        XomTrace(Xkdc, L_HIGH,
            "(%s:%d) CheckForDos: failed to acquire valid IADPacSection interface.",
            __FILE__,
            __LINE__);

        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        goto Cleanup;
    }

    status = PacGetMachinePuid( piPacSect, (ULONGLONG *) &(liPuid.QuadPart) );
    if ( !NT_SUCCESS(status))
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "(%s:%d) CheckForDos: missing PAC_CLIENT_IDENTITY section from client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr));

        XomNtEvent(XEVENT_KDC_HACK_28,
            "(%s:%d) CheckForDos: missing PAC_CLIENT_IDENTITY section from client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr));

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CheckForDos: missing PAC_CLIENT_IDENTITY section from client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr));

        XomTrace(Xkdc, L_ERROR,
            "(%s:%d) CheckForDos: missing PAC_CLIENT_IDENTITY section from client %s.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr));

		xlog5("c:\\xkdc-XkdcProvider-cpp.log", "(%s:%d) CheckForDos: missing PAC_CLIENT_IDENTITY section from client %s.", __FILE__, __LINE__, inet_ntoa(*pInAddr));
        XomTrace(Xkdc, L_HIGH, "(%s:%d) CheckForDos: missing PAC_CLIENT_IDENTITY section from client %s.", __FILE__, __LINE__, inet_ntoa(*pInAddr));

        KerbErr = SilentKerbErr(KDC_ERR_SVC_UNAVAILABLE);
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_INVALID_REQUEST;
        goto Cleanup;
    }

    // We went thru the effort of obtain the machine PUID from the PAC. Lets
    // remember in the log data just in case we abort processing of this request
    // before we get to PolicyCheckMachine()
    pLogData->m_qwMachinePUID = liPuid.QuadPart;
   
    if ( XkdcTgsDosCheckAuthenticator( liPuid, liAuthTime ) )
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

        //g_Counters.IncrementValue32(XKDCPERF_SERVER_DOS_REPLAYS, 1);
        //g_Counters.IncrementValue32(XKDCPERF_SERVER_DOS_REPLAYS_RATE, 1);

        // we have a reqstat bit to key off of in the app logs, and we have tracing. no
        // event spam!

//         XomNtEvent(XEVENT_KDC_HACK_29,
//             "(%s:%d) CheckForDos: replay detected.  Client: %s, puid: 0x%016I64X,
//             timestamp: 0x%016I64X.",
//             __FILE__,
//             __LINE__,
//             inet_ntoa(*pInAddr),
//             liPuid,
//             liAuthTime);

		xlog5("c:\\xkdc-XkdcProvider-cpp.log","(%s:%d) CheckForDos: replay detected.  Client: %s, puid: 0x%016I64X, timestamp: 0x%016I64X.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr),
            liPuid,
            liAuthTime);

        XomTrace(Xkdc, L_ERROR,
            "(%s:%d) CheckForDos: replay detected.  Client: %s, puid: 0x%016I64X, timestamp: 0x%016I64X.",
            __FILE__,
            __LINE__,
            inet_ntoa(*pInAddr),
            liPuid,
            liAuthTime);

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_DOS_ATTACK;

        return SilentKerbErr(KRB_AP_ERR_REPEAT);
    }

    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_PASSED_DOS;

Cleanup:
    return KerbErr;
}

//------------------------------------------------------------------
// Verify that all required pre-auth types, and only them, were specified in the request.
// This is our pre-auth whitelist. It depends on the type of request, which we will
// attempt to determine based on which preauths are included.
//------------------------------------------------------------------
KERBERR
CXkdcProvider::VerifyPreAuthWhitelist(
    IN  IKerbRequest        *piReq,
    IN OUT XKDC_LOGGINGDATA *pLogData)
{
    KERBERR             KerbErr      = KDC_ERR_NONE;
    in_addr*            pInAddr      = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

    static const UINT32 AllowedXenonPreAuth[] = {
        KRB5_PADATA_TGS_REQ,                    // kerberos TGS
        KRB5_PADATA_XENON_SERVICE_REQUEST2,     // xenon and PC request
    };

    static const UINT32 AllowedXenon2PreAuth[] = {
        KRB5_PADATA_TGS_REQ,                    // kerberos TGS
        KRB5_PADATA_XENON_SERVICE_REQUEST3,     // xenon and PC request
    };

    static const UINT32 OptionalPreAuth[] = {
        KRB5_PADATA_PAC_REQUEST_EX,         // to enable compound identity 
        KRB5_PADATA_XBOX_CLIENT_VERSION,    // client version
    };

    // Must be Xenon/PC
    if (GetPaData(piReq, KRB5_PADATA_XENON_SERVICE_REQUEST3))
    {
        if(!VerifyPaList(piReq,
                         AllowedXenon2PreAuth, ARRAY_SIZE(AllowedXenon2PreAuth),
                         OptionalPreAuth, ARRAY_SIZE(OptionalPreAuth) ) )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once.\n"
                "Client type: Xbox360/PC (found XENON_SERVICE_REQUEST3)\n"
                "Client IP: "DBGINAFMT"\n",
                DBGINAPRM(pInAddr));


            XomNtEvent(
                XEVENT_XKDC_HACK_INVALID_PRE_AUTH_TYPE,
                "Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once.\n"
                "Client type: Xbox360/PC (found XENON_SERVICE_REQUEST3)\n"
                "Client IP: "DBGINAFMT"\n",
                DBGINAPRM(pInAddr));
            KerbErr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
            goto Cleanup;
        }
    }
    else if (GetPaData(piReq, KRB5_PADATA_XENON_SERVICE_REQUEST2))
    {
        if(!VerifyPaList(piReq,
                         AllowedXenonPreAuth, ARRAY_SIZE(AllowedXenonPreAuth),
                         OptionalPreAuth, ARRAY_SIZE(OptionalPreAuth) ) )
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once.\n"
                "Client type: Xbox360/PC (found XENON_SERVICE_REQUEST2)\n"
                "Client IP: "DBGINAFMT"\n",
                DBGINAPRM(pInAddr));

            XomNtEvent(
                XEVENT_XKDC_HACK_INVALID_PRE_AUTH_TYPE,
                "Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once.\n"
                "Client type: Xbox360/PC (found XENON_SERVICE_REQUEST2)\n"
                "Client IP: "DBGINAFMT"\n",
                DBGINAPRM(pInAddr));
            KerbErr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
            goto Cleanup;
        }
    }
    else
    {
        // Ignore all Xbox1 at this point. Not even worth eventing
        KerbErr = SilentKerbErr(KDC_ERR_POLICY);
        goto Cleanup;
    }

    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_VERIFIED_PRE_AUTH_LIST;

Cleanup:
    return KerbErr;

}

//------------------------------------------------------------------
//  GetSigningKey: Gets the signing key calculated from the SHA1HMAC
//      of the given data and the KDC signing key.
//------------------------------------------------------------------
NTSTATUS CXkdcProvider::GetSigningKey( IN DWORD dwTitleID,
                                      IN DWORD dwTitleVersion,
                                      IN ULONGLONG qwXboxID,
                                      IN DWORD cSigningKey,
                                      OUT BYTE* abSigningKey )
{
    NTSTATUS status = STATUS_SUCCESS;
    BYTE hmacResult[A_SHA_DIGEST_LEN];

    XOMASSERT( abSigningKey != NULL );

    // ensure the buffer is big enough.
    if ( cSigningKey < XONLINE_KEY_LENGTH )
    {
        status = STATUS_INVALID_BUFFER_SIZE;
        goto Cleanup;
    }

    if (m_bUseUniqueSigninKey != FALSE) 
    {
        // Try full random
        if (!XOCryptGenRandom( (BYTE *) hmacResult, A_SHA_DIGEST_LEN ) ) 
        {
            UINT64 qwNow;
            UINT64 qwTitleInfo;

            // Fall back to semi-random
            GetSystemTimeAsFileTime( (FILETIME *) &qwNow );
            qwTitleInfo   = dwTitleID;
            qwTitleInfo <<= 32;
            qwTitleInfo  |= dwTitleVersion;
               
            XcHMAC3(
                m_signingKey.binKey,
                sizeof( m_signingKey.binKey ),
                (BYTE*)&(qwNow),
                sizeof(UINT64),
                (BYTE*)&(qwTitleInfo),
                sizeof(UINT64),
                (BYTE*)&(qwXboxID),
                sizeof(ULONGLONG),
                (BYTE*)hmacResult
                );
        }
    }
    else
    {
        XcHMAC3(
            m_signingKey.binKey,
            sizeof( m_signingKey.binKey ),
            (BYTE*)&(dwTitleID),
            sizeof(DWORD),
            (BYTE*)&(dwTitleVersion),
            sizeof(DWORD),
            (BYTE*)&(qwXboxID),
            sizeof(ULONGLONG),
            (BYTE*)hmacResult
            );
    }

    // copy only XONLINE_KEY_LENGTH into the buffer.
    memcpy( abSigningKey, hmacResult, XONLINE_KEY_LENGTH );

Cleanup:
    return status;
}

//------------------------------------------------------------------
// GetKdcPolicy:  Override the base provider information so we
//    always use this specific providers policy data.
//------------------------------------------------------------------
const KDC_POLICY_VALUES* __stdcall CXkdcProvider::GetKdcPolicy()
{
    return &m_KdcPolicy;
}


//------------------------------------------------------------------
// IsPrincipalSite1: is given XkdcPrincipal "site1" or not?
//------------------------------------------------------------------
BOOL CXkdcProvider::IsPrincipalSite1(CXkdcPrincipal *pPrinc)
{
    return pPrinc ? GetKdcCore()->pfnKerbEqualKdcNames(pPrinc->GetCanonicalName(), m_pkinSite1Name) : FALSE;
}

//------------------------------------------------------------------
//  GetServiceIdsIntoString: retrieve service ids from a given
//      string.
//------------------------------------------------------------------
void GetServiceIdsIntoString( DWORD dwReqServiceList[], DWORD dwNumOfServices, char *szString , DWORD dwStringSize )
{
    XOMASSERT(szString != NULL);

    // Attach string object to input parameter
    CStr str(szString, dwStringSize);

    // go through the list adding these services to the string.

    const char* pSeparator = ""; // First entry doesn't need a separator prefix

    for(UINT32 i = 0; i < dwNumOfServices; i++ )
    {
        DWORD service = dwReqServiceList[i];

        if(service < 256)
        {
            // single byte service - use decimal format
            str.Format("%s%u", pSeparator, service);
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","%s%u", pSeparator, service);
        }
        else
        {
            // DWORD service - use hexadecimal format
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","%s0x%x", pSeparator, service);
            str.Format("%s0x%x", pSeparator, service);
        }

        // Subsequent entries will be comma-separated
        pSeparator = ",";
    }
}


//------------------------------------------------------------------
//  ReadKeysFromResultSet:  loads all service principal keys
//      into a credential.
//------------------------------------------------------------------
static HRESULT FillKeysFromXkdcPrincipals(
    IN unsigned int const idx,
    IN DWORD const dwItem,
    IN XKDC_PRINCIPAL const * const psPrinc,
    IN OUT XkdcCredential * const pCred,
    IN DWORD const cCred,
    IN DWORD * const pdwKeyVersion,
    IN DWORD * const pdwKeyLen,
    IN XkdcServicePrincipal const * const pServicePrincipals,
    IN unsigned int const cPrincipals,
    OUT DWORD * const pdwTicketLifetimeSecs )
{
    HRESULT hr = S_OK;
    XOCryptoMasterKeyEncryptedStruct EncryptedKey = {0};
    DWORD dwMasterKeyVersion = 0;
    SAFEARRAY* psaResKey = NULL;

    XkdcServicePrincipal const * const pCur = &pServicePrincipals[idx + dwItem];

    // -------------------------------------------------------------------
    // lifetime in seconds
    *pdwTicketLifetimeSecs = pCur->TicketLifetimeSeconds;

    // -------------------------------------------------------------------
    // master key version
    dwMasterKeyVersion = pCur->MasterKeyVersion;

    // -------------------------------------------------------------------
    // the key version
    *pdwKeyVersion = pCur->KeyVersion;

    // -------------------------------------------------------------------
    // the key length
    EncryptedKey.dwKeyLen = *pdwKeyLen = pCur->KeyLen;

    // -------------------------------------------------------------------
    // get the key
    memcpy( EncryptedKey.abKey,
            pCur->Key->pvData,
            __min( pCur->Key->rgsabound[0].cElements, sizeof(EncryptedKey.abKey) ));


    pCred->Key[dwItem].dwKeyVersion = *pdwKeyVersion;
    pCred->Key[dwItem].Key.keytype = KERB_ETYPE_RC4_HMAC_NT;
    pCred->Key[dwItem].Key.keyvalue.length = XKDC_KEYSIZE;
    pCred->Key[dwItem].Key.keyvalue.value = ((BYTE*) pCred) + cCred - (dwItem+1)*XKDC_KEYSIZE;

    // decrypt with proper version of master key

    hr = DecryptWithMasterKey(dwMasterKeyVersion, &EncryptedKey);
    if ( FAILED(hr) )
    {
		xlog5("c:\\xkdc-XkdcProvider-cpp.log","FillKeysFromXkdcPrincipals: DecryptWithMasterKey failed with master key version %d, key ver %d, key len %d, key %S/%S, hr = 0x%08X.",
                    dwMasterKeyVersion,
                    *pdwKeyVersion,
                    *pdwKeyLen,
                    psPrinc->wszServiceName,
                    psPrinc->wszDomainName,
                    hr);

        XomNtEvent(XEVENT_XKDC_DECRYPTION_FAILED,
                    "FillKeysFromXkdcPrincipals: DecryptWithMasterKey failed with master key version %d, key ver %d, key len %d, key %S/%S, hr = 0x%08X.",
                    dwMasterKeyVersion,
                    *pdwKeyVersion,
                    *pdwKeyLen,
                    psPrinc->wszServiceName,
                    psPrinc->wszDomainName,
                    hr);
        goto Cleanup;
    }

    // copy raw key to cred structure
    memcpy((pCred->Key[dwItem].Key.keyvalue.value), EncryptedKey.abKey, XKDC_KEYSIZE);
    ZeroMemory(&EncryptedKey, sizeof(EncryptedKey));

    // read the next result.
    if (idx + dwItem + 1 > cPrincipals)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Yet another copy of our SHA1-HMAC implementation.  This time it does 3
//  sources of data.
//
void
XcHMAC3(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    IN PBYTE pbData3,
    IN ULONG cbData3,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    ZeroMemory(Kipad, HMAC_K_PADSIZE);
    memcpy(Kipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(Kopad, HMAC_K_PADSIZE);
    memcpy(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
        ((DWORD*)Kopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
        A_SHAUpdate(&shaHash, pbData, cbData);
    if (cbData2 != 0)
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    if (cbData3 != 0)
        A_SHAUpdate(&shaHash, pbData3, cbData3);

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    memcpy(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

// -------------------------------------------------------------------------------------
// CStrPolicyData::FormatServices
// Format service list as a comma-separated string
// Returns:
//  Pointer to formatted string
// -------------------------------------------------------------------------------------
LPCSTR CStrPolicyData::FormatServices(BOOL fIncludePrivileges)
{
    TStr::Reset();

    // Format single byte services and privileges. They are encoded in a DWORD array
    // where each bit in the array represents one service/privilege.

    const int     bitsPerDword  = sizeof(DWORD) * 8;
    const DWORD*  pPrivDwords   = _pPolicyData->dwXenonPrivileges;
    const char*   delimiter     = "";

    // Base Services
    // BUGBUG This prints out the CAuthData3 version of the services
    // and privileges but we have a much better representation in CAuthData4.
    // However do it this way until we can figure out a better method.
    for (int dwordIndex = 0;
        dwordIndex < ARRAY_SIZE(_pPolicyData->dwXenonPrivileges);
        dwordIndex++)
    {
        if (!fIncludePrivileges && (dwordIndex * bitsPerDword) >= 128)
        {
            continue;
        }
        for (int bitIndex = 0; bitIndex < bitsPerDword; bitIndex++)
        {
            DWORD mask = 1L << bitIndex;

            if (pPrivDwords[dwordIndex] & mask)
            {
                DWORD val = (dwordIndex * bitsPerDword) + bitIndex;
                TStr::Format("%s%u", delimiter, val);
				xlog5("c:\\xkdc-XkdcProvider-cpp.log","%s%u", delimiter, val);
                delimiter = ",";
            }
        }
    }

    // format DWORD services

    for(int i = 0; i < ARRAY_SIZE(_pPolicyData->dwXenonServiceID); i++)
    {
        if(_pPolicyData->dwXenonServiceID[i])
        {
			xlog5("c:\\xkdc-XkdcProvider-cpp.log","%s0x%x", delimiter, _pPolicyData->dwXenonServiceID[i]);
            TStr::Format("%s0x%x", delimiter, _pPolicyData->dwXenonServiceID[i]);
            delimiter = ",";
        }
    }

    return TStr::cstr();
}

// -------------------------------------------------------------------------------------
// ConvertConsoleToPlatformType
// Convert console type, a value from uodb..t_console_types into platform type, a value
// from the XPLT_* constants declared in xonline.x.
//   - dwConsoleType: console type constant
// Returns:
//   XPLT_* constant that corresponds to the console type. If it can't map the console
//   type to a XPLT_* (like the "Marketplace" type), this function will return 0xFFFFFFFF
//   as an indication that no platform should be able to logon using this title.
// -------------------------------------------------------------------------------------
DWORD ConvertConsoleToPlatformType(DWORD dwConsoleType)
{
    switch(dwConsoleType)
    {
    case 0: return XPLT_XBOX1;
    case 2: return XPLT_XBOX360;
    case 4: return XPLT_PC;
    default: return 0xFFFFFFFF;
    }
}

// -------------------------------------------------------------------------------------
// CXMACSProvider::Audit
// -------------------------------------------------------------------------------------
NTSTATUS CXkdcProvider::Audit(
    IN KDC_AUDIT_EVENT      AuditId,
    IN PIKerbRequest        pIKerbRequest,
    IN PSOCKADDR            ClientAddress,
    IN PKERBERR             pExtError,
    IN PULONG               pKdcOptions,
    IN PKERB_CRYPT_LIST     EncryptionType,
    IN PULONG               pulPreauthType
    )
{
#define CHECK_NTSTATUS(x) \
    if (!NT_SUCCESS(status = (x))) { \
        XomTrace(KdcBase, L_ERROR, "XKDC Audit: %s failed at %s:%u. NtStatus=0x%08X, Operation:\n%s", __FUNCTION__, __FILE__, __LINE__, status, #x ); \
        goto ErrorFallback; \
    }

    IPAXboxRequest*          pPAXboxRequest = NULL;
    IPAXboxLogData*          pPAXboxLog = NULL;
    XKDC_POLICY_DATA*        pPolicyData = NULL;
    XKDC_PA_SERVICE_ADDRESS* pServiceAddress = NULL;
    XKDC_PA_SERVICE_REQUEST* pServiceRequest = NULL;
    XKDC_LOGGINGDATA*        pLogData = NULL;

    NTSTATUS                 status = STATUS_SUCCESS;
    BOOL                     ok = FALSE;
    KERBERR                  kerberr = pExtError ? *pExtError : KDC_ERR_NONE;
    DWORD                    dwPlatformType = XPLT_XBOX360;

    // Let base class process audit event first

    CHECK_NTSTATUS(CBaseAudit::Audit(
        AuditId,
        pIKerbRequest,
        ClientAddress,
        pExtError,
        pKdcOptions,
        EncryptionType,
        pulPreauthType));

    // Grab pointers to some objects. These may fail - for instance, if the request fails
    // to even make it to the xkdc provider code, then we can't get a pointer to the
    // IPAXboxRequest interface. This will happen if the ticket fails a check, among
    // others.

    CHECK_NTSTATUS(pIKerbRequest->GetPAHandler(IID_IPAXboxRequest, (PVOID*)&pPAXboxRequest));
    CHECK_NTSTATUS(pIKerbRequest->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&pPAXboxLog));
    XOMASSERT(pPAXboxRequest);
    XOMASSERT(pPAXboxLog);

    CHECK_NTSTATUS(pPAXboxRequest->GetPolicyData(&pPolicyData));
    CHECK_NTSTATUS(pPAXboxRequest->GetServiceAddress(&pServiceAddress));
    CHECK_NTSTATUS(pPAXboxRequest->GetServiceRequest(&pServiceRequest));
    CHECK_NTSTATUS(pPAXboxLog->GetLogData(&pLogData));
    XOMASSERT(pPolicyData);
    XOMASSERT(pServiceAddress);
    XOMASSERT(pServiceRequest);
    XOMASSERT(pLogData);

#undef CHECK_NTSTATUS

    // Determine if the request succeeded or failed

    if(AuditId == TgsSuccess ||
       AuditId == TgsTicketRequest)
    {
        if(pServiceAddress->hr == S_OK)
        {
            ok = TRUE;
        }
    }

    // Some of failures we have can occur before PolicyCheckMachine() is called.
    // If that is the case, then pPolicyData->dwPlatformType won't be set to
    // the correct type. The solution/workaround is to actually calculate
    // the platform type the same way that PolicyCheckMachine() would
    if (IS_XENON_MACHINE_PUID( pLogData->m_qwMachinePUID) ) 
    {
        dwPlatformType = XPLT_XBOX360;
    }
    else if (IS_PC_MACHINE_PUID( pLogData->m_qwMachinePUID) ) 
    {
        dwPlatformType = XPLT_PC;
    }
    else
    {
        dwPlatformType = XPLT_XBOX1;
    }

    // Process global request performance counters

    // Increment counter based on platform

    switch(dwPlatformType)
    {
    case XPLT_XBOX1:
        if(ok)
        {
           // g_Counters.IncrementValue32(XKDCPERF_SERVER_XBOX_REQUESTS_RATE, 1);
        }
        else
        {
           // g_Counters.IncrementValue32(XKDCPERF_SERVER_XBOX_FAILURES_RATE, 1);
        }
        break;

    case XPLT_XBOX360:
        if(ok)
        {
            //g_Counters.IncrementValue32(XKDCPERF_SERVER_XBOX360_REQUESTS_RATE, 1);
        }
        else
        {
            //g_Counters.IncrementValue32(XKDCPERF_SERVER_XBOX360_FAILURES_RATE, 1);
        }
        break;

    case XPLT_PC:
        if(ok)
        {
           // g_Counters.IncrementValue32(XKDCPERF_SERVER_PC_REQUESTS_RATE, 1);
        }
        else
        {
          //  g_Counters.IncrementValue32(XKDCPERF_SERVER_PC_FAILURES_RATE, 1);
        }
        break;
    }

    // Log request line. This is the only place we log the REQ| line. The format of this
    // has changed from the previous REQ logline.

	xlog5("c:\\xkdc-XkdcProvider-cpp.log","REQ2|%d|"DBGINAFMT"|%d.%d.%d.%d|%X|%X|%X|%X|%016I64X|%I64X|%X|%X|%X|%.2f|%I64X|%X|%X|%X|%.2f|%I64X|%X|%X|%X|%.2f|%I64X|%X|%X|%X|%.2f|%s|%s|%s|%s|%d|%I64X|%X|%X|%d",
           ok,  // new
           DBGINAPRM((in_addr*)&pLogData->m_dwIP),
           (DWORD)pLogData->m_clientVersion.wMajorVersion,
           (DWORD)pLogData->m_clientVersion.wMinorVersion,
           (DWORD)pLogData->m_clientVersion.wBuildNumber,
           (DWORD)pLogData->m_clientVersion.wQFENumber,
           pLogData->m_dwFlashVersion,  // new
           pLogData->m_dwTitleId,
           pLogData->m_dwTitleVersion,
           pLogData->m_dwTitleRegion,
           pLogData->m_qwMachinePUID,
           pLogData->m_qwUserPUID[0],
           pLogData->m_dwUserFlags[0],  // new
           pLogData->m_dwUserStatus[0],
           pPolicyData->hrUser[0],
           pLogData->m_afltUserTrustFactor[0],
           pLogData->m_qwUserPUID[1],
           pLogData->m_dwUserFlags[1],  // new
           pLogData->m_dwUserStatus[1],
           pPolicyData->hrUser[1],
           pLogData->m_afltUserTrustFactor[1],
           pLogData->m_qwUserPUID[2],
           pLogData->m_dwUserFlags[2],  // new
           pLogData->m_dwUserStatus[2],
           pPolicyData->hrUser[2],
           pLogData->m_afltUserTrustFactor[2],
           pLogData->m_qwUserPUID[3],
           pLogData->m_dwUserFlags[3],  // new
           pLogData->m_dwUserStatus[3],
           pPolicyData->hrUser[3],
           pLogData->m_afltUserTrustFactor[3],
           pLogData->m_szServicesRequested,
           pLogData->m_szSiteGranted,
           pLogData->m_szServicesAttain,
           pServiceAddress ? inet_ntoa(pServiceAddress->siteIPAddress) : "",
           pLogData->m_dwTicketLifeTime,
           pLogData->m_qwReqStatus,
           kerberr,
           pServiceAddress ? pServiceAddress->hr : E_UNEXPECTED,
           pIKerbRequest->GetElapsedTimeInMs()
          );

    XomLogFT(log,
           pServiceAddress->flowToken,
           "REQ2|%d|"DBGINAFMT"|%d.%d.%d.%d|%X|%X|%X|%X|%016I64X|%I64X|%X|%X|%X|%.2f|%I64X|%X|%X|%X|%.2f|%I64X|%X|%X|%X|%.2f|%I64X|%X|%X|%X|%.2f|%s|%s|%s|%s|%d|%I64X|%X|%X|%d",
           ok,  // new
           DBGINAPRM((in_addr*)&pLogData->m_dwIP),
           (DWORD)pLogData->m_clientVersion.wMajorVersion,
           (DWORD)pLogData->m_clientVersion.wMinorVersion,
           (DWORD)pLogData->m_clientVersion.wBuildNumber,
           (DWORD)pLogData->m_clientVersion.wQFENumber,
           pLogData->m_dwFlashVersion,  // new
           pLogData->m_dwTitleId,
           pLogData->m_dwTitleVersion,
           pLogData->m_dwTitleRegion,
           pLogData->m_qwMachinePUID,
           pLogData->m_qwUserPUID[0],
           pLogData->m_dwUserFlags[0],  // new
           pLogData->m_dwUserStatus[0],
           pPolicyData->hrUser[0],
           pLogData->m_afltUserTrustFactor[0],
           pLogData->m_qwUserPUID[1],
           pLogData->m_dwUserFlags[1],  // new
           pLogData->m_dwUserStatus[1],
           pPolicyData->hrUser[1],
           pLogData->m_afltUserTrustFactor[1],
           pLogData->m_qwUserPUID[2],
           pLogData->m_dwUserFlags[2],  // new
           pLogData->m_dwUserStatus[2],
           pPolicyData->hrUser[2],
           pLogData->m_afltUserTrustFactor[2],
           pLogData->m_qwUserPUID[3],
           pLogData->m_dwUserFlags[3],  // new
           pLogData->m_dwUserStatus[3],
           pPolicyData->hrUser[3],
           pLogData->m_afltUserTrustFactor[3],
           pLogData->m_szServicesRequested,
           pLogData->m_szSiteGranted,
           pLogData->m_szServicesAttain,
           pServiceAddress ? inet_ntoa(pServiceAddress->siteIPAddress) : "",
           pLogData->m_dwTicketLifeTime,
           pLogData->m_qwReqStatus,
           kerberr,
           pServiceAddress ? pServiceAddress->hr : E_UNEXPECTED,
           pIKerbRequest->GetElapsedTimeInMs()
          );
    return status;

ErrorFallback:

    // Something bad happened - we have no logdata, no kerbrequest, nothing. Log whatever
    // we can from the kdc core material.

    SOCKADDR_IN * pSockAddr = (SOCKADDR_IN*)ClientAddress;

    CSmallStr strPaList;
    GetPaListString(pIKerbRequest, &strPaList);

	xlog5("c:\\xkdc-XkdcProvider-cpp.log","REQFAIL|"DBGINAFMT"|%s|%X|%X|%d",
            DBGINAPRM((in_addr*)&pSockAddr->sin_addr),
            strPaList.cstr(),
            status,
            kerberr,
            pIKerbRequest->GetElapsedTimeInMs()
            );

    XomLog(log, "REQFAIL|"DBGINAFMT"|%s|%X|%X|%d",
            DBGINAPRM((in_addr*)&pSockAddr->sin_addr),
            strPaList.cstr(),
            status,
            kerberr,
            pIKerbRequest->GetElapsedTimeInMs()
            );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcPolicy.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "xkdc.h"
#include "XkdcMachineCache.h"
#include "XkdcDb.h"
#include "strsafe.h"

// local function to call user authorization stored procedure
NTSTATUS
GetUserAuthorization(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    IN XKDC_LOGGINGDATA *pLogData,
    IN DWORD dwUserIndex,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData
    );

#define SetDisconnectRating( dwUserFlags, rating ) ( dwUserFlags &= ~XONLINE_USER_DISCONNECT_RATING_MASK ); ( dwUserFlags |= ( XONLINE_USER_DISCONNECT_RATING_MASK & (rating << 5)) );

#define SetNoShowRating( dwUserFlags, rating ) ( dwUserFlags &= ~XONLINE_USER_NOSHOW_RATING_MASK); ( dwUserFlags |= ( XONLINE_USER_NOSHOW_RATING_MASK & (rating << 2)));

// local function used to set privilege bits in the Xenon authdata
void SetPrivilege( DWORD dwPrivileges[], DWORD dwServiceID, BOOL bAuthorized);

BOOLEAN
CheckTicketAndResetTime(
    IN const TimeStamp * TicketStartTime,
    IN const TimeStamp * PasswdResetTime,
    IN const TimeStamp * AllowedSkew
    )
{
    TimeStamp TicketTimePlus;

    TicketTimePlus.QuadPart = TicketStartTime->QuadPart + AllowedSkew->QuadPart;

    if ( PasswdResetTime->QuadPart > TicketTimePlus.QuadPart )
    {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS PolicyCheckMachine(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData
)
{
    //XOMASSERT( piReq );
    //XOMASSERT( pXkdc );
    //XOMASSERT( piPacSect );
    //XOMASSERT( pServiceRequest );
    //XOMASSERT( pServiceAddress );
    //XOMASSERT( pPolicyData );
    //XOMASSERT( pPolicyData->pXkdcDbData );

    //// validate all parameters
    //if ( NULL == pXkdc ||
    //     NULL == piPacSect ||
    //     NULL == pServiceRequest ||
    //     NULL == pServiceAddress ||
    //     NULL == pPolicyData )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_5, "(%s:%d) PolicyCheckMachine: invalid parameter.", __FILE__, __LINE__);
    //    return STATUS_INVALID_PARAMETER;
    //}

    //IPAXboxRequest *piXboxReq = NULL;
    //IPAXboxLogData *piXboxLog = NULL;
    //XKDC_LOGGINGDATA *pLogData = NULL;
    //NTSTATUS status = STATUS_SUCCESS;
    //HRESULT hr = S_OK;
    //const KERB_ENCRYPTED_TICKET *pTgt = NULL;

    //// These have to be initialized up here, before any GOTOs. Else the compiler
    //// complains.
    //XKDCDB_AUTHORIZATION_DATA*          pXkdcDbData         = pPolicyData->pXkdcDbData;
    //XKDCDB_MACHINE_AUTHORIZATION_DATA*  pxkdcDbMachineData;
    //FILETIME                            TicketStartTime     = {0};
    //FILETIME                            MachineBlockEndTime = {0};
    //NTSTATUS                            machineStatus       = STATUS_SUCCESS;
    //CLargeStr                           errorStr;

    // machine is assumed invalid until all checks pass
 /*   pPolicyData->hrXbox = E_FAIL;
    pPolicyData->bContinueChecks = FALSE;*/

    // get the Xkdc-specific interface from the preauth handler
    //status = piReq->GetPAHandler(IID_IPAXboxRequest, (PVOID*)&piXboxReq);
    //if ( !NT_SUCCESS(status) || NULL == piXboxReq )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_6, "(%s:%d) PolicyCheckMachine: no IID_IPAXboxRequest interface found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    // get the Xkdc log interface from the preauth handler
    //status = piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog);
    //if ( !NT_SUCCESS(status) || NULL == piXboxLog )
    //{
    //    XomNtEvent(XEVENT_KDC_CODE_108, "(%s:%d) PolicyCheckMachine: no IID_IPAXboxLogData interface found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    // get the log data
    //status = piXboxLog->GetLogData( &pLogData );
    //if ( !NT_SUCCESS(status) || NULL == pLogData )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_7, "(%s:%d) PolicyCheckMachine: no Log Data found.", __FILE__, __LINE__);
    //    XomTrace(Xkdc, L_HIGH, "(%s:%d) PolicyCheckMachine: no Log Data found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

   // // Evaluate platform type
   // if(IS_XENON_MACHINE_PUID(pPolicyData->qwXboxID))
   // {
   //     pPolicyData->dwPlatformType = XPLT_XBOX360;
   //     pPolicyData->dwAuthDataFlags |= XONLINE_AUTHDATA_FLAGS_ISXENON;
   // }
   // else if(IS_PC_MACHINE_PUID(pPolicyData->qwXboxID))
   // {
   //     pPolicyData->dwPlatformType = XPLT_PC;
   // }
   // else
   // {
   //     // Any other combination is wrong

   //     XomNtEvent(XEVENT_KDC_HACK_10,
   //         "PolicyCheckMachine: Invalid machine id. "
   //         "MachineId=0x%016I64X AuthDataFlags=0x%x",
   //         pPolicyData->qwXboxID,
   //         pPolicyData->dwAuthDataFlags);

   //     pPolicyData->KerbErr = pXkdc->SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
   //     goto Cleanup;
   // }

   // // lookup machine in machine cache.
   // if ( pXkdc->GetMachineCache()->Find( pPolicyData->qwXboxID, &machineStatus, &MachineBlockEndTime ) )
   // {
   //     // this box is in the cache which means... its banned.
   //     pPolicyData->hrXbox = machineStatus;
   //     pServiceAddress->hr = machineStatus;
   //     pServiceAddress->ftXboxConsoleResumeDate = MachineBlockEndTime;

   //     pLogData->m_qwReqStatus |= XKDC_REQSTATUS_MACHINE_ACCOUNT_BANNED;
   //     XomTrace(Policy, L_HIGH, "PolicyCheckMachine: machine account 0x%016I64X blocked in UODB.  Entry was found in the machine banning cache.", pPolicyData->qwXboxID);
   //     goto Cleanup;
   // }


   // //
   // // Look at cached DB item. If it isn't valid, then this must be a newly allocated
   // // cache item.  We'll fill it out with real DB data. Otherwise, we can avoid the DB
   // // hit and proceed.
   // //
   // if (!pXkdcDbData->IsValid)
   // {
   //     // Machine not present. Hit the DB.

   //     CXkdcDb::GetAuthorizationStatus authStatus;
   //     CXkdcDb                         xkdcdb(pXkdc);
   //     DWORD                           dwTitleId;

   //     // Store the request's dwTitleId, NOT the possibly-different dwLiveTitleId, in the
   //     // cache item. All we need this field for is detecting whether an incoming request
   //     // matches the cached data; so all we care about is the incoming request title id.
   //     // It's waay too difficult to calculate the LiveTitleId for purposes of
   //     // invalidating the cache item.
   //     //
   //     // @@@ TODO kgoodier Maybe move this to PolicyCheckTitleID, where it is more
   //     // appropriate. Downside is we would have to touch that code, which I don't want
   //     // to do right now. We ALWAYS check a machine auth, so this is an OK place to do
   //     // it.

   //     dwTitleId = pXkdcDbData->TitleId = pServiceRequest->dwTitleID;

   //     // Map all legacy PC titles released before PC per-title 5x5 to the panorama system title id
   //     // so we can check for legacy/not activation collisions
   //     if (pPolicyData->dwPlatformType == XPLT_PC && pXkdc->IsLegacyPcTitle(pServiceRequest->dwTitleID))
   //     {
   //         dwTitleId = XONLINE_PC_DASH_TITLE_ID;
   //     }

   //     // Call the into the DB layer to get the machine authorization.
   //     //
   //     // IMPORTANT NOTE: GetAuthorizationBusy will be returned from this call if 
   //     // any of the users are on partitions that are currently throttled. So, a 
   //     // failure here is not necessarily a failure on this partition.
   //     // 
   //     // It was done this way to prevent uncessary UODB round trips. This is the
   //     // first major call in the XKDC interaction with UODB.
   //     // 
   //     // ANOTHER IMPORTANT NOTE: The user ids in the ServiceRequest haven't 
   //     // been validated. However, they will be checked down the road and if they
   //     // aren't correct, the UODB traffic won't occur.
   //     authStatus = xkdcdb.GetMachineAuthorization(
   //         pServiceRequest,
   //         pPolicyData->qwXboxID,
   //         pPolicyData->dwPlatformType,
   //         dwTitleId,
   //         pXkdcDbData,
   //         &errorStr);

   //     switch (authStatus)
   //     {
			//case CXkdcDb::GetAuthorizationNotFound:
			//case CXkdcDb::GetAuthorizationFailed:			
			//case CXkdcDb::GetAuthorizationSucceeded:
			//	break;

			//case CXkdcDb::GetAuthorizationBusy:
			//	{
			//		pPolicyData->KerbErr = KDC_ERR_SERVICE_NOTYET;
			//		goto Cleanup;
			//	}

			//default:
			//	XOMASSERT(FALSE);
			//	break;
   //     }
   // }

   // // Get pointer to machine data
   // pxkdcDbMachineData = &(pXkdcDbData->MachineData);


   // //
   // // Enforcement
   // //

   // // Flash Version check
   // if ( pServiceRequest->dwFlashVersion )
   // {
   //     DWORD dwFlashVersionRequest = pServiceRequest->dwFlashVersion;
   //     DWORD dwFlashVersionUodb    = pxkdcDbMachineData->FlashVersion;

   //     if (dwFlashVersionUodb == 0 ||
   //         dwFlashVersionRequest != dwFlashVersionUodb)
   //     {
   //         // update perf counters
   //         g_Counters.IncrementValue32( XKDCPERF_SERVER_FLASH_VERSION_UPDATE_COUNTER, 1 );
   //         g_Counters.IncrementValue32( XKDCPERF_SERVER_FLASH_VERSION_UPDATE_RATE, 1 );

   //         // If we've never recorded the flash version, or the request flash version is
   //         // different than the recorded one, update the db.

   //         WCHAR wszFlashVersionRequest[16];
   //         XboxClientVersionDwordToWCHARString(
   //             dwFlashVersionRequest,
   //             wszFlashVersionRequest,
   //             ARRAYSIZE(wszFlashVersionRequest));

   //         // Update flash version stored in the database
   //         CComBSTR bstrFlashVersionRequest(wszFlashVersionRequest);
   //         hr = pXkdc->GetManagedProxy()->XkdcSetMachineFlashVersion( pPolicyData->qwXboxID, bstrFlashVersionRequest);
   //         if ( FAILED(hr) )
   //         {
   //             // update perf counters
   //             g_Counters.IncrementValue32( XKDCPERF_SERVER_FLASH_VERSION_UPDATE_FAILED_COUNTER, 1 );
   //             g_Counters.IncrementValue32( XKDCPERF_SERVER_FLASH_VERSION_UPDATE_FAILED_RATE, 1 );

   //             XomTrace(Xkdc, L_WARNING, "p_xkdc_update_flash failed for machine 0x%016I64X, flashver %S. hr = 0x%08X",
   //                      pPolicyData->qwXboxID,
   //                      wszFlashVersionRequest,
   //                      hr);
   //         }

   //         // Also update our cached view of the version! We don't want to write to the
   //         // database again on the next few requests.
   //         pxkdcDbMachineData->FlashVersion = dwFlashVersionRequest;

   //         // Also, alert in the rollback case, but don't block the request. Note we have
   //         // still updated the db to the older version.
   //         if (dwFlashVersionRequest < dwFlashVersionUodb)
   //         {
   //             WCHAR wszFlashVersionUodb[16];
   //             XboxClientVersionDwordToWCHARString(
   //                 dwFlashVersionUodb,
   //                 wszFlashVersionUodb,
   //                 ARRAYSIZE(wszFlashVersionUodb));

   //             if (XPLT_XBOX360 == pPolicyData->dwPlatformType)
   //             {
   //                 // update perf counters
   //                 g_Counters.IncrementValue32( XKDCPERF_SERVER_FLASH_VERSION_ROLLBACK_COUNTER, 1 );
   //                 g_Counters.IncrementValue32( XKDCPERF_SERVER_FLASH_VERSION_ROLLBACK_RATE, 1 );

   //                 // Only event for Xbox360
   //                 in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
   //                 XomNtEvent(XEVENT_XKDC_FLASH_VERSION_ROLLED_BACK,
   //                            "PolicyCheckMachine: Flash version lower than last recorded!\n"
   //                            "IP=%s\nMachineId=0x%016I64X\nRequestFlashVersion=%S\nUodbFlashVersion=%S\n\n"
   //                            "ServiceRequest:\n%s\n"
   //                            "XkdcDbData:\n%s\n",
   //                            inet_ntoa(*pInAddr),
   //                            pPolicyData->qwXboxID,
   //                            wszFlashVersionRequest,
   //                            wszFlashVersionUodb,
   //                            (LPCSTR)XKDC_PA_SERVICE_REQUEST::ToString(*pServiceRequest),
   //                            (LPCSTR)XKDCDB_AUTHORIZATION_DATA::ToString(*pXkdcDbData));
   //             }
   //             else
   //             {
   //                 // A mere trace for other platforms. PCs can bounce around flash
   //                 // versions apparently.
   //                 XomTrace(Xkdc, L_WARNING,
   //                          "PolicyCheckMachine: Flash version %S less than recorded version %S for MachineId=0x%016I64X",
   //                          wszFlashVersionRequest,
   //                          wszFlashVersionUodb,
   //                          pPolicyData->qwXboxID);
   //             }

   //         }
   //     }
   // }

   // // ConsoleRegion check (360 only)
   // if ( pServiceRequest->dwConsoleRegion &&
   //      XPLT_XBOX360 == pPolicyData->dwPlatformType)
   // {
   //     DWORD dwConsoleRegionRequest = pServiceRequest->dwConsoleRegion;
   //     DWORD dwConsoleRegionUodb    = pxkdcDbMachineData->ConsoleRegion;

   //     if (dwConsoleRegionUodb == 0 ||
   //         dwConsoleRegionUodb != dwConsoleRegionRequest)
   //     {
   //         // update perf counters
   //         g_Counters.IncrementValue32( XKDCPERF_SERVER_CONSOLE_REGION_SET_COUNTER, 1);
   //         g_Counters.IncrementValue32( XKDCPERF_SERVER_CONSOLE_REGION_SET_RATE, 1);

   //         // Update Console REgion stored in the database
   //         hr = pXkdc->GetManagedProxy()->XkdcSetMachineConsoleRegion( pPolicyData->qwXboxID, dwConsoleRegionRequest );
   //         if ( FAILED(hr) )
   //         {
   //             // update perf counters
   //             g_Counters.IncrementValue32( XKDCPERF_SERVER_CONSOLE_REGION_SET_FAILED_COUNTER, 1);
   //             g_Counters.IncrementValue32( XKDCPERF_SERVER_CONSOLE_REGION_SET_FAILED_RATE, 1);

   //             XomTrace(Xkdc, L_WARNING, "p_xkdc_update_console_region failed for machine 0x%016I64X, console regoin %x. hr = 0x%08X",
   //                      pPolicyData->qwXboxID,
   //                      dwConsoleRegionRequest,
   //                      hr);
   //         }

   //         // Also update our cached view of the version! We don't want to write to the
   //         // database again on the next few requests.
   //         pxkdcDbMachineData->ConsoleRegion = dwConsoleRegionRequest;

   //         // Alert in the case that we are overwriting the existing console region in UODB
   //         if (dwConsoleRegionUodb != 0 &&
   //             dwConsoleRegionUodb != dwConsoleRegionRequest)
   //         {
   //             // update perf counters
   //             g_Counters.IncrementValue32( XKDCPERF_SERVER_CONSOLE_REGION_OVERWRITTEN_COUNTER, 1 );
   //             g_Counters.IncrementValue32( XKDCPERF_SERVER_CONSOLE_REGION_OVERWRITTEN_RATE, 1 );

   //             // Only event for Xbox360
   //             in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
   //             XomNtEvent(XEVENT_XKDC_CONSOLE_REGION_CHANGED,
   //                        "PolicyCheckMachine: Console Region doesn't match recorded value!\n"
   //                        "IP=%s\nMachineId=0x%016I64X\nRequestConsoleRegion=%x\nUodbConsoleRegion=%x\n\n"
   //                        "ServiceRequest:\n%s\n"
   //                        "XkdcDbData:\n%s\n",
   //                        inet_ntoa(*pInAddr),
   //                        pPolicyData->qwXboxID,
   //                        dwConsoleRegionRequest,
   //                        dwConsoleRegionUodb,
   //                        (LPCSTR)XKDC_PA_SERVICE_REQUEST::ToString(*pServiceRequest),
   //                        (LPCSTR)XKDCDB_AUTHORIZATION_DATA::ToString(*pXkdcDbData));
   //         }
   //     }
   // }

   // // if the Xbox account is invalid (banned), set the hr field and add machine to the
   // // "MachineCache", which is really the machine ban cache. If you're in there, you're
   // // banzored.
   // if ( !NT_SUCCESS(pxkdcDbMachineData->BlockStatus) )
   // {
   //     pXkdc->GetMachineCache()->AddMachine( 
   //         pPolicyData->qwXboxID, 
   //         pxkdcDbMachineData->BlockStatus,
   //         &pxkdcDbMachineData->MachineBlockEndDate 
   //         );

   //     // This used to be XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED but is now whatever 
   //     // value is in the row associated with the machine.
   //     pPolicyData->hrXbox = pxkdcDbMachineData->BlockStatus;
   //     pServiceAddress->hr = pxkdcDbMachineData->BlockStatus;
   //     pServiceAddress->ftXboxConsoleResumeDate = pxkdcDbMachineData->MachineBlockEndDate;

   //     pLogData->m_qwReqStatus |= XKDC_REQSTATUS_MACHINE_ACCOUNT_BANNED;
   //     XomTrace(Policy, L_HIGH, "PolicyCheckMachine: machine account 0x%016I64X blocked in UODB.", pPolicyData->qwXboxID);
   //     goto Cleanup;
   // }

   // // find the incoming TGT
   // pTgt = piReq->GetTgt();
   // if ( NULL == pTgt )
   // {
   //     XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_11, "(%s:%d) PolicyCheckMachine: unable to acquire TGT from IKerbRequest.", __FILE__, __LINE__);
   //     pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
   //     status = STATUS_INVALID_PARAMETER;
   //     goto Cleanup;
   // }

   // // If the machine password has been reset since the TGT was issued,
   // // return a KerbErr indicating TGT was revoked.  The client will
   // // then reauthenticate and try again.
   // KerbConvertGeneralizedTimeToLargeInt(
   //     (PTimeStamp)&TicketStartTime,
   //     &pTgt->starttime,
   //     0);

   // if ( !CheckTicketAndResetTime((const TimeStamp *)&TicketStartTime,
   //                               (const TimeStamp *)&pxkdcDbMachineData->MachineResetDate,
   //                               &pXkdc->GetKdcPolicy()->TimeSkew) )
   // {
   //     XomTrace(Policy, L_ERROR, "PolicyCheckMachine: incoming TGT issued prior to password reset date.");
   //     pPolicyData->KerbErr = KDC_ERR_TGT_REVOKED;
   //     pLogData->m_qwReqStatus |= XKDC_REQSTATUS_TGT_PRIOR_TO_PASSWORD_RESET;
   //     goto Cleanup;
   // }

   // // Title activation enforcement. If the title requires activation and this machine
   // // hasn't done so, we fail the request entirely.
   // //
   // // Note: We may want to change this later -- perhaps we should grant a machine-only
   // // ticket so the machine can sign in and actually activate the title, but currently
   // // that's not how it is done so we'll keep it locked down.
   // //
   // if (pxkdcDbMachineData->ActivationRequired)
   // {
   //     XomTrace(Policy, L_WARNING,
   //              "PolicyCheckMachine: Machine 0x%016I64X requires activation for title 0x%08X, platform %u",
   //              pPolicyData->qwXboxID,
   //              pServiceRequest->dwTitleID,
   //              pPolicyData->dwPlatformType);
   //     pPolicyData->hrXbox = XONLINE_E_LOGON_TITLE_ACTIVATION_REQUIRED;
   //     pLogData->m_qwReqStatus |= XKDC_REQSTATUS_ACTIVATION_REQUIRED;
   //     goto Cleanup;
   // }

   // // This only applies to Panorama because this requires the knowledge that they create
   // // 1 machine accounts per machine, per user, per title. Knowing that, they should not
   // // activate title A but attempt to play title B. This is not true for Xbox360.
   // //
   // if (pPolicyData->dwPlatformType == XPLT_PC &&
   //     pxkdcDbMachineData->ActivatedOtherTitle)
   // {
   //     XomTrace(Policy, L_WARNING,
   //              "PolicyCheckMachine: Machine 0x%016I64X has activated a title other than 0x%08X, platform %u",
   //              pPolicyData->qwXboxID,
   //              pServiceRequest->dwTitleID,
   //              pPolicyData->dwPlatformType);
   //     pPolicyData->hrXbox = XONLINE_E_LOGON_OTHER_TITLE_ACTIVATED;
   //     pLogData->m_qwReqStatus |= XKDC_REQSTATUS_OTHER_TITLE_ACTIVATED;
   //     goto Cleanup;
   // }

   // // Beta box
   // pPolicyData->dwBetaTitleMask = pxkdcDbMachineData->BetaTitleMask;
   // XomTrace(Policy, L_LOW, "PolicyCheckMachine: Machine 0x%016I64X has Beta-title-mask: 0x%X.", pPolicyData->qwXboxID, pxkdcDbMachineData->BetaTitleMask);

   // // Set auth-data flags based on the console type field of the certificate. This field
   // // will be zero if the machine is an original Xbox or a PC. It will also be zero for
   // // Xbox 360 consoles that registered before this feature.
   // if(IS_XENON_MACHINE_PUID(pPolicyData->qwXboxID))
   // {
   //     if(pxkdcDbMachineData->CertConsoleType & CONSOLE_CERTIFICATE_TYPE_DEVKIT)
   //     {
   //         pPolicyData->dwAuthDataFlags |= XONLINE_AUTHDATA_FLAGS_ISDEVKIT;
   //     }

   //     if(pxkdcDbMachineData->CertConsoleType & CONSOLE_CERTIFICATE_TYPE_TESTKIT)
   //     {
   //         pPolicyData->dwAuthDataFlags |= XONLINE_AUTHDATA_FLAGS_ISTESTKIT;
   //     }
   // }
   // // The CertConsoleType field actually means something to the PC now
   // // so we need to treat it seperately from the Xenon
   // else if (IS_PC_MACHINE_PUID(pPolicyData->qwXboxID))
   // {
   //     if (pxkdcDbMachineData->CertConsoleType & PC_MACHINE_TYPE_LIMITED)
   //     {
   //         //Mark the account with limited so the user auth can check to see if they are still limited
   //         pPolicyData->dwAuthDataFlags |= XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE;
   //     }
   // }

   // //
   // // Marshal services
   // //

   // // if service auto-discovery is requested, the next result set will contain
   // // a list of all machine-only services
   // if ( pServiceRequest->wAutoDiscoverServices )
   // {
   //     DWORD dwRowNum = 0;
   //     for ( ;; dwRowNum++ )
   //     {
   //         DWORD dwServiceID = 0;
   //         DWORD dwNumSubscriptions = 0;  // placeholder

   //         // Retrieve from XKDCDB item
   //         if (!pXkdcDbData->FindServiceByIdx(dwRowNum, &dwServiceID, &dwNumSubscriptions))
   //         {
   //             // That's all the services. We're done.
   //             break;
   //         }

   //         // This part feels a little kludgy but it doesn't require lots
   //         // of special-case code in PolicyCheckServices to do one thing
   //         // for Xbox and another for Xenon.
   //         //
   //         // Each machine-only service autodiscovered will be added to the
   //         // pServiceRequest structure and as far as PolicyCheckServices is
   //         // concerned, all the services were explicitly requested.
   //         BOOL bServicePresent = FALSE;
   //         for ( DWORD svcIndex = 0; svcIndex < pServiceRequest->dwNumServices; svcIndex++)
   //         {
   //             if ( dwServiceID == pServiceRequest->dwServiceID[svcIndex] )
   //             {
   //                 bServicePresent = TRUE;
   //                 break;
   //             }
   //         }

   //         if ( !bServicePresent )
   //         {
   //             XomTrace(Policy, L_LOW, "(%s:%d) PolicyCheckMachine: adding auto-discovered service id %d to pServiceRequest (%d services total).", __FILE__, __LINE__, dwServiceID, pServiceRequest->dwNumServices+1);

   //             if(pServiceRequest->dwNumServices >= ARRAYSIZE(pServiceRequest->dwServiceID))
   //             {
   //                 XomNtEvent(XEVENT_KDC_CODE_125,
   //                             "PolicyCheckMachine: stored procedure returned too many services and privileges. "
   //                             "Machine-id: 0x%I64X, AutoDiscover: %u",
   //                             pPolicyData->qwXboxID,
   //                             pServiceRequest->wAutoDiscoverServices);
   //                 pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
   //                 status = STATUS_UNSUCCESSFUL;
   //                 goto Cleanup;
   //             }

   //             pServiceRequest->dwServiceID[pServiceRequest->dwNumServices++] = dwServiceID;
   //         }
   //     }
   // }

   // // machine is valid
   // pPolicyData->hrXbox = S_OK;
   // pPolicyData->bContinueChecks = TRUE;

    XomTrace(Policy, L_NORMAL, "PolicyCheckMachine: machine account 0x%016I64X is valid.", pPolicyData->qwXboxID);

//Cleanup:
    //pServiceAddress->hr = pPolicyData->hrXbox;
    return STATUS_SUCCESS;
}

NTSTATUS PolicyCheckUsers(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData
)
{
    //XOMASSERT( pXkdc );
    //XOMASSERT( piReq );
    //XOMASSERT( piPacSect );
    //XOMASSERT( pServiceRequest );
    //XOMASSERT( pServiceAddress );
    //XOMASSERT( pPolicyData );
    //XOMASSERT( pPolicyData->pXkdcDbData );

    //// validate all parameters
    //if ( NULL == pXkdc ||
    //     NULL == piReq ||
    //     NULL == piPacSect ||
    //     NULL == pServiceRequest ||
    //     NULL == pServiceAddress ||
    //     NULL == pPolicyData )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_8, "(%s:%d) PolicyCheckUsers: invalid parameter.", __FILE__, __LINE__);
    //    return STATUS_INVALID_PARAMETER;
    //}

    //NTSTATUS status = STATUS_SUCCESS;
    //ULONGLONG qwUserID = 0;
    //IPAXboxRequest *piXboxReq = NULL;
    //IPAXboxLogData *piXboxLog = NULL;
    //XKDC_LOGGINGDATA *pLogData = NULL;

    //INT i = 0;

    //// these used to access PAC_COMPOUND_IDENTITY section
    //const KERB_ENCRYPTED_TICKET *pTgt = NULL;
    //const PAC_INFO_BUFFER *pPacBuf = NULL;

    //BOOL bValidUsers = TRUE;
    //BOOL bValidPUID = FALSE;

    //// initialize scratch data
    //for (i=0; i<XONLINE_MAX_LOGON_USERS; i++)
    //{
    //    pPolicyData->users[i].qwUserID = pServiceRequest->qwUserID[i];
    //    pPolicyData->users[i].dwUserFlags = 0;
    //    pPolicyData->hrUser[i] = S_OK;

    //    if ( 0 != pPolicyData->users[i].qwUserID )
    //    {
    //        bValidPUID = TRUE;
    //    }
    //}

    //// if no users are present in the request, no further checks are
    //// needed
    //if ( !bValidPUID )
    //{
    //    goto Cleanup;
    //}

    //// get the Xkdc-specific interface from the preauth handler
    //status = piReq->GetPAHandler(IID_IPAXboxRequest, (PVOID*)&piXboxReq);
    //if ( !NT_SUCCESS(status) || NULL == piXboxReq )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_9, "(%s:%d) PolicyCheckUsers: no IID_IPAXboxRequest interface found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    //// get the Xkdc log interface from the preauth handler
    //status = piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog);
    //if ( !NT_SUCCESS(status) || NULL == piXboxLog )
    //{
    //    XomNtEvent(XEVENT_KDC_CODE_128, "(%s:%d) PolicyCheckUsers: no IID_IPAXboxLogData interface found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    //// get the log data
    //status = piXboxLog->GetLogData( &pLogData );
    //if ( !NT_SUCCESS(status) || NULL == pLogData )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_10, "(%s:%d) PolicyCheckUsers: no Log Data found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    //// find the incoming TGT
    //pTgt = piReq->GetTgt();
    //if ( NULL == pTgt )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_11, "(%s:%d) PolicyCheckUsers: unable to acquire TGT from IKerbRequest.", __FILE__, __LINE__);
    //    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    //// At this moment, we accept TGT tickets that contain either an
    //// XBOX_IDENTITY or those that contain a CLIENT_IDENTITY. 
    //// 
    //// At some point, we will stop accepting those that contain a
    //// CLIENT_IDENTITY
    //// 
    //// Note: we don't explicitly look for a COMPOUND_IDENTITY. We
    //// assume that it can exist if the client identity is present
    //// 
    //status = piPacSect->GetPacSection(PAC_XBOX_IDENTITY, &pPacBuf);

    //// If an error is returned, reply with a KERB_ERR. The reason is that 
    //// we expect a compound identity since there is a use present in the
    //// service request.

    //if ( STATUS_NOT_FOUND == status ) 
    //{
    //    XOMASSERT( NULL == pPacBuf );
    //    XomTrace(Policy, L_LOW, "PolicyCheckUsers: no PAC_XBOX_IDENTITY section found in ticket.");

    //    status = piPacSect->GetPacSection(PAC_CLIENT_IDENTITY, &pPacBuf);
    //    if ( !NT_SUCCESS(status) ) 
    //    {
    //        XOMASSERT( NULL == pPacBuf );
    //        XomTrace(Policy, L_ERROR, "PolicyCheckUsers: no PAC_CLIENT_IDENTITY section found in ticket.");
    //        bValidUsers = FALSE;
    //    }
    //}
    //else if ( !NT_SUCCESS(status) ) 
    //{
    //    XomTrace(Policy, L_ERROR, "PolicyCheckUsers: request for PAC_XBOX_IDENTITY failed with status %d.", status);
    //    bValidUsers = FALSE;
    //}
    //else
    //{
    //    // We don't accept both a CLIENT_IDENTITY and a XBOX_IDENTITY
    //    status = piPacSect->GetPacSection(PAC_CLIENT_IDENTITY, &pPacBuf);
    //    if ( NT_SUCCESS(status) ) 
    //    {
    //        XomTrace(Policy, L_ERROR, "PolicyCheckUsers: found both PAC_XBOX_IDENTITY and PAC_CLIENT_IDENTITY.");
    //        bValidUsers = FALSE;
    //    }

    //    // We don't accept both a COMPOUND_IDENTITY and an XBOX_IDENTITY
    //    status = piPacSect->GetPacSection(PAC_COMPOUND_IDENTITY, &pPacBuf);
    //    if ( NT_SUCCESS(status) ) 
    //    {
    //        XomTrace(Policy, L_ERROR, "PolicyCheckUsers: found both PAC_XBOX_IDENTITY and PAC_COMPOUND_IDENTITY.");
    //        bValidUsers = FALSE;
    //    }
    //}

    ////
    //// If we think that we might have valid users, actually make sure that
    //// they are properly in the PAC data
    //// 

    //if ( TRUE == bValidUsers ) 
    //{
    //    // The user puids in the preauth request are in controller order.
    //    // Before copying them into the authdata, make sure they were
    //    // present in the PAC.
    //    for (i = 0; i < XONLINE_MAX_LOGON_USERS; ++i)
    //    {
    //        // if there is no user on this controller, skip it
    //        if ( 0 == pPolicyData->users[i].qwUserID )
    //        {
    //            continue;
    //        }

    //        status = PacGetUserIdentity(
    //            piPacSect,
    //            pPolicyData->users[i].qwUserID,
    //            &(pPolicyData->dwUserCredentialIdType[i])
    //            );
    //        if (NT_SUCCESS(status) && pPolicyData->dwUserCredentialIdType[i] != CT_Unknown)
    //        {
    //            XomTrace(Policy, L_LOW, "PolicyCheckUsers: FindIdentity found puid 0x%016I64X.", pPolicyData->users[i].qwUserID);
    //            pPolicyData->hrUser[i] = S_OK;
    //            continue;
    //        }

    //        // This PUID was not present in the PAC so fail the entire request
    //        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

    //        CSmallStr str;
    //        PacGetIdentitiesAsString( piPacSect, &str);

    //        XomNtEvent(XEVENT_KDC_HACK_13,
    //            "PolicyCheckUsers: PUID 0x%016I64X present in preauth but not found in combined TGT from machine account: 0x%016I64X client %s. Possible hack attempt.\nPUIDS in TGT:\n%s",
    //            pPolicyData->users[i].qwUserID,
    //            pPolicyData->qwXboxID,
    //            inet_ntoa(*pInAddr),
    //            str.cstr());
    //        // Reject this request.
    //        bValidUsers = FALSE;
    //    }
    //}
 
    //// if not all of the users were found in the AS ticket, don't
    //// bother performing any checks in the UODB
    //if ( FALSE == bValidUsers )
    //{
    //    // If we got here, then that means that one or more users in the 
    //    // tickets is not valid (ie: no compound identity present for it)
    //    // 
    //    // The best we can do at this point is to wipe out the user so that
    //    // they don't show up in the ticket and indicate that an error
    //    // occured.
    //    // 
    //    // Zeroing the user is defensive coding since returning an error 
    //    // from this function should result in no ticket being issued.
    //    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
    //    status = STATUS_INVALID_PARAMETER;
    //    
    //    for (i = 0; i<XONLINE_MAX_LOGON_USERS; ++i) 
    //    {
    //        if ( 0 != pPolicyData->users[i].qwUserID )
    //        {
    //            pPolicyData->hrUser[i] = XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
    //        }
    //        pPolicyData->users[i].qwUserID = 0;
    //        pPolicyData->users[i].dwUserFlags = 0;
    //    }
    //    goto Cleanup;
    //}

    //// NOTE: At this point, we consider that the users present in the request
    //// as having been validated. Any failures in the user validation should
    //// generate a valid machine ticket and a troubleshoot account hr

    //// check the UODB for authorization data for each of the users
    //for (i=0; i<XONLINE_MAX_LOGON_USERS; i++)
    //{
    //    if ( 0 == pPolicyData->users[i].qwUserID )
    //    {
    //        continue;
    //    }

    //    // keep count of the users present in the request
    //    pPolicyData->dwUsers++;

    //    // this handles Xenon requests
    //    status = GetUserAuthorization(
    //        pXkdc,
    //        piReq,
    //        piPacSect,
    //        pServiceRequest,
    //        pLogData,
    //        i,
    //        pServiceAddress,
    //        pPolicyData);
    //    if ( !NT_SUCCESS(status) )
    //    {
    //        XomTrace(Policy, L_WARNING, "(%s:%d) PolicyCheckUsers: GetUserAuthorization failed with status: 0x%08X.", __FILE__, __LINE__, status);
    //        goto Cleanup;
    //    }
    //}

//Cleanup:

    //// if no users, this is machine only. the case of invalid or unauthorized users will
    //// be handled elsewhere.
    //if (pPolicyData->dwUsers == 0)
    //{
    //    pPolicyData->bMachineOnly = TRUE;
    //}

    //// Decide whether or not we can return the SERVICE_ADDRESS_FAILED pre-auth
    //if (pServiceRequest->bAllowServiceAddressFailed == TRUE &&
    //    pPolicyData->bUserAccountSuspended          == TRUE)
    //{
    //    XomTrace(Xkdc, L_ERROR, "XKDC: PolicyCheckUsers() Failed - Forcing SERVICE_ADDRESS_FAILED response" );
    //    pServiceAddress->bUseFailedAddress = TRUE;
    //}

    //// copy the hr values and user flags into the return preauth
    //for (i=0; i<XONLINE_MAX_LOGON_USERS; i++)
    //{
    //    // If a user is in the unknown trust state and another is not trusted,
    //    // then don't return the unknown trust value. 
    //    // 
    //    // The unknown trust state is reserved for situations where the kdc
    //    // will be handing back a limited ticket
    //    if ( pPolicyData->hrUser[i] == XONLINE_E_LOGON_USER_UNKNOWN_TRUST &&
    //         pServiceAddress->bUseFailedAddress == TRUE) 
    //    {
    //        pPolicyData->hrUser[i] = STATUS_SUCCESS;
    //        if (pLogData != NULL) 
    //        {
    //            pLogData->m_dwUserStatus[i] |= XKDC_USERSTATUS_CLEARED_UNKNOWN_TRUST_HR; 
    //        }
    //    }

    //    // If a user is in the requires management state and another is not
    //    // trusted, then don't return the requires management state.
    //    // 
    //    // The requires management state is reserved for situations where the
    //    // kdc will be handing back a limited ticket
    //    if ( pPolicyData->hrUser[i] == XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT) 
    //    {

    //        if (pServiceAddress->bUseFailedAddress) 
    //        {
    //            pPolicyData->hrUser[i] = STATUS_SUCCESS;
    //            if (pLogData != NULL) 
    //            {
    //                pLogData->m_dwUserStatus[i] |= XKDC_USERSTATUS_CLEARED_MANAGEMENT_HR; 
    //            }
    //        }
    //        else
    //        {
    //            // Remember that at least one user is in the require
    //            // management state
    //            pPolicyData->bUserRequiresMaintenance = TRUE;
    //        }
    //    }

    //    pServiceAddress->hrUser[i] = pPolicyData->hrUser[i];
    //    pServiceAddress->dwUserFlags[i] = pPolicyData->users[i].dwUserFlags;
    //    pServiceAddress->ftUserAccountResumeDate[i] = pPolicyData->ftUserAccountResumeDate[i];

    //    // Logging stuff
    //    if (pLogData != NULL)
    //    {
    //        // hrUser can only be these values:
    //        //   S_OK
    //        //   XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
    //        //   XONLINE_E_LOGON_USER_UNKNOWN_TRUST
    //        //   XONLINE_E_LOGON_INTERNAL_ERROR
    //        //   XONLINE_E_LOGON_BLOCKED_BY_CURFEW
    //        //   XONLINE_E_ACCOUNTS_ACCOUNT_BANNED
    //        // However, most of these values are already handled by 
    //        // GetUserAuthorization.

    //        if (pPolicyData->hrUser[i] == XONLINE_E_LOGON_INTERNAL_ERROR)
    //        {
    //            pLogData->m_dwUserStatus[i] |= XKDC_USERSTATUS_INTERNALERROR;
    //        }

    //        pLogData->m_dwUserFlags[i] = pPolicyData->users[i].dwUserFlags;
    //    }

    //    // Skip the trace call if there is no user present in the slot
    //    if ( 0 == pPolicyData->users[i].qwUserID ) 
    //    {
    //        continue;
    //    }
        //XomTrace(Policy, L_LOW, "PolicyCheckUsers: for user 0x%016I64X, adding hrUser = 0x%08X, dwUserFlags=0x%08X to SERVICE_ADDRESS preauth.",
        //    pPolicyData->users[i].qwUserID,
        //    pServiceAddress->hrUser[i],
        //    pServiceAddress->dwUserFlags[i]);
    //}

    return STATUS_SUCCESS;
}


//----------------------------------------------------------------
NTSTATUS
GetUserAuthorization(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    IN XKDC_LOGGINGDATA *pLogData,
    IN DWORD dwUserIndex,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData
    )
{
    //XOMASSERT( pXkdc );
    //XOMASSERT( piReq );
    //XOMASSERT( piPacSect );
    //XOMASSERT( pServiceRequest );
    //XOMASSERT( pServiceAddress );
    //XOMASSERT( pPolicyData );
    //XOMASSERT( pPolicyData->pXkdcDbData );

    //// validate all parameters
    //if ( NULL == pXkdc ||
    //     NULL == piReq ||
    //     NULL == piPacSect ||
    //     NULL == pServiceRequest ||
    //     NULL == pServiceAddress ||
    //     NULL == pPolicyData ||
    //     NULL == pPolicyData->pXkdcDbData )
    //{
    //    XomNtEvent(XEVENT_XKDC_POLICY_BAD_PARAMETER,
    //                "GetUserAuthorization: invalid parameter.");
    //    return STATUS_INVALID_PARAMETER;
    //}

    //DWORD                           i;
    //NTSTATUS                        status = STATUS_SUCCESS;
    //HRESULT                         hr = S_OK;
    //XKDCDB_AUTHORIZATION_DATA*      pXkdcDbData = pPolicyData->pXkdcDbData;
    //XKDCDB_USER_AUTHORIZATION_DATA* pxkdcDbUserData;
    //FILETIME                        TicketStartTime = {0};
    //CLargeStr                       errorStr;

    //
    // Look at cached DB item. If it isn't valid, then this must be a newly allocated
    // cache item.  We'll fill it out with real DB data. Otherwise, we can avoid the DB
    // hit and proceed.
    //
    //if (!pXkdcDbData->IsValid)
    //{
    //    // Cache item not present. Hit the DB.

    //    CXkdcDb::GetAuthorizationStatus authStatus;
    //    CXkdcDb                         xkdcdb(pXkdc);

    //    BOOL fCheckLimitedMac = FALSE;
    //    if ((pPolicyData->dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE) != 0)
    //    {
    //        fCheckLimitedMac = TRUE;
    //    }
    //    authStatus = xkdcdb.GetXenonUserAuthorization(
    //        pServiceRequest,
    //        dwUserIndex,
    //        pPolicyData->qwXboxID,
    //        pServiceAddress->dwLiveTitleId,
    //        fCheckLimitedMac,
    //        pPolicyData->dwPlatformType,
    //        pXkdcDbData,
    //        &errorStr);

    //    switch (authStatus)
    //    {

    //    case CXkdcDb::GetAuthorizationNotFound:
    //        {
    //            status = STATUS_UNSUCCESSFUL;

    //            // user that has been disabled, or not found in stored proc
    //            pPolicyData->hrUser[dwUserIndex] = XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
    //            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_INVALIDNAME;

    //            in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

    //            XomNtEvent(
    //                XEVENT_XKDC_DB_GETUSERAUTH_ERROR,
    //                "GetUserAuthorization: unknown user id 0x%016I64X. This may indicate a race condition "
    //                "or database problem or the user may have an invalid subscription. Please monitor and "
    //                "report to dev team if it occurs more than once for the same user.\n"
    //                "Error string:\n%s\n"
    //                "ServiceRequest:\n%s\n"
    //                "XkdcDbData:\n%s\n"
    //                "PolicyData:\n%s\n",
    //                pPolicyData->users[dwUserIndex].qwUserID,
    //                errorStr.cstr(),
    //                (LPCSTR)XKDC_PA_SERVICE_REQUEST::ToString(*pServiceRequest),
    //                (LPCSTR)XKDCDB_AUTHORIZATION_DATA::ToString(*pXkdcDbData),
    //                (LPCSTR)XKDC_POLICY_DATA::ToString(*pPolicyData));

    //            XomTrace(Xkdc, L_ERROR, "GetUserAuthorization: unknown user id 0x%016I64X!\n", pPolicyData->users[dwUserIndex].qwUserID);

    //            goto Cleanup;
    //        }

    //    case CXkdcDb::GetAuthorizationFailed:
    //        {
    //            XomNtEvent(
    //                XEVENT_XKDC_DB_GETUSERAUTH_ERROR,
    //                "GetUserAuthorization failed. This indicates a database or network problem. Please "
    //                "monitor and if these occur excessively escalate.\n"
    //                "Error string:\n%s\n"
    //                "ServiceRequest:\n%s\n"
    //                "XkdcDbData:\n%s\n"
    //                "PolicyData:\n%s\n",
    //                errorStr.cstr(),
    //                (LPCSTR)XKDC_PA_SERVICE_REQUEST::ToString(*pServiceRequest),
    //                (LPCSTR)XKDCDB_AUTHORIZATION_DATA::ToString(*pXkdcDbData),
    //                (LPCSTR)XKDC_POLICY_DATA::ToString(*pPolicyData));

    //            status = STATUS_UNSUCCESSFUL;
    //            pPolicyData->hrUser[dwUserIndex] = XONLINE_E_LOGON_INTERNAL_ERROR;
    //            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
    //            goto Cleanup;
    //        }

    //    case CXkdcDb::GetAuthorizationSucceeded:
    //        break;

    //    case CXkdcDb::GetAuthorizationBusy:
    //        {
    //            pPolicyData->KerbErr = KDC_ERR_SERVICE_NOTYET;
    //            goto Cleanup;
    //        }

    //    default:
    //        XOMASSERT(FALSE);
    //        break;
    //    }
    //}

    ////
    //// Get pointer to user data
    ////
    //if (!pXkdcDbData->FindUserDataByIdx(dwUserIndex, &pxkdcDbUserData))
    //{
    //    XomNtEvent(
    //        XEVENT_XKDC_DB_GETUSERAUTH_ERROR,
    //        "Failed to find user data (index %u) in XKDCDB_AUTHORIZATION_DATA. This is unexpected, "
    //        "please escalate to the dev team.\n"
    //        "XkdcDbData:\n%s\n"
    //        "ServiceRequest:\n%s\n"
    //        "PolicyData:\n%s\n",
    //        dwUserIndex,
    //        (LPCSTR)XKDCDB_AUTHORIZATION_DATA::ToString(*pXkdcDbData),
    //        (LPCSTR)XKDC_PA_SERVICE_REQUEST::ToString(*pServiceRequest),
    //        (LPCSTR)XKDC_POLICY_DATA::ToString(*pPolicyData));
    //    status = STATUS_UNSUCCESSFUL;
    //    pPolicyData->hrUser[dwUserIndex] = XONLINE_E_LOGON_INTERNAL_ERROR;
    //    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
    //    goto Cleanup;
    //}

    //// find the incoming TGT
    //const KERB_ENCRYPTED_TICKET *pTgt = NULL;

    //pTgt = piReq->GetTgt();
    //XOMASSERT( pTgt );

    //// If the user password has been reset since the TGT was issued,
    //// return a KerbErr indicating TGT was revoked.  The client will
    //// then reauthenticate and try again.
    //KerbConvertGeneralizedTimeToLargeInt(
    //    (PTimeStamp)&TicketStartTime,
    //    &pTgt->starttime,
    //    0
    //    );

    //if ( !CheckTicketAndResetTime((const TimeStamp *)&TicketStartTime,
    //                              (const TimeStamp *)&pxkdcDbUserData->PasswordResetDate,
    //                              &pXkdc->GetKdcPolicy()->TimeSkew) )
    //{
    //    XomTrace(Policy, L_ERROR, "GetUserAuthorization: incoming TGT issued prior to password reset date.");
    //    pPolicyData->KerbErr = KDC_ERR_TGT_REVOKED;
    //    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_TGT_PRIOR_TO_PASSWORD_RESET;
    //    pPolicyData->bContinueChecks = FALSE;
    //    goto Cleanup;
    //}

    ////
    //// Credential Type Check:
    //// 
    //// Make sure that we are happy with the credentials that have gotten passed in
    //// 
    //switch (pPolicyData->dwUserCredentialIdType[dwUserIndex]) 
    //{
    //    // We never expect to see a user authorized with a PC passport to come in
    //    // on anything but a PC
    //    case CT_RawPassport:

    //        // This type of credential is only applicable to Panorama Clients
    //        if (pPolicyData->dwPlatformType != XPLT_PC) 
    //        {
    //            XomTrace(Policy, L_ERROR, "GetUserAuthorization: PC Credentials on a Non PC.");
    //            pPolicyData->KerbErr = KDC_ERR_TGT_REVOKED;
    //            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_TGT_PC_CREDENTIALS;
    //            pPolicyData->bContinueChecks = FALSE;
    //            goto Cleanup;
    //        }
    //        break;

    //    case CT_RandomKey:
    //    case CT_EncryptedPassport:
    //        break;

    //    default:

    //        //
    //        // We have no idea what this auth ticket is. TGT Revoked.
    //        // 
    //        XomTrace(
    //            Policy, 
    //            L_ERROR, 
    //            "GetUserAuthorization: Unknown CredentialIdType: %d.",
    //            pPolicyData->dwUserCredentialIdType[dwUserIndex]
    //            );
    //        pPolicyData->KerbErr                  = KDC_ERR_TGT_REVOKED;
    //        pLogData->m_qwReqStatus               |= XKDC_REQSTATUS_TGT_UNKNOWN_CREDENTIALS;
    //        pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_TGT_UNKNOWN_CREDENTIALS;
    //        pPolicyData->bContinueChecks          = FALSE;
    //        goto Cleanup;
    //}

    //// Check User Machine Trust Level
    ////
    //// Note: The bAllowServiceAddressFailed tells us that the client is running a version
    //// that can handle roaming profile state.

    //BOOL bUserTrustUnknown = FALSE;
    //BOOL bCheckUserMachineTrust = FALSE;
    //BOOL bUserRemovePrivileges = FALSE;

    //bCheckUserMachineTrust =
    //    (pXkdc->GetDisableUserMachineTrust()         == TRUE  ? FALSE : 
    //    (pXkdc->GetEnableUserMachineTrust()          == TRUE  ? TRUE  : 
    //    (pServiceRequest->bAllowServiceAddressFailed == FALSE ? FALSE : TRUE
    //    ) ) );
    //if (bCheckUserMachineTrust == TRUE)
    //{
    //    XomTrace(
    //        Xkdc, 
    //        L_NORMAL, 
    //        "XKDC: GetUserAuthorization() Checking user trust level - Type: %d, Level: %d",
    //        pPolicyData->dwUserCredentialIdType[dwUserIndex],
    //        pxkdcDbUserData->UserMachineTrustLevel 
    //        );

    //    // Make decisions depending on the credential types that this user provided
    //    if (pPolicyData->dwUserCredentialIdType[dwUserIndex] == CT_RandomKey) 
    //    {
    //        // User authenticated with a random key. Accept them if they are trusted level
    //        if (pxkdcDbUserData->UserMachineTrustLevel != XONLINE_USER_MACHINE_TRUST_LEVEL_TRUSTED) 
    //        {
    //            pLogData->m_qwReqStatus               |= XKDC_REQSTATUS_USER_MACHINE_TRUST_FAILURE;
    //            pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_USER_MACHINE_TRUST_FAILURE;
    //            pPolicyData->hrUser[dwUserIndex]      = XONLINE_E_LOGON_USER_NOT_TRUSTED;
    //            pPolicyData->bContinueChecks          = FALSE;

    //            // The logic here is:
    //            // V5 Client -> bAllowServiceAddressFailed == FALSE, so bUseFailedAddress == FALSE
    //            // V6 Client -> bAllowServiceAddressFailed == TRUE,  so bUseFailedAddress == TRUE
    //            pServiceAddress->bUseFailedAddress  = pServiceRequest->bAllowServiceAddressFailed;
    //            XomTrace(Xkdc, L_ERROR, "XKDC: GetUserAuthorization() Failed - Forcing SERVICE_ADDRESS_FAILED response" );
    //            goto Cleanup;
    //        }
    //    }
    //    else if (pPolicyData->dwUserCredentialIdType[dwUserIndex] == CT_EncryptedPassport) 
    //    {
    //        // If the user is on a trusted machine, then there is no point in checking
    //        // to see if the RPS ticket is expired. The user would have been able to
    //        // log on with a CT_RandomKey ticket
    //        // 
    //        // We do validate that the RPS ticket is good in the 'not trusted' trust case
    //        if (pxkdcDbUserData->UserMachineTrustLevel != XONLINE_USER_MACHINE_TRUST_LEVEL_TRUSTED) 
    //        {
    //            if ( !CheckTicketAndResetTime((const TimeStamp *)&TicketStartTime,
    //                                          (const TimeStamp *)&pxkdcDbUserData->LastSignoutDate,
    //                                          &pXkdc->GetKdcPolicy()->TimeSkew) )
    //            {
    //                XomTrace(Policy, L_ERROR, "GetUserAuthorization: incoming TGT issued prior to signout date.");

    //                pLogData->m_qwReqStatus               |= XKDC_REQSTATUS_TGT_PRIOR_TO_SIGNOUT_DATE;
    //                pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_TGT_PRIOR_TO_SIGNOUT_DATE;
    //                pPolicyData->hrUser[dwUserIndex]      = XONLINE_E_LOGON_USER_RPS_EXPIRED;
    //                pPolicyData->bContinueChecks          = FALSE;

    //                // The logic here is:
    //                // V5 Client -> bAllowServiceAddressFailed == FALSE, so bUseFailedAddress == FALSE
    //                // V6 Client -> bAllowServiceAddressFailed == TRUE,  so bUseFailedAddress == TRUE
    //                pServiceAddress->bUseFailedAddress  = pServiceRequest->bAllowServiceAddressFailed;
    //                XomTrace(Xkdc, L_ERROR, "XKDC: GetUserAuthorization() Failed - Forcing SERVICE_ADDRESS_FAILED response" );
    //                goto Cleanup;
    //            }
    //        }
    //        else 
    //        {
    //            pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_USER_MACHINE_NOT_TRUSTED;
    //        }
    //    }
    //}


    //// Title activation enforcement. If the title requires activation and this user hasn't
    //// done so, we fail the request entirely.
    ////
    //// Note: We may want to change this later -- perhaps we should grant a machine-only
    //// ticket so the user can sign in and actually activate the title, but currently
    //// that's not how it is done so we'll keep it locked down.
    ////
    //if (pxkdcDbUserData->ActivationRequired)
    //{
    //    XomTrace(Policy, L_WARNING,
    //             "GetUserAuthorization: User 0x%016I64X requires activation for title 0x%08X, platform %u",
    //             pPolicyData->users[dwUserIndex].qwUserID,
    //             pServiceRequest->dwTitleID,
    //             pPolicyData->dwPlatformType);

    //    // @@@ kgoodier Setting pServiceAddress->hr results in no ticket but NO hrUser
    //    // results; setting pPolicyData->hrUser results in a machine-only services ticket.
    //    // Which do we want?

    //    pServiceAddress->hr = XONLINE_E_LOGON_USER_TITLE_ACTIVATION_REQUIRED;
    //    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_ACTIVATION_REQUIRED;
    //    pPolicyData->bContinueChecks = FALSE;

    //    goto Cleanup;
    //}

    //// Set limited machine bit in authdataflags
    //if ( !pxkdcDbUserData->LimitedMachine )
    //{
    //    pPolicyData->dwAuthDataFlags &= ~XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE;
    //}

    ////
    //// If a curfew would limit the user's ticket lifetime, it will apply to the overall ticket
    ////
    //if ( pxkdcDbUserData->MaxTicketLifetimeSecs < pPolicyData->dwMaxTicketLifetimeSecs )
    //{
    //    pPolicyData->dwMaxTicketLifetimeSecs = pxkdcDbUserData->MaxTicketLifetimeSecs;

    //    XomTrace(Policy, L_LOW, "GetUserAuthorization: User 0x%016I64X subject to curfew limiting ticket lifetime to %u seconds",
    //             pPolicyData->users[dwUserIndex].qwUserID,
    //             pPolicyData->dwMaxTicketLifetimeSecs);
    //}

    ////
    //// An imminent curfew requires us to fail the request entirely so that no ticket is granted and any active sessions can
    //// be terminated by the SG.
    ////
    //if ( pxkdcDbUserData->BlockedByCurfew )
    //{
    //    XomTrace(Policy, L_LOW, "GetUserAuthorization: User 0x%016I64X blocked from receiving ticket due to imminent curfew",
    //             pPolicyData->users[dwUserIndex].qwUserID);

    //    pServiceAddress->hr = XONLINE_E_LOGON_BLOCKED_BY_CURFEW;
    //    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_BLOCKED_BY_CURFEW;
    //    pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_BLOCKED_BY_CURFEW;
    //    pPolicyData->bContinueChecks = FALSE;

    //    goto Cleanup;
    //}

    ////
    //// Move over service authorization data. This includes some funky autodiscovery stuff.
    ////

    //// This part feels a little kludgy but it doesn't require lots
    //// of special-case code in PolicyCheckServices 
    ////
    //// Each service autodiscovered for the user will be added to the
    //// pServiceRequest structure and as far as PolicyCheckServices is
    //// concerned, all the services were explicitly requested.
    ////
    //// We need to walk through all cached (in the dbdata) services.
    ////
    //if ( pServiceRequest->wAutoDiscoverServices )
    //{
    //    DWORD dwRowNum = 0;
    //    for ( ;; dwRowNum++ )
    //    {
    //        DWORD dwServiceID = 0;
    //        DWORD dwNumSubscriptions = 0;

    //        // Retrieve from XKDCDB item
    //        if (!pXkdcDbData->FindServiceByIdx(dwRowNum, &dwServiceID, &dwNumSubscriptions))
    //        {
    //            // That's all the services. We're done.
    //            break;
    //        }

    //        // if the service is not already present in pServiceRequest,
    //        // add it.
    //        BOOL bServicePresent = FALSE;
    //        for (i = 0; i < pServiceRequest->dwNumServices; i++)
    //        {
    //            if ( dwServiceID == pServiceRequest->dwServiceID[i] )
    //            {
    //                bServicePresent = TRUE;
    //                break;
    //            }
    //        }

    //        if ( !bServicePresent )
    //        {
    //            XomTrace(Policy, L_LOW, "(%s:%d) GetXenonUserAuthorization: adding auto-discovered service id %d to pServiceRequest (%d services total).", __FILE__, __LINE__, dwServiceID, pServiceRequest->dwNumServices+1);

    //            XOMASSERT(pServiceRequest->dwNumServices < ARRAYSIZE(pServiceRequest->dwServiceID));
    //            pServiceRequest->dwServiceID[pServiceRequest->dwNumServices++] = dwServiceID;
    //        }
    //    }
    //}

    ////
    //// @@@ TODO kgoodier Clean up and document the ticket flags structure?
    ////

    //DWORD dwTicketFlags = pxkdcDbUserData->TicketFlags;

    //// Voice ban may have been set in the ticket flags but it may also
    //// have been banned for a period of time.  If a voice ban is in place
    //// set the low bit in the ticket flags.
    //dwTicketFlags = dwTicketFlags | pxkdcDbUserData->VoiceBanned;

    ////
    //// Set tier id in the ticket flags
    ////
    //dwTicketFlags &= ~ (0x00F0); // clear out any db bits set in tier id range
    //dwTicketFlags |= (((WORD) pxkdcDbUserData->TierID) << 4);

    //// Add data from the user's ticket flags to the scratch area and
    //// the ticket authdata.
    //pPolicyData->users[dwUserIndex].dwUserFlags =
    //    ((((WORD) dwTicketFlags) << 8) | ((BYTE) pxkdcDbUserData->CountryID)) << 8 ;

    //// Move over and calculate trust values. This will add to the dwUserFlags.
    //pPolicyData->afltTrustFactor[dwUserIndex] = pxkdcDbUserData->TrustFactor;
    //pLogData->m_afltUserTrustFactor[dwUserIndex] = pxkdcDbUserData->TrustFactor;

    //SetDisconnectRating( pPolicyData->users[dwUserIndex].dwUserFlags, pxkdcDbUserData->DisconnectRating);
    //SetNoShowRating( pPolicyData->users[dwUserIndex].dwUserFlags, pxkdcDbUserData->NoShowRating)

    //// There are several conditions under which the user account is
    //// flagged as requiring management:
    ////  - user has not agreed to latest terms of service
    ////  - user has account status id greater than 0
    ////  - user has a failed billing account status
    ////  - user requires name change
    ////  - user WLID account has expired
    ////  - owner WLID account has expired
    //if (pxkdcDbUserData->AcctSuspended) 
    //{
    //    pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_ACCTSUSPENDED;
    //    pPolicyData->bUserAccountSuspended = TRUE;
    //    pPolicyData->ftUserAccountResumeDate[dwUserIndex] = pxkdcDbUserData->AccountResumeDate;

    //    if (pServiceRequest->bAllowServiceAddressFailed == TRUE)
    //    {
    //        // We don't return a valid ticket anymore in this situation!
    //        pPolicyData->bContinueChecks     = FALSE;
    //        pPolicyData->hrUser[dwUserIndex] = XONLINE_E_ACCOUNTS_ACCOUNT_BANNED;
    //    }
    //    else
    //    {
    //        pPolicyData->hrUser[dwUserIndex] = XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
    //        pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_REQUIRESMAINTENANCE;

    //        // Remember that we need to strip out this user's privileges. We always do it
    //        // for banned users even though we would return REQUIRES_MANAGEMENT
    //        bUserRemovePrivileges = TRUE;
    //    }

    //    XomTrace(Policy, L_HIGH, "GetUserAuthorization: user account banned.");
    //}
    //else if (pxkdcDbUserData->InvalidUserPassport || 
    //         pxkdcDbUserData->InvalidOwnerPassport) 
    //{
    //    //
    //    // We consider the user's need for to have a new WLID to
    //    // be more important than the fact that they might not
    //    // be trusted on this machine
    //    // 
    //    if ( pxkdcDbUserData->InvalidUserPassport )
    //    {
    //        pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_INVALIDUSERPASSPORT;
    //    }

    //    if ( pxkdcDbUserData->InvalidOwnerPassport )
    //    {
    //        pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_INVALIDOWNERPASSPORT;
    //    }

    //    pPolicyData->hrUser[dwUserIndex] = XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
    //    pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_REQUIRESMAINTENANCE;

    //    // Remember that we need to strip out this user's privileges
    //    if (pXkdc->GetRemoveUserPrivilegesOnRequiresManagement() == TRUE) 
    //    {
    //        bUserRemovePrivileges = TRUE;
    //    }

    //    XomTrace(
    //        Policy, 
    //        L_NORMAL, 
    //        "GetUserAuthorization: user account requires management: InvalidUserPassport=%d, InvalidOwnerPassport=%d.",
    //        pxkdcDbUserData->InvalidUserPassport,
    //        pxkdcDbUserData->InvalidOwnerPassport
    //        );

    //}
    //else if (bUserTrustUnknown == TRUE) 
    //{
    //    //
    //    // We consider the user's trust level to be less severe than being a banned
    //    // user account, but more severe than one that needs management
    //    // 
    //    pPolicyData->hrUser[dwUserIndex] = XONLINE_E_LOGON_USER_UNKNOWN_TRUST;

    //    XomTrace( Policy,  L_NORMAL,  "GetUserAuthorization: user account unknown trust");
    //}
    //else if (!pxkdcDbUserData->AcceptedTOS            || 
    //         pxkdcDbUserData->BillingAcctStatusFailed || 
    //         pxkdcDbUserData->NameChangeRequired)
    //{
    //    // Process authorization data and funnel from intermediate db/cache representation to
    //    // what we need for this request.

    //    if ( pxkdcDbUserData->AcceptedTOS == 0 )
    //    {
    //        pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_ACCEPTEDTOS;
    //    }

    //    if ( pxkdcDbUserData->BillingAcctStatusFailed)
    //    {
    //        pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_BILLINGFAILED;
    //    }

    //    if ( pxkdcDbUserData->NameChangeRequired )
    //    {
    //        pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_NAMECHANGEREQ;
    //    }

    //    pPolicyData->hrUser[dwUserIndex] = XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
    //    pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_REQUIRESMAINTENANCE;

    //    // Remember that we need to strip out this user's privileges
    //    if (pXkdc->GetRemoveUserPrivilegesOnRequiresManagement() == TRUE) 
    //    {
    //        bUserRemovePrivileges = TRUE;
    //    }

    //    XomTrace(
    //        Policy, 
    //        L_NORMAL, 
    //        "GetUserAuthorization: user account requires management: AcceptedTOS=%d, NameChangeRequired=%d, BillingAcctStatusFailed=%d.",
    //        pxkdcDbUserData->AcceptedTOS,
    //        pxkdcDbUserData->NameChangeRequired,
    //        pxkdcDbUserData->BillingAcctStatusFailed
    //        );
    //} 

    //if ( pxkdcDbUserData->VoiceBanned )
    //{
    //    pLogData->m_dwUserStatus[dwUserIndex] |= XKDC_USERSTATUS_VOICEBAN;
    //    XomTrace( Policy,  L_NORMAL,  "GetUserAuthorization: user account voice banned");
    //}

    ////
    //// If we should strip out the user's privileges, then do so now
    //// 
    //if (bUserRemovePrivileges == TRUE) 
    //{
    //    for (i = XONLINE_FIRST_USER_PRIVILEGE_DWORD_INDEX; 
    //         i < XONLINE_NUM_PRIVILEGE_DWORDS; 
    //         i++)
    //    {
    //        pxkdcDbUserData->Privileges[i] = 0;
    //    }
    //}

    ////
    //// Move over all privileges. OR them in, to maintain previous behavior of setting
    //// individual privileges.
    ////
    //for (i = 0; i < XONLINE_NUM_PRIVILEGE_DWORDS; i++)
    //{
    //    pServiceAddress->dwUserPrivileges[dwUserIndex][i] |= pxkdcDbUserData->Privileges[i];
    //}

//Cleanup:

    return STATUS_SUCCESS;
}


//-------------------------------------------------------------------------
NTSTATUS PolicyCheckTitleID(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData
)
{
    //UNREFERENCED_PARAMETER( piPacSect );
    //XOMASSERT( pXkdc );
    //XOMASSERT( pServiceRequest );
    //XOMASSERT( pPolicyData );
    //XOMASSERT( pPolicyData && pPolicyData->bContinueChecks );

    //// validate all parameters
    //if ( NULL == pXkdc ||
    //     NULL == piPacSect ||
    //     NULL == pServiceRequest ||
    //     NULL == pServiceAddress ||
    //     NULL == pPolicyData )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_12, "(%s:%d) PolicyCheckTitleID: invalid parameter.", __FILE__, __LINE__);
    //    return STATUS_INVALID_PARAMETER;
    //}

    //NTSTATUS status = STATUS_SUCCESS;
    //const TITLE_VERSION *pTitleInfo = NULL;
    //const TITLE_VERSION *pFlashInfo = NULL;
    //HRESULT hrUpdate = S_OK;
    //GUID emptyGuid = {0};
    //IPAXboxLogData* piXboxLog = NULL;
    //XKDC_LOGGINGDATA* pLogData = NULL;

    //status = piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog);
    //if ( !NT_SUCCESS(status) || NULL == piXboxLog )
    //{
    //    XomNtEvent(XEVENT_KDC_CODE_195, "(%s:%d) PolicyCheckTitleID: no IID_IPAXboxLogData interface found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    //// get the log data
    //status = piXboxLog->GetLogData( &pLogData );
    //if ( !NT_SUCCESS(status) || NULL == pLogData )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_15, "(%s:%d) PolicyCheckTitleID: no Log Data found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    //// For each of the groups the machine is in, see if that machine
    //// can get a special version of that title ID.  A machine can only
    //// be in one group, so we're iterating here, and if we don't find
    //// anything, we'll go as if they weren't in a group at all.
    //const TITLE_VERSION *pTempTitleInfo = NULL;
    //for(unsigned int i = 0; (i < pPolicyData->pXkdcDbData->MachineData.NumMachineGroups); i++)
    //{
    //    // verify title id and check version for updates
    //    pTempTitleInfo = pXkdc->GetTitleInfo(
    //        pServiceRequest->dwTitleID,
    //        pPolicyData->dwPlatformType,
    //        pServiceRequest->dwTitleRegion,
    //        pServiceRequest->dwMediaID,
    //        pServiceRequest->dwTitleVersion,
    //        pPolicyData->pXkdcDbData->MachineData.MachineGroups[i]);

    //    // Keep going through all of them and make sure there aren't two working possibilities.
    //    // If there are, pretend they're not in a group.  If there's no row, then you are just SOL
    //    // and can't log in.  The management tool will add these rows, but there's the possibility
    //    // we want to configure a title beta to not allow people currently in the group to log
    //    // in.  This will really stick it to them.  Splante should agree.
    //    if(pTempTitleInfo)
    //    {
    //        if(pTitleInfo)
    //        {
    //            XomNtEvent(XEVENT_XKDC_TITLE_MULTIPLE_GROUPS,
    //                    "(%s:%d) PolicyCheckTitleID: Machine 0x%016I64X is in multiple beta groups for title 0x%08x title version 0x%08x.",
    //                    __FILE__,
    //                    __LINE__,
    //                    pPolicyData->qwXboxID,
    //                    pServiceRequest->dwTitleID,
    //                    pServiceRequest->dwTitleVersion);

    //            pTitleInfo = NULL;
    //            break;
    //        }

    //        pTitleInfo = pTempTitleInfo;
    //    }
    //}

    //// If none of that worked, try without a group.
    //if(!pTitleInfo)
    //{
    //    pTitleInfo = pXkdc->GetTitleInfo(
    //        pServiceRequest->dwTitleID,
    //        pPolicyData->dwPlatformType,
    //        pServiceRequest->dwTitleRegion,
    //        pServiceRequest->dwMediaID,
    //        pServiceRequest->dwTitleVersion,
    //        emptyGuid);
    //}

    //if(!pTitleInfo && pPolicyData->dwPlatformType == XPLT_XBOX360)
    //{
    //    // Hack to minimize impact of platform enforcement in test environments. My guess
    //    // is that a lot of test titles are currently being shared between Xbox and Xbox
    //    // 360.  If we can't find title-info for Xbox 360, try again for the Xbox 1. I'd
    //    // like to remove this hack before we ship but worst case scenario it won't be
    //    // worse than it was before - and we still prevent Pcs from joining the mess.
    //    pTitleInfo = pXkdc->GetTitleInfo(
    //        pServiceRequest->dwTitleID,
    //        XPLT_XBOX1,
    //        pServiceRequest->dwTitleRegion,
    //        pServiceRequest->dwMediaID,
    //        pServiceRequest->dwTitleVersion,
    //        emptyGuid);

    //    if(pTitleInfo)
    //    {
    //        // Add a bit to the log so that we can mine all these bad title ids (or
    //        // hack attempts)

    //        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_TITLE_PLATFORM_FALLBACK;
    //    }
    //}

    //if ( NULL == pTitleInfo )
    //{
    //    // in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

    //    // The title id or version is unknown, return UNKOWN_TITLE (sic) and
    //    // don't continue policy checks and allow services to be granted in
    //    // the ticket.
    //    pServiceAddress->hr = XONLINE_E_LOGON_UNKNOWN_TITLE;

    //    pPolicyData->bContinueChecks = FALSE;

    //    // log an error, this could be an attempted hack but is probably
    //    // just UODB not being updated with a new title
    //    //
    //    // We decide to *not* log an event here, based on the Xbox 360 Console Software issue 21874.
    //    // Evidently this is ginormous (it's a word--http://www.merriam-webster.com/dictionary/ginormous)
    //    // amount of spam in the event log.

    //    XomTrace(Policy, L_WARNING,
    //        "PolicyCheckTitleID: TitleID=0x%08X TitleRegion=0x%08X TitleVersion=0x%08X MediaID=%08X PlatForm=%08X - Not Found",
    //        pServiceRequest->dwTitleID,
    //        pServiceRequest->dwTitleRegion,
    //        pServiceRequest->dwTitleVersion,
    //        pServiceRequest->dwMediaID,
    //        pPolicyData->dwPlatformType);

    //    goto Cleanup;
    //}

    //// Enforce the flashVersion and clientVersion fields match for Xbox360 and PC
    //// platforms. The enforcement of this check can be disabled.
    //DWORD dwFlashVer = pServiceRequest->dwFlashVersion;
    //DWORD dwClientVer = CLIENTVERSION_TO_DWORD(pServiceRequest->clientVersion);

    //if (dwFlashVer != dwClientVer)
    //{
    //    WCHAR wszClientVersion[16];
    //    WCHAR wszFlashVersion[16];
    //    XboxClientVersionDwordToWCHARString(dwClientVer, wszClientVersion, ARRAYSIZE(wszClientVersion), FALSE);
    //    XboxClientVersionDwordToWCHARString(dwFlashVer,  wszFlashVersion,  ARRAYSIZE(wszFlashVersion), FALSE);

    //    XomTrace(Policy, L_WARNING,
    //        "PolicyCheckTitleID: Flash ver %S (0x%08X) mismatches client ver %S for MachineID=0x%016I64X, TitleID=0x%08X",
    //        wszFlashVersion,
    //        dwFlashVer,
    //        wszClientVersion,
    //        pPolicyData->qwXboxID,
    //        pServiceRequest->dwTitleID);

    //    if (pXkdc->GetEnforceClientVersion())
    //    {
    //        in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
    //        XomNtEvent(XEVENT_XKDC_MISMATCHED_CLIENT_VERSION,
    //            "PolicyCheckTitleID: Flash version %S (0x%08X) mismatches client "
    //            "version build number %S. Please investigate "
    //            "the client version history of this machine by looking at recent "
    //            "XKDC logs. This should be escalated to the Live Security team. "
    //            "MachineID=0x%016I64X, TitleID=0x%08X, ip=%s.",
    //            wszFlashVersion,
    //            dwFlashVer,
    //            wszClientVersion,
    //            pPolicyData->qwXboxID,
    //            pServiceRequest->dwTitleID,
    //            inet_ntoa(*pInAddr));

    //        // There's a question of what, exactly, to return here. By returning
    //        // nothing (don't set hr), the client seems to interpret it as
    //        // XONLINE_E_LOGON_AUTHENTICATION_FAILED and it says something about being
    //        // unable to sign the profile in. We need to return a KerbErr in order to
    //        // get something logged to the XKDC REQ log line. We also set a bit in the
    //        // reqstatus indicating this. Seems pretty good to me.
    //        //pServiceAddress->hr = XONLINE_E_LOGON_UNKNOWN_TITLE;
    //        pPolicyData->KerbErr = KDC_ERR_SVC_UNAVAILABLE;
    //        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_MISMATCHED_CLIENT_VERSION;
    //        pPolicyData->bContinueChecks = FALSE;
    //        status = STATUS_INTERNAL_ERROR;
    //        goto Cleanup;
    //    }
    //}

    //// TODO: Change this logic below for the versioning to let them log on or force an update

    //// TODO: re-enable this assert once all title versions are known and
    //// captured in UODB.  Currently, versions of 0 may be returned by
    //// GetTitleInfo in cases where versions aren't known.
    ///* XOMASSERT( pServiceRequest->dwTitleVersion == pTitleInfo->dwBaseVersion ); */

    //XomTrace(Policy, L_LOW, "Title Version Check: ");
    //if( pTitleInfo->dwBaseVersion != pTitleInfo->dwUpdateVersion )
    //{
    //    hrUpdate = XONLINE_E_LOGON_UPDATE_REQUIRED;
    //    XomTrace(Policy, L_NORMAL,
    //        "Title Update required. MachineID=0x%016I64X, TitleID=0x%08x, BaseVersion=0x%08x, UpdateVersion=0x%08x",
    //        pPolicyData->qwXboxID,
    //        pServiceRequest->dwTitleID,
    //        pTitleInfo->dwBaseVersion,
    //        pTitleInfo->dwUpdateVersion);
    //}

    //if(pPolicyData->pXkdcDbData->MachineData.NumMachineGroups > 0)
    //{
    //    pPolicyData->dwAuthDataFlags |= XONLINE_AUTHDATA_FLAGS_ISBETAMACHINE;
    //}

    //// Xbox 360 consoles and PCs must also have the system version

    //// System version is also tracked in uodb..t_title_versions using a special
    //// hardcoded title-id. Each platform has a system title-id to track its
    //// versioning path.

    //DWORD systemTitleId = (pPolicyData->dwPlatformType == XPLT_XBOX360) ?
    //    XONLINE_XENON_DASH_TITLE_ID : XONLINE_PC_DASH_TITLE_ID;



    //// For each of the groups the machine is in, see if that machine
    //// can get a special version of that title ID.  A machine can only
    //// be in one group, so we're iterating here, and if we don't find
    //// anything, we'll go as if they weren't in a group at all.
    //const TITLE_VERSION *pTempFlashInfo = NULL;
    //for(unsigned int i = 0; (i < pPolicyData->pXkdcDbData->MachineData.NumMachineGroups); i++)
    //{
    //    pTempFlashInfo = pXkdc->GetTitleInfo(
    //        systemTitleId,
    //        pPolicyData->dwPlatformType,
    //        0,
    //        0,
    //        pServiceRequest->dwFlashVersion,
    //        pPolicyData->pXkdcDbData->MachineData.MachineGroups[i]);

    //    // Keep going through all of them and make sure there aren't two working possibilities.
    //    // If there are, then we make them not in any group.  If there's not a line in t_title_versions
    //    // at this point for the null group (which should be there), you're just SOL.  Should probably
    //    // event this.
    //    if(pTempFlashInfo)
    //    {
    //        if(pFlashInfo)
    //        {
    //            XomNtEvent(XEVENT_XKDC_FLASH_MULTIPLE_GROUPS,
    //                    "(%s:%d) PolicyCheckTitleID: Machine 0x%016I64X is in multiple beta groups for flash base version 0x%08x.",
    //                    __FILE__,
    //                    __LINE__,
    //                    pPolicyData->qwXboxID,
    //                    pServiceRequest->dwFlashVersion);

    //            pFlashInfo = NULL;
    //            break;
    //        }

    //        pFlashInfo = pTempFlashInfo;
    //    }
    //}

    //if(!pFlashInfo)
    //{
    //    // Not in any flash beta groups, attempt with no group.
    //    pFlashInfo = pXkdc->GetTitleInfo(
    //        systemTitleId,
    //        pPolicyData->dwPlatformType,
    //        0,
    //        0,
    //        pServiceRequest->dwFlashVersion,
    //        emptyGuid);
    //}



    //if(!pFlashInfo)
    //{
    //    XomNtEvent(XEVENT_KDC_CONFIG_39,
    //                "System title id 0x%08x was not configured for base version 0x%08x",
    //                systemTitleId,
    //                pServiceRequest->dwFlashVersion);

    //    status = STATUS_INTERNAL_ERROR;
    //    goto Cleanup;
    //}

    //if(pFlashInfo->dwBaseVersion != pFlashInfo->dwUpdateVersion)
    //{
    //    hrUpdate = XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED;
    //    XomTrace(Policy, L_NORMAL,
    //              "Flash Update required. MachineID=0x%016I64X, BaseVersion=0x%08x, UpdateVersion=0x%08x",
    //              pPolicyData->qwXboxID,
    //              pFlashInfo->dwBaseVersion,
    //              pFlashInfo->dwUpdateVersion);
    //}

    //// If there is an update available for this title id and version, indicate
    //// that an update is required. See if the auto-update service is requested; if so,
    //// don't return an error since this is is how the title resolves this error.
    //if (FAILED(hrUpdate))
    //{
    //    if (!pServiceRequest->wAutoDiscoverServices)
    //    {
    //        // Xbox360, PC, and future...

    //        DWORD dwAutoUpdate = 0;
    //        for (DWORD i=0; i<pServiceRequest->dwNumServices; i++)
    //        {
    //            if (XONLINE_AUTO_UPDATE_SERVICE == pServiceRequest->dwServiceID[i])
    //            {
    //                dwAutoUpdate = 1;
    //            }
    //            else if (XONLINE_DRM_SERVICE != pServiceRequest->dwServiceID[i] &&
    //                     XONLINE_LIVEINFO_SERVICE != pServiceRequest->dwServiceID[i])
    //            {
    //                // Force to ask only for the autoupdate service
    //                dwAutoUpdate = 2;
    //                break;
    //            }
    //        }

    //        if (1 == dwAutoUpdate)
    //        {
    //            // Allow this to passthrough only if auto-update was the only service
    //            // requested (save the drm and liveinfo services)
    //            hrUpdate = S_OK;
    //            pPolicyData->bMachineOnly = TRUE;
    //        }
    //    }

    //    // if the auto update service wasn't requested, 
    //    if ( FAILED(hrUpdate) )
    //    {
    //        XOMASSERT( FALSE == pPolicyData->bMachineOnly );

    //        pServiceAddress->hr = hrUpdate;

    //        pPolicyData->bContinueChecks = FALSE;
    //        XomTrace(Policy, L_NORMAL, "PolicyCheckTitleID: client requires update");
    //    }
    //}

    //pServiceAddress->dwLiveTitleId = pTitleInfo->dwLiveTitleId;

    //C_ASSERT(ARRAYSIZE(pTitleInfo->aAltLiveTitleIds) == XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID);
    //C_ASSERT(ARRAYSIZE(pServiceAddress->altLiveTitleIds) == XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID);
    //for(int i=0; i < XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID; i++)
    //{
    //    pServiceAddress->altLiveTitleIds[i].bServiceID   = (BYTE) pTitleInfo->aAltLiveTitleIds[i].dwServiceId;
    //    pServiceAddress->altLiveTitleIds[i].dwAltTitleID = pTitleInfo->aAltLiveTitleIds[i].dwTitleId;
    //}

    //// Pass the live title-id in the title id field of the authdata. As far as
    //// the services are concerned, this is THE title-id. For old xbox titles,
    //// title-id == live-title-id

    //pPolicyData->dwTitleID = pServiceAddress->dwLiveTitleId;
    //pPolicyData->dwTitleVersion = pServiceRequest->dwTitleVersion;
    //pPolicyData->dwTitleRegion = pServiceRequest->dwTitleRegion;
    //pPolicyData->dwConsoleRegion = pServiceRequest->dwConsoleRegion;
    //pPolicyData->dwMediaID = pServiceRequest->dwMediaID;
    //pPolicyData->wLanguageID = pServiceRequest->wLanguageID;

    //DWORD dwX = 0;

    //// In Xenon, the first title-id in the alternate-title-id array is the
    //// game's real title id (as opposed to the live-title-id)
    //pPolicyData->dwAltTitleID[0] = pServiceRequest->dwTitleID;

    //// The remaining slots will contain up to 3 of the alternate service
    //// title ids

    //for ( dwX = 1; dwX < XONLINE_MAX_ALTERNATE_TITLE_ID; dwX++ )
    //{
    //    pPolicyData->dwAltTitleID[dwX] = pServiceAddress->altLiveTitleIds[dwX-1].dwAltTitleID;
    //}

    XomTrace(Policy, L_NORMAL, "PolicyCheckTitleID: title id 0x%08X, version %d is valid.", pServiceRequest->dwTitleID, pServiceRequest->dwTitleVersion);

 //Cleanup:
    return STATUS_SUCCESS;
}


// Looks through a bunch of service results and does one event (if necessary) about all the bad ones.
static void EventForUnknownServices(XKERB_PA_XENON_SERVICE_RESULT const * const pServiceResults, size_t const cServiceResults, ULONGLONG const qwXboxID, in_addr const * const pInAddr)
{
    // I've done some calculations, and this seems large enough even if all requested services were bad.
    char szServiceResults[512] = {0};
    char* pszCur = szServiceResults;
    size_t cchRemaining = _countof(szServiceResults);
    UINT cBadServices = 0;

    StringCchCatExA(pszCur, cchRemaining, "{ ", &pszCur, &cchRemaining, STRSAFE_FILL_BEHIND_NULL);
    for (UINT idx = 0; idx < cServiceResults && pServiceResults[idx].dwServiceID != 0; ++idx)
    {
        if (pServiceResults[idx].bResult == XENON_SERVICE_STATUS_NOT_AUTHORIZED)
        {
            ++cBadServices;
            StringCchPrintfExA(pszCur, cchRemaining, &pszCur, &cchRemaining, STRSAFE_FILL_BEHIND_NULL, "%d ", pServiceResults[idx].dwServiceID);
        }
    }
    StringCchCatExA(pszCur, cchRemaining, " }", &pszCur, &cchRemaining, STRSAFE_FILL_BEHIND_NULL);

    XomNtEvent(XEVENT_KDC_CONFIG_40,
            "PolicyCheckServices: %d service ids %s unknown, returning XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED in request from machine account: 0x%016I64X client %s.",
            cBadServices,
            szServiceResults,
            qwXboxID,
            inet_ntoa(*pInAddr));
}


NTSTATUS PolicyCheckServices(
    IN CXkdcProvider *pXkdc,
    IN IKerbRequest *piReq,
    IN IADPacSection *piPacSect,
    IN XKDC_PA_SERVICE_REQUEST *pServiceRequest,
    OUT XKDC_PA_SERVICE_ADDRESS *pServiceAddress,
    OUT XKDC_POLICY_DATA *pPolicyData
)
{
    //UNREFERENCED_PARAMETER( piPacSect );
    //XOMASSERT( pXkdc );
    //XOMASSERT( pServiceRequest );
    //XOMASSERT( pServiceAddress );
    //XOMASSERT( pPolicyData );
    //XOMASSERT( pPolicyData && pPolicyData->bContinueChecks);
    //XOMASSERT( pPolicyData->pXkdcDbData);

    //XKDC_LOGGINGDATA *pLogData = NULL;
    //IPAXboxRequest *piXboxReq = NULL;
    //IPAXboxLogData *piXboxLog = NULL;
    //NTSTATUS status = STATUS_SUCCESS;
    //CXkdcPrincipal *pSitePrinc = NULL;
    //XKERB_PA_XENON_SERVICE_RESULT ServiceResult[XONLINE_XE_MAX_BYTE_SERVICEIDS_2 + XONLINE_MAX_DWORD_SERVICEIDS] = {0};
    //BOOL bAnyBadServices = FALSE;
    //DWORD dwNumAuthorizedServices = 0;
    //DWORD i = 0;
    //DWORD dwX = 0;

    //BOOL bValidUsers = FALSE;

    //// validate all parameters
    //if ( NULL == pXkdc ||
    //     NULL == piPacSect ||
    //     NULL == pServiceRequest ||
    //     NULL == pServiceAddress ||
    //     NULL == pPolicyData )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_13, "(%s:%d) PolicyCheckServices: invalid parameter.", __FILE__, __LINE__);
    //    return STATUS_INVALID_PARAMETER;
    //}

    //XOMASSERT(pServiceRequest->dwNumServices <= _countof(ServiceResult));

    //// get the Xkdc-specific interface from the preauth handler
    //status = piReq->GetPAHandler(IID_IPAXboxRequest, (PVOID*)&piXboxReq);
    //if ( !NT_SUCCESS(status) || NULL == piXboxReq )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_14, "(%s:%d) PolicyCheckServices: no IID_IPAXboxRequest interface found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    //// get the Xkdc log interface from the preauth handler
    //status = piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog);
    //if ( !NT_SUCCESS(status) || NULL == piXboxLog )
    //{
    //    XomNtEvent(XEVENT_KDC_CODE_195, "(%s:%d) PolicyCheckServices: no IID_IPAXboxLogData interface found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    //// get the log data
    //status = piXboxLog->GetLogData( &pLogData );
    //if ( !NT_SUCCESS(status) || NULL == pLogData )
    //{
    //    XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_15, "(%s:%d) PolicyCheckServices: no Log Data found.", __FILE__, __LINE__);
    //    status = STATUS_INVALID_PARAMETER;
    //    goto Cleanup;
    //}

    //// machine account must be valid to return services
    //XOMASSERT( S_OK == pServiceAddress->hr );
    //if ( pServiceAddress->hr != S_OK )
    //{
    //    status = STATUS_INVALID_PARAMETER;
    //    pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
    //    goto Cleanup;
    //}


    //// We only grant user services in the following conditions:
    //// 1. response has not been explicitly tagged "machine only" (autoupdate)
    //// 2. there is at least 1 user in the request
    //// 3. all users in response have an S_OK hr.
    //// 4. all users have subscriptions to all services.
    //// We enforce 1, 2, and 3 here. 4 is a bit later.
    //if (!pPolicyData->bMachineOnly && pPolicyData->dwUsers > 0)
    //{
    //    bValidUsers = TRUE;
    //    for (DWORD u=0; u < XONLINE_MAX_LOGON_USERS; u++)
    //    {
    //        if ( 0 == pPolicyData->users[i].qwUserID)
    //            continue;
    //        if ( pPolicyData->hrUser[u] != S_OK )
    //        {
    //            bValidUsers = FALSE;
    //            break;
    //        }
    //    }

    //    // If we're only going to authorize machine services (bValidUsers is false), then
    //    // let's set bMachineOnly to true for reporting purposes. The perf counters in
    //    // xkdcauthdata.cpp will use this info.
    //    if (!bValidUsers)
    //    {
    //        pPolicyData->bMachineOnly = TRUE;
    //    }
    //}

    //// fill in the containing structure
    //pServiceAddress->dwNumServices = 0;

    //for (i=0; i<pServiceRequest->dwNumServices; i++)
    //{
    //    INT     iSvcID               = pServiceRequest->dwServiceID[i];
    //    DWORD   dwNumUsersSubscribed = pPolicyData->pXkdcDbData->GetNumSubscriptionsToService(iSvcID);
    //    BOOL    fIsServiceAuthorized = (pPolicyData->dwUsers == dwNumUsersSubscribed);
    //    DWORD   dwTitleID            = pServiceRequest->dwTitleID;
    //    DWORD   dwTitleVersion       = pServiceRequest->dwTitleVersion;
    //    DWORD   dwTitleRegion        = pServiceRequest->dwTitleRegion;
    //    CXkdcPrincipal *p            = pXkdc->GetServicePrincipal(iSvcID, dwTitleID, dwTitleVersion, dwTitleRegion);

    //    ServiceResult[i].dwServiceID = iSvcID;

    //    // if we know nothing about the service, mark it as failed
    //    if ( NULL == p )
    //    {
    //        // Treat unrecognized service as if it was not authorized.
    //        ServiceResult[i].bResult = XENON_SERVICE_STATUS_NOT_AUTHORIZED;
    //        bAnyBadServices = TRUE;
    //        continue;
    //    }
    //    XOMASSERT( p );
    //    XOMASSERT( iSvcID == p->GetServiceID() );

    //    // use the site of the first service found as the site for the ticket
    //    if ( NULL == pSitePrinc )
    //    {
    //        pSitePrinc = p;
    //    }

    //    // if this service belongs to the site that is being used for the
    //    // ticket, mark it as ok and increment the number of services
    //    if ( p == pSitePrinc || pXkdc->GetKdcCore()->pfnKerbEqualKdcNames( p->GetCanonicalName(), pSitePrinc->GetCanonicalName() ) )
    //    {
    //        if ( 0 == p->IsServiceAvailable() )
    //        {
    //            ServiceResult[i].bResult = XENON_SERVICE_STATUS_UNAVAILABLE;
    //            XomTrace(Policy, L_NORMAL, "PolicyCheckServices: service id %d temporarily unavailable.", iSvcID);
    //        }
    //        else if ( !p->IsMachineOnly() && !fIsServiceAuthorized)
    //        {
    //            ServiceResult[i].bResult = XENON_SERVICE_STATUS_NOT_AUTHORIZED;
    //            XomTrace(Policy, L_NORMAL, "PolicyCheckServices: service id %d not authorized", iSvcID);
    //        }
    //        else if ( bValidUsers || p->IsMachineOnly() || ( pPolicyData->bUserRequiresMaintenance && XONLINE_USER_ACCOUNT_SERVICE == iSvcID ) )
    //        {
    //            if (pPolicyData->bUserAccountSuspended && iSvcID == XONLINE_STATISTICS_SERVICE)
    //            {
    //                ServiceResult[i].bResult = XENON_SERVICE_STATUS_NOT_AUTHORIZED;
    //                XomTrace(Policy, L_NORMAL, "PolicyCheckServices: service id %d not authorized because a user account is suspended", iSvcID);
    //            }
    //            else
    //            {
    //                // if there aren't valid users, only mark the service OK if it
    //                // is a machine-only service
    //                ServiceResult[i].bResult = XENON_SERVICE_STATUS_SUCCESS;
    //                ServiceResult[i].wServicePort = p->GetServicePort();
    //                dwNumAuthorizedServices++;
    //                if ( pPolicyData->bUserRequiresMaintenance )
    //                {
    //                    XomTrace(Policy, L_NORMAL, "PolicyCheckServices: user account requires management, service id %d authorized", iSvcID);
    //                }
    //                else
    //                {
    //                    XomTrace(Policy, L_LOW, "PolicyCheckServices: service id %d authorized", iSvcID);
    //                }
    //            }
    //        }
    //        else
    //        {
    //            ServiceResult[i].bResult = XENON_SERVICE_STATUS_NOT_AUTHORIZED;
    //            XomTrace(Policy, L_LOW, "PolicyCheckServices: service id %d not authorized", iSvcID);
    //        }
    //    }
    //    else
    //    {
    //        // this service is known but not provided by the site associated
    //        // with the ticket so mark it with S_FALSE
    //        ServiceResult[i].bResult = XENON_SERVICE_STATUS_OTHER_SITE;
    //        XomTrace(Policy, L_LOW, "PolicyCheckServices: service id %d not provided by site.", iSvcID);
    //    }
    //}

    //if (bAnyBadServices)
    //{
    //    EventForUnknownServices(ServiceResult, _countof(ServiceResult), pPolicyData->qwXboxID, &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr));
    //}

    ////
    //// Determine whether we're supposed to fill out the V2 (legacy) auth-data structure.
    //// Before this change, both auth-data structs were being filled out at the same time.
    //// However, the V2 struct has less slots for services than the current V3 struct.
    ////

    //BOOL fFillOutV2AuthData = (pSitePrinc != NULL && pSitePrinc->GetAuthdataVersion() == XONLINE_AUTHDATA_VERSION);

    ////
    //// Copy results to pServiceAddress
    ////
    //DWORD dwByteSvc = 0;
    //DWORD dwDwordSvc = 0;

    //pPolicyData->wXboxNumPrivileges = 0;
    //pPolicyData->wXenonNumPrivileges = 0;
    //pPolicyData->wXenonNumDwordServices = 0;

    //for (i=0; i < pServiceRequest->dwNumServices; i++)
    //{
    //    pServiceAddress->ServiceResult[i] = ServiceResult[i];
    //    if ( pServiceAddress->ServiceResult[i].dwServiceID < XONLINE_MAX_PRIVILEGE_ID )
    //    {
    //        dwByteSvc++;
    //    }
    //    else
    //    {
    //        dwDwordSvc++;
    //    }

    //    // inc the number of services in the svcaddr.
    //    pServiceAddress->dwNumServices++;

    //    if ( ServiceResult[i].bResult != XENON_SERVICE_STATUS_SUCCESS &&
    //         ServiceResult[i].bResult != XENON_SERVICE_STATUS_OTHER_SITE)
    //    {
    //        XomTrace(Policy, L_LOW, "PolicyCheckServices: adding unauthorized service %d to return preauth, bResult = 0x%02X.", ServiceResult[i].dwServiceID, ServiceResult[i].bResult);
    //        continue;
    //    }

    //    if ( ServiceResult[i].bResult == XENON_SERVICE_STATUS_SUCCESS )
    //    {
    //        XomTrace(Policy, L_LOW, "PolicyCheckServices: adding authorized service %d to return preauth.", ServiceResult[i].dwServiceID);

    //        // add this service to the ticket... it's available at this site.
    //        // Unlike the returned preauth data,
    //        // the authdata only contains info about services that have been
    //        // authorized.

    //        if (fFillOutV2AuthData)
    //        {
    //            if(pPolicyData->dwXboxNumServices >= ARRAYSIZE(pPolicyData->dwXboxServiceID))
    //            {
    //                XomNtEvent(XEVENT_XKDC_CODE_TOO_MANY_DWORD_SERVICES, "PolicyCheckServices: Too many services for Xbox Auth-data");
    //                status = STATUS_INTERNAL_ERROR;
    //                pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
    //                goto Cleanup;
    //            }

    //            pPolicyData->dwXboxServiceID[pPolicyData->dwXboxNumServices] = ServiceResult[i].dwServiceID;
    //            pPolicyData->dwXboxNumServices++;
    //        }

    //        if ( ServiceResult[i].dwServiceID < XONLINE_MAX_PRIVILEGE_ID )
    //        {
    //            // mark this service as authorized in the authdata
    //            SetPrivilege(
    //                pPolicyData->dwXenonPrivileges,
    //                ServiceResult[i].dwServiceID,
    //                TRUE
    //                );

    //            // mark this service as authorized for each valid user
    //            for (DWORD u=0; u < XONLINE_MAX_LOGON_USERS; u++)
    //            {
    //                if ( 0 != pServiceRequest->qwUserID[u] )
    //                {
    //                    SetPrivilege(
    //                        pPolicyData->dwXenon2UserPrivileges[u],
    //                        ServiceResult[i].dwServiceID,
    //                        TRUE
    //                        );
    //                    SetPrivilege(
    //                        pServiceAddress->dwUserPrivileges[u],
    //                        ServiceResult[i].dwServiceID,
    //                        TRUE
    //                        );
    //                }
    //            }

    //            pPolicyData->wXenonNumPrivileges++;
    //        }
    //        else
    //        {
    //            if (pPolicyData->wXenonNumDwordServices >= ARRAYSIZE(pPolicyData->dwXenonServiceID))
    //            {
    //                XomNtEvent(XEVENT_XKDC_CODE_TOO_MANY_DWORD_SERVICES, "PolicyCheckServices: Too many DWORD services for Xenon Auth-data");
    //                status = STATUS_INTERNAL_ERROR;
    //                pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
    //                goto Cleanup;
    //            }

    //            pPolicyData->dwXenonServiceID[pPolicyData->wXenonNumDwordServices] = ServiceResult[i].dwServiceID;
    //            pPolicyData->wXenonNumDwordServices++;
    //        }

    //        XomTrace(Policy, L_LOW, "PolicyCheckServices: adding authorized service %u to ticket.", ServiceResult[i].dwServiceID);
    //        continue;
    //    }

    //    // this service is not at this site... we don't want to add it to the ticket.
    //    XOMASSERT( ServiceResult[i].bResult == XENON_SERVICE_STATUS_OTHER_SITE );
    //    XomTrace(Policy, L_LOW, "PolicyCheckServices: adding deferred service %d to return preauth.", ServiceResult[i].dwServiceID);
    //}

    //if ( pPolicyData->dwUsers > 0 )
    //{
    //    for (DWORD i=0; i < XONLINE_NUM_PRIVILEGE_DWORDS; i++)
    //    {
    //        DWORD mask = 0xFFFFFFFF;
    //        for (DWORD u=0; u < XONLINE_MAX_LOGON_USERS; u++)
    //        {
    //            if ( 0 == pServiceRequest->qwUserID[u] )
    //                continue;

    //            mask = mask & pServiceAddress->dwUserPrivileges[u][i];

    //            // Be preprared to hand back the per-user privilege
    //            pPolicyData->dwXenon2UserPrivileges[u][i] =
    //                pServiceAddress->dwUserPrivileges[u][i];
    //        }

    //        // Set the CAuthData3 version
    //        pPolicyData->dwXenonPrivileges[i] = mask;
    //    }
    //}

    //// At this point, pSitePrinc may be null if the client requested only unknown
    //// services. dwNumAuthorizedServices will be 0 in this case.

    //// Format list of services granted in the auth-data as a string. Only include
    //// privileges for site 1, since they will be identical for other sites and they bloat
    //// the logfiles considerably. We unfortunately don't have a numeric site-id at this
    //// point.

    //{
    //    // if all services are invalid (pSitePrinc is NULL), go ahead and log the
    //    // privileges as if it is site1.
    //    BOOL fIsSite1 = pSitePrinc ? pXkdc->IsPrincipalSite1(pSitePrinc) : TRUE;
    //    CStrPolicyData servicesAttain(pPolicyData);
    //    servicesAttain.FormatServices(fIsSite1);  // include privileges if site1
    //    lstrcpynA(pLogData->m_szServicesAttain, servicesAttain.cstr(),
    //              ARRAY_SIZE(pLogData->m_szServicesAttain));
    //}

    //// If any of the services requested can be granted, indicate that a
    //// valid site ticket should be returned and copy the IP address of
    //// the site into the return preauth data.
    //if ( dwNumAuthorizedServices > 0 )
    //{
    //    const KERB_INTERNAL_NAME *pName = pSitePrinc->GetName();
    //    in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
    //    CHAR szClientAddr[16] = {0};
    //    CHAR szSiteAddr[16] = {0};

    //    pPolicyData->bUseValidSite = TRUE;
    //    pPolicyData->wAuthDataVersion = (WORD) pSitePrinc->GetAuthdataVersion();
    //    pServiceAddress->siteIPAddress.s_addr = pXkdc->GetLoadBalancingIpAddress(pSitePrinc, pPolicyData->qwXboxID);

    //    // If client did not provide "preauthv5", KRB5_PADATA_XENON_SERVICE_REQUEST3, the 
    //    // new one, then we can only send up to a v3 authdata ticket. This is because 
    //    // authdata v4 plus "preauthv3/v4" equals a packet that is too big.
    //    if (pPolicyData->wAuthDataVersion > XONLINE_XENON_AUTHDATA_VERSION &&
    //        NULL == GetPaData(piReq, KRB5_PADATA_XENON_SERVICE_REQUEST3))
    //    {
    //        pPolicyData->wAuthDataVersion = XONLINE_XENON_AUTHDATA_VERSION;
    //    }

    //    lstrcpynA(szSiteAddr, inet_ntoa(pServiceAddress->siteIPAddress), ARRAYSIZE(szSiteAddr));
    //    lstrcpynA(szClientAddr, inet_ntoa(*pInAddr), ARRAYSIZE(szClientAddr));

    //    StringCchPrintfA(pLogData->m_szSiteGranted, _countof(pLogData->m_szSiteGranted), "%S/%S\0", pName->Names[0].Buffer, pName->Names[1].Buffer);

    //    XomTrace(Policy, L_NORMAL, "PolicyCheckServices: using SG '%S/%S' for service id %d at %s from client %s.",
    //              pName->Names[0].Buffer,
    //              pName->Names[1].Buffer,
    //              pSitePrinc->GetServiceID(),
    //              szSiteAddr,
    //              szClientAddr);
    //}
    //else
    //{
    //    XOMASSERT( FALSE == pPolicyData->bUseValidSite );
    //}
    XomTrace(Policy, L_NORMAL, "PolicyCheckServices: services authorized.");

//Cleanup:
    return STATUS_SUCCESS;
}

// ----------------------------------------------------------------------------------------------
//  SetPrivilege:  sets or clears the appropriate bit in the privlieges flags contained within the Xenon authdata.
// ----------------------------------------------------------------------------------------------
void SetPrivilege( DWORD dwPrivileges[], DWORD dwServiceID, BOOL bAuthorized)
{
    DWORD dwordIndex = dwServiceID / 32;
    DWORD bitIndex = dwServiceID - (dwordIndex * 32);
    DWORD dwMask = 1L << bitIndex;

    if ( bAuthorized )
    {
        dwPrivileges[dwordIndex] |= dwMask;
    }
    else
    {
        dwPrivileges[dwordIndex] &= (~dwMask);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\xlog.h ===
#include <stdarg.h>

void xlog(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcServicePrincipal.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "xkdc.h"
#include "XkdcDb.h"

CXkdcServicePrincipal::CXkdcServicePrincipal(
    CXkdcPrincipal *piPrinc,
    IKerbRequest *piReq,
    CXkdcProvider *pXkdc) :
    m_pkinInvalidName(NULL),
    m_bUseValidSite(FALSE),
    m_piPrinc(piPrinc),
    m_piReq(piReq),
    m_pXkdc(pXkdc),
    m_piPacSect(NULL)
{
    if ( m_piPrinc )
    {
        m_liMaxLifeTime = piPrinc->MaxLifeTime();
    }
    else
    {
        m_liMaxLifeTime.QuadPart = 0;
    }
}


CXkdcServicePrincipal::~CXkdcServicePrincipal()
{
    if ( m_pkinInvalidName )
    {
        m_pXkdc->KdcFreeMemory(m_pkinInvalidName);
    }
    if ( m_piPrinc )
    {
        m_piPrinc->Release();
        m_piPrinc = NULL;
    }
    m_piReq = NULL;
    m_pXkdc = NULL;
}

//
//    IKerbPrincipal methods
//
void __stdcall
CXkdcServicePrincipal::Release(void)
{
    delete this;
}


const KERB_INTERNAL_NAME *
__stdcall
CXkdcServicePrincipal::GetName()
{
    XOMASSERT( m_piPrinc );
    if ( NULL == m_piPrinc )
    {
        return NULL;
    }

    if ( m_bUseValidSite )
    {
        return m_piPrinc->GetName();
    }

    return m_pkinInvalidName;
}

PKERB_INTERNAL_NAME
__stdcall
CXkdcServicePrincipal::GetCanonicalName()
{
    XOMASSERT( m_piPrinc );
    if ( NULL == m_piPrinc )
    {
        return NULL;
    }

    if ( m_bUseValidSite )
    {
        return m_piPrinc->GetCanonicalName();
    }

    return (PKERB_INTERNAL_NAME) GetName();
}


LARGE_INTEGER
__stdcall
CXkdcServicePrincipal::MaxLifeTime()
{
    return m_liMaxLifeTime;
}


IKdbProvider *
__stdcall
CXkdcServicePrincipal::GetIKdbProvider(void)
{
    XOMASSERT( m_pXkdc );
    return  m_pXkdc;
}


NTSTATUS
__stdcall
CXkdcServicePrincipal::Encrypt(
    IN PKERB_CRYPT_LIST         pEtypes,    //types preferred
    IN  SALTFLAGS               saltflags,  //salt flags
    IN  PBYTE                   pbIn,       //buffer to encrypt
    IN  ULONG                   cbIn,       //size of buffer to encrypt
    OUT PKERB_ENCRYPTED_DATA    pData,      //encrypted data
    OUT PKERB_EXT_ERROR         pExtendedError)
{
    XOMASSERT( m_piPrinc );
    if ( NULL == m_piPrinc )
    {
        return STATUS_INVALID_PARAMETER;
    }

    NTSTATUS status = STATUS_SUCCESS;

    // if a ticket is to be issued to a valid site, encrypt using the cached
    // site principal.  Otherwise, encrypt using the random key assigned
    // during initialization.
    if ( m_bUseValidSite )
    {
        status = m_piPrinc->Encrypt(
                pEtypes,
                saltflags,
                pbIn,
                cbIn,
                pData,
                pExtendedError);
    }
    else
    {
        status = CXBasePrincipal::Encrypt(
                pEtypes,
                saltflags,
                pbIn,
                cbIn,
                pData,
                pExtendedError);
    }

    return status;
}


NTSTATUS
__stdcall
CXkdcServicePrincipal::Decrypt(
    IN  const KERB_CRYPT_LIST *      pEtypes,
    IN  SALTFLAGS               saltflags,
    IN  const KERB_ENCRYPTED_DATA *   pData,
    OUT PBYTE                   pbOut,
    OUT PULONG                  pcbOut,
    OUT OPTIONAL PETYPE         pEtype,
    OUT PKERB_EXT_ERROR         pExtendedError)
{
    XOMASSERT( FALSE );
    return STATUS_SERVER_DISABLED;
}


NTSTATUS
__stdcall
CXkdcServicePrincipal::GetChecksumSize(
    IN  CTYPE                Ctype,
    OUT PULONG               pcbOut)
{
    XOMASSERT( m_piPrinc );
    if ( NULL == m_piPrinc )
    {
        return STATUS_INVALID_PARAMETER;
    }
    return m_piPrinc->GetChecksumSize(Ctype, pcbOut);
}


NTSTATUS
__stdcall
CXkdcServicePrincipal::Checksum(
    IN  CTYPE                Ctype,
    IN  SALTFLAGS            saltflags,
    IN  PKERB_CRYPT_LIST     pEtypes,
    IN  PBYTE               *rgpbBuffers,
    IN  ULONG               *rgcbBuffers,
    IN  ULONG                cBuffers,
    IN  PBYTE                pbVerify,     // OPTIONAL
    IN  ULONG                cbVerify,     // OPTIONAL
    OUT PBYTE                pbChecksum,   // OPTIONAL
    OUT PULONG               pcbChecksum,  // OPTIONAL
    OUT PBOOLEAN             pfVerified,   // OPTIONAL
    OUT PKERB_EXT_ERROR      pExtendedError)
{
    XOMASSERT( m_piPrinc );
    if ( NULL == m_piPrinc )
    {
        return STATUS_INVALID_PARAMETER;
    }

    return m_piPrinc->Checksum(
                Ctype,
                saltflags,
                pEtypes,
                rgpbBuffers,
                rgcbBuffers,
                cBuffers,
                pbVerify,
                cbVerify,
                pbChecksum,
                pcbChecksum,
                pfVerified,
                pExtendedError
                );
}


NTSTATUS
__stdcall
CXkdcServicePrincipal::GetEtypes(
    OUT const ETYPE **ppEtypes,
    OUT PULONG      pcEtypes)
{
    XOMASSERT( m_piPrinc );
    if ( NULL == m_piPrinc )
    {
        return STATUS_INVALID_PARAMETER;
    }
    return m_piPrinc->GetEtypes(ppEtypes, pcEtypes);
}


KERBERR
__stdcall
CXkdcServicePrincipal::GetEtypeMatch(
    IN  PKERB_CRYPT_LIST pEtypes,
    OUT PKERB_ETYPE_INFO *ppEtypeInfo)
{
    XOMASSERT( m_piPrinc );
    if ( NULL == m_piPrinc )
    {
        return STATUS_INVALID_PARAMETER;
    }
    return m_piPrinc->GetEtypeMatch(pEtypes, ppEtypeInfo);
}


// non-IKerbPrincipal methods
NTSTATUS
__stdcall
CXkdcServicePrincipal::Initialize ()
{
    UNICODE_STRING ustrDomainName = {0};
    UNICODE_STRING ustrServiceName = {0};
    XkdcCredential *pCred = NULL;
    DWORD dwCredSize = 0;
    HCRYPTPROV hCryptProv = NULL;

    NTSTATUS status = STATUS_SUCCESS;

    XOMASSERT( m_pXkdc );
    if ( NULL == m_pXkdc )
    {
        return STATUS_INVALID_PARAMETER;
    }

    // initialize alloc and free functions
    KdcAllocMemory = m_pXkdc->KdcAllocMemory;
    KdcFreeMemory = m_pXkdc->KdcFreeMemory;

    XOMASSERT( KdcAllocMemory && KdcFreeMemory );
    if ( NULL == KdcAllocMemory || NULL == KdcFreeMemory )
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate space for a single key.  The key will be initialized with
    // random data that will be used to encrypt the ticket if the invalid
    // site is to be returned (no valid services)
    dwCredSize = sizeof(XkdcCredential) + sizeof(XkdcKey) + XKDC_KEYSIZE;
    pCred = (XkdcCredential*) KdcAllocMemory(dwCredSize);
    if ( NULL == pCred )
    {
        XomNtEvent(XEVENT_XKDC_NO_MEMORY_16, "CXkdcServicePrincipal::Initialize: failed to allocate %d bytes.", dwCredSize);
        return STATUS_NO_MEMORY;
    }

    ZeroMemory(pCred, dwCredSize);

    pCred->dwKeyCount = 1;
    pCred->Key[0].dwKeyVersion = 1;
    pCred->Key[0].Key.keytype = KERB_ETYPE_RC4_HMAC_NT;
    pCred->Key[0].Key.keyvalue.length = XKDC_KEYSIZE;
    pCred->Key[0].Key.keyvalue.value = ((BYTE*) pCred) + dwCredSize - XKDC_KEYSIZE;
    if ( !XOCryptGenRandom(pCred->Key[0].Key.keyvalue.value, XKDC_KEYSIZE) )
    {
        // report an error but don't fail
        DWORD dwError = GetLastError();
        XomTrace(Xkdc, L_HIGH, "CXkdcServicePrincipal::Initialize: XOCryptGenRandom failed, last error is %d.", dwError);
    }

    // save the credentials
    m_pCred = pCred;
    pCred = NULL;

    // initialize the crypt interface
    status = m_pXkdc->GetIKerbCrypt(&m_pIKerbCrypt);
    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(&ustrServiceName, L"sg");
    RtlInitUnicodeString(&ustrDomainName, L"site0");

    status = m_pXkdc->GetKdcCore()->pfnKerbBuildFullServiceKdcName(
            &ustrDomainName,
            &ustrServiceName,
            KRB_NT_SRV_INST,
            &m_pkinInvalidName
            );
    if ( !NT_SUCCESS(status) )
    {
        goto Cleanup;
    }

    status = PolicyCheck();
    if ( !NT_SUCCESS(status) )
    {
        goto Cleanup;
    }

Cleanup:
    return status;
}


const XKDC_POLICY_DATA *
CXkdcServicePrincipal::GetPolicyData()
{
    XKDC_POLICY_DATA *pPolicyData = NULL;
    IPAXboxRequest *piXboxReq = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    // get the Xkdc-specific interface from the preauth handler
    status = m_piReq->GetPAHandler(IID_IPAXboxRequest, (PVOID*)&piXboxReq);
    if ( !NT_SUCCESS(status) || (NULL == piXboxReq) )
    {
        // TODO: log/trace
        XomTrace(Xkdc, L_HIGH, "CXkdcServicePrincipal::GetPolicyData: no IID_IPAXboxRequest interface found.");
        goto Cleanup;
    }

    status = piXboxReq->GetPolicyData(&pPolicyData);
    if ( !NT_SUCCESS(status) || NULL == pPolicyData )
    {
        XomTrace(Xkdc, L_HIGH, "CXkdcServicePrincipal::GetPolicyData: unable to retrieve XKERB_AD_XBOX.");
        goto Cleanup;
    }

 Cleanup:
    return pPolicyData;
}

static void GenerateFloken(FLOKEN *pFlowToken)
{
    XOMASSERT(pFlowToken);

    // Perhaps unnecessarily strong, but hey..
    if (!XOCryptGenRandom((BYTE*)&pFlowToken->flowToken, sizeof(pFlowToken->flowToken)))
    {
        // @@@ kgoodier Fall back to a pseudo-RNG?
        XomTrace(Xkdc, L_ERROR, "GenerateFloken: random number generator is broken, flow tokens will not be generated.");
    }
}

NTSTATUS
CXkdcServicePrincipal::PolicyCheck()
{
    NTSTATUS status = STATUS_SUCCESS;
    XKDC_PA_SERVICE_REQUEST *pServiceRequest = NULL;
    XKDC_PA_SERVICE_ADDRESS *pServiceAddress = NULL;
    XKDC_POLICY_DATA *pPolicyData = NULL;
    IPAXboxRequest *piXboxReq = NULL;
    IPAXboxLogData *piXboxLog = NULL;
    XKDC_LOGGINGDATA *pLogData = NULL;
    const PAC_INFO_BUFFER *pPacBuf = NULL;
    const PAC_INFO_BUFFER *pCompoundPacBuf = NULL;
    const KERB_ENCRYPTED_TICKET *pTgt = NULL;
    const PIDENTITY *pId = NULL;

    SOCKADDR_IN *psaClient = (SOCKADDR_IN *) m_piReq->GetClientAddress();

    // get the Xkdc-specific interface from the preauth handler
    status = m_piReq->GetPAHandler(IID_IPAXboxRequest, (PVOID*)&piXboxReq);
    if ( !NT_SUCCESS(status) || NULL == piXboxReq )
    {
        XomNtEvent(XEVENT_KDC_CODE_286, "(%s:%d) CXkdcServicePrincipal::PolicyCheck: no IID_IPAXboxRequest interface found.", __FILE__, __LINE__);
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    // get the Xkdc log interface from the preauth handler
    status = m_piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog);
    if ( !NT_SUCCESS(status) || NULL == piXboxLog )
    {
        XomNtEvent(XEVENT_KDC_CODE_287, "(%s:%d) CXkdcServicePrincipal: no IID_IPAXboxLogData interface found.", __FILE__, __LINE__);
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    // get the log data
    status = piXboxLog->GetLogData( &pLogData );
    if ( !NT_SUCCESS(status) || NULL == pLogData )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_23, "CXkdcServicePrincipal::PolicyCheck: no Log Data found.");
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    // find the PAC handler so we can get at specific sections of the PAC
    if ( NULL == m_piPacSect )
    {
        status = m_piReq->GetADHandler(IID_IADPacSection, (PVOID*)&m_piPacSect);
        if ( !NT_SUCCESS(status) || (NULL == m_piPacSect) )
        {
            // TODO: log/trace
            XomTrace(Xkdc, L_HIGH, "CXkdcServicePrincipal::PolicyCheck: failed to acquire valid IADPacSection interface.");
            status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    status = piXboxReq->GetServiceRequest(&pServiceRequest);
    if ( !NT_SUCCESS(status) || NULL == pServiceRequest )
    {
        XomNtEvent(XEVENT_KDC_CODE_289, "CXkdcServicePrincipal::PolicyCheck: unable to retrieve XKDC_PA_SERVICE_REQUEST.");
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    status = piXboxReq->GetServiceAddress(&pServiceAddress);
    if ( !NT_SUCCESS(status) || NULL == pServiceAddress )
    {
        XomNtEvent(XEVENT_KDC_CODE_290, "CXkdcServicePrincipal::PolicyCheck: unable to retrieve XKDC_PA_SERVICE_ADDRESS.");
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    status = piXboxReq->GetPolicyData(&pPolicyData);
    if ( !NT_SUCCESS(status) || NULL == pPolicyData )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_25, "CXkdcServicePrincipal::PolicyCheck: unable to retrieve XKDC_POLICY_DATA.");
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    // set up logging data fields from what we know
    pLogData->m_qwUserPUID[ 0 ] = pServiceRequest->qwUserID[ 0 ];
    pLogData->m_qwUserPUID[ 1 ] = pServiceRequest->qwUserID[ 1 ];
    pLogData->m_qwUserPUID[ 2 ] = pServiceRequest->qwUserID[ 2 ];
    pLogData->m_qwUserPUID[ 3 ] = pServiceRequest->qwUserID[ 3 ];
    pLogData->m_clientVersion = pServiceRequest->clientVersion;

    // Save the version fields for later use in the ticket
    pPolicyData->clientVersion = pServiceRequest->clientVersion;

    // By default, ticket lifetime should not be constrained beyond what is configured for the site
    pPolicyData->dwMaxTicketLifetimeSecs = UINT_MAX;
    
    // retrieve machine id from the TGT. We need to do this now so we can enforce the DoS
    // policies and retrieve items from the DB cache.

    // find the incoming TGT
    pTgt = m_piReq->GetTgt();
    if ( NULL == pTgt )
    {
        XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_11, "(%s:%d) PolicyCheck: unable to acquire TGT from IKerbRequest.", __FILE__, __LINE__);
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Get the machine identity
    status = PacGetMachinePuid( m_piPacSect, &(pPolicyData->qwXboxID) );
    if (!NT_SUCCESS(status)) 
    {
        in_addr *pInAddr = &(((PSOCKADDR_IN)m_piReq->GetClientAddress())->sin_addr);
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_GENERALERROR;

        XomNtEvent(XEVENT_KDC_HACK_9,
            "PolicyCheck: missing PAC_CLIENT_IDENTITY section from client %s.",
            inet_ntoa(*pInAddr));

        XomTrace(Policy, L_ERROR,
            "PolicyCheck: missing PAC_CLIENT_IDENTITY section from client %s.",
            inet_ntoa(*pInAddr));

        pPolicyData->KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
        pPolicyData->bContinueChecks = FALSE;
        goto Cleanup;
    }

    XomTrace(Policy, L_LOW, "PolicyCheck: found machine id 0x%016I64X in PAC.", pPolicyData->qwXboxID);


    // DoS detection (request throttling)
    // All platforms
    //
    // Also request caching.

    // Notes on request caching:
    //
    // CKdcDosCache::CheckAndAcquire() has some pecularities we need to deal with.
    //
    // Happy case: call succeeds, and cache data is valid. It then falls on us to verify
    // if the data has expired, if the users/titleid have changed, or any other situation
    // that would require us to hit the DB. An autodiscover request will always trigger a
    // DB hit also. In this case, we can write directly to the cache data item. Remember
    // to Release() the cache item at the end.
    //
    // Unhappy case: call succeeds, but cache data is invalid. This means our entry
    // couldn't be found and a new one had to be refurbished. All we have to do is hit the
    // DB in this case.
    //
    // Sad case: call fails with KDCDOS_CACHE_INUSE. This means we found an entry but some
    // other thread is using it. To simplify the implementation and avoid the
    // reader/writer lock business, what this means in practice is the cache item is
    // invalid and should not be used. It should not even be inserted back into the cache
    // at the end. Do not use the cache data item, and instead use a local copy. This will
    // require hitting the DB and the results won't be cached, but this should be a very
    // infrequent case and the performance won't degrade noticeably.
    //
    // Sad case: call fails with KDCDOS_NO_RECORD. This means we did not find an entry and
    // we failed to refurbish the LRU one due to it being in use. We should use a local
    // copy of the cache item and hit the db and toss results.
    //

    // May need a local copy of the cache data in certain cases, and it needs to be in
    // scope for the life of this function. It's only a few hundred bytes being allocated
    // on the stack..  seems OK to do every time, even if not necessary.

    XKDCDB_AUTHORIZATION_DATA xkdcDbData;
    BOOL                      fCacheDataValid = FALSE;
    KDCDOS_STATUS             dosStatus;
    CKdcDosForXkdc*           pKdcDos = m_pXkdc->GetKdcDos();

    if (m_pXkdc->GetRequestCacheEnabled())
    {
        // DOS check and cache acquire
        dosStatus = pKdcDos->CheckAndAcquire(
            pPolicyData->qwXboxID,
            &pPolicyData->pXkdcDbData,
            &fCacheDataValid
            );
    }
    else
    {
        // Just a DOS check. By leaving fCacheDataValid FALSE, this will trigger us to use
        // the local xkdcDbData item, which means we'll hit the DB and not cache the
        // results.
        dosStatus = pKdcDos->Check(
            pPolicyData->qwXboxID);
    }

    // CheckAndAcquire will set the pXkdcDbData parameter to NULL if it fails. Or if
    // caching is disabled, we'll have never set it. In these cases, we need to point to
    // the local copy.
    if (pPolicyData->pXkdcDbData == NULL)
    {
        pPolicyData->pXkdcDbData = &xkdcDbData;
    }

    // Should not be null
    XOMASSERT(pPolicyData->pXkdcDbData);

    if(dosStatus == KDCDOS_LIMIT_EXCEEDED)
    {
        XomNtEvent(
            XEVENT_XKDC_HACK_DOS_ATTACK,
            "A client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires.\n"
            "Client IP: "DBGINAFMT"\n"
            "Machine id: 0x%016I64X",
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            DBGINAPRM(&(((PSOCKADDR_IN)m_piReq->GetClientAddress())->sin_addr)),
            pPolicyData->qwXboxID);

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_TEMPORARILY_BANNED;
        pPolicyData->KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto Cleanup;
    }
    else if(dosStatus == KDCDOS_TEMP_BANNED)
    {
        // Client was previously banned and an event was already logged at that time. To
        // prevent the client from flooding the Nt event log, we're not going to log an
        // event.
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_TEMPORARILY_BANNED;
        pPolicyData->KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto Cleanup;
    }
    else if(dosStatus == KDCDOS_CACHE_INUSE)
    {
        // Found a cache item but another thread is using it. This should be rare. We'll
        // use a local copy.
        fCacheDataValid = FALSE;
        pPolicyData->pXkdcDbData = &xkdcDbData;
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_DOSCACHE_INUSE;

        g_Counters.IncrementValue32(XKDCPERF_SERVER_CACHE_INUSE_FAILURE_COUNTER, 1);
        g_Counters.IncrementValue32(XKDCPERF_SERVER_CACHE_INUSE_FAILURE_RATE, 1);

        XomTrace(Policy, L_ERROR,
            "PolicyCheck: DosCache returned KDCDOS_CACHE_INUSE for machine 0x%016I64X",
            pPolicyData->qwXboxID);

        // We can either continue the request with no caching, which is how things used to
        // work. Or we can abort this request, since there seems to be another one already
        // in progress for the client.
        if (m_pXkdc->GetIgnoreDuplicateRequests())
        {
            pPolicyData->KerbErr = m_pXkdc->SilentKerbErr(KDC_ERR_NO_RESPONSE);
            goto Cleanup;
        }
    }
    else if(dosStatus == KDCDOS_NO_RECORD)
    {
        // Did not find a cache item, and new one is in use. This is very rare. We'll use
        // a local copy.
        fCacheDataValid = FALSE;
        pPolicyData->pXkdcDbData = &xkdcDbData;

        g_Counters.IncrementValue32(XKDCPERF_SERVER_CACHE_NORECORD_FAILURE_COUNTER, 1);
        g_Counters.IncrementValue32(XKDCPERF_SERVER_CACHE_NORECORD_FAILURE_RATE, 1);

        XomTrace(Policy, L_ERROR,
            "PolicyCheck: DosCache returned KDCDOS_CACHE_NORECORD for machine 0x%016I64X",
            pPolicyData->qwXboxID);

        XomNtEvent(
            XEVENT_XKDC_DOSCACHE_NORECORD,
            "The CKdcDosCache class returned KDCDOS_CACHE_NORECORD. This is unexpected "
            "but recoverable. Please alert the dev team immediately. \n"
            "ServiceRequest:\n%s\n"
            "PolicyData:\n%s\n",
            (LPCSTR)XKDC_PA_SERVICE_REQUEST::ToString(*pServiceRequest),
            (LPCSTR)XKDC_POLICY_DATA::ToString(*pPolicyData));
    }
    else if(dosStatus == KDCDOS_OK)
    {
        // If we yanked an item out of the cache and it is valid (marked for us, not in
        // use), then we need to do some additional checks.  What if the title id changed?
        // Or the user configuration?  Or what if the data has expired?  For these cases,
        // we need to hit the DB again and refresh the cache data.
        //
        // Also, when the DosCache is disabled (or DOS itself), we'll hit this codepath.
        // fCacheDataValid will be FALSE and remain so; we'll end up incrementing the
        // "miss (not found)" perf counter, which is good - that means we're hitting the
        // db.

        // Initial requests get special treatment. We always want to hit the DB for them.
        //
        // @@@ How do we differentiate this for Xbox1 requests? Do we need to worry about
        // it, or will the cache lifetime expiration catch these cases?
        if (pServiceRequest->wAutoDiscoverServices)
        {
            fCacheDataValid = FALSE;
            g_Counters.IncrementValue32(XKDCPERF_SERVER_CACHE_MISS_INITIALREQ_RATE, 1);
        }
        else if (fCacheDataValid == FALSE)
        {
            // Complete cache miss, but not because of an initial request - been a long
            // time since we've seen this client? Xbox1 maybe?
            g_Counters.IncrementValue32(XKDCPERF_SERVER_CACHE_MISS_NOTFOUND_RATE, 1);

            XomTrace(Policy, L_NORMAL,
                "PolicyCheck: DosCache miss (not found) for machine 0x%016I64X, autodiscover=%u",
                pPolicyData->qwXboxID, pServiceRequest->wAutoDiscoverServices);
        }
        else
        {
            // If the cache said the data was valid, then we need to really make sure it's
            // ok and that nothing changed between last request and this one.
            XOMASSERT(fCacheDataValid);

            fCacheDataValid = pPolicyData->pXkdcDbData->StillValid(
                m_pXkdc->GetRequestCacheLifetimeInSeconds(),
                pServiceRequest->dwTitleID,  // don't use LiveTitleId, use the request's title id
                pPolicyData->qwXboxID,
                pServiceRequest->qwUserID[0],
                pServiceRequest->qwUserID[1],
                pServiceRequest->qwUserID[2],
                pServiceRequest->qwUserID[3],
                pServiceRequest->dwServiceID,
                pServiceRequest->dwNumServices);

            if (fCacheDataValid == FALSE)
            {
                g_Counters.IncrementValue32(XKDCPERF_SERVER_CACHE_MISS_INVALID_RATE, 1);

                XomTrace(Policy, L_NORMAL,
                    "PolicyCheck: DosCache miss (data invalid) for machine 0x%016I64X",
                    pPolicyData->qwXboxID);
            }
        }
    }


    // The End
    //
    // If cache data isn't valid for whatever reason - new item, expired, doscache
    // disabled, etc - reset the struct.  This will set the fIsValid field to FALSE and
    // cause us to hit the DB again.
    if (!fCacheDataValid)
    {
        pPolicyData->pXkdcDbData->Reset();
    }
    else
    {
        g_Counters.IncrementValue32(XKDCPERF_SERVER_CACHE_HIT_RATE, 1);

        XomTrace(Policy, L_NORMAL,
            "PolicyCheck: DosCache hit for machine 0x%016I64X",
            pPolicyData->qwXboxID);

        // Suppose we could mine this or something..
        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_USING_DOSCACHE_DATA;
    }

    //
    // Enforce flow token policy. Use what client gives us, unless 0, then we generate a 
    // random one. We sort of want to do this before other checks, since having the idea 
    // of a "flow" is a good one to have everywhere. 
    //

    if (!pServiceRequest->flowToken.IsValid())
    {
        // We need to put this in both the ticket (pPolicyData here), and the returned 
        // service address.
        GenerateFloken(&pPolicyData->flowToken);
        pServiceAddress->flowToken = pPolicyData->flowToken;
    }
    else
    {
        // Client provided one, so let's send it right back (and put it in the ticket)
        pPolicyData->flowToken = pServiceRequest->flowToken;
        pServiceAddress->flowToken = pServiceRequest->flowToken;
    }


    //
    // Begin policy checks
    //

    // perform policy checks for the machine account
    if ( NT_SUCCESS(status) )
    {
        status = PolicyCheckMachine(
                m_pXkdc,
                m_piReq,
                m_piPacSect,
                pServiceRequest,
                pServiceAddress,
                pPolicyData);

        pLogData->m_qwMachinePUID = pPolicyData->qwXboxID;
        if ( !NT_SUCCESS(status) )
        {
            pPolicyData->policyStatus = status;
            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_FAILED_MAC_POLICY_CHECK;
            XomTrace(Xkdc, L_NORMAL, "CXkdcServicePrincipal::PolicyCheck: PolicyCheckMachine failed with status %d.", status);

        }

        if ( !pPolicyData->bContinueChecks )
        {
            XomTrace(Xkdc, L_NORMAL, "CXkdcServicePrincipal::PolicyCheck: PolicyCheckMachine halting additional policy checks, machine hr = 0x%08X.", pPolicyData->hrXbox);

        }
    }

    // perform policy checks for the title id and version
    if ( NT_SUCCESS(status) && pPolicyData->bContinueChecks )
    {
        status = PolicyCheckTitleID(
                m_pXkdc,
                m_piReq,
                m_piPacSect,
                pServiceRequest,
                pServiceAddress,
                pPolicyData);
        if ( !NT_SUCCESS(status) )
        {
            pPolicyData->policyStatus = status;
            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_FAILED_TITLEID_POLICY_CHECK;
            XomTrace(Xkdc, L_HIGH, "CXkdcServicePrincipal::PolicyCheck: PolicyCheckTitleID failed with status %d.", status);
        }

        if ( !pPolicyData->bContinueChecks )
        {
            XomTrace(Xkdc, L_NORMAL, "CXkdcServicePrincipal::PolicyCheck: PolicyCheckTitleID halting additional policy checks.");
        }
    }

    // perform policy checks for the users
    if ( NT_SUCCESS(status) && pPolicyData->bContinueChecks && !pPolicyData->bMachineOnly )
    {
        status = PolicyCheckUsers(
                m_pXkdc,
                m_piReq,
                m_piPacSect,
                pServiceRequest,
                pServiceAddress,
                pPolicyData);
        if ( !NT_SUCCESS(status) )
        {
            pPolicyData->policyStatus = status;
            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_FAILED_USER_POLICY_CHECK;
            XomTrace(Xkdc, L_HIGH, "CXkdcServicePrincipal::PolicyCheck: PolicyCheckUsers failed with status %d.", status);
        }

        if ( !pPolicyData->bContinueChecks )
        {
            XomTrace(Xkdc, L_NORMAL, "CXkdcServicePrincipal::PolicyCheck: PolicyCheckUsers halting additional policy checks.");
        }
        
        // If the policy checks resulted in a maximum ticket lifetime 
        // less than what is configured for the site, use it instead.
        m_liMaxLifeTime.QuadPart = __min(m_liMaxLifeTime.QuadPart, (LONGLONG)10000000 * pPolicyData->dwMaxTicketLifetimeSecs);
    }

    // perform policy checks for the services
    if ( NT_SUCCESS(status) && pPolicyData->bContinueChecks )
    {
        status = PolicyCheckServices(
                m_pXkdc,
                m_piReq,
                m_piPacSect,
                pServiceRequest,
                pServiceAddress,
                pPolicyData);
        if ( !NT_SUCCESS(status) )
        {
            pPolicyData->policyStatus = status;
            pLogData->m_qwReqStatus |= XKDC_REQSTATUS_FAILED_SERVICES_POLICY_CHECK;
            XomTrace(Xkdc, L_HIGH, "CXkdcServicePrincipal::PolicyCheck: PolicyCheckServices failed with status %d.", status);
        }

        if ( !pPolicyData->bContinueChecks )
        {
            XomTrace(Xkdc, L_NORMAL, "CXkdcServicePrincipal::PolicyCheck: PolicyCheckServices halting additional policy checks.");
        }
    }

    // use valid site if all the policy checks are complete and successful
    m_bUseValidSite = pPolicyData->bUseValidSite;

    if ( m_bUseValidSite )
    {
        const KERB_INTERNAL_NAME *pName = m_piPrinc->GetName();
        PSOCKADDR_IN ClientAddr = NULL;
        CHAR szClientAddr[16] = {0};
        CHAR szTicketAddr[16] = {0};
        DWORD i = 0;
        DWORD cOK = 0;

        // generate a new key for this authdata.
        if ( STATUS_SUCCESS != (m_pXkdc->GetSigningKey( pPolicyData->dwTitleID, pPolicyData->dwTitleVersion, pPolicyData->qwXboxID, sizeof(pPolicyData->abKey), pPolicyData->abKey)) )
        {
            XomNtEvent(XEVENT_XKDC_NO_MEMORY_17, "CXkdcServicePrincipal::PolicyCheck: Unable to calculate SHA1-HMAC signing key for this request.");
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        // print out the key generation results.
        XomTrace(  Xkdc,
                    L_LOW,
                    "CXkdcServicePrincipal::PolicyCheck: Generated Key for Titleid: 0x%X, Title Version: 0x%X, XboxId: 0x%I64X, Key= 0x%08I64X%08I64X",
                    pPolicyData->dwTitleID,
                    pPolicyData->dwTitleVersion,
                    pPolicyData->qwXboxID
                    );

        XomTrace(  Xkdc,
                    L_NORMAL,
                    "CXkdcServicePrincipal::PolicyCheck: authorization succeeded, using valid site '%S/%S' for ticket.",
                    pName->Names[0].Buffer,
                    pName->Names[1].Buffer);

        ClientAddr = (PSOCKADDR_IN) m_piReq->GetClientAddress();
        XOMASSERT( ClientAddr );
        XOMASSERT( pServiceAddress->dwNumServices > 0 );
        if ( NULL == ClientAddr )
        {
            XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_26, "PolicyCheck: missing client address.");
            goto Cleanup;
        }
        if ( 0 == pServiceAddress->dwNumServices )
        {
            XomNtEvent(XEVENT_XKDC_BAD_PARAMETER_27, "PolicyCheck: no services granted.");
            goto Cleanup;
        }

        // Save the IP addresses of the site and the client.  Since inet_ntoa
        // uses a static buffer, it can't be used for more than one parameter
        // as in the trace call below.
        lstrcpynA(szTicketAddr, inet_ntoa(pServiceAddress->siteIPAddress), ARRAYSIZE(szTicketAddr));
        lstrcpynA(szClientAddr, inet_ntoa(ClientAddr->sin_addr), ARRAYSIZE(szClientAddr));

        // For a successful logon with at least one user and one service,
        // log the following:
        // - date/time
        // - title id
        // - machine puid
        // - user puids
        // - services granted
        if ( pPolicyData->dwUsers > 0 && pServiceAddress->dwNumServices > 0 )
        {
            XomLog(XkdcTicketLog,
                    "UTL|%08X|%016I64X|%016I64X|%016I64X|%016I64X|%016I64X|%s",
                    pServiceRequest->dwTitleID,
                    pPolicyData->qwXboxID,
                    pServiceRequest->qwUserID[ 0 ],
                    pServiceRequest->qwUserID[ 1 ],
                    pServiceRequest->qwUserID[ 2 ],
                    pServiceRequest->qwUserID[ 3 ],
                    pLogData->m_szServicesAttain);
        }

        XomLog(XkdcTicketLog, "XTL|%S/%S@%s|%s|%s",
                pName->Names[0].Buffer,
                pName->Names[1].Buffer,
                szTicketAddr,
                szClientAddr,
                pLogData->m_szServicesAttain);

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_PASSED_POLICY_CHECK;

        // The cached data is now valid. Since we have a pointer to the cache item, there
        // is no need to "store it". Just remember to release it at the very end.
        pPolicyData->pXkdcDbData->IsValid = TRUE;
    }
    else
    {
        const KERB_INTERNAL_NAME *pName = m_pkinInvalidName;
        PSOCKADDR_IN ClientAddr = NULL;
        char szRequestedServices[256] = {0};
        CHAR szClientAddr[16] = {0};
        CHAR szTicketAddr[16] = {0};

        pLogData->m_qwReqStatus |= XKDC_REQSTATUS_USING_INVALID_SITE;

        // In this failure case, determine if we need to hand back the service address
        // failed pre-auth. We only do it if the client support its
        if (pServiceRequest->bAllowServiceAddressFailed == TRUE) 
        {
            // There is a special case where we will not hand back a real ticket
            // when we have 0 services to hand back. In this case along, we 
            // want to not use the ServiceAddressFailed and instead hand back
            // a ServiceRequest3
            if ( FAILED(pServiceAddress->hr) ) 
            {
                pServiceAddress->bUseFailedAddress = TRUE;
            }
        }

        ClientAddr = (PSOCKADDR_IN) m_piReq->GetClientAddress();
        XOMASSERT( ClientAddr );

        GetServiceIdsIntoString( pServiceRequest->dwServiceID, pServiceRequest->dwNumServices, szRequestedServices, ARRAYSIZE(szRequestedServices) );

        // Save the IP addresses of the site and the client.  Since inet_ntoa
        // uses a static buffer, it can't be used for more than one parameter
        // as in the trace call below.
        lstrcpynA(szTicketAddr, inet_ntoa(pServiceAddress->siteIPAddress), ARRAYSIZE(szTicketAddr));
        lstrcpynA(szClientAddr, inet_ntoa(ClientAddr->sin_addr), ARRAYSIZE(szClientAddr));

        XomTrace(Xkdc, L_ERROR,
            "XKDC: authorization failure: invalid ticket: %S/%S@%s granted to machine account: 0x%016I64X client: %s requesting services: %s.",
            pName->Names[0].Buffer,
            pName->Names[1].Buffer,
            szTicketAddr,
            pPolicyData->qwXboxID,
            szClientAddr,
            ( pServiceRequest->dwNumServices != 0 ) ? szRequestedServices : "none\0" );
    }

 Cleanup:

    // We may need to release the cache data item, though there are special circumstances
    // where we don't want to. The safest thing is to see if the cache item we've been
    // using is the local copy or the cached copy. We could also check for KDCDOS_OK error
    // code. Only release if we're using the cached copy.
    if (pPolicyData->pXkdcDbData != &xkdcDbData)
    {
        if (!pKdcDos->Release(pPolicyData->qwXboxID))
        {
            // This situation ASSERTs in debug builds. Throw an event so we can
            // investigate in retail builds.

            XomNtEvent(
                XEVENT_XKDC_DOSCACHE_RELEASE_ERROR,
                "Failed to release an acquired cache item. This should never happen and indicates the "
                "server may be in an inconsistent state. Please escalate to the dev team immediately.\n"
                "ServiceRequest:\n%s\n"
                "XkdcDbData:\n%s\n"
                "PolicyData:\n%s\n",
                (LPCSTR)XKDC_PA_SERVICE_REQUEST::ToString(*pServiceRequest),
                (LPCSTR)XKDCDB_AUTHORIZATION_DATA::ToString(*pPolicyData->pXkdcDbData),
                (LPCSTR)XKDC_POLICY_DATA::ToString(*pPolicyData));
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\XkdcUtil.cpp ===
#include "xkdc.h"

NTSTATUS
PacGetMachinePuid(
    IN  IADPacSection *piPacSection,
    OUT ULONGLONG     *pMachineId
    )
{
    DWORD                  i                 = 0;
    NTSTATUS               status            = STATUS_SUCCESS;
    const PAC_INFO_BUFFER *pPacBuf           = NULL;
    PCIDENTITY             pId               = NULL;
    PCXBOX_IDENTITY        pXboxId           = NULL;

    // If there is an Xbox Identity present, then we will find what
    // we want to find there
    status = piPacSection->GetPacSection( PAC_XBOX_IDENTITY, &pPacBuf );
    if (NT_SUCCESS(status) && pPacBuf != NULL) 
    {
        pXboxId     = (PCXBOX_IDENTITY) pPacBuf->Data;
        *pMachineId =                   pXboxId->MachineIdentity;
        return status;
    }

    // If we got here, then that is because it is because the machine
    // puid is in the CLIENT_IDENTITY section
    status = piPacSection->GetPacSection( PAC_CLIENT_IDENTITY, &pPacBuf );
    if (!NT_SUCCESS(status)) 
    {
        return status;
    }
    if (pPacBuf == NULL) 
    {
        return STATUS_NOT_FOUND;
    }

    pId         =  ( (PIDENTITY  ) pPacBuf->Data );
    *pMachineId = *( (ULONGLONG *) pId->Identity );
    return status;
}

NTSTATUS
PacGetUserIdentity(
    IN  IADPacSection *piPacSection,
    IN  ULONGLONG      qwUserId,
    OUT ULONG         *pCredentialType
    )
{
    DWORD                  i                 = 0;
    NTSTATUS               status            = STATUS_SUCCESS;
    const PAC_INFO_BUFFER *pPacBuf           = NULL;
    PCCOMPOUND_IDENTITY    pCompoundIdentity = NULL;
    PCIDENTITY             pId               = NULL;
    PCXBOX_IDENTITY        pXboxId           = NULL;
    ULONGLONG              qwPuid            = 0;

    // Default for 'we can't find this user'
    *pCredentialType = CT_Unknown;

    // If there is an Xbox Identity present, then we will find what
    // we want to find there
    status = piPacSection->GetPacSection( PAC_XBOX_IDENTITY, &pPacBuf );
    if (NT_SUCCESS(status) && pPacBuf != NULL) 
    {
        pXboxId = (PCXBOX_IDENTITY) pPacBuf->Data;

        // Look thru each of the user slots for the matching user
        for (i = 0; i < XBOX_IDENTITY_MAX_USERS; ++i) 
        {
            if (pXboxId->UserIdentity[i] != qwUserId) 
            {
                continue;
            }
            *pCredentialType = pXboxId->UserIdentityCredential[i];
            return status;
        }
    }

    // Take a look in the compound identity section first to see if there
    // is an entry that claims to be the user
    status = piPacSection->GetPacSection( PAC_COMPOUND_IDENTITY, &pPacBuf );
    if (NT_SUCCESS(status) && pPacBuf != NULL) 
    {
        pCompoundIdentity = (PCCOMPOUND_IDENTITY) pPacBuf->Data;

        // We have a compound identity. Look thru each one and see if
        // one is identified as the machine
        pId = (PCIDENTITY) &pCompoundIdentity->Identities[0];
        while (i < pCompoundIdentity->NumberOfIdentities) 
        {
            // We only accept ID_PUID
            XOMASSERT( pId->IdentityType == ID_PUID );
            if ( ID_PUID == pId->IdentityType &&
                 IA_USER == pId->IdentityAttributes) 
            {
                qwPuid = * ( (ULONGLONG *) pId->Identity );
                if (qwPuid == qwUserId) 
                {
                    *pCredentialType = pId->CredentialIdType;
                    return status;
                }
            }
            pId = (PCIDENTITY) (((PBYTE) pId) + pId->LengthOfIdentity);
            ++i;
        }
    }
    return STATUS_NOT_FOUND;
}

VOID
PacGetIdentitiesAsString(
    IN  IADPacSection *piPacSection,
    IN  CStr          *pStr
    )
{
    DWORD                  i;
    NTSTATUS               status;
    const PAC_INFO_BUFFER *pPacBuf           = NULL;
    PCCOMPOUND_IDENTITY    pCompoundIdentity = NULL;
    PCIDENTITY             pId               = NULL;
    PCXBOX_IDENTITY        pXboxId           = NULL;
    QWORD                  qwPuid;

    status = piPacSection->GetPacSection( PAC_XBOX_IDENTITY, &pPacBuf );
    if (NT_SUCCESS(status) && pPacBuf != NULL) 
    {
        pXboxId = (PCXBOX_IDENTITY) pPacBuf->Data;

        if (pXboxId->MachineIdentity != 0) 
        {
            pStr->Format(
                "machinepuid: 0x%016I64X (CredType %d)\n",
                pXboxId->MachineIdentity,
                pXboxId->MachineIdentityCredential
                );
        }
        for (i = 0; i < XBOX_IDENTITY_MAX_USERS; ++i) 
        {
            if (pXboxId->UserIdentity[i] == 0) 
            {
                continue;
            }
            pStr->Format(
                "userpuid[%d]: 0x%016I64X (CredType %d)\n",
                i,
                pXboxId->UserIdentity[i],
                pXboxId->UserIdentityCredential[i]
                );
        }
    }

    status = piPacSection->GetPacSection( PAC_COMPOUND_IDENTITY, &pPacBuf );
    if (NT_SUCCESS(status) && pPacBuf != NULL) 
    {
        pCompoundIdentity = (PCCOMPOUND_IDENTITY) pPacBuf->Data;
        pId               = (PCIDENTITY)         &(pCompoundIdentity->Identities[0]);
        for (i = 0; i < pCompoundIdentity->NumberOfIdentities; ++i) 
        {
            if (ID_PUID == pId->IdentityType) 
            {
                qwPuid = * (ULONGLONG *) pId->Identity;
                pStr->Format(
                    "compid[%d]: 0x%016I64X (CredType %d)\n",
                    i,
                    qwPuid,
                    pId->CredentialIdType
                    );
            }
            else
            {
                pStr->Format(
                    "compid[%d]: Unknown Identity Type %d\n",
                    i,
                    pId->IdentityType
                    );
            }
            pId = (PCIDENTITY) (((PBYTE) pId) + pId->LengthOfIdentity);
        }
    }

    status = piPacSection->GetPacSection( PAC_CLIENT_IDENTITY, &pPacBuf );
    if (NT_SUCCESS(status) && pPacBuf != NULL) 
    {
        pId = (PCIDENTITY) pPacBuf->Data;

        if (ID_PUID == pId->IdentityType) 
        {
            qwPuid = * (ULONGLONG *) pId->Identity;
            pStr->Format(
                "clientid[%d]: 0x%016I64X (CredType %d)\n",
                i,
                qwPuid,
                pId->CredentialIdType
                );
        }
        else
        {
            pStr->Format(
                "clientid[%d]: Unknown Identity Type %d\n",
                i,
                pId->IdentityType
                );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertGeneralizedTimeToLargeInt
//
//  Synopsis:   Converts a generalized time (ASN.1 format) to a large integer
//              (NT format)
//
//  Effects:
//
//  Arguments:  TimeStamp - receives NT-style time
//              ClientTime - client generalized time
//              ClientUsec - client micro second count
//
//  Requires:   none
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN const KERB_TIME * ClientTime,
    IN int ClientUsec
    )
{
    KERB_TIME ZeroTime = {0};
    SYSTEMTIME TimeFields;

    ZeroTime.universal = TRUE;

    //
    // Skip this check after 3/1/97 - no clients should send this sort of
    // zero time
    //

    if (!memcmp(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart = 0;
#else // WIN32_CHICAGO
        *TimeStamp = 0;
#endif // WIN32_CHICAGO
        return;
    }

    //
    // Check for MIT zero time
    //

    ZeroTime.year = 1970;
    ZeroTime.month = 1;
    ZeroTime.day = 1;

    if (!memcmp(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart = 0;
#else // WIN32_CHICAGO
        *TimeStamp = 0;
#endif // WIN32_CHICAGO
        return;
    }
    else
    {
        TimeFields.wYear = ClientTime->year;
        TimeFields.wMonth = ClientTime->month;
        TimeFields.wDay = ClientTime->day;
        TimeFields.wHour = ClientTime->hour;
        TimeFields.wMinute = ClientTime->minute;
        TimeFields.wSecond = ClientTime->second;
        TimeFields.wMilliseconds = ClientTime->millisecond;  // to convert from micro to milli
        TimeFields.wDayOfWeek = 0;

        SystemTimeToFileTime(&TimeFields, (LPFILETIME) TimeStamp );

        //
        // add in any micro seconds
        //

        TimeStamp->QuadPart += ClientUsec * 10;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertLargeIntToGeneralizedTime
//
//  Synopsis:   Converts a large integer to ageneralized time
//
//  Effects:
//
//  Arguments:  ClientTime - receives generalized time
//              ClientUsec - receives micro second count
//              TimeStamp - contains NT-style time
//
//  Requires:   none
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN const TimeStamp * TimeStamp
    )
{
    SYSTEMTIME TimeFields;

    //
    // Special case zero time
    //

#ifndef WIN32_CHICAGO
    if (TimeStamp->QuadPart == 0)
#else // WIN32_CHICAGO
    if (*TimeStamp == 0)
#endif // WIN32_CHICAGO
    {
        ZeroMemory(
            ClientTime,
            sizeof(KERB_TIME)
            );
        //
        // For MIT compatibility, time zero is 1/1/70
        //

        ClientTime->year = 1970;
        ClientTime->month = 1;
        ClientTime->day = 1;

        if (ARGUMENT_PRESENT(ClientUsec))

        {
            *ClientUsec  = 0;
        }
        ClientTime->universal = TRUE;
    }
    else
    {
        FileTimeToSystemTime((LPFILETIME) TimeStamp, &TimeFields );

        //
        // Generalized times can only contains years up to four digits.
        //

        if (TimeFields.wYear > 2037)
        {
            ClientTime->year = 2037;
        }
        else
        {
            ClientTime->year = TimeFields.wYear;
        }

        ClientTime->month = (ASN1uint8_t) TimeFields.wMonth;
        ClientTime->day = (ASN1uint8_t) TimeFields.wDay;
        ClientTime->hour = (ASN1uint8_t) TimeFields.wHour;
        ClientTime->minute = (ASN1uint8_t) TimeFields.wMinute;
        ClientTime->second = (ASN1uint8_t) TimeFields.wSecond;

        //
        // MIT kerberos does not support millseconds
        //

        ClientTime->millisecond = 0;

        if (ARGUMENT_PRESENT(ClientUsec))
        {
            //
            // Since we don't include milliseconds above, use the whole
            // thing here.
            //

            *ClientUsec = (TimeStamp->LowPart / 10) % 1000000;
        }

        ClientTime->diff = 0;
        ClientTime->universal = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xkdc_none_12.4.56.0_none_b4e77231192be044
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkdc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28.manifest
XP_MANIFEST_PATH=manifests\x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28.cat
XP_CATALOG_PATH=manifests\x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28.cat
XP_PAYLOAD_PATH=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkdc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xkdc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xkdc_none_12.4.56.0_none_b4e77231192be044
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkdc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28.manifest
XP_MANIFEST_PATH=manifests\x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28.cat
XP_CATALOG_PATH=manifests\x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28.cat
XP_PAYLOAD_PATH=x86_xkdc_no-public-key_12.4.56.0_x-ww_e6a6ee28
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkdc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\DoSComponent.h ===
//--------------------------------------------------------------------
// DOSComponent.h: interface for the CHashTable and CDOSList class.
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  Includes
//--------------------------------------------------------------------
#include <time.h>
#include "cryptkeysref.h"

//--------------------------------------------------------------------
//  Definitions
//--------------------------------------------------------------------

#if !defined(AFX_DOSCOMPONENT_H__D5F38145_64C1_4E36_96BA_E28905DC886F__INCLUDED_)
#define AFX_DOSCOMPONENT_H__D5F38145_64C1_4E36_96BA_E28905DC886F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//--------------------------------------------------------------------
//  Constants
//--------------------------------------------------------------------

// DOS_DATA_SIZE is dependent on the Nodes that will be given to it... these should be adjusted to meet our needs.
#define DOS_DATA_SIZE                                       116
#define DOS_KEY_SIZE                                        XBOX_SERIAL_NUMBER_LEN + XONLINE_PPA_HASH_SIZE

// 20 XMACS hit per hour allowed
const   int c_nACCESS_ALLOWANCE_PER_TIME_PERIOD             = 20;

//--------------------------------------------------------------------
//  TYPES/STRUCTURES
//--------------------------------------------------------------------
typedef enum _DOS_STATE
{
    DOS_INIT = 0,
    DOS_COMPLETE_STAGE1,
    DOS_COMPLETE_ALL
} DOS_STATE;

typedef enum _DOS_RESULT
{
    DOS_FAILURE = 0,
    DOS_OK,
    DOS_ITEM_BUSY,
    DOS_COPY_ONLY,
    DOS_CACHE_TIMEOUT,
    DOS_ACCESS_MAXIMUM,
    DOS_SERVICE_OVERLOAD,
    DOS_INVALID_DATA,
    DOS_ACCESS_MAXIMUM_FIRST,
} DOS_RESULT;

typedef struct _HashListNode
{
    // hash table pointers
    _HashListNode      *m_pHTPrev;
    _HashListNode      *m_pHTNext;
    
} HashListNode;

typedef struct _ListNode
{
    // hash table pointers
    HashListNode       *m_pHTPrev;
    HashListNode       *m_pHTNext;

    // used list node pointer.
    _ListNode          *m_pNext;
    _ListNode          *m_pPrev;

    // values used to track this node.
    BYTE                m_pKey[DOS_KEY_SIZE];

    ULONGLONG           m_ullAccessCount;                 // the number of times this node has been accessed.
    time_t              m_tTimeStamp;                   // the time of the first attempt
    time_t              m_tLastAccess;                  // the time of the last access
    time_t              m_tStage1Cache;                 // the time of the last stage1 cached request.
    time_t              m_tStage2Cache;                 // the time of the last stage2 cached request.
    DOS_STATE           m_dsCurState;                   // the current DOS state.

    DWORD               m_dwOwnerId;                    // the thread id of the owner of this node.  Default 0;
    time_t              m_tAcquired;                    // the time the owner acquired this node.
 
    BYTE                m_pData[DOS_DATA_SIZE];         // addition data to send.
} ListNode;


//--------------------------------------------------------------------
//  Global functions.
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  Class:  CHashTable
//--------------------------------------------------------------------
class CHashTable  
{
public:
    CHashTable();
    virtual ~CHashTable();

    //-----------------------------------------------
    // -- Methods
    HashListNode       *Lookup( const BYTE *pKey );
    void                Insert( ListNode *plnIns );
    void                Delete( ListNode *plnDel );

    // computes the hash function for this table.
    int                 Compute( const BYTE *pKey );

    BOOL                IsValid();

protected:
    //-----------------------------------------------
    // -- Attributes
    HashListNode*       m_pTable;                       // pointer to the table.
    int                 m_nTableSize;                   // size of the table
    int                 m_nNumOfEnt;                    // number of entries

private:
    CRITICAL_SECTION    m_csHashTable;                  // the cs around the hash table.

};

//--------------------------------------------------------------------
//  Class:  DOSList
//--------------------------------------------------------------------
class CDOSList  
{
public:
    CDOSList( int nMaxAllowancePerHour, int nStage1Timeout, int nStage2Timeout, BOOL bDisableDoS = FALSE );
    virtual ~CDOSList();

    //-----------------------------------------------
    //  InitialService:  Looks up a node.  Gets it 
    //       ready for service.
    //-----------------------------------------------
    DOS_RESULT          InitialService( DWORD dwThreadId, const BYTE *pKey, ListNode **ppNode /*out*/ );
    
    //-----------------------------------------------
    //  SecondService: Re-acquires the node for
    //      stage 2 processing.
    //-----------------------------------------------
    DOS_RESULT          SecondService(  DWORD dwThreadId, ListNode *pNode /*in*/ );

    //-----------------------------------------------
    //  ReleaseNode:  Releases threads ownership 
    //          on node.
    //-----------------------------------------------
    BOOL                ReleaseNode( DWORD dwThreadId, ListNode *pNode /*in*/ );
    
    //-----------------------------------------------
    //  Am_I_In_Charge: Used to check if id is still 
    //          in charge of this node.
    //-----------------------------------------------
    inline BOOL         Am_I_In_Charge( DWORD dwThreadId, ListNode *pNode /*in*/ )
    { return ( dwThreadId == pNode->m_dwOwnerId );    }

    //-----------------------------------------------
    //  Lookup:  Lookups up key's entry in table.
    //    The returned value is the key if it exists
    //    otherwise it is NULL.
    //-----------------------------------------------
    ListNode*           Lookup( const BYTE *pKey );

    //-----------------------------------------------
    //  IsValid:  Checks if this object is valid.
    //-----------------------------------------------
    BOOL                IsValid( );

    //
    // Accessor functions
    //
    int                 SetMaxAllowance(int nMaxAllowancePerHour );
    int                 GetMaxAllowance() { return m_nMaxAllow; }
    
    int                 SetStage1Timeout(int nStage1Timeout);
    int                 GetStage1Timeout() { return m_nStage1Timeout; }

    int                 SetStage2Timeout(int nStage2Timeout);
    int                 GetSTage2Timeout() { return m_nStage2Timeout; }

protected:

    //-----------------------------------------------
    // -- Methods
    void                MoveToDoSListHead( ListNode *pNewItem );
    void                ReInitializeNode( ListNode *pItem );

    BOOL                Acquire( DWORD dwThreadId, ListNode *pItem );

    //-----------------------------------------------
    // -- Attributes
    // the DOS list.
    ListNode*           m_pDOSList;                     // the list of entries.
    int                 m_nNumOfEnt;                    // number of entries
    int                 m_nListSize;                    // the size of the list.
    int                 m_nMaxAllow;                    // the maximum allowance per hour.
    int                 m_nStage1Timeout;               // the time out for stage 1 cache info (In seconds)
    int                 m_nStage2Timeout;               // the time out for stage 2 cache info (In seconds)
    BOOL                m_bDisableDoS;                  // signals that DoS should be disabled.

    // the use list.
    ListNode*       m_pListHead;                    // head of the DOS list.

    CHashTable          m_objHashTbl;                   // hash table pointer.

private:
    CRITICAL_SECTION    m_csDOSList;
    CRITICAL_SECTION    m_csAcquire;                    // critical section for the acquire lock.
};

#endif // !defined(AFX_DOSCOMPONENT_H__D5F38145_64C1_4E36_96BA_E28905DC886F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\PcAccountCreation.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// PcAccountCreation.cpp
//
// Xmacs PC account creation
// --------------------------------------------------------------------------------------

#include "xmacsp.h"
#include "baseprovider.h"
#include "baselog.h"
#include "PcAccountCreation.h"

#include <array>

XomImportArea(log);
XomImportArea(XMACS);

// We have 5 different implementations of HMAC-SHA1 in our source tree. Most of them are 
// just copy-and-paste copies. One of them is in cryptohelper.lib, however, adding it to 
// cryptohelper.h breaks all the other projects that have their own implementation but 
// also include cryptohelper.h. I've gotta do something about this. Anyways, this refers 
// to the implementation in cryptohelper.lib

void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    );


// ----------------
// -- PC Structs --
// ----------------

// Parse the pre-auth from a byte array.
// - pbuffer: pointer to buffer
// - cbbuffer: size of the buffer
// Returns:
//  Method returns TRUE if operation succeeded, FALSE if otherwise.
// Remarks:
//  Some of the structure members are just pointers into the external buffer. Don't 
//  release the buffer until you're done referencing this structure as well.
BOOL PA_PC_ACCOUNT_CREATION_REQ::Parse(BYTE* pbuffer, UINT32 cbbuffer)
{
    BOOL ok = TRUE;

    CMemoryStream ms;
    ms.Attach(pbuffer, cbbuffer, cbbuffer);

    ok = ok && ms.GetPointerAndAdvance((void**)&pnonce, NONCE_LENGTH);
    ok = ok && ms.ReadValue(&ticketLen) && IS_BETWEEN(ticketLen, 1, TICKET_MAX_LENGTH);
    ok = ok && ms.GetPointerAndAdvance((void**)&pticket, ticketLen);
    ok = ok && ms.ReadValue(&encDataLen) && IS_BETWEEN(encDataLen, 1, ENC_DATA_MAX_LENGTH);
    ok = ok && ms.GetPointerAndAdvance((void**)&pencData, encDataLen);

    return ok;
}

// Parse the pre-auth from a byte array.
// - pbuffer: pointer to buffer
// - cbbuffer: size of the buffer
// Returns:
//  Method returns TRUE if operation succeeded, FALSE if otherwise.
// Remarks:
//  This structure is self-contained and doesn't depend on external buffers after 
//  parsed.
BOOL PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA::Parse(BYTE* pbuffer, UINT32 cbbuffer)
{
    BOOL ok = TRUE;

    CMemoryStream ms;
    ms.Attach(pbuffer, cbbuffer, cbbuffer);

    ok = ok && ms.ReadBytes(pcId, sizeof(pcId));
    ok = ok && ms.ReadValue(&sponsorTokenLen) && IS_BETWEEN(sponsorTokenLen, 1, XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH);
    ok = ok && ms.ReadBytes(sponsorToken, sponsorTokenLen);

    if(ok)
    {
        // null-terminate sponsor token
        sponsorToken[sponsorTokenLen] = 0;
    }

    return ok;
}

// Parse the pre-auth from a byte array.
// - pbuffer: pointer to buffer
// - cbbuffer: size of the buffer
// Returns:
//  Method returns TRUE if operation succeeded, FALSE if otherwise.
// Remarks:
//  Some of the structure members are just pointers into the external buffer. Don't 
//  release the buffer until you're done referencing this structure as well.
BOOL PA_PC_ACCOUNT_CREATION_REQ2::Parse(BYTE* pbuffer, UINT32 cbbuffer)
{
    BOOL ok = TRUE;

    CMemoryStream ms;
    ms.Attach(pbuffer, cbbuffer, cbbuffer);

    ok = ok && ms.GetPointerAndAdvance((void**)&abEncSessionKey, ENC_SESSION_KEY_SIZE);
    ok = ok && ms.ReadValue(&encDataLen) && IS_BETWEEN(encDataLen, 1, ENC_DATA_MAX_LENGTH);
    ok = ok && ms.GetPointerAndAdvance((void**)&pencData, encDataLen);

    return ok;
}

// Parse the pre-auth from a byte array.
// - pbuffer: pointer to buffer
// - cbbuffer: size of the buffer
// Returns:
//  Method returns TRUE if operation succeeded, FALSE if otherwise.
// Remarks:
//  This structure is self-contained and doesn't depend on external buffers after parsed.
BOOL PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA2::Parse(BYTE* pbuffer, UINT32 cbbuffer)
{
    BOOL ok = TRUE;

    CMemoryStream ms;
    ms.Attach(pbuffer, cbbuffer, cbbuffer);

    ok = ok && ms.ReadBytes(&qwAuthtime, sizeof(qwAuthtime));
    ok = ok && ms.ReadBytes(&pcId, sizeof(pcId));
    ok = ok && ms.ReadValue(&ticketLen) && IS_BETWEEN(ticketLen, 1, TICKET_MAX_LENGTH);
    ok = ok && ms.ReadValue(&sponsorTokenLen) && IS_BETWEEN(sponsorTokenLen, 1, XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH);
    ok = ok && ms.ReadBytes(ticket, ticketLen);
    ok = ok && ms.ReadBytes(sponsorToken, sponsorTokenLen);

    if(ok)
    {
        // null-terminate sponsor token
        sponsorToken[sponsorTokenLen] = 0;
    }

    return ok;
}


// --------------------------------
// -- CPaPcAccountCreationHandler --
// --------------------------------

// Constructor
// - pxmacs: pointer to CXMACSProvider passed in by the factory
// - pkerbRequest: pointer to Kerberos request passed in by the factory
CPaPcAccountCreationHandler::CPaPcAccountCreationHandler(CXMACSProvider* pxmacs, IKerbRequest* pkerbRequest) :
    _xmacsDb(pxmacs)
{
    _pxmacs         = pxmacs;
    _pkerbRequest   = pkerbRequest;
    _status         = 0;
    memset(_principalKey, 0, sizeof(_principalKey));
    memset(&_kerbPrincipalKey, 0, sizeof(_kerbPrincipalKey));
    _passportPuid   = 0;
    memset(&_pcId, 0, sizeof(_pcId));
    _sponsorToken[0] = 0;
    memset(&_sponsorTokenHash, 0, sizeof(_sponsorTokenHash));
    _fSponsorTokenAlreadyUsed = 0;
    _fTitleRequiresActivation = 0;
    _userXuid       = 0;
    _titleId        = 0;
    _machineId      = 0;

    memset(_machineKey, 0, sizeof(_machineKey));
}

// Release
// overriding IPAHandler
// Called by the KDC when it's time to release the handler
void CPaPcAccountCreationHandler::Release(void)
{
    delete this;
}

// CPaPcAccountCreationHandler::ReturnToClient
// overriding IPAHandler
// Creates the machine account and returns the account information to the client.
// - pikerbRequest: the request
// - ppOutPaData(out): the list of pre-auths that the KDC should add to the response.
// Returns:
//  KDC_ERR_NONE if succeeded.
KERBERR CPaPcAccountCreationHandler::ReturnToClient(
    IN  IKerbRequest*       pikerbRequest,
    OUT PKERB_PA_DATA_LIST* ppOutPaData
    )
{
    KERBERR kerberr = KDC_ERR_NO_RESPONSE;
    PKERB_PA_DATA_LIST plistElement = NULL;

    if(!(_status & STATUS_FOUND_PRE_AUTH))
    {
        // not a PC account creation request
        return KDC_ERR_NONE;
    }

    if(!(_status & STATUS_CONSTRUCTED_CLIENT_PRINC))
    {
        XOMASSERT(!"ReturnToClient shouldn't have been called");
        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    kerberr = CreateAccount();
    if(!KERB_SUCCESS(kerberr))
    {
        goto Exit;
    }

    //
    // Fill out reply 
    //

    PA_PC_ACCOUNT_CREATION_REP reply;
    reply.machineId = _machineId;
    C_ASSERT(sizeof(reply.machineKey) == sizeof(_machineKey));
    memcpy(reply.machineKey, _machineKey, sizeof(reply.machineKey));

    //
    // Encrypt, pack and add it to the pre-auth list
    //

    plistElement = (PKERB_PA_DATA_LIST) _pxmacs->KdcAllocMemory(sizeof(KERB_PA_DATA_LIST));

    if(!plistElement)
    {
        XomNtEvent(
            XEVENT_XMACS_CODE_MEMORY_ALLOCATION_ERROR, 
            "Failed to allocate memory for pListElement");

        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    memset(plistElement, 0, sizeof(*plistElement));

    plistElement->value.preauth_data_type   = KRB5_PADATA_PC_ACCOUNT_CREATION;

    C_ASSERT(sizeof(plistElement->value.preauth_data.value) == sizeof(PVOID));
    C_ASSERT(sizeof(plistElement->value.preauth_data.length) == sizeof(UINT32));

    kerberr = EncryptReply(
        (BYTE*) &reply, 
        sizeof(reply), 
        (PVOID*)&plistElement->value.preauth_data.value,
        (UINT32*)&plistElement->value.preauth_data.length);

    if(!KERB_SUCCESS(kerberr))
    {
        goto Exit;
    }

    // add it to the beginning of the list

    plistElement->next = *ppOutPaData;
    *ppOutPaData = plistElement;
    plistElement = NULL;

    kerberr = KDC_ERR_NONE;

Exit:

    if(plistElement)
    {
        if(plistElement->value.preauth_data.value)
        {
            _pxmacs->KdcFreeMemory(plistElement->value.preauth_data.value);
        }

        _pxmacs->KdcFreeMemory(plistElement);
    }

    return kerberr;
}

// SetStatus
// Set request status flag.
//  - status: one of the STATUS_* constants
// Remarks:
// The status member tracks request progress. It's logged in both NT events and 
// request log entries and provide can provide details on request failures
void CPaPcAccountCreationHandler::SetStatus(STATUS status)
{
    _status |= status;
}

// CPaPcAccountCreationHandler::Audit
// Called by CXMACSProvider to give us a chance to log information about the request.
//  - auditId: kerberos audit type - depends on the request type and whether it succeeded 
//  or not
//  - pKerbRequest: kerberos request
//  - pClientAddress: the IP address of the client
//  - kerberr: kerberos error. It will be KDC_ERR_NONE if no error occurred.
//  - pPreauthType: in case of a pre-auth failure, this will point to the corresponding 
//  pre-auth type id. Otherwise it will be NULL.
NTSTATUS CPaPcAccountCreationHandler::Audit(
    KDC_AUDIT_EVENT auditId,
    IKerbRequest*   pKerbRequest,
    SOCKADDR*       pClientAddress,
    KERBERR         kerberr,
    PULONG          pPreauthType
    )
{
    // This method will be called for Xbox and Xenon requests as well but we only want to 
    // log stuff if this was a PC account creation. We can determine if the request is a 
    // PC account creation request if the PC account creation preauth was detected. We 
    // can use the _status field for that.

    if(!(_status & STATUS_FOUND_PRE_AUTH))
    {
        // Not a PC machine account creation request
        return STATUS_SUCCESS;
    }

    // Derive whether this is a success or a failure from the audit event type

    BOOL ok;

    switch(auditId)
    {
    case AsTicket:
    case TgsSuccess:
    case TgsTicketRequest:
        ok = TRUE;
        break;

    default:
        ok = FALSE;
    }

    // Determine the logline identifier

    const char *loglinePrefix = "PCACC?";
    switch (GetProcessedPAType())
    {
        case KRB5_PADATA_PC_ACCOUNT_CREATION:
        {
            loglinePrefix = "PCACC";
            break;
        }
        case KRB5_PADATA_PC_ACCOUNT_CREATION2:
        {
            loglinePrefix = "PCACC2";
            break;
        }
    }

    // Log

    XomLog(
        log, "%s|%s|0x%I64X|0x%I64X|%s|%s|%s|%d|0x%X|%d|0x%I64X|%u|%s|0x%x|0x%x|0x%x|%d",
        loglinePrefix,
        ok ? "1" : "0",
        _passportPuid,
        _userXuid,
        (LPCSTR)PC_ID::ToString(_pcId),
        _sponsorToken,
        (LPCSTR)TOKEN_HASH::ToString(_sponsorTokenHash),
        _fSponsorTokenAlreadyUsed,
        _titleId,
        _fTitleRequiresActivation,
        _machineId,
        _consoleTypeFlags,
        CStrUtil().FormatIpN(((sockaddr_in*)pClientAddress)->sin_addr.s_addr),
        kerberr,
        pPreauthType ? *pPreauthType : 0,
        _status,
        pKerbRequest->GetElapsedTimeInMs());

    // NT event log

    if(!ok)
    {
        if(kerberr != KRB_AP_ERR_SKEW &&            // Clock skew errors are common and expected
           !(_status & STATUS_DONT_LOG_NT_EVENT))   // We indicated that we should not log an event
        {
            XomNtEvent(
                XEVENT_XMACS_PC_ACCOUNT_CREATION_FAILED,
                "PC account creation failed. A previous event should contain the reason."
                " ClientAddress: %s Kerberr: 0x%x Status: 0x%x",
                CStrUtil().FormatIpN(((sockaddr_in*)pClientAddress)->sin_addr.s_addr),
                kerberr,
                _status);
        }
        g_Counters.IncrementValue32(XMACSPERF_SERVER_INVALID_REQUEST_COUNTER, 1);
    }

    return STATUS_SUCCESS;
}

// CPaPcAccountCreationHandler::EncryptReply
// Encrypt response blob using KERB_ETYPE_RC4_HMAC_NT and encoded it using ASN.1 DER (the 
// pdu is KERB_ENCRYPTED_DATA_PDU).
// - preply: pointer to reply buffer
// - replyLength: size of the reply in bytes
// - ppencData: pointer to a pointer to receive the allocated buffer. This buffer must be 
// released later using IKdcCore::KdcFreeMemory (or the _pxmacs->KdcFreeMemory)
// - pencDataLength: sizeo of the data returned in ppencData
// Remarks:
//  Don't forget to release the buffer returned in ppencData!
KERBERR CPaPcAccountCreationHandler::EncryptReply(
    BYTE*       preply,
    UINT32      replyLength,
    OUT PVOID*  ppencData,
    OUT UINT32* pencDataLength
    )
{
    KERB_ENCRYPTED_DATA encdata;
    IKerbCrypt* pcrypt;
    CLargeBuffer cipherText;
    KERBERR kerberr = KDC_ERR_NO_RESPONSE;

    pcrypt = _pxmacs->GetKdcCore()->pfnKdcGetICrypt();
    XOMASSERT(pcrypt);

    memset(&encdata, 0, sizeof(encdata));
    encdata.encryption_type = KERB_ETYPE_RC4_HMAC_NT;

    // Use crypt object to determine the size of the final cipher text blob

    kerberr = pcrypt->GetCiphertextSize(
        KERB_ETYPE_RC4_HMAC_NT,
        replyLength,
        &encdata.cipher_text.length);

    if(!KERB_SUCCESS(kerberr))
    {
        XomNtEvent(
            XEVENT_XMACS_CODE_FAILED_TO_GET_CIPHERTEXT_SIZE,
            "Failed to get ciphertext size for PC account creation reply. "
            "kerberr=0x%x", kerberr);

        kerberr = _pxmacs->SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto Exit;
    }

    // Make sure our buffer is large enough. It will expand if necessary.

    if(!cipherText.SetCapacity(encdata.cipher_text.length))
    {
        XomNtEvent(
            XEVENT_XMACS_CODE_MEMORY_ALLOCATION_ERROR, 
            "Failed to allocate memory for ciphertext");

        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    encdata.cipher_text.value = (ASN1octet_t*) cipherText.GetPtr();

    // Use crypt object to encryt data

    kerberr = pcrypt->Encrypt(
        &_kerbPrincipalKey,
        0 /* ulKeyVersion */,
        KERB_PA_PC_ACCOUNT_CREATION_REP_SALT,
        preply,
        replyLength,
        &encdata);

    if(!KERB_SUCCESS(kerberr))
    {
        XomNtEvent(
            XEVENT_XMACS_CODE_FAILED_TO_ENCRYPT_REPLY,
            "Failed to encrypt PC account creation reply. kerberr=0x%x", kerberr);

        goto Exit;
    }

    // Encode using ASN.1 DER

    C_ASSERT(sizeof(*pencDataLength) == sizeof(ULONG));
    kerberr = _pxmacs->GetKdcCore()->pfnKerbPackData(
        &encdata,
        KERB_ENCRYPTED_DATA_PDU,
        (PULONG) pencDataLength,
        (PUCHAR*) ppencData);

    if(!KERB_SUCCESS(kerberr))
    {
        XomNtEvent(
            XEVENT_XMACS_CODE_FAILED_TO_PACK_REPLY,
            "Failed to pack PC account creation reply. kerberr=0x%x", kerberr);

        goto Exit;
    }

    kerberr = KDC_ERR_NONE;

Exit:

    return kerberr;
}

// CPaPcAccountCreationHandler::GamertagFromMachineId
// Format a PC "gamertag" given a machine-id.
//  - machineId: machine-id of the PC
//  - pGamertag (OUT): receives PC gamertag
// Returns:
//  TRUE if succeeded, FALSE if failed (usually because pGamertag's capacity is not large 
//  enough)
// Remarks:
//  Xbox consoles use their serial number as their gamertag, Xenon consoles use their 
//  console-id. PCs have neither but it needs something to send to the ASKDC as the 
//  client name. The decision was to use the machine-id to format a unique gamertag using 
//  the following format:
//    PC.<12-digit-machine-id-in-hex>
//  E.g.
//  If the machine-id is 0xFB00112233445566, then the gamertag would be "PC.112233445566"
//  This fits perfectly on the 15 characters maximum gamertag size. It's safe to ignore 
//  the most significant WORD of the machine-id because it's always the same for PC 
//  machine ids (0xFB00)
BOOL CPaPcAccountCreationHandler::GamertagFromMachineId(
    UINT64 machineId,
    OUT CStr* pGamertag
)
{
    pGamertag->Format("PC.%012I64X", (machineId & ~PUID_BASE_MASK));
    return !pGamertag->HasFailedOrTruncated();
}

// CPaPcAccountCreationHandler::CreateAccount
// Create a machine account for the token,pcId pair if one doesn't exist already. If the 
// account already exists, the current account is reset (a new key is generated).
// Returns:
//  KDC_ERR_NONE if succeeded
//  KDC_ERR_SVC_UNAVAILABLE on weird errors
KERBERR CPaPcAccountCreationHandler::CreateAccount()
{
    KERBERR kerberr = KDC_ERR_SVC_UNAVAILABLE;
    XOCryptoIVStruct iV;
    XOCryptoKeyStruct encryptedKey;
    XOCryptoKeyStruct rawKey;
    XOCryptoSPPAStruct bSPPA;
    XOCryptoPPAStruct  bPPA;
    HRESULT hr;

    CXmacsDb::PcAccountLookupStatus lookupStatus;
    CComBSTR bstrMagicToken;
    TLocalWStr<XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH> tokenw;

    _consoleTypeFlags = PC_MACHINE_TYPE_NORMAL;

    // Is the sponsorToken a "Magic 5x5"? Please note, despite the plurality of the name, 
    // that this is not a delimited token list. It is a single token that must match 
    // exactly. Sorry for the confusion, things have changed.
    _pxmacs->GetLimitedTokens(&bstrMagicToken);

    if (bstrMagicToken.m_str != NULL)
    {
        // Convert token to unicode
        tokenw.Format(L"%S", _sponsorToken);
        if (!tokenw.IsEmpty())
        {
            tokenw.ToUpper();
            if (wcscmp(bstrMagicToken, tokenw.cstr()) == 0)
            {
                _consoleTypeFlags = PC_MACHINE_TYPE_LIMITED;
                GenerateUserPUIDHash();
                _status |= STATUS_PC_SENT_SPECIAL_TOKEN;
            }
        }
    }

    // Need to know the xuid when looking up the account, to enforce 1 5x5 per account. We 
    // like xuid more than passport puid b/c we don't have to worry about passport 
    // switching.
    hr = _xmacsDb.GetXboxUserByPassport(_passportPuid, &_userXuid);

    // @@@kgoodier REVIEW user not found is ok, for now
    if (hr != XONLINE_E_ACCOUNTS_INVALID_USER && FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Exit;
    }

    // Go look everything up
    hr = _xmacsDb.PcAccountLookup(_sponsorTokenHash, _pcId, _userXuid, &lookupStatus, &_machineId, &_titleId, &_fSponsorTokenAlreadyUsed, &_fTitleRequiresActivation);
    if (FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Exit;
    }

    if(lookupStatus == CXmacsDb::PcAccountLookupSucceeded)
    {
        // Account already exist. Reset account.
        _status |= STATUS_PC_ACCOUNT_EXISTS;
        if (_titleId == 0)
        {
            // if the hash wasn't tied to a title it was created using the Panorama System TitleId
            _titleId = XONLINE_PC_DASH_TITLE_ID;
        }
        return ResetAccount();
    }
    else if(lookupStatus == CXmacsDb::PcAccountLookupVoucherInvalid)
    {
        if ((_consoleTypeFlags & PC_MACHINE_TYPE_LIMITED) == 0)
        {
            _status |= STATUS_DONT_LOG_NT_EVENT;
            return KDC_ERR_XBOX_TOKEN_INVALID;
        }
        else
        {
            //put the voucher in uodb
            hr = _xmacsDb.UODBAddPUIDVoucher(_sponsorTokenHash);
            if (SUCCEEDED(hr))
            {
                lookupStatus = CXmacsDb::PcAccountLookupNotFound;
                _status |= STATUS_PC_PUID_VOUCHER_ADDED;
            }
            else if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
            {
                kerberr = KDC_ERR_SERVICE_NOTYET;
            }
            else
            {
                _status |= STATUS_DONT_LOG_NT_EVENT;
                return KDC_ERR_XBOX_TOKEN_INVALID;
            }
        }
    }
    else if(lookupStatus == CXmacsDb::PcAccountLookupVoucherBanned)
    {
        _status |= STATUS_DONT_LOG_NT_EVENT;
        return KDC_ERR_XBOX_TOKEN_BANNED;
    }
    else if(lookupStatus == CXmacsDb::PcAccountLookupVoucherUsageExceeded)
    {
        _status |= STATUS_DONT_LOG_NT_EVENT;
        return KDC_ERR_XBOX_TOKEN_USAGE_EXCEEDED;
    }
    else if(lookupStatus == CXmacsDb::PcAccountLookupVoucherInUse)
    {
        _status |= STATUS_DONT_LOG_NT_EVENT;
        return KDC_ERR_XBOX_TOKEN_IN_USE;
    }
    else if(lookupStatus != CXmacsDb::PcAccountLookupNotFound)
    {
        return KDC_ERR_SVC_UNAVAILABLE;
    }

    // Generate a new PC machine id

    hr = _pxmacs->GeneratePcPuid(&_machineId);
    if(FAILED(hr))
    {
        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    // convert machine-id to a gamertag

    GamertagFromMachineId(_machineId, &_gamertag);

    _status |= STATUS_GENERATED_NEW_MACHINE_ID;

    // Generate new key stuff

    if(!_pxmacs->GetCryptoHelper()->GenerateNewKey(&iV, &encryptedKey, &rawKey))
    {
        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    // And the anti-DoS stuff

    if (!GenPPAforDB(_gamertag.cstr(), &rawKey, &bSPPA, &bPPA ))
    {
        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    _status |= STATUS_GENERATED_NEW_KEY;

    // Write machine account information to t_pc_accounts (partitioned by token)

    hr = _xmacsDb.PcAccountCreate(
        _sponsorTokenHash,
        _pcId,
        _machineId,
        _passportPuid);
    if(FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Exit;
    }

    _status |= STATUS_DB_WRITE_TO_PC_ACCOUNTS;

    // Write machine name and keys to t_user_names and t_user_keys (partitioned by 
    // gamertag)

    hr = _xmacsDb.UODBResetPasswordMachinePC(
        _gamertag.cstr(),
        _machineId,
        c_nXMACS_KEY_VERSION,
        encryptedKey,
        iV,
        bPPA,
        bSPPA);
    if(FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Exit;
    }

    _status |= STATUS_DB_WRITE_TO_USER_NAMES;

    // Write machine id to t_machines (partitioned by machine-id)

    hr = _xmacsDb.UODBMachinePCUpdatePuid(
        _gamertag.cstr(),
        _machineId,
        _consoleTypeFlags
        );
    if(FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Exit;
    }

    _status |= STATUS_DB_WRITE_TO_MACHINES;
    if (_titleId == 0)
    {
        // leave the titleId alone if the voucher is associated with the PUID
        if ((_status & STATUS_PC_PUID_VOUCHER_ADDED) == 0)
        {
            // if the hash wasn't tied to a title it was created using the Panorama System TitleId
            _titleId = XONLINE_PC_DASH_TITLE_ID;
        }
    }

    // Title Activation. May not do anything, but we should call it anyway.
    kerberr = ActivateTitle();
    if (!KERB_SUCCESS(kerberr))
    {
        goto Exit;
    }

    // Remember the key we just generated. It's the machine account key which we'll return 
    // to the client.

    C_ASSERT(sizeof(_machineKey) == sizeof(rawKey.abKey));
    memcpy(_machineKey, rawKey.abKey, sizeof(_machineKey));

    kerberr = KDC_ERR_NONE;

    // Update perf counters

    switch (GetProcessedPAType())
    {
        case KRB5_PADATA_PC_ACCOUNT_CREATION:
        {
            g_Counters.IncrementValue32(XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_PC_RATE, 1);
            break;
        }
        case KRB5_PADATA_PC_ACCOUNT_CREATION2:
        {
            g_Counters.IncrementValue32(XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_PC2_RATE, 1);
            break;
        }
    }

    if (_consoleTypeFlags != PC_MACHINE_TYPE_NORMAL)
    {
        g_Counters.IncrementValue32(XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_LIMITED_RATE,1);
    }

Exit:

    return kerberr;
}

// CPaPcAccountCreationHandler::ResetAccount
// Reset the PC machine account (generate a new machine key)
// Returns:
//  KDC_ERR_NONE if succeeded
//  KDC_ERR_SVC_UNAVAILABLE on weird errors
KERBERR CPaPcAccountCreationHandler::ResetAccount()
{
    BOOL bIsFound;
    HRESULT hr;
    KERBERR kerberr = KDC_ERR_SVC_UNAVAILABLE;
    XOCryptoIVStruct iV;
    XOCryptoKeyStruct encryptedKey;
    XOCryptoKeyStruct rawKey;
    XOCryptoSPPAStruct bSPPA;
    XOCryptoPPAStruct  bPPA;
    FILETIME ftResetDate;
    FILETIME ftBlockDate;

    // Look up the row in t_machines. Read the block date and the reset date.
    
    hr = _xmacsDb.UODBMachineLookup(_machineId, &ftBlockDate, &ftResetDate, &bIsFound);

    if(FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Exit;
    }

    _status |= STATUS_DB_MACHINE_LOOKUP;

    //
    // PS Bug # 18273
    // 
    // Add a check to see if the machine exists before deciding that it is banned. This
    // is because the default values for the block date are 0.0, which always convert
    // to a value that is less than now. So for the case where the machine doesn't
    // exist properly, we want to bypass the ban check
    // 
    if (bIsFound == TRUE) 
    {
        // Check if machine is blocked (banned) by comparing the blocked date to the current 
        // time. If blocked date is in the past, the machine is banned.

        SYSTEMTIME now;
        ::GetSystemTime(&now);

        FILETIME ftnow;
        ::SystemTimeToFileTime(&now, &ftnow);

        if(*((ULONGLONG*)&ftBlockDate) < *((ULONGLONG*)&ftnow))
        {
            // Machine is currently blocked. Don't return a response.
            // This is relatively common. Don't log an event.
            _status |= STATUS_DONT_LOG_NT_EVENT;
            kerberr = _pxmacs->SilentKerbErr(KDC_ERR_NO_RESPONSE);
            goto Exit;
        }
    }

    _status |= STATUS_MACHINE_IS_NOT_BLOCKED;

    // convert machine-id to a gamertag

    GamertagFromMachineId(_machineId, &_gamertag);

    // Generate new key stuff

    if(!_pxmacs->GetCryptoHelper()->GenerateNewKey(&iV, &encryptedKey, &rawKey))
    {
        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    // And the anti-DoS stuff

    if (!GenPPAforDB(_gamertag.cstr(), &rawKey, &bSPPA, &bPPA ))
    {
        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    _status |= STATUS_GENERATED_NEW_KEY;

    // Reset account key

    hr = _xmacsDb.UODBResetPasswordMachinePC(
        _gamertag.cstr(), 
        _machineId,
        c_nXMACS_KEY_VERSION,
        encryptedKey,
        iV,
        bPPA,
        bSPPA);

    if(FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Exit;
    }

    _status |= STATUS_DB_RESET_KEY;

    // Update account reset date in t_machines (and if machine creation failed earlier, 
    // heal by inserting the row in t_machines)

    hr = _xmacsDb.UODBMachinePCUpdatePuid(
        _gamertag.cstr(), 
        _machineId,
        _consoleTypeFlags
        );

    if(FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Exit;
    }

    _status |= STATUS_DB_UPDATED_RESET_DATE;

    // Title Activation. May not do anything, but we should call it anyway.
    kerberr = ActivateTitle();
    if (!KERB_SUCCESS(kerberr))
    {
        goto Exit;
    }

    // Remember the key we just generated. It's the machine account key which we'll 
    // return to the client.

    C_ASSERT(sizeof(_machineKey) == sizeof(rawKey.abKey));
    memcpy(_machineKey, rawKey.abKey, sizeof(_machineKey));

    kerberr = KDC_ERR_NONE;

    // Update perf counters

    switch (GetProcessedPAType())
    {
        case KRB5_PADATA_PC_ACCOUNT_CREATION:
        {
            g_Counters.IncrementValue32(XMACSPERF_SERVER_SUCCESS_PWD_RESET_PC_RATE, 1);
            break;
        }
        case KRB5_PADATA_PC_ACCOUNT_CREATION2:
        {
            g_Counters.IncrementValue32(XMACSPERF_SERVER_SUCCESS_PWD_RESET_PC2_RATE, 1);
            break;
        }
    }

    if (_consoleTypeFlags != PC_MACHINE_TYPE_NORMAL)
    {
        g_Counters.IncrementValue32(XMACSPERF_SERVER_SUCCESS_PWD_RESET_LIMITED_RATE, 1);
    }

Exit:

    return kerberr;
}

// CPaPcAccountCreationHandler::GenerateSponsorTokenHash
// Generate the hash of the sponsor token stored in _sponsorToken
void CPaPcAccountCreationHandler::GenerateSponsorTokenHash()
{
    // Convert token to upper-case unicode
    TLocalWStr<XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH> tokenw;
    tokenw.Format(L"%S", _sponsorToken).ToUpper();

    // Calculate hash - include the NULL terminator
    C_ASSERT(sizeof(_sponsorTokenHash.hash) == A_SHA_DIGEST_LEN);
    A_SHA_CTX shactx;
    A_SHAInit(&shactx);
    A_SHAUpdate(&shactx, (unsigned char*) tokenw.cstr(), 
                (tokenw.GetLength()+1) * sizeof(WCHAR));
    A_SHAFinal(&shactx, _sponsorTokenHash.hash);
}

// CPaPcAccountCreationHandler::GenerateUserPUIDHash
// Generate the hash of the user puid and store in _sponsorTokenHash
void CPaPcAccountCreationHandler::GenerateUserPUIDHash()
{
    // Calculate hash
    C_ASSERT(sizeof(_sponsorTokenHash.hash) == A_SHA_DIGEST_LEN);
    A_SHA_CTX shactx;
    A_SHAInit(&shactx);
    //add the puid twice for more entropy
    A_SHAUpdate(&shactx, (unsigned char*)&_passportPuid, sizeof(_passportPuid));
    A_SHAUpdate(&shactx, (unsigned char*)&_passportPuid, sizeof(_passportPuid));
    A_SHAFinal(&shactx, _sponsorTokenHash.hash);
}

// CPaPcAccountCreationHandler::ActivateTitle
// Records usage of token in tokendb by user. Writes to machine and user title activation 
// tables in uodb.
KERBERR CPaPcAccountCreationHandler::ActivateTitle()
{
    KERBERR kerberr = KDC_ERR_SVC_UNAVAILABLE;
    HRESULT hr;

    // Need to handle the special test-only tokens. They must never be consumed (in 
    // tokendb..t_vouchers_used), since that table is what enforces the 1 user per 5x5.  
    // That is definitely not true for test vouchers.

    if (stricmp(TEST_PC_ACCOUNT_CREATION_VOUCHER, _sponsorToken) == 0)
    {
        // Activate the wild-card title-id 0 only. Do not record usage of this token by 
        // the user, as we share the test tokens among many people.
        return RecordTitleIdActivation(0);
    }

    // We don't want to activate titles that don't require activation -- this is the 
    // mechanism by which we detect the XONLINE_E_LOGON_OTHER_TITLE_ACTIVATED error code.  
    // This means you used an SSA token for a non-SSA title, and we block that in the 
    // XKDC. 

    if (_fTitleRequiresActivation)
    {

        // Write token (voucher) redemption for user to tokendb (partitioned by token)

        if (!_fSponsorTokenAlreadyUsed && _userXuid != 0)
        {
            hr = _xmacsDb.UseVoucher(
                _sponsorTokenHash,
                _userXuid);

            if (FAILED(hr))
            {
                if (hr == XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED) // 0x80154009, XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED
                {
                    _status |= STATUS_DONT_LOG_NT_EVENT;
                    kerberr = KDC_ERR_XBOX_TOKEN_IN_USE;
                }
                else if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
                {
                    kerberr = KDC_ERR_SERVICE_NOTYET;
                }
                else
                {
                    kerberr = KDC_ERR_SVC_UNAVAILABLE;
                }
                goto Exit;
            }

            _status |= STATUS_DB_VOUCHERS_USED;
        }
    }

    // Write title and machine to uodb t_machine_title_activations (partitioned by 
    // machine-id). Test vouchers activate title-id 0, which is a wildcard.

    if (_titleId != 0)
    {
        kerberr = RecordTitleIdActivation(_titleId);

        if (!KERB_SUCCESS(kerberr))
        {
            goto Exit;
        }
    }

    kerberr = KDC_ERR_NONE;

Exit:

    return kerberr;
}

// CPaPcAccountCreationHandler::RecordTitleIdActivation
// Writes entry to machine and user title activation tables in uodb.
KERBERR CPaPcAccountCreationHandler::RecordTitleIdActivation(UINT32 titleIdToActivate)
{
    KERBERR kerberr = KDC_ERR_SVC_UNAVAILABLE;
    HRESULT hr;

    // Write title and machine to uodb t_machine_title_activations (partitioned by 
    // machine-id). Test vouchers activate title-id 0, which is a wildcard.

    hr = _xmacsDb.ActivateTitleForMachine(
        _machineId,
        titleIdToActivate,
        CXmacsDb::CONSOLETYPE_PC);

    if (FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Exit;
    }

    _status |= STATUS_DB_MACHINE_ACTIVATION;

    // Write title and user to uodb t_user_title_activations (partitioned by user-id).

    if (_userXuid != 0)
    {
        hr = _xmacsDb.ActivateTitleForUser(
            _userXuid,
            titleIdToActivate,
            CXmacsDb::CONSOLETYPE_PC);

        if (FAILED(hr))
        {
            if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
            {
                kerberr = KDC_ERR_SERVICE_NOTYET;
            }
            else
            {
                kerberr = KDC_ERR_SVC_UNAVAILABLE;
            }
            goto Exit;
        }

        _status |= STATUS_DB_USER_ACTIVATION;
    }

    kerberr = KDC_ERR_NONE;

Exit:

    return kerberr;
}

// QueryInterface
// overriding IPAHandler
// Returns an interface given the interface id.
//  - intf : interface id (GUID)
//  - ppv : pointer to interface corresponding to interface id
// Returns:
//  This method returns S_OK if succeeded or E_NOINTERFACE if the object doesn't 
//  support the interface that was requested.
HRESULT __stdcall CPaPcAccountCreationHandler::QueryInterface(REFIID intf, PVOID *ppv)
{
    if (IsEqualIID(intf, GetGuid()))
    {
        *ppv = (PVOID)(CPaPcAccountCreationHandler*)this;
        return  S_OK;
    }

    return E_NOINTERFACE;
}

// I get the feeling that IPAHandler was not designed to have a single instance handle multiple different preauths.
// Following what was done recently for Xenon and returning V1 always, even though it will be wrong part of the time.
ULONG CPaPcAccountCreationHandler::GetPAType()
{
    return KRB5_PADATA_PC_ACCOUNT_CREATION;
}

// Returns the pc preauth type that was handled by Process or KRB5_PADATA_PC_ACCOUNT_CREATION if unknown.
ULONG CPaPcAccountCreationHandler::GetProcessedPAType()
{
    UINT32 paTypeUsed = KRB5_PADATA_PC_ACCOUNT_CREATION;
    if (_status & STATUS_PREAUTH_V2)
    {
        paTypeUsed = KRB5_PADATA_PC_ACCOUNT_CREATION2;
    }
    return paTypeUsed;
}

// CPaPcAccountCreationHandler::DecryptPreAuth
// Decrypt and parse encrypted portion of pre-auth data
//  - pencData: pointer to encrypted data
//  - encDataLen: size in bytes of the encrypted data
//  - pdata (out): pointer to structure to receive the decrypted and parsed pre-auth data
// Returns:
//  Method returns FALSE if operation fails
template <typename PaType>
BOOL CPaPcAccountCreationHandler::DecryptPreAuth(
    BYTE*   pencData,
    UINT32  encDataLen,
    OUT PaType* pdata)
{
    IKerbCrypt* pikerbCrypt;
    KERBERR kerberr;
    KERB_ENCRYPTED_DATA* pUnpacked = NULL;
    IKdcCore* pKdcCore;
    BOOL ok = FALSE;

    pKdcCore = _pxmacs->GetKdcCore();

    // Unpack data
    kerberr = pKdcCore->pfnKerbUnpackData(
        pencData,
        encDataLen,
        KERB_ENCRYPTED_DATA_PDU,
        (void**) &pUnpacked);

    if(!KERB_SUCCESS(kerberr))
    {
        XomNtEvent(
            XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH_2,
            "Failed to unpack PC account creation pre-auth encrypted portion.");

        goto Exit;
    }

    _status |= STATUS_UNPACKED_PRE_AUTH;

    // Decrypt
    pikerbCrypt = pKdcCore->pfnKdcGetICrypt();
    XOMASSERT(pikerbCrypt);

    std::tr1::array<BYTE, PaType::ENC_DATA_MAX_LENGTH> scratch;
    ULONG scratchLen = scratch.size();

    kerberr = pikerbCrypt->Decrypt(
        pUnpacked,
        &_kerbPrincipalKey,
        KERB_PA_PC_ACCOUNT_CREATION_SALT,
        scratch.data(),
        &scratchLen);

    if(!KERB_SUCCESS(kerberr))
    {
        XomNtEvent(
            XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH_3,
            "Failed to decrypt PC account creation pre-auth encrypted portion.");

        goto Exit;
    }

    _status |= STATUS_DECRYPTED_PRE_AUTH;

    // Parse
    if(!pdata->Parse(scratch.data(), scratchLen))
    {
        XomNtEvent(
            XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH_4,
            "Failed to parse PC account creation pre-auth encrypted portion.");

        goto Exit;
    }

    _status |= STATUS_PARSED_ENC_PRE_AUTH;

    ok = TRUE;

Exit:

    if(pUnpacked)
    {
        pKdcCore->pfnKerbFreeData(KERB_ENCRYPTED_DATA_PDU, pUnpacked);
    }

    return ok;
}

// CPaPcAccountCreationHandler::Process
// Process the pre-auth in the request. Should be called by GetPrincipal when 
// retrieving the client's principal. The main reason why it should be called there 
// is because this pre-auth will provide the principal's key. It also provides the 
// means to authenticate the client.
// - pikerbRequest: the request
// Returns:
//  KDC_ERR_NONE if succeeded.
KERBERR CPaPcAccountCreationHandler::Process(IKerbRequest* pikerbRequest)
{
    KERBERR             kerberr = KDC_ERR_NO_RESPONSE;
    ASN1octetstring_t*  padata1 = NULL;
    ASN1octetstring_t*  padata2 = NULL;
    in_addr*            pInAddr = &(((PSOCKADDR_IN)pikerbRequest->GetClientAddress())->sin_addr); 
    PA_PC_ACCOUNT_CREATION_REQ  req1 = {0};
    PA_PC_ACCOUNT_CREATION_REQ2 req2 = {0};

    // Find the pre-auth in the request
    padata1 = GetPaData(pikerbRequest, KRB5_PADATA_PC_ACCOUNT_CREATION);
    padata2 = GetPaData(pikerbRequest, KRB5_PADATA_PC_ACCOUNT_CREATION2);

    // Verify that all required pre-auth types, and only them, were specified in the request.
    if (padata1)
    {
        _status |= STATUS_FOUND_PRE_AUTH;

        static const std::tr1::array<UINT32, 2> allowedPreAuths = {
            KRB5_PADATA_PC_ACCOUNT_CREATION, // this is us
            KRB5_PADATA_ENC_TIMESTAMP        // standard kerberos encryped timestamp
            };

        if(!VerifyPaList(pikerbRequest, allowedPreAuths.data(), allowedPreAuths.size(), NULL, 0))
        {
            XomNtEvent(
                XEVENT_XMACS_HACK_INVALID_PRE_AUTH_TYPE,
                "Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once.\n"
                "Client type: PC1\n"
                "Client IP: "DBGINAFMT"\n",
                DBGINAPRM(pInAddr));
            kerberr = KDC_ERR_NO_RESPONSE;
            goto Exit;
        }
    }
    else if (padata2)
    {
        _status |= STATUS_FOUND_PRE_AUTH;
        _status |= STATUS_PREAUTH_V2;

        static const std::tr1::array<UINT32, 2> allowedPreAuths = {
            KRB5_PADATA_PC_ACCOUNT_CREATION2, // this is us
            KRB5_PADATA_ENC_TIMESTAMP        // standard kerberos encryped timestamp
            };

        if(!VerifyPaList(pikerbRequest, allowedPreAuths.data(), allowedPreAuths.size(), NULL, 0))
        {
            XomNtEvent(
                XEVENT_XMACS_HACK_INVALID_PRE_AUTH_TYPE,
                "Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once.\n"
                "Client type: PC2\n"
                "Client IP: "DBGINAFMT"\n",
                DBGINAPRM(pInAddr));
            kerberr = KDC_ERR_NO_RESPONSE;
            goto Exit;
        }
    }
    else
    {
        XOMASSERT(!"CPaPcAccountCreationHandler::Process should not have been called");
        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    _status |= STATUS_VERIFIED_PRE_AUTH_LIST;

    // Each preauth is handled separately
    if (padata1)
    {
        // Parse pre-auth
        if(!req1.Parse(padata1->value, padata1->length))
        {
            XomNtEvent(
                XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH,
                "Failed to parse PC1 account creation pre-auth.\n"
                "Client IP: "DBGINAFMT"\n",
                DBGINAPRM(pInAddr));
            kerberr = KDC_ERR_NO_RESPONSE;
            goto Exit;
        }

        _status |= STATUS_PARSED_PRE_AUTH;

        kerberr = ProcessV1(pikerbRequest, &req1);
    }
    else if (padata2)
    {
        // Parse pre-auth
        if (!req2.Parse(padata2->value, padata2->length))
        {
            XomNtEvent(
                XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH,
                "Failed to parse PC2 account creation pre-auth.\n"
                "Client IP: "DBGINAFMT"\n",
                DBGINAPRM(pInAddr));
            kerberr = KDC_ERR_NO_RESPONSE;
            goto Exit;
        }

        _status |= STATUS_PARSED_PRE_AUTH;

        kerberr = ProcessV2(pikerbRequest, &req2);

    }

    if (kerberr != KDC_ERR_NONE)
    {
        goto Exit;
    }

    GenerateSponsorTokenHash();

    kerberr = KDC_ERR_NONE;

Exit:
    if (KERB_SUCCESS( kerberr ) == FALSE) 
    {
        _pxmacs->SilentKerbErr( kerberr );
    }
    return kerberr;
}

// Process the pre-auth in the request.  Contains the implementation details of Process for a V1 request
KERBERR CPaPcAccountCreationHandler::ProcessV1(IKerbRequest* pikerbRequest, PA_PC_ACCOUNT_CREATION_REQ *pPcRequest)
{
    HRESULT             hr     = S_OK;
    KERBERR             kerberr = KDC_ERR_NO_RESPONSE;
    CTinyBuffer         ticketKey;
    in_addr*            pInAddr = &(((PSOCKADDR_IN)pikerbRequest->GetClientAddress())->sin_addr);
    PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA data = {0};

    // Crack passport ticket
    hr = _pxmacs->GetPassportPuidFromTicket(
        pikerbRequest,
        pPcRequest->pticket,
        pPcRequest->ticketLen,
        TRUE,
        &_passportPuid,
        &ticketKey
        );
    if (FAILED(hr))
    {
        // The error code that the KDC will give us if the RPS is expired
        // is TRUST_E_TIME_STAMP. If we got that one back, then send
        // back an error that will indicate the root cause of the problem
        // to the client
        if (hr == XONLINE_E_LOGON_USER_RPS_EXPIRED) 
        {
            kerberr = KDC_ERR_REVOKED_CERTIFICATE;
        }
        else
        {
            kerberr = KDC_ERR_NO_RESPONSE;
        }

        goto Exit;
    }

    _status |= STATUS_CRACKED_TICKET;

    // DoS detection
    CKdcDos* pKdcDos = _pxmacs->GetKdcDos();
    KDCDOS_STATUS dosStatus = pKdcDos->Check(_passportPuid);

    if(dosStatus == KDCDOS_LIMIT_EXCEEDED)
    {
        XomNtEvent(
            XEVENT_XMACS_HACK_DOS_ATTACK,
            "A client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires.\n"
            "Client type: PC1\n"
            "Client IP: "DBGINAFMT"\n"
            "Passport puid: 0x%016I64X",
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            DBGINAPRM(pInAddr),
            _passportPuid);

        _status |= STATUS_TEMPORARILY_BANNED;
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }
    else if(dosStatus == KDCDOS_TEMP_BANNED)
    {
        // Client was previously banned and an event was already logged at that time. To 
        // prevent the client from flooding the Nt event log, we're not going to log an event.
        _status |= STATUS_TEMPORARILY_BANNED | STATUS_DONT_LOG_NT_EVENT;
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }

    XOMASSERT(dosStatus == KDCDOS_OK);

    // Derive the principal key
    BYTE scratch[A_SHA_DIGEST_LEN];

    XcHMAC((BYTE*)ticketKey.GetPtr() , ticketKey.GetSize(),
        pPcRequest->pnonce                , PA_PC_ACCOUNT_CREATION_REQ::NONCE_LENGTH,
        NULL /* pbData2 */        , 0 /* cbData2 */,
        scratch);

    C_ASSERT(sizeof(_principalKey) < sizeof(scratch));
    memcpy(_principalKey, scratch, sizeof(_principalKey));

    _kerbPrincipalKey.keytype         = KERB_ETYPE_RC4_HMAC_NT;
    _kerbPrincipalKey.keyvalue.length = sizeof(_principalKey);
    _kerbPrincipalKey.keyvalue.value  = _principalKey;

    // Use the key to decrypt the encrypted portion of the pre-auth data
    if(!DecryptPreAuth(pPcRequest->pencData, pPcRequest->encDataLen, &data))
    {
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }

    C_ASSERT(sizeof(data.pcId) == sizeof(_pcId.id));
    memcpy(_pcId.id, data.pcId, sizeof(_pcId.id));

    C_ASSERT(sizeof(data.sponsorToken) == sizeof(_sponsorToken));
    strcpy(_sponsorToken, data.sponsorToken);

    kerberr = KDC_ERR_NONE;

Exit:
    return kerberr;
}

// Process the pre-auth in the request.  Contains the implementation details of Process for a V2 request
KERBERR CPaPcAccountCreationHandler::ProcessV2(IKerbRequest* pikerbRequest, PA_PC_ACCOUNT_CREATION_REQ2 *pPcRequest)
{
    HRESULT             hr     = S_OK;
    KERBERR             kerberr = KDC_ERR_NO_RESPONSE;
    in_addr*            pInAddr = &(((PSOCKADDR_IN)pikerbRequest->GetClientAddress())->sin_addr);
    DWORD               cb = 0;
    BYTE                abDecryptedSessionKey[256] = {0};
    PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA2 data = {0};
    LARGE_INTEGER       currentTime = {0};
    LARGE_INTEGER       authTime = {0};
    LARGE_INTEGER       skewTime = {0};

    // Decrypt the the key that the client provided using the private xmacs assymetric key
    cb = sizeof(abDecryptedSessionKey);
    if(!XmacsCryptoDecryptWithXmacsKey(pPcRequest->abEncSessionKey,
                                    PA_PC_ACCOUNT_CREATION_REQ2::ENC_SESSION_KEY_SIZE,
                                    abDecryptedSessionKey,
                                    &cb,
                                    sizeof(abDecryptedSessionKey)))
    {
        kerberr = KDC_ERR_NO_RESPONSE;
        XomNtEvent(XEVENT_KDC_HACK_43, "Failed to decrypt PC2 session key.");
        goto Exit;
    }

    if(cb != XONLINE_KEY_LENGTH)
    {
        kerberr = KDC_ERR_NO_RESPONSE;
        XomNtEvent(XEVENT_KDC_HACK_44, "Size of PC2 session key is wrong: %u", cb);
        goto Exit;
    }

    memcpy(_principalKey, abDecryptedSessionKey, cb);
    _kerbPrincipalKey.keytype         = KERB_ETYPE_RC4_HMAC_NT;
    _kerbPrincipalKey.keyvalue.length = sizeof(_principalKey);
    _kerbPrincipalKey.keyvalue.value  = _principalKey;

    // Decrypt the preauth data using the session key
    if (!DecryptPreAuth(pPcRequest->pencData, pPcRequest->encDataLen, &data))
    {
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }

    // Verify AuthTime in the decrypted data
    GetSystemTimeAsFileTime((PFILETIME)&currentTime);
    skewTime = _pxmacs->GetKdcPolicy()->TimeSkew;
    authTime = *(LARGE_INTEGER*)&data.qwAuthtime;

    if ((currentTime.QuadPart + skewTime.QuadPart < authTime.QuadPart) || (currentTime.QuadPart - skewTime.QuadPart > authTime.QuadPart))
    {
        kerberr = KRB_AP_ERR_SKEW;
        _status |= STATUS_PREAUTH_SKEW;
        goto Exit;
    }

    // Crack passport ticket
    hr = _pxmacs->GetPassportPuidFromTicket(
        pikerbRequest,
        data.ticket,
        data.ticketLen,
        TRUE,
        &_passportPuid,
        NULL
        );
    if (FAILED(hr))
    {
        // The error code that the KDC will give us if the RPS is expired
        // is TRUST_E_TIME_STAMP. If we got that one back, then send
        // back an error that will indicate the root cause of the problem
        // to the client
        if (hr == XONLINE_E_LOGON_USER_RPS_EXPIRED) 
        {
            kerberr = KDC_ERR_REVOKED_CERTIFICATE;
        }
        else
        {
            kerberr = KDC_ERR_NO_RESPONSE;
        }

        goto Exit;
    }

    _status |= STATUS_CRACKED_TICKET;

    // Dos detection
    CKdcDos* pKdcDos = _pxmacs->GetKdcDos();
    KDCDOS_STATUS dosStatus = pKdcDos->Check(_passportPuid);

    if(dosStatus == KDCDOS_LIMIT_EXCEEDED)
    {
        XomNtEvent(
            XEVENT_XMACS_HACK_DOS_ATTACK,
            "A client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires.\n"
            "Client type: PC2\n"
            "Client IP: "DBGINAFMT"\n"
            "Passport puid: 0x%016I64X",
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            DBGINAPRM(pInAddr),
            _passportPuid);

        _status |= STATUS_TEMPORARILY_BANNED;
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }
    else if(dosStatus == KDCDOS_TEMP_BANNED)
    {
        // Client was previously banned and an event was already logged at that time. To prevent the client from flooding the Nt event log, we're not going to log an event.
        _status |= STATUS_TEMPORARILY_BANNED | STATUS_DONT_LOG_NT_EVENT;
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }

    XOMASSERT(dosStatus == KDCDOS_OK);

    // Store relevent data
    //static_assert(sizeof(_pcId) == sizeof(data.pcId)) //TODO: uncomment once we have a newer compiler
    memcpy(&_pcId, &data.pcId, sizeof(data.pcId));

    if (data.sponsorTokenLen > sizeof(_sponsorToken))
    {
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }

    memset(_sponsorToken, 0, sizeof(_sponsorToken));
    strcpy(_sponsorToken, data.sponsorToken);

    kerberr = KDC_ERR_NONE;

Exit:
    return kerberr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\DoSComponent.cpp ===
//--------------------------------------------------------------------
// DOSComponent.cpp: implementation of the CHashTable and CDOSList 
//  classes.
//--------------------------------------------------------------------

//--------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------
#include "xmacsp.h"


void logto634647(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

//--------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------

//  Prime Numbers
//        { 37,59,89,139,227,359,577,929,1499,2423,3919,6337,10253,16573,
//        26821,43391,70207,113591,183797,297377,481171,778541,1259701,2038217,3297913,5336129,
//        8633983,13970093,22604069,36574151,59178199,95752333,154930511,250682837,405613333,
//        656296153,1061909479,1718205583,2780115059,0xFFFFFFFF};

// used for logging and debugging
XomDefineArea(DOS);

//--------------------------------------------------------------------
// CONSTANTS
//--------------------------------------------------------------------

// Hash table size -- currently constants with prime numbers.
const int c_nHashTableSize          = 297377;        

// DOS table list -- currently constants with prime numbers.
const int c_nDOSTableSize           = 113591;        

// the max node life (1 minutes)
const int c_nMaxNodeLifeInSeconds   = 60;

// the max time a DOS node is incompletely valid in the list.
const int c_nDoSTimeCheckInSecs     = 60;


//--------------------------------------------------------------------
//  HashTable -- definitions.
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  The following macros are defined to simplify list manipulation
//      calls.  Logically they are procedures but create less overhead
//      as macros.
//--------------------------------------------------------------------
#define InitializeListHead(ListHead) {\
    (ListHead)->m_pHTNext = (ListHead)->m_pHTPrev = (HashListNode*)(ListHead); \
    }

#define RemoveEntryList(Entry) {\
    HashListNode *pHTPrev;\
    HashListNode *pHTNext;\
    pHTNext = (Entry)->m_pHTNext;\
    pHTPrev = (Entry)->m_pHTPrev;\
    pHTPrev->m_pHTNext = pHTNext;\
    pHTNext->m_pHTPrev = pHTPrev;\
    }

#define InsertTailList(ListHead,Entry) {\
    HashListNode *pHTPrev;\
    HashListNode *_EX_ListHead;\
    _EX_ListHead = (HashListNode*)(ListHead);\
    pHTPrev = _EX_ListHead->m_pHTPrev;\
    (Entry)->m_pHTNext = _EX_ListHead;\
    (Entry)->m_pHTPrev = pHTPrev;\
    pHTPrev->m_pHTNext = (HashListNode*)(Entry);\
    _EX_ListHead->m_pHTPrev = (HashListNode*)(Entry);\
    }

#define InsertDOSHeadList(ListHead,Entry) {\
    ListNode *_EX_pNode = (ListHead)->m_pNext; \
    (Entry)->m_pNext    = _EX_pNode;\
    (Entry)->m_pPrev    = (ListHead);\
    (_EX_pNode)->m_pPrev= (Entry);\
    (ListHead)->m_pNext = (Entry);\
    }

#define RemoveDOSEntryList(Entry) {\
    ListNode* pPrev;\
    ListNode* pNext;\
    pNext = (Entry)->m_pNext;\
    pPrev = (Entry)->m_pPrev;\
    pPrev->m_pNext = (Entry)->m_pNext;\
    pNext->m_pPrev = (Entry)->m_pPrev;\
    (Entry)->m_pNext = NULL;\
    (Entry)->m_pPrev = NULL;\
    }

#define RemoveDOSListTail(ListHead,Entry) {\
    (ListHead)->m_pPrev = ((Entry)->m_pPrev);\
    (Entry)->m_pPrev->m_pNext = (ListHead);\
    (Entry)->m_pPrev = NULL;\
    (Entry)->m_pNext = NULL;\
    }


//--------------------------------------------------------------------
//  Local Function Declarations
//--------------------------------------------------------------------

//--------------------------------------------------------------------
// Class:  CHashTable
//--------------------------------------------------------------------

CHashTable::CHashTable()
{
    int nCount;

    m_nTableSize    = c_nHashTableSize;
    m_nNumOfEnt     = 0;

    // create the table
    m_pTable = new HashListNode[m_nTableSize];
    if ( m_pTable == NULL )
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(CHashTable)  Failed to attain enough memory for the hash table.");
        // log a problem here... without this list... we can't continue
        XomTrace(DOS, L_HIGH, "DOS:(CHashTable)  Failed to attain enough memory for the hash table.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING, "DOS:(CHashTable)  Failed to attain enough memory for the hash table.");
        XOMASSERT(0);       
        return;
    }
    
    // initialize the entries.
    for ( nCount = 0; nCount < m_nTableSize; nCount++ )
    {
        InitializeListHead( &( m_pTable[nCount] ) );
    }

    InitializeCriticalSection( &m_csHashTable );
	logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(CHashTable)  Hash table successfully created.");
    XomTrace(DOS, L_NORMAL,  "DOS:(CHashTable)  Hash table successfully created.");
    
}

CHashTable::~CHashTable()
{
    // delete the table.
    delete[] m_pTable;

    // then clear the memory.
    m_pTable        = NULL;
    m_nTableSize    = 0;

    // delete the critical section.
    DeleteCriticalSection( &m_csHashTable );

	logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(~CHashTable)  Hash table successfully destroyed.");
    XomTrace(DOS, L_NORMAL,  "DOS:(~CHashTable)  Hash table successfully destroyed.");
    
}

//-------------------------------------------
// CHashTable::Lookup
//-------------------------------------------
HashListNode * CHashTable::Lookup( const BYTE *pKey )
{
    int nIdx                = Compute(pKey);                // index of bucket we want.
    HashListNode * plnHead;
    HashListNode * pln      = NULL;
    HashListNode * plnRes   = NULL;

	logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(CHashTable::Lookup)  Enter.");
    XomTrace(DOS, L_LOW, "DOS:(CHashTable::Lookup)  Enter.");

    XOMASSERT( m_pTable );
    if ( m_pTable == NULL )
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DoS:(CHashTable::Lookup)  No hash table exists.  DoS has not been properly set up.  Please reload configuration.");
        XomTrace( DOS, L_WARNING, "DoS:(CHashTable::Lookup)  No hash table exists.  DoS has not been properly set up.  Please reload configuration.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_1, "DoS:(CHashTable::Lookup)  No hash table exists.  DoS has not been properly set up.  Please reload XMACS.");
        plnRes = NULL;
        goto Exit;
    }
    
    plnHead  = &(m_pTable[nIdx]);
    
    // scan forward for the desired node.
    for ( pln = plnHead->m_pHTNext; pln != plnHead; pln = pln->m_pHTNext)
    {
        if ( memcmp( ((ListNode*)pln)->m_pKey, pKey, DOS_KEY_SIZE ) == 0 )
        {
            // got it.
            plnRes = pln;
            goto Exit;
        }
    }

Exit:
	logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(CHashTable::Lookup)  Exit.");
    XomTrace(DOS, L_LOW, "DOS:(CHashTable::Lookup)  Exit.");
    return plnRes;
}

//-------------------------------------------
// CHashTable::Insert a listnode into the list.
//-------------------------------------------
void CHashTable::Insert( ListNode * plnIns)
{
	logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(CHashTable::Insert)  Enter.");
    XomTrace(DOS, L_LOW, "DOS:(CHashTable::Insert)  Enter.");

    XOMASSERT( m_pTable );
    if ( m_pTable == NULL )
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DoS:(CHashTable::Insert)  No hash table exists.  DoS has not been properly set up.  Please reload configuration.");
        XomTrace( DOS, L_WARNING, "DoS:(CHashTable::Insert)  No hash table exists.  DoS has not been properly set up.  Please reload configuration.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_2, "DoS:(CHashTable::Insert)  No hash table exists.  DoS has not been properly set up.  Please reload XMACS.");
        return;    
    }

    HashListNode * plnHead = &m_pTable[ Compute(plnIns->m_pKey) ];

    // ensure this item is not already in the list.
    InsertTailList(plnHead, plnIns);
    m_nNumOfEnt += 1;
	logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(CHashTable::Insert)  Exit.");
    XomTrace(DOS, L_LOW, "DOS:(CHashTable::Insert)  Exit.");
}

//-------------------------------------------
// CHashTable::Delete entry for the table.
//-------------------------------------------
void CHashTable::Delete( ListNode * plnDel )
{
    XOMASSERT( m_nNumOfEnt >= 0 );
    if ( m_nNumOfEnt < 0 )
    {
        return;
    }

    // don't handle NULL nodes.
    XOMASSERT( plnDel );
    if ( plnDel == NULL )
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DoS:(CHashTable::Insert)  Passed param is NULL.  This is a coding error and should be investigated by the developer responsible.  Please reload XMACS is this continues.");
 
        XomTrace( DOS, L_WARNING, "DoS:(CHashTable::Insert)  Passed param is NULL.  This is a coding error and should be investigated by the developer responsible.  Please reload XMACS is this continues.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_3, "DoS:(CHashTable::Insert)  No hash table exists.  DoS has not been properly set up.  Please reload XMACS.");
        return;            
    }

    XOMASSERT( m_pTable );
    if ( m_pTable == NULL )
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DoS:(CHashTable::Insert)  No hash table exists.  DoS has not been properly set up.  Please reload configuration.");
   
        XomTrace( DOS, L_WARNING, "DoS:(CHashTable::Insert)  No hash table exists.  DoS has not been properly set up.  Please reload configuration.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_4, "DoS:(CHashTable::Insert)  No hash table exists.  DoS has not been properly set up.  Please reload XMACS.");
        return;    
    }
    
	logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(CHashTable::Delete)  Enter.");
    XomTrace(DOS, L_LOW, "DOS:(CHashTable::Delete)  Enter.");

    if ( ( (plnDel->m_pHTNext == NULL) && (plnDel->m_pHTPrev == NULL) ) )
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(CHashTable::Delete)  Exit.");
        // this entry doesn't exist... in the list.
        XomTrace(DOS, L_LOW, "DOS:(CHashTable::Delete)  Exit.");
        return;
    }

    // remove the entry.
    RemoveEntryList(plnDel);

    m_nNumOfEnt -= 1;
	logto634647("c:\\xmacs-DoSComponent-cpp.log","CHashTable - DOS:(CHashTable::Delete)  Exit.");
    XomTrace(DOS, L_LOW, "DOS:(CHashTable::Delete)  Exit.");
}

//-------------------------------------------
// CHashTable::Compute: the hash function
//-------------------------------------------
int CHashTable::Compute( const BYTE *pKey )
{
    int nRes                = 0;
    int nUpper              = (int)(*((int*)(pKey)));
    int nMid                = (int)(*((int*)(pKey+4)));
    int nLower              = (int)(*((int*)(pKey+8)));
    
    // multiply the upper and lower mod the table size... very nice.
    ULONGLONG ullval = ( nUpper * nLower * nMid );
    nRes = (int)( ullval % m_nTableSize);

    return nRes;
}

//-------------------------------------------
// CHashTable::IsValid: returns result of 
//      this object being valid or not.
//-------------------------------------------
BOOL CHashTable::IsValid()
{
    return ( m_pTable != NULL );
}

//--------------------------------------------------------------------
// Class:  CDOSList
//--------------------------------------------------------------------

CDOSList::CDOSList(
    int nMaxAllowancePerHour,
    int nStage1Timeout,
    int nStage2Timeout,
    BOOL bDisableDoS /*= false */  
    ) :
         m_nMaxAllow(nMaxAllowancePerHour), 
         m_nStage1Timeout(nStage1Timeout),
         m_nStage2Timeout(nStage2Timeout),
         m_bDisableDoS(bDisableDoS)
{
    int nCount              = 0;

    // set the list size
    m_nListSize = c_nDOSTableSize;

    // initialize the critical section
    InitializeCriticalSection( &m_csDOSList );
    InitializeCriticalSection( &m_csAcquire );

    // create the table
    m_pDOSList = new ListNode[m_nListSize];//(ListNode*)malloc(m_nListSize * sizeof(ListNode) );
    if ( m_pDOSList == NULL )
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","CDOSList - DOS:(CDOSList)  Failed to attain enough memory for the DOS list.");
        // log a problem here... without this list... we can't continue
        XomTrace(DOS, L_HIGH, "DOS:(CDOSList)  Failed to attain enough memory for the DOS list.");
        XOMASSERT(0);      
        return;
    }
    ZeroMemory( m_pDOSList, sizeof(ListNode) * m_nListSize );
    
    // set the 2 lists.
    m_pListHead = new ListNode;

    // initialize values for the head.
    m_pListHead->m_dsCurState     = DOS_INIT;
    m_pListHead->m_ullAccessCount = 0;
    m_pListHead->m_tTimeStamp     = 0;
    m_pListHead->m_tLastAccess    = 0;
    m_pListHead->m_tStage1Cache   = 0;
    m_pListHead->m_tStage2Cache   = 0;
    m_pListHead->m_dwOwnerId      = 0;
    m_pListHead->m_tAcquired      = (time_t)0;
    m_pListHead->m_pNext          = m_pListHead;
    m_pListHead->m_pPrev          = m_pListHead;
    m_pListHead->m_pHTNext        = NULL;
    m_pListHead->m_pHTPrev        = NULL;

    // initialize the entries.
    for ( nCount = 0; nCount < m_nListSize; nCount++ )
    {

        m_pDOSList[nCount].m_pHTNext = NULL;
        m_pDOSList[nCount].m_pHTPrev = NULL;

        // initialize values
        m_pDOSList[nCount].m_dsCurState     = DOS_INIT;
        m_pDOSList[nCount].m_ullAccessCount = 0;
        m_pDOSList[nCount].m_tTimeStamp     = 0;
        m_pDOSList[nCount].m_tLastAccess    = 0;
        m_pDOSList[nCount].m_tStage1Cache   = 0;
        m_pDOSList[nCount].m_tStage2Cache   = 0;
        m_pDOSList[nCount].m_dwOwnerId      = 0;
        m_pDOSList[nCount].m_tAcquired      = (time_t)0;

        // insert at the head of the list.
        InsertDOSHeadList( m_pListHead, &(m_pDOSList[nCount]) );

    }

	logto634647("c:\\xmacs-DoSComponent-cpp.log","CDOSList - DOS:(CDOSList)  DOS has successful been created.");
    XomTrace(DOS, L_NORMAL,  "DOS:(CDOSList)  DOS has successful been created.");

}

CDOSList::~CDOSList()
{
    delete[] m_pDOSList;
    delete   m_pListHead;
    m_pDOSList              = NULL;
    m_pListHead             = NULL;
    m_nListSize             = 0;

    DeleteCriticalSection( &m_csAcquire );
    DeleteCriticalSection( &m_csDOSList );
	logto634647("c:\\xmacs-DoSComponent-cpp.log","CDOSList - DOS:(CDOSList)  DOS has successful been created.");
    XomTrace(DOS, L_NORMAL,  "DOS:(CDOSList)  DOS has successful been created.");
}

//-------------------------------------------
// CDOSList::IsValid: returns result of 
//      this object being valid or not.
//-------------------------------------------
BOOL CDOSList::IsValid()
{
    if ( m_pListHead == NULL || m_pDOSList == NULL )
    {
        return FALSE;
    }

    return m_objHashTbl.IsValid();
}

//-------------------------------------------
// CDOSList::InitialService: Checks the service
//            updating necessary infomation.
//
//  Results:  
//      DOS_OK -- perform initial stage, node has
//          been acquired
//      DOS_COPY_ONLY -- no need to do init stage,
//          but the node has been acquired.
//      DOS_ITEM_BUSY -- Node not acquired since
//          it's currently in use.
//      DOS_ACCESS_MAXIMUM_FIRST -- too many vists,
//          Node not acquired. First occurence.
//      DOS_ACCESS_MAXIMUM -- too many vists,
//          Node not acquired.
//      DOS_SERVICE_OVERLOAD -- table handling
//          more entries than possible.  No
//          node is acquired.
//-------------------------------------------
DOS_RESULT CDOSList::InitialService( DWORD dwThreadId, const BYTE *pKey, ListNode **ppNode /*out*/ )
{
    USES_CONVERSION;
    DOS_RESULT drRes        = DOS_OK;
    ListNode *pItem         = NULL;
    int nStringSize         = 0;
    time_t curTime;

    XOMASSERT( m_pListHead );
    XOMASSERT( m_pDOSList );
    XOMASSERT( dwThreadId != 0 );

	logto634647("c:\\xmacs-DoSComponent-cpp.log","InitialService - DOS:(CDOSList::InitialService)  Service now running for: %.12s.", pKey);
    XomTrace(DOS, L_NORMAL, "DOS:(CDOSList::InitialService)  Service now running for: %.12s.", pKey);
    
    // set the default value.
    XOMASSERT( ppNode != NULL );
    *ppNode = NULL;
        
    EnterCriticalSection( &m_csDOSList );
    // check if disable DOS if specified.  NOTE:  THIS WILL CAUSE A PERFORMANCE HIT IF DOS IS REMOVED!!!!!
    // lookup this item in the list.
    if ( !m_bDisableDoS )
    {
        pItem = Lookup( pKey );
    }

    // check if we found anything
    if ( pItem == NULL )
    {
        pItem = m_pListHead->m_pPrev;

        // get the current time.
        time( &curTime );

        // ensure this node hasn't been visited recently
        if ( (pItem->m_dsCurState != DOS_INIT ) && ( curTime - pItem->m_tLastAccess ) < c_nMaxNodeLifeInSeconds )
        {
			logto634647("c:\\xmacs-DoSComponent-cpp.log","InitialService - DOS List overloaded");
            // we can't get this node now...  overload
            XOMASSERT(!"DOS List overloaded");
			logto634647("c:\\xmacs-DoSComponent-cpp.log","InitialService - DOS:(CDOSList::InitialService)  DOS List overloaded for key:  %.12s.  No entries available for access.", pKey);
            XomTrace(DOS, L_WARNING, "DOS:(CDOSList::InitialService)  DOS List overloaded for key:  %.12s.  No entries available for access.", pKey); 

            // last entry is still in progress... nothing we can do.
            drRes = DOS_SERVICE_OVERLOAD;
            *ppNode = NULL;
            goto Exit;
            
        }
        
        //ensure that the DOS State for the next node can be modified.
        if ( !Acquire( dwThreadId, pItem ) )
        {
			logto634647("c:\\xmacs-DoSComponent-cpp.log","InitialService - DOS List overloaded");
            // we can't get this node now...  overload
            XOMASSERT(!"DOS List overloaded");
			logto634647("c:\\xmacs-DoSComponent-cpp.log","InitialService - DOS:(CDOSList::InitialService)  DOS List overloaded for key:  %.12s.  No entries available for access.", pKey); 
            XomTrace(DOS, L_WARNING, "DOS:(CDOSList::InitialService)  DOS List overloaded for key:  %.12s.  No entries available for access.", pKey); 
            XomNtEvent(XEVENT_XMACS_GENERIC_RESOURCE_WARNING_5, "DOS:(CDOSList::InitialService)  DOS List overloaded for key:  %.12s.  No entries available for access.", pKey); 

            // last entry is still in progress... nothing we can do.
            drRes = DOS_SERVICE_OVERLOAD;
            *ppNode = NULL;
            goto Exit;
            
        }

        // remove this entry from the hash table.
        m_objHashTbl.Delete(pItem);        

        ReInitializeNode( pItem );

        // copy the key into a buffer.
        memcpy( (void*)(pItem->m_pKey), (void*)pKey, DOS_KEY_SIZE );

        // insert this new entry into the hash list.
        m_objHashTbl.Insert( pItem );
    }
    else
    {
        // see if someone is already messing with this node.
        if ( !Acquire( dwThreadId, pItem ) )
        {
            // last entry is still in progress... nothing we can do.
            drRes = DOS_ITEM_BUSY;
            *ppNode = NULL;
            goto Exit;
            
        }
        
    }

    // get the current time.
    time( &curTime );

    // move to the head of the list.
    MoveToDoSListHead( pItem );

    // set the last access time for this node.
    pItem->m_tLastAccess = curTime;

    XOMASSERT( Am_I_In_Charge( dwThreadId, pItem ));
    
    // check this node.
    if ( pItem->m_tTimeStamp != 0 )
    {
        // if the current time is a minute beyond the stamp reset and restart.
        if ( curTime > ( pItem->m_tTimeStamp + c_nDoSTimeCheckInSecs ) )
        {
            pItem->m_tTimeStamp = curTime;
            pItem->m_ullAccessCount = 1;
        }
        else
        {
            (pItem->m_ullAccessCount)++;
            if ( pItem->m_ullAccessCount > m_nMaxAllow )
            {
                // First hit is special
                if ( pItem->m_ullAccessCount == m_nMaxAllow + 1)
                {
                    drRes = DOS_ACCESS_MAXIMUM_FIRST;
                }
                else
                {
                    drRes = DOS_ACCESS_MAXIMUM;
                }

				logto634647("c:\\xmacs-DoSComponent-cpp.log","InitialService - DOS:(CDOSList::InitialService) Access allowance has maxed out for %.12s.  It has returned %d in the last minute.\n", pKey, pItem->m_ullAccessCount );
                XomTrace( DOS, L_WARNING, "DOS:(CDOSList::InitialService) Access allowance has maxed out for %.12s.  It has returned %d in the last minute.\n", pKey, pItem->m_ullAccessCount );

                // return this node so the someone can figure this out....
                *ppNode = pItem;
                ReleaseNode( dwThreadId, pItem );
                goto Exit;
            }
        }

        // ensure that we haven't exceeded the cache life time.
        if ( curTime > ( pItem->m_tStage1Cache + m_nStage1Timeout ) )
        {
            // the cache has timed out... return the proper response.
			logto634647("c:\\xmacs-DoSComponent-cpp.log","InitialService - DOS:(CDOSList::InitialService) The stage 1 cache has expired for %.12s.  Signalling cache timeout.\n", pItem->m_pKey, pItem->m_ullAccessCount );
            XomTrace( DOS, L_LOW, "DOS:(CDOSList::InitialService) The stage 1 cache has expired for %.12s.  Signalling cache timeout.\n", pItem->m_pKey, pItem->m_ullAccessCount );

            pItem->m_dsCurState = DOS_INIT;
            drRes = DOS_OK;
        }

    }
    else
    {
        // first time shopper.. give them the time and inc that access amount.
        pItem->m_tTimeStamp = curTime;
        pItem->m_tStage1Cache = 0;
        pItem->m_tStage2Cache = 0;
        pItem->m_ullAccessCount = 1;
    }

    // if this thread is not in charge and the state claims to be finished with stage one... copy only.
    if ( pItem->m_dsCurState == DOS_COMPLETE_ALL || pItem->m_dsCurState == DOS_COMPLETE_STAGE1 )
    {
        drRes = DOS_COPY_ONLY;
    }
    *ppNode = pItem;
    
    XOMASSERT( (drRes == DOS_COPY_ONLY) || (drRes == DOS_OK));
    
Exit:
    LeaveCriticalSection( &m_csDOSList );
	logto634647("c:\\xmacs-DoSComponent-cpp.log","InitialService - DOS:(CDOSList::InitialService)  Service for key %.12s is complete with result: %d.", pKey, drRes);
    XomTrace(DOS, L_NORMAL, "DOS:(CDOSList::InitialService)  Service for key %.12s is complete with result: %d.", pKey, drRes);

    return drRes;
}

//-------------------------------------------
// CDOSList::SecondService:  reacquires a node
//      for stage 2 processing
//-------------------------------------------
DOS_RESULT CDOSList::SecondService(  DWORD dwThreadId, ListNode *pNode /*in*/ )
{
    DOS_RESULT drRes = DOS_OK;
    time_t    tcurTime;

    XOMASSERT( dwThreadId != 0 );
    XOMASSERT( pNode );

    // re-acquire the lock.
    if ( Acquire( dwThreadId, pNode ) )
    {        
        // acquired and ready for action.
        if ( DOS_COMPLETE_STAGE1 == pNode->m_dsCurState )
        {
            // proceed with preauth
            drRes = DOS_OK;
        }
        else if ( DOS_COMPLETE_ALL == pNode->m_dsCurState )
        {
            time( &tcurTime );
            // ensure that we haven't exceeded the cache life time.
            if ( tcurTime > ( pNode->m_tStage2Cache + m_nStage2Timeout ) )
            {
				logto634647("c:\\xmacs-DoSComponent-cpp.log","SecondService - DOS:(CDOSList::SecondService) The stage2 cache has expired for %.12s.  Signalling cache timeout.\n", pNode->m_pKey, pNode->m_ullAccessCount );
 
                // the cache has timed out... return the proper response.
                XomTrace( DOS, L_LOW, "DOS:(CDOSList::SecondService) The stage2 cache has expired for %.12s.  Signalling cache timeout.\n", pNode->m_pKey, pNode->m_ullAccessCount );

                pNode->m_dsCurState = DOS_COMPLETE_STAGE1;
                drRes = DOS_OK;
            }
            else
            {
				logto634647("c:\\xmacs-DoSComponent-cpp.log","SecondService - DOS_COPY_ONLY");
                // just copy information then release.
                drRes = DOS_COPY_ONLY;
            }
        }
        else
        {
			logto634647("c:\\xmacs-DoSComponent-cpp.log","SecondService - DOS_INVALID_DATA");
            // proceed with preauth
            drRes = DOS_INVALID_DATA;
        }
    }
    else
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","SecondService - DOS_ITEM_BUSY");
        drRes = DOS_ITEM_BUSY;
    }

	logto634647("c:\\xmacs-DoSComponent-cpp.log","drRes: 0x%X", drRes);
    return drRes;
}

//-----------------------------------------------
//  CDOSList::ReleaseNode:  Releases threads ownership 
//          on node.
//-----------------------------------------------
BOOL CDOSList::ReleaseNode( DWORD dwThreadId, ListNode *pNode /*in*/ )
{
    BOOL bRes = TRUE;

    XOMASSERT( dwThreadId != 0 );
    XOMASSERT( pNode );

    // set the thread ownership back to 0.
    EnterCriticalSection( &m_csAcquire );
    if ( pNode->m_dwOwnerId == dwThreadId )
    {
        pNode->m_dwOwnerId = 0;
    }
    else
    {
        // ok... this node does not belong to this thread... so it can't release it.
        bRes = FALSE;
    }
    LeaveCriticalSection( &m_csAcquire );
    
    return bRes;
}

    
//-----------------------------------------------
//  CDOSList::Acquire: Acquires ownership of a 
//      node. 
//-----------------------------------------------
BOOL CDOSList::Acquire( DWORD dwThreadId, ListNode *pNode /*in*/ )
{
    BOOL bRes = TRUE;
    time_t curTime;

    // get current time.
    time( &curTime );

    XOMASSERT( dwThreadId != 0 );
    XOMASSERT( pNode );
    XOMASSERT( pNode->m_dwOwnerId != dwThreadId );
    
    // enter the critical section.
    EnterCriticalSection( &m_csAcquire );
    
    if ( pNode->m_dwOwnerId == 0 )
    {
        pNode->m_dwOwnerId = dwThreadId;
        pNode->m_tAcquired = curTime; 
    }
    else
    {
        // check the nodes acquire lifetime.
        if ( ( curTime - pNode->m_tAcquired ) > c_nMaxNodeLifeInSeconds )
        {
            // this node has been ideal too long.  Seize control.
            pNode->m_dwOwnerId = dwThreadId;
            pNode->m_tAcquired = curTime;
        } 
        else
        {
            // this node could still be processing... do not seize control.
            bRes = FALSE;
        }
    }

    LeaveCriticalSection( &m_csAcquire );
    return bRes;
}
    


//-------------------------------------------
// CDOSList::Lookup: looks up the desired node.
//-------------------------------------------
ListNode * CDOSList::Lookup( const BYTE *pKey )
{
    XOMASSERT( pKey != NULL );

    if ( pKey == NULL )
    {
        return NULL;
    }

    return (ListNode*)(m_objHashTbl.Lookup(pKey));
}

//-------------------------------------------
// CDOSList::MoveToDoSListHead:  Inserts an element
//      into the head of the DOS list. NOT the 
//    hash table.
//-------------------------------------------
void CDOSList::MoveToDoSListHead( ListNode *pNewItem )
{
    XOMASSERT( m_pListHead );
    XOMASSERT( m_pDOSList );

    XOMASSERT( pNewItem != NULL );

    if ( m_pListHead == NULL || m_pDOSList == NULL || pNewItem == NULL )
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","MoveToDoSListHead - DOS:(CDOSList::Service)  DoS object is in invalid state.  Please reload XMACS.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_6, "DOS:(CDOSList::Service)  DoS object is in invalid state.  Please reload XMACS.");
        XomTrace(DOS, L_WARNING, "DOS:(CDOSList::Service)  DoS object is in invalid state.  Please reload XMACS.");
        return;
    }

    RemoveDOSEntryList( pNewItem );

	logto634647("c:\\xmacs-DoSComponent-cpp.log","MoveToDoSListHead - DOS:(CDOSList::Insert)  Enter.");
    XomTrace(DOS, L_LOW, "DOS:(CDOSList::Insert)  Enter.");
    InsertDOSHeadList( m_pListHead, pNewItem );
	logto634647("c:\\xmacs-DoSComponent-cpp.log","MoveToDoSListHead - DOS:(CDOSList::Insert)  Exit.");
    XomTrace(DOS, L_LOW, "DOS:(CDOSList::Insert)  Exit.");
}

//-------------------------------------------
// CDOSList::ReInitializeNode:  Removes element from 
//   the tail of the list and puts it on the 
//     head.
//-------------------------------------------
void CDOSList::ReInitializeNode( ListNode *pItem )
{
    XOMASSERT( m_pListHead );
    XOMASSERT( m_pDOSList );

    XOMASSERT( pItem != NULL );
    if ( m_pListHead == NULL || m_pDOSList == NULL || pItem == NULL )
    {
		logto634647("c:\\xmacs-DoSComponent-cpp.log","ReInitializeNode - DOS:(CDOSList::Service)  DoS object is in invalid state.  Please reload XMACS.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_7, "DOS:(CDOSList::Service)  DoS object is in invalid state.  Please reload XMACS.");
        XomTrace(DOS, L_WARNING, "DOS:(CDOSList::Service)  DoS object is in invalid state.  Please reload XMACS.");
        return;        
    }

	logto634647("c:\\xmacs-DoSComponent-cpp.log","ReInitializeNode - DOS:(CDOSList::DeleteAndInit)  Enter.");
    XomTrace(DOS, L_LOW, "DOS:(CDOSList::DeleteAndInit)  Enter.");
    
    // reset the node values.  This node is free now.
    pItem->m_ullAccessCount     = 0;
    pItem->m_dsCurState         = DOS_INIT;
    pItem->m_tTimeStamp         = 0;
    pItem->m_tLastAccess        = 0;
    pItem->m_tStage1Cache       = 0;
    pItem->m_tStage2Cache       = 0;

    // clean up the memory in this node.
    ZeroMemory( pItem->m_pData, DOS_DATA_SIZE );
    ZeroMemory( pItem->m_pKey,  DOS_KEY_SIZE );
    
	logto634647("c:\\xmacs-DoSComponent-cpp.log","ReInitializeNode - DOS:(CDOSList::DeleteAndInit)  Exit.");    
    XomTrace(DOS, L_LOW, "DOS:(CDOSList::DeleteAndInit)  Exit.");    
}

int CDOSList::SetMaxAllowance(int nMaxAllowancePerHour )
{
    m_nMaxAllow = nMaxAllowancePerHour;
    return m_nMaxAllow;
}

int CDOSList::SetStage1Timeout(int nStage1Timeout )
{
    m_nStage1Timeout = nStage1Timeout;
    return m_nStage1Timeout;
}

int CDOSList::SetStage2Timeout(int nStage2Timeout )
{
    m_nStage2Timeout = nStage2Timeout;
    return m_nStage2Timeout;
}

//--------------------------------------------------------------------
//  Local Functions
//--------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\xmacsp.h ===
#include "BaseProvider.h"
#include "BasePrincipal.h"
#include "BasePerfCtrs.h"

#include <time.h>
#include <assert.h>
#include <oleauto.h>
#include <Rpcdce.h>
#include <string.h>
#include <wincrypt.h>
#include <ctype.h>
#include <atlbase.h>
#include <atlcom.h>
#include <atlctl.h>
#include <atlsafe.h>
#include <atlconv.h>

#include <commonconfig.h>
#include "wsockntp.h"
#include "xonlinep.h"
#include "XAlloc.h"
#include <xmgmt.h>
#include "OleDbWrapper.h"

#include "Base64.h"
#include "DOSComponent.h"
#include <KdcDos.h>

#include "XMACSProvider.h"
#include "XMACSPreAuth.h"

#include "cryptkeysref.h"

#include "perfapi.h"
#include "xmacsperf.h"

#include "xeventids.h"

#include "xomcmmon.h"
#include "xetestkeys.h"
#include "XmacsCrypto.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\xmacsdb.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// XmacsDb.h
//
// Database stuff for xmacs
// --------------------------------------------------------------------------------------

#pragma once

class CXMACSProvider;

struct PC_ID
{
    BYTE id[XONLINE_PC_ID_LENGTH];
    
    void WriteToString(CStr* pstr) const
    {
        for(int i=0; i < ARRAY_SIZE(id); i++)
        {
            pstr->Format("%02X", id[i]);
        }
    }

    typedef TToString<PC_ID, 32> ToString;
};

struct TOKEN_HASH
{
    BYTE hash[20];

    void WriteToString(CStr* pstr) const
    {
        for(int i=0; i < ARRAY_SIZE(hash); i++)
        {
            pstr->Format("%02X", hash[i]);
        }
    }

    typedef TToString<TOKEN_HASH, 40> ToString;
};

class CXmacsDb
{
public:

    CXmacsDb(CXMACSProvider* pxmacs) :
        _pxmacs(pxmacs)
    {
    }

    // These should probably match what is in p_xmacs_pc_account_lookup
    enum PcAccountLookupStatus
    {
        PcAccountLookupSucceeded            = 0,
        PcAccountLookupVoucherInvalid       = 1,
        PcAccountLookupVoucherBanned        = 2,
        PcAccountLookupNotFound             = 3,
        PcAccountLookupVoucherUsageExceeded = 4,
        PcAccountLookupVoucherInUse         = 5,
        PcAccountLookupFailed               = 6,
    };

    // see uodb..t_console_types, used in t_title_versions, t_machine_title_activations, 
    // t_user_title_activations
    static const UINT   CONSOLETYPE_XBOX1                 = 0;
    static const UINT   CONSOLETYPE_XBOX360               = 2;
    static const UINT   CONSOLETYPE_PC                    = 4;

    static const UINT   LIMITED_PC_VOUCHER_USECOUNT       = 100;
    static const UINT   LIMITED_PC_VOUCHER_CONSOLETYPE    = 4;
    static const UINT   LIMITED_PC_VOUCHER_STATUS         = 0;
    static const UINT64 LIMITED_PC_VOUCHER_OFFERID        = 0x585207D10FF00002;

    HRESULT PcAccountLookup(
        const TOKEN_HASH&          tokenHash,
        const PC_ID&               pcId,
        const UINT64               userId,
        OUT PcAccountLookupStatus* pStatus,
        OUT UINT64*                pMachineId,
        OUT UINT32*                pTitleId,
        OUT BOOL*                  pTokenAlreadyUsed,
        OUT BOOL*                  pTitleRequiresActivation);

    HRESULT PcAccountCreate(
        const TOKEN_HASH&  tokenHash,
        const PC_ID&       pcId,
        UINT64             machineId,
        UINT64             passportPuid);


    HRESULT UODBMachineLookup(
        ULONGLONG qwMachinePUID, 
        FILETIME *pftBlockDate, 
        FILETIME *pftResetDate,
        BOOL     *pbIsFound);

    HRESULT UODBResetPasswordMachinePC(
        LPCSTR             szConsoleId,
        ULONGLONG          qwMachinePUID,
        UINT               nKeyVersion, 
        XOCryptoKeyStruct  encKey, 
        XOCryptoIVStruct   iV, 
        XOCryptoPPAStruct  bPPA, 
        XOCryptoSPPAStruct bSPPA
        );

    HRESULT UODBMachinePCUpdatePuid(
        LPCSTR     szConsoleId,
        QWORD      qwMachinePuid,
        const UINT dwConsoleTypeFlags
        );

    HRESULT UODBAddPUIDVoucher(
        const TOKEN_HASH&  tokenHash);

    HRESULT GetXboxUserByPassport(
        UINT64  passportUserId,
        OUT UINT64* pxboxUserId);

    HRESULT UseVoucher(
        const TOKEN_HASH& tokenHash,
        const UINT64      userId);

    HRESULT ActivateTitleForMachine(
        const UINT64 machineId,
        const UINT32 titleId,
        const UINT32 consoleTypeId);

    HRESULT ActivateTitleForUser(
        const UINT64 userId,
        const UINT32 titleId,
        const UINT32 consoleTypeId);


protected:
    CXMACSProvider*        _pxmacs;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\xmacsdb.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// XmacsDb.cpp
//
// Database stuff for xmacs
// --------------------------------------------------------------------------------------

#include "xmacsp.h"
#include "xmacsdb.h"

void logto634664576457647(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

XomImportArea(XMACS);

HRESULT CXmacsDb::PcAccountLookup(
    const TOKEN_HASH&          tokenHash,
    const PC_ID&               pcId,
    const UINT64               userId,
    OUT PcAccountLookupStatus* pStatus,
    OUT UINT64*                pMachineId,
    OUT UINT32*                pTitleId,
    OUT BOOL*                  pTokenAlreadyUsed,
    OUT BOOL*                  pTitleRequiresActivation
)
{
    HRESULT hr = S_OK;
    LONG ret = 0;
    UINT64 machineId = 0;
    long tokenAlreadyUsed = 0;
    long titleRequiresActivation = 0;
    unsigned long titleId = 0;
    *pStatus = PcAccountLookupFailed;

    SAFEARRAY saTokenHash; // @bin_voucher_hash
    SetupSafeArray(&saTokenHash, sizeof(tokenHash.hash), (PVOID) tokenHash.hash);

    SAFEARRAY saPcId; // @b_pc_id
    SetupSafeArray(&saPcId, sizeof(pcId.id), (PVOID) pcId.id);

    hr = _pxmacs->GetManagedProxy()->XMacsPcAccountLookup(&saTokenHash, &saPcId, userId, &machineId, &titleId, &tokenAlreadyUsed, &titleRequiresActivation, &ret);
    if (FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: FAILED(hr)");
        if (hr != XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: PcAccountLookup failed. Operation: XMacsPcAccountLookup. Hr=0x%08x", hr);
            XomNtEvent(XEVENT_XMACS_DB_PC_ACCOUNT_LOOKUP_ERROR, "PcAccountLookup failed. Operation: XMacsPcAccountLookup. Hr=0x%08x", hr);
        }
        goto Exit;
    }

    *pTokenAlreadyUsed = tokenAlreadyUsed;
    *pTitleRequiresActivation = titleRequiresActivation;
    *pTitleId = titleId;

    // Check return status
    switch(ret)
    {
    case 0:
        C_ASSERT(sizeof(*pMachineId) == sizeof(LONGLONG));
        *pMachineId = machineId;
        *pStatus = PcAccountLookupSucceeded;
        break;

    case 1:
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "PcAccountLookupVoucherInvalid");
        *pStatus = PcAccountLookupVoucherInvalid;
        goto Exit;

    case 2:
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "PcAccountLookupVoucherBanned");
        *pStatus = PcAccountLookupVoucherBanned;
        goto Exit;

    case 3:
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "PcAccountLookupNotFound");
        *pStatus = PcAccountLookupNotFound;
        goto Exit;

    case 4:
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "PcAccountLookupVoucherUsageExceeded");
        *pStatus = PcAccountLookupVoucherUsageExceeded;
        goto Exit;

    case 5:
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "PcAccountLookupVoucherInUse");
        *pStatus = PcAccountLookupVoucherInUse;
        goto Exit;

    default:
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "PcAccountLookupFailed");
        *pStatus = PcAccountLookupFailed;
        goto Exit;
    }

Exit:

    if(*pStatus == PcAccountLookupFailed)
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: PcAccountLookup failed. hr=0x%08x, TokenHash=%s, Pcid=%s, UserId=0x%016I64X, ret=%u",
            hr, (LPCSTR)TOKEN_HASH::ToString(tokenHash), (LPCSTR)PC_ID::ToString(pcId), userId, ret);
        XomNtEvent(
            XEVENT_XMACS_DB_PC_ACCOUNT_LOOKUP_ERROR,
            "PcAccountLookup failed. hr=0x%08x, TokenHash=%s, Pcid=%s, UserId=0x%016I64X, ret=%u",
            hr, (LPCSTR)TOKEN_HASH::ToString(tokenHash), (LPCSTR)PC_ID::ToString(pcId), userId, ret);
    }

    return hr;
};

HRESULT CXmacsDb::PcAccountCreate(
    const TOKEN_HASH&  tokenHash,
    const PC_ID&       pcId,
    UINT64             machineId,
    UINT64             passportPuid
)
{
    HRESULT hr = S_OK;
    LONG ret = 0;

    // Set parameters
    SAFEARRAY saTokenHash; // @bin_voucher_hash
    SetupSafeArray(&saTokenHash, sizeof(tokenHash.hash), (PVOID) tokenHash.hash);

    SAFEARRAY saPcId; // @b_pc_id
    SetupSafeArray(&saPcId, sizeof(pcId.id), (PVOID) pcId.id);

    // Execute stored procedure
    hr = _pxmacs->GetManagedProxy()->XMacsPcAccountCreate(&saTokenHash, &saPcId, machineId, passportPuid, &ret);
    if (FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: PcAccountCreate - XMacsPcAccountCreate FAILED(hr)");
        goto Exit;
    }
    if(ret != 0)
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: PcAccountCreate - E_FAIL");
        hr = E_FAIL;
        goto Exit;
    }

Exit:

    if(FAILED(hr) && hr != XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: PcAccountCreate failed. "
            "hr=0x%08x, TokenHash=%s, Pcid=%s, MachineId=0x%016I64X, PassportPuid=0x%016I64X, ret=%u",
            hr, (LPCSTR)TOKEN_HASH::ToString(tokenHash), (LPCSTR)PC_ID::ToString(pcId), 
            machineId, passportPuid, ret);

        XomNtEvent(
            XEVENT_XMACS_DB_PC_ACCOUNT_CREATE_ERROR,
            "PcAccountCreate failed. "
            "hr=0x%08x, TokenHash=%s, Pcid=%s, MachineId=0x%016I64X, PassportPuid=0x%016I64X, ret=%u",
            hr, (LPCSTR)TOKEN_HASH::ToString(tokenHash), (LPCSTR)PC_ID::ToString(pcId), 
            machineId, passportPuid, ret);
    }

    return hr;
};

// @@@ copied from xmacspreauth.cpp. At some point one implementation should be removed. 
// @@@ this method could use some cleaning up
HRESULT CXmacsDb::UODBMachineLookup(
    ULONGLONG qwMachinePUID, 
    FILETIME *pftBlockDate, 
    FILETIME *pftResetDate,
    OUT BOOL *pbIsFound
    )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    DATE dtBlockDate = 0.0;
    DATE dtResetDate = 0.0;
    long isFound = 0;

    // execute the query
    hr = _pxmacs->GetManagedProxy()->XMacsMachineLookup(qwMachinePUID, &dtBlockDate, &dtResetDate, &isFound);
    if (FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBMachineLookup - XMacsMachineLookup");
        goto Exit;
    }

    // Remember that we found the machine (or not)
    *pbIsFound = isFound;

    // get the block date.
    if ( dtBlockDate > 0.0 )
    {
        // attain the filetime from the given.
        hr = GetFILETIMEFromDATE( dtBlockDate, pftBlockDate );
        if ( FAILED(hr) )
        {
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: XMACS:(CXMACSProvider::UODBMachineLookup)  Failed to get a filetime from given black date.  RESULT = 0x%X", hr);
            XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::UODBMachineLookup)  Failed to get a filetime from given black date.  RESULT = 0x%X", hr);
            XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_36, "XMACS:(CXMACSProvider::UODBMachineLookup)  Failed to get a filetime from given black date.  RESULT = 0x%X", hr);
            goto Exit;
        }
    }
    else
    {
        // set it back to the beginning of FILETIME
        ZeroMemory( (void*)pftBlockDate, sizeof(FILETIME) );
    }

    // get the reset date.
    if ( dtResetDate > 0.0 )
    {
        // attain the filetime from the given.
        hr = GetFILETIMEFromDATE( dtResetDate, pftResetDate );
        if ( FAILED(hr) )
        {
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: XMACS:(CXMACSProvider::UODBMachineLookup)  Failed to get a filetime from given black date.  RESULT = 0x%X", hr);
            XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::UODBMachineLookup)  Failed to get a filetime from given black date.  RESULT = 0x%X", hr);
            XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_38, "XMACS:(CXMACSProvider::UODBMachineLookup)  Failed to get a filetime from given black date.  RESULT = 0x%X", hr);
            goto Exit;
        }
    }
    else
    {
        // set it back to the beginning of FILETIME
        ZeroMemory( (void*)pftResetDate, sizeof(FILETIME) );
    }

Exit:

    return hr;

}

HRESULT CXmacsDb::UODBResetPasswordMachinePC(
    LPCSTR szConsoleId,
    ULONGLONG qwMachinePUID,
    UINT nKeyVersion, 
    XOCryptoKeyStruct encKey, 
    XOCryptoIVStruct iV, 
    XOCryptoPPAStruct bPPA, 
    XOCryptoSPPAStruct bSPPA 
    )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    CComBSTR bstrConsoleId;
    SAFEARRAY saEncKey = {0};
    SAFEARRAY saIV = {0};
    SAFEARRAY saPPA = {0};
    SAFEARRAY saSPPA = {0};
    NTSTATUS status = STATUS_SUCCESS;
    LPCWSTR wszConsoleId = A2W(szConsoleId);

    XOMASSERT(AES_BLOCKLEN == sizeof(iV.abIV));
    XOMASSERT(ONLINE_KEY_LEN == sizeof(encKey.abKey));
    XOMASSERT(PPA_DATA_LEN == sizeof(bPPA.abPPA));
    XOMASSERT(A_SHA_DIGEST_LEN == sizeof(bSPPA.abSPPA));

    // create the consoleid bstr
    bstrConsoleId.Attach(SysAllocString( wszConsoleId ));
    if ( bstrConsoleId == NULL )
    {
        hr = E_OUTOFMEMORY;
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: XMACS:(CXMACSProvider::UODBResetAccount)  Failed to allocate enough memory for BSTR.  Please investigate.");
        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::UODBResetAccount)  Failed to allocate enough memory for BSTR.  Please investigate.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_21, "XMACS:(CXMACSProvider::UODBResetAccount)  Failed to allocate enough memory for BSTR.  Please investigate.");
        goto Exit;
    }

    // setup the safe arrays.
    SetupSafeArray( &saEncKey, ARRAYSIZE(encKey.abKey), &(encKey.abKey) );
    SetupSafeArray( &saIV, ARRAYSIZE(iV.abIV), &(iV.abIV) );
    SetupSafeArray( &saPPA, ARRAYSIZE(bPPA.abPPA), &(bPPA.abPPA) );
    SetupSafeArray( &saSPPA, ARRAYSIZE(bSPPA.abSPPA), &(bSPPA.abSPPA) );

    // execute the query
    hr = _pxmacs->GetManagedProxy()->XMacsResetPasswordMachinePC(
        bstrConsoleId, 
        qwMachinePUID,
        _pxmacs->GetEncryptionKeyVersion(), 
        nKeyVersion, 
        &saIV, 
        &saEncKey, 
        &saPPA, 
        &saSPPA,
        &status
        );
    if (FAILED(hr) || !NT_SUCCESS(status))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBResetPasswordMachinePC - XMacsResetPasswordMachinePC FAILED(hr)");
        if ( status == STATUS_UNSUCCESSFUL )
        {
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBResetPasswordMachinePC - STATUS_UNSUCCESSFUL");
            hr = E_XMACS_NO_UODB;
        }
        else if (!FAILED(hr))
        {
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBResetPasswordMachinePC - E_FAIL");
            hr = E_FAIL;
        }
        goto Exit;
    }

Exit:
    return hr;
}

// @@@ copied from xmacspreauth.cpp. At some point one implementation should be removed. 
// @@@ this method could use some cleaning up
HRESULT CXmacsDb::UODBMachinePCUpdatePuid(
    LPCSTR     szConsoleId,    
    QWORD      qwMachinePUID,
    const UINT dwConsoleTypeFlags
    )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    CComBSTR bstrConsoleId;
    LPCWSTR wszConsoleId = A2W(szConsoleId);

    // create the consoleid bstr
    bstrConsoleId.Attach(SysAllocString( wszConsoleId ));
    if ( bstrConsoleId == NULL )
    {
        hr = E_OUTOFMEMORY;
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: XMACS:(CXMACSProvider::UODBMachinePCUpdatePuid)  Failed to allocate enough memory for BSTR.  Please investigate.");
        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::UODBMachinePCUpdatePuid)  Failed to allocate enough memory for BSTR.  Please investigate.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_62, "XMACS:(CXMACSProvider::UODBMachinePCUpdatePuid)  Failed to allocate enough memory for BSTR.  Please investigate.");
        goto Exit;
    }


    // execute the query
    //   NOTE this is a write only database command.
    hr = _pxmacs->GetManagedProxy()->XMacsResetMachine(
        bstrConsoleId,
        qwMachinePUID, 
        dwConsoleTypeFlags,
        NULL,
        NULL,
        NULL,
        STATUS_SUCCESS
        );
    if (FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBMachinePCUpdatePuid - XMacsResetMachine FAILED(hr)");
        hr = E_XMACS_NO_UODB;
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CXmacsDb::UODBAddPUIDVoucher(const TOKEN_HASH&  tokenHash)
{
    HRESULT hr = S_OK;
    LONG ret = 0;
    LONG partition = 0;

    // @bin_voucher_hash
    SAFEARRAY saTokenHash; 
    SetupSafeArray(&saTokenHash, sizeof(tokenHash.hash), (PVOID) tokenHash.hash); 

    // execute the query
    hr = _pxmacs->GetManagedProxy()->SvcAddVoucher(&saTokenHash, LIMITED_PC_VOUCHER_OFFERID, LIMITED_PC_VOUCHER_USECOUNT, LIMITED_PC_VOUCHER_STATUS, 0, LIMITED_PC_VOUCHER_CONSOLETYPE, &ret);
    if (FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBAddPUIDVoucher - SvcAddVoucher FAILED(hr)");
        if (hr != XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBAddPUIDVoucher failed. Operation: SvcAddVoucher");
            XomNtEvent(XEVENT_XMACS_DB_PC_PUIDVOUCHER_ADD_ERROR, "UODBAddPUIDVoucher failed. Operation: SvcAddVoucher");
        }

        goto Exit;
    }

    if(ret != 0)
    {
        if (ret == XONLINE_E_OFFERING_INVALID_OFFER_ID)
        {
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBAddPUIDVoucher - UODBAddPUIDVoucher failed, missing offer id 0x%016I64X. This is fatal, "
                        "no limited PC machine accounts can be created until this offer is "
                        "present. It is typically associated with title id 0x585207D1. "
                        "Token hash: 0x%s",
                        LIMITED_PC_VOUCHER_OFFERID,
                        (LPCSTR)TOKEN_HASH::ToString(tokenHash));

            XomNtEvent(XEVENT_XMACS_DB_PC_PUIDVOUCHER_ADD_ERROR,
                        "UODBAddPUIDVoucher failed, missing offer id 0x%016I64X. This is fatal, "
                        "no limited PC machine accounts can be created until this offer is "
                        "present. It is typically associated with title id 0x585207D1. "
                        "Token hash: 0x%s",
                        LIMITED_PC_VOUCHER_OFFERID,
                        (LPCSTR)TOKEN_HASH::ToString(tokenHash));
            hr = E_FAIL;
        }
        else if (ret == 1)
        {
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBAddPUIDVoucher - UODBAddPUIDVoucher updated the voucher. This is not fatal, but "
                        "it is unexpected. Please investigate how this could have happened. "
                        "Token hash: 0x%s",
                        (LPCSTR)TOKEN_HASH::ToString(tokenHash));
            XomNtEvent(XEVENT_XMACS_DB_PC_PUIDVOUCHER_ADD_ERROR,
                        "UODBAddPUIDVoucher updated the voucher. This is not fatal, but "
                        "it is unexpected. Please investigate how this could have happened. "
                        "Token hash: 0x%s",
                        (LPCSTR)TOKEN_HASH::ToString(tokenHash));
            // success
        }
        else
        {
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UODBAddPUIDVoucher - UODBAddPUIDVoucher failed. Return val: 0x%X. Token hash: 0x%s",
                        ret,
                        (LPCSTR)TOKEN_HASH::ToString(tokenHash));
            XomNtEvent(XEVENT_XMACS_DB_PC_PUIDVOUCHER_ADD_ERROR,
                        "UODBAddPUIDVoucher failed. Return val: 0x%X. Token hash: 0x%s",
                        ret,
                        (LPCSTR)TOKEN_HASH::ToString(tokenHash));
            hr = E_FAIL;
        }

        goto Exit;
    }


Exit:

    return hr;
}



// ---------------------------------------------------------------------------------------
// CXmacsDb::GetXboxUserByPassport
// Retrieve a Xbox User id from the database given a passport user id.
//  - passportUserId: the passport user id
//  - pxboxUserId (OUT): receives the xbox user id
// Returns:
//  - S_OK on success
//  - XONLINE_E_ACCOUNTS_INVALID_USER (0x80154002) if there was no xbox user mapped to 
//  passportUserId
//  - Misc. HRESULT errors
//
// Copied from ASProvider.cpp.
// ---------------------------------------------------------------------------------------
HRESULT CXmacsDb::GetXboxUserByPassport(
    UINT64  passportUserId,
    OUT UINT64* pxboxUserId
)
{
    HRESULT     hr = E_UNEXPECTED;

    // @@@kgoodier - We may want to allow invalid lookups through, to support tests and 
    // such. We shouldn't spam events if we decide to do that.

    C_ASSERT(sizeof(*pxboxUserId) == sizeof(LONGLONG));
    hr = _pxmacs->GetManagedProxy()->AskdcGetUserPuidFromPassportPuid(passportUserId, pxboxUserId);
    if (FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: GetXboxUserByPassport - AskdcGetUserPuidFromPassportPuid");
        goto Exit;
    }

    if(!IS_USER_PUID(*pxboxUserId))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: GetXboxUserByPassport - Database returned an invalid xbox user id. "
            "Input-Passport-Id: 0x%016I64x "
            "Output-Xbox-User-Id: 0x%016I64x.",
            passportUserId,
            *pxboxUserId);
        XomNtEvent(
            XEVENT_XMACS_FAILED_TO_GET_USER_ID_FOR_PASSPORT_ID,
            "Database returned an invalid xbox user id. "
            "Input-Passport-Id: 0x%016I64x "
            "Output-Xbox-User-Id: 0x%016I64x.",
            passportUserId,
            *pxboxUserId);
        hr = E_FAIL;
        goto Exit;
    }
 
	logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "S_OK: GetXboxUserByPassport");
    hr = S_OK;

Exit:
    return hr;
}

// ---------------------------------------------------------------------------------------
// CXmacsDb::UseVoucher
//
// Consume a voucher for a user. Puts row in tokendb..t_vouchers_used
// ---------------------------------------------------------------------------------------
HRESULT CXmacsDb::UseVoucher(
    const TOKEN_HASH& tokenHash,
    const UINT64      userId)
{
    HRESULT     hr = S_OK;
    LONG        ret = 0;

    SAFEARRAY saTokenHash; // @bin_voucher_hash
    SetupSafeArray(&saTokenHash, sizeof(tokenHash.hash), (PVOID) tokenHash.hash); 

    hr = _pxmacs->GetManagedProxy()->XMacsUseVoucher(&saTokenHash, userId, &ret);

    if (FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UseVoucher - XMacsUseVoucher");
        goto Exit;
    }

    // Returns:
    // 0x80154007       -- XONLINE_E_ACCOUNTS_INVALID_VOUCHER
    // 0x80154009       -- XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED
    // 0x0              -- success
    //
    // @@@kgoodier Do we want to re-interpret any of these as non-errors?
    //
    if (ret != 0)
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: ret 0x%X", ret);
        hr = ret;
    }

Exit:

    if(FAILED(hr))
    {
        CSmallStr strExtra;
        switch (hr)
        {
        case XONLINE_E_ACCOUNTS_INVALID_VOUCHER:
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: XONLINE_E_ACCOUNTS_INVALID_VOUCHER");
            strExtra.Format("Invalid voucher.");
            break;
        case XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED:
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: Voucher already used.");
            strExtra.Format("Voucher already used.");
            break;
        default:
			logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: <unknown>");
            strExtra.Format("<unknown>");
            break;
        }

		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: UseVoucher failed. Reason: %s "
            "hr=0x%08X, TokenHash=%s, UserId=0x%016I64X, ret=0x%X",
            strExtra.cstr(), hr, (LPCSTR)TOKEN_HASH::ToString(tokenHash), userId, ret);

        XomNtEvent(
            XEVENT_XMACS_DB_USE_VOUCHER_ERROR,
            "UseVoucher failed. Reason: %s "
            "hr=0x%08X, TokenHash=%s, UserId=0x%016I64X, ret=0x%X",
            strExtra.cstr(), hr, (LPCSTR)TOKEN_HASH::ToString(tokenHash), userId, ret);
    }

    return hr;
}


// ---------------------------------------------------------------------------------------
// CXmacsDb::ActivateTitleForMachine
//
// Inserts a row into uodb..t_machine_title_activations.
// ---------------------------------------------------------------------------------------
HRESULT CXmacsDb::ActivateTitleForMachine(
    const UINT64 machineId,
    const UINT32 titleId,
    const UINT32 consoleTypeId)
{
    HRESULT     hr = S_OK;
    LONG        ret = 0;

    hr = _pxmacs->GetManagedProxy()->XMacsActivateTitleForMachine(machineId, titleId, consoleTypeId, &ret);

    if (FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: ActivateTitleForMachine - XMacsActivateTitleForMachine");
        goto Exit;
    }

    // Returns:
    // 0    -- success, no previous activation found
    // 1    -- success, found previous activation and updated end date

    if (ret != 0 && ret != 1)
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: ActivateTitleForMachine - E_FAIL");
        hr = E_FAIL;
    }

Exit:

    if(FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: ActivateTitleForMachine failed. "
            "hr=0x%08X, MachineId=0x%016I64X, TitleId=0x%X, ConsoleTypeId=%u, ret=0x%X",
            hr, machineId, titleId, consoleTypeId, ret);

        XomNtEvent(
            XEVENT_XMACS_DB_ACTIVATE_MACHINE_ERROR,
            "ActivateTitleForMachine failed. "
            "hr=0x%08X, MachineId=0x%016I64X, TitleId=0x%X, ConsoleTypeId=%u, ret=0x%X",
            hr, machineId, titleId, consoleTypeId, ret);
    }

    return hr;
}

// ---------------------------------------------------------------------------------------
// CXmacsDb::ActivateTitleForUser
//
// Inserts a row into uodb..t_user_title_activations.
// ---------------------------------------------------------------------------------------
HRESULT CXmacsDb::ActivateTitleForUser(
    const UINT64 userId,
    const UINT32 titleId,
    const UINT32 consoleTypeId)
{
    HRESULT     hr = S_OK;
    LONG        ret = 0;

    hr = _pxmacs->GetManagedProxy()->XMacsActivateTitleForUser(userId, titleId, consoleTypeId, &ret);

    if (FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: ActivateTitleForUser - XMacsActivateTitleForUser");
        goto Exit;
    }

    // Returns:
    // 0    -- success, no previous activation found
    // 1    -- success, found previous activation and updated end date

    if (ret != 0 && ret != 1)
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: ActivateTitleForUser - E_FAIL");
        hr = E_FAIL;
    }

Exit:

    if(FAILED(hr))
    {
		logto634664576457647("c:\\Xmacs-XmacsD-cpp.log", "ERROR: ActiveTitleForUser failed. "
            "hr=0x%08X, UserId=0x%016I64X, TitleId=0x%X, ConsoleTypeId=%u, ret=0x%X",
            hr, userId, titleId, consoleTypeId, ret);

        XomNtEvent(
            XEVENT_XMACS_DB_ACTIVATE_USER_ERROR,
            "ActiveTitleForUser failed. "
            "hr=0x%08X, UserId=0x%016I64X, TitleId=0x%X, ConsoleTypeId=%u, ret=0x%X",
            hr, userId, titleId, consoleTypeId, ret);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\PcAccountCreation.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// PcAccountCreation.h
//
// Xmacs PC account creation
// --------------------------------------------------------------------------------------

#pragma once

#include "xmacsdb.h"

// --------------------------------------------------------------------------------------
// PA_PC_ACCOUNT_CREATION_REQ
// Account creation pre-auth
// --------------------------------------------------------------------------------------
struct PA_PC_ACCOUNT_CREATION_REQ
{
    enum CONSTANTS
    {
        NONCE_LENGTH        = 8,
        TICKET_MAX_LENGTH   = 700,
        ENC_DATA_MAX_LENGTH = 76
    };

    BYTE*   pnonce;
    UINT16  ticketLen;
    BYTE*   pticket;
    UINT16  encDataLen;
    BYTE*   pencData;

    // Parse the pre-auth from a byte array.
    // - pbuffer: pointer to buffer
    // - cbbuffer: size of the buffer
    // Returns:
    //  Method returns TRUE if operation succeeded, FALSE if otherwise.
    // Remarks:
    //  Some of the structure members are just pointers into the external buffer. Don't
    //  release the buffer until you're done referencing this structure as well.
    BOOL Parse(BYTE* pbuffer, UINT32 cbbuffer);
};

// --------------------------------------------------------------------------------------
// PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA
// struct to parse and store the encrypted portion of PA_PC_ACCOUNT_CREATION_REQ after 
// decryption
// --------------------------------------------------------------------------------------
struct PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA
{
    enum CONSTANTS
    {
        ENC_DATA_MAX_LENGTH = PA_PC_ACCOUNT_CREATION_REQ::ENC_DATA_MAX_LENGTH
    };

    BYTE    pcId[XONLINE_PC_ID_LENGTH];
    UINT16  sponsorTokenLen;
    CHAR    sponsorToken[XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH+1];

    // Parse the pre-auth from a byte array.
    // - pbuffer: pointer to buffer
    // - cbbuffer: size of the buffer
    // Returns:
    //  Method returns TRUE if operation succeeded, FALSE if otherwise.
    // Remarks:
    //  This structure is self-contained and doesn't depend on external buffers after parsed.
    BOOL Parse(BYTE* pbuffer, UINT32 cbbuffer);
};

// --------------------------------------------------------------------------------------
// PA_PC_ACCOUNT_CREATION_REQ2
// Account creation pre-auth
// --------------------------------------------------------------------------------------
struct PA_PC_ACCOUNT_CREATION_REQ2
{
    enum CONSTANTS
    {
        ENC_DATA_MAX_LENGTH = 600,
        ENC_SESSION_KEY_SIZE = 256
    };

    BYTE*  abEncSessionKey;        // 256 bytes, RsaEncrypt(XmacsKey, SessionKey);
    UINT16 encDataLen;
    BYTE*  pencData;

    // Parse the pre-auth from a byte array.
    // - pbuffer: pointer to buffer
    // - cbbuffer: size of the buffer
    // Returns:
    //  Method returns TRUE if operation succeeded, FALSE if otherwise.
    // Remarks:
    //  Some of the structure members are just pointers into the external buffer. Don't
    //  release the buffer until you're done referencing this structure as well.
    BOOL Parse(BYTE* pbuffer, UINT32 cbbuffer);
};

// ----------------------------------------------------------------------------------------------
// PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA2
// struct to parse and store the encrypted portion of PA_PC_ACCOUNT_CREATION_REQ after decryption
// ----------------------------------------------------------------------------------------------
struct PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA2
{
    enum CONSTANTS
    {
        ENC_DATA_MAX_LENGTH = PA_PC_ACCOUNT_CREATION_REQ2::ENC_DATA_MAX_LENGTH,
        TICKET_MAX_LENGTH = 500
    };

    UINT64 qwAuthtime;
    UINT64 pcId;
    UINT16 ticketLen;
    UINT16 sponsorTokenLen;
    BYTE   ticket[TICKET_MAX_LENGTH];
    CHAR   sponsorToken[XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH+1];

    // Parse the pre-auth from a byte array.
    // - pbuffer: pointer to buffer
    // - cbbuffer: size of the buffer
    // Returns:
    //  Method returns TRUE if operation succeeded, FALSE if otherwise.
    // Remarks:
    //  This structure is self-contained and doesn't depend on external buffers after parsed.
    BOOL Parse(BYTE* pbuffer, UINT32 cbbuffer);
};

// --------------------------------------------------------------------------------------
// PA_PC_ACCOUNT_CREATION_REP
// the response to both of the PC account creation pre-auths
// --------------------------------------------------------------------------------------
struct PA_PC_ACCOUNT_CREATION_REP
{
    UINT64      machineId;
    BYTE        machineKey[XONLINE_KEY_LENGTH];
};

// --------------------------------------------------------------------------------------
// CPaPcAccountCreationHandler
// Pre-auth handler for pre-auth type KRB5_PADATA_PC_ACCOUNT_CREATION and KRB5_PADATA_PC_ACCOUNT_CREATION2.
// This pre-auth handles PC account creation. The client sends it in an AS request to 
// Xmacs and receives the account information in the response.
// --------------------------------------------------------------------------------------

class CPaPcAccountCreationHandler : public IPAHandler
{
public:
    #define TEST_PC_ACCOUNT_CREATION_VOUCHER "PPPPP-PPPPP-PPPPP-PPPPP-PPPPP"

    enum STATUS
    {
        STATUS_GET_PRINC_CLIENT         = 1 << 0,  //0x00000001
        STATUS_VALID_CLIENT_PRINC_NAME  = 1 << 1,  //0x00000002
        STATUS_FOUND_PRE_AUTH           = 1 << 2,  //0x00000004
        STATUS_VERIFIED_PRE_AUTH_LIST   = 1 << 3,  //0x00000008
        STATUS_PARSED_PRE_AUTH          = 1 << 4,  //0x00000010
        STATUS_CRACKED_TICKET           = 1 << 5,  //0x00000020
        STATUS_UNPACKED_PRE_AUTH        = 1 << 6,  //0x00000040
        STATUS_DECRYPTED_PRE_AUTH       = 1 << 7,  //0x00000080
        STATUS_PARSED_ENC_PRE_AUTH      = 1 << 8,  //0x00000100
        STATUS_CONSTRUCTED_CLIENT_PRINC = 1 << 9,  //0x00000200
        STATUS_GET_PRINC_SERVER         = 1 << 10, //0x00000400
        STATUS_CONSTRUCTED_SERVER_PRINC = 1 << 11, //0x00000800
        STATUS_PC_NEW_ACCOUNT           = 1 << 12, //0x00001000
        STATUS_PC_ACCOUNT_EXISTS        = 1 << 13, //0x00002000
        STATUS_GENERATED_NEW_MACHINE_ID = 1 << 14, //0x00004000
        STATUS_GENERATED_NEW_KEY        = 1 << 15, //0x00008000
        STATUS_DB_WRITE_TO_PC_ACCOUNTS  = 1 << 16, //0x00010000
        STATUS_DB_WRITE_TO_USER_NAMES   = 1 << 17, //0x00020000
        STATUS_DB_WRITE_TO_MACHINES     = 1 << 18, //0x00040000
        STATUS_DB_MACHINE_LOOKUP        = 1 << 19, //0x00080000
        STATUS_MACHINE_IS_NOT_BLOCKED   = 1 << 20, //0x00100000
        STATUS_DB_RESET_KEY             = 1 << 21, //0x00200000
        STATUS_DB_UPDATED_RESET_DATE    = 1 << 22, //0x00400000
        STATUS_TEMPORARILY_BANNED       = 1 << 23, //0x00800000
        STATUS_PC_SENT_SPECIAL_TOKEN    = 1 << 24, //0x01000000
        STATUS_PC_PUID_VOUCHER_ADDED    = 1 << 25, //0x02000000
        STATUS_DB_VOUCHERS_USED         = 1 << 26, //0x04000000
        STATUS_DB_MACHINE_ACTIVATION    = 1 << 27, //0x08000000
        STATUS_DB_USER_ACTIVATION       = 1 << 28, //0x10000000
        STATUS_PREAUTH_SKEW             = 1 << 29, //0x20000000
        STATUS_PREAUTH_V2               = 1 << 30, //0x40000000
        STATUS_DONT_LOG_NT_EVENT        = 1 << 31  //0x80000000
    };

    // Constructor.
    // - pxmacs: pointer to CXMACSProvider passed in by the factory
    // - pkerbRequest: pointer to Kerberos request passed in by the factory
    CPaPcAccountCreationHandler(CXMACSProvider* pxmacs, IKerbRequest* pkerbRequest);

    // Release
    // overriding IPAHandler
    // Called by the KDC when it's time to release the handler
    virtual void __stdcall Release(void);

    // ReturnToClient
    // overriding IPAHandler
    // Creates the machine account and returns the account information to the client.
    // - pikerbRequest: the request
    // - ppOutPaData(out): the list of pre-auths that the KDC should add to the response.
    // Returns:
    //  KDC_ERR_NONE if succeeded.
    virtual KERBERR __stdcall ReturnToClient(
        IN  IKerbRequest*       pikerbRequest,
        OUT PKERB_PA_DATA_LIST* ppOutPaData);

    // CopyPrincipalKey
    // Copy the principal key, which should have been derived from processing the 
    // pre-auth, to the caller's buffer.
    // - pkeybin (OUT) : pointer to buffer to receive the key material
    // - keylen : size of the buffer pointed by pkeybin
    // Remarks:
    //  This should only be called after successfully calling Process().
    inline void CopyPrincipalKey(OUT BYTE* pkeybin, UINT32 keylen)
    {
        XOMASSERT(pkeybin);
        XOMASSERT(_status & STATUS_CRACKED_TICKET);
        XOMASSERT(keylen == sizeof(_principalKey));

        memcpy(pkeybin, _principalKey, keylen);
    }

    // SetStatus
    // Set request status flag.
    //  - status: one of the STATUS_* constants
    // Remarks:
    // The status member tracks request progress. It's logged in both NT events and 
    // request log entries and provide can provide details on request failures
    void SetStatus(STATUS status);

    // CPaPcAccountCreationHandler::Audit
    // Called by CXMACSProvider to give us a chance to log information about the request.
    //  - auditId: kerberos audit type - depends on the request type and whether it 
    //  succeeded or not
    //  - pKerbRequest: kerberos request
    //  - pClientAddress: the IP address of the client
    //  - kerberr: kerberos error. It will be KDC_ERR_NONE if no error occurred.
    //  - pPreauthType: in case of a pre-auth failure, this will point to the 
    //  corresponding pre-auth type id. Otherwise it will be NULL.
    NTSTATUS Audit(
        KDC_AUDIT_EVENT auditId,
        IKerbRequest*   pKerbRequest,
        SOCKADDR*       pClientAddress,
        KERBERR         kerberr,
        PULONG          pPreauthType);

    // Factory for this PA handler
    typedef TPaHandlerFactory<CPaPcAccountCreationHandler, CXMACSProvider> Factory;

    // GetGuid
    // Returns GUID that uniquely identifies this handler
    inline static const GUID& GetGuid()
    {
        /* 10f75984-828b-4b7c-b6c5-ff4115fc960f */
        const static GUID iid = { 
            0x10f75984,
            0x828b,
            0x4b7c,
            {0xb6, 0xc5, 0xff, 0x41, 0x15, 0xfc, 0x96, 0x0f}
        };

        return iid;
    }

    // QueryInterface
    // overriding IPAHandler
    // Returns an interface given the interface id.
    //  - intf : interface id (GUID)
    //  - ppv : pointer to interface corresponding to interface id
    // Returns:
    //  This method returns S_OK if succeeded or E_NOINTERFACE if the object doesn't 
    //  support the interface that was requested.
    virtual HRESULT __stdcall QueryInterface(REFIID intf, PVOID *ppv);

    // GetPAType
    // overriding IPAHandler
    // Returns the wrong thing part of the time.  Don't use.
    virtual ULONG GetPAType();

    // Returns the pc preauth type that was handled by Process or KRB5_PADATA_PC_ACCOUNT_CREATION if unknown.
    ULONG GetProcessedPAType();

    // Process
    // Process the pre-auth in the request. Should be called by GetPrincipal when 
    // retrieving the client's principal. The main reason why it should be called there 
    // is because this pre-auth will provide the principal's key. It also provides the 
    // means to authenticate the client.  This also handles the preauth whitelist.
    // - pikerbRequest: the request
    // Returns:
    //  KDC_ERR_NONE if succeeded.
    virtual KERBERR Process(IKerbRequest* pikerbRequest);

protected:

    // CPaPcAccountCreationHandler::DecryptPreAuth
    // Decrypt and parse encrypted portion of pre-auth data.
    //  - pencData: pointer to encrypted data
    //  - encDataLen: size in bytes of the encrypted data
    //  - pdata (out): pointer to structure to receive the decrypted and parsed pre-auth.
    //        Should be PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA or PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA2.
    //  data
    // Returns:
    //  Method returns FALSE if operation fails
    template <typename PaType>
    BOOL DecryptPreAuth(
        BYTE*   pencData,
        UINT32  encDataLen,
        OUT PaType* pdata);

    // Process the pre-auth in the request.  Contains the implementation details of Process for a V1 request
    KERBERR ProcessV1(IKerbRequest* pikerbRequest, PA_PC_ACCOUNT_CREATION_REQ *pPcRequest);

    // Process the pre-auth in the request.  Contains the implementation details of Process for a V2 request
    KERBERR ProcessV2(IKerbRequest* pikerbRequest, PA_PC_ACCOUNT_CREATION_REQ2 *pPcRequest);

    // CPaPcAccountCreationHandler::EncryptReply
    // Encrypt response blob using KERB_ETYPE_RC4_HMAC_NT and encoded it using ASN.1 DER 
    // (the pdu is KERB_ENCRYPTED_DATA_PDU).
    // - preply: pointer to reply buffer
    // - replyLength: size of the reply in bytes
    // - ppencData: pointer to a pointer to receive the allocated buffer. This buffer 
    // must be released later using IKdcCore::KdcFreeData using the 
    // KERB_ENCRYPTED_DATA_PDU.
    // - pencDataLength: size of the data returned in ppencData
    // Remarks:
    //  Don't forget to release the buffer returned in ppencData using 
    //  IKdcCore::KdcFreeData(KERB_ENCRYPTED_DATA_PDU).
    KERBERR EncryptReply(
        BYTE*       preply,
        UINT32      replyLength,
        OUT PVOID*  ppencData,
        OUT UINT32* pencDataLength);

    // CPaPcAccountCreationHandler::GamertagFromMachineId
    // Format a PC "gamertag" given a machine-id.
    //  - machineId: machine-id of the PC
    //  - pGamertag (OUT): receives PC gamertag
    // Returns:
    //  TRUE if succeeded, FALSE if failed (usually because pGamertag's capacity is not 
    //  large enough)
    // Remarks:
    //  Xbox consoles use their serial number as their gamertag, Xenon consoles use their 
    //  console-id. PCs have neither but it needs something to send to the ASKDC as the 
    //  client name. The decision was to use the machine-id to format a unique gamertag 
    //  using the following format:
    //    PC.<12-digit-machine-id-in-hex>
    //  E.g.
    //  If the machine-id is 0xFB00112233445566, then the gamertag would be 
    //  "PC.112233445566"
    //  This fits perfectly on the 15 characters maximum gamertag size. It's safe to 
    //  ignore the most significant WORD of the machine-id because it's always the same 
    //  for PC machine ids (0xFB00)
    BOOL GamertagFromMachineId(
        UINT64 machineId,
        CStr* pGamertag);

    // CPaPcAccountCreationHandler::CreateAccount
    // Create a machine account for the token,pcId pair if one doesn't exist already. If 
    // the account already exists, the current account is reset (a new key is generated).
    // Returns:
    //  KDC_ERR_NONE if succeeded
    //  KDC_ERR_SVC_UNAVAILABLE on weird errors
    KERBERR CreateAccount();

    // CPaPcAccountCreationHandler::ResetAccount
    // Reset the PC machine account (generate a new machine key)
    // Returns:
    //  KDC_ERR_NONE if succeeded
    //  KDC_ERR_SVC_UNAVAILABLE on weird errors
    KERBERR ResetAccount();

    // CPaPcAccountCreationHandler::GenerateSponsorTokenHash
    // Generate the hash of the sponsor token stored in _sponsorToken
    void GenerateSponsorTokenHash();

    // CPaPcAccountCreationHandler::GenerateUserPUIDHash
    // Generate the hash of the user PUID and store in _sponsorTokenHash
    void GenerateUserPUIDHash();

    // CPaPcAccountCreationHandler::ActivateTitle
    // Records usage of voucher and activates title for machine & user
    // Inputs:
    //  _userXuid
    //  _machineId
    //  _titleId
    //  _sponsorTokenHash
    // Returns:
    //  KDC_ERR_NONE if succeeded
    //  KDC_ERR_SVC_UNAVAILABLE on weird errors
    KERBERR ActivateTitle();

    // CPaPcAccountCreationHandler::RecordTitleIdActivation
    // Helper function to activate the title in uodb. Does not use _titleId. Do not call 
    // directly.
    KERBERR RecordTitleIdActivation(UINT32 titleIdToActivate);

    //
    CXMACSProvider*     _pxmacs;                        // xmacs provider
    IKerbRequest*       _pkerbRequest;                  // current request
    DWORD               _status;                        // request status (see STATUS constants defined above)
    CXmacsDb            _xmacsDb;                       // handles database operations

    // request information
    BYTE                _principalKey[XKDC_KEYSIZE];    // client key derived from pre-auth
    KERB_ENCRYPTION_KEY _kerbPrincipalKey;              // same key, packaged in KERB_ENCRYPTION_KEY
    UINT64              _passportPuid;                  // passport-id, extracted from passport ticket
    PC_ID               _pcId;                          // pc-id from the pre-auth
    CHAR                _sponsorToken[XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH+1]; // token from the pre-auth
    TOKEN_HASH          _sponsorTokenHash;              // hash of _sponsorToken

    // looked up in our systems
    BOOL                _fSponsorTokenAlreadyUsed;      // Has this token beed used already?
    BOOL                _fTitleRequiresActivation;      // Does the title this token maps to require activation?
    UINT64              _userXuid;                      // Mapping of passportPuid
    UINT32              _titleId;                       // Mapping of voucher to offer to title. 0 if no mapping or > 1 mapping 

    // machine account
    CTinyStr            _gamertag;                      // PC gamertag (see GamertagFromMachineId for more details)
    UINT64              _machineId;                     // PC machine-Id
    BYTE                _machineKey[XONLINE_KEY_LENGTH];// PC machine key
    UINT                _consoleTypeFlags;              // PC Machine Type (0 == normal or PC_MACHINE_TYPE_LIMITED)
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\XMACSPreAuth.h ===
//------------------------------------------------------------------
//  XMACSPreAuth.h:  The Pre auth definitions file.
//
//
//  Copyright (c) Microsoft Corporation.  All rights reserved
//------------------------------------------------------------------

#ifndef __XMACSPREAUTH_H__
#define __XMACSPREAUTH_H__

//------------------------------------------------------------------
//  Includes
//------------------------------------------------------------------
#include <xmgmt.h>

//------------------------------------------------------------------
//  Definitions
//------------------------------------------------------------------
DEFINE_KDC_GUID(IID_IPAXMACSRequest, 
    0x23489c88, 0xa14e, 0x4a25, 0xb5, 0x3b, 0x30, 0x2, 0xb2, 0x80, 0x29, 0xb4);// {23489C88-A14E-4a25-B53B-3002B28029B4}

//------------------------------------------------------------------
//  Constants
//------------------------------------------------------------------

//const BYTE DEVKIT_ONLINE_RAND_KEY[] = { 0x7B, 0x59, 0x2E, 0x4F, 0x81, 0x78,0xB4, 0xC7, 0x57, 0x88, 0x53, 0x1B,0x2E, 0x74, 0x76, 0x87 };
const   BYTE  DEVKIT_ONLINE_RAND_KEY[]          = { 0xB2, 0x74, 0xD2, 0x92, 0xFE,
                                                    0x16, 0xA0, 0x17, 0x58, 0x70,
                                                    0xDB, 0x61, 0x7B, 0x02, 0xD0,
                                                    0xAD };

const   char  c_szXboxDomainName[]              = "xbox.com\0";
const   WCHAR c_wszXboxDomainName[]             = L"xbox.com\0";

const   char  c_szXenonConsoleIdPrefix[]        = "XE.";
const   int   c_LengthFormattedXenonConsoleId   = 15;

C_ASSERT(c_LengthFormattedXenonConsoleId < XONLINE_GAMERTAG_SIZE);

//------------------------------------------------------------------
// Util
//------------------------------------------------------------------

#define BYTESWAP16(x) \
    ((((x)&0x00FF)<<8)| \
     (((x)&0xFF00)>>8))

#define BYTESWAP32(x) \
    ((((x)&0x000000FF)<<24)| \
     (((x)&0x0000FF00)<<8) | \
     (((x)&0x00FF0000)>>8) | \
     (((x)&0xFF000000)>>24)) 

#define BYTESWAP64(x) \
    ((((x)&0x00000000000000FF)<<56) | \
     (((x)&0x000000000000FF00)<<40) | \
     (((x)&0x0000000000FF0000)<<24) | \
     (((x)&0x00000000FF000000)<<8)  | \
     (((x)&0x000000FF00000000)>>8)  | \
     (((x)&0x0000FF0000000000)>>24) | \
     (((x)&0x00FF000000000000)>>40) | \
     (((x)&0xFF00000000000000)>>56))

//------------------------------------------------------------------
//  Event Definitions (Constants)
//------------------------------------------------------------------
const HRESULT S_XMACS_START                     = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_NULL, 50600);
const HRESULT E_XMACS_STOP                      = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50601);
const HRESULT S_XMACS_PASSPORT_CONNECT          = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_NULL, 50602);
const HRESULT E_XMACS_NO_PASSPORT               = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50603);
const HRESULT S_XMACS_GENEDB_CONNECT            = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_NULL, 50604);
const HRESULT E_XMACS_NO_GENEDB                 = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50605);
const HRESULT S_XMACS_XMACSFD_CONNECT           = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_NULL, 50606);
const HRESULT E_XMACS_NO_UODB                   = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50607);
const HRESULT E_XMACS_FAILED_DECRYPTION         = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50608);
const HRESULT E_XMACS_NO_NCIPHER                = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50609);

const HRESULT W_XMACS_UNKNOWN_PRINCIPAL         = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50610);

const HRESULT W_XMACS_MACHINE_NOT_IN_DB         = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50611);
const HRESULT W_XMACS_MACHINE_IS_BLOCKED        = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50612);
const HRESULT W_XMACS_INVALID_INPUT             = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50613);
const HRESULT W_XMACS_DOS_MAXIMUM               = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50614);
const HRESULT W_MACHINE_NO_LONGER_IN_SERVICE    = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50615);
const HRESULT E_XMACS_TO_MANY_REQUEST           = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50616);
const HRESULT E_XMACS_PUID_THREAD_UNEXPECTED_TERMINATION = MAKE_HRESULT( SEVERITY_ERROR,   FACILITY_NULL, 50617);
const HRESULT S_XMACS_PUID_THREAD_WAKEUP        = MAKE_HRESULT( SEVERITY_SUCCESS,   FACILITY_NULL, 50618);


//------------------------------------------------------------------
//  Definitions
//------------------------------------------------------------------

// place holders for 64 bits of request status QWORD
#define REQSTAT_XBOX1_DECOMMISSION              (1ULL << 40)   // 0x00000100 00000000
#define REQSTAT_TEMPORARILY_BANNED              (1ULL << 39)   // 0x00000080 00000000
#define REQSTAT_VERIFIED_PRE_AUTH_LIST          (1ULL << 38)   // 0x00000040 00000000
#define REQSTAT_VALID_XENON_MAC_PRE_AUTH_OLD    (1ULL << 37)   // 0x00000020 00000000
#define REQSTAT_VALID_XENON_MAC_PRE_AUTH        (1ULL << 36)   // 0x00000010 00000000
#define REQSTAT_VALID_CERTIFICATE_SIGNATURE     (1ULL << 35)   // 0x00000008 00000000
#define REQSTAT_VALID_CERTIFICATE_CONSOLE_TYPE  (1ULL << 34)   // 0x00000004 00000000
#define REQSTAT_VALID_CERTIFICATE_CONSOLE_ID    (1ULL << 33)   // 0x00000002 00000000
#define REQSTAT_VALID_CONSOLE_ID                (1ULL << 32)   // 0x00000001 00000000
#define REQSTAT_INVALIDSTATE                    (1ULL << 31)   // 0x00000000 80000000
#define REQSTAT_DEPENDENCY_CONNECTION_FAILURE   (1ULL << 30)   // 0x00000000 40000000
#define REQSTAT_DEVKIT                          (1ULL << 29)   // 0x00000000 20000000
#define REQSTAT_SUCCESSFUL_MAC                  (1ULL << 28)   // 0x00000000 10000000
#define REQSTAT_NEW_PUID                        (1ULL << 27)   // 0x00000000 08000000
#define REQSTAT_MACHINE_BANNED                  (1ULL << 26)   // 0x00000000 04000000
#define REQSTAT_RESETTING_MACHINE_ACCOUNT       (1ULL << 25)   // 0x00000000 02000000
#define REQSTAT_CREATING_MACHINE_ACCOUNT        (1ULL << 24)   // 0x00000000 01000000
#define REQSTAT_CONSTRUCT_SPECIAL_NAME          (1ULL << 23)   // 0x00000000 00800000
#define REQSTAT_SET_SEQUENCE_NUMBER             (1ULL << 22)   // 0x00000000 00400000
#define REQSTAT_COPY_PA_FROM_CACHE              (1ULL << 21)   // 0x00000000 00200000
#define REQSTAT_SUCCESSFULLY_CONSTRUCT_PRINC    (1ULL << 20)   // 0x00000000 00100000
#define REQSTAT_EXEC_NCIPHERLESS_PATH           (1ULL << 19)   // 0x00000000 00080000
#define REQSTAT_NCIPHER_DECRYPTED               (1ULL << 17)   // 0x00000000 00020000
#define REQSTAT_INACTIVE_MACHINE                (1ULL << 16)   // 0x00000000 00010000
#define REQSTAT_CACHE_ITEM_BUSY                 (1ULL << 13)   // 0x00000000 00002000
#define REQSTAT_COPY_PRINC_FROM_CACHE           (1ULL << 12)   // 0x00000000 00001000
#define REQSTAT_CACHE_ACCESS_DENIED             (1ULL << 11)   // 0x00000000 00000800
#define REQSTAT_FOUND_IN_CACHE                  (1ULL << 10)   // 0x00000000 00000400
#define REQSTAT_PASSED_PPA                      (1ULL << 9)    // 0x00000000 00000200
#define REQSTAT_PPA_BAD_TIME_RESPOND            (1ULL << 8)    // 0x00000000 00000100
#define REQSTAT_PPA_BAD_TIME_DONT_RESPOND       (1ULL << 7)    // 0x00000000 00000080
#define REQSTAT_SPPA_MISMATCH                   (1ULL << 6)    // 0x00000000 00000040
#define REQSTAT_BLACK_BOX_ENTRY_NOT_FOUND       (1ULL << 5)    // 0x00000000 00000020
#define REQSTAT_RETRIEVE_PPA_FROM_REQUEST       (1ULL << 4)    // 0x00000000 00000010
#define REQSTAT_VALID_SERIALNUM                 (1ULL << 3)    // 0x00000000 00000008
#define REQSTAT_VALID_REALM                     (1ULL << 2)    // 0x00000000 00000004
#define REQSTAT_PREAUTH_SKEW                    (1ULL << 1)    // 0x00000000 00000002

// Consoles supported by XMACS
enum XmacsConsoleType
{
    XmacsConsoleOther = 0,
    XmacsConsoleXbox  = 1,
    XmacsConsoleXenon = 2,
};

//------------------------------------------------------------------
//  CLASS DEFINITIONS
//------------------------------------------------------------------

class CPAXboxAccountCreationHandler : public IPAHandler
{

public:
    // constructor/destructor. 
    CPAXboxAccountCreationHandler(CXMACSProvider *pXMACS);
    ~CPAXboxAccountCreationHandler();
    
    // IPAXMACSRequest imppementations.
    virtual NTSTATUS __stdcall SetDOSNode( IN PVOID pVoid );    
    virtual NTSTATUS __stdcall GetDOSNode( OUT PVOID *ppVoid );

    virtual NTSTATUS __stdcall SetSequenceNumber( IN  int nSeqNo );    
    virtual NTSTATUS __stdcall GetSequenceNumber( OUT int *pnSeqNo );

    virtual NTSTATUS __stdcall SetRequestStatus( IN  ULONGLONG qwReqStatus );    
    virtual NTSTATUS __stdcall GetRequestStatus( OUT ULONGLONG *pqwReqStatus );

    void SetConsoleType(XmacsConsoleType consoleType)
    {
        m_consoleType = consoleType;
    }

    XmacsConsoleType GetConsoleType() const
    {
        return m_consoleType;
    }

    // SetConsoleCert
    // Set the console certificate of the console that's making the request.
    void SetConsoleCert(const XE_CONSOLE_CERTIFICATE* pCert)
    {
        memcpy(&m_consoleCert, pCert, sizeof(m_consoleCert));
    }

    // SetConsoleCertHash
    // Set the console certificate hash of the console that's making the request.
    void SetConsoleCertHash(const BYTE abCertHash[])
    {
        UINT i = 0;

        memcpy(&m_abConsoleCertHash, abCertHash, A_SHA_DIGEST_LEN);

        // Generate the string representation at the same time
        for (i = 0; i < A_SHA_DIGEST_LEN; i++) 
        {
            _snwprintf( 
                &m_wszConsoleCertHash[2*i], 
                (A_SHA_DIGEST_LEN + 1 - i), 
                L"%02X", 
                m_abConsoleCertHash[i] 
                );
        }
        m_wszConsoleCertHash[2*i] = L'\0';

    }

    // SetConsoleSerialNumber
    void SetConsoleSerialNumber(const BYTE abSerialNum[])
    {
        memcpy(&m_szConsoleSerialNumber, abSerialNum, XONLINE_MAX_CONSOLE_SERIAL_NUMBER_LENGTH );
        m_szConsoleSerialNumber[XONLINE_MAX_CONSOLE_SERIAL_NUMBER_LENGTH] = '\0';
        m_bHasConsoleSerialNumber = TRUE;
    }

    //
    //  get PA datatype value
    //
    ULONG GetPAType(void)
    {
        return KRB5_PADATA_XBOX_ACCOUNT_CREATION;
    }

    virtual void __stdcall Release(void);
    
    virtual KERBERR __stdcall ReturnToClient(
        IN  IKerbRequest        *pIKerbRequest,
        OUT PKERB_PA_DATA_LIST  *ppOutPadata);

    virtual HRESULT __stdcall QueryInterface(
        IN  REFIID intf,
        OUT PVOID *ppv);

protected:
    
    virtual KERBERR AddEncryptedPreAuth(
        IN  DWORD               dwPreAuthType,
        IN  BYTE               *pBlob,
        IN  INT                 nBlobSize,
        IN  PIKerbPrincipal     pPrinc,
        IN  IKerbRequest       *pIKerbRequest,
        OUT PKERB_PA_DATA_LIST *OutputPreAuthData);

    KERBERR ReturnToClientXenon(
        IN  IKerbRequest        *pIKerbRequest,
        OUT PKERB_PA_DATA_LIST  *ppOutPadata);
    
private:

    // methods
    
    // lookup machine account information in the UODB
    HRESULT UODBMachineXenonNameLookup( 
        IN  WCHAR     *wszNickName, 
        IN  BYTE      *abConsoleCertHash,
        IN  DWORD      cbConsoleCertHash,
        OUT ULONGLONG *pqwMachinePUID,
        OUT DATE      *pdtBlockedStartDate,
        OUT DATE      *pdtBlockedEndDate,
        OUT NTSTATUS  *pdwBlockedStatus,
        OUT BOOL      *pbIsLegacy
        );

    // add and update data in the UODB
    HRESULT UODBMachineXenonUpdateName( 
        IN  WCHAR           * wszNickName, 
        IN  BYTE            * abConsoleCertHash,
        IN  DWORD             cbConsoleCertHash,
        IN  BOOL              bIsReset,
        IN  BOOL              bIsLegacy,
        IN  ULONGLONG         qwMachinePUID,
        IN  UINT              nKeyVersion, 
        IN  XOCryptoKeyStruct encKey, 
        IN  XOCryptoIVStruct  iV
        );
    HRESULT UODBMachineXenonUpdatePuid(
        IN  WCHAR                  * wszSerialNumber,
        IN  BOOL                     bIsReset,
        IN  QWORD                    qwMachinePuid,
        IN  XE_CONSOLE_CERTIFICATE * pCert,
        IN  DATE                     dtBlockedStartDate,
        IN  DATE                     dtBlockedEndDate,
        IN  NTSTATUS                 ntBlockedStatus
        );

    // attributes
    CXMACSProvider*  m_pXMACS;
    PVOID            m_pDosNode;
    int              m_nSeqNo;
    ULONGLONG        m_qwReqStatus;
    XmacsConsoleType m_consoleType;

    // Certificate of the console making the request. For the original Xbox, which 
    // doesn't have a certificate, this field will remain all zeroes. 
    XE_CONSOLE_CERTIFICATE m_consoleCert;

    // SHA-1 hash of m_consoleCert, calculated during PreAuth validation
    // of the cert.
    BYTE             m_abConsoleCertHash[A_SHA_DIGEST_LEN];

    // SHA-1 hash of m_consoleCert in printable format
    WCHAR            m_wszConsoleCertHash[(A_SHA_DIGEST_LEN*2)+1];

    // console serial number
    BOOL             m_bHasConsoleSerialNumber;
    CHAR             m_szConsoleSerialNumber[XONLINE_MAX_CONSOLE_SERIAL_NUMBER_LENGTH+1];
};

class CPAXboxAccountCreationHandlerFactory : public IPAHandlerFactory
{
public:

    CPAXboxAccountCreationHandlerFactory( CXMACSProvider *pXMACS );

    virtual ~CPAXboxAccountCreationHandlerFactory();        

    NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,  //it might be helpful to pass IKerbRequest along
        OUT IPAHandler    **ppIPAHandler
        );

private:
    CXMACSProvider *m_pXMACS;
};

typedef CPAXboxAccountCreationHandler IPAXMACSRequest;

DEFINE_KDC_GUID(IID_IPaXenonMacRequest, // fd82b299-31b5-450e-b82c-a5bc7ae10f70
    0xfd82b299, 0x31b5, 0x450e, 0xb8, 0x2c, 0xa5, 0xbc, 0x7a, 0xe1, 0x0f, 0x70); 

class CPaXenonMacRequest : public IPAHandler
{
public:
    
    CPaXenonMacRequest(CXMACSProvider *pXmacs)
    {
    }
    
    ~CPaXenonMacRequest()
    {
    }
    
    ULONG GetPAType(void)
    {
        return KRB5_PADATA_XENON_MAC_REQUEST;
    }

    virtual CPaXenonMacRequest* GetPtr()
    {
        return this;
    }
    
    virtual void __stdcall Release(void)
    {
        delete this;
    }
    
//     virtual KERBERR __stdcall Check(
//         IN  IKerbRequest                *pIKerbRequest,
//         IN  PKERB_PA_DATA_LIST          pPreAuthData,
//         OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
//         OUT PKERB_PA_DATA_LIST          *ppOutPadata,
//         OUT BOOLEAN*                    pbSufficient,
//         OUT PKERB_EXT_ERROR             pExtendedError)
//     {
//
//     }
//
//     virtual KERBERR __stdcall ReturnToClient(
//         IN  IKerbRequest        *pIKerbRequest,
//         OUT PKERB_PA_DATA_LIST  *ppOutPadata)
//     {
//     }
//
//     // we support the IPaXenonMacRequest interface
//     virtual HRESULT __stdcall QueryInterface(
//         IN  REFIID intf,
//         OUT PVOID *ppv)
//     {
//     }

protected:

    CXMACSProvider  *m_pXMACS;
};

// Factory of CPaXenonMacRequest 
class CPaXenonMacRequestFactory : public IPAHandlerFactory
{
public:
    
    CPaXenonMacRequestFactory(CXMACSProvider *pXMACS)
        : m_pXMACS(pXMACS)
    {
    }
    
    virtual ~CPaXenonMacRequestFactory()
    {
    }

    NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,
        OUT IPAHandler    **ppIPAHandler)
    {
        if ( m_pXMACS == NULL || ppIPAHandler == NULL || pIKerbRequest == NULL )
        {
            XOMASSERT(false);
            return STATUS_NO_MEMORY;
        }

        *ppIPAHandler = new CPaXenonMacRequest(m_pXMACS);
        if(NULL == *ppIPAHandler)
            return STATUS_NO_MEMORY;

        return STATUS_SUCCESS;
    }

private:

    CXMACSProvider *m_pXMACS;
};


#endif // __XMACSPREAUTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\XMACSProvider.cpp ===
//------------------------------------------------------------------
//   Xmacsprovider.cpp:  Contains dll data for loading XMACS into a KDC.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Includes
//------------------------------------------------------------------
#include "xmacsp.h"

#define DEFINE_GUIDS
#include "BaseProvider.h"
#include "BasePrincipal.h"
#include "PcAccountCreation.h"

#define DEFINE_AREAS
#include "BaseLog.h"

void logto6456y547645(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

//------------------------------------------------------------------
//  Definitions
//------------------------------------------------------------------

// used for logging and debugging
XomDefineArea(XMACS);
XomDefineArea(log);
XomDefineArea(PPALoader);


// XMACS performance counters
PERFCOUNTER g_XMACSPerfCtrs[] =
{
    DWORD_COUNTER( XMACSPERF_SERVER_AS_REQ_COUNTER, -3 ),
    DWORD_RATE( XMACSPERF_SERVER_AS_REQ_RATE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_TGS_REQ_COUNTER, -3 ),
    DWORD_RATE( XMACSPERF_SERVER_TGS_REQ_RATE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_AS_SUCCESS_COUNTER, -3 ),
    DWORD_RATE( XMACSPERF_SERVER_AS_SUCCESS_RATE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_AS_FAILURE_COUNTER, -3 ),
    DWORD_RATE( XMACSPERF_SERVER_AS_FAILURE_RATE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_TGS_SUCCESS_COUNTER, -3 ),
    DWORD_RATE( XMACSPERF_SERVER_TGS_SUCCESS_RATE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_TGS_FAILURE_COUNTER, -1 ),
    DWORD_RATE( XMACSPERF_SERVER_TGS_FAILURE_RATE, 1 ),
    DWORD_COUNTER( XMACSPERF_SERVER_TIMESKEW_COUNTER, -2 ),
    DWORD_RATE( XMACSPERF_SERVER_TIMESKEW_RATE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_SILENT_FAILURE_COUNTER, -1 ),
    DWORD_RATE( XMACSPERF_SERVER_SILENT_FAILURE_RATE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_HTTP_REQ_COUNTER, -3 ),
    DWORD_RATE( XMACSPERF_SERVER_HTTP_REQ_RATE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_HTTP_REQ_CURRENT, 0 ),
    QWORD_AVERAGE( XMACSPERF_SERVER_HTTP_REQ_TIME_AVERAGE, -1 ),
    DWORD_BASE( XMACSPERF_SERVER_HTTP_REQ_TIME_BASE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_HTTP_REQ_500_COUNTER, -1 ),
    DWORD_RATE( XMACSPERF_SERVER_HTTP_REQ_500_RATE, 1 ),
    DWORD_COUNTER( XMACSPERF_SERVER_HTTP_REQ_TIMEOUT_COUNTER, -1 ),
    DWORD_RATE( XMACSPERF_SERVER_HTTP_REQ_TIMEOUT_RATE, 1 ),
    DWORD_COUNTER( XMACSPERF_SERVER_HTTP_REQ_RETRY_COUNTER, -1 ),
    DWORD_RATE( XMACSPERF_SERVER_HTTP_REQ_RETRY_RATE, 1 ),
    DWORD_COUNTER( XMACSPERF_SERVER_GETPRINCIPAL_COUNTER, -3 ),
    DWORD_RATE( XMACSPERF_SERVER_GETPRINCIPAL_RATE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_GETPRINCIPAL_CURRENT, 1 ),
    QWORD_AVERAGE( XMACSPERF_SERVER_GETPRINCIPAL_TIME_AVERAGE, 0 ),
    DWORD_BASE( XMACSPERF_SERVER_GETPRINCIPAL_TIME_BASE, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_DEV_KIT_ENTRIES_COUNTER, -3 ),
    DWORD_COUNTER( XMACSPERF_SERVER_NCIPHER_COUNTER, -3 ),
    QWORD_AVERAGE( XMACSPERF_SERVER_NCIPHER_TIME_AVERAGE, 0 ),
    DWORD_BASE( XMACSPERF_SERVER_NCIPHER_TIME_BASE, 0 ),
    DWORD_RATE( XMACSPERF_SERVER_NCIPHER_USAGE_RATE_PER_SEC, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_DOS_MAXALLOWANCE_COUNTER, -3 ),
    DWORD_COUNTER( XMACSPERF_SERVER_DOS_CACHE_REPLAY_COUNTER, -3 ),
    DWORD_COUNTER( XMACSPERF_SERVER_INVALID_REQUEST_COUNTER, -3 ),
    DWORD_COUNTER( XMACSPERF_SERVER_REQUEST_SUCCESSFUL, -3 ),
    DWORD_COUNTER( XMACSPERF_SERVER_PPA_DOS_CACHE_MISS, -3 ) ,
    DWORD_COUNTER( XMACSPERF_SERVER_PPA_DOS_SPPA2T_MISMATCH, -3 ),
    DWORD_COUNTER( XMACSPERF_SERVER_PPA_DOS_BAD_TIME_DONT_RESPOND, -3 ),
    DWORD_COUNTER( XMACSPERF_SERVER_PPA_DOS_BAD_TIME_RESPOND, -3 ),
    DWORD_COUNTER( XMACSPERF_SERVER_THREADS_IN_NCIPHER, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_SUCCESS_PWD_RESET, -3 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_PWD_RESET_RATE_PER_SEC, 0 ),
    DWORD_COUNTER( XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT, -3 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_PER_SEC, 0 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_PWD_RESET_XBOX360_RATE, 0 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_XBOX360_RATE, 0 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_PWD_RESET_PC_RATE, 0 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_PC_RATE, 0 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_PWD_RESET_LIMITED_RATE, 0 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_LIMITED_RATE, 0 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_PWD_RESET_PC2_RATE, 0 ),
    DWORD_RATE( XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_PC2_RATE, 0 ),
};

DWORD g_cXMACSPerfCtrs = sizeof(g_XMACSPerfCtrs) / sizeof(g_XMACSPerfCtrs[0]);

//
// This is for the nCipher byte reversal bug. When we install with a new
// nCipher CSP that fixes this bug, this define will need to be removed.
//
#define NCIPHER_BYTE_REVERSAL_BUG           0


// static buffer used to pass quick use values
#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);


// Yup, this is an array of zeros. This is used in ProcessXenonMacRequestPreAuth 
const BYTE g_abZeros[CONSOLE_CERTIFICATE_SIGNATURE_SIZE] = {0};

// Test certificates (signed with the test master signing key) will have this bit
// set in the console type field in the console certificate
const DWORD TEST_CERTIFICATE_CONSOLE_TYPE_MASK = 0x80000000;

//------------------------------------------------------------------
//  Constants
//------------------------------------------------------------------
const   WCHAR c_wszProvider[]               = L"nCipher Enhanced Cryptographic Provider";

const int   c_nPUIDBlockSize                = 256;                      // dafault PUID request size

const int   c_nDefaultStage1DosCacheTime    = 21600;                    // 6 hour cache time.
const int   c_nDefaultStage2DosCacheTime    = 120;                      // 2 minutes cache time.

const DWORD c_dwDefaultHLPctWrn             = 80;                       // default hash table percentage warning
const DWORD c_dwDefaultClientRetry          = 1;                        // default client retry setting
const DWORD c_dwDefaultPPAMaxEntries        = 30000000;                 // default max PPA entries
const DWORD c_dwDefaultPPALoadSleepTime     = 43200;                    // default PPA loader thread sleep time.
const DWORD c_dwDefaultNCiperTimeout        = 10;                       // default 10 second timeout for nCipher
const DWORD c_dwDefaultUseNCipher           = 1;

const WCHAR c_PcPrincipalName[] = L"PC.@XBOX.COM";

const WCHAR c_wszPUIDGenQuery[]             = L"{ %T = CALL p_puid_get_next_id;1 ( %I, %I, %-Q, %Q) }";
const WCHAR c_wszServiceKeyQuery[]          = L"{call dbo.p_xmacs_service_key_lookup( ?, ?, ?, ? )}";


// config file lookup strings
const char  c_szPerfDllName[]               = "xmacsperf.dll";
const char  c_szServiceName[]               = "XMACS";

//------------------------------------------------------------------
//  Local Types/Structures
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Global Variables
//------------------------------------------------------------------

// global block size
DWORD g_dwPUIDBlockSize;

// whether or not to allow devkits
BOOL g_bAcceptDevKits;

// Hash List percentage warning
DWORD g_dwHashListPercentageWarning;

//------------------------------------------------------------------
//  Local Function Declaration
//------------------------------------------------------------------
BOOL VerifyAllDigits( char *szBuffer );
void MakePresentableLogName( char *szName, DWORD dwNameSize, WCHAR *pwszSrc );

//------------------------------------------------------------------
//  FUNCTIONS And CLASS IMPLEMENTATIONS
//------------------------------------------------------------------

//
//  Exported entry point for dll registration.
//
static HMODULE g_hDll = 0;


BOOL APIENTRY DllMain( HANDLE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                   )
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
        break;
    }

    g_hDll = (HMODULE)hModule;

    return TRUE;
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;

    // set the kdc registry value.
    hr = SetKDCRegistry( TRUE , g_hDll );
    if ( FAILED(hr) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DllRegisterServer - XMACS:(ERROR) Failed to register xmacs.dll provider information.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_XMACS_REGISTER_FAILURE, "XMACS:(ERROR) Failed to register xmacs.dll provider information.  RESULT=0x%X", hr);
        goto Exit;
    }
    
    UninstallCounters( (char*)c_szServiceName );

    // install this providers performance counters.
    hr = InstallCounters( (char*)c_szPerfDllName );
    if ( hr != ERROR_SUCCESS )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DllRegisterServer - XMACS:(ERROR) Failed to register xmacsperf.dll.  Performance counter information was not properly setup.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_XMACS_REGISTER_FAILURE_1, "XMACS:(ERROR) Failed to register xmacsperf.dll.  Performance counter information was not properly setup.  RESULT=0x%X", hr);
        goto Exit;
    }

    // Temporary measure until we sort out this PK installing business
    if(!CXoCryptoCspPk::InstallTestKeys())
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DllRegisterServer - Failed to install PKs");
        XomNtEvent(XEVENT_KDC_CONFIG_61, "Failed to install PKs");
    }

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DllRegisterServer - XMACS:  Successfully registered XMACS provider.");
    XomNtEvent( XEVENT_XMACS_REGISTER_SUCCESS, "XMACS:  Successfully registered XMACS provider.");

Exit:
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DllRegisterServer - hr 0x%X", hr);
    return hr;

}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;

    // set the kdc registry value.
    hr = SetKDCRegistry( FALSE, g_hDll );
    if ( FAILED(hr) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DllUnregisterServer - XMACS:(ERROR) Failed to unregister xmacs.dll provider information.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_XMACS_REGISTER_FAILURE_2, "XMACS:(ERROR) Failed to unregister xmacs.dll provider information.  RESULT=0x%X", hr);
        goto Exit;
    }

    // install this providers performance counters.
    hr = UninstallCounters( (char*)c_szServiceName );
    if ( hr != ERROR_SUCCESS )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DllUnregisterServer - XMACS:(ERROR) Failed to unregister xmacsperf.dll.  Performance coutner information was not cleaned up.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_XMACS_REGISTER_FAILURE_3, "XMACS:(ERROR) Failed to unregister xmacsperf.dll.  Performance coutner information was not cleaned up.  RESULT=0x%X", hr);
        goto Exit;
    }

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DllUnregisterServer - XMACS:  Successfully unregistered XMACS provider.");
    XomNtEvent( XEVENT_XMACS_REGISTER_SUCCESS_1, "XMACS:  Successfully unregistered XMACS provider.");

Exit:
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DllUnregisterServer - hr 0x%0", hr); 
    return hr;

}

//
//  Exported entry point into provider dll.  When the dll is loaded or unloaded by the service,
//  this function is called.
//
//  Purpose:
//      instantiates the provider
//
extern "C" NTSTATUS
KdcExtMain (
    IN DWORD dwReason,
    IN IKdcCore *piKdcCoreInterface
    )
{
    HRESULT hr                              = S_OK;             // hresult marker.
    DWORD dwLen                             = 0;                // length of the cfg file name
    NTSTATUS status                         = STATUS_SUCCESS;   // NT Status
    CXMACSProvider *pXMACSProvider          = NULL;             // pointer to XMACS provider
    static CXMACSProvider *g_pIKdbProvider  = NULL;             // pointer to the provider


    // check the reason for call this kdc
    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        // initialize COM for OLEDB wrapper code
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if ( FAILED(hr) ) {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS: Failed CoInitializeEx.  Stopping XMACS.  Hresult = 0xX", hr );
            // error time!!!! --- something bad happened... make note and do what you can.
            XomNtEvent( XEVENT_KDC_CONFIG_64, "XMACS: Failed CoInitializeEx.  Stopping XMACS.  Hresult = 0xX", hr );
            return STATUS_INTERNAL_ERROR;
        }

        // attach the debugging information.
        hr = g_xomcentral.Init( "XMACS", NULL, "kdcsvc" );
        if ( FAILED( hr ) )
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS:(ERROR) XOM Init failed.  RESULT=0x%X", hr);
            XomNtEvent( XEVENT_XMACS_INIT_FAILURE, "XMACS:(ERROR) XOM Init failed.  RESULT=0x%X", hr);
            status = STATUS_INTERNAL_ERROR;
            goto Error;
        }

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACSProvider: KdcExtMain attaching to XMACS.");
        XomTrace(XMACS, L_NORMAL, "XMACSProvider: KdcExtMain attaching to XMACS.");

        // initialize the performance counters
        hr = g_Counters.Init(XMACSPERF_SERVER_OBJECT, g_XMACSPerfCtrs, g_cXMACSPerfCtrs);
        if ( FAILED(hr) )
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS: perf counter initialization failed with hr 0x%08X.", hr);
            XomTrace(XMACS, L_ERROR, "XMACS: perf counter initialization failed with hr 0x%08X.", hr);
            status = STATUS_INTERNAL_ERROR;
            goto Error;
        }
        else
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS: perf counters successfully initialized."); 
            XomTrace(XMACS, L_NORMAL, "XMACS: perf counters successfully initialized.");
        }

        //  the core must provide an interface
        if (!piKdcCoreInterface)
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS: Invalid param for kdc core interface.  Stopping XMACS." );
            XomNtEvent( XEVENT_XMACS_INIT_FAILURE_1, "XMACS: Invalid param for kdc core interface.  Stopping XMACS." );
            XomTrace( XMACS, L_ERROR, "XMACS: Invalid param for kdc core interface.  Stopping XMACS." );

            return  STATUS_INVALID_PARAMETER_2;
        }

        //
        //  Initialize global objects that the provider is serving up
        //
        pXMACSProvider = new CXMACSProvider(piKdcCoreInterface);
        if (NULL == pXMACSProvider)
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS: Failed to allocate memory for XMACSProvider.  Stopping XMACS." );
            XomNtEvent( XEVENT_XMACS_INIT_FAILURE_2, "XMACS: Failed to allocate memory for XMACSProvider.  Stopping XMACS." );
            XomTrace( XMACS, L_ERROR, "XMACS: Failed to allocate memory for XMACSProvider.  Stopping XMACS." );

            status = STATUS_NO_MEMORY;
            goto Error;
        }

        //
        //  Bringing up the provider
        //
        status = pXMACSProvider->Initialize();
        if (!NT_SUCCESS(status))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS: KdcExtMain failed to initialize provider.  Stopping XMACS." );
            XomNtEvent( XEVENT_XMACS_INIT_FAILURE_3, "XMACS: KdcExtMain failed to initialize provider.  Stopping XMACS." );
            XomTrace( XMACS, L_ERROR, "XMACS: KdcExtMain failed to initialize provider.  Stopping XMACS." );

            goto Error;
        }

        //
        //  Setting up the crypto interface.
        //
        status = pXMACSProvider->AttainNCipherCryptoKeys();
        if (!NT_SUCCESS(status))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS: KdcExtMain failed to initialize crypto interface.  Stopping XMACS." );
            XomNtEvent( XEVENT_XMACS_INIT_FAILURE_4, "XMACS: KdcExtMain failed to initialize crypto interface.  Stopping XMACS." );
            XomTrace( XMACS, L_ERROR, "XMACS: KdcExtMain failed to initialize crypto interface.  Stopping XMACS." );

            goto Error;
        }


        // turn on connection pooling for OLEDB
        CODBWSession::InitializeConnectionPooling();

        //
        //  Let the core know about this provider
        //
        status = piKdcCoreInterface->pfnKdcRegisterProvider(pXMACSProvider);
        if (!NT_SUCCESS(status))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS: KdcExtMain failed to register provider." );
            XomNtEvent( XEVENT_XMACS_INIT_FAILURE_5, "XMACS: KdcExtMain failed to register provider." );
            XomTrace( XMACS, L_ERROR, "XMACS: KdcExtMain failed to register provider." );

            goto Error;
        }

        //
        //  ownership belongs to g_pIKdbProvider
        //
        g_pIKdbProvider = pXMACSProvider;
        pXMACSProvider = NULL;

        // notify that XMACS has successfuly
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACSProvider : XMACS has successfully started." );
        XomNtEvent( XEVENT_XMACS_INIT_SUCCESS, "XMACSProvider : XMACS has successfully started." );
        XomTrace( XMACS, L_NORMAL, "XMACSProvider : XMACS has successfully started." );

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACSProvider: KdcExtMain detaching...");
        XomTrace( XMACS, L_WARNING, "XMACSProvider: KdcExtMain detaching...");

        if (g_pIKdbProvider)
        {
            g_pIKdbProvider->Unload();
            delete g_pIKdbProvider;
            g_pIKdbProvider = NULL;
        }

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACSProvider: Successful detach.  XMACS Stopped.");

        XomNtEvent( XEVENT_XMACS_TERM_SUCCESS, "XMACSProvider: Successful detach.  XMACS Stopped.");
        XomTrace( XMACS, L_WARNING, "XMACSProvider: KdcExtMain successfully detached.  XMACS Stopped.");

        // terminate the logging and debugging.
        g_xomcentral.Term();

        CoUninitialize();

    }

Done:
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - NT_STATUS = 0x%X", status);
    return status;

Error:
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KdcExtMain - XMACS:(ERROR) XMACS stopping.  NT_STATUS = 0x%X", status);
    XomNtEvent( XEVENT_XMACS_STOPPING, "XMACS:(ERROR) XMACS stopping.  NT_STATUS = 0x%X", status);

    delete pXMACSProvider;
    g_pIKdbProvider = NULL;
    goto Done;
}


//------------------------------------------------------------------------------------
//                      IKdbProvider
//------------------------------------------------------------------------------------
CXMACSProvider::CXMACSProvider(IKdcCore *pIKdcCore) :
    CXBaseProvider(pIKdcCore, L"XMACS KDC", MACS_KERBEROS_REALM_L ),
    m_XboxPuids(this, PUID_BASE_XBOX),
    m_XenonPuids(this, PUID_BASE_XENON),
    m_PcPuids(this, PUID_BASE_PC)
{
    m_hPrvKey                   = NULL;
    m_hProv                     = NULL;
    m_pDos                      = NULL;
    m_pCryptKeyHlper            = NULL;
    m_fNeedToSetupCryptoHelper  = TRUE;
    ZeroMemory(m_szLastPPATime, sizeof(m_szLastPPATime) );
    m_pDoSBB                    = NULL;
    m_bIsNCipherInit            = FALSE;
    m_cExceptionListEntries     = 0;
    m_dwConsoleTypeMask         = 0;
    m_fAllowOldConsoleCert      = FALSE;
}


CXMACSProvider::~CXMACSProvider()
{
    m_pDos                      = NULL;
    m_hPrvKey                   = NULL;
    m_hProv                     = NULL;
    m_pCryptKeyHlper            = NULL;
    m_fNeedToSetupCryptoHelper  = FALSE;
    m_pDoSBB                    = NULL;
    ZeroMemory(m_szLastPPATime, sizeof(m_szLastPPATime) );
    m_bIsNCipherInit            = FALSE;
}

// Finish up work synchronously because provider is getting unloaded
void __stdcall
CXMACSProvider::Unload()
{
    // lock this section.
    ConfigWriteLock();

    // release the crypto objects if they exist.
    if (m_hPrvKey != NULL)
    {
        CryptReleaseContext( m_hPrvKey, NULL );
    }
    if (m_hProv != NULL)
    {
        CryptReleaseContext( m_hProv, NULL );
    }

    // release the write lock
    ConfigWriteUnlock();

    // uninitialize everything else
    Uninitialize();

    // unload the base provider.
    CXBaseProvider::Unload();

    CODBWSession::TerminateConnectionPooling();

}

//
//  Non-IKdbProvider methods for CXMACSProvider
//


//
//  Uninitialize values for XMACS provider.
//
NTSTATUS
CXMACSProvider::Uninitialize()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr      = S_OK;

    ConfigWriteLock();

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Uninitialize - CXMACSProvider:(Reinitialize) Now uninitializing XMACS data." );
    XomTrace( XMACS, L_WARNING, "CXMACSProvider:(Reinitialize) Now uninitializing XMACS data." );

    //  terminate the exception list
    TerminateExceptionList();

    //  finish off the DoS list.
    if ( m_pDoSBB )
    {
        delete m_pDoSBB;
        m_pDoSBB = NULL;
    }

    // destroy the crypto helper...
    if ( m_pCryptKeyHlper != NULL )
    {
         delete m_pCryptKeyHlper;
         m_pCryptKeyHlper = NULL;
         m_fNeedToSetupCryptoHelper = TRUE;
    }

    // check for DOS implementation.
    if ( m_pDos )
    {
        delete m_pDos;
        m_pDos = NULL;
    }

    // Uninitialize keys
    XmacsCryptoTerm();
    m_masterSigningPublicKey.Reset();
    m_masterSigningPublicKeyTest.Reset();

    status = CXBaseProvider::Uninitialize();
    if ( !NT_SUCCESS(status) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Uninitialize - CXMACSProvider:(Uninitialize) base class initialization failed with status %d.", status);
        XomTrace(XMACS, L_ERROR, "CXMACSProvider:(Uninitialize) base class initialization failed with status %d.", status);
        goto Exit;
    }

Exit:
    ConfigWriteUnlock();

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Uninitialize - status: %d.", status);
    return status;

}

//
//  Uninitialize values for XMACS provider.
//
NTSTATUS
CXMACSProvider::Reinitialize()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr      = S_OK;
    XOCryptoKeyEncryptionHelper *pCryptKEKHlp = NULL;


    ConfigWriteLock();

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - CXMACSProvider:(Reinitialize) Now reloading XMACS data." );
    XomTrace( XMACS, L_WARNING, "CXMACSProvider:(Reinitialize) Now reloading XMACS data." );

    if ( !NT_SUCCESS( LoadConfig()) )
    {
        ConfigWriteUnlock();

        status = STATUS_NO_MEMORY;
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - STATUS_NO_MEMORY");
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - CXMACSProvider:(Reinitialize) Failed to reload config data." );
        XomNtEvent( XEVENT_XMACS_INIT_FAILURE_6, "CXMACSProvider:(Reinitialize) Failed to reload config data." );
        XomTrace( XMACS, L_ERROR, "CXMACSProvider:(Reinitialize) Failed to reload config data." );

        goto Exit;
    }

    ConfigWriteUnlock();

    // talk to UODB for key encryption key data.
    hr = Attain_Service_Keys( m_dwEncryptionKeyVersion, &pCryptKEKHlp );
    if ( hr == E_XMACS_NO_UODB || hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY  || hr == S_FALSE )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - CXMACSProvider:(Reinitialize) Attaining service keys failed.  Could not get a VALID response from UODB, please ensure: (a) XMACS servers can talk to UODB servers.\n\r(b) UODB can communicate with the UODB.\n\r(c) The UODB is active with the proper table values and stored procedures.\n\r(d}The UODB is populated with the correct key information");
        XomNtEvent( XEVENT_XMACS_NO_CONNECT_FD,
            "CXMACSProvider:(Reinitialize) Attaining service keys failed.  Could not get a VALID response from UODB, please ensure: (a) XMACS servers can talk to UODB servers.\n\r(b) UODB can communicate with the UODB.\n\r(c) The UODB is active with the proper table values and stored procedures.\n\r(d}The UODB is populated with the correct key information");

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - CXMACSProvider:(Reinitialize) Attaining service keys failed.  Could not get a VALID response from UODB, please ensure: (a) XMACS servers can talk to UODB servers.\n\r(b) UODB can communicate with the UODB.\n\r(c) The UODB is active with the proper table values and stored procedures.\n\r(d}The UODB is populated with the correct key information");
        XomTrace( XMACS, L_ERROR, "CXMACSProvider:(Reinitialize) Attaining service keys failed.  Could not get a VALID response from UODB, please ensure: (a) XMACS servers can talk to UODB servers.\n\r(b) UODB can communicate with the UODB.\n\r(c) The UODB is active with the proper table values and stored procedures.\n\r(d}The UODB is populated with the correct key information");
        status = STATUS_NO_MEMORY;
        goto Exit;
    }
    else if ( FAILED(hr) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - CXMACSProvider:(Reinitialize) Attaining service keys failed.  Could be associated to memory or resource problems.  Result= 0x%X", hr );
 
        XomNtEvent( XEVENT_KDC_CONFIG_72,
                    "CXMACSProvider:(Reinitialize) Attaining service keys failed.  Could be associated to memory or resource problems.  Result= 0x%X", hr );

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - CXMACSProvider:(Reinitialize) Attaining service keys failed.  Could be associated to memory or resource problems.  Result= 0x%X", hr );
		XomTrace( XMACS, L_ERROR, "CXMACSProvider:(Reinitialize) Attaining service keys failed.  Could be associated to memory or resource problems.  Result= 0x%X", hr );

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - STATUS_NO_MEMORY");
        status = STATUS_NO_MEMORY;
        goto Exit;
    }

    ConfigWriteLock();

    // set the pointer to the kek helper object.
    if ( m_pCryptKeyHlper )
    {
        delete m_pCryptKeyHlper;
        m_pCryptKeyHlper = NULL;
    }
    m_pCryptKeyHlper = pCryptKEKHlp;
    pCryptKEKHlp = NULL;

    ConfigWriteUnlock();

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - CXMACSProvider:(Reinitialize) completed successfully." );
    XomNtEvent( XEVENT_XMACS_RELOAD_SUCCESS, "CXMACSProvider:(Reinitialize) completed successfully." );
    XomTrace( XMACS, L_LOW, "CXMACSProvider:(Reinitialize) completed successfully." );

Exit:
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Reinitialize - status: 0x%X", status);
    return status;
}


//
//  Initialize values for XMACS provider.
//
NTSTATUS
CXMACSProvider::Initialize()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr      = S_OK;
    CComBSTR setting;
    CLargeStr errorstr;
    BOOL success;

    ConfigWriteLock();

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Reinitialize) Now initializing XMACS data." );
    XomTrace( XMACS, L_WARNING, "CXMACSProvider:(Reinitialize) Now initializing XMACS data." );

    status = CXBaseProvider::Initialize(this);
    if ( !NT_SUCCESS(status) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) base class initialization failed with status %d.", status);
        XomTrace(XMACS, L_ERROR, "CXMACSProvider:(Initialize) base class initialization failed with status %d.", status);
        goto Exit;
    }

    // talk to UODB for key encryption key data.
    m_fNeedToSetupCryptoHelper = TRUE;
    hr = Attain_Service_Keys( m_dwEncryptionKeyVersion, &m_pCryptKeyHlper);
    if (  hr == E_XMACS_NO_UODB || hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY || hr == S_FALSE )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) Attaining service keys failed.  Could not get a VALID response from UODB, please ensure: (a) XMACS servers can talk to UODB servers.\n\r(b) UODB can communicate with the UODB.\n\r(c) The UODB is active with the proper table values and stored procedures.\n\r(d}The UODB is populated with the correct key information");
        XomNtEvent( XEVENT_XMACS_NO_CONNECT_FD_1,
            "CXMACSProvider:(Initialize) Attaining service keys failed.  Could not get a VALID response from UODB, please ensure: (a) XMACS servers can talk to UODB servers.\n\r(b) UODB can communicate with the UODB.\n\r(c) The UODB is active with the proper table values and stored procedures.\n\r(d}The UODB is populated with the correct key information");

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) Attaining service keys failed.  Could not get a VALID response from UODB, please ensure: (a) XMACS servers can talk to UODB servers.\n\r(b) UODB can communicate with the UODB.\n\r(c) The UODB is active with the proper table values and stored procedures.\n\r(d}The UODB is populated with the correct key information");

        XomTrace( XMACS, L_ERROR, "CXMACSProvider:(Initialize) Attaining service keys failed.  Could not get a VALID response from UODB, please ensure: (a) XMACS servers can talk to UODB servers.\n\r(b) UODB can communicate with the UODB.\n\r(c) The UODB is active with the proper table values and stored procedures.\n\r(d}The UODB is populated with the correct key information");
        m_fNeedToSetupCryptoHelper = TRUE;
    }
    else if ( FAILED(hr) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) Attaining service keys failed.  Could be associated to memory or resource problems.  Result= 0x%X", hr );

        XomNtEvent( XEVENT_KDC_CONFIG_73,
                    "CXMACSProvider:(Initialize) Attaining service keys failed.  Could be associated to memory or resource problems.  Result= 0x%X", hr );

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) Attaining service keys failed.  Could be associated to memory or resource problems.  Result= 0x%X", hr );

		XomTrace( XMACS, L_ERROR, "CXMACSProvider:(Initialize) Attaining service keys failed.  Could be associated to memory or resource problems.  Result= 0x%X", hr );
		
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - STATUS_NO_MEMORY");
    
		status = STATUS_NO_MEMORY;
        goto Exit;
    }
    else
    {
        XOMASSERT( m_pCryptKeyHlper != NULL );
        if ( m_pCryptKeyHlper == NULL )
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) Attaining service keys was sucessful, however memory for this object was not allocated.  Please check system resources.  Result= 0x%X", hr );

            XomNtEvent( XEVENT_KDC_CONFIG_74,
                    "CXMACSProvider:(Initialize) Attaining service keys was sucessful, however memory for this object was not allocated.  Please check system resources.  Result= 0x%X", hr );
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) Attaining service keys was sucessful, however memory for this object was not allocated.  Please check system resources.  Result= 0x%X", hr );

			XomTrace( XMACS, L_ERROR, "CXMACSProvider:(Initialize) Attaining service keys was sucessful, however memory for this object was not allocated.  Please check system resources.  Result= 0x%X", hr );
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) Attaining service keys was sucessful, however memory for this object was not allocated.  Please check system resources.  Result= 0x%X", hr );
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - STATUS_NO_MEMORY");
			status = STATUS_NO_MEMORY;
            goto Exit;
        }
        m_fNeedToSetupCryptoHelper = FALSE;
    }

    // Initialize XmacsCrypto (Xmacs private key)
    if(!XmacsCryptoInit(GetDWORDSetting(Setting_kdcsvc_xmacs_UseTestXmacsKey, 0),
                        GetDWORDSetting(Setting_kdcsvc_xmacs_useNCipher, 0)))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - XmacsCryptoInit failed. A previous event should contain the reason why it failed.");
        XomNtEvent(XEVENT_KDC_CONFIG_75, "XmacsCryptoInit failed. A previous event should contain the reason why it failed.");
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    // Initialize master-signing-public-key
    if(!m_masterSigningPublicKey.OpenBsafePublicKey(g_XenonMasterSigningProdBsafePub2048, CXoCryptoCspPk::KeyPurposeSign))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - Failed to initialize master-signing-public-key");
        XomNtEvent(XEVENT_KDC_CODE_377, "Failed to initialize master-signing-public-key");
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    // Optionally initialize *test* master-signing-public-key
    if(GetDWORDSetting(Setting_kdcsvc_xmacs_UseTestMasterSigningKey, 0))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - WARNING: XMACS is configured to use test master signing rsa public key. This must never happen in production.");
        XomNtEvent(XEVENT_KDC_CONFIG_76, "WARNING: XMACS is configured to use test master signing rsa public key. This must never happen in production.");

        if(!m_masterSigningPublicKeyTest.OpenBsafePublicKey(g_XenonMasterSigningBsafePub2048, CXoCryptoCspPk::KeyPurposeSign))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - Failed to initialize master-signing-public-key (test)");
            XomNtEvent(XEVENT_KDC_CODE_378, "Failed to initialize master-signing-public-key (test)");
            status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }
    }

    if(!InitializeExceptionList())
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - Failed to initialize exception list");
        XomNtEvent(XEVENT_KDC_CONFIG_77, "Failed to initialize exception list");
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    if(m_dwConsoleTypeMask == 0)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - Fatal Error: Setting kdcsvc_xmacs_consoleTypeMask cannot be zero");
        XomNtEvent(XEVENT_KDC_CONFIG_78, "Fatal Error: Setting kdcsvc_xmacs_consoleTypeMask cannot be zero");
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - Console Type Mask: 0x%08x", m_dwConsoleTypeMask);
    XomNtEvent(XEVENT_KDC_INFO_23, "Console Type Mask: 0x%08x", m_dwConsoleTypeMask);
    
    // initialize the PUID lock for PUID management variables.
    InitializeCriticalSection( &m_csPUIDLock );

    //construct the DOS list.
    m_pDos = new CDOSList(  GetDWORDSetting( Setting_kdcsvc_xmacs_maxAllowancePerHour, c_nACCESS_ALLOWANCE_PER_TIME_PERIOD ),
                            GetDWORDSetting( Setting_kdcsvc_xmacs_DOSStage1CacheTimeout, c_nDefaultStage1DosCacheTime ),
                            GetDWORDSetting( Setting_kdcsvc_xmacs_DOSStage2CacheTimeout, c_nDefaultStage2DosCacheTime ),
                            (BOOL)(GetDWORDSetting( Setting_kdcsvc_xmacs_disableDOS, (DWORD)(false) )) );
    if ( m_pDos == NULL || !(m_pDos->IsValid()) )
    {
        status = STATUS_NO_MEMORY;
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - STATUS_NO_MEMORY");

        XomNtEvent( XEVENT_KDC_CONFIG_80,
                    "CXMACSProvider:(Initialize) Failed to initialize DOS implementation.  Not enough memory.  RESULT = 0x%X",
                    status);

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) Failed to initialize DOS implementation.  Not enough memory.  RESULT = 0x%X",
                    status);

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - CXMACSProvider:(Initialize) Failed to initialize DOS implementation.  Not enough memory.  RESULT = 0x%X", status);

        XomTrace( XMACS, L_ERROR, "CXMACSProvider:(Initialize) Failed to initialize DOS implementation.  Not enough memory.  RESULT = 0x%X", status);

        goto Exit;
    }

    if (FAILED(m_pConfig->GetSetting(Setting_kdcsvc_xmacs_LimitedPcTokens,&setting)))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - Failed to read setting kdcsvc_xmacs_LimitedPcTokens");
        XomNtEvent(XEVENT_KDC_CONFIG_83, 
                    "Failed to read setting kdcsvc_xmacs_LimitedPcTokens");
        goto Exit;
    }
    m_bstrLimitedTokens = setting;
    m_bstrLimitedTokens.ToUpper();
    setting.Empty();
    
    // Configure Dos2

    BOOL   enabled      = GetDWORDSetting(Setting_kdcsvc_xmacs_DoS2_enabled, 0);
    UINT32 maxRecords   = GetDWORDSetting(Setting_kdcsvc_xmacs_DoS2_cacheSize, 0);
    double sizeRatio    = 0.5;
    UINT32 maxRequests  = GetDWORDSetting(Setting_kdcsvc_xmacs_DoS2_maxRequests, 0);
    UINT32 interval     = GetDWORDSetting(Setting_kdcsvc_xmacs_DoS2_interval, 0);
    UINT32 blockingTime = GetDWORDSetting(Setting_kdcsvc_xmacs_DoS2_blockingTime, 0);

    success = m_Dos2.Init(
        enabled, 
        maxRecords, 
        sizeRatio, 
        maxRequests, 
        interval, 
        blockingTime);

    if(!success)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - Failed to initialize DoS detection. Verify that the following settings "
            "contain valid parameters: \n"
            " kdcsvc_xmacs_DoS2_enabled: %u \n"
            " kdcsvc_xmacs_DoS2_cacheSize: %u \n"
            " kdcsvc_xmacs_DoS2_maxRequests: %u \n"
            " kdcsvc_xmacs_DoS2_interval: %u \n"
            " kdcsvc_xmacs_DoS2_blockingTime: %u \n",
            enabled,
            maxRecords, 
            maxRequests,
            interval,
            blockingTime);

        XomNtEvent(
            XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
            "Failed to initialize DoS detection. Verify that the following settings "
            "contain valid parameters: \n"
            " kdcsvc_xmacs_DoS2_enabled: %u \n"
            " kdcsvc_xmacs_DoS2_cacheSize: %u \n"
            " kdcsvc_xmacs_DoS2_maxRequests: %u \n"
            " kdcsvc_xmacs_DoS2_interval: %u \n"
            " kdcsvc_xmacs_DoS2_blockingTime: %u \n",
            enabled,
            maxRecords, 
            maxRequests,
            interval,
            blockingTime);

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Initialize - STATUS_INTERNAL_ERROR");
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

Exit:
    ConfigWriteUnlock();

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "Initialize - status: 0x%X", status);
    return status;
}

// Initialize a CXoCryptoCspPk object with the key specified by a setting.
// If the setting is an empty string, this function will still succeed and it
// will return NULL in *ppKey. This's the condition in which it would succeed 
// and return NULL at the same time.
BOOL CXMACSProvider::InitializeKey(
    IN     CComBSTR          keySetting, 
    IN OUT CXoCryptoCspPk*  pKey
)
{
    BOOL            fRet         = FALSE;
    WCHAR*          pSemicollon  = NULL;
    WCHAR*          pszProvider  = NULL;
    WCHAR*          pszContainer = NULL;
    CComBSTR        bstrSetting;
    CXoCryptoCspPk::OpenContainerStatus ocstatus;

    pKey->Reset();

    // Get the key name (and maybe provider) from the setting
    if(FAILED(m_pConfig->GetSetting(keySetting, &bstrSetting)))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Failed to the setting value with the name of a Xenon key");
        XomNtEvent(XEVENT_KDC_CONFIG_83, 
            "Failed to the setting value with the name of a Xenon key");
        goto lDone;
    }

    if(*bstrSetting == L'\0')
    {
        // Setting value is an empty string. That's OK. Succeed but return
        // NULL in ppKey.
        fRet = TRUE;
        goto lDone;
    }

    // Parse the key name setting. If there is a semicollon in the string, the 
    // setting contains both the name of the provider name and name of the 
    // container. Otherwise, it's just the container name and the provider will 
    // be assumed to be MS_ENHANCED_PROV.
    pSemicollon = wcschr(bstrSetting, L';');

    if(pSemicollon)
    {
        *pSemicollon = 0;
        pszProvider  = bstrSetting;
        pszContainer = pSemicollon+1;
    }
    else
    {
        pszContainer = bstrSetting;
        pszProvider  = MS_ENHANCED_PROV_W;
    }

    // Open the key containier
    ocstatus = pKey->OpenContainer(pszContainer, pszProvider, true);
    if(ocstatus != CXoCryptoCspPk::OpenContainerSuccess)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","pKey->OpenContainer failed. ocstatus=%u", (DWORD)ocstatus);
        XomNtEvent(XEVENT_KDC_CONFIG_84, "pKey->OpenContainer failed. ocstatus=%u", (DWORD)ocstatus);
        goto lDone;
    }

    fRet = TRUE;

lDone:

    if(!fRet)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log",
			"Failed to open key container specified by %S. A previous event "
            "should contain the reason.", bstrSetting);
        XomNtEvent(XEVENT_KDC_CONFIG_85, 
            "Failed to open key container specified by %S. A previous event "
            "should contain the reason.", bstrSetting);
    }

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","fRet: 0x%X", fRet);
    return fRet;
}

// Check if a console id is in the exception list. Returns true if it is.
BOOL CXMACSProvider::CheckExceptionList(IN ULONGLONG qwConsoleId)
{
    BOOL bResult = false;

    EnterCriticalSection( &m_csExceptionList );

    for(DWORD i=0; i < m_cExceptionListEntries; i++)
    {
        if (m_rgqwExceptionList[i] == qwConsoleId)
        {
            bResult = true;
            break;
        }
    }

    LeaveCriticalSection( &m_csExceptionList );
    return bResult;
}

BOOL CXMACSProvider::InitializeExceptionList()
{
    BOOL        fRet = FALSE;
    CComBSTR    bstrList;
    HRESULT     hr;

    //
    // Initialize the critical section lock
    //
    InitializeCriticalSection( &m_csExceptionList );

    //
    // Get the setting from the config system
    //

    hr = m_pConfig->GetSetting(
        Setting_kdcsvc_xmacs_consoleExceptionList,
        &bstrList);
    if (FAILED(hr))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeExceptionList - Failed to get setting kdcsvc_xmacs_consoleExceptionList");
        XomNtEvent(
            XEVENT_KDC_CONFIG_86,
            "Failed to get setting kdcsvc_xmacs_consoleExceptionList"
            );
        goto lDone;
    }

    //
    // Load the exception list
    //

    hr = LoadExceptionList( bstrList );
    if (FAILED(hr))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeExceptionList - Failed to LoadExceptionList()");
        XomNtEvent(
            XEVENT_KDC_CONFIG_87,
            "Failed to LoadExceptionList()"
            );
        goto lDone;
    }
    
    //
    // Success
    //
    fRet = TRUE;

lDone:
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeExceptionList - fRet: 0x%X", fRet); 
    return fRet;
}

HRESULT CXMACSProvider::LoadExceptionList(CComBSTR bstrList)
{   
    CHAR        szList[2048];
    CHAR*       pEntry;
    HRESULT     hr = E_FAIL;
    ULONGLONG   rgqwExceptionList[XMACS_EXCEPTION_LIST_MAX_SIZE];
    DWORD       cEntries = 0;

    //
    // Zero the exception list memory
    //
    ZeroMemory(rgqwExceptionList, sizeof(rgqwExceptionList));

    //
    // Convert to the correct format and ensure null termination
    //
    ::WideCharToMultiByte(
        CP_ACP,
        0,
        bstrList,
        -1,
        szList,
        ARRAYSIZE(szList),
        NULL,
        NULL
        );
    szList[ARRAYSIZE(szList)-1]= '\0';

    //
    // Parse the whole list
    //
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "LoadExceptionList - Parsing exception list: %s", szList);
    XomTrace(XMACS, L_LOW, "Parsing exception list: %s", szList);
    for (pEntry = ::strtok(szList,";,"); 
         pEntry != NULL;
         pEntry = ::strtok(NULL,";,"))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "LoadExceptionList - Entry: %s", pEntry, szList);
        XomTrace(XMACS, L_LOW, "Entry: %s", pEntry, szList);

        if(cEntries >= XMACS_EXCEPTION_LIST_MAX_SIZE)
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "LoadExceptionList - Failed to parse exception list. Number of entries exceed maximum.");
            XomNtEvent(
                XEVENT_KDC_CONFIG_88,
                "Failed to parse exception list. Number of entries exceed maximum."
                );
            goto lDone;
        }

        if(!VerifyConsoleId(pEntry, NULL, 0, &rgqwExceptionList[cEntries]))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "LoadExceptionList - Failed to parse exception list entry: %s. It's not a valid console id",
                pEntry
                ); 
            XomNtEvent(
                XEVENT_KDC_CONFIG_89,
                "Failed to parse exception list entry: %s. It's not a valid console id",
                pEntry
                );
            goto lDone;
        }

        cEntries++;
    }
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "LoadExceptionList - Done parsing exception list. Total entries=%u",
        cEntries
        );
    XomTrace(
        XMACS,
        L_LOW,
        "Done parsing exception list. Total entries=%u",
        cEntries
        );

    //
    // Compile time assert to make sure that the array sizes are okay
    //
    C_ASSERT(sizeof(m_rgqwExceptionList) == sizeof(rgqwExceptionList));

    //
    // Replace global list (this requires the critical section lock)
    //
    EnterCriticalSection( &m_csExceptionList );
    memcpy(m_rgqwExceptionList, rgqwExceptionList, sizeof(m_rgqwExceptionList));
    m_cExceptionListEntries = cEntries;
    LeaveCriticalSection( &m_csExceptionList );

    //
    // Done
    //
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "LoadExceptionList - Loaded exception list: %S",
        (const WCHAR*)bstrList
        );  
    XomNtEvent(
        XEVENT_KDC_INFO_24,
        "Loaded exception list: %S",
        (const WCHAR*)bstrList
        ); 
    hr = S_OK;

lDone:

    return hr;
}

void CXMACSProvider::TerminateExceptionList()
{
    //
    // Set the number of entries in the exception list to zero
    //
    EnterCriticalSection( &m_csExceptionList );
    ZeroMemory(m_rgqwExceptionList, sizeof(m_rgqwExceptionList));
    m_cExceptionListEntries = 0;
    LeaveCriticalSection( &m_csExceptionList );

    //delete the critical section.  We dont' need it anymore.
    DeleteCriticalSection( &m_csExceptionList );

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "TerminateExceptionList - XMACS:(CXMACSProvider::TerminateExceptionList)  ExceptionList terminated\n");
    XomTrace(
        XMACS,
        L_NORMAL,
        "XMACS:(CXMACSProvider::TerminateExceptionList)  ExceptionList terminated\n");
}

NTSTATUS CXMACSProvider::AttainNCipherCryptoKeys()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    HANDLE hNCipherThread = NULL;
    DWORD dwThreadId = 0;
    DWORD dwWaitRes = 0;

    // check if we accept raw keys.  If not then set the nCipher used flag to true and set initialized true.

    // if we accept raw keys... don't use the nCipher device.
    if ( GetDWORDSetting( Setting_kdcsvc_xmacs_useNCipher, c_dwDefaultUseNCipher ) == 0 )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  XMACS is configured to not use nCipher Device."); 
        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  XMACS is configured to not use nCipher Device.");
        XomNtEvent( XEVENT_XMACS_INIT_WARNING, "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  XMACS is configured to not use nCipher Device.");

        m_bUseNCipher = FALSE;
        InterlockedExchange( (LPLONG)&m_bIsNCipherInit,  TRUE);
        goto Exit;
    }

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::InitializeCrypto)  XMACS is now attempting to acquire a handle to nCipher key informaiton.  Please ensure the operator card is present.  If this is successful this message should be followed by a success message.");
 
    // message the start of this.
    XomTrace(
            XMACS,
            L_NORMAL,
			"XMACS:(CXMACSProvider::InitializeCrypto)  XMACS is now attempting to acquire a handle to nCipher key informaiton.  Please ensure the operator card is present.  If this is successful this message should be followed by a success message.");

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::InitializeCrypto)  XMACS is now attempting to acquire a handle to nCipher key informaiton.  Please ensure the operator card is present.  If this is successful this message should be followed by a success message.");

	
	XomNtEvent(
            XEVENT_KDC_INFO_25,
            "XMACS:(CXMACSProvider::InitializeCrypto)  XMACS is now attempting to acquire a handle to nCipher key informaiton.  Please ensure the operator card is present.  If this is successful this message should be followed by a success message.");

    // create the thread
    hNCipherThread = CreateThread( NULL, NULL, NCipherInitThread, this, 0, &dwThreadId );
    if ( hNCipherThread == NULL )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  Failed to create the thread for nCipher initialization.  GetLastError = 0x%X", GetLastError());

        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  Failed to create the thread for nCipher initialization.  GetLastError = 0x%X", GetLastError());
        XomNtEvent( XEVENT_XMACS_INIT_FAILURE_9, "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  CryptGetUserKey failed with 0x%X", GetLastError());
        status = STATUS_SERVER_DISABLED;
        goto Exit;
    }

    // wait on the event for the timeout length of time.
    dwWaitRes = WaitForSingleObject( hNCipherThread,
                                     GetDWORDSetting( Setting_kdcsvc_xmacs_nCipherInitTimeoutInSecs, c_dwDefaultNCiperTimeout ) * 1000 );

    // check the return result
    switch(dwWaitRes)
    {
        case WAIT_TIMEOUT:
        {
            // if timed out
            //  fire an event and signal a shutdown.
            XomTrace(
                    XMACS,
                    L_ERROR,
                    "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  NCipher Initialization timed out after %d milliseconds.  Please ensure the operator card is present before initialization and that the configured timeout leaves enough time for the nCipher device to initialize.",
                    GetDWORDSetting( Setting_kdcsvc_xmacs_nCipherInitTimeoutInSecs, c_dwDefaultNCiperTimeout ) * 1000 );

			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  NCipher Initialization timed out after %d milliseconds.  Please ensure the operator card is present before initialization and that the configured timeout leaves enough time for the nCipher device to initialize.",
                    GetDWORDSetting( Setting_kdcsvc_xmacs_nCipherInitTimeoutInSecs, c_dwDefaultNCiperTimeout ) * 1000 );

            XomNtEvent(
                    XEVENT_KDC_CODE_379,
                    "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  NCipher Initialization timed out after %d milliseconds.  Please ensure the operator card is present before initialization and that the configured timeout leaves enough time for the nCipher device to initialize.",
                    GetDWORDSetting( Setting_kdcsvc_xmacs_nCipherInitTimeoutInSecs, c_dwDefaultNCiperTimeout ) * 1000 );

			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  NCipher Initialization timed out after %d milliseconds.  Please ensure the operator card is present before initialization and that the configured timeout leaves enough time for the nCipher device to initialize.",
                    GetDWORDSetting( Setting_kdcsvc_xmacs_nCipherInitTimeoutInSecs, c_dwDefaultNCiperTimeout ) * 1000 );

			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - STATUS_SERVER_DISABLED");
            status = STATUS_SERVER_DISABLED;
            goto Exit;
        }
        case WAIT_OBJECT_0:
        {
            // check if initialized... if not... stop XMACS now.
            if ( !m_bIsNCipherInit )
            {
                status = STATUS_SERVER_DISABLED;
				logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - STATUS_SERVER_DISABLED");
                goto Exit;
            }
            m_bUseNCipher = TRUE;

			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  NCipher Initialization successfully completed." );
            // if successfully signaled.
            XomTrace(
                    XMACS,
                    L_NORMAL,
                    "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  NCipher Initialization successfully completed." );

			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  NCipher Initialization successfully completed." );

            XomNtEvent(
                    XEVENT_KDC_INFO_26,
                    "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  NCipher Initialization successfully completed." );

            break;
        }
        default:
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  Unknown status received from nCipher thread.  GetLastError = 0x%X.",
                    GetLastError());
         
			XomTrace(
                    XMACS,
                    L_ERROR,
                    "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  Unknown status received from nCipher thread.  GetLastError = 0x%X.",
                    GetLastError());

			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  Unknown status received from nCipher thread.  GetLastError = 0x%X.",
                    GetLastError());

            XomNtEvent(
                    XEVENT_KDC_CODE_380,
                    "XMACS:(CXMACSProvider::AttainNCipherCryptoKeys)  Unknown status received from nCipher thread.  GetLastError = 0x%X.",
                    GetLastError());

			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - STATUS_SERVER_DISABLED");
            status = STATUS_SERVER_DISABLED;
            goto Exit;
        }

    }

Exit:

    // perform necessary cleanups.
    if ( hNCipherThread != NULL )
    {
        CloseHandle( hNCipherThread );
    }

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "AttainNCipherCryptoKeys - status: 0x%X", status);
    return status;
}

NTSTATUS
CXMACSProvider::InitializePrincipalStore()
{
    HRESULT hr                      = S_OK;
    NTSTATUS status                 = STATUS_SUCCESS;


    // initialize the base providers principal store.
    status = CXBaseProvider::InitializePrincipalStore();
    if ( !NT_SUCCESS(status) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "InitializePrincipalStore - CXMACSProvider:(InitializePrincipalStore) Failed to initialize the base provider principle store.  XMACS Stopping.  RESULT = 0x%X",
                    status);
        XomNtEvent( XEVENT_KDC_CONFIG_92,
                    "CXMACSProvider:(InitializePrincipalStore) Failed to initialize the base provider principle store.  XMACS Stopping.  RESULT = 0x%X",
                    status);

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "InitializePrincipalStore - CXMACSProvider:(InitializePrincipalStore) Failed to initialize the base provider principle store.  XMACS Stopping.  RESULT = 0x%X", status );

        XomTrace( XMACS, L_ERROR, "CXMACSProvider:(InitializePrincipalStore) Failed to initialize the base provider principle store.  XMACS Stopping.  RESULT = 0x%X", status );

        goto Exit;
    }


Exit:
    return status;
}


KERBERR __stdcall
CXMACSProvider::GetPrincipal(
    IN  GET_PRINC_FLAGS             flags,
    IN  PKERB_INTERNAL_NAME         pName,
    IN  LPCWSTR                     pcwszRealm,
    IN  IKerbRequest                *pIKerbRequest,
    OUT PIKerbPrincipal             *ppIPrincipal,
    OUT PKERB_EXT_ERROR             pExtendedError,
    OUT OPTIONAL PUNICODE_STRING    *ppustrReferredRealm
    )
{
    USES_CONVERSION;
    KERBERR KerbErr                 = KDC_ERR_NONE;                 // the return value
    NTSTATUS status                 = STATUS_NOT_FOUND;
    CXBasePrincipal *pcPrincipal    = NULL;
    XKDC_PRINCIPAL sPrinc           = {0};
    XkdcCredential *pCred           = NULL;
    DWORD dwCredSize                = 0;
    in_addr *pInAddr                = NULL;
    UNICODE_STRING princName;
    HRESULT hr                      = S_OK;
    XOCryptoKeyEncryptionHelper *pCryptKEKHlp = NULL;
    QWORD qwStartTime = 0;
    QWORD qwEndTime = 0;
    QWORD qwElapsedMs = 0;

    // do not perform referrals
    if ( ppustrReferredRealm )
    {
        *ppustrReferredRealm = NULL;
    }

    pInAddr = &(((PSOCKADDR_IN)pIKerbRequest->GetClientAddress())->sin_addr);

    // MACS.XBOX.COM realm should never receive TGS requests from valid Xbox clients
    if ( KerbTgs == pIKerbRequest->GetServId() )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - (%s:%d) GetPrincipal: invalid TGS request to %s realm from client %s.  Possible hack attempt.",
                 __FILE__,
                 __LINE__,
                MACS_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

        XomTrace(XMACS, L_ERROR,
                "(%s:%d) GetPrincipal: invalid TGS request to %s realm from client %s.  Possible hack attempt.",
                 __FILE__,
                 __LINE__,
                MACS_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - KDC_ERR_POLICY");
        KerbErr = SilentKerbErr(KDC_ERR_POLICY);
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - STATUS_NOT_SUPPORTED");
        status = STATUS_NOT_SUPPORTED;
        goto Exit;
    }

    // ensure the correct realm.  MACS should only handle MACS realm issues.
    if ( _wcsicmp( pcwszRealm , MACS_KERBEROS_REALM_L ) != 0 )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - KDC_ERR_PREAUTH_FAILED");
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - STATUS_NOT_SUPPORTED");
        KerbErr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
        status = STATUS_NOT_SUPPORTED;
        goto Exit;
    }

    g_Counters.IncrementValue32(XMACSPERF_SERVER_GETPRINCIPAL_CURRENT, 1);

    GetSystemTimeAsFileTime((FILETIME*)&qwStartTime);

    XOMASSERT( m_bIsNCipherInit );

    //check if we've setup the crypto helper properly.
    if ( m_fNeedToSetupCryptoHelper )
    {
        ConfigWriteLock();

        if ( m_fNeedToSetupCryptoHelper )
        {

            // talk to UODB for key encryption key data.
            hr = Attain_Service_Keys( m_dwEncryptionKeyVersion, &pCryptKEKHlp );

            if ( hr != S_OK || pCryptKEKHlp == NULL )
            {
                KerbErr = KDC_ERR_SERVICE_NOTYET;
                status = STATUS_NO_MEMORY;
                m_fNeedToSetupCryptoHelper = TRUE;
                ConfigWriteUnlock();
				logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - CXMACSProvider:(GetPrincipal) Attaining service keys failed.  Please ensure that XMACS can communicate with UODB.  Result = 0x%X", hr );

                XomTrace( XMACS, L_WARNING, "CXMACSProvider:(GetPrincipal) Attaining service keys failed.  Please ensure that XMACS can communicate with UODB.  Result = 0x%X", hr );
                goto Exit2;
            }
            else
            {
                // set the pointer to the kek helper object.
                if ( m_pCryptKeyHlper )
                {
                    delete m_pCryptKeyHlper;
                    m_pCryptKeyHlper = NULL;
                }
                m_pCryptKeyHlper = pCryptKEKHlp;
                pCryptKEKHlp = NULL;
                m_fNeedToSetupCryptoHelper = FALSE;
            }
        }

        ConfigWriteUnlock();


    }

    // reset this lock.
    ConfigReadLock();

    GetKdcCore()->pfnKerbConvertKdcNameToString(&princName, pName, NULL);

    // just some extra information
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - XMACS:(GetPrincipal) Before RetrievePrincipal:  Realm=%S, Name=%S, NameCount=%d, Flags=%d", pcwszRealm, princName.Buffer, pName->NameCount, flags );

    XomTrace(XMACS, L_NORMAL, "XMACS:(GetPrincipal) Before RetrievePrincipal:  Realm=%S, Name=%S, NameCount=%d, Flags=%d", pcwszRealm, princName.Buffer, pName->NameCount, flags );

    KerbFreeString(&princName);

    status = RetrievePrincipal( flags, pName, pcwszRealm, pIKerbRequest, &sPrinc, &KerbErr );
    if ( !NT_SUCCESS(status) || (KerbErr != KDC_ERR_NONE) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - XMACS:(GetPrincipal) RetrievePrincipal was unsuccessful.  KerbErr=0x%X , Status=0x%X", KerbErr, status );
        XomTrace( XMACS, L_ERROR, "XMACS:(GetPrincipal) RetrievePrincipal was unsuccessful.  KerbErr=0x%X , Status=0x%X", KerbErr, status );
        goto Exit;
    }

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - XMACS:(GetPrincipal) After RetrievePrincipal: ServiceName=%S, DomainName=%S\n", sPrinc.wszServiceName, sPrinc.wszDomainName);

    // output notice that we finished the retrieve principal without incident.
    XomTrace(XMACS, L_NORMAL, "XMACS:(GetPrincipal) After RetrievePrincipal: ServiceName=%S, DomainName=%S\n", sPrinc.wszServiceName, sPrinc.wszDomainName);

    // allocate space for new credential structure
    dwCredSize = sizeof(XkdcCredential) + sizeof(XkdcKey) + XKDC_KEYSIZE;
    pCred = (XkdcCredential*) KdcAllocMemory(dwCredSize);
    if ( NULL == pCred )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - XMACS:(GetPrincipal) No memory for new credentials.  Please investigate.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_69, "XMACS:(GetPrincipal) No memory for new credentials.  Please investigate.");
        XomTrace( XMACS, L_WARNING, "XMACS:(GetPrincipal) No memory for new credentials.  Please investigate.");
        return STATUS_NO_MEMORY;
    }
    ZeroMemory(pCred, dwCredSize);

    pCred->dwKeyCount                   = 1;
    pCred->Key[0].dwKeyVersion          = 1;
    pCred->Key[0].Key.keytype           = KERB_ETYPE_RC4_HMAC_NT;
    pCred->Key[0].Key.keyvalue.length   = XKDC_KEYSIZE;
    pCred->Key[0].Key.keyvalue.value    = ((BYTE*) pCred) + dwCredSize - XKDC_KEYSIZE;
    memcpy(pCred->Key[0].Key.keyvalue.value, sPrinc.rgKey[0].binKey, XKDC_KEYSIZE);

    // use the info from the DB to construct the new principal
    pcPrincipal = new CXBasePrincipal();
    if ( NULL == pcPrincipal )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - XMACS:(GetPrincipal) No memory for new principal.  Please investigate.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_70, "XMACS:(GetPrincipal) No memory for new principal.  Please investigate.");
        XomTrace( XMACS, L_WARNING, "XMACS:(GetPrincipal) No memory for new principal.  Please investigate.");

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - KRB_ERR_GENERIC");
        KerbErr = KRB_ERR_GENERIC;
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - STATUS_NO_MEMORY");
        status = STATUS_NO_MEMORY;

        goto Exit;
    }

    status = pcPrincipal->Initialize(
                            this,                   // pointer to Kdb provider
                            m_pIKdcCore,            // pointer to KdcCore
                            &m_ustrRealmName,       // realm name
                            &sPrinc,                // principal data
                            pCred,                  // cred key data
                            m_liMaxLifetime,        // max lifetime
                            m_liMaxRenewTime,       // max renew time
                            KERB_KDB_TIME_NEVER,    // last modified
                            KERB_KDB_TIME_NEVER,    // expiration
                            KERB_KDB_DATA_ALL);

    if ( !NT_SUCCESS(status) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - XMACS:(GetPrincipal) Failed to initialize principal.  Returned Status = 0x%X", status );
        XomTrace( XMACS, L_ERROR,  "XMACS:(GetPrincipal) Failed to initialize principal.  Returned Status = 0x%X", status );
        KerbErr = KRB_ERR_GENERIC;
        goto Exit;
    }

    *ppIPrincipal = static_cast<IKerbPrincipal*> (pcPrincipal);
    pcPrincipal = NULL;

    KerbErr = KDC_ERR_NONE;
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - KDC_ERR_NONE");
   // g_Counters.IncrementValue32(XMACSPERF_SERVER_GETPRINCIPAL_COUNTER, 1);
   // g_Counters.IncrementValue32(XMACSPERF_SERVER_GETPRINCIPAL_RATE, 1);

Exit:

    ConfigReadUnlock();

Exit2:

    if ( pcPrincipal )
    {
        delete pcPrincipal;
    }

    pExtendedError->status = status;

    GetSystemTimeAsFileTime((FILETIME*)&qwEndTime);
    qwElapsedMs = ( qwEndTime - qwStartTime ) / 10000;

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "GetPrincipal - KerbErr: 0x%X", KerbErr);

    return KerbErr;
}

NTSTATUS
CXMACSProvider::RetrievePrincipal(
    IN  GET_PRINC_FLAGS flags,
    IN  PKERB_INTERNAL_NAME  pkinName,
    IN  LPCWSTR pcwszRealm,
    IN  IKerbRequest *pIKerbRequest,
    OUT PXKDC_PRINCIPAL pKdcPrinc,
    OUT KERBERR* pExtendedError
    )
{
    XOMASSERT(pKdcPrinc);
    XOMASSERT(pExtendedError);
    XOMASSERT(pIKerbRequest);

    // Figure out who is making this request. If it was a Xenon console, the pre-auth 
    // type KRB5_PADATA_XENON_MAC_REQUEST should be included in the request. If it was a 
    // PC, the pre-auth type KRB5_PADATA_PC_ACCOUNT_CREATION should be included.  
    // Otherwise we assume it's an Xbox machine account creation request.

    const KERB_KDC_REQUEST* pKdcReq = pIKerbRequest->GetKdcRequest();
    PKERB_KDC_REQUEST_preauth_data padata = pKdcReq->preauth_data;

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "RetrievePrincipal - padata 0x%X KRB5_PADATA_XENON_MAC_REQUEST 0x%X KRB5_PADATA_PC_ACCOUNT_CREATION 0x%X ",padata, KRB5_PADATA_XENON_MAC_REQUEST, KRB5_PADATA_PC_ACCOUNT_CREATION );
    while(padata)
    {
        switch(padata->value.preauth_data_type)
        {
        case KRB5_PADATA_XENON_MAC_REQUEST2:
        case KRB5_PADATA_XENON_MAC_REQUEST:
            {
				logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "RetrievePrincipal - KRB5_PADATA_XENON_MAC_REQUEST");
                // This is a Xenon machine account creation request
                return RetrieveXenonPrincipal(pkinName, pcwszRealm, pIKerbRequest,
                                              pKdcPrinc, pExtendedError);
            }

        case KRB5_PADATA_PC_ACCOUNT_CREATION:
        case KRB5_PADATA_PC_ACCOUNT_CREATION2:
            {
				logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "RetrievePrincipal - KRB5_PADATA_PC_ACCOUNT_CREATION");
                // This is a PC machine account creation request
                return RetrievePcPrincipal(flags, pkinName, pcwszRealm, pIKerbRequest, pKdcPrinc, pExtendedError);
            }

        }

        padata = padata->next;
    }

    // This is an Xbox machine account creation request
    return RetrieveXboxPrincipal(pkinName,pcwszRealm,pIKerbRequest,
                                 pKdcPrinc,pExtendedError);
}

// --------------------------------------------------------------------------------------
// CXMACSProvider::RetrievePcPrincipal
// Fills out a pKdcPrinc structure with principal information (name and keys, mostly).
// The PC case is special - the client principal name in the request is always the same 
// constant. Since, like Xenon, we don't have genealogy on the PC, we also don't have a 
// client key. Instead we're going to derive a client key from the session key inside the 
// passport ticket that should have been presented in this request's pre-auth.
//  - flags: kerberos GetPrincipal flags. The ones we care about are 
//  KDC_KDB_GET_PRINC_CLIENT which indicates that the principal type is client and 
//  KDC_KDB_GET_PRINC_SERVER which indicates that the principal type is server.
//  - pkinName: principal name
//  - pcwszRealm: request's realm
//  - pIKerbRequest: kerberos request
//  - pKdcPrinc (OUT): if everything is fine, this method will fill-out the struct 
//  pointed by this parameter with principal information
//  - pExtendedError (OUT): a KERB_ERR error id. If request succeeds, this method will 
//  return KDC_ERR_NONE. Otherwise, a KDC_ERR_* error will be returned.
// Returns:
//  This method returns STATUS_SUCCESS if operation succeeded and 
//  STATUS_KDC_INVALID_REQUEST otherwise.
// --------------------------------------------------------------------------------------
NTSTATUS
CXMACSProvider::RetrievePcPrincipal(
    IN  GET_PRINC_FLAGS flags,
    IN  PKERB_INTERNAL_NAME  pkinName,
    IN  LPCWSTR pcwszRealm,
    IN  IKerbRequest *pIKerbRequest,
    OUT PXKDC_PRINCIPAL pKdcPrinc,
    OUT KERBERR* pExtendedError
    )
{
    memset(pKdcPrinc, 0, sizeof(*pKdcPrinc));
    CPaPcAccountCreationHandler* pPreAuth = NULL;
    KERBERR kerberr = KDC_ERR_NO_RESPONSE;

    // Get PC account creation pre-auth handler
    {
        NTSTATUS status = pIKerbRequest->GetPAHandler(
            CPaPcAccountCreationHandler::GetGuid(),
            (PVOID*)&pPreAuth);

        if(!NT_SUCCESS(status))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "RetrievePcPrincipal - Failed to get PC account creation pa-handler");
            XOMASSERT(!"Failed to get PC account creation pa-handler");
            kerberr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
            goto Exit;
        }
    }

    //
    // RetrievePcPrincipal should get called twice for every request. The first call is 
    // to retrieve the client principal and the second one is to retrieve the server 
    // principal.
    //

    if(flags & KDC_KDB_GET_PRINC_CLIENT)
    {
        // Machine account creation is a big hack, err... special case in the Kerberos 
        // world. There is no client principal per-se. We're in fact creating one. The 
        // client name for example is a constant.
        
        pPreAuth->SetStatus(CPaPcAccountCreationHandler::STATUS_GET_PRINC_CLIENT);
        
        if(pkinName->NameCount != 1 ||
           wcsicmp(pkinName->Names[0].Buffer, c_PcPrincipalName) != 0)
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "RetrievePcPrincipal - Invalid client name: %S/%S",
                pkinName->NameCount >= 1 ? pkinName->Names[0].Buffer : L"(null)",
                pkinName->NameCount >= 2 ? pkinName->Names[1].Buffer : L"(null)");
            XomNtEvent(
                XEVENT_XMACS_HACK_INVALID_CLIENT_NAME,
                "Invalid client name: %S/%S",
                pkinName->NameCount >= 1 ? pkinName->Names[0].Buffer : L"(null)",
                pkinName->NameCount >= 2 ? pkinName->Names[1].Buffer : L"(null)");

            kerberr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
            goto Exit;
        }

        pPreAuth->SetStatus(CPaPcAccountCreationHandler::STATUS_VALID_CLIENT_PRINC_NAME);

        // The client key is actually embedded in the machine account creation pre-auth.  
        // Therefore we must process it now.

        kerberr = pPreAuth->Process(pIKerbRequest);

        if(!KERB_SUCCESS(kerberr))
        {
            goto Exit;
        }

        // We have all the information required to return principal information

        C_ASSERT(ARRAYSIZE(pKdcPrinc->wszServiceName) >= ARRAYSIZE(c_PcPrincipalName));
        lstrcpyW(pKdcPrinc->wszServiceName, c_PcPrincipalName);
        lstrcpynW(pKdcPrinc->wszDomainName, pcwszRealm, ARRAYSIZE(pKdcPrinc->wszDomainName));

        pKdcPrinc->iFlags   = 0;
        pKdcPrinc->iType    = KRB_NT_PRINCIPAL;
        pKdcPrinc->iNumKeys = 1;

        pPreAuth->CopyPrincipalKey(
            pKdcPrinc->rgKey[0].binKey, 
            sizeof(pKdcPrinc->rgKey[0].binKey));
        
        pPreAuth->SetStatus(CPaPcAccountCreationHandler::STATUS_CONSTRUCTED_CLIENT_PRINC);
    }
    else
    {
        // The machine account creation is not a real AS request. The ticket that will be 
        // returned in the response will be discarded. Checking the server principal is 
        // just a formality. We also don't need to worry about a real server key 
        // (pKdcPrinc has already been initialized to zeros).

        XOMASSERT(flags & KDC_KDB_GET_PRINC_SERVER);
        
        pPreAuth->SetStatus(CPaPcAccountCreationHandler::STATUS_GET_PRINC_SERVER);

        if(pkinName->NameCount != 2 ||
           wcsicmp(pkinName->Names[0].Buffer, L"krbtgt") != 0 ||
           wcsicmp(pkinName->Names[1].Buffer, XBOX_KERBEROS_REALM_L) != 0)
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "RetrievePcPrincipal - Invalid server name: %S/%S",
                pkinName->NameCount >= 1 ? pkinName->Names[0].Buffer : L"(null)",
                pkinName->NameCount >= 2 ? pkinName->Names[1].Buffer : L"(null)");
            XomNtEvent(
                XEVENT_XMACS_HACK_INVALID_CLIENT_NAME,
                "Invalid server name: %S/%S",
                pkinName->NameCount >= 1 ? pkinName->Names[0].Buffer : L"(null)",
                pkinName->NameCount >= 2 ? pkinName->Names[1].Buffer : L"(null)");
            
            kerberr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
            goto Exit;
        }

        pPreAuth->SetStatus(CPaPcAccountCreationHandler::STATUS_CONSTRUCTED_SERVER_PRINC);
    }

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "RetrievePcPrincipal - KDC_ERR_NONE");
    kerberr = KDC_ERR_NONE;

Exit:

    *pExtendedError = kerberr;

	
    return kerberr == KDC_ERR_NONE ? STATUS_SUCCESS : STATUS_KDC_INVALID_REQUEST;
}

NTSTATUS
CXMACSProvider::RetrieveXboxPrincipal(
    IN  PKERB_INTERNAL_NAME  pkinName,
    IN  LPCWSTR pcwszRealm,
    IN  IKerbRequest *pIKerbRequest,
    OUT PXKDC_PRINCIPAL pKdcPrinc,
    OUT KERBERR* pExtendedError
)
{
    USES_CONVERSION;
    NTSTATUS status                 = STATUS_SUCCESS;
    KERBERR KerbErr                 = KDC_ERR_NONE;     // the returned kerb result.
    IPAXMACSRequest *pReqInf        = NULL;             // handle to the request interface.
    in_addr *pInAddr                = NULL;
    ULONGLONG qwReqStatus           = 0;

    // verify the given is valid
    XOMASSERT( pKdcPrinc );
    XOMASSERT( pExtendedError );
    XOMASSERT( pIKerbRequest );

    // pass this information through.
    pIKerbRequest->GetPAHandler( IID_IPAXMACSRequest, ((PVOID*)&pReqInf) );
    pInAddr = &(((PSOCKADDR_IN)pIKerbRequest->GetClientAddress())->sin_addr);
    pReqInf->GetRequestStatus( &qwReqStatus );
    pReqInf->SetConsoleType(XmacsConsoleXbox);

    // We are configured to fail all xbox 1 requests
    KerbErr = KDC_ERR_POLICY;
    qwReqStatus |= REQSTAT_XBOX1_DECOMMISSION;

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "RetrieveXboxPrincipal - ACC|????????????|%.8X|%.16I64X|"DBGINAFMT"|0|%d", 
        KerbErr, 
        qwReqStatus, 
        DBGINAPRM(pInAddr), 
        pIKerbRequest->GetElapsedTimeInMs()
        );

    XomLog( 
        log, 
        "ACC|????????????|%.8X|%.16I64X|"DBGINAFMT"|0|%d", 
        KerbErr, 
        qwReqStatus, 
        DBGINAPRM(pInAddr), 
        pIKerbRequest->GetElapsedTimeInMs()
        );
    pReqInf->SetRequestStatus( qwReqStatus );

    if (pExtendedError != NULL) 
    {
        *pExtendedError = KerbErr;
    }
    return status;
}

NTSTATUS
CXMACSProvider::RetrieveXenonPrincipal(
    IN  PKERB_INTERNAL_NAME  pkinName,
    IN  LPCWSTR              pcwszRealm,
    IN  IKerbRequest*        pIKerbRequest,
    OUT PXKDC_PRINCIPAL      pKdcPrinc,
    OUT KERBERR*             pExtendedError
)
{
    ASN1octetstring_t*      padata = NULL;
    ASN1octetstring_t*      padata2 = NULL;
    BOOL                    fSucceeded = false;
    KERBERR                 kerberr = KDC_ERR_SVC_UNAVAILABLE;
    const WCHAR*            pszName = L"???";
    CHAR                    szConsoleId[c_LengthFormattedXenonConsoleId+1]; szConsoleId[0] = '\0';
    ULONGLONG               qwConsoleId = 0;
    BYTE                    pbBinCid[CONSOLE_ID_SIZE] = {0};
    const KERB_KDC_REQUEST* pKdcReq = NULL;
    IPAXMACSRequest         *pReqInf = NULL;
    ULONGLONG               qwReqStatus = 0;
    LARGE_INTEGER           authTime = { 0 };
    LARGE_INTEGER           skewTime = { 0 };
    
#define EVTFOOTERFMT "\n\n{{ Ip: " DBGSINFMT ", Console-id: %s, ReqStatus: 0x%I64X, Kerberr: 0x%X }}"
#define EVTFOOTERPRM DBGSINPRM((PSOCKADDR_IN)pIKerbRequest->GetClientAddress()), szConsoleId, qwReqStatus, kerberr

    memset(pKdcPrinc, 0, sizeof(*pKdcPrinc));

    // Remember that this is a Xenon request
    if(!NT_SUCCESS(pIKerbRequest->GetPAHandler(IID_IPAXMACSRequest, ((PVOID*)&pReqInf))))
    {
        XOMASSERT(false);
        goto lDone;
    }
    pReqInf->GetRequestStatus(&qwReqStatus);
    pReqInf->SetConsoleType(XmacsConsoleXenon);

    // Get principal name from pkinName
    if(!GetNameFromKerbInternalName(pkinName, &pszName))
    {
        g_Counters.IncrementValue32( XMACSPERF_SERVER_INVALID_REQUEST_COUNTER, 1);
        kerberr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "RetrieveXenonPrincipal - Principal name is invalid: %S" EVTFOOTERFMT, 
                   pszName, EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_34, "Principal name is invalid: %S" EVTFOOTERFMT, 
                   pszName, EVTFOOTERPRM);
        goto lDone;
    }

    // Special case. Why is it so?
    if(wcscmp(pszName, L"krbtgt") == 0)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - KDC_ERR_NONE"); 
        kerberr = KDC_ERR_NONE;
        goto lDone;
    }

    // Convert to ASCII and verify console id
    if(!WideCharToMultiByte(CP_ACP, 0, pszName, -1, szConsoleId, ARRAYSIZE(szConsoleId), NULL, NULL) ||
       !VerifyConsoleId(szConsoleId, pbBinCid,  sizeof(pbBinCid), &qwConsoleId))
    {
        g_Counters.IncrementValue32( XMACSPERF_SERVER_INVALID_REQUEST_COUNTER, 1);
        kerberr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - Console id is invalid." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_35, "Console id is invalid." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        goto lDone;
    }

    qwReqStatus |= REQSTAT_VALID_CONSOLE_ID;

    // Verify that all required pre-auth types, and only them, were specified in 
    // the request. We want to do this after DoS checks.

    static const UINT32 AllowedXenonPreAuth[] = {
        KRB5_PADATA_XENON_MAC_REQUEST,      // our certificate and other data
        KRB5_PADATA_ENC_TIMESTAMP,          // standard kerberos encryped timestamp
    };

    static const UINT32 AllowedXenon2PreAuth[] = {
        KRB5_PADATA_XENON_MAC_REQUEST2,     // our certificate and other data
        KRB5_PADATA_ENC_TIMESTAMP,          // standard kerberos encryped timestamp
    };

    static const UINT32 OptionalPreAuth[] = {
        KRB5_PADATA_PAC_REQUEST_EX,         // to enable compound identity 
        KRB5_PADATA_XBOX_CLIENT_VERSION     // client version
    };

    // Look for the Xenon-Mac-Request pre-auth. 
    padata  = GetPaData( pIKerbRequest, KRB5_PADATA_XENON_MAC_REQUEST );
    padata2 = GetPaData( pIKerbRequest, KRB5_PADATA_XENON_MAC_REQUEST2 );
    if (padata        != NULL &&
        padata->value != NULL &&
        padata->length == sizeof(XKERB_PA_XENON_MAC_REQUEST) ) 
    {
        fSucceeded = VerifyPaList(
            pIKerbRequest,
            AllowedXenonPreAuth, ARRAY_SIZE( AllowedXenonPreAuth ),
            OptionalPreAuth,     ARRAY_SIZE( OptionalPreAuth )
            );

        if ( FALSE == fSucceeded )
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once." EVTFOOTERFMT,
                EVTFOOTERPRM);
            XomNtEvent(
                XEVENT_XMACS_HACK_INVALID_PRE_AUTH_TYPE, 
                "Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once." EVTFOOTERFMT,
                EVTFOOTERPRM);
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - KDC_ERR_NO_RESPONSE");
            kerberr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
            goto lDone;
        }

        qwReqStatus |= REQSTAT_VERIFIED_PRE_AUTH_LIST;

        fSucceeded = ProcessXenonMacRequestPreAuth(
            pIKerbRequest,
            padata->value,
            padata->length, 
            pbBinCid,
            qwConsoleId,
            (UINT64 *) &(authTime.QuadPart),
            pKdcPrinc->rgKey[0].binKey, 
            ONLINE_KEY_LEN,
            &qwReqStatus);
        if ( FALSE == fSucceeded )
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - KDC_ERR_PREAUTH_FAILED");
            kerberr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
            goto lDone;
        }
    }
    else if (padata2         != NULL &&
             padata2->value  != NULL &&
             padata2->length == sizeof(XKERB_PA_XENON_MAC_REQUEST2)) 
    {
        fSucceeded = VerifyPaList(
            pIKerbRequest,
            AllowedXenon2PreAuth, ARRAY_SIZE( AllowedXenon2PreAuth ),
            OptionalPreAuth,      ARRAY_SIZE( OptionalPreAuth )
            );

        if ( FALSE == fSucceeded )
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once." EVTFOOTERFMT,
                EVTFOOTERPRM);
            XomNtEvent(
                XEVENT_XMACS_HACK_INVALID_PRE_AUTH_TYPE, 
                "Either the request does not contain all required pre-auths, "
                "the request specified an invalid pre-auth type or "
                "a pre-auth type was specified more than once." EVTFOOTERFMT,
                EVTFOOTERPRM);
            kerberr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
            goto lDone;
        }

        qwReqStatus |= REQSTAT_VERIFIED_PRE_AUTH_LIST;

        fSucceeded = ProcessXenonMacRequest2PreAuth(
            pIKerbRequest,
            padata2->value,
            padata2->length, 
            pbBinCid,
            qwConsoleId,
            (UINT64 *) &(authTime.QuadPart),
            pKdcPrinc->rgKey[0].binKey, 
            ONLINE_KEY_LEN,
            &qwReqStatus);
        if ( FALSE == fSucceeded )
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - KDC_ERR_PREAUTH_FAILED");
            kerberr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
            goto lDone;
        }
    }
    else
    {
        kerberr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - The request is missing the KRB5_PADATA_XENON_MAC_REQUEST and "
            "KRB5_PADATA_XENON_MAC_REQUEST2 pre-auth type." EVTFOOTERFMT,
            EVTFOOTERPRM
            );
        XomNtEvent(
            XEVENT_KDC_HACK_36, 
            "The request is missing the KRB5_PADATA_XENON_MAC_REQUEST and "
            "KRB5_PADATA_XENON_MAC_REQUEST2 pre-auth type." EVTFOOTERFMT,
            EVTFOOTERPRM
            );
       
        goto lDone;
    }

#if 0
    //TFS 304510: We need to revert AuthTime validation in the XenonMac preauth.
    //It turns out that xbox360 clients send up random garbage in the AuthTime field, so we cannot validate this.
    //In the future if we add a V3 Xenon Xmacs preauth, we can fix the client then and re-enable this code for just V3.

    // Verify the auth time
    GetSystemTimeAsFileTime( (PFILETIME) &currentTime );
    skewTime = GetKdcPolicy()->TimeSkew;

    if ((currentTime.QuadPart + skewTime.QuadPart < authTime.QuadPart) ||
        (currentTime.QuadPart - skewTime.QuadPart > authTime.QuadPart) ) 
    {
        kerberr = KRB_AP_ERR_SKEW;
        qwReqStatus |= REQSTAT_PREAUTH_SKEW;
        goto lDone;
    }
#endif

    // DoS detection using DoS2 settings for Xenon XMACS. Must do this after 
    // ProcessXenonMacRequestPreAuth, since it guarantees the console id supplied by the 
    // client matches the one in the client's certificate.
    
    CKdcDos* pKdcDos = GetKdcDos();
    KDCDOS_STATUS dosStatus = pKdcDos->Check(qwConsoleId);

    if(dosStatus == KDCDOS_LIMIT_EXCEEDED)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - A client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires." EVTFOOTERFMT,
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            EVTFOOTERPRM);
        XomNtEvent(
            XEVENT_XMACS_HACK_DOS_ATTACK,
            "A client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires." EVTFOOTERFMT,
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            EVTFOOTERPRM);
        qwReqStatus |= REQSTAT_TEMPORARILY_BANNED;
        kerberr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto lDone;
    }
    else if(dosStatus == KDCDOS_TEMP_BANNED)
    {
        // Client was previously banned and an event was already logged at that time. To 
        // prevent the client from flooding the Nt event log, we're not going to log an 
        // event.
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - KDC_ERR_NO_RESPONSE");
        qwReqStatus |= REQSTAT_TEMPORARILY_BANNED;
        kerberr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto lDone;
    }

    XOMASSERT(dosStatus == KDCDOS_OK);


    // Fill out principal info
    MultiByteToWideChar(CP_ACP, 0, szConsoleId, -1, pKdcPrinc->wszServiceName,
        ARRAYSIZE(pKdcPrinc->wszServiceName));
    lstrcpynW(pKdcPrinc->wszDomainName, pcwszRealm, ARRAYSIZE(pKdcPrinc->wszDomainName));
    pKdcPrinc->wszDomainName[ARRAYSIZE(pKdcPrinc->wszDomainName)-1] = 0;
    pKdcPrinc->iFlags = 0;
    pKdcPrinc->iType  = KRB_NT_PRINCIPAL;
    pKdcPrinc->iNumKeys = 1; // Key was filled out by ProcessXenonMacRequestPreAuth

    kerberr = KDC_ERR_NONE; 


lDone:

    if ( kerberr == KDC_ERR_NONE )
    {
        qwReqStatus |= (REQSTAT_SUCCESSFULLY_CONSTRUCT_PRINC);
    }
    else
    {
        DWORD dwIpAddr = ((PSOCKADDR_IN)pIKerbRequest->GetClientAddress())->sin_addr.S_un.S_addr;

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","RetrieveXenonPrincipal - XEACC|%.15s|%.8X|%.16I64X|"DBGINAFMT"|0|%d", 
                 szConsoleId, kerberr, qwReqStatus, DBGINAPRM((in_addr*)&dwIpAddr), pIKerbRequest->GetElapsedTimeInMs());

        XomLog( log, "XEACC|%.15s|%.8X|%.16I64X|"DBGINAFMT"|0|%d", 
                 szConsoleId, kerberr, qwReqStatus, DBGINAPRM((in_addr*)&dwIpAddr), pIKerbRequest->GetElapsedTimeInMs());

        // deprecate XEVENT_KDC_HACK_37

        g_Counters.IncrementValue32(XMACSPERF_SERVER_INVALID_REQUEST_COUNTER, 1);
    }

    pReqInf->SetRequestStatus( qwReqStatus );

    *pExtendedError = kerberr;

    return kerberr == KDC_ERR_NONE ? STATUS_SUCCESS : STATUS_KDC_INVALID_REQUEST;

#undef EVTFOOTERFMT
#undef EVTFOOTERPRM

}

bool CXMACSProvider::ProcessXenonMacRequestPreAuth(
    IN IKerbRequest             *pIKerbRequest,
    IN const BYTE*              pbPreAuth,
    IN DWORD                    cbPreAuth,
    IN const BYTE*              pbCid,
    IN QWORD                    qwConsoleId,
    OUT UINT64*                 pAuthtime,
    OUT BYTE*                   pbSessionKey,
    IN BYTE                     cbSessionKey,
    IN ULONGLONG                *pqwReqStatus
)
{
    bool                         ret = false;
    DWORD                        dwConsoleType = 0;
    A_SHA_CTX                    shactx;
    XKERB_PA_XENON_MAC_REQUEST*  pPa = (XKERB_PA_XENON_MAC_REQUEST*) pbPreAuth;
    BYTE                         abSha[A_SHA_DIGEST_LEN];
    BYTE                         abConsoleCertSha[A_SHA_DIGEST_LEN];
    DWORD                        cb;
    XE_CONSOLE_CERTIFICATE*      pCert = NULL;
    BYTE                         abDecryptedSessionKey[256];
    IPAXMACSRequest              *pReqInf = NULL;
    CXoCryptoCspPk               keyConsole;
    
#define EVTFOOTERFMT "\n\n{{ Ip: " DBGSINFMT ", Console-id: %s, ReqStatus: 0x%I64X }}"
#define EVTFOOTERPRM DBGSINPRM((PSOCKADDR_IN)pIKerbRequest->GetClientAddress()), CStrUtil().FormatConsoleId(qwConsoleId), *pqwReqStatus

    if(cbPreAuth != sizeof(XKERB_PA_XENON_MAC_REQUEST))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequestPreAuth - Bad pre-auth size: %u" EVTFOOTERFMT, cbPreAuth, EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_38, "Bad pre-auth size: %u" EVTFOOTERFMT, cbPreAuth, EVTFOOTERPRM);
        goto lDone;
    }

    if(!NT_SUCCESS(pIKerbRequest->GetPAHandler(IID_IPAXMACSRequest, ((PVOID*)&pReqInf))))
    {
        XOMASSERT(false);
        goto lDone;
    }

    // Verify the console certificate first
    pCert = &pPa->ConsoleCert;

    if(BYTESWAP16(pCert->CertSize) != sizeof(XE_CONSOLE_CERTIFICATE))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequestPreAuth - Bad console cert size: %u" EVTFOOTERFMT, 
                   BYTESWAP16(pPa->ConsoleCert.CertSize), EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_39, "Bad console cert size: %u" EVTFOOTERFMT, 
                   BYTESWAP16(pPa->ConsoleCert.CertSize), EVTFOOTERPRM);
        goto lDone;
    }

    if(memcmp(pCert->ConsoleId, pbCid, CONSOLE_ID_SIZE) != 0)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequestPreAuth - Console id in certificate doesn't match the one in the request. " 
                   "Cert = %s, Req = %s." EVTFOOTERFMT,
                   CStrUtil().FormatConsoleId(pCert->ConsoleId), CStrUtil().FormatConsoleId(pbCid), 
                   EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_40, "Console id in certificate doesn't match the one in the request. " 
                   "Cert = %s, Req = %s." EVTFOOTERFMT,
                   CStrUtil().FormatConsoleId(pCert->ConsoleId), CStrUtil().FormatConsoleId(pbCid), 
                   EVTFOOTERPRM);
        goto lDone;
    }

    *pqwReqStatus |= REQSTAT_VALID_CERTIFICATE_CONSOLE_ID;

    // Check if the console type is allowed in this environment
    dwConsoleType = BYTESWAP32(pCert->ConsoleType);

    if(!VerifyConsoleType(pIKerbRequest, qwConsoleId, dwConsoleType))
    {
        goto lDone;
    }

    *pqwReqStatus |= REQSTAT_VALID_CERTIFICATE_CONSOLE_TYPE;

    // Verify the certificate's signature. Calculate the digest (sha1) of 
    // the certificate
    A_SHAInit(&shactx);
    BYTE* p = (BYTE*) &(pPa->ConsoleCert);
    cb = offsetof(XE_CONSOLE_CERTIFICATE, Signature);
    XOMASSERT(p + cb == pPa->ConsoleCert.Signature);
    A_SHAUpdate(&shactx, p, cb);
    A_SHAFinal(&shactx, abConsoleCertSha);

    // Verify signature using master-signing-key
    if(!m_masterSigningPublicKey.VerifySignature(abConsoleCertSha, sizeof(abConsoleCertSha), 
        pPa->ConsoleCert.Signature, sizeof(pPa->ConsoleCert.Signature)))
    {
        if(!m_masterSigningPublicKeyTest.IsInitialized() ||
           !m_masterSigningPublicKeyTest.VerifySignature(abConsoleCertSha, sizeof(abConsoleCertSha), 
                pPa->ConsoleCert.Signature, sizeof(pPa->ConsoleCert.Signature)))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequestPreAuth - Failed to verify signature of the console certificate." EVTFOOTERFMT,
                       EVTFOOTERPRM);
            XomNtEvent(XEVENT_KDC_HACK_42, "Failed to verify signature of the console certificate." EVTFOOTERFMT,
                       EVTFOOTERPRM);
            goto lDone;
        }
    }

    *pqwReqStatus |= REQSTAT_VALID_CERTIFICATE_SIGNATURE;

    // Decrypt the session key
    cb = sizeof(pPa->abEncSessionKey);
    if(!XmacsCryptoDecryptWithXmacsKey(pPa->abEncSessionKey,
                                       sizeof(pPa->abEncSessionKey),
                                       abDecryptedSessionKey,
                                       &cb,
                                       sizeof(abDecryptedSessionKey)))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequestPreAuth - Failed to decrypt session key." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_43, "Failed to decrypt session key." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        goto lDone;
    }

    if(cb != cbSessionKey)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequestPreAuth - Size of session key is wrong: %u" EVTFOOTERFMT, 
            cbSessionKey, EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_44, "Size of session key is wrong: %u" EVTFOOTERFMT, 
            cbSessionKey, EVTFOOTERPRM);
        goto lDone;
    }
    memcpy(pbSessionKey, abDecryptedSessionKey, cbSessionKey);

    // Now we can use the console's online Rsa key to verify the signature of
    // Authtime || SHA1(SessionKey)
    if(!keyConsole.OpenConsolePublicKey((BYTE*)&pCert->ConsolePublicKey,
        sizeof(pCert->ConsolePublicKey), CXoCryptoCspPk::KeyPurposeSign))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequestPreAuth - Failed to import console key." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_45, "Failed to import console key." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        goto lDone;
    }
    
    // Calculate Sha1(session-key)
    A_SHAInit(&shactx);
    A_SHAUpdate(&shactx, pbSessionKey, cbSessionKey);
    A_SHAFinal(&shactx, abSha);
    
    // Calculate Sha1(Authtime || sha1(session-key))
    A_SHAInit(&shactx);
    A_SHAUpdate(&shactx, (BYTE*)&pPa->qwAuthtime, sizeof(pPa->qwAuthtime));
    A_SHAUpdate(&shactx, abSha, sizeof(abSha));
    A_SHAFinal(&shactx, abSha);
    
    // Verify signature
    if(!keyConsole.VerifySignature(abSha, sizeof(abSha), pPa->abSignAtSk,
        sizeof(pPa->abSignAtSk)))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequestPreAuth - Failed to verify signature of Authtime || sha1(session-key)" EVTFOOTERFMT,
                   EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_46,  "Failed to verify signature of Authtime || sha1(session-key)" EVTFOOTERFMT,
                   EVTFOOTERPRM);
        goto lDone;
    }

    *pAuthtime = pPa->qwAuthtime;

    ret = true;
    *pqwReqStatus |= REQSTAT_VALID_XENON_MAC_PRE_AUTH;

    // Remember the console certificate and hash for future use
    pReqInf->SetConsoleCertHash( abConsoleCertSha );
    pReqInf->SetConsoleCert( &(pPa->ConsoleCert) );

lDone:

    return ret;

#undef EVTFOOTERFMT
#undef EVTFOOTERPRM

}

bool CXMACSProvider::ProcessXenonMacRequest2PreAuth(
    IN IKerbRequest             *pIKerbRequest,
    IN const BYTE*              pbPreAuth,
    IN DWORD                    cbPreAuth,
    IN const BYTE*              pbCid,
    IN QWORD                    qwConsoleId,
    OUT UINT64*                 pAuthtime,
    OUT BYTE*                   pbSessionKey,
    IN BYTE                     cbSessionKey,
    IN ULONGLONG                *pqwReqStatus
)
{
    bool                         ret = false;
    DWORD                        dwConsoleType = 0;
    A_SHA_CTX                    shactx;
    XKERB_PA_XENON_MAC_REQUEST2* pPa = (XKERB_PA_XENON_MAC_REQUEST2*) pbPreAuth;
    BYTE                         abSha[A_SHA_DIGEST_LEN];
    BYTE                         abConsoleCertSha[A_SHA_DIGEST_LEN];
    DWORD                        cb;
    XE_CONSOLE_CERTIFICATE*      pCert = NULL;
    BYTE                         abDecryptedSessionKey[256];
    IPAXMACSRequest              *pReqInf = NULL;
    CXoCryptoCspPk               keyConsole;
    
#define EVTFOOTERFMT "\n\n{{ Ip: " DBGSINFMT ", Console-id: %s, ReqStatus: 0x%I64X }}"
#define EVTFOOTERPRM DBGSINPRM((PSOCKADDR_IN)pIKerbRequest->GetClientAddress()), CStrUtil().FormatConsoleId(qwConsoleId), *pqwReqStatus

    if(cbPreAuth != sizeof(XKERB_PA_XENON_MAC_REQUEST2))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Bad pre-auth size: %u" EVTFOOTERFMT, cbPreAuth, EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_38, "Bad pre-auth size: %u" EVTFOOTERFMT, cbPreAuth, EVTFOOTERPRM);
        goto lDone;
    }

    if(!NT_SUCCESS(pIKerbRequest->GetPAHandler(IID_IPAXMACSRequest, ((PVOID*)&pReqInf))))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - !NT_SUCCESS(pIKerbRequest->GetPAHandler(IID_IPAXMACSRequest, ((PVOID*)&pReqInf)");
        XOMASSERT(false);
        goto lDone;
    }

    // Verify the console certificate first
    pCert = &pPa->ConsoleCert;

    if(BYTESWAP16(pCert->CertSize) != sizeof(XE_CONSOLE_CERTIFICATE))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Bad console cert size: %u" EVTFOOTERFMT, 
                   BYTESWAP16(pPa->ConsoleCert.CertSize), EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_39, "Bad console cert size: %u" EVTFOOTERFMT, 
                   BYTESWAP16(pPa->ConsoleCert.CertSize), EVTFOOTERPRM);
        goto lDone;
    }

    if(memcmp(pCert->ConsoleId, pbCid, CONSOLE_ID_SIZE) != 0)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Console id in certificate doesn't match the one in the request. " 
                   "Cert = %s, Req = %s." EVTFOOTERFMT,
                   CStrUtil().FormatConsoleId(pCert->ConsoleId), CStrUtil().FormatConsoleId(pbCid), 
                   EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_40, "Console id in certificate doesn't match the one in the request. " 
                   "Cert = %s, Req = %s." EVTFOOTERFMT,
                   CStrUtil().FormatConsoleId(pCert->ConsoleId), CStrUtil().FormatConsoleId(pbCid), 
                   EVTFOOTERPRM);
        goto lDone;
    }

    *pqwReqStatus |= REQSTAT_VALID_CERTIFICATE_CONSOLE_ID;

    // Check if the console type is allowed in this environment
    dwConsoleType = BYTESWAP32(pCert->ConsoleType);

    if(!VerifyConsoleType(pIKerbRequest, qwConsoleId, dwConsoleType))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - if(!VerifyConsoleType(pIKerbRequest, qwConsoleId, dwConsoleType))");
        goto lDone;
    }

    *pqwReqStatus |= REQSTAT_VALID_CERTIFICATE_CONSOLE_TYPE;

    // Verify the certificate's signature. Calculate the digest (sha1) of 
    // the certificate
    A_SHAInit(&shactx);
    BYTE* p = (BYTE*) &(pPa->ConsoleCert);
    cb = offsetof(XE_CONSOLE_CERTIFICATE, Signature);
    XOMASSERT(p + cb == pPa->ConsoleCert.Signature);
    A_SHAUpdate(&shactx, p, cb);
    A_SHAFinal(&shactx, abConsoleCertSha);

    // Verify signature using master-signing-key
    if(!m_masterSigningPublicKey.VerifySignature(abConsoleCertSha, sizeof(abConsoleCertSha), 
        pPa->ConsoleCert.Signature, sizeof(pPa->ConsoleCert.Signature)))
    {
        if(!m_masterSigningPublicKeyTest.IsInitialized() ||
           !m_masterSigningPublicKeyTest.VerifySignature(abConsoleCertSha, sizeof(abConsoleCertSha), 
                pPa->ConsoleCert.Signature, sizeof(pPa->ConsoleCert.Signature)))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Failed to verify signature of the console certificate." EVTFOOTERFMT,
                       EVTFOOTERPRM);
            XomNtEvent(XEVENT_KDC_HACK_42, "Failed to verify signature of the console certificate." EVTFOOTERFMT,
                       EVTFOOTERPRM);
            goto lDone;
        }
    }

    *pqwReqStatus |= REQSTAT_VALID_CERTIFICATE_SIGNATURE;

    // Decrypt the session key
    cb = sizeof(pPa->abEncSessionKey);
    if(!XmacsCryptoDecryptWithXmacsKey(pPa->abEncSessionKey,
                                       sizeof(pPa->abEncSessionKey),
                                       abDecryptedSessionKey,
                                       &cb,
                                       sizeof(abDecryptedSessionKey)))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Failed to decrypt session key." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_43, "Failed to decrypt session key." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        goto lDone;
    }

    if(cb != cbSessionKey)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Size of session key is wrong: %u" EVTFOOTERFMT, 
            cbSessionKey, EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_44, "Size of session key is wrong: %u" EVTFOOTERFMT, 
            cbSessionKey, EVTFOOTERPRM);
        goto lDone;
    }
    memcpy(pbSessionKey, abDecryptedSessionKey, cbSessionKey);

    // Now we can use the console's online Rsa key to verify the signature of
    // Authtime || SHA1(SessionKey)
    if(!keyConsole.OpenConsolePublicKey((BYTE*)&pCert->ConsolePublicKey,
        sizeof(pCert->ConsolePublicKey), CXoCryptoCspPk::KeyPurposeSign))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Failed to import console key." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_45, "Failed to import console key." EVTFOOTERFMT,
                   EVTFOOTERPRM);
        goto lDone;
    }
    
    // Calculate Sha1(session-key)
    A_SHAInit(&shactx);
    A_SHAUpdate(&shactx, pbSessionKey, cbSessionKey);
    A_SHAFinal(&shactx, abSha);
    
    // Calculate Sha1(Authtime | abSerialNum | sha1(session-key))
    A_SHAInit(&shactx);
    A_SHAUpdate(&shactx, (BYTE*)&pPa->qwAuthtime, sizeof(pPa->qwAuthtime));
    A_SHAUpdate(&shactx, (BYTE*)pPa->abSerialNum, sizeof(pPa->abSerialNum));
    A_SHAUpdate(&shactx, abSha, sizeof(abSha));
    A_SHAFinal(&shactx, abSha);
    
    // Verify signature
    if(!keyConsole.VerifySignature(abSha, sizeof(abSha), pPa->abSignAtSk,
        sizeof(pPa->abSignAtSk)))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Failed to verify signature of Authtime || sha1(session-key)" EVTFOOTERFMT,
                   EVTFOOTERPRM);
        XomNtEvent(XEVENT_KDC_HACK_46,  "Failed to verify signature of Authtime || sha1(session-key)" EVTFOOTERFMT,
                   EVTFOOTERPRM);
        goto lDone;
    }

    *pAuthtime = pPa->qwAuthtime;

    ret = true;
    *pqwReqStatus |= REQSTAT_VALID_XENON_MAC_PRE_AUTH;

    // Remember the console certificate, serial number, and hash for future use
    pReqInf->SetConsoleCertHash( abConsoleCertSha );
    pReqInf->SetConsoleCert( &(pPa->ConsoleCert) );
    pReqInf->SetConsoleSerialNumber( pPa->abSerialNum );

lDone:

    return ret;

#undef EVTFOOTERFMT
#undef EVTFOOTERPRM

}

// --------------------------------------------------------------------------------------
// CXMACSProvider::VerifyConsoleType
//   Check the console type from a console certificate against the console type mask 
//   that the server is configured with. This is where we differentiate between retail 
//   and non-retail units and grant or deny access accordingly.
//  - consoleId: console-id for logging purposes and for exception list
//  - consoleType: console-type field from the console's certificate in host byte order
// Returns true if console type is allowed in this environment and false otherwise. This 
// function will log an event on failure.
// --------------------------------------------------------------------------------------
bool CXMACSProvider::VerifyConsoleType(IKerbRequest *pIKerbRequest, UINT64 consoleId, DWORD consoleType)
{
    if((consoleType & m_dwConsoleTypeMask) != consoleType &&
       !CheckExceptionList(consoleId))
    {
        if(consoleType & CONSOLE_CERTIFICATE_TYPE_TESTKIT)
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Testkit detected. Alert Dev immediately! "
                "Console-id = %s, Console-type = 0x%x, Environment-mask = 0x%x, Ip = " DBGSINFMT,
                CStrUtil().FormatConsoleId(consoleId), consoleType, m_dwConsoleTypeMask, 
                DBGSINPRM((PSOCKADDR_IN)pIKerbRequest->GetClientAddress()));
            XomNtEvent(
                XEVENT_XMACS_HACK_TESTKIT_NOT_ALLOWED,
                "Testkit detected. Alert Dev immediately! "
                "Console-id = %s, Console-type = 0x%x, Environment-mask = 0x%x, Ip = " DBGSINFMT,
                CStrUtil().FormatConsoleId(consoleId), consoleType, m_dwConsoleTypeMask, 
                DBGSINPRM((PSOCKADDR_IN)pIKerbRequest->GetClientAddress()));
        }
        else
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ProcessXenonMacRequest2PreAuth - Console type not allowed in this environment. "
                "Console-id = %s, Console-type = 0x%x, Environment-mask = 0x%x, Ip = " DBGSINFMT,
                CStrUtil().FormatConsoleId(consoleId), consoleType, m_dwConsoleTypeMask, 
                DBGSINPRM((PSOCKADDR_IN)pIKerbRequest->GetClientAddress()));
            XomNtEvent(
                XEVENT_XMACS_HACK_CONSOLE_TYPE_NOT_ALLOWED,
                "Console type not allowed in this environment. "
                "Console-id = %s, Console-type = 0x%x, Environment-mask = 0x%x, Ip = " DBGSINFMT,
                CStrUtil().FormatConsoleId(consoleId), consoleType, m_dwConsoleTypeMask, 
                DBGSINPRM((PSOCKADDR_IN)pIKerbRequest->GetClientAddress()));
        }

        return false;
    }

    return true;
}

// Verify and convert a console id in string form to its 5 byte binary and
// QWORD form
bool CXMACSProvider::VerifyConsoleId(
    IN  const CHAR* pszCid,
    OUT BYTE*       pbBinCid,
    IN DWORD        cbBinCid,
    OUT ULONGLONG*  pqwConsoleId
)
{
    if(pbBinCid && cbBinCid != CONSOLE_ID_SIZE)
        return false;
    
    int cchName = strlen(pszCid);
    if(cchName != c_LengthFormattedXenonConsoleId)
        return false; // Wrong size

    if(memcmp(pszCid, c_szXenonConsoleIdPrefix, ARRAYSIZE(c_szXenonConsoleIdPrefix)-1) != 0)
        return false; // Wrong prefix

    // The console id is made of 11 significant digits + 1 checksum digit
    // For example: XE.123456789016 
    // Where 6 is the checksum of 12345678901
    // Calculate checksum now. At the same time calculate binary form of the 
    // console id
    const CHAR* pchDigit = pszCid + (ARRAYSIZE(c_szXenonConsoleIdPrefix) - 1);
    DWORD cch = c_LengthFormattedXenonConsoleId - (ARRAYSIZE(c_szXenonConsoleIdPrefix) - 1);
    DWORD digit  = 0;
    DWORD chksum = 0;
    UINT64 qwCid = 0;
    DWORD i;
    for(i=0; i < cch-1; i++)
    {
        if(!isdigit(pchDigit[i]))
            return false; // Console id must be made of just digits

        digit = (pchDigit[i] - '0');
        chksum += digit; 
        qwCid = (qwCid * 10) + digit;
    }

    if(qwCid == 0)
        return false; // Cid can't be zero
    
    if(qwCid > 0x0FFFFFFFFF)
        return false; // Cid is too large
    
    // Verify checksum
    digit = (pchDigit[i] - '0'); 
    if(digit != chksum % 10)
        return false; // Failed checksum

    qwCid = (qwCid << 4) + digit;

    if(pqwConsoleId)
    {
        *pqwConsoleId = qwCid | PUID_BASE_XENON_CONSOLE;
    }

    if(pbBinCid)
    {
        for(i=0; i < cbBinCid; i++)
        {
            pbBinCid[cbBinCid - i - 1] = (BYTE)(qwCid & 0xFF);
            qwCid >>= 8;
        }
    }
    
    return true;
}

bool CXMACSProvider::GetNameFromKerbInternalName(
    IN PKERB_INTERNAL_NAME pkinName,
    OUT LPCWSTR* ppszName
)
{
    if ( IsKrbTgt(pkinName) )
    {
        // krbtgt is the first component, the realm name is the second
        *ppszName = pkinName->Names[0].Buffer;
        return true;
    }
    else if ( IsSG(pkinName) )
    {
        // Not supported by this extension
        return false;
    }
    else if ( pkinName->NameCount == 1 )
    {
        // ordinary principal, name is the first component
        *ppszName = pkinName->Names[0].Buffer;
        return true;
    }
    else
    {
        // Unsupported name convention
        return false;
    }
}

NTSTATUS
CXMACSProvider::InitializeExtensionHandlers()
{
    // @@@ All these factories are being leaked. Not a super big deal but we should fix 
    // it for the sake of a clean shutdown

    NTSTATUS status = STATUS_SUCCESS;
    IPAHandlerFactory *pIPAFac = NULL;

    // Register CPAXboxAccountCreationHandlerFactory
    pIPAFac = (IPAHandlerFactory*) new CPAXboxAccountCreationHandlerFactory(this);
    if ( NULL == pIPAFac )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeExtensionHandlers - STATUS_SERVER_DISABLED");
        status = STATUS_SERVER_DISABLED;
        goto Exit;
    }
    KdcRegisterPAHandlerFactory(pIPAFac);
    pIPAFac = NULL;

    // Register CPaXenonMacRequestFactory
    pIPAFac = (IPAHandlerFactory*) new CPaXenonMacRequestFactory(this);
    if ( NULL == pIPAFac )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeExtensionHandlers - STATUS_SERVER_DISABLED");
        status = STATUS_SERVER_DISABLED;
        goto Exit;
    }
    KdcRegisterPAHandlerFactory(pIPAFac);
    pIPAFac = NULL;

    pIPAFac = (IPAHandlerFactory*) new CPaPcAccountCreationHandler::Factory(this);
    if ( NULL == pIPAFac )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeExtensionHandlers - STATUS_SERVER_DISABLED");
        status = STATUS_SERVER_DISABLED;
        goto Exit;
    }
    KdcRegisterPAHandlerFactory(pIPAFac);
    pIPAFac = NULL;

Exit:
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeExtensionHandlers - status: 0x%X",status);
    return status;
}


NTSTATUS
CXMACSProvider::LoadConfig()
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;

    g_dwPUIDBlockSize = GetDWORDSetting( 
        Setting_kdcsvc_xmacs_PUIDBlockSize,
        c_nPUIDBlockSize
        );
    m_dwEncryptionKeyVersion = GetDWORDSetting(
        Setting_kdcsvc_xmacs_keyEncryptionKeyVersion,
        0
        );
    g_bAcceptDevKits = (BOOL)GetDWORDSetting(
        Setting_kdcsvc_xmacs_acceptDevKits,
        FALSE
        );
    g_dwHashListPercentageWarning = GetDWORDSetting(
        Setting_kdcsvc_xmacs_hashListPercentageWarning,
        c_dwDefaultHLPctWrn
        );
    m_KdcPolicy.TimeSkew.QuadPart = 
        (LONGLONG) 10000000 *
        GetDWORDSetting( Setting_kdcsvc_xmacs_timeSkewSeconds, 120 );
    m_dwConsoleTypeMask = GetDWORDSetting(
        Setting_kdcsvc_xmacs_consoleTypeMask,
        0
        );
    return status;

}

CXBaseProvider::VALIDATE_SETTING_RESULT 
CALLBACK
CXMACSProvider::ValidateSetting(
    CComBSTR &SettingChange
    )
{
    static const CComBSTR aValidSettings[] = {
        Setting_kdcsvc_xmacs_maxAllowancePerHour,
        Setting_kdcsvc_xmacs_DOSStage1CacheTimeout,
        Setting_kdcsvc_xmacs_DOSStage2CacheTimeout,
        Setting_kdcsvc_xmacs_PUIDBlockSize,
        Setting_kdcsvc_xmacs_keyEncryptionKeyVersion,
        Setting_kdcsvc_xmacs_acceptDevKits,
        Setting_kdcsvc_xmacs_hashListPercentageWarning,
        Setting_kdcsvc_xmacs_timeSkewSeconds,
        Setting_kdcsvc_xmacs_consoleTypeMask,
        Setting_kdcsvc_xmacs_consoleExceptionList,
        Setting_kdcsvc_xmacs_DoS2_enabled, 
        Setting_kdcsvc_xmacs_DoS2_cacheSize, 
        Setting_kdcsvc_xmacs_DoS2_maxRequests, 
        Setting_kdcsvc_xmacs_DoS2_interval, 
        Setting_kdcsvc_xmacs_DoS2_blockingTime,
        Setting_kdcsvc_xmacs_LimitedPcTokens 
    };

    VALIDATE_SETTING_RESULT result = SETTING_DONT_CARE;

    for(int i=0; i < ARRAYSIZE(aValidSettings); i++)
    {
        if(SettingChange == aValidSettings[i])
        {
            result = SETTING_ACCEPTED;
            break;
        }
    }

    return result;
}

void
CXMACSProvider::ApplySetting(
    CComBSTR &SettingChange,
    CComBSTR &bsValueNew
    )
{
    HRESULT hr = S_OK;

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ApplySetting - CXMACSProvider::ApplySetting(%ws) called.",
        static_cast<wchar_t *> (SettingChange)
        );

    XomNtEvent(
        XEVENT_KDC_INFO_28,
        "CXMACSProvider::ApplySetting(%ws) called.",
        static_cast<wchar_t *> (SettingChange)
        );

    //
    // Hold the config write lock
    //
    ConfigWriteLock();

    //
    // Take action based upon which setting we are asked to change
    //
    if (SettingChange == Setting_kdcsvc_xmacs_maxAllowancePerHour)
    {
        //
        // Update the DOS list setting if possible
        //
        if (m_pDos)
        {
            m_pDos->SetMaxAllowance( wcstoul( bsValueNew, NULL, 0 ) );
        }
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_DOSStage1CacheTimeout)
    {
        //
        // Update the DOS list setting if possible
        //
        if (m_pDos)
        {
            m_pDos->SetStage1Timeout( wcstoul( bsValueNew, NULL, 0 ) );
        }
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_DOSStage2CacheTimeout)
    {
        //
        // Update the DOS list setting if possible
        //
        if (m_pDos)
        {
            m_pDos->SetStage2Timeout( wcstoul( bsValueNew, NULL, 0 ) );
        }
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_PUIDBlockSize)
    {
        //
        // Update the global variable
        //
        g_dwPUIDBlockSize = wcstoul( bsValueNew, NULL, 0 );
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_keyEncryptionKeyVersion)    
    {        
        //
        // Update the internal variable
        //
        m_dwEncryptionKeyVersion = wcstoul( bsValueNew, NULL, 0 );
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_acceptDevKits)
    {
        //
        // Update the global variable
        //
        g_bAcceptDevKits = (BOOL) wcstoul( bsValueNew, NULL, 0 );
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_hashListPercentageWarning)
    {
        //
        // Update the global variable
        //
        g_dwHashListPercentageWarning = wcstoul( bsValueNew, NULL, 0 );
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_timeSkewSeconds)
    {
        //
        // Update the internal variable
        //
        m_KdcPolicy.TimeSkew.QuadPart = 
            (LONGLONG)10000000 *
            wcstoul( bsValueNew, NULL, 0 );
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_consoleTypeMask)
    {       
        //
        // Update the internal variable
        //
        m_dwConsoleTypeMask = wcstoul(bsValueNew, NULL, 0);
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_consoleExceptionList)
    {
        hr = LoadExceptionList(bsValueNew);
        if (FAILED(hr))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ApplySetting - Failed to LoadExceptionList()");
            XomNtEvent(XEVENT_KDC_CONFIG_109, "Failed to LoadExceptionList()");
            hr = E_FAIL;
        }
    }
    else if (SettingChange == Setting_kdcsvc_xmacs_LimitedPcTokens)
    {
        m_bstrLimitedTokens.Empty();
        m_bstrLimitedTokens = bsValueNew;
        m_bstrLimitedTokens.ToUpper();

    }

    //
    // Done with the setting change
    //
    ConfigWriteUnlock();
    
    // The following don't require the ConfigWriteLock
    
    if(SettingChange == Setting_kdcsvc_xmacs_DoS2_enabled)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetEnabled(value))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ApplySetting - Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xmacs_DoS2_enabled: %u \n",
                value);
            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xmacs_DoS2_enabled: %u \n",
                value);
        }

    }
    else if(SettingChange == Setting_kdcsvc_xmacs_DoS2_maxRequests)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetMaxRequests(value))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ApplySetting - Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xmacs_DoS2_maxRequests: %u \n",
                value);
            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xmacs_DoS2_maxRequests: %u \n",
                value);
        }
    }
    else if(SettingChange == Setting_kdcsvc_xmacs_DoS2_interval)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetInterval(value))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ApplySetting - Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xmacs_DoS2_interval: %u \n",
                value);
            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xmacs_DoS2_interval: %u \n",
                value);
        }
    }
    else if(SettingChange == Setting_kdcsvc_xmacs_DoS2_blockingTime)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetBlockingTime(value))
        {
			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","ApplySetting - Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xmacs_DoS2_blockingTime: %u \n",
                value);
            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_xmacs_DoS2_blockingTime: %u \n",
                value);
        }
    }

    return;
}

//------------------------------------------------------------------
//  IsDevKit:  Checks if the serial number is a dev kit.
//------------------------------------------------------------------
BOOL CXMACSProvider::IsDevKit( const char* szSerialNum )
{
    BOOL bRes = TRUE;

    // ensure the serial number has 12 characters.
    XOMASSERT( strlen( szSerialNum ) == 12 );

    // 9 and 10 characters rep the week.  There is no week 99 ... this is
    //   how a dev kit ids itself.
    bRes = ( szSerialNum[8] == '9' && szSerialNum[9]== '9' );

    return bRes;
}


//------------------------------------------------------------------
//  IsDevKitW:  Checks if the serial number is a dev kit.
//------------------------------------------------------------------
BOOL CXMACSProvider::IsDevKitW( const WCHAR* wszSerialNum )
{
    BOOL bRes = TRUE;

    // ensure the serial number has 12 characters.
    XOMASSERT( wcslen( wszSerialNum ) == 12 );

    // 9 and 10 characters rep the week.  There is no week 99 ... this is
    //   how a dev kit ids itself.
    bRes = ( wszSerialNum[8] == '9' && wszSerialNum[9]== '9' );

    return bRes;
}

//------------------------------------------------------------------
// NCipherInit thread implementation

//------------------------------------------------------------------
//  NCipherInitThread:  Thread to get keys from nCipher.
//------------------------------------------------------------------
DWORD WINAPI CXMACSProvider::NCipherInitThread( LPVOID pThis )
{
    ((CXMACSProvider*)pThis)->InitializeCrypto();

    return 0;
}

//------------------------------------------------------------------
//  InitializeCrypto:  Thread to get keys from nCipher.
//------------------------------------------------------------------
NTSTATUS CXMACSProvider::InitializeCrypto()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    BOOL bResult = TRUE;

    // open crypto context with the private key
    bResult = CryptAcquireContext(&m_hProv, L"XboxOnlineKeyV1", c_wszProvider, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET | CRYPT_SILENT );
    if (!bResult)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeCrypto - XMACS:(CXMACSProvider::InitializeCrypto)  nCipher CryptAcquireContext failed with 0x%X.  This could be caused by an improper nCIpher key setup on this machine or missing operator cards.  Please investigate the error.", GetLastError());

        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::InitializeCrypto)  nCipher CryptAcquireContext failed with 0x%X.  This could be caused by an improper nCIpher key setup on this machine or missing operator cards.  Please investigate the error.", GetLastError());
        XomNtEvent( XEVENT_XMACS_NCIPHER_NOT_FUNCTIONING, "XMACS:(CXMACSProvider::InitializeCrypto)  nCipher CryptAcquireContext failed with 0x%X", GetLastError());
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeCrypto - STATUS_SERVER_DISABLED");
        status = STATUS_SERVER_DISABLED;
        goto Exit;
    }

    bResult = CryptGetUserKey(m_hProv, AT_KEYEXCHANGE, &m_hPrvKey );
    if (!bResult)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeCrypto - XMACS:(CXMACSProvider::InitializeCrypto)  CryptGetUserKey failed with 0x%X", GetLastError());
        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::InitializeCrypto)  CryptGetUserKey failed with 0x%X", GetLastError());
        XomNtEvent( XEVENT_XMACS_NCIPHER_NOT_FUNCTIONING_1, "XMACS:(CXMACSProvider::InitializeCrypto)  CryptGetUserKey failed with 0x%X", GetLastError());
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeCrypto - STATUS_SERVER_DISABLED");
        status = STATUS_SERVER_DISABLED;
        goto Exit;
    }

    InterlockedExchange( (LPLONG)&m_bIsNCipherInit,  (LONG)TRUE );

Exit:
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","InitializeCrypto - status: 0x%X", status);
    return status;

}
//------------------------------------------------------------------
//  GetNewPuidRange:  Get a puid range from the UODB
//------------------------------------------------------------------
HRESULT CXMACSProvider::GetNewPuidRange(
    int nReqSize, 
    ULONGLONG qwBase, 
    OUT DWORD* pdwRemainingPuids, 
    OUT ULONGLONG* pqwNextPuid
    )
{
    // Doing this allows only the first CallProc call to have to do any parsing
    static CWSProcCache cache;

    HRESULT hr = S_OK;
    ULONGLONG qwNextPuidRange = 0;
    DWORD dwProcRetVal = 0;
    NTSTATUS status = STATUS_SUCCESS;

    CComBSTR bsConnectionString;

    CODBWSession ses;

    hr = m_pConfig->get_NpdbConnectionString(&bsConnectionString);
    if (FAILED(hr))
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","GetNewPuidRange - XMACS:(CXMACSProvider::GetNewPuidRange)  Failed to get NPDB connection string.  RESULT = 0x%X", hr);

        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::GetNewPuidRange)  Failed to get NPDB connection string.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_83, "XMACS:(CXMACSProvider::GetNewPuidRange)  Failed to get NPDB connection string.  This should never be fired; XMACS is in an invalid state.  Please investigate.  RESULT = 0x%X", hr);
        goto Exit;
    }

    // Connect to the NPDB database
    hr = ses.InitializeEx( bsConnectionString );
    if( FAILED( hr ) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","GetNewPuidRange - XMACS:(CXMACSProvider::GetNewPuidRange)  Failed to get intialize session with CN='%ws'.  RESULT = 0x%X", bsConnectionString, hr);

        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::GetNewPuidRange)  Failed to get intialize session with CN='%ws'.  RESULT = 0x%X", bsConnectionString, hr);
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_86, "XMACS:(CXMACSProvider::GetNewPuidRange)  Failed to get intialize session with CN='%ws'.  This should never be fired; XMACS is in an invalid state.  Please investigate.  RESULT = 0x%X", bsConnectionString, hr);
        goto Exit;
    }

    // Get the next block of team puids
    int dwBucket = 0; // take puids from bucket 0
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","GetNewPuidRange - { hr = CALL p_puid_get_next_id;1 ( %d, %d, %d, %d) }", dwBucket, nReqSize, 0, qwBase);
    XomTrace( XMACS, L_LOW, "{ hr = CALL p_puid_get_next_id;1 ( %d, %d, %d, %d) }", dwBucket, nReqSize, 0, qwBase);
    hr = ses.CallProc( &cache, c_wszPUIDGenQuery, dwBucket, nReqSize, qwBase);
    if( FAILED( hr ) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","GetNewPuidRange - XMACS:(CXMACSProvider::GetNewPuidRange)  Failed to call p_puid_get_next_id via '%ws'.  RESULT = 0x%X", c_wszPUIDGenQuery, hr);
        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::GetNewPuidRange)  Failed to call p_puid_get_next_id via '%ws'.  RESULT = 0x%X", c_wszPUIDGenQuery, hr);
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_87, "XMACS:(CXMACSProvider::GetNewPuidRange)  Failed to call p_puid_get_next_id via '%ws'.  This should never be fired; XMACS is in an invalid state.  Please investigate.  RESULT = 0x%X", c_wszPUIDGenQuery, hr);
        goto Exit;
    }

    dwProcRetVal = ses.GetStatus();
    if( FAILED( dwProcRetVal ) )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","GetNewPuidRange - XMACS:(CXMACSProvider::GetNewPuidRange)  Failing result code from p_puid_get_next_id.  RESULT = 0x%X", dwProcRetVal);
        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::GetNewPuidRange)  Failing result code from p_puid_get_next_id.  RESULT = 0x%X", dwProcRetVal);
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_88, "XMACS:(CXMACSProvider::GetNewPuidRange)  Failing result code from p_puid_get_next_id.  This should never be fired; XMACS is in an invalid state.  Please investigate.  RESULT = 0x%X", dwProcRetVal);
        hr = dwProcRetVal;
        goto Exit;
    }

    qwNextPuidRange = *((QWORD *) ses.GetParam(4));

    // ensure the puid range is not zero.
    if ( qwNextPuidRange == 0 )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","GetNewPuidRange - XMACS:(CXMACSProvider::GetNewPuidRange)  Stored proc returned a 0 PUID range.  PUID RANGE= 0x%I64X, Return Value=0xX, RESULT = 0x%X", qwNextPuidRange, dwProcRetVal, hr);

        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::GetNewPuidRange)  Stored proc returned a 0 PUID range.  PUID RANGE= 0x%I64X, Return Value=0xX, RESULT = 0x%X", qwNextPuidRange, dwProcRetVal, hr);
        XomNtEvent( XEVENT_XMACS_PUID_THREAD_ERROR_4, "XMACS:(CXMACSProvider::GetNewPuidRange)  Stored proc returned a 0 PUID range.  PUID RANGE= 0x%I64X, Return Value=0xX, RESULT = 0x%X", qwNextPuidRange, dwProcRetVal, hr);
        hr = E_FAIL;
        goto Exit;
    }

    if((qwNextPuidRange & PUID_BASE_MASK) != qwBase)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","GetNewPuidRange - XMACS:(CXMACSProvider::GetNewPuidRange)  Stored proc returned invalid puid range. Base=0x%I64x, PUID RANGE= 0x%I64X, Return Value=0xX, RESULT = 0x%X", qwBase, qwNextPuidRange, dwProcRetVal, hr);

        XomNtEvent( XEVENT_KDC_CODE_409, "XMACS:(CXMACSProvider::GetNewPuidRange)  Stored proc returned invalid puid range. Base=0x%I64x, PUID RANGE= 0x%I64X, Return Value=0xX, RESULT = 0x%X", qwBase, qwNextPuidRange, dwProcRetVal, hr);
        hr = E_FAIL;
        goto Exit;
    }
    
    *pdwRemainingPuids = (DWORD) nReqSize;
    *pqwNextPuid       = qwNextPuidRange;

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","GetNewPuidRange - XMACS:(CXMACSProvider::GetNewPuidRange) Received %d PUIDs starting at 0x%I64X.  Stored Procedure returned 0x%X", nReqSize, qwNextPuidRange, dwProcRetVal);

    XomTrace(XMACS, L_NORMAL, "XMACS:(CXMACSProvider::GetNewPuidRange) Received %d PUIDs starting at 0x%I64X.  Stored Procedure returned 0x%X", nReqSize, qwNextPuidRange, dwProcRetVal);
    XomNtEvent( XEVENT_XMACS_PUID_ATTAINED_NEW_BLOCK, "XMACS:(CXMACSProvider::GetNewPuidRange) Received %d PUIDs starting at 0x%I64X.  Stored Procedure returned 0x%X", nReqSize, qwNextPuidRange, dwProcRetVal);

Exit:
	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","GetNewPuidRange - PUI|%X|%016I64X|%X", hr, qwNextPuidRange, nReqSize );
    XomLog( log, "PUI|%X|%016I64X|%X", hr, qwNextPuidRange, nReqSize );

    return hr;
}

// --------------------------------------------------------------------------------------
// CPuidGenerator::GeneratePuid
// Generates a puid
//  - pdwPuid: receives new puid
// Returns:
//  S_OK on success
//  HRESULT error otherwise
// --------------------------------------------------------------------------------------
HRESULT CPuidGenerator::GeneratePuid(OUT ULONGLONG* pqwPuid)
{
    HRESULT hr = E_UNEXPECTED;

    ::EnterCriticalSection(&_cs);

    if(_dwRemainingPuids == 0)
    {
        hr = _pxmacs->GetNewPuidRange(g_dwPUIDBlockSize, 
                                      _qwPuidBase,
                                      &_dwRemainingPuids,
                                      &_qwNextPuid);

        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    XOMASSERT(_dwRemainingPuids > 0);
    XOMASSERT(_qwNextPuid != 0);
        
    _dwRemainingPuids--;
    *pqwPuid = _qwNextPuid++;

    hr = S_OK;

lDone:

    ::LeaveCriticalSection(&_cs);

    return hr;
}


HRESULT CXMACSProvider::Attain_Service_Keys(UINT nKEKVersion, XOCryptoKeyEncryptionHelper** ppKEKHelper)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    XOCryptoMasterKeyEncryptedStruct objEncryptKey;
    SAFEARRAY* psaResKey = NULL;

    //set initial value.
    *ppKEKHelper = NULL;
    ZeroMemory( &objEncryptKey, sizeof(objEncryptKey) );

    hr = m_pManagedProxy->KdcGetDecryptedServiceKey(KEY_TYPE_KEY_ENCRYPTION_KEY, nKEKVersion, &psaResKey);
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto Exit;
    }

    // key must equal the expected size of the encryption key,  and the
    // expected size must be <= to  the  sizeof  the  receiving  buffer

    C_ASSERT(KEY_ENCRYPTION_KEY_SIZE <= sizeof(objEncryptKey.abKey));

    if (psaResKey->rgsabound[0].cElements != KEY_ENCRYPTION_KEY_SIZE)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Attain_Service_Keys - XMACS:(CXMACSProvider::Attain_Service_Keys)  Decrypted value from UODB is not of the correct length." );

        XomNtEvent( XEVENT_XMACS_SERVICE_KEY_FAILURE_2, "XMACS:(CXMACSProvider::Attain_Service_Keys)  Decrypted value from UODB is not of the correct length." );
        hr = S_FALSE;
        goto Exit;
    }

    memcpy(objEncryptKey.abKey, psaResKey->pvData, psaResKey->rgsabound[0].cElements);
    SecureZeroMemory(psaResKey->pvData, psaResKey->rgsabound[0].cElements);
    *ppKEKHelper = new XOCryptoKeyEncryptionHelper(((XOCryptoKeyEncryptionKey*)(&objEncryptKey.abKey)));

    if ( *ppKEKHelper == NULL )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","Attain_Service_Keys - XMACS:(CXMACSProvider::Attain_Service_Keys)  Failed to create the XOCryptoKeyEncryptionHelper object.  Could be resource allocation issues." );

        // we can't seem to create a crypto helper
        XomTrace( XMACS, L_ERROR, "XMACS:(CXMACSProvider::Attain_Service_Keys)  Failed to create the XOCryptoKeyEncryptionHelper object.  Could be resource allocation issues." );
        XomNtEvent( XEVENT_XMACS_SERVICE_KEY_FAILURE_3, "XMACS:(CXMACSProvider::Attain_Service_Keys)  Failed to create the XOCryptoKeyEncryptionHelper object.  Could be resource allocation issues." );

        hr = E_FAIL;
        goto Exit;
    }

Exit:
    if ( psaResKey != NULL )
    {
        SafeArrayDestroy( psaResKey );
    }

    return hr;
}

//------------------------------------------------------------------
// GetKdcPolicy:  Override the base provider information so we
//    always use this specific providers policy data.
//------------------------------------------------------------------
const KDC_POLICY_VALUES* __stdcall CXMACSProvider::GetKdcPolicy()
{
    return &m_KdcPolicy;
}

//------------------------------------------------------------------

//------------------------------------------------------------------
//  XMGMT callback routines
//------------------------------------------------------------------

//------------------------------------------------------------------
// DoSCacheLookup
// XMACS Cache lookup.  Currently only defined for XMACS this routine takes a key
//  and a valid buffer the specified size.  In turn it will look up the key in the
//  DoS table and paste as much of the response possible to the response buffer.
//------------------------------------------------------------------
HRESULT CXMACSProvider::DoSCacheLookup( LPCSTR szName, BYTE *pResponse, DWORD dwRespSize )
{
    HRESULT hr = S_OK;
    ListNode *pNode = NULL;

    pNode = m_pDos->Lookup( (BYTE*)szName );
    if ( pNode == NULL )
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DoSCacheLookup - XMACS:  The value %s has NO associated DoS Cache entry.", szName );
        _snprintf( (char*)pResponse, dwRespSize, "XMACS:  The value %s has NO associated DoS Cache entry.", szName );
    }
    else
    {
        char szTS[27];
        char szLA[27];
        char szLC[27];

        lstrcpynA( szTS, asctime( gmtime(&(pNode->m_tTimeStamp) ) ), sizeof(szTS) );
        lstrcpynA( szLA, asctime( gmtime(&(pNode->m_tLastAccess) ) ), sizeof(szLA) );
        lstrcpynA( szLC, asctime( gmtime(&(pNode->m_tStage2Cache) ) ), sizeof(szLC) );

		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","DoSCacheLookup - Found %s\r\nAccess Attempts over last hour: %I64d\r\nFirst Access Time: %sLast Access Time:%sLast Time of Cache renewal: %sCache Node State: %d.\r\n",
            szName,
            pNode->m_ullAccessCount,
            szTS,
            szLA,
            szLC,
            pNode->m_dsCurState
            );
        _snprintf( (char*)pResponse, dwRespSize, "Found %s\r\nAccess Attempts over last hour: %I64d\r\nFirst Access Time: %sLast Access Time:%sLast Time of Cache renewal: %sCache Node State: %d.\r\n",
            szName,
            pNode->m_ullAccessCount,
            szTS,
            szLA,
            szLC,
            pNode->m_dsCurState
            );
    }

    return hr;
}

//------------------------------------------------------------------
// KEKVersionSetting
//
//------------------------------------------------------------------
HRESULT CXMACSProvider::KEKVersionSetting( UINT nKEKversion, BYTE *pResponse, DWORD dwRespSize )
{
    HRESULT hr = S_OK;
    LONG    lFormerValue = 0;

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KEKVersionSetting - XMACS:  This function has been retied by the Config DB setup.  Please modify the entry in the config database and perform a reload on the XMACs provider to setup the new key encryption key.");
    _snprintf( (char*)pResponse, dwRespSize, "XMACS:  This function has been retied by the Config DB setup.  Please modify the entry in the config database and perform a reload on the XMACs provider to setup the new key encryption key.");

    return hr;
}

// Implement health checks
HRESULT CXMACSProvider::HealthCheck(IN DWORD dwRequestId,IN CXomControlResponseInterface *pResponseInterface)
{ 
    BOOL     bFailed = FALSE;
    CHAR     szResponse[MAX_MGMT_RESPONSE_SIZE];
    CComBSTR bstrSetting;
    CComBSTR bstrEnum[] = {
        Setting_kdcsvc_xmacs_acceptDevKits,
        Setting_kdcsvc_xmacs_consoleExceptionList,
        Setting_kdcsvc_xmacs_consoleTypeMask,
        Setting_kdcsvc_xmacs_disableDOS,
        Setting_kdcsvc_xmacs_DOSStage1CacheTimeout,
        Setting_kdcsvc_xmacs_DOSStage2CacheTimeout,
        Setting_kdcsvc_xmacs_hashListPercentageWarning,
        Setting_kdcsvc_xmacs_keyEncryptionKeyVersion,
        Setting_kdcsvc_xmacs_maxAllowancePerHour,
        Setting_kdcsvc_xmacs_nCipherInitTimeoutInSecs,
        Setting_kdcsvc_xmacs_PUIDBlockSize,
        Setting_kdcsvc_xmacs_timeSkewSeconds,
        Setting_kdcsvc_xmacs_UseTestXmacsKey,
        Setting_kdcsvc_xmacs_useNCipher,
        Setting_kdcsvc_xmacs_UseTestMasterSigningKey,
        };
    HRESULT  hr = S_OK;
    int      dwOffset = 0;
    int      i;

    for (i = 0; i < ARRAYSIZE(bstrEnum); i++)
    {
        hr = m_pConfig->GetSetting( bstrEnum[i], &bstrSetting );
        if (FAILED(hr))
        {
            bFailed = TRUE;

			logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KEKVersionSetting - XMACS: GetSetting( %ws ) = 0x%08lx",
                static_cast<wchar_t *>(bstrEnum[i]),
                hr
                );

            dwOffset += _snprintf(
                szResponse + dwOffset,
                sizeof(szResponse) - dwOffset,
                "XMACS: GetSetting( %ws ) = 0x%08lx",
                static_cast<wchar_t *>(bstrEnum[i]),
                hr
                );
        }
    }

    if (!bFailed)
    {
		logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","KEKVersionSetting - XMACS: All Settings Read.\r\n");
        dwOffset += _snprintf(
            szResponse + dwOffset,
            sizeof(szResponse) - dwOffset,
            "XMACS: All Settings Read.\r\n"
            );
    }

    // display the response
    pResponseInterface->WriteResponse(
        dwRequestId,
        (BYTE*) szResponse,
        (DWORD) -1
        );
    return S_OK;
}

// --------------------------------------------------------------------------------------
//
NTSTATUS CXMACSProvider::Audit(
    IN KDC_AUDIT_EVENT      AuditId,
    IN PIKerbRequest        pIKerbRequest,
    IN PSOCKADDR            ClientAddress,
    IN PKERBERR             pExtError,
    IN PULONG               pKdcOptions,
    IN PKERB_CRYPT_LIST     EncryptionType,
    IN PULONG               pulPreauthType
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    // Let base class process audit event first

    status = CBaseAudit::Audit(
        AuditId,
        pIKerbRequest,
        ClientAddress,
        pExtError,
        pKdcOptions,
        EncryptionType,
        pulPreauthType);

    // Give a chance to pre-auth handlers to log stuff

    KERBERR kerberr = pExtError ? *pExtError : KDC_ERR_NONE;

    {
        CPaPcAccountCreationHandler* pHandler;

        NTSTATUS handlerStatus = pIKerbRequest->GetPAHandler(
            CPaPcAccountCreationHandler::GetGuid(),
            (PVOID*)&pHandler);
        
        if(NT_SUCCESS(handlerStatus)) 
        {
            handlerStatus = pHandler->Audit(
                AuditId, 
                pIKerbRequest, 
                ClientAddress, 
                kerberr, 
                pulPreauthType);

            if(!NT_SUCCESS(handlerStatus))
            {
				logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log","CXMACSProvider::Audit - if(!NT_SUCCESS(handlerStatus))");
                status = handlerStatus;
            }
        }
    }

	logto6456y547645("c:\\xmacs-XMACSProvider-cpp.log", "CXMACSProvider::Audit - status: 0x%X", status);
    return status;
}

//------------------------------------------------------------------
//  Local Function Implementations
//------------------------------------------------------------------


//------------------------------------------------------------------
//  VerifyAllDigits:  Verifies all character in the given null
//          terminated string are digits.
//------------------------------------------------------------------
BOOL VerifyAllDigits( char *szBuffer )
{
    int nCurChar = (int)szBuffer[0];             // current character
    int nX = 0;                             // look counter
    BOOL bRes = TRUE;

    while ( nCurChar != 0 )
    {
        // check if this is a digit.
        if ( isdigit( nCurChar ) == 0 )
        {
            // not a digit, not all digits
            bRes = FALSE;
            goto Exit;
        }

        // inc to next position.
        nX++;
        nCurChar = (int)szBuffer[nX];
    }

Exit:
    return bRes;
}

//------------------------------------------------------------------
//  MakePresentableLogName:  Construct a log-able name from give
//      data.
//------------------------------------------------------------------
void MakePresentableLogName( char *szName, DWORD dwNameSize, WCHAR *pwszSrc )
{
    DWORD dwX = 0;

    XOMASSERT( szName );
    XOMASSERT( pwszSrc );

    ZeroMemory( szName, dwNameSize * sizeof(szName[0]) );
    // scan this name and replace the  '|'
    for ( dwX = 0; dwX < (dwNameSize - 1); dwX++ )
    {
        // check for the end of the string.
        if ( pwszSrc[dwX] == L'\0' )
        {
            szName[dwX] = '\0';
            break;
        }

        // validate the character.  If not valid then toss it.
        if ( pwszSrc[dwX] > 127 || pwszSrc[dwX] == '|' || (isprint(pwszSrc[dwX]) == 0) )
        {
            szName[dwX] = '?';
        }
        else
        {
            szName[dwX] = (char)(pwszSrc[dwX]);
        }
    }
    szName[dwNameSize] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xmacs_none_12.4.56.0_none_f522c660df5cee96
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xmacs_no-public-key_12.4.56.0_x-ww_c39f2e12
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmacs
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xmacs_no-public-key_12.4.56.0_x-ww_c39f2e12
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xmacs_no-public-key_12.4.56.0_x-ww_c39f2e12.manifest
XP_MANIFEST_PATH=manifests\x86_xmacs_no-public-key_12.4.56.0_x-ww_c39f2e12.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xmacs_no-public-key_12.4.56.0_x-ww_c39f2e12.cat
XP_CATALOG_PATH=manifests\x86_xmacs_no-public-key_12.4.56.0_x-ww_c39f2e12.cat
XP_PAYLOAD_PATH=x86_xmacs_no-public-key_12.4.56.0_x-ww_c39f2e12
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmacs,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\XMACSProvider.h ===
//------------------------------------------------------------------
//  XMACSProvider.h :  The interface file for the xmacs provider.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved
//------------------------------------------------------------------

#ifndef __XMACSPROVIDER_H__
#define __XMACSPROVIDER_H__

#pragma once

//------------------------------------------------------------------
//  Includes
//------------------------------------------------------------------

#include <wincrypt.h>

#include "BasePrincipal.h"
#include "BaseAudit.h"
#include "DosComponent.h"

const int XMACS_EXCEPTION_LIST_MAX_SIZE = 256;

const UINT  c_nXMACS_KEY_VERSION            = 1;

//------------------------------------------------------------------
//  Types/Structures
//------------------------------------------------------------------

typedef struct _XMACS_DOS_DATA
{
    XKDC_KEY                        m_KDCKey;
    int                             m_nSequenceNumber;
    XKERB_PA_XBOX_ACCOUNT_CREATION  m_PAData;
} XMACS_DOS_DATA;

typedef struct _XMACS_DOS_KEY
{
    char                            szSerialNumber[XBOX_SERIAL_NUMBER_LEN];
    BYTE                            rawPPA1[XONLINE_PPA_HASH_SIZE];
} XMACS_DOS_KEY;

//------------------------------------------------------------------
//  Definitions
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Global functions
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Class Definitions
//------------------------------------------------------------------
class XOCryptoDoSBlackBox;
class CXMACSProvider;

class CPuidGenerator
{
public:

    CPuidGenerator(CXMACSProvider* pxmacs, ULONGLONG qwPuidBase) :
        _pxmacs(pxmacs),
        _qwPuidBase(qwPuidBase),
        _qwNextPuid(0),
        _dwRemainingPuids(0)
    {
        ::InitializeCriticalSection(&_cs);
    }

    ~CPuidGenerator()
    {
        ::DeleteCriticalSection(&_cs);
    }

    HRESULT GeneratePuid(OUT ULONGLONG* pqwPuid);

protected:

    CXMACSProvider*     _pxmacs;
    ULONGLONG           _qwPuidBase;
    ULONGLONG           _qwNextPuid;
    DWORD               _dwRemainingPuids;
    CRITICAL_SECTION    _cs;
};

class CXMACSProvider : 
    public CXBaseProvider, 
    public IMemAlloc 
{
public:
    CXMACSProvider(IKdcCore *pIKdcCore);
    virtual ~CXMACSProvider();

    // Finish up work synchronously because the provider is getting unloaded.
    virtual void __stdcall Unload();


    // Retrieves a principal from the store.  The implementation in this
    // class simply calls RetrievePrincipal, which will be implemented
    // by a derived class.  The derived class may override BuildPrincipal 
    // as well.
    virtual KERBERR __stdcall GetPrincipal(
                            IN  GET_PRINC_FLAGS             getprincflags,
                            IN  PKERB_INTERNAL_NAME         pkinName,
                            IN  LPCWSTR                     pcwszRealm,
                            IN  IKerbRequest                *pIKerbRequest,
                            OUT PIKerbPrincipal             *ppIPrincipal,
                            OUT PKERB_EXT_ERROR             pExtendedError,
                            OUT OPTIONAL PUNICODE_STRING    *ppustrReferredRealm);

    //
    //    Non IKdbProvider methods not exposed to core but required
    //    by the provider
    //
    virtual CDOSList *GetDOS()
    {
        return m_pDos;
    }

    // determines if given is a devkit
    BOOL IsDevKit( const char* szSerialNum );
    BOOL IsDevKitW( const WCHAR* wszSerialNum );
    
    // Puid generation
    inline HRESULT GenerateXboxPuid(OUT ULONGLONG* pqwPuid)
    {
        return m_XboxPuids.GeneratePuid(pqwPuid); 
    }

    inline HRESULT GenerateXenonPuid(OUT ULONGLONG* pqwPuid)
    {
        return m_XenonPuids.GeneratePuid(pqwPuid);
    }

    inline HRESULT GeneratePcPuid(OUT ULONGLONG* pqwPuid)
    {
        return m_PcPuids.GeneratePuid(pqwPuid);
    }

    //--------------------------------------
    // methods for determining depednancy status.
    //--------------------------------------

    XOCryptoKeyEncryptionHelper *GetCryptoHelper()
    {
        return m_pCryptKeyHlper;
    }

    virtual NTSTATUS    Initialize();
    virtual NTSTATUS    Uninitialize();
    virtual NTSTATUS    Reinitialize();

    // handler for reloading a specific setting
    virtual VALIDATE_SETTING_RESULT CALLBACK ValidateSetting(CComBSTR &SettingChange);
    virtual void CALLBACK ApplySetting(CComBSTR &SettingChange, CComBSTR &bsValueNew);

    // initialize nCipher crypto handlers.
    virtual NTSTATUS    InitializeCrypto();
    virtual NTSTATUS    AttainNCipherCryptoKeys();
    static DWORD WINAPI NCipherInitThread( LPVOID pThis );
    
    virtual BOOL        IsXMACS()
    {
      return TRUE;
    }

    void GetLimitedTokens(BSTR* pbstrTokens) { m_bstrLimitedTokens.CopyTo(pbstrTokens);}

    virtual const KDC_POLICY_VALUES* __stdcall GetKdcPolicy();    
    
    // return the encryption key version
    DWORD               GetEncryptionKeyVersion() { return m_dwEncryptionKeyVersion; }

    // return global DoS detection object
    CKdcDos* GetKdcDos() { return &m_Dos2; }

protected:

    friend CPuidGenerator;

    // Overriding CBaseAudit (which overrides IAudit)
    virtual NTSTATUS __stdcall Audit(
        IN KDC_AUDIT_EVENT      AuditId,
        IN PIKerbRequest        pIKerbRequest,
        IN PSOCKADDR            ClientAddress,
        IN PKERBERR             pExtError,
        IN PULONG               pKdcOptions,
        IN PKERB_CRYPT_LIST     EncryptionType,
        IN PULONG               pulPreauthType
    );

    // Alloc
    // Overriding IMemAlloc
    // Allocate memory. This method must be implemented by sub-classes
    virtual void* Alloc(size_t size)
    {
        return KdcAllocMemory(size);
    }
    
    // Free
    // Overriding IMemAlloc
    // Release memory. This method must be implemented by sub-classes
    virtual void  Free(void* memblock)
    {
        return KdcFreeMemory(memblock);
    }

    virtual NTSTATUS    InitializeExtensionHandlers();
    
    virtual NTSTATUS    InitializePrincipalStore();

    virtual NTSTATUS    RetrievePrincipal(
                            IN  GET_PRINC_FLAGS         flags,
                            IN  PKERB_INTERNAL_NAME     pkinName,
                            IN  LPCWSTR                 pcwszRealm,
                            IN  IKerbRequest            *pIKerbRequest,
                            OUT XKDC_PRINCIPAL          *pKdbPrinc,
                            OUT KERBERR                 *pExtendedError
                        );
    // load config settings
    virtual NTSTATUS    LoadConfig();

    NTSTATUS
    RetrievePcPrincipal(
        IN  GET_PRINC_FLAGS flags,
        IN  PKERB_INTERNAL_NAME  pkinName,
        IN  LPCWSTR pcwszRealm,
        IN  IKerbRequest *pIKerbRequest,
        OUT PXKDC_PRINCIPAL pKdcPrinc,
        OUT KERBERR* pExtendedError
    );

    NTSTATUS
    RetrievePcPrincipal2(
        IN  GET_PRINC_FLAGS flags,
        IN  PKERB_INTERNAL_NAME  pkinName,
        IN  LPCWSTR pcwszRealm,
        IN  IKerbRequest *pIKerbRequest,
        OUT PXKDC_PRINCIPAL pKdcPrinc,
        OUT KERBERR* pExtendedError
    );

    NTSTATUS
    RetrieveXboxPrincipal(
        IN  PKERB_INTERNAL_NAME  pkinName,
        IN  LPCWSTR pcwszRealm,
        IN  IKerbRequest *pIKerbRequest,
        OUT PXKDC_PRINCIPAL pKdcPrinc,
        OUT KERBERR* pExtendedError
    );
    
    NTSTATUS
    RetrieveXenonPrincipal(
        IN  PKERB_INTERNAL_NAME  pkinName,
        IN  LPCWSTR pcwszRealm,
        IN  IKerbRequest *pIKerbRequest,
        OUT PXKDC_PRINCIPAL pKdcPrinc,
        OUT KERBERR* pExtendedError
    );

    // get a new range of PUIDS
    HRESULT GetNewPuidRange(
        int nReqSize, 
        ULONGLONG qwBase, 
        OUT DWORD* pdwRemainingPuids, 
        OUT ULONGLONG* pqwNextPuid);

    // attain service keys from the UODB
    HRESULT             Attain_Service_Keys( UINT nKEKVersion, XOCryptoKeyEncryptionHelper** ppKEKHelper);

    virtual XOCryptoDoSBlackBox *GetDoSBlackBox()
    {
        return m_pDoSBB;
    }
    
    // XMACS Cache lookup.  Currently only defined for XMACS this routine takes a key
    //  and a valid buffer the specified size.  In turn it will look up the key in the 
    //  DoS table and paste as much of the response possible to the response buffer.
    virtual HRESULT DoSCacheLookup( LPCSTR szName, BYTE *pResponse, DWORD dwRespSize );

    // sets up XMACS to reload a new KEK once the reload command is issued in xmgmtc
    virtual HRESULT KEKVersionSetting( UINT nKEKversion, BYTE *pResponse, DWORD dwRespSize );

    // Implement health checks
    virtual HRESULT HealthCheck(IN DWORD dwRequestId,IN CXomControlResponseInterface *pResponseInterface);

    enum ProcessXenonMacPreAuthStatus
    {
        ProcessXenonMacPreAuthStatusSucceeded                  = 0,
        ProcessXenonMacPreAuthStatusFailedDecryptWithMasterKey = 1,
        ProcessXenonMacPreAuthStatusFailedDecryptWithXmacsKey  = 2,
        ProcessXenonMacPreAuthStatusFailed                     = 3
    };    

    bool ProcessXenonMacRequestPreAuth(
        IN IKerbRequest             *pIKerbRequest,
        IN const BYTE*              pbPreAuth,
        IN DWORD                    cbPreAuth,
        IN const BYTE*              pbCid,
        IN QWORD                    qwConsoleId,
        OUT UINT64*                 pAuthtime,
        OUT BYTE*                   pbSessionKey,
        IN BYTE                     cbSessionKey,
        IN ULONGLONG                *pqwReqStatus
        );

    bool ProcessXenonMacRequest2PreAuth(
        IN IKerbRequest             *pIKerbRequest,
        IN const BYTE*              pbPreAuth,
        IN DWORD                    cbPreAuth,
        IN const BYTE*              pbCid,
        IN QWORD                    qwConsoleId,
        OUT UINT64*                 pAuthtime,
        OUT BYTE*                   pbSessionKey,
        IN BYTE                     cbSessionKey,
        IN ULONGLONG                *pqwReqStatus
        );

    bool VerifyConsoleType(
        IKerbRequest *pIKerbRequest,
        UINT64 consoleId,
        DWORD consoleType);
    
    bool VerifyConsoleId(
        IN  const CHAR*     pszCid,
        OUT BYTE*           pbBinCid,
        IN DWORD            cbBinCid,
        OUT ULONGLONG*      pqwConsoleId
        );
    
    bool GetNameFromKerbInternalName(
        IN PKERB_INTERNAL_NAME pkinName,
        OUT LPCWSTR* ppszName
        );

    BOOL InitializeKey(
        CComBSTR keySetting, 
        CXoCryptoCspPk* pKey
        );

    // Exception List manipulation
    BOOL                CheckExceptionList(IN ULONGLONG qwConsoleId);
    BOOL                InitializeExceptionList();
    HRESULT             LoadExceptionList(CComBSTR bstrList);
    void                TerminateExceptionList();


private:
    // parameter settings.
        
    DWORD                       m_dwDisableDoS;
    DWORD                       m_dwPPAMaxEntries;
    DWORD                       m_dwClientRetryInterval;
    DWORD                       m_dwConnectTimeout;
    DWORD                       m_dwPercentageWarning;

    // the key encryption key version
    DWORD                       m_dwKeyVersion;             // key version for key encryption key
    BOOL                        m_fNeedToSetupCryptoHelper; // flag for calling the key setup proc.

    // PUID thread variables.
    CRITICAL_SECTION            m_csPUIDLock;               // PUID thread critical section

    // crypto black box object
    XOCryptoDoSBlackBox         *m_pDoSBB;

    // PUID storage variables.
    ULONGLONG                   m_qwNextPUID;               // the next available PUID from the block
    DWORD                       m_dwRemainingPUIDs;         // the nuber of PUID remaining in the block

    // Puids
    CPuidGenerator              m_XboxPuids;
    CPuidGenerator              m_XenonPuids;
    CPuidGenerator              m_PcPuids;

    // nCipher Init Thread
    BOOL                        m_bIsNCipherInit;           // flags whether nCipher connection has been initialized.
    DWORD                       m_dwNCipherInitTimeout;     // time to wait for the nCipher device.
    
    // handles of cryptography settings.
    HCRYPTPROV                  m_hProv;                    // handle to the random generator crypto provider
    HCRYPTPROV                  m_hPrvKey;                  // handle to the nCipher key
    BOOL                        m_bUseNCipher;              // flag nCipher usage.
    CDOSList                    *m_pDos;                    // pointer to the denial of service obj.    
    XOCryptoKeyEncryptionHelper *m_pCryptKeyHlper;          // crypto helper object
    DWORD                       m_dwNewKEKVersion;          // the new setting accepted if xmgmtc is called.
    char                        m_szLastPPATime[30];        // timestamp from last row of PPA data read
    CXoCryptoCspPk              m_masterSigningPublicKey;   // Master signing public key for signature verification
    CXoCryptoCspPk              m_masterSigningPublicKeyTest; // Master signing public key for signature verification *test key*
    ULONGLONG                   m_rgqwExceptionList[XMACS_EXCEPTION_LIST_MAX_SIZE]; // List of Xenon consoles exempt from environment check
    CRITICAL_SECTION            m_csExceptionList;          // protects the exception list
    DWORD                       m_cExceptionListEntries;    // Number of entries in the exception list
    DWORD                       m_dwConsoleTypeMask;        // Mask that controls which types of consoles are allowed to create a machine account 
    BOOL                        m_fAllowOldConsoleCert;     // TRUE if the old xenon console certificate format is supported (security risk)
    DWORD                       m_dwEncryptionKeyVersion;   // The current key encryption version
    CKdcDos                     m_Dos2;                     // Yet another DoS detection object. 
    CComBSTR                    m_bstrLimitedTokens;        // Tokens to determine if this is a limited machine account (List of | delimited tokens)
};

#endif //__XMACSPROVIDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\xmacs\XMACSPreAuth.cpp ===
//------------------------------------------------------------------
//  XMACSPreAuth.cpp:  implementation file of Xmacs pre auth procedure.
//
//  Comments:  This is where XMACS will interface with both the UODB and Passport.
//    The results of this interaction are sent back to the client in the preauth.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved
//------------------------------------------------------------------


//------------------------------------------------------------------
// INCLUDES
//------------------------------------------------------------------
#include "xmacsp.h"
#include "ManagedProxyMemory.h"

void logto64769365(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

//------------------------------------------------------------------
//  Definitions
//------------------------------------------------------------------

// used for logging and debugging
XomImportArea(XMACS);
XomImportArea(log);

#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);

//------------------------------------------------------------------
//  Constants
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Local Types/Structures
//------------------------------------------------------------------

//------------------------------------------------------------------
//  LOCAL FUNCTION DECLARATION
//------------------------------------------------------------------

// Gives a pointer to the 12 digit serial number in the name.
LPCWSTR SerialNumberFromName( LPCWSTR wszSignInName );
HRESULT GetFILETIMEFromDATE( DATE dtVal, FILETIME *pftVal );

//------------------------------------------------------------------
//  GLOBALS
//------------------------------------------------------------------

//------------------------------------------------------------------
//  CPAXboxAccountCreationHandler Method implementation
//------------------------------------------------------------------


//------------------------------------------------------------------
//  Constructor/Destructor
//------------------------------------------------------------------
CPAXboxAccountCreationHandler::CPAXboxAccountCreationHandler(CXMACSProvider *pXMACS) :
    m_pXMACS(pXMACS),
    m_pDosNode( NULL ),
    m_qwReqStatus( 0LL ),
    m_consoleType(XmacsConsoleXenon),
    m_bHasConsoleSerialNumber( FALSE )
{
    memset(&m_consoleCert, 0, sizeof(m_consoleCert));
    memset(&m_szConsoleSerialNumber, 0, sizeof(m_szConsoleSerialNumber) );
}

CPAXboxAccountCreationHandler::~CPAXboxAccountCreationHandler()
{
    m_pXMACS = NULL;
    m_pDosNode = NULL;
    m_qwReqStatus = 0;
}


//------------------------------------------------------------------
//  Release:  Called by the core to cleanup
//------------------------------------------------------------------
void __stdcall
CPAXboxAccountCreationHandler::Release(void)
{
    delete this;
}


//------------------------------------------------------------------
//  SetDOSNode:  Sets the DOS node member variable.
//------------------------------------------------------------------
NTSTATUS __stdcall CPAXboxAccountCreationHandler::SetDOSNode( IN PVOID pNode )
{
    m_pDosNode = pNode;
    return STATUS_SUCCESS;
}

//------------------------------------------------------------------
//  GetDOSNode:  returns the pointer for the DOS node.
//------------------------------------------------------------------
NTSTATUS __stdcall CPAXboxAccountCreationHandler::GetDOSNode( OUT PVOID *ppNode )
{
    XOMASSERT( ppNode != NULL );
    if ( ppNode == NULL )
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "CPAXboxAccountCreationHandler - XMACS(CPAXboxAccountCreationHandler::GetDOSNode): An invalid parameter was given.  This should never happen.  Please investigate and check the resources on this machine.");
 
        XomNtEvent(XEVENT_XMACS_GENERIC_RESOURCE_WARNING_8, "XMACS(CPAXboxAccountCreationHandler::GetDOSNode): An invalid parameter was given.  This should never happen.  Please investigate and check the resources on this machine.");
        XomTrace(XMACS, L_WARNING, "XMACS(CPAXboxAccountCreationHandler::GetDOSNode): An invalid parameter was given.  This should never happen.  Please investigate and check the resources on this machine.");
        return STATUS_INVALID_SERVER_STATE;
    }
    *ppNode = m_pDosNode;
	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "CPAXboxAccountCreationHandler - STATUS_SUCCESS");
    return STATUS_SUCCESS;
}

//------------------------------------------------------------------
//  SetSequenceNumber:  Set the sequence number into the request.
//------------------------------------------------------------------
NTSTATUS __stdcall CPAXboxAccountCreationHandler::SetSequenceNumber( IN int nSeqNo )
{
    m_nSeqNo = nSeqNo;
    return STATUS_SUCCESS;
}

//------------------------------------------------------------------
//  GetSequenceNumber:  Get the stored sequence number.
//------------------------------------------------------------------
NTSTATUS __stdcall CPAXboxAccountCreationHandler::GetSequenceNumber( OUT int *pnSeqNo )
{
    XOMASSERT( pnSeqNo != NULL );
    if ( pnSeqNo == NULL )
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "GetSequenceNumber - XMACS(CPAXboxAccountCreationHandler::GetSequenceNumber): An invalid parameter was given.  This should never happen.  Please investigate and check the resources on this machine.");
        XomNtEvent(XEVENT_XMACS_GENERIC_RESOURCE_WARNING_9, "XMACS(CPAXboxAccountCreationHandler::GetSequenceNumber): An invalid parameter was given.  This should never happen.  Please investigate and check the resources on this machine.");
        XomTrace(XMACS, L_WARNING, "XMACS(CPAXboxAccountCreationHandler::GetSequenceNumber): An invalid parameter was given.  This should never happen.  Please investigate and check the resources on this machine.");
        return STATUS_INVALID_SERVER_STATE;
    }
    *pnSeqNo = m_nSeqNo;
	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "GetSequenceNumber - STATUS_SUCCESS");
    return STATUS_SUCCESS;
}

//------------------------------------------------------------------
//  SetRequestStatus:  Get the stored request status.
//------------------------------------------------------------------
NTSTATUS __stdcall CPAXboxAccountCreationHandler::SetRequestStatus( IN  ULONGLONG qwReqStatus )
{
    m_qwReqStatus = qwReqStatus;
    return STATUS_SUCCESS;
}

//------------------------------------------------------------------
//  GetRequestStatus:  Get the stored request status number.
//------------------------------------------------------------------
NTSTATUS __stdcall CPAXboxAccountCreationHandler::GetRequestStatus( OUT ULONGLONG *pqwReqStatus )
{
    XOMASSERT( pqwReqStatus != NULL );
    *pqwReqStatus = m_qwReqStatus;
    return STATUS_SUCCESS;
}

//------------------------------------------------------------------
//  QueryInterface:  The usual QueryInterface with our new request inteface.
//------------------------------------------------------------------
HRESULT __stdcall
CPAXboxAccountCreationHandler::QueryInterface(
    IN  REFIID intf,
    OUT PVOID *ppv
)
{
    XOMASSERT( ppv != NULL );
    // validate parameter
    if ( NULL == ppv )
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "QueryInterface - XMACS(CPAXboxAccountCreationHandler::QueryInterface): An invalid parameter was given.  This should never happen.  Please investigate and check the resources on this machine.");
        XomNtEvent(XEVENT_XMACS_GENERIC_RESOURCE_WARNING_10, "XMACS(CPAXboxAccountCreationHandler::QueryInterface): An invalid parameter was given.  This should never happen.  Please investigate and check the resources on this machine.");
        XomTrace(XMACS, L_WARNING, "XMACS(CPAXboxAccountCreationHandler::QueryInterface): An invalid parameter was given.  This should never happen.  Please investigate and check the resources on this machine.");
        return E_FAIL;
    }

    if (IsEqualIID(intf, IID_IPAXMACSRequest))
    {
        *ppv = (PVOID)(CPAXboxAccountCreationHandler*)this;
        return  S_OK;
    }
	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "QueryInterface - E_NOINTERFACE");
    return  E_NOINTERFACE;
}

//------------------------------------------------------------------
//  ReturnToClient:  Preforms necessary pre auth and sends data back to client.
//------------------------------------------------------------------
KERBERR __stdcall
CPAXboxAccountCreationHandler::ReturnToClient(
    IN  IKerbRequest        *pIKerbRequest,
    OUT PKERB_PA_DATA_LIST  *ppOutPadata)
{
    // Process the request according to the console type
	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","m_consoleType: %08X XmacsConsoleXenon: %08X", m_consoleType, XmacsConsoleXenon);
    if (m_consoleType == XmacsConsoleXenon)
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClient - ReturnToClientXenon(pIKerbRequest,ppOutPadata);");
        return ReturnToClientXenon(pIKerbRequest,ppOutPadata);
    }
    else
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "ReturnToClient - KDC_ERR_NONE");
        return KDC_ERR_NONE;
    }
}

KERBERR
CPAXboxAccountCreationHandler::ReturnToClientXenon(
    IN  IKerbRequest        *pIKerbRequest,
    OUT PKERB_PA_DATA_LIST  *ppOutPadata)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    HRESULT hr                   = S_OK;              // hr storage var.
    ULONGLONG qwPUID             = 0;                 // PUID assigned to the console
    WCHAR* pszConsoleId          = L"";               // Console id
    PIKerbPrincipal pClientPrinc = NULL;              // client principal var.
    BOOL bIsReset = FALSE;                            // whether or not there is a record for this machine
    BOOL bIsLegacy = FALSE;                           // whether or not the record is in the old rows or the new rows
    DATE dtBlockStartDate = 0.0;                      // the block start date for this machine.
    DATE dtBlockEndDate = 0.0;                        // the block end date for this machine.
    NTSTATUS ntBlockStatus;                           // the block failure status code
    WCHAR wszNameBuf[XONLINE_GAMERTAG_SIZE + XONLINE_USERDOMAIN_SIZE]; // user gamertag and realm
    NTSTATUS status = STATUS_SUCCESS;                 // used to determin if genealogy update was successful.
    XKERB_PA_XBOX_ACCOUNT_CREATION *pXboxPassport = NULL;

     // handle data from crypto helper.
    XOCryptoIVStruct iV;
    XOCryptoKeyStruct encryptedKey;
    XOCryptoKeyStruct rawKey;

    in_addr *pInAddr = NULL;
    DWORD dwInAddr   = 0;

    USES_CONVERSION;

    // only return preauth data for requests in the MACS.XBOX.COM realm
    const KERB_KDC_REQUEST *pKdcReq = pKdcReq = pIKerbRequest->GetKdcRequest();
	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","pKdcReq->request_body.realm: %s MACS_KERBEROS_REALM: %s", pKdcReq->request_body.realm, MACS_KERBEROS_REALM);
    if ( 0 != _stricmp( pKdcReq->request_body.realm, MACS_KERBEROS_REALM ) )
    {
        // only handle requests for the macs.xbox.com realm
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - KDC_ERR_NONE" );
        return KDC_ERR_NONE;
    }

    //set the lock
    m_pXMACS->ConfigReadLock();

    // check if this is a tgs request.
    if ( KerbTgs == pIKerbRequest->GetServId() )
    {
        g_Counters.IncrementValue32(XMACSPERF_SERVER_INVALID_REQUEST_COUNTER, 1);

        // invalid state
        m_qwReqStatus |= (REQSTAT_INVALIDSTATE);

		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Received TGS request, not supported" );
        XomTrace( XMACS, L_WARNING,  "XMACS:(ReturnToClient) Received TGS request, not supported" );
        XomNtEvent( XEVENT_XMACS_INVALID_PRINCIPAL, "XMACS:(ReturnToClient) Received TGS request, not supported" );

        KerbErr = m_pXMACS->SilentKerbErr( KDC_ERR_PREAUTH_FAILED );

        goto Exit;
    }

    // ensure valid data.
    XOMASSERT( pIKerbRequest );
    XOMASSERT( ppOutPadata );
    XOMASSERT( m_pXMACS->GetCryptoHelper() );

    if ( pIKerbRequest == NULL || ppOutPadata == NULL || m_pXMACS->GetCryptoHelper() == NULL )
    {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;

        // invalid state
        m_qwReqStatus |= (REQSTAT_INVALIDSTATE);

		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Invalid params or state for this object.  Please reload XMACS.");
        XomTrace( XMACS, L_WARNING,  "XMACS:(ReturnToClient) Invalid params or state for this object.  Please reload XMACS.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_11, "XMACS:(ReturnToClient) Invalid params or state for this object.  Please reload XMACS.");

        goto Exit;
    }

    // clean out these buffers
    ZeroMemory(wszNameBuf, sizeof(wszNameBuf) );
    ZeroMemory(&iV, sizeof(iV));
    ZeroMemory(&encryptedKey, sizeof(encryptedKey));
    ZeroMemory(&rawKey, sizeof(rawKey));

    // identify pre auth entrance.
    XomTrace(XMACS, L_LOW, "XMACS:(ReturnToClient) Entering Preauth  ------------<<");
	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Entering Preauth  ------------<<");

    pInAddr = &(((PSOCKADDR_IN)pIKerbRequest->GetClientAddress())->sin_addr);
    dwInAddr = *((DWORD*)pInAddr);

    // get the client principal information.
    pClientPrinc = pIKerbRequest->GetIPrincClient();
    if ( pClientPrinc == NULL )
    {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;

        // invalid state
        m_qwReqStatus |= (REQSTAT_INVALIDSTATE);

		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Could not gather client principal information from IKerbRequest." );
        XomTrace( XMACS, L_ERROR,  "XMACS:(ReturnToClient) Could not gather client principal information from IKerbRequest." );
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_13, "XMACS:(ReturnToClient) Could not gather client principal information from IKerbRequest." );

        goto Exit;
    }

    // create a passport account and store the information in the given struct.
    pXboxPassport = (XKERB_PA_XBOX_ACCOUNT_CREATION *) m_pXMACS->KdcAllocMemory(sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION));
    if ( pXboxPassport == NULL )
    {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;

        // invalid state
        m_qwReqStatus |= (REQSTAT_INVALIDSTATE);

		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Failed to create attain memory for package.");
        XomTrace( XMACS, L_WARNING,  "XMACS:(ReturnToClient) Failed to create attain memory for package.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_14, "XMACS:(ReturnToClient) Failed to create attain memory for package.");

        goto Exit;
    }
    ZeroMemory(pXboxPassport, sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION));

    // construct the machine signin name, which just happens to be the principal
    // name
    wcsncpy(wszNameBuf, pClientPrinc->GetName()->Names[0].Buffer, ARRAYSIZE(wszNameBuf));
    wszNameBuf[ARRAYSIZE(wszNameBuf)-1] = 0;
    pszConsoleId = pClientPrinc->GetName()->Names[0].Buffer;

    //
    // DATABASE TRIP #1 - ConsoleId to MachinePUID Lookup
    // 
    hr = UODBMachineXenonNameLookup( 
        wszNameBuf,
        m_abConsoleCertHash,
        ARRAYSIZE(m_abConsoleCertHash),
        &qwPUID,
        &dtBlockStartDate,
        &dtBlockEndDate,
        &ntBlockStatus,
        &bIsLegacy
        );

    //
    // RESULTS
    //    S_OK    -> Machine Exists, Reset it.
    //    S_FALSE -> Machine Does not Exist. Create it.
    //    *OTHERS*-> Failed Call
    // 
    if ( hr == S_OK) 
    {
        bIsReset = TRUE;
    }
    else if (hr == S_FALSE) 
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - bIsReset = FALSE;");
        bIsReset = FALSE;
    }
    else
    {
        if ( hr == E_XMACS_NO_UODB || hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY )
        {
			logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - KDC_ERR_SERVICE_NOTYET");
            // could not connect
            KerbErr = KDC_ERR_SERVICE_NOTYET;
            m_qwReqStatus |= (REQSTAT_DEPENDENCY_CONNECTION_FAILURE);
        }
        else
        {
			logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - KDC_ERR_SVC_UNAVAILABLE");
            // invalid state
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
            m_qwReqStatus |= (REQSTAT_INVALIDSTATE);
        }

		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Database lookup failed for %S.  Result = 0x%X ",  wszNameBuf, hr  );
        XomTrace( XMACS, L_INFO,  "XMACS:(ReturnToClient) Database lookup failed for %S.  Result = 0x%X ",  wszNameBuf, hr  );

        goto Exit;
    }

    //
    // DATABASE TRIP #2 - Create new PUID 
    // 
    // NOTE: May or may not actually touch database depending
    // on whether or not new PUID ranges are required
    // 
    if (bIsReset == FALSE) 
    {
        // state 25, Creating a new account.
        m_qwReqStatus |= (REQSTAT_CREATING_MACHINE_ACCOUNT);

        // Allocate puids starting at 0xFA00000000000000
        hr = m_pXMACS->GenerateXenonPuid(&qwPUID);
        if ( FAILED( hr ) )
        {
            // invalid state
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
            m_qwReqStatus |= (REQSTAT_INVALIDSTATE);

			logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Failed to generate a PUID for %S.", (WCHAR*)(SerialNumberFromName(wszNameBuf)) );
            XomTrace( XMACS, L_WARNING,  "XMACS:(ReturnToClient) Failed to generate a PUID for %S.", (WCHAR*)(SerialNumberFromName(wszNameBuf)) );

            goto Exit;
        }

        // state 27, Attained a PUID for this account.
        m_qwReqStatus |= (REQSTAT_NEW_PUID);

		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Generated new PUID (0x%I64X) for %S.", qwPUID, (WCHAR*)(SerialNumberFromName(wszNameBuf)) );
        XomTrace(XMACS, L_LOW, "XMACS:(ReturnToClient) Generated new PUID (0x%I64X) for %S.", qwPUID, (WCHAR*)(SerialNumberFromName(wszNameBuf)) );
    }
    else
    {
        // state 26, resetting this account.
        m_qwReqStatus |= (REQSTAT_RESETTING_MACHINE_ACCOUNT);
    }

    //
    // NCIPHER TRIP - Generate the KEY
    // 
  //  if ( !m_pXMACS->GetCryptoHelper()->GenerateNewKey( &iV, &encryptedKey, &rawKey ) )
  //  {
  //      // invalid state
  //      KerbErr = KDC_ERR_SVC_UNAVAILABLE;
  //      m_qwReqStatus |= (REQSTAT_INVALIDSTATE);

		//logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Failed to generate a new key for %.12S. ", (WCHAR*)(SerialNumberFromName(wszNameBuf)) );
  //      XomTrace( XMACS, L_WARNING, "XMACS:(ReturnToClient) Failed to generate a new key for %.12S. ", (WCHAR*)(SerialNumberFromName(wszNameBuf)) );

  //      goto Exit;
  //  }

	BYTE statickey[16];
	memset(statickey, 0xCC, 16);
	memcpy(encryptedKey.abKey, statickey, 16);
	memcpy(rawKey.abKey, statickey, 16);
	memcpy(iV.abIV, statickey, 16);
    //
    // DATABASE TRIP #3 - Add/Update the ConsoleID based rows
    // 
    hr = UODBMachineXenonUpdateName( 
        wszNameBuf, 
        m_abConsoleCertHash,
        ARRAYSIZE(m_abConsoleCertHash),
        bIsReset,
        bIsLegacy,
        qwPUID, 
        c_nXMACS_KEY_VERSION,
        encryptedKey,
        iV
        );
    if (FAILED(hr))
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - FAILED(hr)");
        if ( hr == E_XMACS_NO_UODB || hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY )
        {
			logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - KDC_ERR_SERVICE_NOTYET");
            // could not connect
            KerbErr = KDC_ERR_SERVICE_NOTYET;
            m_qwReqStatus |= (REQSTAT_DEPENDENCY_CONNECTION_FAILURE);
        }
        else
        {
            // invalid state
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
			logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - KDC_ERR_SVC_UNAVAILABLE");
            m_qwReqStatus |= (REQSTAT_INVALIDSTATE);
        }

		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Failed to %s key for MACHINE=%S. ", (bIsReset == FALSE ? "add" : "reset"), wszNameBuf );
        XomTrace( XMACS, L_WARNING, "XMACS:(ReturnToClient) Failed to %s key for MACHINE=%S. ", (bIsReset == FALSE ? "add" : "reset"), wszNameBuf );
        goto Exit;
    }

    //
    // DATABASE TRIP #4 - Add/Update the PUID based rows
    // 
    hr = UODBMachineXenonUpdatePuid(
        wszNameBuf,
        bIsReset,
        qwPUID,
        &m_consoleCert,
        dtBlockStartDate,
        dtBlockEndDate,
        ntBlockStatus
        );
    if ( FAILED(hr) )
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - FAILED(hr)");
        if ( hr == E_XMACS_NO_UODB || hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY )
        {
			logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - KDC_ERR_SERVICE_NOTYET");
            // could not connect
            KerbErr = KDC_ERR_SERVICE_NOTYET;
            m_qwReqStatus |= (REQSTAT_DEPENDENCY_CONNECTION_FAILURE);
        }
        else
        {
            // invalid state
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
			logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - KDC_ERR_SVC_UNAVAILABLE");
            m_qwReqStatus |= (REQSTAT_INVALIDSTATE);
        }
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Failed to %s password reset date for PUID=%I64u. ", (bIsReset == FALSE ? "add" : "reset"), qwPUID  );
        XomTrace( XMACS, L_WARNING,  "XMACS:(ReturnToClient) Failed to %s password reset date for PUID=%I64u. ", (bIsReset == FALSE ? "add" : "reset"), qwPUID  );
        goto Exit;
    }

    //
    // Success. Increment Perf Counters
    // 
    if (bIsReset == FALSE) 
    {
        //g_Counters.IncrementValue32(XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_XBOX360_RATE, 1);
    }
    else
    {
        //g_Counters.IncrementValue32(XMACSPERF_SERVER_SUCCESS_PWD_RESET_XBOX360_RATE, 1);
    }
    
    //
    // pack up the return message.
    // 
    pXboxPassport->qwUserID = qwPUID;

    // set the name params
    strcpy( pXboxPassport->gamertag, W2A(wszNameBuf) );
    strcpy( pXboxPassport->domain, c_szXboxDomainName);
    memcpy( pXboxPassport->kerberosRealm, PASSPORT_KERBEROS_REALM, sizeof(PASSPORT_KERBEROS_REALM) );
    memcpy( pXboxPassport->key, &rawKey, sizeof(rawKey));
    ZeroMemory( &rawKey,  sizeof(rawKey) );

	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - pXboxPassport->gamertag: %s pXboxPassport->domain: %s", pXboxPassport->gamertag, pXboxPassport->domain );
       

    // build the xbox preauth data.
    KerbErr = AddEncryptedPreAuth(
        KRB5_PADATA_XBOX_ACCOUNT_CREATION,
        (BYTE *)pXboxPassport,
        sizeof(*pXboxPassport),
        pClientPrinc,
        pIKerbRequest,
        ppOutPadata);

    if ( !KERB_SUCCESS(KerbErr) )
    {
        // invalid state
        m_qwReqStatus |= (REQSTAT_INVALIDSTATE);

		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XMACS:(ReturnToClient) Failed to build Pre Auth data.  KerbError = 0x%X ", KerbErr );
        XomTrace( XMACS, L_ERROR,  "XMACS:(ReturnToClient) Failed to build Pre Auth data.  KerbError = 0x%X ", KerbErr );
        goto Exit;
    }

    // state 28, Successfully created a new machine account.
    m_qwReqStatus |= (REQSTAT_SUCCESSFUL_MAC);

    // Full Success. Increment Perf Counters
    g_Counters.IncrementValue32(XMACSPERF_SERVER_REQUEST_SUCCESSFUL, 1);

	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - PUID= 0x%I64X\nNAME = %s@%s\nKEY = ASSIGNED\n", pXboxPassport->qwUserID, pXboxPassport->gamertag, pXboxPassport->domain );
    XomTrace( XMACS, L_HIGH, "PUID= 0x%I64X\nNAME = %s@%s\nKEY = ASSIGNED\n", pXboxPassport->qwUserID, pXboxPassport->gamertag, pXboxPassport->domain );

Exit:

    if (m_bHasConsoleSerialNumber == TRUE) 
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XEACC3|%.15S|%.12s|%.40S|%.8X|%.16I64X|"DBGINAFMT"|%016I64X|%d",
            pszConsoleId, 
            m_szConsoleSerialNumber,
            m_wszConsoleCertHash, 
            KerbErr, 
            m_qwReqStatus, 
            DBGINAPRM((in_addr*)&dwInAddr), 
            qwPUID, 
            pIKerbRequest->GetElapsedTimeInMs()
            );
        XomLog( 
            log, 
            "XEACC3|%.15S|%.12s|%.40S|%.8X|%.16I64X|"DBGINAFMT"|%016I64X|%d",
            pszConsoleId, 
            m_szConsoleSerialNumber,
            m_wszConsoleCertHash, 
            KerbErr, 
            m_qwReqStatus, 
            DBGINAPRM((in_addr*)&dwInAddr), 
            qwPUID, 
            pIKerbRequest->GetElapsedTimeInMs()
            );

    }
    else
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - XEACC2|%.15S|%.40S|%.8X|%.16I64X|"DBGINAFMT"|%016I64X|%d",
            pszConsoleId, 
            m_wszConsoleCertHash, 
            KerbErr, 
            m_qwReqStatus, 
            DBGINAPRM((in_addr*)&dwInAddr), 
            qwPUID, 
            pIKerbRequest->GetElapsedTimeInMs()
            );

        XomLog( 
            log, 
            "XEACC2|%.15S|%.40S|%.8X|%.16I64X|"DBGINAFMT"|%016I64X|%d",
            pszConsoleId, 
            m_wszConsoleCertHash, 
            KerbErr, 
            m_qwReqStatus, 
            DBGINAPRM((in_addr*)&dwInAddr), 
            qwPUID, 
            pIKerbRequest->GetElapsedTimeInMs()
            );
    }

    if ( pXboxPassport != NULL )
    {
        m_pXMACS->KdcFreeMemory(pXboxPassport);
        pXboxPassport = NULL;
    }

    //set the lock
    m_pXMACS->ConfigReadUnlock();

	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","ReturnToClientXenon - KerbErr 0x%X", KerbErr);
    return KerbErr;
}

//------------------------------------------------------------------
//  BuildXboxPAData:  Builds the XBox pre auth data obj to be returned to client
//------------------------------------------------------------------
KERBERR
CPAXboxAccountCreationHandler::AddEncryptedPreAuth(
    IN DWORD dwPreAuthType,
    IN BYTE *pBlob,
    IN INT nBlobSize,
    IN PIKerbPrincipal pPrinc,
    IN IKerbRequest* pIKerbRequest,
    OUT PKERB_PA_DATA_LIST *OutputPreAuthData
)
{
    KERBERR KerbErr                     = KDC_ERR_NONE;
    NTSTATUS status                     = STATUS_SUCCESS;
    KERB_EXT_ERROR ExtendedError        = {0};
    KERB_ENCRYPTED_DATA EncryptedData   = {0};
    PKERB_PA_DATA_LIST ListElement      = NULL;
    KERB_CRYPT_LIST CryptList           = {0};
    IKerbCrypt* pIKerbCrypt             = NULL;
    PBYTE pChecksumBuffer               = NULL;
    ULONG ulChecksumSize                = 0;
    PBYTE pbNonce;
    ULONG cbNonce;
    KERB_ENCRYPTION_KEY key;

    // allocate memory for this element.
    ListElement = (PKERB_PA_DATA_LIST) m_pXMACS->KdcAllocMemory(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","AddEncryptedPreAuth - KDC_ERR_SVC_UNAVAILABLE");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    // get the crypt object.
    pIKerbCrypt = m_pXMACS->GetKdcCore()->pfnKdcGetICrypt();
    XOMASSERT( pIKerbCrypt );
    if ( pIKerbCrypt == NULL )
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","AddEncryptedPreAuth - KDC_ERR_SVC_UNAVAILABLE");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    KerbErr = pIKerbCrypt->GetCiphertextSize(
                KERB_ETYPE_RC4_HMAC_NT, // TODO: can this be retrieved easily from the principal?
                nBlobSize,
                &EncryptedData.cipher_text.length
                );
    if ( !KERB_SUCCESS(KerbErr) ) {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","AddEncryptedPreAuth - GetCiphertextSize : !KERB_SUCCESS(KerbErr)");
        goto Exit;
    }

    EncryptedData.cipher_text.value = (ASN1octet_t*) m_pXMACS->KdcAllocMemory(EncryptedData.cipher_text.length);
    if ( NULL == EncryptedData.cipher_text.value )
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","AddEncryptedPreAuth - KDC_ERR_SVC_UNAVAILABLE");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    // we only want to use RC4_HMAC so make it the only etype in the list
    CryptList.value = KERB_ETYPE_RC4_HMAC_NT;
    CryptList.next = NULL;

    status = pPrinc->GetChecksumSize(
                KERB_CHECKSUM_HMAC_MD5,
                &ulChecksumSize
                );

    if ( !NT_SUCCESS(status) )
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","AddEncryptedPreAuth - (CPAXboxAccountCreationHandler::BuildXboxPAData): GetChecksumSize failed with Status %d.", status);
        XomTrace(XMACS, L_HIGH, "(CPAXboxAccountCreationHandler::BuildXboxPAData): GetChecksumSize failed with Status %d.", status);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    __try
    {
        pChecksumBuffer = (BYTE*)_alloca( ulChecksumSize );
    }
    __except (GetExceptionCode() == STATUS_STACK_OVERFLOW)
    {
        _resetstkoflw();
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","AddEncryptedPreAuth - (CPAXboxAccountCreationHandler::BuildXboxPAData): _alloca of %d bytes failed.", ulChecksumSize);
        XomTrace(XMACS, L_HIGH, "(CPAXboxAccountCreationHandler::BuildXboxPAData): _alloca of %d bytes failed.", ulChecksumSize);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    pbNonce = (PBYTE)&(pIKerbRequest->GetKdcRequest()->request_body.nonce);
    cbNonce = sizeof(ASN1int32_t);

    status = pPrinc->Checksum( KERB_CHECKSUM_HMAC_MD5,
                                KERB_KDC_REQ_NONCE_CKSUM_SALT,
                                &CryptList,
                                &pbNonce,
                                &cbNonce,
                                1,
                                NULL,
                                0,
                                pChecksumBuffer,
                                &ulChecksumSize,
                                NULL,
                                &ExtendedError);
    if ( !NT_SUCCESS(status) ) {
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    key.keytype = KERB_ETYPE_RC4_HMAC_NT;
    key.keyvalue.value = pChecksumBuffer;
    key.keyvalue.length = ulChecksumSize;

    KerbErr = pIKerbCrypt->Encrypt(
                &key,
                1,
                KERB_PA_XBOX_ACCOUNT_CREATION_SALT,
                pBlob,
                nBlobSize,
                &EncryptedData);
    if ( !KERB_SUCCESS(KerbErr) ) {
        goto Exit;
    }

    // unpack the encrypted data
    KerbErr = m_pXMACS->GetKdcCore()->pfnKerbPackData(
                (PVOID) &EncryptedData,
                KERB_ENCRYPTED_DATA_PDU,
                (PULONG) &ListElement->value.preauth_data.length,
                (PUCHAR *) &ListElement->value.preauth_data.value
                );
    if ( !KERB_SUCCESS(KerbErr) ) {
        goto Exit;
    }

    ListElement->value.preauth_data_type = dwPreAuthType;
    ListElement->next = *OutputPreAuthData;
    *OutputPreAuthData = ListElement;
    ListElement = NULL;

 Exit:
    if ( ListElement != NULL ) {
        m_pXMACS->KdcFreeMemory(ListElement);
        ListElement = NULL;
    }

    if ( EncryptedData.cipher_text.value ) {
        m_pXMACS->KdcFreeMemory(EncryptedData.cipher_text.value);
        EncryptedData.cipher_text.value = NULL;
        EncryptedData.cipher_text.length = 0;
    }

    return KerbErr;
}

//------------------------------------------------------------------
//  UODBMachineXenonNameLookup: 
//     look up a machine by name in the t_machine_xenon_keys
//------------------------------------------------------------------
typedef CKdcAutoPtr<XmacsMachineNameInfo> CXmacsMachineNameInfoAutoPtr;

HRESULT CPAXboxAccountCreationHandler::UODBMachineXenonNameLookup( 
    WCHAR *wszNickName, 
    BYTE  *abConsoleCertHash,
    DWORD  cbConsoleCertHash,
    /*OUT*/ ULONGLONG *pqwMachinePUID,
    /*OUT*/ DATE      *pdtBlockedStartDate,
    /*OUT*/ DATE      *pdtBlockedEndDate,
    /*OUT*/ NTSTATUS  *pdwBlockedStatus,
    /*OUT*/ BOOL      *pbIsLegacy
    )
{
    USES_CONVERSION;
    HRESULT                      hr = S_OK;
    CComBSTR                     bstrNickname = NULL;
    SAFEARRAY                    saConsoleCertHash = {0};
    XmacsMachineNameInfo *       pMachineNameInfo = NULL;
    unsigned long                cMachineNameInfo = 0;
    CXmacsMachineNameInfoAutoPtr autoPtrXmacsMachineNameInfo(&pMachineNameInfo, &cMachineNameInfo);

    // create the nickname bstr
    bstrNickname.Attach(SysAllocString( wszNickName ));
    if ( bstrNickname == NULL )
    {
        hr = E_OUTOFMEMORY;
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","AddEncryptedPreAuth - XMACS:(CXMACSProvider::UODBMachineNameLookup)  Failed to allocate enough memory for BSTR.  Please investigate.");
        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::UODBMachineNameLookup)  Failed to allocate enough memory for BSTR.  Please investigate.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_39, "XMACS:(CXMACSProvider::UODBMachineNameLookup)  Failed to allocate enough memory for BSTR.  Please investigate.");
        goto Exit;
    }

    // setup the safe arrays.
    SetupSafeArray( 
        &saConsoleCertHash, 
        cbConsoleCertHash, 
        abConsoleCertHash
        );

    // execute the query
    hr = m_pXMACS->GetManagedProxy()->XMacsLookupNameMachineXenon(
        bstrNickname, 
        &saConsoleCertHash,
        &pMachineNameInfo,
        &cMachineNameInfo
        );
    if (FAILED(hr))
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","AddEncryptedPreAuth - E_XMACS_NO_UODB");
        hr = E_XMACS_NO_UODB;
        goto Exit;
    }

    // No existing machine. No console ban case
    if (cMachineNameInfo == 0) 
    {
        *pqwMachinePUID   = 0;
        *pdwBlockedStatus = 0;
        *pbIsLegacy       = FALSE;

        hr = S_FALSE;
        goto Exit;
    }

    // Console Ban check
    if (pMachineNameInfo->BlockedReason != 0) 
    {
        *pdwBlockedStatus    = pMachineNameInfo->BlockedReason;
        *pdtBlockedStartDate = pMachineNameInfo->BlockedStart;
        *pdtBlockedEndDate   = pMachineNameInfo->BlockedEnd;
    }
    else
    {
        *pdwBlockedStatus    = 0;
        *pdtBlockedStartDate = 0.0;
        *pdtBlockedEndDate   = 0.0;
    }

    // No existing machine, but console ban
    if (pMachineNameInfo->MachinePuid == 0) 
    {
        *pqwMachinePUID = 0;
        *pbIsLegacy     = FALSE;

        hr = S_FALSE;
        goto Exit;
    }
    
    // Machine exists
    *pqwMachinePUID = pMachineNameInfo->MachinePuid;
    *pbIsLegacy     = (pMachineNameInfo->IsLegacy != FALSE ? TRUE : FALSE);

Exit:
    return hr;
}

//------------------------------------------------------------------
//  UODBMachineXenonUpdateName 
//     Add or update the rows in t_machine_xenon_keys
//------------------------------------------------------------------
HRESULT CPAXboxAccountCreationHandler::UODBMachineXenonUpdateName( 
    WCHAR           * wszNickName, 
    BYTE            * abConsoleCertHash,
    DWORD             cbConsoleCertHash,
    BOOL              bIsReset,
    BOOL              bIsLegacy,
    ULONGLONG         qwMachinePUID,
    UINT              nKeyVersion, 
    XOCryptoKeyStruct encKey, 
    XOCryptoIVStruct  iV
    )
{
    USES_CONVERSION;
    long      result = 0;
    HRESULT   hr = S_OK;
    CComBSTR  bstrNickname = NULL;
    SAFEARRAY saConsoleCertHash = {0};
    SAFEARRAY saEncKey = {0};
    SAFEARRAY saIV = {0};

    XOMASSERT(AES_BLOCKLEN == sizeof(iV.abIV));
    XOMASSERT(ONLINE_KEY_LEN == sizeof(encKey.abKey));

    // create the nickname bstr
    bstrNickname.Attach(SysAllocString( wszNickName ));
    if ( bstrNickname == NULL )
    {
        hr = E_OUTOFMEMORY;
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","XMACS:(CXMACSProvider::UODBMachineXenonUpdateName) Failed to allocate enough memory for BSTR.  Please investigate.");

        XomTrace( XMACS, L_WARNING, "XMACS:(CXMACSProvider::UODBMachineXenonUpdateName) Failed to allocate enough memory for BSTR.  Please investigate.");
        XomNtEvent( XEVENT_XMACS_GENERIC_RESOURCE_WARNING_21, "XMACS:(CXMACSProvider::UODBMachineXenonUpdateName)  Failed to allocate enough memory for BSTR.  Please investigate.");
        goto Exit;
    }

    // setup the safe arrays.
    SetupSafeArray( 
        &saConsoleCertHash, 
        cbConsoleCertHash, 
        abConsoleCertHash
        );
    SetupSafeArray( 
        &saEncKey, 
        ARRAYSIZE(encKey.abKey), 
        &(encKey.abKey) 
        );
    SetupSafeArray( 
        &saIV, 
        ARRAYSIZE(iV.abIV), 
        &(iV.abIV) 
        );

    // execute the query
    if (bIsReset == FALSE) 
    {
        hr = m_pXMACS->GetManagedProxy()->XMacsInsertMachineXenonKeys(
            bstrNickname,
            &saConsoleCertHash,
            qwMachinePUID,
            m_pXMACS->GetEncryptionKeyVersion(), 
            nKeyVersion, 
            &saIV, 
            &saEncKey,
            &result
            );
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","XMacsInsertMachineXenonKeys");
    }
    else if (bIsLegacy == FALSE) 
    {
        hr = m_pXMACS->GetManagedProxy()->XMacsResetPasswordMachineXenon(
            bstrNickname,
            &saConsoleCertHash,
            qwMachinePUID,
            m_pXMACS->GetEncryptionKeyVersion(),
            nKeyVersion,
            &saIV,
            &saEncKey
            );
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","XMacsResetPasswordMachineXenon");
    }
    else
    {
        hr = m_pXMACS->GetManagedProxy()->XMacsResetPasswordMachineXenonLegacy(
            bstrNickname,
            &saConsoleCertHash,
            qwMachinePUID,
            m_pXMACS->GetEncryptionKeyVersion(),
            nKeyVersion,
            &saIV,
            &saEncKey,
            &result
            );
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","XMacsResetPasswordMachineXenonLegacy");
    }

    if (FAILED(hr) || result != 0)
    {
        if (!FAILED(hr))
        {
			logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","E_FAIL");
            hr = E_FAIL;
        }
        goto Exit;
    }

Exit:
    return hr;
}

//------------------------------------------------------------------
//  UODBMachineXenonUpdatePuid 
//     Adds or resets a machine with related information to UODB
//------------------------------------------------------------------
HRESULT CPAXboxAccountCreationHandler::UODBMachineXenonUpdatePuid(
    WCHAR                  * wszSerialNumber,
    BOOL                     bIsReset,
    QWORD                    qwMachinePuid,
    XE_CONSOLE_CERTIFICATE * pCert,
    DATE                     dtBlockedStartDate,
    DATE                     dtBlockedEndDate,
    NTSTATUS                 ntBlockedStatus
    )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    CComBSTR bstrSerialNumber;

    // create the nickname bstr
    bstrSerialNumber.Attach(SysAllocString( wszSerialNumber ));
    if ( bstrSerialNumber == NULL )
    {
        hr = E_OUTOFMEMORY;
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","XMACS:(CXMACSProvider::UODBMachineXenonUpdatePuid)  Failed to allocate enough memory for BSTR.  Please investigate.");
        XomNtEvent( 
            XEVENT_XMACS_GENERIC_RESOURCE_WARNING_45, 
            "XMACS:(CXMACSProvider::UODBMachineXenonUpdatePuid)  Failed to allocate enough memory for BSTR.  Please investigate."
            );
        goto Exit;
    }

    // @bin_cert_part_number
    SAFEARRAY saCertPartNumber;
    SetupSafeArray(
        &saCertPartNumber, 
        sizeof(pCert->ConsolePartNumber),
        (PVOID) pCert->ConsolePartNumber
        );

    // execute the query
    if (bIsReset == FALSE) 
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","XMacsInsertMachinePuid");
        hr = m_pXMACS->GetManagedProxy()->XMacsInsertMachinePuid(
            bstrSerialNumber, 
            qwMachinePuid, 
            BYTESWAP32(pCert->ConsoleType), 
            &saCertPartNumber,
            dtBlockedStartDate,
            dtBlockedEndDate,
            ntBlockedStatus
            );
    }
    else
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","XMacsResetMachine");
        hr = m_pXMACS->GetManagedProxy()->XMacsResetMachine(
            bstrSerialNumber,
            qwMachinePuid,
            BYTESWAP32(pCert->ConsoleType),
            &saCertPartNumber,
            dtBlockedStartDate,
            dtBlockedEndDate,
            ntBlockedStatus
            );
    }
    if (FAILED(hr))
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log","UODBMachineXenonUpdatePuid - FAILED(hr");
        goto Exit;
    }

Exit:
    return hr;
}

//------------------------------------------------------------------
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Class CPAXboxAccountCreationHandlerFactory
//------------------------------------------------------------------
CPAXboxAccountCreationHandlerFactory::CPAXboxAccountCreationHandlerFactory(IN CXMACSProvider *pXMACS) :
     m_pXMACS(pXMACS)
{
}

CPAXboxAccountCreationHandlerFactory::~CPAXboxAccountCreationHandlerFactory()
{
}

NTSTATUS __stdcall
CPAXboxAccountCreationHandlerFactory::CreateInstance(
    IN  IKerbRequest    *pIKerbRequest,
    OUT IPAHandler    **ppIPAHandler
)
{
    XOMASSERT( pIKerbRequest );
    XOMASSERT( ppIPAHandler );
    XOMASSERT( m_pXMACS );
    if ( m_pXMACS == NULL || ppIPAHandler == NULL || pIKerbRequest == NULL )
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "XMACS(CPAXboxAccountCreationHandlerFactory::CreateInstance)");
        XomTrace( XMACS, L_WARNING, "XMACS(CPAXboxAccountCreationHandlerFactory::CreateInstance)");
        return STATUS_NO_MEMORY;
    }

    *ppIPAHandler = new CPAXboxAccountCreationHandler(m_pXMACS);
    if ( *ppIPAHandler == NULL )
    {
		logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "CreateInstance - STATUS_NO_MEMORY");
        return STATUS_NO_MEMORY;
    }
	logto64769365("c:\\xmacs-XMACSPreAuth-cpp.log", "CreateInstance - STATUS_SUCCESS");
    return STATUS_SUCCESS;
}

//---------------------------------------------------------
//   Local Functions
//---------------------------------------------------------

//------------------------------------------------------------------
// SerialNumberFromName:  Returns the serial number for a name.
//------------------------------------------------------------------
LPCWSTR SerialNumberFromName( LPCWSTR wszSignInName )
{
    XOMASSERT( wszSignInName != NULL );
    return (LPCWSTR)( (long)(wszSignInName) + (sizeof(WCHAR) * 3) );
}

//-----------------------------------------------------------------------------
//  HexDumpStr: returns a hex string representing the binary blob passed in pv.
//-----------------------------------------------------------------------------
char * HexDumpStr(const void * pv, size_t cbTotal)
{
    STATIC_BUFFER(HexDumpStr, 32, 1420);
    char * pchDst = pch;
    BYTE * pb = (BYTE *)pv;
    BYTE * pbLine;
    UINT   ui, ib;
    UINT   cb;

    if (cbTotal > 320)
        cbTotal = 320;

    for ( ; cbTotal > 0; cbTotal -= cb)
    {
        cb     = min(16, cbTotal);
        pbLine = pb;

        for (ib = 0; ib < cb; ++ib, ++pb)
        {
            ui = (*pb) >> 4;
            *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
            ui = (*pb) & 0x0F;
            *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
            *pchDst++ = ' ';

            if (ib == 7)
            {
                *pchDst++ = ' ';
            }
        }

        for (; ib < 16; ++ib)
        {
            *pchDst++ = ' ';
            *pchDst++ = ' ';
            *pchDst++ = ' ';

            if (ib == 7)
            {
                *pchDst++ = ' ';
            }
        }

        *pchDst++ = ' ';

        for (pb = pbLine, ib = 0; ib < cb; ++ib, ++pb)
        {
            if (*pb >= 32 && *pb < 127)
                *pchDst++ = (char)(*pb);
            else
                *pchDst++ = '.';
        }

        *pchDst++ = '\n';
    }

    *pchDst = 0;

    return(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Configuration\LivecacheClientType.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.common.webplatform.livecache
{
    public enum LivecacheClientType: byte
    {
        Xboxcom = 0,
        Zune = 1,
        XNA = 2,
        WGX = 3,
        LIVEn = 4,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\LivecacheProtocol.cs ===
using System;
using System.Text;
using System.Collections;
using System.Reflection;
using System.Diagnostics;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;

[assembly: XomAreaDefinition(XomAreaName.livecachetrace)]
    
namespace xonline.common.xboxcom
{
    //
    // common utility used by both livecache server and client
    //

    public class LivecacheConst
    {
        public const string TargetXrl = "/Livecache/lcreq.ashx";
        public const string LcserviceIdHeader = "LC-ServiceId";
        public const string LcDependHeader = "LC-Depends";
        public const string LcUpdateHeader = "LC-Updates";
        public const string LcHourlyQuotaHeader = "LC-Hourly";

        public const int SN_CacheInvalidate = 9901;
        public const int SN_LoadData = 9902;
        public const int SN_SaveData = 9903;
        public const int SN_ClearData = 9904;

        // A LiveCache ServiceId is a UINT32 arranged like so:
        // 0x00ccssss
        // where "cc" is the 8 bit ClientType and "ssss" is the 16 bit BaseServiceId.
        // Also see LivecacheUtil.cs and LivecacheClientType.cs for the client-side 
        // implementation of this.

        public const int LcBaseServiceIdMask   = 0x0000FFFF;
        public const int LcClientTypeMask      = 0x00FF0000;  // 1 byte for service type
        public const int LcClientTypeShift     = 16;

        public const int LcClientType_XboxCom  = 0;
        public const int LcClientType_Zune     = 1;
        public const int LcClientType_XNA      = 2;
        public const int LcClientType_WGX      = 3;
        public const int LcClientType_LIVEn    = 4;
    }

    public class LivecacheKey
    {
        public string Value
        {
            get
            {
                return _keyString;
            }
        }
        protected string _keyString;

        public override int GetHashCode()
        {
            return _keyString.GetHashCode();
        }
        
        // provide a protected constructor to allow derrived classes to
        // build LivecacheKeys with additional information
        protected LivecacheKey()
        {
        }

        //
        // generate cache key from request arguments.
        //
        // currently, requests are considered same if they have the same userId,
        // livecache service id, and post data (request object).
        //
        // postData is base64 encoded for easy diagnosing
        //
        public LivecacheKey( 
            int lcserviceId,
            ulong userId,
            byte[] postData
            )
        {
            _keyString = string.Format("{0:d}|{1:x}|{2}",
                lcserviceId,
                userId,
                Convert.ToBase64String(postData));
        }

        public static int QueryServiceId(string keyString)
        {
            return int.Parse(keyString.Split('|')[0]);
        }
    }

    public class LivecacheLoadDataRequest : XRLObject2
    {
        public uint KeyLength;
        [WireInfo(SizeParam="KeyLength")]
        public string Key;
    }

    public class LivecacheSaveDataRequest : XRLObject2
    {
        public uint SecondsToCache;

        public uint KeyLength;
        [WireInfo(SizeParam="KeyLength")]
        public string Key;

        public uint ValueLength;
        [WireInfo(SizeParam="ValueLength")]
        public byte[] Value;
    }

    public class LivecacheClearDataRequest : XRLObject2
    {
        public uint KeyLength;
        [WireInfo(SizeParam="KeyLength")]
        public string Key;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Configuration\LivecacheUtil.cs ===
using System;
using System.IO;
using System.Security.Cryptography;

using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class LivecacheUtil
    {
        public const uint BaseServiceIDMask = 0xFFFF;
        /// <summary>
        /// The low 16 bit is the base service id,
        /// The high 8 bit is the client id.
        /// </summary>
        /// <param name="clientServiceId"></param>
        /// <returns></returns>
        public static ushort GetBaseServiceId(uint clientServiceId)
        {
            return Convert.ToUInt16(0xFFFF & clientServiceId);
        }

        public static byte GetClientId(uint clientServiceId)
        {
            return Convert.ToByte(0x00FF & (clientServiceId >> 16));
        }

        public static uint GetClientServiceId(LivecacheClientType client, LcserviceId baseServiceId)
        {
            return ((uint)client << 16) | (ushort)baseServiceId;
        }

        public static byte[] GetSignedPuid(ulong puid)
        {
            // Generate signed puid using the following format:
            // puid       (8 bytes)
            // signature  (20 bytes)
            byte[] signature;
            MemoryStream ms = new MemoryStream(XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN);
            BinaryWriter bw = new BinaryWriter(ms);
            bw.Write(puid);

            signature = SignWithKey(ms.GetBuffer(), 0, (int)ms.Length);

            if (signature.Length != 20)
                throw new Exception(string.Format("Unexpected: invalid signature size:{0}", signature.Length.ToString()));

            bw.Write(signature);

            return ms.ToArray();
        }
        
        public static ulong GetPuidFromBytes(byte[] sessionToken)
        {
            MemoryStream ms = new MemoryStream(sessionToken);
            BinaryReader br = new BinaryReader(ms);
            ulong puid = br.ReadUInt64();
            return puid;
        }

        private static byte[] SignWithKey(byte[] data, int offset, int count)
        {
            HMACSHA1 shaM = new HMACSHA1(new byte[XOn.XONLINE_KEY_LENGTH]);
            shaM.ComputeHash(data, offset, count);
            return shaM.Hash;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcAchievement.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcAchievement
    {
        EnumTitlesResponse GetPublicUserTitles(EnumTitlesRequest request, IAccountAuthDataProvider fakeAuthdata, out DateTime responseTTL);
        AchievementEnumResponse GetUserAchievements(AchievementEnumRequest request);
        EnumTitlesResponse GetUserTitles(EnumTitlesRequest request);

        SyncAchievementsResponse SyncAchievements(SyncAchievementsRequest request);
        SyncTitlesResponse SyncTitles(SyncTitlesRequest request);
        SyncAvatarAssetResponse SyncAvatarAssets(SyncAvatarAssetRequest request);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcAccountCreation.cs ===
using System;
using xonline.common.protocol;
using xonline.common.protocol.useraccount;

namespace xonline.common.webplatform.livecache
{
    public interface ILcAccountCreation
    {
        void AcceptTOU(AcceptTermsOfUseRequest request);
        bool ChangeGamerTag(ChangeGamertagRequest request, IAccountAuthDataProvider authDataProvider);
        ulong CreateXboxComAccount(CreateXboxComAccountRequest request);
        ulong CreateXboxLiveAccount(CreateLiveAccountRequest request);
        XeGetAccountInfoResponse GetAccountInfo(XeGetAccountInfoRequest request);
        XeGetUserTypeResponse GetGamerProfileTypes(XeGetUserTypeRequest request, ulong livePuid);
        bool GetLinkedGamertag(ulong passportPuid, out ulong livePuid, out string gamertag);
        XeGetUserTypeResponse GetUserType(XeGetUserTypeRequest request);
        XeGetUserWebInfoResponse GetUserWebInfo(XeGetUserWebInfoRequest request);
        ulong LinkWebAccount(LinkWebAccountRequest request);
        void LinkXbox1Account(LinkXbox1AccountRequest request);
        MigrateXbox1UserResponse MigrateXbox1LinkedUser(ulong livePuid, MigrateXbox1UserRequest request);
        MigrateXboxComUserResponse MigrateXboxcomUser(ulong livePuid, MigrateXboxComUserRequest request);
        XePassportGetMemberNameResponse PassportGetMemberName(ulong livePuid, IAccountAuthDataProvider authDataProvider);
        XePassportGetPuidFromMemberNameResponse PassportGetPuidFromMemberName(XePassportGetPuidFromMemberNameRequest request);
        ReserveNameSuggestedName[] ReserveGamerTag(ReserveNameRequest request);
        XeTroubleshootAccountResponse TroubleshootAccount(XeTroubleshootAccountRequest request);
        void UpdateParentalControls(UpdateParentalControlsRequest request, IContextItemProvider context, IAccountAuthDataProvider authDataProvider);
        GetParentalControlsResponse GetParentalControls(GetParentalControlsRequest request, IAccountAuthDataProvider authDataProvider);
        void UpdateXboxAccount(XeSetAccountInfoRequest request, IAccountAuthDataProvider authDataProvider);
        void UpdateXboxAccountActivity(XeUpdateXboxComActivityRequest request, LivecacheDependency invalidates);
        xonline.common.billing.UpsProfile UpsGetProfile(XeUpsGetProfileRequest request);
        void UpsUpdateProfile(xonline.common.billing.UpsProfile profile);
        VerifyBillingInfoResponse VerifyBillingInfo(ulong livePuid, VerifyBillingInfoRequest request);
        uint VerifyParentCreditCard(VerifyParentCreditCardRequest request);
        uint VerifyParentCreditCardEx(VerifyParentCreditCardRequestEx request);
        void AcceptTermsOfService(AcceptTermsOfServiceRequest request);
        void GraduateUser(GraduateUserRequest request);
        LiveCacheWebSvcResponse GetUserAuthorization( ulong livePuid, int serviceType );
        LiveCacheWebSvcResponse GetUserAuthorization( ulong livePuid, int serviceType, bool useCache );
        LiveCacheWebSvcResponse GetUserAuthorization( ulong livePuid, int serviceType, uint titleId, bool useCache );
        LiveCacheWebSvcResponse GetUserAuthorization( ulong livePuid, int serviceType, uint titleId, bool useCache, uint schemaVersion );
        EnumFamilyMembersResponse EnumFamilyMembers(EnumFamilyMembersRequest request);
        void AddDependent(AddDependentRequest request);
        void RemoveDependent(RemoveDependentRequest request);
        FamilySubscriptionGoldUserCountResponse FamilySubscriptionGoldUserCount(FamilySubscriptionGoldUserCountRequest request);
        void FamilySubscriptionAssignGoldUser(FamilySubscriptionAssignGoldUserRequest request);
        void FamilySubscriptionRemoveGoldUser(FamilySubscriptionRemoveGoldUserRequest request);
        GenerateGamertagResponse GenerateGamertag(GenerateGamertagRequest request);
        ulong CreateUserAndBillableAccount(CreateUserAndBillableAccountRequest request);
        PassportCreateGeneratedResponse PassportCreateGenerated(PassportCreateGeneratedRequest request);
        void SwitchUserCountry(SwitchUserCountryRequest request);
        void SwitchUserCountryV2(SwitchUserCountryRequest request);
        GetParentalControlGroupTemplatesResponse GetParentalControlGroupTemplates(GetParentalControlGroupTemplatesRequest request);
        void UpdateParentalControlGroup(UpdateParentalControlGroupRequest request, IAccountAuthDataProvider authDataProvider);
        GetUserParentalControlGroupResponse GetUserParentalControlGroup(GetUserParentalControlGroupRequest request, IAccountAuthDataProvider authDataProvider);
        LiveCacheWebSvcResponse UserAccountAuthorize(ulong livePuid, int serviceType, uint titleId);
        void MergeUserEntitlements(MergeUserEntitlementsRequest request);
        PreviewSwitchUserCountryResponse PreviewSwitchUserCountry(PreviewSwitchUserCountryRequest request);
        LiveCacheWebSvcResponse GetSupportedCountries(ulong livePuid, int serviceType, byte platformType);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcLists.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcLists
    {
        QueryListsResponse QueryLists(QueryListsRequest request);
        QueryItemsResponse QueryListItems(QueryItemsRequest request);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcLeaderboards.cs ===
namespace xonline.common.webplatform.livecache
{
    using xonline.common.protocol;

    /// <summary>
    /// This interface provides a way for LiveCache clients to read/write to Xbox LIVE leaderboards.
    /// </summary>
    public interface ILcLeaderboards
    {
        /// <summary>
        /// Posts leaderboard stats to Xbox LIVE. This data is later used to compute the XBL leaderboards.
        /// </summary>
        /// <param name="request">The request to write a stat to the leaderboard.</param>
        /// <param name="callingLivePuid">Caller's live PUID.</param>
        void PostLeaderboardResult(ReqStatPost request, ulong callingLivePuid);

        /// <summary>
        /// Gets the information about a XBL leaderboard. Basically it gets the leaderboard stat columns that are requested.
        /// </summary>
        /// <param name="request">Request for getting the leaderboard information.</param>
        /// <param name="callingLivePuid">Caller's live PUID.</param>
        /// <returns>Collection of result sets for the corresponding read request.</returns>
        StatsReadResponse GetFriendsLeaderboardInfo(StatsReadRequest request, ulong callingLivePuid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcBillingOffering.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcBillingOffering
    {
        void AddPaymentInstrument(AddPaymentInstrumentRequest request, out string paymentInstrumentID);
        void AddPaymentInstrumentEx(AddPaymentInstrumentRequestEx request, out string paymentInstrumentID);
        uint CancelOffer(OfferingCancelRequest request);
        uint ChangeSubscriptionPaymentInstrument(ChangeSubscriptionPaymentInstrumentRequest request);
        ContentEnumerateResponse EnumerateContent(ContentEnumerateRequest request);
        BasicSubscriptionInfo[] EnumerateSubscriptionOffers(SubscriptionEnumerateRequest request);
        FindMediaInstanceUrlsResponse FindMediaInstanceUrls(FindMediaInstanceUrlsRequest request);
        uint GetContentOfferDetails(ContentDetailsRequest request, out ContentDetailsResponse response);
        GetKeyResponse GetKey(GetKeyRequest request);
        GetMediaLicenseResponse GetMediaLicense(GetMediaLicenseRequest request);
        GetPaymentInstrumentsResponse GetPaymentInstruments(GetPaymentInstrumentsRequest request);
        XeGetPointsBalanceResponse GetPointsBalance(XeGetPointsBalanceRequest request);
        XeGetPointsBalanceResponse GetCachedPointsBalance(XeGetPointsBalanceRequest request);
        SubscriptionDetailsResponse GetSubscriptionOfferDetails(SubscriptionDetailsRequest request);
        XeGetUserSubscriptionDetailsResponse GetUserSubscriptionDetails(XeGetUserSubscriptionDetailsRequest request);
        uint OfferingVerifyToken(ulong livePuid, XeOfferingVerifyTokenRequest request, out XeOfferingVerifyTokenResponse tokenInfo);
        LiveCacheWebSvcResponse PurchaseHistory(ulong livePuid, LivecacheWebSvcRequest request);
        LiveCacheWebSvcResponse CachedPurchaseHistory(ulong livePuid, LivecacheWebSvcRequest request);
        uint PurchaseGamerTag(XeOfferPurchaseGamertagRequest request, IAccountAuthDataProvider authDataProvider);
        uint PurchaseMediaOffers(PurchaseMediaOffersRequest request);
        uint PurchasePoints(XeOfferPurchaseRequest request);
        uint PurchaseSubscription(XeOfferPurchaseRequest request);
        void RemovePaymentInstrument(RemovePaymentInstrumentRequest request);
        uint UpdatePaymentInstrument(UpdatePaymentInstrumentRequest request);
        uint VerifyToken(XeVerifyTokenRequest request, out XeVerifyTokenResponse response);
        uint VerifyParentCreditCard(VerifyParentCreditCardRequest request);
        PreviewProductPurchaseResponse PreviewProductPurchase(PreviewProductPurchaseRequest request);
        LiveCacheWebSvcResponse SubscriptionOfferEnumerate(ulong livePuid, LivecacheWebSvcRequest request);
        AssetConsumeResponse AssetConsume(ulong livePuid, AssetConsumeRequest request);
        AssetEnumerateResponse AssetEnumerate(ulong livePuid, AssetEnumerateRequest request);
        LiveCacheWebSvcResponse GetUserSubscriptions(ulong livePuid, LivecacheWebSvcRequest request);
        
        //All these below APIs exist in xuacs but they should have been in billing front door.
        PreviewMergeSubscriptionResponse PreviewMergeSubscription(PreviewMergeSubscriptionRequest request);
        LiveCacheWebSvcResponse TransferPointsBalance(ulong primaryUserPuid, ulong dependentUserPuid, int pointstoTransfer);
        LiveCacheWebSvcResponse GetDependentPointsBalance(ulong primaryUserPuid, ulong dependentUserPuid);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcPresence.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcPresence
    {
        void AcceptFriendRequest(PresenceAcceptBuddyMsg request);
        void AddFriend(PresenceAddBuddy2Msg request);
        void AddFriendFromContact(PresenceAddBuddy2Msg request);
        void DeleteFriend(PresenceDeleteBuddyMsg request);
        bool DeleteMessage(DeleteMessageMsg request);
        MessageSummary2[] EnumerateMessages(EnumerateMessages2Msg request, bool includeWebAlive);
        MessageSummary2[] EnumerateMessages(EnumerateMessages2Msg request);
        SystemMessageSummary[] EnumerateSystemMessages(ulong livePuid, EnumerateSystemMessagesMsg request);
        WebFriendsResponse GetFriends(WebFriendsRequest request);
        GetFriendsListResponse GetFriendsOfFriend(GetFriendsListRequest request);
        MessageDetailsReply GetMessageDetails(MessageDetailsMsg request);
        MessageSummary2 GetMessageSummary(MessageSummary2Msg request);
        PresenceInfoResponse GetPresenceInfo(GetPresenceInfoRequest request);
        PresenceInfoResponse GetPublicPresenceInfo(GetPresenceInfoRequest request, out DateTime responseTTL);
        SystemMessageDetailsReply GetSystemMessageDetails(ulong livePuid, SystemMessageDetailsMsg request);
        QueryAffiliatesReplyData[] QueryAffiliates(PresenceQueryAffiliatesMsg request);
        void RejectFriendRequest(PresenceRejectBuddyMsg request);
        SendMessageReply SendMessage(SendMessageMsg request);
        void SendWebAlive(ulong callerLivepuid);
        void SendWebAlive2(ulong callerLivepuid);
        bool SetMessageFlags(MessageFlagsMsg request);
        void SubmitComplaint(SubmitComplaintRequest request);
        void AddUsersToNeverList(AddUsersToNeverListMsg request);
        void RemoveUsersFromNeverList(RemoveUsersFromNeverListMsg request);
        CanSendMessageToUsersResponse CanSendMessageToUsers(CanSendMessageToUsersMsg request);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcServerSideDownloadQueue.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcServerSideDownloadQueue
    {
        CreateDownloadQueueResponse CreateDownloadQueue(CreateDownloadQueueRequest request);
        QueryDownloadQueuesResponse QueryDownloadQueues(QueryDownloadQueuesRequest request);
        QueryDownloadQueuesResponse QueryDownloadQueuesNonCached(QueryDownloadQueuesRequest request);
        QueryDownloadItemsResponse QueryDownloadItems(QueryDownloadItemsRequest request);
        InsertDownloadItemsResponse InsertDownloadItems(InsertDownloadItemsRequest request);
        DeleteDownloadItemsResponse DeleteDownloadItems(DeleteDownloadItemsRequest request);
        MoveDownloadItemsResponse MoveDownloadItems(MoveDownloadItemsRequest request);
        ModifyDownloadItemsResponse ModifyDownloadItems(ModifyDownloadItemsRequest request);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcTitleStorage.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcTitleStorage
    {
        byte[] StorageRead(string path, uint titleID, LivecacheClientType client);
        void StorageRemove(string path, LivecacheClientType client);
        bool StorageValidate(string path, uint titleID, LivecacheClientType client);
        void StorageWrite(string path, byte[] data, DateTime expirationDate, byte countryId, LivecacheClientType client);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcSts.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcSts
    {
        LiveCacheWebSvcResponse GetSecurityTicket(ulong livePuid, uint titleId, LivecacheWebSvcRequest request, IAAInfoData infoData);
        LiveCacheWebSvcResponse GetPartnerSecurityTicket(ulong livePuid, uint titleId, LivecacheWebSvcRequest request, IAAInfoData infoData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcUserRatings.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache.Data
{
    public interface ILcUserRatings
    {
        GetRatingResponse GetUserRating(GetRatingRequest request);
        void RateMedia(RateMediaRequest request);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcXMachine.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcXMachine
    {
        bool IsConsoleIdAndScodeBanned(string consoleid, string secondaryId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcStringSvr.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcStringSvr
    {
        string StringLookup(uint titleId, uint stringId, ushort liveLanguageId, out DateTime responseTTL);
        StringVetResponse VetString(StringVet2Request request);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcStats.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcStats
    {
        ReadSettingsResponse PublicReadSettings(ulong targetLivepuid, uint[] settings, out DateTime responseTTL);
        float ReadFloatSetting(UserSetting setting, float defaultValue, float noPermissionValue);
        int ReadIntSetting(UserSetting setting, int defaultValue, int noPermissionValue);
        ReadSettingsResponse[] ReadMultiUsersSettings(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, IAccountAuthDataProvider authdataProvider);
        ReadSettingsResponse ReadSettings(ulong callingLivepuid, ulong targetLivepuid, uint[] settings, IAccountAuthDataProvider authdataProvider);
        string ReadStringSetting(UserSetting setting, string defaultValue, string noPermissionValue);
        SyncSettingsResponse SyncSettings(ulong callingLivepuid, UserSetting[] settings, IAccountAuthDataProvider authdataProvider);

        AvatarAssetEnumResponse GetUserAvatarAwards(AvatarAssetEnumRequest request, IAccountAuthDataProvider authdataProvider);
        ValidateAvatarManifestResponse ValidateAvatarManifest(ValidateAvatarManifestRequest request, IAccountAuthDataProvider authdataProvider);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcXCache.cs ===
using System;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    public interface ILcXCache
    {
        bool GetOfficialGamerTag(string gamertag, out ulong livePuid, out string officialGamertag);
        bool GetPuidByGamerTag(string gamertag, out ulong livePuid);
        bool LookupWebID(ulong passportPuid, out ulong livePuid, out string gamertag);
        bool GetGamertagByPuid(ulong livePuid, out string gamertag);

        /// <summary>
        /// Lookup gamertags for an array of xuids - one gamertag per xuid.  Gamertags are
        /// returned in output array in same order as the xuids listed in the input  array.
        /// If no gamertag is found for a given xuid, then ILcXCache.InvalidGamertag is
        /// returned for that xuid.
        /// </summary>
        /// <param name="xuids">Input array of user xuids</param>
        /// <param name="gamertags">An output array containing the matching gamertags.</param>
        /// <returns>True if at least one gamertag is found - otherwise false</returns>
        bool GetGamertagsByXuid(ulong[] xuids, out string[] gamertags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\ILcXSig.cs ===
using System;
using xonline.common.protocol;


namespace xonline.common.webplatform.livecache
{
    public enum DigestRevocationDeliveryType : byte
    {
        RevocationList = 1,
        ServerSideCheck = 2,
    }
    public interface ILcXSig
    {
        RefreshGameLicenseResponse RefreshGameLicense(RefreshGameLicenseRequest request);
        GetLicenseTransferStateResponse GetLicenseTransferState(GetLicenseTransferStateRequest request);
        void UpdateLicenseTransferState(UpdateLicenseTransferStateRequest request);
        byte[] GetSignedHeader(uint fileSize, uint fileType, byte[] fileHash);
        void BlacklistDigest(byte[] digest, DigestRevocationDeliveryType deliveryType, string revocationReason);
        void UnBlacklistDigest(byte[] digest);
        AcknowledgeLicensesDeliveryResponse AcknowledgeLicensesDelivery(AcknowledgeLicensesDeliveryRequest request);
        AcquireMediaLicensesResponse AcquireMediaLicenses(AcquireMediaLicensesRequest request);
        LiveCacheWebSvcResponse AcquireMediaLicensesWeb(string[] miids, string[] oids, ulong xuid, string clientInfo);
        LiveCacheWebSvcResponse CheckLicensesAvailability(string[] miids, string[] oids, ulong xuid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcAchievement.cs ===
using System;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Summary description for AchievementDataAccess.
    /// </summary>
    public class LcAchievement : ILcAchievement
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("Achievement", "WebPlatform_Livecache");

        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint titleId;
        private IAccountAuthDataProvider authdataProvider;

        public LcAchievement(LivecacheClientType clientType, uint clientTitleId, IAccountAuthDataProvider authDataProvider)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }
            if (authDataProvider == null)
            {
                throw new ArgumentNullException("authDataProvider");
            }
            client = clientType;
            titleId = clientTitleId;
            authdataProvider = authDataProvider;
        }

        public EnumTitlesResponse GetUserTitles(EnumTitlesRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.UserId == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency dependency = LivecacheDependencies.Stats(request.UserId);

            LivecacheRequest lcReq = new LivecacheRequest(request.UserId,
                                                        client,
                                                        LcserviceId.EnumTitles, 
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        dependency,
                                                        null);

            uint hr = 1;
            hr = lcReq.Send();
            
            EnumTitlesResponse response = new EnumTitlesResponse();
            response.Titles = new UserTitle[0];

            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                {
                    return response;
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }

            // get the response
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public EnumTitlesResponse GetPublicUserTitles(EnumTitlesRequest request, IAccountAuthDataProvider authdata,  out DateTime responseTTL)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            request.UserId = LivecacheRequest.PublicRequestLivePuid; //cached for all calling livepuid

            LivecacheDependency dependency = LivecacheDependencies.Stats(request.UserId);

            LivecacheRequest lcReq = new LivecacheRequest(LivecacheRequest.PublicRequestLivePuid, 
                                                        client,
                                                        LcserviceId.PublicEnumTitles, 
                                                        request,
                                                        titleId,
                                                        authdata,
                                                        dependency,
                                                        null);
            uint hr = 1;
            hr = lcReq.Send();

            EnumTitlesResponse response = new EnumTitlesResponse();
            response.Titles = new UserTitle[0];

            // check for errors
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                {
                    responseTTL = lcReq.ResponseExpiry;
                    return response;
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }

            responseTTL = lcReq.ResponseExpiry;
            response.SetBytes(lcReq.ResponseData);
            return response;    
        }

        public AchievementEnumResponse GetUserAchievements(AchievementEnumRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.Puid == 0)
            {
                throw new ArgumentException("invalid calling livepuid");
            }
            if (request.ForPuid == 0)
            {
                throw new ArgumentException("invalid target livepuid");
            }

            LivecacheDependency dependency = LivecacheDependencies.Stats(request.Puid);

            LivecacheRequest lcReq = new LivecacheRequest(request.Puid,
                                                    client,
                                                    LcserviceId.AchievementEnum, 
                                                    request,
                                                    titleId,
                                                    authdataProvider,
                                                    dependency,
                                                    null);

            uint hr = 1;
            hr = lcReq.Send();
 
            AchievementEnumResponse response = new AchievementEnumResponse();
            response.Achievements = new Achievement[0];

            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                {
                    return response;
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }

            // get the response
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public SyncAchievementsResponse SyncAchievements(SyncAchievementsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.UserId == 0)
            {
                throw new ArgumentException("invalid calling livepuid");
            }
            if (request.TitleId == 0)
            {
                throw new ArgumentException("invalid titleid");
            }

            LivecacheDependency invalidates = LivecacheDependencies.Stats(request.UserId);

            LivecacheRequest lcReq = new LivecacheRequest(request.UserId,
                                                    client,
                                                    LcserviceId.SyncAchievements,
                                                    request,
                                                    titleId,
                                                    authdataProvider,
                                                    null,
                                                    invalidates);

            uint hr = 1;
            hr = lcReq.Send();

            SyncAchievementsResponse response = new SyncAchievementsResponse();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public SyncTitlesResponse SyncTitles(SyncTitlesRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.UserId == 0)
            {
                throw new ArgumentException("invalid calling livepuid");
            }

            LivecacheDependency invalidates = LivecacheDependencies.Stats(request.UserId);

            LivecacheRequest lcReq = new LivecacheRequest(request.UserId,
                                                    client,
                                                    LcserviceId.SyncTitles,
                                                    request,
                                                    titleId,
                                                    authdataProvider,
                                                    null,
                                                    invalidates);

            uint hr = 1;
            hr = lcReq.Send();

            SyncTitlesResponse response = new SyncTitlesResponse();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public SyncAvatarAssetResponse SyncAvatarAssets(SyncAvatarAssetRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.UserId == 0)
            {
                throw new ArgumentException("invalid calling livepuid");
            }
            if (request.TitleId == 0)
            {
                throw new ArgumentException("invalid titleid");
            }

            LivecacheDependency invalidates = LivecacheDependencies.Stats(request.UserId);

            LivecacheRequest lcReq = new LivecacheRequest(request.UserId,
                                                    client,
                                                    LcserviceId.SyncAvatarAssets,
                                                    request,
                                                    titleId,
                                                    authdataProvider,
                                                    null,
                                                    invalidates);

            uint hr = 1;
            hr = lcReq.Send();

            SyncAvatarAssetResponse response = new SyncAvatarAssetResponse();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcLists.cs ===
using System;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class LcLists : ILcLists
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("Lists", "WebPlatform_Livecache");

        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint titleId = 0;
        private IAccountAuthDataProvider authdataProvider = null;

        public LcLists(LivecacheClientType clientType, uint clientTitleId, IAccountAuthDataProvider authDataProvider)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }
            if (authDataProvider == null)
            {
                throw new ArgumentNullException("authDataProvider");
            }
            client = clientType;
            titleId = clientTitleId;
            authdataProvider = authDataProvider;
        }

        public QueryListsResponse QueryLists(QueryListsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency dependency = LivecacheDependencies.Lists(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.QueryLists,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        dependency,
                                                        null);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            QueryListsResponse response = new QueryListsResponse(new QueryListsReply());
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public QueryItemsResponse QueryListItems(QueryItemsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency dependency = LivecacheDependencies.Lists(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.QueryListItems,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        dependency,
                                                        null);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            QueryItemsResponse response = new QueryItemsResponse(new QueryItemsReply());
            response.SetBytes(lcReq.ResponseData);
            return response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcPresence.cs ===
using System;
using xonline.common.protocol;
using xonline.common.service;


namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Summary description for Friends.
    /// </summary>
    public class LcPresence : ILcPresence
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("Presence", "WebPlatform_Livecache");

        private IContextItemProvider context;
        private IAccountAuthDataProvider authdataProvider;
        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint titleId;

        public LcPresence(LivecacheClientType clientType, uint clientTitleId, IContextItemProvider contextProvider, IAccountAuthDataProvider authDataProvider)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }

            client = clientType;
            titleId = clientTitleId;
            context = contextProvider;
            authdataProvider = authDataProvider;
        }

        /// <summary>
        /// load user presence info to memory
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="context"></param>
        /// <param name="callerLivepuid"></param>
        public void SendWebAlive(ulong callerLivepuid)
        {
            if (callerLivepuid == 0)
            {
                throw new ArgumentException("callerLivepuid can't be 0.");
            }

            // enforce only calling once per user request
            if (context != null)
            {
                string key = "WebAlive_" + callerLivepuid.ToString();

                if (context[key] != null)
                {
                    return;
                }
                context[key] = true;
            }

            WebAliveRequest aliveReq = new WebAliveRequest();
            aliveReq.puid = callerLivepuid;

            LivecacheRequest lcReq = new LivecacheRequest(callerLivepuid, 
                            client,
                            LcserviceId.WebAlive, 
                            aliveReq, 
                            titleId, 
                            authdataProvider);

            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            WebAliveResponse aliveResp = new WebAliveResponse();
            aliveResp.SetBytes(lcReq.ResponseData);

            // see if presence reported an error in the message itself
            if (aliveResp.hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq, "Web Alive call failed with hr = " + aliveResp.hr);
            }
        }

        /// <summary>
        /// Flow user presence to Presence FD along with the titleId associated with this instance
        /// </summary>
        /// <param name="callerLivepuid"></param>
        public void SendWebAlive2(ulong callerLivepuid)
        {
            if (callerLivepuid == 0)
            {
                throw new ArgumentException("callerLivepuid can't be 0.");
            }

            // titleId == 0 is handled by the constructor.

            // enforce only calling once per user request
            if (context != null)
            {
                string key = "WebAlive2_" + callerLivepuid.ToString();

                if (context[key] != null)
                {
                    return;
                }
                context[key] = true;
            }

            WebAlive2Request aliveReq = new WebAlive2Request();
            aliveReq.puid = callerLivepuid;
            aliveReq.titleId = titleId;  //set the title id that was set on the instance

            LivecacheRequest lcReq = new LivecacheRequest(callerLivepuid,
                            client,
                            LcserviceId.WebAlive2,
                            aliveReq,
                            titleId,
                            authdataProvider);

            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            WebAliveResponse aliveResp = new WebAliveResponse();
            aliveResp.SetBytes(lcReq.ResponseData);

            // see if presence reported an error in the message itself
            if (aliveResp.hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq, "Web Alive2 call failed with hr = " + aliveResp.hr);
            }
        }

        /// <summary>
        /// get recent players list
        /// </summary>
        /// <param name="request"></param>
        /// <returns></returns>
        public QueryAffiliatesReplyData[] QueryAffiliates(PresenceQueryAffiliatesMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwSenderID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.cdwLimit == 0)
            {
                return new QueryAffiliatesReplyData[0];
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwSenderID);

            //cache the LiveCache request
            LivecacheRequest lcReq = new LivecacheRequest(request.qwSenderID,
                            client,
                            LcserviceId.QueryAffiliates,
                            request,
                            titleId,
                            authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            // check for errors
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            PresenceQueryAffiliatesReplyMsg qaResp = new PresenceQueryAffiliatesReplyMsg();
            qaResp.SetBytes(lcReq.ResponseData);
            if ((qaResp.cdwResults == 0) && (qaResp.hr != HResult.S_OK))
            {
                switch (qaResp.hr)
                {
                    case 0x80070525: //HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_NO_PEER_SUBSCRIBE: // non error
                    case xonline.common.service.HResult.E_INVALIDARG: //query affiliates on mute or block list
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_INVALID_PUID: //callerid=0
                        _logArea.LogInfo("No QueryAffiliates results. hr = {0}, caller:{1}.",
                                    qaResp.hr, request.qwSenderID);
                        return new QueryAffiliatesReplyData[0];
                    default:
                        throw new ServiceUnavailableException(String.Format("QueryAffiliates process failed on the service. hr = {0}, caller:{1}.", qaResp.hr, request.qwSenderID));
                }
            }

            return qaResp.rgResults;
        }

        public PresenceInfoResponse GetPresenceInfo(GetPresenceInfoRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwSenderID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.rgUsers == null || request.rgUsers.Length == 0)
            {
                throw new ArgumentException("invalid target userpuid list");
            }

            LivecacheRequest lcReq = new LivecacheRequest(request.qwSenderID, 
                                                client,
                                                LcserviceId.GetPresenceInfo, 
                                                request, 
                                                titleId, 
                                                authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            PresenceInfoResponse presenceResp = new PresenceInfoResponse();
            presenceResp.SetBytes(lcReq.ResponseData);
            return presenceResp;
        }

        public PresenceInfoResponse GetPublicPresenceInfo(GetPresenceInfoRequest request, out DateTime responseTTL)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwSenderID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.rgUsers == null || request.rgUsers.Length == 0)
            {
                throw new ArgumentException("invalid target userpuid list");
            }

            LivecacheRequest lcReq = new LivecacheRequest(LivecacheRequest.PublicRequestLivePuid, //cache for all calling livepuid
                                    client,
                                    LcserviceId.GetPublicPresenceInfo, 
                                    request, 
                                    titleId, 
                                    null);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            PresenceInfoResponse presenceResp = new PresenceInfoResponse();
            presenceResp.SetBytes(lcReq.ResponseData);
            responseTTL = lcReq.ResponseExpiry;
            return presenceResp;
        }

        public WebFriendsResponse GetFriends(WebFriendsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.puid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }
            // Force presence to load the online record for this user
            SendWebAlive2(request.puid);

            LivecacheDependency dependency = LivecacheDependencies.Friends(request.puid);
            LivecacheRequest lcReq = new LivecacheRequest(request.puid,
                                                        client,
                                                        LcserviceId.GetFriends,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        dependency,
                                                        null);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            WebFriendsResponse wfrResp = new WebFriendsResponse();
            wfrResp.SetBytes(lcReq.ResponseData);
            return wfrResp;
        }

        public GetFriendsListResponse GetFriendsOfFriend(GetFriendsListRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwSender == 0)
            {
                throw new ArgumentException("invalid sender puid");
            }
            if (request.qwTarget == 0)
            {
                throw new ArgumentException("invalid target puid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            LivecacheRequest lcReq = new LivecacheRequest(request.qwSender,
                                                        client,
                                                        LcserviceId.GetFriendsOfFriend,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        null);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            GetFriendsListResponse friendsListResp = new GetFriendsListResponse();
            friendsListResp.SetBytes(lcReq.ResponseData);
            return friendsListResp;
        }

        public void AddFriend(PresenceAddBuddy2Msg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwSenderID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.qwBuddyID == 0)
            {
                throw new ArgumentException("invalid friend userpuid");
            }

            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwSenderID);

            LivecacheDependency invalidate = LivecacheDependencies.Friends(request.qwSenderID);
            LivecacheRequest lcReq = new LivecacheRequest(request.qwSenderID,
                                                        client,
                                                        LcserviceId.AddFriend,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                switch (hr)
                {
                    // need to throw custom exceptions for these cases
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_LIST_FULL:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_BLOCKED:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_FRIEND_PENDING:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_TOO_MANY_REQUESTS:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_USER_NOT_FOUND:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_OTHER_LIST_FULL:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_SELF:
                    default:
                        throw new LivecacheResponseException(lcReq);
                }
            }
        }

        /// <summary>
        /// All services that add friends in bulk (WLM friend finder, etc.) should use AddFriendFromContact() to
        /// ensure the proper LiveCache API bucket is used for the transaction.
        /// </summary>
        /// <param name="request"></param>
        public void AddFriendFromContact(PresenceAddBuddy2Msg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwSenderID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.qwBuddyID == 0)
            {
                throw new ArgumentException("invalid friend userpuid");
            }

            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwSenderID);

            LivecacheDependency invalidate = LivecacheDependencies.Friends(request.qwSenderID);
            LivecacheRequest lcReq = new LivecacheRequest(request.qwSenderID,
                                                        client,
                                                        LcserviceId.AddFriendFromContact,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                switch (hr)
                {
                    // need to throw custom exceptions for these cases
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_LIST_FULL:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_BLOCKED:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_FRIEND_PENDING:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_TOO_MANY_REQUESTS:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_USER_NOT_FOUND:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_OTHER_LIST_FULL:
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_SELF:
                    default:
                        throw new LivecacheResponseException(lcReq);
                }
            }
        }

        public void DeleteFriend(PresenceDeleteBuddyMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.qwBuddyID == 0)
            {
                throw new ArgumentException("invalid friend userpuid");
            }

            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            LivecacheDependency invalidate = LivecacheDependencies.Friends(request.qwUserID);
            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.DeleteFriend,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public void AcceptFriendRequest(PresenceAcceptBuddyMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.qwBuddyID == 0)
            {
                throw new ArgumentException("invalid friend userpuid");
            }

            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            LivecacheDependency invalidate = LivecacheDependencies.Friends(request.qwUserID).AddMessages();
            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.AcceptFriendRequest,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public void RejectFriendRequest(PresenceRejectBuddyMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.qwBuddyID == 0)
            {
                throw new ArgumentException("invalid friend userpuid");
            }

            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            LivecacheDependency invalidate = LivecacheDependencies.Friends(request.qwUserID).AddMessages();
            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.RejectFriendRequest,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public MessageSummary2[] EnumerateMessages(EnumerateMessages2Msg request)
        {
            return EnumerateMessages(request, true);
        }

        public MessageSummary2[] EnumerateMessages(EnumerateMessages2Msg request, bool includeWebAlive)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            if (includeWebAlive)
            {
                SendWebAlive2(request.qwUserID);
            }

            LivecacheDependency dependency = LivecacheDependencies.Messages(request.qwUserID);
            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.EnumerateMessages,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        dependency,
                                                        null);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            EnumerateMessages2Reply response = new EnumerateMessages2Reply();
            response.SetBytes(lcReq.ResponseData);
            return response.rgMessages;
        }

        public MessageSummary2 GetMessageSummary(MessageSummary2Msg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.dwMessageID == 0)
            {
                throw new ArgumentException("invalid message id");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.GetMessageSummary,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            MessageSummary2Reply response = new MessageSummary2Reply();
            response.SetBytes(lcReq.ResponseData);
            return response.summary;
        }

        public MessageDetailsReply GetMessageDetails(MessageDetailsMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.dwMessageID == 0)
            {
                throw new ArgumentException("invalid message id");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            LivecacheDependency invalidation = LivecacheDependencies.Messages(request.qwUserID);
            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.GetMessageDetails,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidation);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            MessageDetailsReply response = new MessageDetailsReply();
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public bool DeleteMessage(DeleteMessageMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.dwMessageID == 0)
            {
                throw new ArgumentException("invalid message id");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }
            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            LivecacheDependency invalidation = LivecacheDependencies.Messages(request.qwUserID);
            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.DeleteMessage,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidation);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
            return true;
        }

        public bool SetMessageFlags(MessageFlagsMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.dwMessageID == 0)
            {
                throw new ArgumentException("invalid message id");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            // set up the LiveCache request
            LivecacheDependency invalidation = LivecacheDependencies.Messages(request.qwUserID);
            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.SetMessageFlags,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidation);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            return true;
        }

        public SendMessageReply SendMessage(SendMessageMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwSenderID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.qwRecipientIDs == null || request.qwRecipientIDs.Length == 0)
            {
                throw new ArgumentException("invalid sending userpuid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwSenderID);

            LivecacheRequest lcReq = new LivecacheRequest(request.qwSenderID,
                                                        client,
                                                        LcserviceId.SendMessage,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            SendMessageReply response = new SendMessageReply();
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public SystemMessageSummary[] EnumerateSystemMessages(ulong livePuid, EnumerateSystemMessagesMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.dwTitleID == 0)
            {
                throw new ArgumentException("invalid titleId");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            LivecacheRequest lcReq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.EnumerateSystemMessages,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            EnumerateSystemMessagesReply response = new EnumerateSystemMessagesReply();
            response.SetBytes(lcReq.ResponseData);
            return response.rgMessages;
        }

        public SystemMessageDetailsReply GetSystemMessageDetails(ulong livePuid, SystemMessageDetailsMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.dwMessageID == 0)
            {
                throw new ArgumentException("invalid message id");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            LivecacheRequest lcReq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.GetSystemMessageDetails,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            SystemMessageDetailsReply response = new SystemMessageDetailsReply();
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public void SubmitComplaint(SubmitComplaintRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.senderPUID == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (request.targetPUID == 0)
            {
                throw new ArgumentException("invalid target userpuid");
            }
            if (request.senderPUID == request.targetPUID)
            {
                throw new ArgumentException("calling userpuid can't be same as target userpuid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.senderPUID);

            LivecacheRequest lcReq = new LivecacheRequest(request.senderPUID,
                                                        client,
                                                        LcserviceId.SubmitComplaint,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public void AddUsersToNeverList(AddUsersToNeverListMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling qwUserID");
            }
            if (request.cNeverListUserCount == 0 || request.rgqwNeverListUsers.Length != request.cNeverListUserCount)
            {
                throw new ArgumentException("invalid cNeverListUserCount");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.AddUsersToNeverList,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public void RemoveUsersFromNeverList(RemoveUsersFromNeverListMsg request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling qwUserID");
            }
            if (request.cNeverListUserCount == 0 || request.rgqwNeverListUsers.Length != request.cNeverListUserCount)
            {
                throw new ArgumentException("invalid cNeverListUserCount");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.RemoveUsersFromNeverList,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }
        
        public CanSendMessageToUsersResponse CanSendMessageToUsers(CanSendMessageToUsersMsg  request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.qwUserID == 0)
            {
                throw new ArgumentException("invalid calling qwUserID");
            }
            if (request.cUserListCount == 0 || request.rgqwUsers.Length != request.cUserListCount)
            {
                throw new ArgumentException("invalid cUserListCount");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // make sure Presence has an online record loaded for the calling user
            SendWebAlive2(request.qwUserID);

            LivecacheRequest lcReq = new LivecacheRequest(request.qwUserID,
                                                        client,
                                                        LcserviceId.CanSendMessageToUsers,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            CanSendMessageToUsersResponse response = new CanSendMessageToUsersResponse();
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcLeaderboards.cs ===
namespace xonline.common.webplatform.livecache
{
    using System.IO;
    using xonline.common.protocol;
    using xonline.common.service;

    /// <summary>
    /// Implementation of the interface to read/write to Xbox LIVE leaderboards.
    /// </summary>
    public class LcLeaderboards : ILcLeaderboards
    {
        /// <summary>
        /// The client type for the interface.
        /// </summary>
        private const LivecacheClientType ClientType = LivecacheClientType.LIVEn;

        /// <summary>
        /// Posts leaderboard stats to Xbox LIVE. This data is later used to compute the XBL leaderboards.
        /// </summary>
        /// <param name="request">The request to write a stat to the leaderboard.</param>
        /// <param name="callingLivePuid">Caller's live PUID.</param>
        public void PostLeaderboardResult(ReqStatPost request, ulong callingLivePuid)
        {
            using (MemoryStream memStream = new MemoryStream())
            using (BinaryWriter writer = new BinaryWriter(memStream))
            {
                // Write the stat post request to a memory stream via a binary writer.
                request.WriteTo(writer);
                writer.Flush();

                LivecacheRequest livecacheRequest = new LivecacheRequest(
                                                            callingLivePuid,
                                                            ClientType,
                                                            LcserviceId.PostLeaderboardResult,
                                                            memStream.GetBuffer(),
                                                            0,
                                                            request._uiTitleId,
                                                            null,
                                                            null,
                                                            null,
                                                            request);

                if (livecacheRequest.Send() != HResult.S_OK)
                {
                    throw new LivecacheResponseException(livecacheRequest);
                }

                // For all clients that use XBL v2 i.e. Xbox 360 protocol, there should be no response. Are you using Xbox 1 protocol?
                if (livecacheRequest.ResponseData.Length > 0)
                {
                    throw new LivecacheResponseException(
                        livecacheRequest,
                        "For all clients that use XBL v2 i.e. Xbox 360 protocol, there should be no response. Are you using Xbox 1 protocol?");
                }
            }
        }

        /// <summary>
        /// Gets the information about a XBL leaderboard. Basically it gets the leaderboard stat columns that are requested.
        /// </summary>
        /// <param name="request">Request for getting the leaderboard information.</param>
        /// <param name="callingLivePuid">Caller's live PUID.</param>
        /// <returns>Collection of result sets for the corresponding read request.</returns>
        public StatsReadResponse GetFriendsLeaderboardInfo(StatsReadRequest request, ulong callingLivePuid)
        {
            LivecacheRequest livecacheRequest = new LivecacheRequest(
                                                        callingLivePuid,
                                                        ClientType,
                                                        LcserviceId.GetFriendsLeaderboardInfo,
                                                        request,
                                                        request.TitleId,
                                                        null);

            if (livecacheRequest.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(livecacheRequest);
            }

            // Get the response
            StatsReadResponse readResp = new StatsReadResponse();
            readResp.SetBytes(livecacheRequest.ResponseData);
            return readResp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcStats.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Net;
using System.Text;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class LcStats : ILcStats
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("Stats", "WebPlatform_Livecache");
        
        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint titleId;

        /// <summary>
        /// Internal class used to set Livecache privileges for public settings access.
        /// </summary>
        private class AuthPublicSettings : IAccountAuthDataProvider
        {
            private ulong _livePuid;
            private byte _tier;
            private uint[] _privileges;

            public AuthPublicSettings()
            {
                _livePuid = LivecacheRequest.PublicRequestLivePuid;
                _tier = 0;

                // hard code privileges to baseline level
                _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
                AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
                // hard code PROFILE_VIEWING for bug 174038
                AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
            }

            private void AddPrivilege(int privilegeId)
            {
                uint mask = (uint) 1 << (privilegeId % 32);
                _privileges[privilegeId / 32] |= mask;
            }

            public ulong LivePuid
            {
                get { return _livePuid; }
            }
            
            public byte Tier
            {
                get { return _tier; }
            }

            public uint[] Privileges
            {
                get { return _privileges; }
            }

            public IPEndPoint ClientIPEndPoint
            {
                get { return new IPEndPoint(0,0); }
            }
        }

        public LcStats(LivecacheClientType clientType, uint clientTitleId)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }

            client = clientType;
            titleId = clientTitleId;
        }


        public ReadSettingsResponse ReadSettings(ulong callingLivepuid, ulong targetLivepuid, uint[] settings, IAccountAuthDataProvider authdataProvider)
        {
            if (callingLivepuid == 0)
            {
                throw new ArgumentException("invalid calling livepuid");
            }
            if (targetLivepuid == 0)
            {
                throw new ArgumentException("invalid target livepuid");
            }
            if (settings == null)
            {
                throw new ArgumentNullException("settings");
            }
            if (settings.Length == 0)
            {
                throw new ArgumentException("invalid settings");
            }

            ReadSettingsRequest request = new ReadSettingsRequest();

            request.TitleId = titleId;
            request.UserId = callingLivepuid;
            request.ForUserIds = new ulong[] { targetLivepuid };
            request.SettingIds = settings;

            LivecacheDependency dependency = LivecacheDependencies.Stats(targetLivepuid);
            LivecacheRequest lcReq;

            if (authdataProvider != null)
            {
                lcReq = new LivecacheRequest(callingLivepuid,
                                            client,
                                            LcserviceId.ReadSettings,
                                            request, 
                                            titleId,
                                            authdataProvider,
                                            dependency, 
                                            null);
            }
            else if (callingLivepuid == targetLivepuid)
            {
                //for xbox1 user, we may request user setting before user signed in. Need to pass calling livepuid
                lcReq = new LivecacheRequest(callingLivepuid, 
                                            client,
                                            LcserviceId.ReadSettings,
                                            request, 
                                            titleId, 
                                            null,
                                            dependency, 
                                            null);
            }
            else
            {
                throw new LivecacheCodeErrorException("sign in required to read other user's setting");
            }

            if (lcReq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            ReadSettingsResponse readResp = new common.protocol.ReadSettingsResponse();  
            readResp.SetBytes(lcReq.ResponseData);    
            return readResp;
        }

        public ReadSettingsResponse PublicReadSettings(ulong targetLivepuid, uint[] settings, out DateTime responseTTL)
        {
            if (targetLivepuid == 0)
            {
                throw new ArgumentException("invalid target livepuid");
            }
            if (settings == null)
            {
                throw new ArgumentNullException("settings");
            }
            if (settings.Length == 0)
            {
                throw new ArgumentException("invalid settings");
            }

            ReadSettingsRequest request = new ReadSettingsRequest();
            request.TitleId = titleId;
            request.UserId = LivecacheRequest.PublicRequestLivePuid;
            request.ForUserIds = new ulong[] { targetLivepuid };
            request.SettingIds = settings;

            IAccountAuthDataProvider auth = new AuthPublicSettings();

            LivecacheDependency dependency = LivecacheDependencies.Stats(targetLivepuid);
            LivecacheRequest lcReq = new LivecacheRequest(LivecacheRequest.PublicRequestLivePuid,
                                                client,
                                                LcserviceId.PublicReadSettings,
                                                request,
                                                titleId,
                                                auth,
                                                dependency,
                                                null);

            if (lcReq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            responseTTL = lcReq.ResponseExpiry;

            ReadSettingsResponse readResp = new ReadSettingsResponse();  
            readResp.SetBytes(lcReq.ResponseData);    
            return readResp;
        }

        public ReadSettingsResponse[] ReadMultiUsersSettings(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, IAccountAuthDataProvider authdataProvider)
        {
            if (callingLivepuid == 0)
            {
                throw new ArgumentException("invalid calling livepuid");
            }
            if (targetLivepuids == null || targetLivepuids.Length == 0)
            {
                throw new ArgumentException("invalid target livepuid list");
            }
            if (settings == null)
            {
                throw new ArgumentNullException("settings");
            }
            if (settings.Length == 0)
            {
                throw new ArgumentException("invalid setting list");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // since stats limits our call to 16 puids at a time, we need to interate in increments of 16
            int iNextStartIndex = 0;
            const int iMaxUsers = (int)XOn.XONLINE_MAX_SETTING_USERS;
            bool bContinue = (iNextStartIndex < targetLivepuids.Length);

            ReadSettingsResponse[] responses = new ReadSettingsResponse[0];
            ArrayList results = new ArrayList();

            while (bContinue)
            {
                ReadSettingsRequest readReq = new ReadSettingsRequest();
                readReq.TitleId = titleId;
                readReq.UserId = callingLivepuid;

                int iArrayLength = Math.Min(iMaxUsers, targetLivepuids.Length - iNextStartIndex);
                readReq.ForUserIds = new ulong[iArrayLength];

                for (int i = 0; i < readReq.ForUserIds.Length; i++)
                {
                    readReq.ForUserIds[i] = targetLivepuids[iNextStartIndex + i];
                }

                iNextStartIndex += iMaxUsers;

                if (iNextStartIndex >= targetLivepuids.Length)
                {
                    bContinue = false;
                }

                readReq.SettingIds = settings;

                //cache livecache request
                LivecacheDependency dependency = LivecacheDependencies.Stats(callingLivepuid);
                LivecacheRequest lcReq = new LivecacheRequest(callingLivepuid,
                                                            client,
                                                            LcserviceId.ReadSettings, 
                                                            readReq, 
                                                            titleId,
                                                            authdataProvider,
                                                            dependency, 
                                                            null);

                if (lcReq.Send() != HResult.S_OK)
                {
                    throw new LivecacheResponseException(lcReq);
                }

                ReadSettingsResponse readResp = new ReadSettingsResponse();  
                readResp.SetBytes(lcReq.ResponseData);    
                results.Add(readResp);
            }
          
            responses = new ReadSettingsResponse[results.Count];
            results.CopyTo(responses);
            return responses;
        }

        public SyncSettingsResponse SyncSettings(ulong callingLivepuid, UserSetting[] settings, IAccountAuthDataProvider authdataProvider)
        {
            if (callingLivepuid == 0)
            {
                throw new ArgumentException("invalid calling livepuid");
            }
            if (settings == null)
            {
                throw new ArgumentNullException("settings");
            }
            if (settings.Length == 0)
            {
                throw new ArgumentException("invalid settings");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            // Do a quick check that we're setting values for the callingLivepuid.
            // This is not an exhastive check, but should catch this case for standard
            // usage.
            if (callingLivepuid != settings[0].UserId)
            {
                throw new ArgumentException("The UserId for whom settings are being set does not match the calling UserId.", "settings");
            }

            SyncSettingsRequest syncReq = new SyncSettingsRequest();
            syncReq.Settings = settings;
            syncReq.TitleId = titleId;
            syncReq.UserId = callingLivepuid;
            syncReq.Version = XOn.MinDateTime;
            syncReq.StartinIndex = 0;

            // really we want to invalidate the user for whom we are applying the settings, but that should always be
            // the same as the calling user
            LivecacheDependency invalidates = LivecacheDependencies.Stats(callingLivepuid);
            LivecacheRequest lcReq = new LivecacheRequest(callingLivepuid,
                                                        client,
                                                        LcserviceId.SyncSettings,
                                                        syncReq,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidates);

            if (lcReq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            SyncSettingsResponse syncResp = new common.protocol.SyncSettingsResponse();
            syncResp.SetBytes(lcReq.ResponseData);
            return syncResp;
        }

        /// <summary>
        /// helper utility for reading  string setting
        /// </summary>
        /// <param name="setting"></param>
        /// <param name="defaultValue"></param>
        /// <param name="noPermissionValue"></param>
        /// <returns></returns>
        public string ReadStringSetting(UserSetting setting, string defaultValue, string noPermissionValue)
        {
            if (((setting.SettingId >> 28) & 0xf) != (byte)XuserDataType.Unicode)
            {
                throw new LivecacheCodeErrorException(
                    "ReadStringSetting was called with a setting ID that does not indicate a Unicode type. Type value for setting " + setting + " is " + ((setting.SettingId >> 28) & 0xf) + ".");
            }

            if (setting.Source == XOn.XSOURCE_PERMISSION_DENIED)
            {
                return noPermissionValue;
            }
            else if (setting.Source == XOn.XSOURCE_NO_VALUE)
            {
                return defaultValue;
            }
            else if (setting.ValueLen <= 2)
            {
                return "";
            }
            else
            {
                Encoding unicode = Encoding.Unicode;
                return unicode.GetString(setting.Value, 0, setting.ValueLen - 2);
            }
        }

        /// <summary>
        /// helper utility for reading float setting
        /// </summary>
        /// <param name="setting"></param>
        /// <param name="defaultValue"></param>
        /// <param name="noPermissionValue"></param>
        /// <returns></returns>
        public float ReadFloatSetting(UserSetting setting, float defaultValue, float noPermissionValue)
        {
            if (((setting.SettingId >> 28) & 0xf) != (byte)XuserDataType.Float)
            {
                throw new LivecacheCodeErrorException(
                    "ReadFloatSetting was called with a setting ID that does not indicate a Float type. Type value for setting " + setting + " is " + ((setting.SettingId >> 28) & 0xf) + ".");
            }

            if (setting.Source == XOn.XSOURCE_PERMISSION_DENIED)
            {
                return noPermissionValue;
            }
            else if (setting.Source == XOn.XSOURCE_NO_VALUE)
            {
                return defaultValue;
            }
            else
            {
                if (setting.ValueLen == 4)
                {
                    return BitConverter.ToSingle(setting.Value, 0);
                }
                else
                {
                    throw new LivecacheCodeErrorException(
                        "Can't convert setting " + setting.SettingId.ToString() + " to a float. " + setting.ValueLen.ToString() + " bytes were in the response - needs to be 4 bytes to convert.");
                }
            }
        }

        /// <summary>
        /// helper utility for reading  int setting
        /// </summary>
        /// <param name="setting"></param>
        /// <param name="defaultValue"></param>
        /// <param name="noPermissionValue"></param>
        /// <returns></returns>
        public int ReadIntSetting(UserSetting setting, int defaultValue, int noPermissionValue)
        {
            if (((setting.SettingId >> 28) & 0xf) != (byte)XuserDataType.Int32)
            {
                throw new LivecacheCodeErrorException(
                    "ReadIntSetting was called with a setting ID that does not indicate a Int32 type. Type value for setting " + setting + " is " + ((setting.SettingId >> 28) & 0xf) + ".");
            }

            if (setting.Source == XOn.XSOURCE_PERMISSION_DENIED)
            {
                return noPermissionValue;
            }
            else if (setting.Source == XOn.XSOURCE_NO_VALUE)
            {
                return defaultValue;
            }
            else
            {
                if (setting.ValueLen == 1)
                {
                    return (int)setting.Value[0];
                }
                else if (setting.ValueLen == 2)
                {
                    return (int)BitConverter.ToInt16(setting.Value, 0);
                }
                else if (setting.ValueLen == 4)
                {
                    return BitConverter.ToInt32(setting.Value, 0);
                }
                else
                {
                    throw new LivecacheCodeErrorException(
                        "Can't convert setting " + setting.SettingId.ToString() + " to an int. " + setting.ValueLen.ToString() + " bytes were in the response - needs to be 1, 2, or 4 bytes to convert.");
                }
            }
        }

        public AvatarAssetEnumResponse GetUserAvatarAwards(AvatarAssetEnumRequest request, IAccountAuthDataProvider authdataProvider)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.Puid == 0)
            {
                throw new ArgumentException("invalid calling livepuid");
            }
            if (request.ForPuid == 0)
            {
                throw new ArgumentException("invalid target livepuid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            LivecacheDependency dependency = LivecacheDependencies.Stats(request.Puid);

            LivecacheRequest lcReq = new LivecacheRequest(request.Puid,
                                                    client,
                                                    LcserviceId.AvatarAwardEnum,
                                                    request,
                                                    titleId,
                                                    authdataProvider,
                                                    dependency,
                                                    null);

            uint hr = 1;
            hr = lcReq.Send();

            AvatarAssetEnumResponse response = new AvatarAssetEnumResponse();
            response.AvatarAssets = new AvatarAsset[0];

            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                {
                    return response;
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }

            // get the response
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public ValidateAvatarManifestResponse ValidateAvatarManifest(ValidateAvatarManifestRequest request, IAccountAuthDataProvider authdataProvider)
        {
            if (request.UserId == 0)
            {
                throw new ArgumentException("invalid calling livepuid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            LivecacheRequest lcReq = new LivecacheRequest(request.UserId,
                                                        client,
                                                        LcserviceId.ValidateAvatarManifest,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        null);

            if (lcReq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            ValidateAvatarManifestResponse response = new ValidateAvatarManifestResponse();
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        [Conditional("DEBUG")]
        public void HitTestFD(ulong targetLivepuid, byte[] body, IAccountAuthDataProvider authdataProvider, ref byte[] response)
        {
            HitTestFD(targetLivepuid, body, authdataProvider, LcserviceId.TestAPI, ref response);
        }

        [Conditional("DEBUG")]
        public void HitTestFD(ulong targetLivepuid, byte[] body, IAccountAuthDataProvider authdataProvider, LcserviceId service, ref byte[] response)
        {
            if (targetLivepuid == 0)
            {
                throw new ArgumentException("invalid target livepuid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            LivecacheRequest lcReq = new LivecacheRequest(targetLivepuid,
                                                client,
                                                service,
                                                body,
                                                0,
                                                titleId,
                                                authdataProvider,
                                                null,
                                                null,
                                                null);

            lcReq.ContentTypeOverride = "application/x-www-form-urlencoded";

            if (lcReq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            response = lcReq.ResponseData;
        }

        [Conditional("DEBUG")]
        public void HitTestFDWithDependency(ulong targetLivepuid, byte[] body, IAccountAuthDataProvider authdataProvider, LcserviceId serviceID, LivecacheDependency dependency, ref byte[] response)
        {
            if (targetLivepuid == 0)
            {
                throw new ArgumentException("invalid target livepuid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            LivecacheRequest lcReq = new LivecacheRequest(targetLivepuid,
                                                client,
                                                serviceID,
                                                body,
                                                0,
                                                titleId,
                                                authdataProvider,
                                                dependency,
                                                null,
                                                null);

            lcReq.ContentTypeOverride = "application/x-www-form-urlencoded";

            if (lcReq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            response = lcReq.ResponseData;
        }


        [Conditional("DEBUG")]
        public void InvalidateTestFD(ulong targetLivepuid, byte[] body, IAccountAuthDataProvider authdataProvider, LcserviceId serviceID, LivecacheDependency dependency, ref byte[] response)
        {
            if (targetLivepuid == 0)
            {
                throw new ArgumentException("invalid target livepuid");
            }
            if (authdataProvider == null)
            {
                throw new ArgumentNullException("authdataProvider");
            }

            LivecacheRequest lcReq = new LivecacheRequest(targetLivepuid,
                                                client,
                                                serviceID,
                                                body,
                                                0,
                                                titleId,
                                                authdataProvider,
                                                null,
                                                dependency,
                                                null);

            lcReq.ContentTypeOverride = "application/x-www-form-urlencoded";

            if (lcReq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            response = lcReq.ResponseData;
        }
    }

    public enum XuserDataType : byte
    {
        Context = 0x0,
        Int32 = 0x1,
        Int64 = 0x2,
        Double = 0x3,
        Unicode = 0x4,
        Float = 0x5,
        Binary = 0x6,
        DateTime = 0x7,
        Null = 0xF
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcBillingOffering.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.user;

namespace xonline.common.webplatform.livecache
{
    public class LcBillingOffering : ILcBillingOffering
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("BillingOffering", "WebPlatform_Livecache");

        private IAccountAuthDataProvider authdataProvider;
        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint titleId;
        private bool _supressPrivateData = true;

        public LcBillingOffering(LivecacheClientType clientType, uint clientTitleId, IAccountAuthDataProvider authDataProvider, bool supressPrivateData)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }
            if (authDataProvider == null)
            {
                throw new ArgumentNullException("authDataProvider");
            }
            client = clientType;
            titleId = clientTitleId;
            authdataProvider = authDataProvider;
            _supressPrivateData = supressPrivateData;
        }

        /// <summary>
        /// Get user subscritpion details
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="authDataProvider">user privileges</param>
        /// <returns>XeGetUserSubscriptionDetailsResponse</returns>
        public XeGetUserSubscriptionDetailsResponse GetUserSubscriptionDetails(XeGetUserSubscriptionDetailsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("userPuid can't be 0");
            }
            if (request.offerId == 0)
            {
                throw new ArgumentException("offerId can't be 0");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.GetUserSubscriptionDetails,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        LivecacheDependencies.UserAccount(request.userPuid),
                                                        null);
            uint hr = 1;
            hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            XeGetUserSubscriptionDetailsResponse resp = new XeGetUserSubscriptionDetailsResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        /// <summary>
        /// get account point balance (realtime)
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="authDataProvider"></param>
        /// <returns></returns>
        public XeGetPointsBalanceResponse GetPointsBalance(XeGetPointsBalanceRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("userPuid can't be 0");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.GetPointsBalance,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        LivecacheDependencies.UserAccount(request.userPuid),
                                                        null);
            uint hr = 1;
            hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            XeGetPointsBalanceResponse resp = new XeGetPointsBalanceResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        /// <summary>
        /// get account point balance (cached)
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="authDataProvider"></param>
        /// <returns></returns>
        public XeGetPointsBalanceResponse GetCachedPointsBalance(XeGetPointsBalanceRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("userPuid can't be 0");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.GetCachedPointsBalance,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        LivecacheDependencies.UserAccount(request.userPuid),
                                                        null);
            uint hr = 1;
            hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            XeGetPointsBalanceResponse resp = new XeGetPointsBalanceResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="authDataProvider"></param>
        /// <returns>HResult</returns>
        public uint ChangeSubscriptionPaymentInstrument(ChangeSubscriptionPaymentInstrumentRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("userPuid can't be 0");
            }

            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.ChangeSubscriptionPaymentInstrument,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        LivecacheDependencies.UserAccount(request.userPuid));

            return lcReq.Send();
        }

        public void AddPaymentInstrument(AddPaymentInstrumentRequest request, out string paymentInstrumentID)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.AddPaymentInstrument,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        LivecacheDependencies.UserAccount(request.userPuid));
            lcReq.IsPrivate = _supressPrivateData;
            if (lcReq.Send() != HResult.S_OK)
            {
                _logArea.LogInfo("AddPaymentInstrument failed: {0}", lcReq.Hr.ToString());
                paymentInstrumentID = null;

                if (lcReq.Hr == HResult.XONLINE_E_BILLING_BADZIP ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_CITY_INVALID ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID3 ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID4 ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_ZIP_INVALID_FOR_ENTERED_STATE ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_COVERS_MULTIPLE_CITIES ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND)
                {
                    throw new InvalidPostalCodeException(lcReq.Hr, "Adding payment instrument failed");
                }
                else if (lcReq.Hr == HResult.XONLINE_E_BILLING_INVALID_CREDIT_CARD_NUMBER)
                {
                    throw new InvalidCardNumberException();
                }
                else if (lcReq.Hr == HResult.XONLINE_E_BILLING_AUTHORIZATION_FAILED)
                {
                    throw new BillingAuthorizationFailedException();
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }

            AddPaymentInstrumentResponse resp = new AddPaymentInstrumentResponse();
            resp.SetBytes(lcReq.ResponseData);
            paymentInstrumentID = resp.paymentInstrumentId;
        }

        public void AddPaymentInstrumentEx(AddPaymentInstrumentRequestEx request, out string paymentInstrumentID)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.AddPaymentInstrumentEx,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        LivecacheDependencies.UserAccount(request.userPuid));
            lcReq.IsPrivate = _supressPrivateData;
            if (lcReq.Send() != HResult.S_OK)
            {
                _logArea.LogInfo("AddPaymentInstrumentEx failed: {0}", lcReq.Hr.ToString());
                paymentInstrumentID = null;

                if (lcReq.Hr == HResult.XONLINE_E_BILLING_BADZIP ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_CITY_INVALID ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID3 ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID4 ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_ZIP_INVALID_FOR_ENTERED_STATE ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_STATE_ZIP_COVERS_MULTIPLE_CITIES ||
                    lcReq.Hr == HResult.XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND)
                {
                    throw new InvalidPostalCodeException(lcReq.Hr, "Adding payment instrument failed");
                }
                else if (lcReq.Hr == HResult.XONLINE_E_BILLING_INVALID_CREDIT_CARD_NUMBER)
                {
                    throw new InvalidCardNumberException();
                }
                else if (lcReq.Hr == HResult.XONLINE_E_BILLING_AUTHORIZATION_FAILED)
                {
                    throw new BillingAuthorizationFailedException();
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }

            AddPaymentInstrumentResponse resp = new AddPaymentInstrumentResponse();
            resp.SetBytes(lcReq.ResponseData);
            paymentInstrumentID = resp.paymentInstrumentId;
        }

        public uint UpdatePaymentInstrument(UpdatePaymentInstrumentRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            Validate(request.creditCardInfo);

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.UpdatePaymentInstrument,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        LivecacheDependencies.UserAccount(request.userPuid));
            lcreq.IsPrivate = _supressPrivateData;
            uint hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                _logArea.LogInfo("UpdatePaymentInstrument failed: {0:X}", hr.ToString("x"));
            }
            return hr;
        }

        public GetPaymentInstrumentsResponse GetPaymentInstruments(GetPaymentInstrumentsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.GetPaymentInstruments,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        LivecacheDependencies.UserAccount(request.userPuid),
                                                        null);
            lcreq.IsPrivate = _supressPrivateData;
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            // TODO: why would this be zero bytes?
            if (lcreq.ResponseData.Length == 0)
            {
                return null;
            }

            GetPaymentInstrumentsResponse resp = new GetPaymentInstrumentsResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public void RemovePaymentInstrument(RemovePaymentInstrumentRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            if (String.IsNullOrEmpty(request.paymentInstrumentId))
            {
                throw new ArgumentException("invalid paymentInstrumentId");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.RemovePaymentInstrument,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        LivecacheDependencies.UserAccount(request.userPuid));
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }
        }

        public BasicSubscriptionInfo[] EnumerateSubscriptionOffers(SubscriptionEnumerateRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency dependency = null;
            if (request.queryForCurrent || request.queryForSuspended)
            {
                dependency = LivecacheDependencies.UserAccount(request.userPuid);
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.SubscriptionEnum,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        dependency,
                                                        null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            SubscriptionEnumerateResponse resp = new SubscriptionEnumerateResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp.infos;
        }

        public ContentEnumerateResponse EnumerateContent(ContentEnumerateRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.ContentEnum,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            ContentEnumerateResponse response = new ContentEnumerateResponse();
            response.SetBytes(lcreq.ResponseData);
            return response;
        }

        public uint OfferingVerifyToken(ulong livePuid, XeOfferingVerifyTokenRequest request, out XeOfferingVerifyTokenResponse tokenInfo)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.OfferingVerifyToken,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                tokenInfo = null;
                return lcreq.Hr;
            }

            tokenInfo = new XeOfferingVerifyTokenResponse();
            tokenInfo.SetBytes(lcreq.ResponseData);
            return HResult.S_OK;
        }

        public uint CancelOffer(OfferingCancelRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }
            LivecacheDependency invalidate = LivecacheDependencies.UserAccount(request.userPuid);

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.CancelOffer,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            if (lcreq.Send() != HResult.S_OK)
            {
                _logArea.LogInfo("CancelOffer failed: {0}", lcreq.Hr.ToString());
                return lcreq.Hr;
            }

            return HResult.S_OK;
        }

        public uint PurchaseSubscription(XeOfferPurchaseRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                        client,
                                        LcserviceId.PurchaseSubscription,
                                        request,
                                        titleId,
                                        authdataProvider,
                                        null,
                                        LivecacheDependencies.UserAccount(request.userPuid));
            uint hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                _logArea.LogInfo("PurchaseSubscription failed: {0:X}", hr.ToString("x"));
            }
            return hr;
        }

        public uint PurchasePoints(XeOfferPurchaseRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                        client,
                                        LcserviceId.PurchasePoints,
                                        request,
                                        titleId,
                                        authdataProvider,
                                        null,
                                        LivecacheDependencies.UserAccount(request.userPuid));
            uint hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                _logArea.LogInfo("PurchasePoints failed: {0:X}", hr.ToString("x"));
            }
            return hr;
        }

        public SubscriptionDetailsResponse GetSubscriptionOfferDetails(SubscriptionDetailsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            request.userPuid = 1;

            LivecacheRequest lcreq = new LivecacheRequest(1, //cached for all users
                                                        client,
                                                        LcserviceId.SubscriptionDetails,
                                                        request,
                                                        titleId,
                                                        null);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            SubscriptionDetailsResponse resp = new SubscriptionDetailsResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public uint GetContentOfferDetails(ContentDetailsRequest request, out ContentDetailsResponse response)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            request.userPuid = 1;

            response = new ContentDetailsResponse();
            LivecacheRequest lcreq = new LivecacheRequest(1,
                                                        client,
                                                        LcserviceId.ContentDetails,
                                                        request,
                                                        titleId,
                                                        null);
            uint hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                switch (hr)
                {
                    case HResult.XOFF_E_INVALID_OFFER_ID:
                        return hr;

                    default:
                        throw new LivecacheResponseException(lcreq);
                }
            }

            response.SetBytes(lcreq.ResponseData);

            return hr;
        }

        public uint PurchaseMediaOffers(PurchaseMediaOffersRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                        client,
                                        LcserviceId.PurchaseMediaOffers,
                                        request,
                                        titleId,
                                        authdataProvider,
                                        null,
                                        LivecacheDependencies.UserAccount(request.userPuid));
            uint hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                _logArea.LogInfo("PurchaseMediaOffers failed: {0:X}", hr.ToString("x"));
            }
            return hr;
        }

        public FindMediaInstanceUrlsResponse FindMediaInstanceUrls(FindMediaInstanceUrlsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(1, //cached for all users
                                                        client,
                                                        LcserviceId.FindMediaInstanceUrls,
                                                        request,
                                                        titleId,
                                                        null);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            FindMediaInstanceUrlsResponse resp = new FindMediaInstanceUrlsResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public LiveCacheWebSvcResponse PurchaseHistory(ulong livePuid, LivecacheWebSvcRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.PurchaseHistory,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        LivecacheDependencies.UserAccount(livePuid),
                                                        null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public LiveCacheWebSvcResponse CachedPurchaseHistory(ulong livePuid, LivecacheWebSvcRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.CachedPurchaseHistory,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        LivecacheDependencies.UserAccount(livePuid),
                                                        null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public uint VerifyToken(XeVerifyTokenRequest request, out XeVerifyTokenResponse response)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.VerifyToken,
                                                        request,
                                                        titleId,
                                                        authdataProvider);

            uint hr = lcreq.Send();
            switch (hr)
            {
                case HResult.S_OK:
                    response = new XeVerifyTokenResponse();
                    response.SetBytes(lcreq.ResponseData);
                    break;
                case HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER:
                case HResult.XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED:
                case HResult.XONLINE_E_ACCOUNTS_VOUCHER_INVALID_FOR_TIER:
                case HResult.XOFF_E_INVALID_OFFER_ID:
                case HResult.E_INVALIDARG:
                case HResult.XOFF_E_INELIGIBLE_FOR_OFFER: /* billing system appears to return this for silver tokens (48 hour gold trials) being redeemed by gold users.  Trap it so we don't throw an exception when someone tries to redeem one - it will display the generic "invalid offer"  */
                    response = null;
                    break;
                default:
                    throw new LivecacheResponseException(lcreq);
            }

            return hr;
        }

        public static void Validate(CreditCardInfoData card)
        {
            if (card == null)
            {
                throw new ArgumentNullException("creditCardInfo");
            }
            if (card.accountHolderName == null
                || card.accountNumber == null
                || card.ccvNumber == null)
            {
                throw new ArgumentException();
            }
        }

        public uint VerifyParentCreditCard(VerifyParentCreditCardRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(0,
                        client,
                        LcserviceId.VerifyParentCreditCard,
                        request,
                        titleId,
                        null);
            lcreq.IsPrivate = _supressPrivateData;
            return lcreq.Send();
        }

        public uint PurchaseGamerTag(XeOfferPurchaseGamertagRequest request, IAccountAuthDataProvider authDataProvider)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("userPuid can't be 0");
            }
            if (!NameUtil.VerifyGamerTag(request.gamertag, false))
            {
                throw new ArgumentException("invalid gamertag");
            }

            LivecacheDependency dependency = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                            client,
                            LcserviceId.PurchaseGamertag,
                            request.GetBytes(),
                            request.machinePuid,
                            titleId,
                            authDataProvider,
                            dependency,
                            dependency,
                            request);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                // _logArea.LogInfo("PurchaseGamerTag failed: {0:X}", hr);
            }

            return hr;
        }
        public PreviewProductPurchaseResponse PreviewProductPurchase(PreviewProductPurchaseRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("Invalid calling userPuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest
                                     (
                                          request.userPuid,
                                          client,
                                          LcserviceId.PreviewProductpurchase,
                                          request,
                                          titleId,
                                          authdataProvider
                                       );

            uint hr = lcreq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            PreviewProductPurchaseResponse resp = new PreviewProductPurchaseResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }
        public LiveCacheWebSvcResponse SubscriptionOfferEnumerate(ulong livePuid, LivecacheWebSvcRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.SubscriptionOfferEnumerate,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        LivecacheDependencies.UserAccount(livePuid),
                                                        null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public AssetConsumeResponse AssetConsume(ulong livePuid, AssetConsumeRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("Invalid calling userPuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.AssetConsume,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        LivecacheDependencies.Assets(livePuid));

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            AssetConsumeResponse resp = new AssetConsumeResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public AssetEnumerateResponse AssetEnumerate(ulong livePuid, AssetEnumerateRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("Invalid calling userPuid");
            }


            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.AssetEnumerate,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        new LivePuidDependency(LiveCacheDependencyBitFlags.UserAccount | LiveCacheDependencyBitFlags.Assets, livePuid),
                                                        null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            AssetEnumerateResponse resp = new AssetEnumerateResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public LiveCacheWebSvcResponse TransferPointsBalance(ulong primaryUserPuid, ulong dependentUserPuid, int pointstoTransfer)
        {
            if (primaryUserPuid == 0)
            {
                throw new ArgumentException("Invalid primary puid");
            }
            if (dependentUserPuid == 0)
            {
                throw new ArgumentException("Invalid dependent puid");
            }
            if (pointstoTransfer < 0)
            {
                throw new ArgumentException("Invalid PointstoTransfer");
            }
            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();
            request.NameValuePairs.Add(new WebServiceNameValuePair("primaryUserPuid", primaryUserPuid.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("dependentUserPuid", dependentUserPuid.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("pointstoTransfer", pointstoTransfer.ToString()));

            LivecacheDependency invalidation = LivecacheDependencies.UserAccount(primaryUserPuid);

            //no depedency. Will invalidate the other apis which have userPuid dependency like GetDepdentPointsBalance and GetPointsBalance
            LivecacheRequest lcreq = new LivecacheRequest(primaryUserPuid,
                                          client,
                                          LcserviceId.TransferPointsBalance,
                                          request,
                                          titleId,
                                          authdataProvider,
                                          null,
                                          invalidation);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public LiveCacheWebSvcResponse GetDependentPointsBalance(ulong primaryUserPuid, ulong dependentUserPuid)
        {
            if (primaryUserPuid == 0)
            {
                throw new ArgumentException("Invalid primary puid");
            }
            if (dependentUserPuid == 0)
            {
                throw new ArgumentException("Invalid dependent puid");
            }
            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();
            request.NameValuePairs.Add(new WebServiceNameValuePair("primaryUserPuid", primaryUserPuid.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("dependentUserPuid", dependentUserPuid.ToString()));

            LivecacheDependency dependency = LivecacheDependencies.UserAccount(primaryUserPuid);

            //Will not invalidate anything.But will get invalidated by transferPointsbalance
            LivecacheRequest lcreq = new LivecacheRequest(primaryUserPuid,
                                          client,
                                          LcserviceId.GetDependentPointsBalance,
                                          request,
                                          titleId,
                                          authdataProvider,
                                          dependency,
                                          null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public GetKeyResponse GetKey(GetKeyRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(1, //cached for all users
                                                        client,
                                                        LcserviceId.GetKey, 
                                                        request,
                                                        titleId,
                                                        null);

            if (lcreq.Send() != HResult.S_OK)
            {
                _logArea.LogInfo("GetKey failed: {0}", lcreq.Hr.ToString());
                throw new LivecacheResponseException(lcreq);
            }

            GetKeyResponse resp = new GetKeyResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public GetMediaLicenseResponse GetMediaLicense(GetMediaLicenseRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid, 
                                                        client,
                                                        LcserviceId.GetMediaLicense,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            GetMediaLicenseResponse respone = new GetMediaLicenseResponse();
            respone.SetBytes(lcreq.ResponseData);
            return respone;
        }

        public PreviewMergeSubscriptionResponse PreviewMergeSubscription(PreviewMergeSubscriptionRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            //make sure that any change in user state invalidates this api
            LivecacheDependency dependency = LivecacheDependencies.UserAccount(request.primaryUserPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.primaryUserPuid,
                client,
                LcserviceId.PreviewMergeSubscription,
                request,
                titleId,
                authdataProvider,
                dependency,//will be invalidated by any subscription purchase calls
                null);
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            PreviewMergeSubscriptionResponse resp = new PreviewMergeSubscriptionResponse();
            resp.SetBytes(lcReq.ResponseData);
            return resp;
        }

        public LiveCacheWebSvcResponse GetUserSubscriptions(ulong livePuid, LivecacheWebSvcRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.GetUserSubscriptions,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcAccountCreation.cs ===
using System;
using xonline.common.billing;
using xonline.common.protocol;
using xonline.common.protocol.useraccount;
using xonline.common.service;
using xonline.common.user;

namespace xonline.common.webplatform.livecache
{

    public class LcAccountCreation : ILcAccountCreation
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("AccountCreation", "WebPlatform_Livecache");
        const ulong Xbox_360_Silver_Subscription_OfferId = 0xFFFE07D180000011;

        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint titleId;
        private IAccountAuthDataProvider authdataProvider;
        private bool _suppressPrivateData = true;

        public LcAccountCreation(LivecacheClientType clientType, uint clientTitleId, bool suppressPrivateData)
            : this(clientType, clientTitleId, null, suppressPrivateData)
        {
        }

        public LcAccountCreation(LivecacheClientType clientType, uint clientTitleId, IAccountAuthDataProvider authdataProvider, bool suppressPrivateData)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }

            client = clientType;
            titleId = clientTitleId;
            this.authdataProvider = authdataProvider;
            _suppressPrivateData = suppressPrivateData;
        }

        /// <summary>
        /// reserve gamertag for given machinePuid. If gamertag is in use, return alternative gamertag list.
        /// </summary>
        /// <param name="client">clientType for livecache request</param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns>alternative gamertag list</returns>
        public ReserveNameSuggestedName[] ReserveGamerTag(ReserveNameRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request.machinePuid == 0)
            {
                throw new LivecacheCodeErrorException("machinePuid is required for reserving gamertag");
            }
            if (!NameUtil.VerifyGamerTag(request.gamertag, false))
            {
                throw new ArgumentException("invalid gamertag");
            }

            LivecacheRequest lcReq = new LivecacheRequest(0,
                client,
                LcserviceId.ReserveName,
                request.GetBytes(),
                request.machinePuid,
                titleId,
                null,
                null,
                null,
                request);

            uint hr = 1;
            hr = lcReq.Send();

            ReserveNameSuggestedName[] alternates = null;
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_S_ACCOUNTS_NAME_TAKEN)
                {
                    ReserveNameResponse resRN = null;
                    resRN = new common.protocol.ReserveNameResponse();
                    resRN.SetBytes(lcReq.ResponseData);
                    if (resRN.nameCount > 0)
                    {
                        alternates = resRN.names;
                    }
                }
                else
                {
                    // Unable to reserve a gamer tag
                    throw new LivecacheResponseException(lcReq);
                }
            }

            return alternates;
        }

        /// <summary>
        /// update user profile to UPS system
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="profile"></param>
        public void UpsUpdateProfile(UpsProfile profile)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }

            if(profile == null)
            {
                throw new ArgumentNullException("profile");
            }
            ulong passportPuid = profile.GetPassportPuid();
            if (passportPuid == 0)
            {
                throw new ArgumentException("passportPuid can't be 0 in ups profile");
            }

            XeUpsUpdateProfileRequest updreq = new XeUpsUpdateProfileRequest();
            updreq.profile = profile.Xml;
            updreq.profileLength = (ushort)updreq.profile.Length;

            LivecacheDependency invalidates = LivecacheDependencies.PassportAccount(passportPuid);
            LivecacheRequest lcReq = new LivecacheRequest(passportPuid,
                        client,
                        LcserviceId.UpsUpdateProfile,
                        updreq,
                        titleId,
                        null,
                        null,
                        invalidates);

            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_PASSPORT_INVALID_POSTAL_CODE)
                {
                    string message = "Call to /xuacs/XeUpsUpdateProfile failed - invalid postal code.";
                    throw new InvalidPostalCodeException(hr, message);
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }

        }

        /// <summary>
        /// retrieve user profile from UPS for defined profile fields
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns></returns>
        public UpsProfile UpsGetProfile(XeUpsGetProfileRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }

            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            ulong passportPuid = request.puid;
            if (passportPuid == 0)
            {
                throw new ArgumentException("request passport puid can't be 0.");
            }

            LivecacheDependency dependency = LivecacheDependencies.PassportAccount(passportPuid);
            LivecacheRequest lcReq = new LivecacheRequest(passportPuid,
                            client,
                            LcserviceId.UpsGetProfile,
                            request,
                            titleId,
                            null,
                            dependency,
                            null);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                // Unable to get ups information
                throw new LivecacheResponseException(lcReq);
            }
            XeUpsGetProfileResponse resp = new XeUpsGetProfileResponse();
            resp.SetBytes(lcReq.ResponseData);
            UpsProfile profile = new UpsProfile(resp.profile);
            return profile;
        }

        /// <summary>
        /// Get the user type (xenon, xbox1,xboxcom) for gamertag.
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns>XeGetUserTypeResponse</returns>
        /// <exception cref="InvalidGamertagException">gamertag not found</exception>
        /// <exception cref="GamertagTakenException">Account is still in processing</exception>
        public XeGetUserTypeResponse GetUserType(XeGetUserTypeRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (!NameUtil.VerifyGamerTag(request.gamertag, false))
            {
                throw new ArgumentException("invalid gamertag");
            }

            LivecacheRequest lcReq = new LivecacheRequest(0,
                        client,
                        LcserviceId.GetUserType,
                        request,
                        titleId,
                        null);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_ACCOUNTS_INVALID_USER)
                {
                    throw new InvalidGamertagException(request.gamertag);
                }
                else if(hr == HResult.XONLINE_E_PUID_IS_MACHINE)
                {
                    throw new GamertagTakenException(request.gamertag);
                }
                else
                {
                    // fail to get user type
                    throw new LivecacheResponseException(lcReq);
                }
            }

            XeGetUserTypeResponse utResp = new XeGetUserTypeResponse();
            utResp.SetBytes(lcReq.ResponseData);
            return utResp;
        }

        /// <summary>
        /// check gamerprofile for existing user
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="livePuid"></param>
        /// <returns>XeGetUserTypeResponse</returns>
        public XeGetUserTypeResponse GetGamerProfileTypes(XeGetUserTypeRequest request, ulong livePuid)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (!NameUtil.VerifyGamerTag(request.gamertag, false))
            {
                throw new ArgumentException("invalid gamertag");
            }
            if (livePuid == 0)
            {
                throw new ArgumentException("livePuid can't be 0.");
            }

            LivecacheDependency dependency = LivecacheDependencies.UserAccount(livePuid).AddStats();
            LivecacheRequest lcReq = new LivecacheRequest(livePuid,
                        client,
                        LcserviceId.GetGamerProfileTypes,
                        request,
                        titleId,
                        null,
                        dependency,
                        null);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_ACCOUNTS_INVALID_USER)
                {
                    throw new InvalidGamertagException(request.gamertag);
                }
                else if(hr == HResult.XONLINE_E_PUID_IS_MACHINE)
                {
                    throw new GamertagTakenException(request.gamertag);
                }
                else
                {
                    // fail to get user type
                    throw new LivecacheResponseException(lcReq);
                }
            }

            common.protocol.XeGetUserTypeResponse utResp = new common.protocol.XeGetUserTypeResponse();
            utResp.SetBytes(lcReq.ResponseData);
            return utResp;
        }

        /// <summary>
        /// verify parent credit card
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns>HResult</returns>
        public uint VerifyParentCreditCard(VerifyParentCreditCardRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(0,
                        client,
                        LcserviceId.VerifyParentCreditCard,
                        request,
                        titleId,
                        null);
            lcreq.IsPrivate = _suppressPrivateData;
            return lcreq.Send();
        }

        /// <summary>
        /// verify parent credit card
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns>HResult</returns>
        public uint VerifyParentCreditCardEx(VerifyParentCreditCardRequestEx request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            LivecacheRequest lcreq = new LivecacheRequest(0,
                        client,
                        LcserviceId.VerifyParentCreditCardEx,
                        request,
                        titleId,
                        null);
            lcreq.IsPrivate = _suppressPrivateData;
            return lcreq.Send();
        }

        /// <summary>
        /// Creates xbox live account for new user in live-enabled culture
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns>account livePuid</returns>
        public ulong CreateXboxLiveAccount(CreateLiveAccountRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.signedUserPassportPuid.Length == 0)
            {
                throw new ArgumentException("invalid user passport puid");
            }

            ulong passportPuid = LivecacheUtil.GetPuidFromBytes(request.signedUserPassportPuid);

            LivecacheDependency invalidates = LivecacheDependencies.PassportAccount(passportPuid);
            LivecacheRequest lcReq = new LivecacheRequest(passportPuid,
                                    client,
                                    LcserviceId.CreateLiveAccount,
                                    request.GetBytes(),
                                    request.machinePuid,
                                    titleId,
                                    null,
                                    null,
                                    invalidates,
                                    request);
            lcReq.IsPrivate = _suppressPrivateData;
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_BILLING_BADZIP ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID3 ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID4 ||
                    hr == HResult.XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND)
                {
                    throw new InvalidPostalCodeException(hr, "Creating Xbox live account failed");
                }
                // Unable to create account
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            CreateLiveAccountResponse response = new CreateLiveAccountResponse();
            response.SetBytes(lcReq.ResponseData);
            return response.userPuid;

        }

        /// <summary>
        /// Creates xboxcom user for new user not in live-enabled culture
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns>account livepuid</returns>
        public ulong CreateXboxComAccount(CreateXboxComAccountRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPassportPuid == 0)
            {
                throw new ArgumentException("invalid user passport puid");
            }

            LivecacheDependency invalidates = LivecacheDependencies.PassportAccount(request.userPassportPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPassportPuid,
                client,
                LcserviceId.CreateXboxComAccount,
                request.GetBytes(),
                request.machinePuid,
                titleId,
                null,
                null,
                invalidates,
                request);
            lcReq.IsPrivate = _suppressPrivateData;
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_BILLING_BADZIP ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID3 ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID4 ||
                    hr == HResult.XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND)
                {
                    throw new InvalidPostalCodeException(hr, "Creating Xbox web account failed");
                }

                // Unable to create account
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            CreateXboxComAccountResponse response = new CreateXboxComAccountResponse();
            response.SetBytes(lcReq.ResponseData);
            return response.userPuid;
        }

        /// <summary>
        /// Links a web account(passport) for xbox1 non linked users
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns>account livepuid</returns>
        /// <exception cref="UnderAgeAccountException"/>
        /// <exception cref="LivecacheResponseException"/>
        public ulong LinkWebAccount(LinkWebAccountRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.webId.Length == 0)
            {
                throw new ArgumentException("invalid user passport puid (webId)");
            }
            if (!NameUtil.VerifyGamerTag(request.gamertag, false))
            {
                throw new ArgumentException("invalid gamertag");
            }

            ulong passportPuid = LivecacheUtil.GetPuidFromBytes(request.webId);
            LivecacheDependency invalidates = LivecacheDependencies.PassportAccount(passportPuid);
            LivecacheRequest lcReq = new LivecacheRequest(passportPuid,
                            client,
                            LcserviceId.LinkWebAccount,
                            request,
                            titleId,
                            null,
                            null,
                            invalidates);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_ACCOUNTS_UNDER_AGE)
                {
                    string message = "Call to /xuacs/linkwebaccount failed - the user is under age, hr=0x" + hr.ToString("X8") + "\r\nRequest:\r\n" + request.ToString();
                    throw new UnderAgeAccountException(message);
                }
                else
                {
                    // Unable to link web account
                    throw new LivecacheResponseException(lcReq);
                }
            }

            // get the response
            LinkWebAccountResponse response = new LinkWebAccountResponse();
            response.SetBytes(lcReq.ResponseData);
            return response.userPuid;
        }

        /// <summary>
        /// Link xbox1 unlinked account with owner/user passport puid
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        public void LinkXbox1Account(LinkXbox1AccountRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.signedUserPassportPuid.Length == 0)
            {
                throw new ArgumentException("invalid user passport puid");
            }
            if (request.signedOwnerPassportPuid.Length == 0)
            {
                throw new ArgumentException("invalid owner passport puid");
            }
            if (!NameUtil.VerifyGamerTag(request.gamertag, false))
            {
                throw new ArgumentException("invalid gamertag");
            }
            ulong passportPuid = LivecacheUtil.GetPuidFromBytes(request.signedUserPassportPuid);
            LivecacheDependency invalidates = LivecacheDependencies.PassportAccount(passportPuid);
            LivecacheRequest lcReq = new LivecacheRequest(passportPuid,
                                    client,
                                    LcserviceId.LinkXbox1Account,
                                    request.GetBytes(),
                                    request.machinePuid,
                                    titleId,
                                    null,
                                    null,
                                    invalidates,
                                    request);

            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                // Unable to link xbox1 account
                throw new LivecacheResponseException(lcReq);
            }
        }

        /// <summary>
        /// Get account gamertag and livepuid for given passportpuid
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="passportPuid"></param>
        /// <param name="livePuid"></param>
        /// <param name="gamertag"></param>
        /// <returns>true if account exists, false if no account linked with this passportpuid</returns>
        public bool GetLinkedGamertag(ulong passportPuid, out ulong livePuid, out string gamertag)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (passportPuid == 0)
            {
                throw new ArgumentException("invalid passportPuid");
            }

            GetLinkedGamertagRequest getLinkGamertagReq = new GetLinkedGamertagRequest();
            getLinkGamertagReq.signedPassportPuid = LivecacheUtil.GetSignedPuid(passportPuid);

            LivecacheRequest lcreq = new LivecacheRequest(0,
                client,
                LcserviceId.GetLinkedGamertag,
                getLinkGamertagReq,
                titleId,
                null,
                LivecacheDependencies.PassportAccount(passportPuid),
                null);

            uint hr = 1;
            hr = lcreq.Send();

            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_ACCOUNTS_PASSPORT_NOT_LINKED)
                {
                    _logArea.LogInfo("gamertag not found in database");
                    livePuid = 0;
                    gamertag = String.Empty;
                    return false;
                }

                throw new LivecacheResponseException(lcreq);
            }

            GetLinkedGamertagResponse reply = new GetLinkedGamertagResponse();
            reply.SetBytes(lcreq.ResponseData);

            livePuid = reply.userPuid;
            gamertag = reply.gamertag;

            _logArea.LogInfo("registered user: gamertag={0}, livepuid={1:x}", gamertag, livePuid);
            return true;
        }

        /// <summary>
        /// Gets the account information for xenon, xbox1, xboxcom users
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns>XeGetAccountInfoResponse</returns>
        public XeGetAccountInfoResponse GetAccountInfo(XeGetAccountInfoRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid userPuid");
            }

            LivecacheDependency dependency = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                    client,
                                    LcserviceId.GetAccountInfo,
                                    request,
                                    titleId,
                                    null,
                                    dependency,
                                    null);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            XeGetAccountInfoResponse accRes = new XeGetAccountInfoResponse();
            accRes.SetBytes(lcReq.ResponseData);
            return accRes;
        }

        /// <summary>
        /// update existing user account info
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="authDataProvider">provide user privileges</param>
        public void UpdateXboxAccount(XeSetAccountInfoRequest request, IAccountAuthDataProvider authDataProvider)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("request userPuid can't be 0.");
            }

            LivecacheDependency invalidates = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                            client,
                            LcserviceId.SetAccountInfo,
                            request,
                            titleId,
                            authDataProvider,
                            null,
                            invalidates);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_BILLING_BADZIP ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID3 ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID4 ||
                    hr == HResult.XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND)
                {
                    throw new InvalidPostalCodeException(hr, "Invalid postal code. Updating Xbox account failed");
                }

                // Unable to update account information
                throw new LivecacheResponseException(lcReq);
            }
        }

        /// <summary>
        /// update user privileges
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="context">ensure Update Parental Controls is called only once in current context</param>
        /// <param name="authDataProvider">authdata provide current user privileges</param>
        public void UpdateParentalControls(UpdateParentalControlsRequest request, IContextItemProvider context, IAccountAuthDataProvider authDataProvider)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid userPuid");
            }

            // Force presence to load the online record for this user,
            //update privilege API needs presence data available
            LcPresence pda = new LcPresence(client, titleId, context, authDataProvider);
            pda.SendWebAlive(request.userPuid);

            LivecacheDependency invalidates = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                client,
                                LcserviceId.UpdateParentalControls,
                                request,
                                titleId,
                                authDataProvider,
                                null,
                                invalidates);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }
        }


        /// <summary>
        /// get user privileges
        /// </summary>
        /// <param name="authDataProvider">authdata provide current user privileges</param>
        public GetParentalControlsResponse GetParentalControls(GetParentalControlsRequest request,
            IAccountAuthDataProvider authDataProvider)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid userPuid");
            }

            LivecacheDependency dependencies = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcreq = new LivecacheRequest(request.requestorPuid,
                                client,
                                LcserviceId.GetParentalControls,
                                request,
                                titleId,
                                authDataProvider,
                                dependencies,
                                null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            GetParentalControlsResponse resp = new GetParentalControlsResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        /// <summary>
        /// get existing account passport email names
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="livePuid"></param>
        /// <param name="authDataProvider"></param>
        /// <returns>XePassportGetMemberNameResponse</returns>
        public XePassportGetMemberNameResponse PassportGetMemberName(ulong livePuid, IAccountAuthDataProvider authDataProvider)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (livePuid == 0)
            {
                throw new ArgumentException("livePuid can't be 0");
            }

            XePassportGetMemberNameRequest memberNameReq = new XePassportGetMemberNameRequest();
            memberNameReq.userPuid = livePuid;

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.PassportGetMemberName,
                                                        memberNameReq,
                                                        titleId,
                                                        authDataProvider);
            uint hr = 1;
            hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            XePassportGetMemberNameResponse resp = new XePassportGetMemberNameResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        /// <summary>
        /// return exisitng user webinfo
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns>XeGetUserWebInfoResponse</returns>
        public XeGetUserWebInfoResponse GetUserWebInfo(XeGetUserWebInfoRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("request userPuid can't be 0.");
            }

            LivecacheDependency dep = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                            client,
                                            LcserviceId.GetUserWebInfo,
                                            request,
                                            titleId,
                                            null,
                                            dep,
                                            null);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_ACCOUNTS_SERVICE_NOT_PROVISIONED)
                {
                    throw new ServiceNotProvisionedException(hr, "Account had not accepted TOS yet.");
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }

            XeGetUserWebInfoResponse reply = new XeGetUserWebInfoResponse();
            reply.SetBytes(lcReq.ResponseData);
            return reply;
        }

        /// <summary>
        /// Updates account last web activity date
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="invalidates"></param>
        public void UpdateXboxAccountActivity(XeUpdateXboxComActivityRequest request, LivecacheDependency invalidates)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("request userPuid can't be 0.");
            }

            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                        client,
                        LcserviceId.UpdateXboxComActivity,
                        request,
                        titleId,
                        null,
                        null,
                        invalidates);

            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                // Unable to update web activity date
                throw new LivecacheResponseException(lcReq);
            }
        }

        /// <summary>
        /// VerifyBillingInfo for xbox1 unlinked user
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="livePuid"></param>
        /// <param name="request"></param>
        /// <returns>VerifyBillingInfoResponse</returns>
        public VerifyBillingInfoResponse VerifyBillingInfo(ulong livePuid, VerifyBillingInfoRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (!NameUtil.VerifyGamerTag(request.gamertag, false))
            {
                throw new ArgumentException("invalid gamertag");
            }
            if (livePuid == 0)
            {
                throw new ArgumentException("livePuid can't be 0");
            }

            LivecacheDependency depends = LivecacheDependencies.UserAccount(livePuid);
            LivecacheRequest lcReq = new LivecacheRequest(livePuid,
                        client,
                        LcserviceId.VerifyBillingInfo,
                        request,
                        titleId,
                        null,
                        depends,
                        null);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            VerifyBillingInfoResponse response = new VerifyBillingInfoResponse();
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        /// <summary>
        /// migrate xbox1linked user to xbox360 user
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="livePuid"></param>
        /// <param name="request"></param>
        /// <returns></returns>
        public MigrateXbox1UserResponse MigrateXbox1LinkedUser(ulong livePuid, MigrateXbox1UserRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.signedUserPassportPuid.Length == 0)
            {
                throw new ArgumentException("passportPuid can't be 0");
            }
            if (livePuid == 0)
            {
                throw new ArgumentException("invalid livePuid");
            }

            LivecacheDependency invalidates = LivecacheDependencies.UserAccount(livePuid);
            LivecacheRequest lcReq = new LivecacheRequest(livePuid,
                        client,
                        LcserviceId.MigrateXbox1User,
                        request,
                        titleId,
                        null,
                        null,
                        invalidates);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            MigrateXbox1UserResponse response = new MigrateXbox1UserResponse();
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        /// <summary>
        /// migrate xboxcom user to xbox360 silver user in live-enabled country
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="livePuid"></param>
        /// <param name="request"></param>
        /// <returns>MigrateXboxComUserResponse</returns>
        public MigrateXboxComUserResponse MigrateXboxcomUser(ulong livePuid, MigrateXboxComUserRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.signedPassportPuid.Length == 0)
            {
                throw new ArgumentException("passportPuid can't be 0");
            }
            if (livePuid == 0)
            {
                throw new ArgumentException("invalid livePuid");
            }

            //ensure xboxcom user is migrated to xbox360 silver user
            request.offerId = Xbox_360_Silver_Subscription_OfferId;

            LivecacheDependency invalidates = LivecacheDependencies.UserAccount(livePuid);
            LivecacheRequest lcReq = new LivecacheRequest(livePuid,
                                client,
                                LcserviceId.MigrateXboxComUser,
                                request,
                                titleId,
                                null,
                                null,
                                invalidates);
            lcReq.IsPrivate = _suppressPrivateData;
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (Array.IndexOf(BillingConfig.NonBillingUserErrors, hr) == -1)
                {
                    throw new InvalidUserInputException(hr, "User input error occured during xboxcom migration");
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }

            // get the response
            MigrateXboxComUserResponse response = new MigrateXboxComUserResponse();
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        /// <summary>
        /// check if account needs maintenance
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <returns></returns>
        public XeTroubleshootAccountResponse TroubleshootAccount(XeTroubleshootAccountRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("userPuid can't be 0");
            }

            LivecacheDependency dependency = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                            client,
                            LcserviceId.TroubleshootAccount,
                            request,
                            titleId,
                            null,
                            dependency,
                            null);

            lcReq.SchemaVersion = WireData.MakeSchemaVersion(5, 1);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                // Unable to get troubleshoot account information
                throw new LivecacheResponseException(lcReq);
            }

            if (lcReq.ResponseData == null)
            {
                throw new LivecacheResponseException(lcReq,
                    string.Format("XeTroubleshootAccountResponse returned from XeTroubleshootAccount API call is null for user livepuid={0}", request.userPuid));
            }

            XeTroubleshootAccountResponse resp = new XeTroubleshootAccountResponse();
            resp.SetBytes(lcReq.ResponseData);
            return resp;
        }

        /// <summary>
        /// change gamertag for existing live account
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="authDataProvider"></param>
        /// <returns>true: changeGamerTag succeed; false: GamerTag taken</returns>
        public bool ChangeGamerTag(ChangeGamertagRequest request, IAccountAuthDataProvider authDataProvider)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("userPuid can't be 0");
            }
            if (!NameUtil.VerifyGamerTag(request.gamertag, false))
            {
                throw new ArgumentException("invalid gamertag");
            }

            LivecacheDependency dependency = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                            client,
                            LcserviceId.ChangeGamerTag,
                            request.GetBytes(),
                            request.machinePuid,
                            titleId,
                            authDataProvider,
                            dependency,
                            dependency,
                            request);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN)
                {
                    //gamertag is reserved
                    return false;
                }
                else
                {
                    throw new LivecacheResponseException(lcReq);
                }
            }
            return true;
        }

        /// <summary>
        /// Accept TOU for existing user
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        public void AcceptTOU(AcceptTermsOfUseRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("userPuid can't be 0");
            }

            LivecacheDependency dependency = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.AcceptTOU,
                                                        request.GetBytes(),
                                                        request.machinePuid,
                                                        titleId,
                                                        null,
                                                        dependency,
                                                        dependency,
                                                        request);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public void AcceptTermsOfService(AcceptTermsOfServiceRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("userPuid can't be 0");
            }

            request.titleId = titleId;

            LivecacheDependency dependency = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.AcceptTermsOfService,
                                                        request.GetBytes(),
                                                        request.machinePuid,
                                                        titleId,
                                                        null,
                                                        dependency,
                                                        dependency,
                                                        request);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public XePassportGetPuidFromMemberNameResponse PassportGetPuidFromMemberName(XePassportGetPuidFromMemberNameRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (!NameUtil.VerifyEmail(request.memberName))
            {
                throw new ArgumentException("invaild email name");
            }

            LivecacheRequest lcReq = new LivecacheRequest(0,
                    client,
                    LcserviceId.PassportGetPuidFromMemberName,
                    request,
                    titleId,
                    null);
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            if (lcReq.ResponseData == null)
            {
                throw new LivecacheResponseException(lcReq,
                    string.Format("XePassportGetPuidFromMemberNameResponse returned from XePassportGetPuidFromMemberName API call is null for email={0}", request.memberName));
            }

            XePassportGetPuidFromMemberNameResponse resp = new XePassportGetPuidFromMemberNameResponse();
            resp.SetBytes(lcReq.ResponseData);
            return resp;
        }

        public void GraduateUser(GraduateUserRequest request)
        {
            LivecacheDependency invalidation = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid, client, LcserviceId.GraduateUser, request,
                titleId, authdataProvider, null, invalidation);
            lcReq.IsPrivate = _suppressPrivateData;
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public LiveCacheWebSvcResponse GetUserAuthorization( ulong livePuid, int serviceType, bool useCache )
        {
            return GetUserAuthorization( livePuid, serviceType, titleId, useCache );
        }

        public LiveCacheWebSvcResponse GetUserAuthorization(ulong livePuid, int serviceType)
        {
            return GetUserAuthorization(livePuid, serviceType, true);
        }

        public LiveCacheWebSvcResponse GetUserAuthorization( ulong livePuid, int serviceType, uint titleId, bool useCache )
        {
            uint defaultSchemaVersion = WireData.MakeSchemaVersion( 7, 0 );
            return GetUserAuthorization( livePuid, serviceType, titleId, useCache, defaultSchemaVersion );
        }

        public LiveCacheWebSvcResponse GetUserAuthorization(ulong livePuid, int serviceType, uint titleId, bool useCache, uint schemaVersion )
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }

            if (livePuid == 0)
            {
                throw new ArgumentException("livePuid can't be 0");
            }

            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();
            request.NameValuePairs.Add(new WebServiceNameValuePair("serviceType", serviceType.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("titleId", titleId.ToString()));

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                            client,
                                            useCache ? LcserviceId.GetUserAuthorization : LcserviceId.GetUserAuthorizationNoCache,
                                            request,
                                            titleId,
                                            authdataProvider,
                                            LivecacheDependencies.UserAccount(livePuid),
                                            null);

            lcreq.SchemaVersion = schemaVersion;

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public EnumFamilyMembersResponse EnumFamilyMembers(EnumFamilyMembersRequest request)
        {
            LivecacheDependency dependency = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                client,
                LcserviceId.EnumFamilyMembers,
                request,
                titleId,
                authdataProvider,
                dependency,
                null);
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            EnumFamilyMembersResponse resp = new EnumFamilyMembersResponse();
            resp.SetBytes(lcReq.ResponseData);
            return resp;
        }

        public void AddDependent(AddDependentRequest request)
        {
            LivecacheDependency invalidates = LivecacheDependencies.UserAccount(request.ownerPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.ownerPuid,
                client,
                LcserviceId.AddDependent,
                request,
                titleId,
                authdataProvider,
                null,
                invalidates);
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public void RemoveDependent(RemoveDependentRequest request)
        {
            LivecacheDependency invalidates = LivecacheDependencies.UserAccount(request.ownerPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.ownerPuid,
                client,
                LcserviceId.RemoveDependent,
                request,
                titleId,
                authdataProvider,
                null,
                invalidates);
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public FamilySubscriptionGoldUserCountResponse FamilySubscriptionGoldUserCount(FamilySubscriptionGoldUserCountRequest request)
        {
            LivecacheDependency dependency = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                client,
                LcserviceId.FamilySubscriptionGoldUserCount,
                request,
                titleId,
                authdataProvider,
                dependency,
                null);
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            FamilySubscriptionGoldUserCountResponse resp = new FamilySubscriptionGoldUserCountResponse();
            resp.SetBytes(lcReq.ResponseData);
            return resp;
        }

        public void FamilySubscriptionAssignGoldUser(FamilySubscriptionAssignGoldUserRequest request)
        {
            LivecacheDependency invalidates = LivecacheDependencies.UserAccount(request.ownerPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.ownerPuid,
                client,
                LcserviceId.FamilySubscriptionAssignGoldUser,
                request,
                titleId,
                authdataProvider,
                null,
                invalidates);
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public void FamilySubscriptionRemoveGoldUser(FamilySubscriptionRemoveGoldUserRequest request)
        {
            LivecacheDependency invalidates = LivecacheDependencies.UserAccount(request.ownerPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.ownerPuid,
                client,
                LcserviceId.FamilySubscriptionRemoveGoldUser,
                request,
                titleId,
                authdataProvider,
                null,
                invalidates);
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public GenerateGamertagResponse GenerateGamertag(GenerateGamertagRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (0 == titleId)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (0 == request.machinePuid)
            {
                throw new LivecacheCodeErrorException("machinePuid is required for generating gamertags");
            }

            LivecacheRequest lcReq = new LivecacheRequest(LivecacheRequest.PublicRequestLivePuid,
                client,
                LcserviceId.GenerateGamertag,
                request.GetBytes(),
                request.machinePuid,
                titleId,
                null,
                null,
                null,
                request);

            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            GenerateGamertagResponse resp = new GenerateGamertagResponse();
            resp.SetBytes(lcReq.ResponseData);
            return resp;
        }

        /// <summary>
        /// Create new XBox user
        /// </summary>
        public ulong CreateUserAndBillableAccount(CreateUserAndBillableAccountRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.signedUserPassportPuid.Length == 0)
            {
                throw new ArgumentException("invalid user passport puid");
            }

            ulong passportPuid = LivecacheUtil.GetPuidFromBytes(request.signedUserPassportPuid);

            LivecacheDependency invalidates = LivecacheDependencies.PassportAccount(passportPuid);
            LivecacheRequest lcReq = new LivecacheRequest(passportPuid,
                                    client,
                                    LcserviceId.CreateUserAndBillableAccount,
                                    request.GetBytes(),
                                    request.machinePuid,
                                    titleId,
                                    null,
                                    null,
                                    invalidates,
                                    request);
            lcReq.IsPrivate = _suppressPrivateData;
            uint hr = 1;
            hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                if (hr == HResult.XONLINE_E_BILLING_BADZIP ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID3 ||
                    hr == HResult.XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID4 ||
                    hr == HResult.XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND)
                {
                    throw new InvalidPostalCodeException(hr, "Creating Xbox live account failed");
                }
                // Unable to create account
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            CreateUserAndBillableAccountResponse response = new CreateUserAndBillableAccountResponse();
            response.SetBytes(lcReq.ResponseData);
            return response.userPuid;
        }

        /// <summary>
        /// Create a generated Passport user
        /// </summary>
        public PassportCreateGeneratedResponse PassportCreateGenerated(PassportCreateGeneratedRequest request)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("TitleId can't be 0.");
            }
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.machinePuid == 0)
            {
                throw new ArgumentException("machinePuid can't be 0.");
            }
            if (request.sessionKey.Length == 0)
            {
                throw new ArgumentException("invalid sessionKey");
            }
            if (request.sessionIV.Length == 0)
            {
                throw new ArgumentException("invalid sessionIV");
            }

            LivecacheRequest lcReq = new LivecacheRequest(LivecacheRequest.PublicRequestLivePuid,
                client,
                LcserviceId.PassportCreateGenerated,
                request.GetBytes(),
                request.machinePuid,
                titleId,
                null,
                null,
                null,
                request);

            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            PassportCreateGeneratedResponse resp = new PassportCreateGeneratedResponse();
            resp.SetBytes(lcReq.ResponseData);
            return resp;
        }

        public void SwitchUserCountry(SwitchUserCountryRequest request)
        {
            LivecacheDependency invalidation = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid, client, LcserviceId.SwitchUserCountry, request,
                titleId, authdataProvider, null, invalidation);
            lcReq.IsPrivate = _suppressPrivateData;
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public void SwitchUserCountryV2(SwitchUserCountryRequest request)
        {
            LivecacheDependency invalidation = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid, client, LcserviceId.SwitchUserCountryV2, request,
                titleId, authdataProvider, null, invalidation);
            lcReq.IsPrivate = _suppressPrivateData;
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public GetParentalControlGroupTemplatesResponse GetParentalControlGroupTemplates(GetParentalControlGroupTemplatesRequest request)
        {
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                client,
                LcserviceId.GetParentalControlGroupTemplates,
                request,
                titleId,
                authdataProvider,
                null,
                null);
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            GetParentalControlGroupTemplatesResponse resp = new GetParentalControlGroupTemplatesResponse();
            resp.SetBytes(lcReq.ResponseData);
            return resp;
        }

        /// <summary>
        /// update user parental control group
        /// </summary>
        /// <param name="client"></param>
        /// <param name="titleId"></param>
        /// <param name="request"></param>
        /// <param name="authDataProvider">authdata provide current user privileges</param>
        public void UpdateParentalControlGroup(UpdateParentalControlGroupRequest request, IAccountAuthDataProvider authDataProvider)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid userPuid");
            }

            LivecacheDependency invalidates = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                client,
                                LcserviceId.UpdateParentalControlGroup,
                                request,
                                titleId,
                                authDataProvider,
                                null,
                                invalidates);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }
        }


        /// <summary>
        /// get user parental control group
        /// </summary>
        /// <param name="authDataProvider">authdata provide current user privileges</param>
        public GetUserParentalControlGroupResponse GetUserParentalControlGroup(GetUserParentalControlGroupRequest request,
            IAccountAuthDataProvider authDataProvider)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.requestorPuid == 0)
            {
                throw new ArgumentException("invalid requestorPuid");
            }

            LivecacheDependency dependencies = LivecacheDependencies.UserAccount(request.requestorPuid);
            LivecacheRequest lcreq = new LivecacheRequest(request.requestorPuid,
                                client,
                                LcserviceId.GetUserParentalControlGroup,
                                request,
                                titleId,
                                authDataProvider,
                                dependencies,
                                null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            GetUserParentalControlGroupResponse resp = new GetUserParentalControlGroupResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }


        public LiveCacheWebSvcResponse UserAccountAuthorize(ulong livePuid, int serviceType, uint titleId)
        {
            if (serviceType == 0)
            {
                throw new ArgumentException("serviceType can't be 0.");
            }

            if (titleId == 0)
            {
                throw new ArgumentException("titleId can't be 0");
            }

            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();
            request.NameValuePairs.Add(new WebServiceNameValuePair("serviceType", serviceType.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("titleId", titleId.ToString()));

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                            client,
                                            LcserviceId.UserAccountAuthorize,
                                            request,
                                            titleId,
                                            authdataProvider,
                                            LivecacheDependencies.UserAccount(livePuid),
                                            null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public void MergeUserEntitlements(MergeUserEntitlementsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            if (request.destUserPuid == 0)
            {
                throw new ArgumentException("destination user can't be 0");
            }

            LivecacheRequest lcReq = new LivecacheRequest(request.destUserPuid,
                client,
                LcserviceId.MergeUserEntitlements,
                request,
                titleId,
                authdataProvider,
                null,
                LivecacheDependencies.UserAccount(request.destUserPuid)
                );

            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        public PreviewSwitchUserCountryResponse PreviewSwitchUserCountry(PreviewSwitchUserCountryRequest request)
        {
            LivecacheDependency invalidation = LivecacheDependencies.UserAccount(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid, client, LcserviceId.PreviewSwitchUserCountry, request,
                titleId, authdataProvider, null, invalidation);
            lcReq.IsPrivate = _suppressPrivateData;
            uint hr = lcReq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            var resp = new PreviewSwitchUserCountryResponse();
            resp.SetBytes(lcReq.ResponseData);
            return resp;
        }

        public LiveCacheWebSvcResponse GetSupportedCountries( ulong livePuid, int serviceType, byte platformType )
        {
            if (livePuid == 0)
            {
                throw new ArgumentException("livePuid can't be 0");
            }

            if (serviceType == 0)
            {
                throw new ArgumentException("serviceType can't be 0.");
            }

            if (platformType == 0)
            {
                throw new ArgumentException("platformType can't be 0.");
            }

            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();
            request.NameValuePairs.Add( new WebServiceNameValuePair( "serviceType", serviceType.ToString() ) );
            request.NameValuePairs.Add( new WebServiceNameValuePair( "platformType", platformType.ToString() ) );

            LivecacheRequest lcreq = new LivecacheRequest( livePuid,
                                            client,
                                            LcserviceId.GetSupportedCountries,
                                            request,
                                            titleId,
                                            authdataProvider,
                                            LivecacheDependencies.UserAccount( livePuid ),
                                            null );

            if ( lcreq.Send() != HResult.S_OK )
            {
                throw new LivecacheResponseException( lcreq );
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes( lcreq.ResponseData );
            return resp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcServerSideDownloadQueue.cs ===
using System;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class LcServerSideDownloadQueue : ILcServerSideDownloadQueue
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("ServerSideDownloadQueue", "WebPlatform_Livecache");

        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint titleId = 0;
        private IAccountAuthDataProvider authdataProvider = null;

        public LcServerSideDownloadQueue(LivecacheClientType clientType, uint clientTitleId, IAccountAuthDataProvider authDataProvider)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }
            if (authDataProvider == null)
            {
                throw new ArgumentNullException("authDataProvider");
            }
            client = clientType;
            titleId = clientTitleId;
            authdataProvider = authDataProvider;
        }

        public CreateDownloadQueueResponse CreateDownloadQueue(CreateDownloadQueueRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency invalidate = LivecacheDependencies.Lists(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.CreateDownloadQueue,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            CreateDownloadQueueResponse response = new CreateDownloadQueueResponse(new CreateListReply());
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public QueryDownloadQueuesResponse QueryDownloadQueues(QueryDownloadQueuesRequest request)
        {
            return QueryDownloadQueues(request, true);
        }

        public QueryDownloadQueuesResponse QueryDownloadQueuesNonCached(QueryDownloadQueuesRequest request)
        {
            return QueryDownloadQueues(request, false);
        }

        private QueryDownloadQueuesResponse QueryDownloadQueues(QueryDownloadQueuesRequest request, bool cacheable)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LcserviceId serviceId = LcserviceId.QueryDownloadQueues;
            if (!cacheable)
            {
                serviceId = LcserviceId.QueryDownloadQueuesNonCached;
            }

            LivecacheDependency dependency = LivecacheDependencies.Lists(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        serviceId,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        dependency,
                                                        null);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            QueryDownloadQueuesResponse response = new QueryDownloadQueuesResponse(new QueryListsReply());
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public QueryDownloadItemsResponse QueryDownloadItems(QueryDownloadItemsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency dependency = LivecacheDependencies.Lists(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.QueryDownloadItems,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        dependency,
                                                        null);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            QueryDownloadItemsResponse response = new QueryDownloadItemsResponse(new QueryItemsReply());
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public InsertDownloadItemsResponse InsertDownloadItems(InsertDownloadItemsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency invalidate = LivecacheDependencies.Lists(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.InsertDownloadItems,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            InsertDownloadItemsResponse response = new InsertDownloadItemsResponse(new InsertItemsReply());
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public DeleteDownloadItemsResponse DeleteDownloadItems(DeleteDownloadItemsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency invalidate = LivecacheDependencies.Lists(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.DeleteDownloadItems,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            DeleteDownloadItemsResponse response = new DeleteDownloadItemsResponse(new DeleteItemsReply());
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public MoveDownloadItemsResponse MoveDownloadItems(MoveDownloadItemsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency invalidate = LivecacheDependencies.Lists(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.MoveDownloadItems,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            MoveDownloadItemsResponse response = new MoveDownloadItemsResponse(new MoveItemsReply());
            response.SetBytes(lcReq.ResponseData);
            return response;
        }

        public ModifyDownloadItemsResponse ModifyDownloadItems(ModifyDownloadItemsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheDependency invalidate = LivecacheDependencies.Lists(request.userPuid);
            LivecacheRequest lcReq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.ModifyDownloadItems,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        invalidate);
            uint hr = 1;
            hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            ModifyDownloadItemsResponse response = new ModifyDownloadItemsResponse(new ModifyItemsReply());
            response.SetBytes(lcReq.ResponseData);
            return response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcXCache.cs ===
using System;

using xonline.common.service;


namespace xonline.common.webplatform.livecache
{
    public class LcXCache : ILcXCache
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("XCache", "WebPlatform_Livecache");

        public static string InvalidGamertag = XCache.InvalidGamertag;
        public const uint CredentialType_Passport = 1;

        public bool LookupWebID(ulong passportPuid, out ulong livePuid, out string gamertag)
        {
            _logArea.LogVerbose("lookup puid {0:x} from xcache", passportPuid);

            try
            {
                byte[] webId = System.BitConverter.GetBytes(passportPuid);
                PUIDAndOwner[] puidAndOwner = XCache.LookupWebID(webId, CredentialType_Passport);

                if (puidAndOwner.Length <= 0)
                {
                    _logArea.LogInfo("livepuid not found in xcache");
                    livePuid = 0;
                    gamertag = String.Empty;
                    return false;
                }

                livePuid = puidAndOwner[0].PUID;
                gamertag = XCache.LookupGamerTag(livePuid);
            }
            catch (System.Threading.ThreadAbortException ex)
            {
                _logArea.LogError(
                    LcSysEventId.XCache_LookupPuidAbort,
                    ex,
                    "LookupXCache by passport puid failed");
                throw;
            }
            catch (Exception ex) // XCache proxy throws generic Exception
            {
                _logArea.LogError(
                    LcSysEventId.XCache_LookupPuid,
                    ex,
                    "LookupXCache failed. Passport PUID=0x{0:X}", passportPuid);
                livePuid = 0;
                gamertag = String.Empty;
                return false;
            }

            if (String.IsNullOrEmpty(gamertag) || (gamertag.Length > 0 && gamertag[0] == '?'))
            {
                _logArea.LogInfo("gamertag not found in xcache");
                return false;
            }

            _logArea.LogInfo("registered user: gamertag={0}, livepuid={1:x}", gamertag, livePuid);
            return true;
        }

        public bool GetOfficialGamerTag(string gamertag, out ulong livePuid, out string officialGamertag)
        {
            if (GetPuidByGamerTag(gamertag, out livePuid))
            {
                ulong[] puidList = new ulong[] { livePuid };

                string[] officialGamertags = null;

                try
                {
                    officialGamertags = XCache.LookupGamerTags(puidList);
                }
                catch (System.Threading.ThreadAbortException ex)
                {
                    _logArea.LogError(
                        LcSysEventId.XCache_LookupGamertagAbort,
                        ex,
                        "LookupXCache by gamertag failed");
                    throw;
                }
                catch (Exception ex) // XCache proxy throws generic Exception
                {
                    _logArea.LogError(
                        LcSysEventId.XCache_LookupGamertag,
                        ex,
                        "XCache.LookupGamerTags failed for livepuid=0x{0:X}", puidList[0]);
                    livePuid = 0;
                    officialGamertag = String.Empty;
                    return false;
                }

                if (officialGamertags.Length <= 0)
                {
                    _logArea.LogInfo("livepuid not found in xcache");
                    livePuid = 0;
                    officialGamertag = String.Empty;
                    return false;
                }

                officialGamertag = officialGamertags[0];
            }
            else
            {
                livePuid = 0;
                officialGamertag = String.Empty;
                return false;
            }

            return true;
        }

        public bool GetPuidByGamerTag(string gamertag, out ulong livePuid)
        {
            _logArea.LogVerbose("lookup gamertag {0} from xcache", gamertag);

            ulong[] puid = null;

            try
            {
                puid = XCache.LookupPUIDs(new string[] { gamertag });
            }
            catch (System.Threading.ThreadAbortException ex)
            {
                _logArea.LogError(
                    LcSysEventId.XCache_LookupGamertagAbort,
                    ex,
                    "LookupXCache by gamertag failed");
                throw;
            }
            catch (System.ArgumentException)
            {
                // Swallow this kind of exception to avoid spamming the application log
                livePuid = 0;
                return false;
            }
            catch (Exception ex) // XCache proxy throws generic Exception
            {
                _logArea.LogError(
                    LcSysEventId.XCache_LookupGamertag,
                    ex,
                    "XCache.LookupPUIDs failed. Gamertag={0}", gamertag);
                livePuid = 0;
                return false;
            }

            if (puid.Length <= 0)
            {
                _logArea.LogInfo("livepuid not found in xcache");
                livePuid = 0;
                return false;
            }

            livePuid = puid[0];

            if (livePuid == 0)
            {
                _logArea.LogInfo("gamertag not found in xcache");
                return false;
            }

            _logArea.LogInfo("registered user: gamertag={0}, livepuid={1:x}", gamertag, livePuid);
            return true;
        }

        public bool GetGamertagByPuid(ulong livePuid, out string gamertag)
        {
            _logArea.LogVerbose("lookup livePuid {0} from xcache", livePuid);

            try
            {
                gamertag = XCache.LookupGamerTag(livePuid);
            }
            catch (System.Threading.ThreadAbortException ex)
            {
                _logArea.LogError(
                    LcSysEventId.XCache_LookupGamertagAbort,
                    ex,
                    "LookupXCache by livePuid failed");
                throw;
            }
            catch (Exception ex) // XCache proxy throws generic Exception
            {
                _logArea.LogError(
                    LcSysEventId.XCache_LookupGamertag,
                    ex,
                    "XCache.LookupGamertag failed. LivePuid={0}", livePuid);
                gamertag = String.Empty;
                return false;
            }

            if (gamertag.Length <= 0)
            {
                _logArea.LogInfo("gamertag not found in xcache");
                gamertag = String.Empty;
                return false;
            }

            _logArea.LogInfo("registered user: gamertag={0}, livepuid={1:x}", gamertag, livePuid);
            return true;
        }


        public bool GetGamertagsByXuid(ulong[] xuids, out string[] gamertags)
        {
            int numXuids = xuids == null ? 0 : xuids.Length;
            _logArea.LogVerbose("looking up {0} gamertags by xuid from xcache", numXuids);

            // if they passed us an empty array, then give them one back
            
            gamertags = new string[numXuids];
            if (numXuids == 0) return false;

            // otherwise do a bulk lookup.  count so we can log  results
            // and return  true if we find at least one of the gamertags

            int numFound = 0;

            try
            {
                XCacheUserResponseData[] xcacheUserResponseData = XCache.LookupUsersByXUID(xuids);

                for (int i = 0; i < xcacheUserResponseData.Length; i++) {
                    gamertags[i] = xcacheUserResponseData[i].szGamertag;
                    if (gamertags[i] != XCache.InvalidGamertag) numFound++;
                }
            }
            catch (System.Threading.ThreadAbortException ex)
            {
                _logArea.LogError(LcSysEventId.XCache_LookupGamertagAbort, ex, "XCache.LookupUsersByXUID failed");
                throw;
            }
            catch (Exception ex) // XCache proxy throws generic Exception
            {
                _logArea.LogError(LcSysEventId.XCache_LookupGamertag, ex, "XCache.LookupUsersByXUID failed.");
                return false;
            }

            _logArea.LogInfo("Found {0} gamertags for {1} xuids", numXuids, numFound);
            return numFound > 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcStringSvr.cs ===
using System;

using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class LcStringSvr : ILcStringSvr
	{
        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint cTitleId;

        public LcStringSvr(LivecacheClientType clientType, uint clientTitleId)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }

            client = clientType;
            cTitleId = clientTitleId;
        }

        /// <summary>
        /// get localized game title or string
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="stringId"></param>
        /// <param name="liveLanguageId"></param>
        /// <param name="responseTTL"></param>
        /// <returns>localized string</returns>
        public string StringLookup(uint titleId, uint stringId, ushort liveLanguageId, out DateTime responseTTL)
        {
            if (titleId == 0)
            {
                throw new ArgumentException("invalid titleId");
            }

            StringLookupRequest stringReq = new StringLookupRequest();
            stringReq.dwTitleID = titleId;
            stringReq.wLanguage = liveLanguageId;
            stringReq.rgdwStringIDs = new uint[] { stringId };

            LivecacheRequest lcReq = new LivecacheRequest(0,
                                            client, 
                                            LcserviceId.StringLookup, 
                                            stringReq,
                                            cTitleId,
                                            null);

            if (lcReq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            responseTTL = lcReq.ResponseExpiry;
            StringLookupResponse stringResp = new StringLookupResponse();  
            stringResp.SetBytes(lcReq.ResponseData);    

            if (stringResp.wNumStrings != 1)
            {
                return "";
            }
            
            return stringResp.rgStringData[0].szString;
        }

        ///***************************************************************************
        //* Purpose: Vet the string passed
        //* Parameters: passport puid, locale, motto
        //* Return value: true if string is offensive
        //****************************************************************************/
        public StringVetResponse VetString(StringVet2Request request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.wNumStrings == 0 || request.rgStringData == null || request.rgStringData.Length == 0)
            {
                throw new ArgumentException("invalid string list");
            }

            LivecacheRequest lcReq = new LivecacheRequest(0,
                                                    client,
                                                    LcserviceId.VetString,
                                                    request,
                                                    cTitleId,
                                                    null);

            if (lcReq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            StringVetResponse vetResp = new StringVetResponse();
            vetResp.SetBytes(lcReq.ResponseData);
            return vetResp;
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcXSig.cs ===
using System;
using xonline.common.protocol;
using xonline.common.service;


namespace xonline.common.webplatform.livecache
{
    public class LcXSig : ILcXSig
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("XSig", "WebPlatform_Livecache");

        private IAccountAuthDataProvider authdataProvider;
        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint titleId;

        public LcXSig(LivecacheClientType clientType, uint clientTitleId, IAccountAuthDataProvider authDataProvider)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }
            if (authDataProvider == null)
            {
                throw new ArgumentNullException("authDataProvider");
            }
            client = clientType;
            titleId = clientTitleId;
            authdataProvider = authDataProvider;
        }

        public RefreshGameLicenseResponse RefreshGameLicense(RefreshGameLicenseRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userId == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userId,
                                                        client,
                                                        LcserviceId.RefreshGameLicense,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            RefreshGameLicenseResponse response = new RefreshGameLicenseResponse();
            response.SetBytes(lcreq.ResponseData);
            return response;
        }

        public GetLicenseTransferStateResponse GetLicenseTransferState(GetLicenseTransferStateRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.GetLicenseTransferState,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            GetLicenseTransferStateResponse response = new GetLicenseTransferStateResponse();
            response.SetBytes(lcreq.ResponseData);

            return response;
        }

        public void UpdateLicenseTransferState(UpdateLicenseTransferStateRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.UpdateLicenseTransferState,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }
        }

        public byte[] GetSignedHeader(uint fileSize, uint fileType, byte[] fileHash)
        {
            if (fileHash == null)
            {
                throw new ArgumentNullException("fileHash");
            }

            if (fileSize == 0)
            {
                throw new ArgumentException("fileSize must be non-zero", "filesize");
            }

            if (fileHash.Length != GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE)
            {
                throw new ArgumentException(String.Format(
                    "fileHash.Length must be exactly {0}, but is {1}.", GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE, fileHash.Length),
                    "fileHash");
            }

            GetSignedHeaderRequest request = new GetSignedHeaderRequest();

            request.fileSize = fileSize;
            request.fileType = fileType;
            request.fileHash = fileHash;

            LivecacheRequest lcreq = new LivecacheRequest(0,
                                                          client,
                                                          LcserviceId.GetSignedHeader,
                                                          request,
                                                          titleId,
                                                          null);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            GetSignedHeaderResponse response = new GetSignedHeaderResponse();
            response.SetBytes(lcreq.ResponseData);

            return response.header;
        }

        public const Int32 DIGEST_LENGTH = 20;
        public void BlacklistDigest(byte[] digest, DigestRevocationDeliveryType deliveryType, string revocationReason)
        {
            BlacklistDigestImpl(digest, 1, (byte)deliveryType, revocationReason);
        }

        public void UnBlacklistDigest(byte[] digest)
        {
            BlacklistDigestImpl(digest, 0, 0, String.Empty);
        }

        private const Int32 MAX_REASON_LENGTH = 80;
        private void BlacklistDigestImpl(byte[] digest, byte status, byte deliveryType, string reason)
        {
            // Check arguments...
            if (digest == null)
            {
                throw new ArgumentNullException("digest");
            }
            if (digest.Length != DIGEST_LENGTH)
            {
                throw new ArgumentException(String.Format("digest.Length must be {0} but is {1}", DIGEST_LENGTH, digest.Length), "digest");
            }
            if (!(status == 0 || status == 1))
            {
                throw new ArgumentException(String.Format("status must be 0 or 1, but is {0}", status, status), "status");
            }
            if (!(deliveryType == 0 || deliveryType == 1 || deliveryType == 2))
            {
                throw new ArgumentException(String.Format("deliveryType must be 0, 1 or 2, but is {0}", deliveryType), "deliveryType");
            }
            if (reason == null)
            {
                throw new ArgumentNullException("reason");
            }
            if (reason.Length == 0 || reason.Length > MAX_REASON_LENGTH)
            {
                throw new ArgumentException(String.Format("reason must be between 0 and {0} in length, but has length {1}", MAX_REASON_LENGTH, reason.Length), "reason");
            }

            // Form-up the request and send it.
            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();
            Array.ForEach(digest, delegate(byte b) { request.NameValuePairs.Add(new WebServiceNameValuePair("digest", b.ToString())); });
            request.NameValuePairs.Add(new WebServiceNameValuePair("status", status.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("deliveryType", deliveryType.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("reason", reason));

            LivecacheRequest lcreq = new LivecacheRequest(0,
                                                          client,
                                                          LcserviceId.SetBlacklistDigestState,
                                                          request,
                                                          titleId,
                                                          authdataProvider);

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }
        }

        public AcknowledgeLicensesDeliveryResponse AcknowledgeLicensesDelivery(AcknowledgeLicensesDeliveryRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.AcknowledgeLicensesDelivery,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            AcknowledgeLicensesDeliveryResponse response = new AcknowledgeLicensesDeliveryResponse();
            response.SetBytes(lcreq.ResponseData);

            return response;
        }

        public AcquireMediaLicensesResponse AcquireMediaLicenses(AcquireMediaLicensesRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userPuid == 0)
            {
                throw new ArgumentException("invalid calling userpuid");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userPuid,
                                                        client,
                                                        LcserviceId.AcquireMediaLicenses,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            AcquireMediaLicensesResponse response = new AcquireMediaLicensesResponse();
            response.SetBytes(lcreq.ResponseData);

            return response;
        }

        public LiveCacheWebSvcResponse CheckLicensesAvailability(
            string[] miids,             // Media instance ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx". 
            string[] oids,              // Offer ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".
            ulong xuid                 // User puid.
        )
        {
            if (miids == null)
            {
                throw new ArgumentNullException("miids");
            }
            if (oids == null)
            {
                throw new ArgumentNullException("oids");
            }

            if (xuid == 0)
            {
                throw new ArgumentException("invalid calling xuid");
            }

            if (miids.Length != oids.Length)
            {
                throw new ArgumentException("miids and oids length do not match");
            }

            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();

            foreach (string s in miids)
            {
                request.NameValuePairs.Add(new WebServiceNameValuePair("miids", s));
            }

            foreach (string s in oids)
            {
                request.NameValuePairs.Add(new WebServiceNameValuePair("oids", s));
            }

            request.NameValuePairs.Add(new WebServiceNameValuePair("xuid", xuid.ToString()));

            LivecacheRequest lcreq = new LivecacheRequest(xuid,
                                                        client,
                                                        LcserviceId.CheckLicensesAvailability,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse response = new LiveCacheWebSvcResponse();
            response.SetBytes(lcreq.ResponseData);

            return response;
        }

        public LiveCacheWebSvcResponse AcquireMediaLicensesWeb(
            string[] miids,             // Media instance ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx". 
            string[] oids,              // Offer ids. Guids in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".
            ulong xuid,                 // User puid.
            string clientInfo           // Client info (from WMRM).
        )
        {
            if (miids == null)
            {
                throw new ArgumentNullException("miids");
            }
            if (oids == null)
            {
                throw new ArgumentNullException("oids");
            }

            if (clientInfo == null)
            {
                throw new ArgumentNullException("clientInfo");
            }
            if (xuid == 0)
            {
                throw new ArgumentException("invalid calling xuid");
            }
            if (miids.Length != oids.Length)
            {
                throw new ArgumentException("miids and oids length do not match");
            }

            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();

            foreach (string s in miids)
            {
                request.NameValuePairs.Add(new WebServiceNameValuePair("miids", s));
            }

            foreach (string s in oids)
            {
                request.NameValuePairs.Add(new WebServiceNameValuePair("oids", s));
            }

            request.NameValuePairs.Add(new WebServiceNameValuePair("xuid", xuid.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("clientInfo", clientInfo));

            LivecacheRequest lcreq = new LivecacheRequest(xuid,
                                                        client,
                                                        LcserviceId.AcquireMediaLicensesWeb,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse response = new LiveCacheWebSvcResponse();
            response.SetBytes(lcreq.ResponseData);

            return response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcSts.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using xonline.common.xboxcom;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.offer;
using xonline.common.user;

namespace xonline.common.webplatform.livecache
{
    public class LcSts : ILcSts
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("Sts", "WebPlatform_Livecache");

        private IAccountAuthDataProvider authdataProvider;
        private LivecacheClientType client = LivecacheClientType.Xboxcom;

        public LcSts(LivecacheClientType clientType, IAccountAuthDataProvider authDataProvider)
        {
            if (authDataProvider == null)
            {
                throw new ArgumentNullException("authDataProvider");
            }
            client = clientType;
            authdataProvider = authDataProvider;
        }

        public LiveCacheWebSvcResponse GetSecurityTicket(ulong livePuid, uint titleId, LivecacheWebSvcRequest request, IAAInfoData infoData)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            if (titleId == 0)
            {
                throw new ArgumentOutOfRangeException("titleId can't be 0.");
            }

            if (infoData == null)
            {
                throw new ArgumentNullException("infoData");
            }

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.GetSecurityTicket,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        null);

            lcreq.AddAAInfoToRequest(new AAInfoLivecache(infoData));

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }

        public LiveCacheWebSvcResponse GetPartnerSecurityTicket(ulong livePuid, uint titleId, LivecacheWebSvcRequest request, IAAInfoData infoData)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            if (infoData == null)
            {
                throw new ArgumentNullException("infoData");
            }

            if (titleId == 0)
            {
                throw new ArgumentOutOfRangeException("titleId can't be 0.");
            }

            LivecacheRequest lcreq = new LivecacheRequest(livePuid,
                                                        client,
                                                        LcserviceId.GetPartnerSecurityTicket,
                                                        request,
                                                        titleId,
                                                        authdataProvider,
                                                        null,
                                                        null);

            lcreq.AddAAInfoToRequest(new AAInfoLivecache(infoData));

            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            LiveCacheWebSvcResponse resp = new LiveCacheWebSvcResponse();
            resp.SetBytes(lcreq.ResponseData);
            return resp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcTitleStorage.cs ===
using System;
using System.IO;
using System.Collections;
using System.Security.Cryptography;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.billing;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class LcTitleStorage : ILcTitleStorage
    {
        const ulong BotdUserPuid = 1;  // TODO: do we have a PUID for "system services"?
        const ulong BotdXboxPuid = 0;

        public void StorageWrite(string path, byte[] data, DateTime expirationDate, byte countryId, LivecacheClientType client)
        {
            StorageWrite(BotdUserPuid, path, data, expirationDate, countryId, client);
        }

        public void StorageWrite(ulong ownerPuid, string path, byte[] data, DateTime expirationDate, byte countryId, LivecacheClientType client)
        {
            StorageWrite(ownerPuid, path, data, expirationDate, countryId, client, XOn.XENON_DASH_TITLE_ID);
        }

        public void StorageWrite(ulong ownerPuid, string path, byte[] data, DateTime expirationDate, byte countryId, LivecacheClientType client, uint titleId)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentNullException("path");
            }
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            if (expirationDate != DateTime.MinValue && expirationDate < DateTime.Now)
            {
                throw new ArgumentException("expirationDate must be in the future");
            }

            ReqHdrWriteFile req = new ReqHdrWriteFile();

            // Set up the base access token
            WriteFileToken token = new WriteFileToken();
            token._operation = (ushort)Operation.FileWrite;
            token._serviceId = (uint)XOService.Storage;
            token._flags = 0;
            token._userPuid = ownerPuid;
            token._xboxPuid = BotdXboxPuid;
            token._pathName = path; // _pathNameSize is set automatically based on this

            // Set up the write access token
            token._tokenExpirationDate = 0;
            token._fileExpirationDate = expirationDate.ToFileTime();
            token._maxFileSize = ProtocolConstants.maxFileSize;

            req._accessToken = token;
            req._titleId = titleId;
            req._titleVersion = 0;
            req._userCountryId = countryId;
            req._compressionType = (byte)CompressionType.Uncompressed;
            req._contentType = (uint)ContentType.ContentBlob;

            // Compute a digest of the file
            SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider();
            req._blobHash = sha1.ComputeHash(data);

            // NOTE: Make the signature the correct size, but leave it all zeroes.
            req._blobSignature = new byte[ProtocolConstants.sizeSignature];

            req._blobSizeUncompressed = (uint)data.Length;
            req._blobSize = (uint)data.Length;
            req._attributes = null; // _attributesSize is set automatically based on this

            // Write the full request into a binary stream
            MemoryStream ostream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(ostream);

            // Write out the request header
            req.WriteTo(writer);

            // Write out the attachment data
            writer.Write(data);

            // Make sure the BinaryWriter is finished writing
            writer.Flush();

            LivecacheDependency invalidate = LivecacheDependencies.TitleStorage(ownerPuid);
            LivecacheRequest lcreq = new LivecacheRequest(ownerPuid,
                                                client,
                                                LcserviceId.StorageWrite,
                                                ostream.ToArray(),
                                                0,
                                                titleId,
                                                null,
                                                null,
                                                invalidate,
                                                req);

            uint hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }
        }

        public void StorageRemove(string path, LivecacheClientType client)
        {
            StorageRemove(BotdUserPuid, path, client);
        }

        public void StorageRemove(ulong ownerPuid, string path, LivecacheClientType client)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentNullException("path");
            }

            ReqRemoveFile req = new ReqRemoveFile();

            // Set up the base access token
            RemoveFileToken token = new RemoveFileToken();
            token._operation = (ushort)Operation.FileRemove;
            token._serviceId = (uint)XOService.Storage;
            token._flags = 0;
            token._userPuid = ownerPuid;
            token._xboxPuid = BotdXboxPuid;
            token._pathName = path; // _pathNameSize is set automatically based on this
            token._signature = null; // _signatureSize is set automatically based on this

            // Set up the delete access token
            token._tokenExpirationDate = 0;

            req._accessToken = token;

            // Set up the request body
            req._titleId = XOn.XENON_DASH_TITLE_ID;
            req._titleVersion = 0;
            req._teamTickets = null;

            // Write the full request into a binary stream
            MemoryStream ostream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(ostream);

            // Write out the request header
            req.WriteTo(writer);

            // Make sure the BinaryWriter is finished writing
            writer.Flush();

            LivecacheDependency invalidate = LivecacheDependencies.TitleStorage(ownerPuid);
            LivecacheRequest lcreq = new LivecacheRequest(ownerPuid,
                                            client,
                                            LcserviceId.StorageRemove,
                                            ostream.ToArray(),
                                            0,
                                            XOn.XENON_DASH_TITLE_ID,
                                            null,
                                            null,
                                            invalidate,
                                            req);

            uint hr = lcreq.Send();
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }
        }

        public byte[] StorageRead(string path, uint titleID, LivecacheClientType client)
        {
            return StorageRead(BotdUserPuid, path, titleID, client);
        }

        public byte[] StorageRead(ulong readerPuid, string path, uint titleID, LivecacheClientType client)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentNullException("path");
            }
            if (titleID == 0)
            {
                throw new ArgumentException("invalid titleID");
            }

            byte[] file = null;

            ReadFileToken t = new ReadFileToken();
            t._operation = (ushort)Operation.FileRead;
            t._version = AccessToken.accessTokenVersion;
            t._serviceId = (uint)XOService.Storage;
            t._userPuid = readerPuid;
            t._xboxPuid = BotdXboxPuid;
            t._pathName = path;

            t._tokenExpirationDate = 0;
            t._signature = null;

            //t._flags    = (uint) ( _teamTickets == null ? 0 : (uint) FlagType.TeamTicket );

            ReqReadFile req = new ReqReadFile();
            req._titleId = titleID;
            req._titleVersion = 0;
            req._userCountryId = 0;  // not actually used by stfd
            req._rangeStart = 0;
            req._rangeEnd = 0;
            req._ifModifiedSinceDate = 0;
            req._accessToken = t;
            req._teamTickets = null;

            // Write the full request into a binary stream
            MemoryStream ostream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(ostream);

            // Write out the request header
            req.WriteTo(writer);

            // Make sure the BinaryWriter is finished writing
            writer.Flush();

            LivecacheDependency dependency = LivecacheDependencies.TitleStorage(readerPuid);
            LivecacheRequest lcreq = new LivecacheRequest(readerPuid,
                                client,
                                LcserviceId.StorageRead,
                                ostream.ToArray(),
                                0,
                                titleID,
                                null,
                                dependency,
                                null,
                                req);

            uint hr = lcreq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            RepHdrReadFile rep = new RepHdrReadFile();
            ostream = new MemoryStream(lcreq.ResponseData);
            BinaryReader reader = new BinaryReader(ostream);
            rep.ReadFrom(reader);

            file = reader.ReadBytes((int)rep._blobSize);

            return file;

        }

        public bool StorageValidate(string path, uint titleID, LivecacheClientType client)
        {
            return StorageValidate(BotdUserPuid, path, titleID, client);
        }

        public bool StorageValidate(ulong readerPuid, string path, uint titleID, LivecacheClientType client)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentNullException("path");
            }
            if (titleID == 0)
            {
                throw new ArgumentException("invalid titleID");
            }

            ReadFileToken t = new ReadFileToken();
            t._operation = (ushort)Operation.FileRead;
            t._version = AccessToken.accessTokenVersion;
            t._serviceId = (uint)XOService.Storage;
            t._userPuid = readerPuid;
            t._xboxPuid = BotdXboxPuid;
            t._pathName = path;

            t._tokenExpirationDate = 0;
            t._signature = null;

            //t._flags    = (uint) ( _teamTickets == null ? 0 : (uint) FlagType.TeamTicket );

            ReqReadFile req = new ReqReadFile();
            req._titleId = titleID;
            req._titleVersion = 0;
            req._userCountryId = 0;  // not actually used by stfd
            req._rangeStart = 0;
            req._rangeEnd = 0;
            req._ifModifiedSinceDate = DateTime.UtcNow.ToFileTimeUtc(); //use current time to avoid return blob
            req._accessToken = t;
            req._teamTickets = null;

            // Write the full request into a binary stream
            MemoryStream ostream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(ostream);

            // Write out the request header
            req.WriteTo(writer);

            // Make sure the BinaryWriter is finished writing
            writer.Flush();

            LivecacheDependency dependency = LivecacheDependencies.TitleStorage(readerPuid);
            LivecacheRequest lcreq = new LivecacheRequest(readerPuid,
                                client,
                                LcserviceId.StorageValidate,
                                ostream.ToArray(),
                                0,
                                titleID,
                                null,
                                dependency,
                                null,
                                req);

            uint hr = lcreq.Send();
            if (hr == HResult.S_OK || hr == HResult.XONLINE_S_STORAGE_FILE_NOT_MODIFIED)
            {
                //tile is valid
                return true;
            }
            else
            {
                return false;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcXMachine.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using System.IO;

using xonline.common.xboxcom;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.offer;
using xonline.common.user;
using xonline.common.utilities2;

namespace xonline.common.webplatform.livecache
{
    public class LcXMachine : ILcXMachine
    {
        private IAccountAuthDataProvider authdataProvider;
        private string xmachineNamespace = "urn:schemas-xbox-com:machine-data";
        private LivecacheClientType client = LivecacheClientType.Xboxcom;
        private uint titleId;

        public LcXMachine(LivecacheClientType clientType, IAccountAuthDataProvider authDataProvider)
        {
            if (authDataProvider == null)
            {
                throw new ArgumentNullException("authDataProvider");
            }
            client = clientType;
            titleId = XOn.DASH_TITLE_ID; 
            authdataProvider = authDataProvider;
        }

        public bool IsConsoleIdAndScodeBanned(string consoleid, string secondaryId)
        {
            if (String.IsNullOrEmpty(consoleid))
            {
                throw new ArgumentNullException("consoleid");
            }
 
            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();

            request.NameValuePairs.Add(new WebServiceNameValuePair("consoleid", consoleid));

            //remove the hyphens from the secondary string
            string newSecondaryId = String.IsNullOrEmpty(secondaryId) ? "0" : secondaryId.Replace("-", "");

            byte[] convertSecondary = (byte[])Blob.Parse(newSecondaryId);

            foreach (byte b in convertSecondary)
            {
                request.NameValuePairs.Add(new WebServiceNameValuePair("secondaryid", b.ToString()));
            }

 
            LivecacheRequest lcreq = new LivecacheRequest(0,
                                                        client,
                                                        LcserviceId.IsConsoleIdAndSCodeBanned,
                                                        request,
                                                        titleId,
                                                        authdataProvider);
            if (lcreq.Send() != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcreq);
            }

            XmlSerializer serializer = new XmlSerializer(typeof(bool), xmachineNamespace);
            bool result = (bool)serializer.Deserialize(new MemoryStream(lcreq.ResponseData));
 
            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\LcUserRatings.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.webplatform.livecache.Data
{
    public class LcUserRatings : ILcUserRatings
    {
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("UserRating", "WebPlatform_Livecache");

        private LivecacheClientType _client = LivecacheClientType.Xboxcom;
        private uint _titleId;
        private IAccountAuthDataProvider _authdataProvider;

        public LcUserRatings(LivecacheClientType clientType, uint clientTitleId, IAccountAuthDataProvider authDataProvider)
        {
            if (clientTitleId == 0)
            {
                throw new ArgumentException("clientTitleId can't be 0.");
            }
            if (authDataProvider == null)
            {
                throw new ArgumentNullException("authDataProvider");
            }
            _client = clientType;
            _titleId = clientTitleId;
            _authdataProvider = authDataProvider;
        }


        public GetRatingResponse GetUserRating(GetRatingRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userXuid == 0)
            {
                throw new ArgumentException("userXuid can't be 0");
            }
            if (request.mediaId == Guid.Empty)
            {
                throw new ArgumentException("mediaId can't be 0");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userXuid, _client, LcserviceId.GetUserRating,
                request, _titleId, _authdataProvider, LivecacheDependencies.UserAccount(request.userXuid), null);
            
            uint hr = lcreq.Send();

            GetRatingResponse resp = new GetRatingResponse();
            if (HResult.Succeeded(hr))
            {
                resp.SetBytes(lcreq.ResponseData);
            }
            else
            {

                _logArea.LogError(LcSysEventId.UserRatings_Retrieve, new LivecacheResponseException(lcreq), "Error Getting User Rating");
                //throw new LivecacheResponseException(lcreq);
            }

            return resp;
        }

        public void RateMedia(RateMediaRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            if (request.userXuid == 0)
            {
                throw new ArgumentException("userXuid can't be 0");
            }
            if (request.mediaId == Guid.Empty)
            {
                throw new ArgumentException("mediaId can't be empty");
            }

            LivecacheRequest lcreq = new LivecacheRequest(request.userXuid, _client, LcserviceId.RateMedia,
                request, _titleId, _authdataProvider, null, LivecacheDependencies.UserAccount(request.userXuid));

            uint hr = lcreq.Send();

            GetRatingResponse resp = new GetRatingResponse();
            if (HResult.Failed(hr))
            {
                _logArea.LogError(LcSysEventId.UserRatings_Save, new LivecacheResponseException(lcreq), "Error Saving User Rating");
                //throw new LivecacheResponseException(lcreq);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Data\UserSettingBuilder.cs ===
using System;
using System.Text;
using System.Collections;

using xonline.common.service;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
	/// <summary>
	/// Assists in building an array of common.protocol.UserSetting objects.
	/// </summary>
	public class UserSettingBuilder
	{
        private const int defaultInitialCapacity = 10;
        ArrayList settings;

        /// <summary>
        /// Constructs a UserSettingBuilder with a default initial capacity
        /// </summary>
        public UserSettingBuilder(ulong targetLivepuid) : this(targetLivepuid, defaultInitialCapacity)
		{
		}

        /// <summary>
        /// Constructs a UserSettingBuilder with the specified initial capacity.
        /// </summary>
        /// <param name="targetLivepuid">The live PUID of the user we want to get information about.</param>
        /// <param name="initialCapacity">Initial capacity of the UserSettingBuilder</param>
        public UserSettingBuilder(ulong targetLivepuid, int initialCapacity)
        {
            settings = new ArrayList(initialCapacity);
            _userId  = targetLivepuid;
        }

        /// <summary>
        /// Gets or sets the source that will be used when adding settings
        /// </summary>
        public uint Source 
        {
            get {return _source ;}
            set {_source  = value;}
        }
        private uint _source = XOn.XSOURCE_DEFAULT;

        /// <summary>
        /// Gets the user that the setting is being requested for.
        /// </summary>
        /// <remarks>
        /// This value is set by the constructor. Since we only want to make a request
        /// for a single user's settings, this helps to enforce only having one user defined
        /// in the resulting UserSetting array.</remarks>
        public ulong UserId 
        {
            get {return _userId ;}
        }
        private ulong _userId = 0;

        public void AddIntSetting(uint setting, int value)
        {
            if (((setting >> 28) & 0xf) != (byte) XuserDataType.Int32)
            {
                throw new LivecacheCodeErrorException(
                    "AddIntSetting was called with a setting ID that does not indicate a Int32 type. Type value for setting " + setting + " is " + ((setting >> 28) & 0xf) + ".");
            }

            byte[] byteValue = BitConverter.GetBytes(value);
            UserSetting newSetting = new UserSetting(UserId, Source, setting, byteValue);
            settings.Add(newSetting);
        }

        public void AddStringSetting(uint setting, string value)
        {
            if (((setting >> 28) & 0xf) != (byte) XuserDataType.Unicode)
            {
                throw new LivecacheCodeErrorException(
                    "AddStringSetting was called with a setting ID that does not indicate a Unicode type. Type value for setting " + setting + " is " + ((setting >> 28) & 0xf) + ".");
            }

            Encoding unicode = Encoding.Unicode;
            
            int byteCount = unicode.GetByteCount(value);

            byte[] byteValue = new byte[byteCount + 2];
            unicode.GetBytes(value, 0, value.Length, byteValue, 0);
            byteValue[byteCount] = 0;
            byteValue[byteCount + 1] = 0;

            UserSetting newSetting = new UserSetting(UserId, Source, setting, byteValue);
            settings.Add(newSetting);
        }

        public void AddFloatSetting(uint setting, float value)
        {
            if (((setting >> 28) & 0xf) != (byte) XuserDataType.Float)
            {
                throw new LivecacheCodeErrorException(
                    "AddFloatSetting was called with a setting ID that does not indicate a Float type. Type value for setting " + setting + " is " + ((setting >> 28) & 0xf) + ".");
            }

            byte[] byteValue = BitConverter.GetBytes(value);
            UserSetting newSetting = new UserSetting(UserId, Source, setting, byteValue);
            settings.Add(newSetting);
        }

        public void AddBinarySetting(uint setting, byte[] value)
        {
            if (((setting >> 28) & 0xf) != (byte)XuserDataType.Binary)
            {
                throw new LivecacheCodeErrorException(
                    "AddBinarySetting was called with a setting ID that does not indicate a Binary type. Type value for setting " + setting + " is " + ((setting >> 28) & 0xf) + ".");
            }

            UserSetting newSetting = new UserSetting(UserId, Source, setting, value);
            settings.Add(newSetting);

        }

        public UserSetting[] ToUserSettingArray()
        {
            UserSetting[] settingsArray = new UserSetting[settings.Count];

            settings.CopyTo(settingsArray);

            return settingsArray;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\InsufficientPrivilegesException.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.common.webplatform.livecache
{
    public class InsufficientPrivilegesException : System.Exception
    {
        public InsufficientPrivilegesException(string message)
            : base(message)
        {
        }

        public InsufficientPrivilegesException(string message, System.Exception inner)
            : base(message, inner)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\InvalidUserInputException.cs ===
using System;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class InvalidUserInputException : XRLException
    {
        public InvalidUserInputException(uint hr, string message)
            : base(hr, (XEvent.Id)XOn.XeventCommUnexpectedError, message)
        {
        }

        public InvalidUserInputException(string message)
            : base(HResult.E_INVALIDARG, (XEvent.Id)LcSysEventId.Common_InvalidUserInput, message)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\InvalidPostalCodeException.cs ===
using System;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class InvalidPostalCodeException : XRLException
    {
        public InvalidPostalCodeException(uint hr, string message)
            : base(hr, (XEvent.Id)XOn.XeventCommUnexpectedError, message)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\InvalidGamertagException.cs ===
using System;

using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Summary description for InvalidGamertagException.
    /// </summary>
    public class InvalidGamertagException : ExceptionWithEventId
    {
        public InvalidGamertagException(string gamertag)
            : base((XEvent.Id)LcSysEventId.Common_InvalidGamertag, "Gamertag does not correspond to a Xbox Live user.")
        {
            this.gamertag = gamertag;
        }

        public InvalidGamertagException(ulong passportPuid)
            : base((XEvent.Id)LcSysEventId.Common_InvalidGamertag, "Passport PUID does not correspond to a Xbox Live user.")
        {
            this.puid = passportPuid;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Gamertag 
        {
            get {return gamertag ;}
        }
        private string gamertag = null;


        /// <summary>
        /// 
        /// </summary>
        public ulong PassportPuid 
        {
            get {return puid ;}
        }
        private ulong puid = 0;


        public override string Message
        {
            get
            {
                if (gamertag != null)
                {
                    return base.Message + "\r\nGamertag = '" + gamertag + "'.";
                }
                else if (puid != 0)
                {
                    return base.Message + "\r\nPassport PUID = '" + puid.ToString("X8") + "'.";
                }
                else
                {
                    return base.Message;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\GamertagTakenException.cs ===
using System;

using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Summary description for InvalidGamertagException.
    /// </summary>
    public class GamertagTakenException : ExceptionWithEventId
    {
        public GamertagTakenException(string gamertag)
            : base((XEvent.Id)LcSysEventId.Common_InvalidGamertag, "Gamertag is taken.")
        {
            this.gamertag = gamertag;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Gamertag 
        {
            get {return gamertag ;}
        }
        private string gamertag = null;


          public override string Message
        {
            get
            {
                if (gamertag != null)
                {
                    return base.Message + "\r\nGamertag = '" + gamertag + "'.";
                }
                else
                {
                    return base.Message;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\InvalidCardNumberException.cs ===
using System;

namespace xonline.common.webplatform.livecache
{
    public class InvalidCardNumberException : Exception
    {
        public InvalidCardNumberException()
        {
        }

        public InvalidCardNumberException(string message)
            : base(message)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\LivecacheResponseException.cs ===
using System;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class LivecacheResponseException : XRLException
    {
        private LivecacheRequest _lcRequest;
        /*
        public LivecacheResponseException(string message)
            : base(xonline.common.service.HResult.E_FAIL, 0, message)
        {
            _lcRequest = null;
        }
        */
        public LivecacheResponseException(LivecacheRequest lcReq)
            : base(lcReq.Hr, (XEvent.Id)lcReq.GetEventID(), lcReq.ToDiagString())
        {
            _lcRequest = lcReq;
        }

        public LivecacheResponseException(LivecacheRequest lcReq, string message)
            : base(lcReq.Hr, (XEvent.Id)lcReq.GetEventID(), message)
        {
            _lcRequest = lcReq;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\LcRequestEventId.cs ===
using System;

namespace xonline.common.webplatform.livecache
{
    public class SysEventFlags
    {
        /// <summary>
        /// Use this flag if the http response status code is 500
        /// </summary>
        public const uint Error = 0xC0000000;

        /// <summary>
        /// Use this flag if user will see an error message
        /// </summary>
        public const uint Warning = 0x80000000;

        /// <summary>
        /// Use this flag if the failure is completely expected
        /// </summary>
        public const uint Info = 0x40000000;
    }

    /// <summary>
    /// livecache request: 42XXX
    /// </summary>
    public enum LcRequestEventId : uint
    {
        Unknown = SysEventFlags.Error | 42000,

        AcceptFriendRequest = SysEventFlags.Error | 42001,
        AchievementEnum = SysEventFlags.Error | 42002,
        AddFriend = SysEventFlags.Error | 42003,
        CreateXboxComAccount = SysEventFlags.Error | 42004,
        DeleteFriend = SysEventFlags.Error | 42005,
        DeleteMessage = SysEventFlags.Error | 42006,
        EnumerateMessages = SysEventFlags.Error | 42007,
        EnumerateSystemMessages = SysEventFlags.Error | 42008,
        EnumTitles = SysEventFlags.Error | 42009,
        GetAccountInfo = SysEventFlags.Error | 42010,

        GetFriends = SysEventFlags.Error | 42011,
        GetLinkedGamertag = SysEventFlags.Error | 42012,
        GetMessageDetails = SysEventFlags.Error | 42013,
        GetMessageSummary = SysEventFlags.Error | 42014,
        GetPresenceInfo = SysEventFlags.Error | 42015,
        GetPublicPresenceInfo = SysEventFlags.Error | 42016,
        GetSystemMessageDetails = SysEventFlags.Error | 42017,
        GetUserType = SysEventFlags.Error | 42018,
        GetUserWebInfo = SysEventFlags.Error | 42019,
        LinkWebAccount = SysEventFlags.Error | 42020,

        LivecacheResponse = SysEventFlags.Error | 42021,
        PublicEnumTitles = SysEventFlags.Error | 42022,
        PublicReadSettings = SysEventFlags.Error | 42023,
        QueryAffiliates = SysEventFlags.Error | 42024,
        ReadSettings = SysEventFlags.Error | 42025,
        RejectFriendRequest = SysEventFlags.Error | 42026,
        ReserveName = SysEventFlags.Error | 42027,
        SendMessage = SysEventFlags.Error | 42028,
        SetAccountInfo = SysEventFlags.Error | 42029,
        SetMessageFlags = SysEventFlags.Error | 42030,

        StorageRead = SysEventFlags.Error | 42031,
        StorageRemove = SysEventFlags.Error | 42032,
        StorageWrite = SysEventFlags.Error | 42033,
        StringLookup = SysEventFlags.Error | 42034,
        SyncSettings = SysEventFlags.Error | 42035,
        UpdateXboxComActivity = SysEventFlags.Error | 42036,
        UpsGetProfile = SysEventFlags.Error | 42037,
        UpsUpdateProfile = SysEventFlags.Error | 42038,
        VetString = SysEventFlags.Error | 42039,
        WebAlive = SysEventFlags.Error | 42040,

        CacheInvalidate = SysEventFlags.Error | 42041,
        LoadData = SysEventFlags.Error | 42042,
        SaveData = SysEventFlags.Error | 42043,
        ClearData = SysEventFlags.Error | 42044,
        CreateLiveAccount = SysEventFlags.Error | 42045,
        SubscriptionEnum = SysEventFlags.Error | 42046,
        SubscriptionDetails = SysEventFlags.Error | 42047,
        MigrateXbox1User = SysEventFlags.Error | 42048,
        MigrateXboxComUser = SysEventFlags.Error | 42049,
        VerifyBillingInfo = SysEventFlags.Error | 42050,

        OfferingVerifyToken = SysEventFlags.Error | 42051,
        PurchaseSubscription = SysEventFlags.Error | 42052,
        GetUserSubscriptionDetails = SysEventFlags.Error | 42053,
        PurchasePoints = SysEventFlags.Error | 42054,
        GetPointsBalance = SysEventFlags.Error | 42055,
        AddPaymentInstrument = SysEventFlags.Error | 42056,
        UpdatePaymentInstrument = SysEventFlags.Error | 42057,
        GetPaymentInstruments = SysEventFlags.Error | 42058,
        ContentEnum = SysEventFlags.Error | 42059,
        ContentDetails = SysEventFlags.Error | 42060,

        CancelOffer = SysEventFlags.Error | 42061,
        VerifyParentCreditCard = SysEventFlags.Error | 42062,
        UpdateParentalControls = SysEventFlags.Error | 42063,
        RemovePaymentInstrument = SysEventFlags.Error | 42064,
        PassportGetMemberName = SysEventFlags.Error | 42065,
        ChangeSubscriptionPaymentInstrument = SysEventFlags.Error | 42066,
        GetGamerProfileTypes = SysEventFlags.Error | 42067,
        StorageValidate = SysEventFlags.Error | 42068,
        TroubleshootAccount = SysEventFlags.Error | 42069,
        ChangeGamerTag = SysEventFlags.Error | 42070,

        AcceptTOU = SysEventFlags.Error | 42071,
        LinkXbox1Account = SysEventFlags.Error | 42072,
        PassportGetPuidFromMemberName = SysEventFlags.Error | 42073,

        SubmitComplaint = SysEventFlags.Error | 42074,
        AcceptTermsOfService = SysEventFlags.Error | 42075,
        GetFriendsOfFriend = SysEventFlags.Error | 42076,

        PurchaseMediaOffers = SysEventFlags.Error | 42077,
        FindMediaInstanceUrls = SysEventFlags.Error | 42078,
        PurchaseHistory = SysEventFlags.Error | 42079,
        VerifyToken = SysEventFlags.Error | 42080,
        GetLicenseTransferState = SysEventFlags.Error | 42081,
        UpdateLicenseTransferState = SysEventFlags.Error | 42082,
        RefreshGameLicense = SysEventFlags.Error | 42083,
        GraduateUser = SysEventFlags.Error | 42084,

        CreateDownloadQueue = SysEventFlags.Error | 42085,
        QueryDownloadQueues = SysEventFlags.Error | 42086,
        QueryDownloadItems = SysEventFlags.Error | 42087,
        InsertDownloadItems = SysEventFlags.Error | 42088,
        DeleteDownloadItems = SysEventFlags.Error | 42089,
        MoveDownloadItems = SysEventFlags.Error | 42090,
        ModifyDownloadItems = SysEventFlags.Error | 42091,
        QueryLists = SysEventFlags.Error | 42092,
        QueryListItems = SysEventFlags.Error | 42093,
        QueryDownloadQueuesNonCached = SysEventFlags.Error | 42098,

        AddFriendFromContact = SysEventFlags.Error | 42094,
        GetSignedHeader = SysEventFlags.Error | 42095,
        GetCachedPointsBalance = SysEventFlags.Error | 42096,
        SetBlacklistDigestState = SysEventFlags.Error | 42097,

        GetUserAuthorization = SysEventFlags.Error | 42098,
        CachedPurchaseHistory = SysEventFlags.Error | 42099,

        GetUserRating = SysEventFlags.Error | 42100,
        RateMedia = SysEventFlags.Error | 42101,

        AcknowledgeLicensesDelivery = SysEventFlags.Error | 42102,
        AcquireMediaLicenses = SysEventFlags.Error | 42103,
        AcquireMediaLicensesWeb = SysEventFlags.Error | 42104,
        CheckLicensesAvailability = SysEventFlags.Error | 42105,

        PurchaseGamertag = SysEventFlags.Error | 42106,

        GetSecurityTicket = SysEventFlags.Error | 42107,
        GetPartnerSecurityTicket = SysEventFlags.Error | 42108,

        SyncTitles = SysEventFlags.Error | 42109,
        SyncAchievements = SysEventFlags.Error | 42110,
        AvatarAwardEnum = SysEventFlags.Error | 42111,
        ValidateAvatarManifest = SysEventFlags.Error | 42112,
        SyncAvatarAssets = SysEventFlags.Error | 42113,  
     
        AssetEnumerate = SysEventFlags.Error | 42114,
        AssetConsume = SysEventFlags.Error | 42115,
        


        IsConsoleIdAndSCodeBanned = SysEventFlags.Error | 42116,

        MergeUserEntitlements = SysEventFlags.Error | 42117,

        SwitchUserCountry = SysEventFlags.Error | 42118,
        SwitchUserCountryV2 = SysEventFlags.Error | 42119,
        PreviewSwitchUserCountry = SysEventFlags.Error | 42120,
        GetSupportedCountries = SysEventFlags.Error | 42121,

	WebAlive2 = SysEventFlags.Error | 42122,

        PostLeaderboardResult = SysEventFlags.Error | 42123,
        GetFriendsLeaderboardInfo = SysEventFlags.Error | 42124,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\LivecacheConfigException.cs ===
using System;

namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Summary description for BadConfigException.
    /// </summary>
    public class LivecacheConfigException : Exception
    {
        public string ConfigPath;

        public LivecacheConfigException(string configpath, string errmsg)
            : base(errmsg)
        {
            ConfigPath = configpath;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\ServiceNotProvisionedException.cs ===
using System;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    public class ServiceNotProvisionedException : XRLException
    {
        public ServiceNotProvisionedException(uint hr, string message)
            : base(hr, (XEvent.Id)XOn.XeventCommUnexpectedError, message)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\BillingAuthorizationFailedException.cs ===
using System;

namespace xonline.common.webplatform.livecache
{
    [global::System.Serializable]
    public class BillingAuthorizationFailedException : Exception
    {
        //
        // For guidelines regarding the creation of new exception types, see
        //    http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpgenref/html/cpconerrorraisinghandlingguidelines.asp
        // and
        //    http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncscol/html/csharp07192001.asp
        //

        public BillingAuthorizationFailedException() { }
        public BillingAuthorizationFailedException(string message) : base(message) { }
        public BillingAuthorizationFailedException(string message, Exception inner) : base(message, inner) { }
        protected BillingAuthorizationFailedException(
          System.Runtime.Serialization.SerializationInfo info,
          System.Runtime.Serialization.StreamingContext context)
            : base(info, context) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\LivecacheCodeErrorException.cs ===
using System;

namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Summary description for CoreCodeErrorException.
    /// </summary>
    public class LivecacheCodeErrorException : Exception
    {
        public LivecacheCodeErrorException(string message)
            : base(message)
        {
        }

        public LivecacheCodeErrorException(string message, Exception inner)
            : base(message, inner)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\LcSysEventId.cs ===
using System;

namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// 400xx livecache API
    /// </summary>
    public enum LcSysEventId : uint
    {
        /// <summary>
        /// Dev Cause: Failed looking up gamertag for given puid from xcache
        /// Dev Action:
        /// Ops Action:
        /// </summary>
        XCache_LookupGamertag = SysEventFlags.Error | 40040,

        /// <summary>
        /// Dev Cause: Failed looking up puid for given gamertag from xcache
        /// Dev Action:
        /// Ops Action:
        /// </summary>
        XCache_LookupPuid = SysEventFlags.Error | 40041,

        /// <summary>
        /// Dev Cause: Thread abort when looking up gamertag for given puid from xcache
        /// Dev Action:
        /// Ops Action:
        /// </summary>
        XCache_LookupGamertagAbort = SysEventFlags.Error | 40042,

        /// <summary>
        /// Dev Cause: Thread abort when looking up puid for given gamertag from xcache
        /// Dev Action:
        /// Ops Action:
        /// </summary>
        XCache_LookupPuidAbort = SysEventFlags.Error | 40043,


        /// <summary>
        /// Dev Cause: The name of the interface in t_livecache_apis table is unknown.
        /// Dev Action: Check if xonline.common.xboxcom.dll is up-to-date.
        /// Ops Action: Check if the entry is correctly spelled in t_livecache_apis table.
        /// </summary>
        LivecacheAPI_InvalidInterface = SysEventFlags.Error | 40050,

        /// <summary>
        /// Dev Cause: Failed when loading livecache service entries from t_livecache_apis table.
        /// Dev Action:
        /// Ops Action:
        /// </summary>
        LivecacheAPI_Load = SysEventFlags.Error | 40051,

        /// <summary>
        /// Dev Cause: Matching EventID not found for the livecache API.
        /// Dev Action: Add missing mapping to GetEventIdMappingTable().
        /// Ops Action:
        /// </summary>
        LivecacheAPI_EventMap = SysEventFlags.Error | 40052,

        /// <summary>
        /// Dev Cause: The SPI has reached maximum number of requests allowed in that second.
        /// Dev Action: Find out why we're getting more requests than we projected. Increase quota if necessary.
        /// Ops Action: Engage dev team.
        /// </summary>
        Livecache_ThrottledForTPS = SysEventFlags.Error | 40053,

        /// <summary>
        /// Dev Cause: Request was throttled because the user had too many requests during the hour.
        /// Dev Action: 
        /// Ops Action: Investigate why that user is making so many requests. Maybe a screen scraping program?
        /// </summary>
        Livecache_ThrottledForSpam = SysEventFlags.Error | 40054,


        /// <summary>
        /// Dev Cause: the supplied gamer tag is invalid
        /// Dev Action: 
        /// Ops Action:
        /// </summary>
        Common_InvalidGamertag = SysEventFlags.Error | 40180,

        /// <summary>
        /// Dev cause: user input is invalid found by our validation rule
        /// Dev Action: error should be catched and handled
        /// Ops Action: 
        /// </summary>
        Common_InvalidUserInput = SysEventFlags.Error | 40181,


        /// <summary>
        /// Dev Cause:   An error occured while getting or saving a user's game rating
        /// Dev Action:  n/a
        /// Ops Action:  Verify livecache errors.
        /// </summary>
        UserRatings_Retrieve = SysEventFlags.Error | 40182,
        UserRatings_Save = SysEventFlags.Error | 40183,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\UnderAgeAccountException.cs ===
using System;


namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Summary description for UnderAgeAccountException.
    /// </summary>
    public class UnderAgeAccountException : Exception
    {
        public UnderAgeAccountException(string message) : base(message)
        {
        }
        
        public UnderAgeAccountException(string message, Exception inner): base(message, inner)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\ServiceUnavailableException.cs ===
using System;

namespace xonline.common.webplatform.livecache
{
    //
    // these execptions don't need to be logged. they should be handled by caller
    //
    public class ServiceUnavailableException : Exception
    {
        public ServiceUnavailableException(string message) : base(message)
        {
        }

        public ServiceUnavailableException() : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Exception\LivecacheUserThrottledException.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.common.webplatform.livecache
{
    public class LivecacheUserThrottledException : Exception
    {
        public LivecacheUserThrottledException(ulong livePuid)
            : base("User has hit the LiveCache per user throttle.")
        {
            _livePuid = livePuid;
        }

        public ulong LivePuid
        {
            get { return _livePuid; }
        }
        private ulong _livePuid = 0;


        public override string Message
        {
            get
            {
                return String.Format("{0} LivePuid = 0x{1:X8}", base.Message, LivePuid);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\IContextItemProvider.cs ===
using System;

namespace xonline.common.webplatform.livecache
{
    public interface IContextItemProvider
    {
        object this[string name]
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\IAccountAuthDataProvider.cs ===
using System;
using System.Net;

using xonline.common.service;
using xonline.common.protocol;

namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Provide account info
    /// </summary>
    public interface IAccountAuthDataProvider
    {
        ulong LivePuid { get; }
        byte Tier { get; }
        uint[] Privileges { get; }
        IPEndPoint ClientIPEndPoint { get; }
    }

    public interface IExtendedAuthDataProvider : IAccountAuthDataProvider
    {
        ulong XboxPuid { get; }
        byte ClientPlatform { get; }
    }

    /// <summary>
    /// Name value collection which will be added as header to the request
    /// </summary>
    public interface IExtendedAuthDataProvider2 : IExtendedAuthDataProvider
    {
        LiveCacheWebHeaderCollection WebHeaderCollection { get; }
    }

    internal sealed class ExtendedAuthWrapperForIAccountAuthProvider : IExtendedAuthDataProvider2
    {
        private IAccountAuthDataProvider _auth;

        internal ExtendedAuthWrapperForIAccountAuthProvider(IAccountAuthDataProvider auth)
        {
            if (auth == null)
                throw new ArgumentNullException("auth");

            _auth = auth;
        }

        public ulong LivePuid { get { return _auth.LivePuid; } }
        public byte Tier { get { return _auth.Tier; } }
        public uint[] Privileges { get { return _auth.Privileges; } }
        public IPEndPoint ClientIPEndPoint { get { return _auth.ClientIPEndPoint; } }

        //return 0 and XPLT_INVALID as default for Puid and Client platform
        public ulong XboxPuid { get { return 0; } }
        public byte ClientPlatform { get { return XOn.XPLT_INVALID; } }
        //return null name value collection as default
        public LiveCacheWebHeaderCollection WebHeaderCollection { get { return null; } }
    }

    internal sealed class ExtendedAuthWrapperForIExtendedAuthDataProvider : IExtendedAuthDataProvider2
    {
        private IExtendedAuthDataProvider _auth;

        internal ExtendedAuthWrapperForIExtendedAuthDataProvider(IExtendedAuthDataProvider auth)
        {
            if (auth == null)
                throw new ArgumentNullException("auth");

            _auth = auth;
        }

        public ulong LivePuid { get { return _auth.LivePuid; } }
        public byte Tier { get { return _auth.Tier; } }
        public uint[] Privileges { get { return _auth.Privileges; } }
        public IPEndPoint ClientIPEndPoint { get { return _auth.ClientIPEndPoint; } }

        public ulong XboxPuid { get { return _auth.XboxPuid; } }
        public byte ClientPlatform { get { return _auth.ClientPlatform; } }
        //return null name value collection as default
        public LiveCacheWebHeaderCollection WebHeaderCollection { get { return null; } }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\AAInfoLivecache.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using xonline.common.service;

namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Create a derived class from AAInfo that allows us to modify the primary data fields
    /// directly and generate the serialized HTTP Header.
    /// 
    /// None of the other fancy functionality of AAInfo is supported.
    /// </summary>
	internal class AAInfoLivecache : AAInfo
	{
        public AAInfoLivecache(IAAInfoData infoData) : base()
        {
            _fUseXBanc = false;

            _passportPuid = infoData.PassportPuid;
            _ipAddressInternet = infoData.IpAddressInternet;

            _certDeviceId = infoData.CertDeviceId;
            
            if (infoData.IssueInstant.HasValue)
            {
                _issueInstantDateTime = infoData.IssueInstant.Value;
            }

            if (infoData.NotAfter.HasValue)
            {
                _notAfterDateTime = infoData.NotAfter.Value;
            }

            if (infoData.PassportCId.HasValue)
            {
                _passportCId = infoData.PassportCId.Value;
            }

            _originatingIP = infoData.OriginatingIP;
            _samlToken = infoData.SamlToken ?? "";
        }

        // This class should never need to support the fetching of this additional
        // data. Leave them as not implemented
        protected override void PopulateLiveXuid()
        {
            throw new NotImplementedException();
        }

        protected override void PopulateUserInfo()
        {
            throw new NotImplementedException();
        }

        protected override void PopulateUserPrivileges()
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\LcDependency.cs ===
using System;
using System.Text;

namespace xonline.common.webplatform.livecache
{
    public struct LivecacheDependencyRequired
    {
        public byte Flags;

        public bool Check(LivecacheDependency dep)
        {
            if (Flags != 0)
            {
                if (dep == null)
                {
                    return false;
                }
                else if ((Flags & ~dep.DataSets) != 0)
                {
                    return false;
                }
            }

            return true;
        }
    }

    public enum LiveCacheDependencyBitFlags : uint
    {
        UserAccount = 1,
        PassportAccount = 2,
        Messages = 4,
        Friends = 8,
        Stats = 16,
        TitleStorage = 32,
        Lists = 64,
        Assets = 128,
    }

    public class LivecacheDependency
    {
        public ulong Puid;
        public uint DataSets; // currently one data set only, may expand in future

        protected enum LiveCacheDependencyName
        {
            UserAccount = 'u',
            PassportAccount = 'p',
            Messages = 'm',
            Friends = 'f',
            Stats = 's',
            TitleStorage = 't',
            Lists = 'l',
            Assets = 'a',
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            // the names (f,m,p,s,u) must be unique
            AppendDependency(sb, LiveCacheDependencyBitFlags.UserAccount,
                                 LiveCacheDependencyName.UserAccount);
            AppendDependency(sb, LiveCacheDependencyBitFlags.PassportAccount,
                                 LiveCacheDependencyName.PassportAccount);
            AppendDependency(sb, LiveCacheDependencyBitFlags.Messages,
                                 LiveCacheDependencyName.Messages);
            AppendDependency(sb, LiveCacheDependencyBitFlags.Friends,
                                 LiveCacheDependencyName.Friends);
            AppendDependency(sb, LiveCacheDependencyBitFlags.Stats,
                                 LiveCacheDependencyName.Stats);
            AppendDependency(sb, LiveCacheDependencyBitFlags.TitleStorage,
                                 LiveCacheDependencyName.TitleStorage);
            AppendDependency(sb, LiveCacheDependencyBitFlags.Lists,
                                 LiveCacheDependencyName.Lists);
            AppendDependency(sb, LiveCacheDependencyBitFlags.Assets,
                                 LiveCacheDependencyName.Assets);

            return sb.ToString();
        }

        private void AppendDependency(StringBuilder sb, LiveCacheDependencyBitFlags bit, LiveCacheDependencyName name)
        {
            if ((DataSets & (uint)bit) != 0)
            {
                if (sb.Length > 0)
                {
                    sb.Append(',');
                }

                sb.Append(Puid.ToString("x"));
                sb.Append('.');
                sb.Append((char)name);
            }
        }
    }

    public class LivePuidDependency : LivecacheDependency
    {
        public LivePuidDependency(LiveCacheDependencyBitFlags category, ulong livePuid)
        {
            DataSets = (uint)category;
            Puid = livePuid;
        }

        public LivePuidDependency AddUserAccount()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.UserAccount;
            return this;
        }

        public LivePuidDependency AddFriends()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.Friends;
            return this;
        }

        public LivePuidDependency AddMessages()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.Messages;
            return this;
        }

        public LivePuidDependency AddStats()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.Stats;
            return this;
        }

        public LivePuidDependency AddTitleStorage()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.TitleStorage;
            return this;
        }

        public LivePuidDependency AddLists()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.Lists;
            return this;
        }

        public LivePuidDependency AddAssets()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.Assets;
            return this;
        }
    }

    public class PassportPuidDependency : LivecacheDependency
    {
        public PassportPuidDependency(LiveCacheDependencyBitFlags category, ulong passportPuid)
        {
            DataSets = (uint)category;
            Puid = passportPuid;
        }
    }

    public class LivecacheDependencies
    {
        public static PassportPuidDependency PassportAccount(ulong passportPuid)
        {
            return new PassportPuidDependency(LiveCacheDependencyBitFlags.PassportAccount, passportPuid);
        }

        public static LivePuidDependency UserAccount(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.UserAccount, livePuid);
        }

        public static LivePuidDependency Friends(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.Friends, livePuid);
        }

        public static LivePuidDependency Messages(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.Messages, livePuid);
        }

        public static LivePuidDependency Stats(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.Stats, livePuid);
        }

        public static LivePuidDependency TitleStorage(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.TitleStorage, livePuid);
        }

        public static LivePuidDependency Lists(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.Lists, livePuid);
        }

        public static LivePuidDependency Assets(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.Assets, livePuid);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\IAAInfoData.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;

namespace xonline.common.webplatform.livecache
{
	public interface IAAInfoData
	{
        // Required fields
        ulong PassportPuid { get; }
        string IpAddressInternet { get; }

        // Optional fields
        ulong? PassportCId { get; }
        string CertDeviceId { get; }
        DateTime? IssueInstant { get; }
        DateTime? NotAfter { get; }
        IPAddress OriginatingIP { get; }
        string SamlToken { get; }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\LcServiceId.cs ===
using System;
using xonline.common.xboxcom;

namespace xonline.common.webplatform.livecache
{

    public enum LcserviceId : ushort
    {
        Unknown = 0,

        //
        // presence and notification: 10XX
        //
        GetFriends = 1001,
        GetPresenceInfo = 1003,
        AddFriend = 1004,
        DeleteFriend = 1005,
        AcceptFriendRequest = 1006,
        RejectFriendRequest = 1007,
        QueryAffiliates = 1008,
        GetPublicPresenceInfo = 1009,
        WebAlive = 1010,
        GetFriendsOfFriend = 1011,
        AddFriendFromContact = 1012,
        AddUsersToNeverList = 1013,
        RemoveUsersFromNeverList = 1014,
        CanSendMessageToUsers = 1015,
        WebAlive2 = 1016,


        //
        // stringsvr: 12XX
        //
        VetString = 1201,
        StringLookup = 1202,

        //
        // Lists/Download Queue: 15xx
        //
        CreateDownloadQueue = 1501,
        QueryDownloadQueues = 1502,
        QueryDownloadItems = 1503,
        InsertDownloadItems = 1504,
        DeleteDownloadItems = 1505,
        MoveDownloadItems = 1506,
        ModifyDownloadItems = 1507,
        QueryLists = 1508,
        QueryListItems = 1509,
        QueryDownloadQueuesNonCached = 1510,

        //
        // Sts: 17xx
        //
        GetSecurityTicket = 1701,
        GetPartnerSecurityTicket = 1702,

        //
        // user account: 2XXX
        //
        LinkWebAccount = 2001,
        CreateXboxComAccount = 2002,
        CreateLiveAccount = 2003,
        UpsGetProfile = 2004,
        UpsUpdateProfile = 2005,
        ReserveName = 2007,
        UpdateXboxComActivity = 2008,
        GetUserWebInfo = 2009,
        GetLinkedGamertag = 2010,
        GetUserType = 2011,
        GetAccountInfo = 2012,
        SetAccountInfo = 2013,
        MigrateXbox1User = 2014,
        MigrateXboxComUser = 2015,
        VerifyBillingInfo = 2016,
        GetUserSubscriptionDetails = 2017,
        GetPointsBalance = 2018,
        RemovePaymentInstrument = 2019,
        AddPaymentInstrument = 2020,
        UpdatePaymentInstrument = 2021,
        GetPaymentInstruments = 2022,
        CancelOffer = 2023,
        VerifyParentCreditCard = 2024,
        UpdateParentalControls = 2025,
        PassportGetMemberName = 2026,
        ChangeSubscriptionPaymentInstrument = 2027,
        GetGamerProfileTypes = 2028,
        TroubleshootAccount = 2029,
        ChangeGamerTag = 2030,
        AcceptTOU = 2031,
        LinkXbox1Account = 2032,
        PassportGetPuidFromMemberName = 2033,
        AcceptTermsOfService = 2034,
        GraduateUser = 2035,
        GetCachedPointsBalance = 2036,
        GetUserAuthorization = 2037,
        EnumFamilyMembers = 2038,
        AddDependent = 2039,
        FamilySubscriptionGoldUserCount = 2040,
        FamilySubscriptionAssignGoldUser = 2041,
        FamilySubscriptionRemoveGoldUser = 2042,
        RemoveDependent = 2043,
        GenerateGamertag = 2044,
        CreateUserAndBillableAccount = 2045,
        GetParentalControls = 2046,
        PassportCreateGenerated = 2047,
        GetUserAuthorizationNoCache = 2048,
        SwitchUserCountry = 2049,
        UpdateParentalControlGroup = 2050,
        GetUserParentalControlGroup = 2051,
        GetParentalControlGroupTemplates = 2052,
        UserAccountAuthorize = 2053,
        MergeUserEntitlements = 2054,
        SwitchUserCountryV2 = 2055,
        PreviewSwitchUserCountry = 2056,
        GetSupportedCountries = 2057,
        VerifyParentCreditCardEx = 2058,
        AddPaymentInstrumentEx = 2059,
        GetKey = 2060,
        
        //
        // stats: 30XX
        //
        SyncSettings = 3001,
        ReadSettings = 3002,
        EnumTitles = 3003,
        AchievementEnum = 3004,
        PublicReadSettings = 3005,
        PublicEnumTitles = 3006,
        ReadSettingsNoCache = 3007,         // Zune special API added, not part of official bits
        PublicReadSettingsNoCache = 3008,   // Zune special API added, not part of official bits
        SyncTitles = 3009,
        SyncAchievements = 3010,
        AvatarAwardEnum = 3011,
        ValidateAvatarManifest = 3012,
        SyncAvatarAssets = 3013,

        //
        // leaderboard: 31XX
        //
        PostLeaderboardResult = 3101,
        GetFriendsLeaderboardInfo = 3102,

        //
        // billing & offering: 40XX
        //
        SubscriptionEnum = 4001,
        SubscriptionDetails = 4002,
        OfferingVerifyToken = 4003,
        PurchaseSubscription = 4004,
        PurchasePoints = 4005,
        ContentEnum = 4006,
        ContentDetails = 4007,
        PurchaseMediaOffers = 4008,
        FindMediaInstanceUrls = 4009,
        PurchaseHistory = 4010,
        VerifyToken = 4011,
        CachedPurchaseHistory = 4012,
        PurchaseGamertag = 4013,
        PreviewProductpurchase = 4014,
        SubscriptionOfferEnumerate = 4015,
        TransferPointsBalance = 4016,
        GetDependentPointsBalance = 4017,
        PreviewMergeSubscription = 4018,
        AssetConsume = 4019,
        AssetEnumerate = 4020,
        GetMediaLicense = 4021,
        GetUserSubscriptions = 4022,

        //
        // user ratings: 41XX
        //
        GetUserRating = 4101,
        RateMedia = 4102,

        //
        // storage: 5XXX
        //
        StorageWrite = 5001,
        StorageRemove = 5002,
        StorageRead = 5003,
        StorageValidate = 5004,
        //
        // messaging and feedback: 6XXX
        //
        EnumerateMessages = 6001,
        GetMessageSummary = 6002,
        GetMessageDetails = 6003,
        DeleteMessage = 6004,
        SetMessageFlags = 6005,
        SendMessage = 6006,
        EnumerateSystemMessages = 6007,
        GetSystemMessageDetails = 6008,
        SubmitComplaint = 6009,

        //
        // Signature (xsig): 7XXX
        //
        GetLicenseTransferState = 7001,
        UpdateLicenseTransferState = 7002,
        RefreshGameLicense = 7003,
        GetSignedHeader = 7004,
        SetBlacklistDigestState = 7005,
        AcknowledgeLicensesDelivery = 7006,
        AcquireMediaLicenses = 7007,
        AcquireMediaLicensesWeb = 7008,
        CheckLicensesAvailability = 7009,

        //
        // XMachine: 8XXX
        //
        IsConsoleIdAndSCodeBanned = 8001,

        //
        // internal API = 99XX
        //
        CacheInvalidate = LivecacheConst.SN_CacheInvalidate, // 9901
        SaveData = LivecacheConst.SN_SaveData,
        LoadData = LivecacheConst.SN_LoadData,
        ClearData = LivecacheConst.SN_ClearData,
        TestAPIWithFriendsDependency = 9993,
        TestAPIWithFriendsInvalidation = 9994,
        TestAPIWithStatsDependency = 9995,
        TestAPIWithStatsInvalidation = 9996,
        TestAPI = 9997,
        TestAPIWithUserAccountDependency = 9998,
        TestAPIWithUserAccountInvalidation = 9999,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\LcRequest.cs ===
using System;
using System.Diagnostics;
using System.Globalization;
using System.Net;
using System.Text;

using xonline.common.config;
using xonline.common.service;
using xonline.common.xboxcom;

namespace xonline.common.webplatform.livecache
{
    public class LcConstants
    {
        public const int MaxKeyLength = 600; // typical key should be less then 50 characters
        public const int MaxDataLength = 81000; // object over 83KB will be stored in large object heap
        public const int DefaultTTL = 1200; // twenty minutes
    }

    public delegate void LivecacheLocaleHandler(out uint language, out uint country);

    //
    // client side API to access livecache
    //
    public class LivecacheRequest : XrlRequest
    {
        private static string behaviorInjectionHeaders = null;

        public const ulong PublicRequestLivePuid = 1;
        public static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("LivecacheRequest", "WebPlatform_Livecache");

        private LivecacheKey _cacheKey;
        private bool _hasInvalidation;
        private ulong _requestingUserId = 0;
        private AAInfo _aaInfo = null;

        internal LivecacheRequest(
                ulong requestingUserId,
                LivecacheClientType client,
                LcserviceId lcserviceId,
                XRLObject2 request2,
                uint titleID,
                IAccountAuthDataProvider authdataProvider
                )
            : this(requestingUserId,
                client,
                lcserviceId,
                request2,
                titleID,
                EnsureExtendedAuthData2(authdataProvider),
                null,
                null)
        {
        }

        internal LivecacheRequest(
            ulong requestingUserId,
            LivecacheClientType client,
            LcserviceId lcserviceId,
            XRLObject2 request2,
            uint titleID,
            IAccountAuthDataProvider authdataProvider,
            LivecacheDependency dependency,
            LivecacheDependency invalidation
            )
            : this(requestingUserId,
                client,
                lcserviceId,
                request2,
                titleID,
                EnsureExtendedAuthData2(authdataProvider),
                dependency,
                invalidation)
        {
        }

        internal LivecacheRequest(
            ulong requestingUserId,
            LivecacheClientType client,
            LcserviceId lcserviceId,
            XRLObject2 request2,
            uint titleID,
            IExtendedAuthDataProvider2 authdataProvider,
            LivecacheDependency dependency,
            LivecacheDependency invalidation
            )
            : this(requestingUserId,
                 client,
                 lcserviceId,
                 request2.GetBytes(),
                 authdataProvider != null ? authdataProvider.XboxPuid : 0,
                 titleID,
                 authdataProvider,
                 dependency,
                 invalidation,
                 request2)
        {
            this.ContentTypeOverride = request2.ContentType;
            if (authdataProvider != null && authdataProvider.ClientPlatform != XOn.XPLT_INVALID)
            {
                base.RequestHeaders.Add(XHttpHdr.XPLT_I, authdataProvider.ClientPlatform.ToString());
            }
            if (authdataProvider != null)
            {
                if (authdataProvider.WebHeaderCollection != null)
                {
                    base.RequestHeaders.Add(XHttpHdr.HEADERCOLLECTION, authdataProvider.WebHeaderCollection.GetEncodedString());
                }
            }
        }

        internal LivecacheRequest(
                ulong requestingUserId,
                LivecacheClientType client,
                LcserviceId lcserviceId,
                byte[] postData,
                ulong xboxID,
                uint titleID,
                IAccountAuthDataProvider authdataProvider,
                LivecacheDependency dependency,
                LivecacheDependency invalidation,
                object requestObjectForDbg
                )
            : this(requestingUserId,
                client,
                lcserviceId,
                postData,
                CreateHTTPAuthData(requestingUserId, client, lcserviceId, xboxID, titleID, EnsureExtendedAuthData2(authdataProvider)),
                dependency,
                invalidation,
                false,
                0,
                requestObjectForDbg)
        {
        }

        private LivecacheRequest(
                ulong requestingUserId,
                LivecacheClientType client,
                LcserviceId lcserviceId,
                byte[] postData,
                HTTPAuthData httpAuthData,
                LivecacheDependency dependency,
                LivecacheDependency invalidation,
                bool hashProvided,
                ulong partitionHash,
                object requestObjectForDbg
                )
            : base()
        {
            //check service requirement
            uint clientServiceId = LivecacheUtil.GetClientServiceId(client, lcserviceId);
            LcserviceInfo si = LcserviceInfo.Lookup(clientServiceId);
            _lcServiceId = lcserviceId;
            _serviceInfo = si;
            _requestingUserId = requestingUserId;

            if (!si.ExpectedDependency.Check(dependency))
            {
                throw new LivecacheCodeErrorException("required dependency for this SPI was not supplied");
            }

            if (!si.ExpectedInvalidation.Check(invalidation))
            {
                throw new LivecacheCodeErrorException("required invalidation for this SPI was not supplied");
            }

            Debug.Assert(Config.GetBoolSetting(Setting.livecache_serviceEnabled), "check LivecacheServiceEnabled first");

            if (_interfaceBucketChangeEventHandler == null)
            {
                _interfaceBucketChangeEventHandler = new InterfaceBucketChangeEventHandler(OnInterfaceBucketChange);
                Config.InterfaceBucketChange += _interfaceBucketChangeEventHandler;
            }

            LivecacheKey key = new LivecacheKey((int)clientServiceId, requestingUserId, postData);

            if (!hashProvided)
            {
                if (dependency != null)
                {
                    // consider: we could partition on both Puid and DataSet for more even distribution. However,
                    // if we ever support multiple data sets, that makes it harder to invalidate.
                    partitionHash = dependency.Puid;
                }
                else if (invalidation != null)
                {
                    partitionHash = invalidation.Puid;
                }
                else
                {
                    partitionHash = (ulong)key.GetHashCode();
                }
            }

            uint partition = Config.GetBucketNum(Interface.livecache, partitionHash);
            IBucketServer bucket = Config.GetBucketServer(Interface.livecache, partition);

            base.TargetInterfaceInfo = bucket.CurrentServer;
            base.Path = LivecacheConst.TargetXrl;
            base.AuthData = httpAuthData.GetBase64EncodedString();
            base.PostData = postData;
            base.RequestHeaders.Add(LivecacheConst.LcserviceIdHeader, ((int)clientServiceId).ToString());

            if (dependency != null)
            {
                base.RequestHeaders.Add(LivecacheConst.LcDependHeader, dependency.ToString());
                _logArea.LogVerbose("LivecacheRequest: depends={0}", dependency);
            }

            if (invalidation != null)
            {
                base.RequestHeaders.Add(LivecacheConst.LcUpdateHeader, invalidation.ToString());
                _logArea.LogVerbose("LivecacheRequest: invalidates={0}", invalidation);
                _hasInvalidation = true;
            }

            // debug only function to add BehaviorInjection headers
            AddBehaviorInjectionHeadersInDebug();

            _requestObjectForDbg = requestObjectForDbg;
            _cacheKey = key;

            _logArea.LogVerbose("LivecacheRequest: service={0}, requester={1}, url={2}", clientServiceId, requestingUserId, base.Url);
        }

        private static HTTPAuthData CreateHTTPAuthData(
                ulong requestingUserId,
                LivecacheClientType client,
                LcserviceId lcserviceId,
                ulong xboxID,
                uint titleID,
                IExtendedAuthDataProvider2 authdataProvider)
        {
            //user validation
            if (authdataProvider != null && authdataProvider.LivePuid != requestingUserId)
            {
                throw new LivecacheCodeErrorException(String.Format("Account livePuid {0} in Authdata provider does not match requesting user livePuid {1}",
                                                                    authdataProvider.LivePuid,
                                                                    requestingUserId));
            }

            if (authdataProvider != null && (authdataProvider.Privileges == null || authdataProvider.Privileges.Length == 0))
            {
                throw new LivecacheCodeErrorException("No valid privileges in Authdata provider");
            }

            uint clientServiceId = LivecacheUtil.GetClientServiceId(client, lcserviceId);
            LcserviceInfo si = LcserviceInfo.Lookup(clientServiceId);

            // get current language and country
            // when is CurrentLocaleHandler not set, default everything to zero.
            // also default to zero if the SPI is not locale sensitive (eg. does not return a string)
            uint langID = 0;
            uint countryID = 0;

            if (si.CultureSensitive && CurrentLocaleHandler != null)
            {
                CurrentLocaleHandler(out langID, out countryID);
            }

            // set user flags
            uint userFlags = 0;
            XUIDAndTrust.SetUserFlagCountry(ref userFlags, countryID);
            XUIDAndTrust.SetUserFlagLanguage(ref userFlags, langID);

            byte tier = 0;
            if (authdataProvider != null)
            {
                tier = authdataProvider.Tier;
            }
            XUIDAndTrust.SetUserFlagTier(ref userFlags, tier);

            ushort port = 0;
            uint ip = 0;

            if (authdataProvider != null)
            {
                IPEndPoint endpoint = authdataProvider.ClientIPEndPoint;

                if (endpoint != null)
                {
                    // Make sure we've gotten the expected IP4 address family before trying to interperet
                    // the address and port info

                    if (endpoint.AddressFamily != System.Net.Sockets.AddressFamily.InterNetwork)
                    {
                        throw new ArgumentOutOfRangeException("When creating HttpAuthData for an LcRequest, the IPEndPoint specified in AuthdataProvider.ClientIPEndPoint must have an AddressFamily of InterNetwork. Actually got an AddressFamily of " + endpoint.AddressFamily.ToString());
                    }

                    byte[] addr = endpoint.Address.GetAddressBytes();
                    ip = ((uint)addr[0]) +
                        ((uint)addr[1] << 8) +
                        ((uint)addr[2] << 16) +
                        ((uint)addr[3] << 24);

                    port = (ushort)endpoint.Port;
                }
            }

            // build a XUIDAndTrust structure with userID and userFlags
            XUIDAndTrust[] userTrusts = new XUIDAndTrust[1];
            userTrusts[0] = new XUIDAndTrust(requestingUserId, userFlags, 0.0F);

            HTTPAuthData authData = new HTTPAuthData(
                port,
                ip,
                0,  // request ID
                xboxID,
                userTrusts,
                titleID,
                si.LiveServiceId,
                0);  // 2nd service ID

            if (si.LiveServiceId == (uint)XOService.Billing_Offering)
            {
                // xbos services occationally checks Base_Subscription or User_Account
                authData.SetPrivilege((byte)XOService.Base_Subscription);
                authData.SetPrivilege((byte)XOService.User_Account);
            }

            authData.OverrideAuthDataFlags |= SGInfo.XONLINE_AUTHDATA_FLAGS_ISXENON_MASK;
            authData.OverrideLanguageID = (ushort)langID;

            // append user privileges to authdata
            if (authdataProvider != null)
            {
                uint[] privileges = authdataProvider.Privileges;
                // REVIEW: privileges may contain the low order service bits as well as high bits.
                // for now, combine user privilege with those set by livecache
                uint[] services = authData.OverridePrivileges;

                for (int i = 0; i < privileges.Length && i < services.Length; i++)
                {
                    privileges[i] |= services[i];
                }

                authData.OverridePrivileges = privileges;
            }

            return authData;
        }

        public static LivecacheRequest SaveDataRequest(string key, byte[] value, uint seconds)
        {
            return SaveDataRequest(0, key, value, seconds);
        }

        public static LivecacheRequest SaveDataRequest(ulong livePuid, string key, byte[] value, uint seconds)
        {
            if (key == null)
            {
                throw new ArgumentNullException("key");
            }
            if (key.Length == 0)
            {
                throw new ArgumentException("key too short", "key");
            }
            if (key.Length > LcConstants.MaxKeyLength)
            {
                throw new ArgumentException("key too long", "key");
            }
            if (value == null)
            {
                throw new ArgumentNullException("value");
            }
            if (value.Length > LcConstants.MaxDataLength)
            {
                throw new ArgumentException("data too long", "value");
            }
            if (seconds == 0)
            {
                throw new ArgumentOutOfRangeException("seconds", "zero second not allowed");
            }
            if (seconds > 100 * 24 * 3600)
            {
                throw new ArgumentOutOfRangeException("seconds", "session data cannot last over 100 days");
            }

            LivecacheSaveDataRequest req = new LivecacheSaveDataRequest();
            req.SecondsToCache = seconds;
            req.Key = key;
            req.Value = value;

            return NewSessionDataRequest(LcserviceId.SaveData, livePuid, key, req);
        }

        public static LivecacheRequest LoadDataRequest(string key)
        {
            return LoadDataRequest(0, key);
        }

        public static LivecacheRequest LoadDataRequest(ulong livePuid, string key)
        {
            if (key == null)
            {
                throw new ArgumentNullException("key");
            }
            if (key.Length == 0)
            {
                throw new ArgumentException("key too short", "key");
            }
            if (key.Length > LcConstants.MaxKeyLength)
            {
                throw new ArgumentException("key too long", "key");
            }

            LivecacheLoadDataRequest req = new LivecacheLoadDataRequest();
            req.Key = key;

            return NewSessionDataRequest(LcserviceId.LoadData, livePuid, key, req);
        }

        public static LivecacheRequest ClearDataRequest(string key)
        {
            return ClearDataRequest(0, key);
        }

        public static LivecacheRequest ClearDataRequest(ulong livePuid, string key)
        {
            if (key == null)
            {
                throw new ArgumentNullException("key");
            }
            if (key.Length == 0)
            {
                throw new ArgumentException("key too short", "key");
            }
            if (key.Length > LcConstants.MaxKeyLength)
            {
                throw new ArgumentException("key too long", "key");
            }

            LivecacheClearDataRequest req = new LivecacheClearDataRequest();
            req.Key = key;

            return NewSessionDataRequest(LcserviceId.ClearData, livePuid, key, req);
        }

        private static LivecacheRequest NewSessionDataRequest(LcserviceId lcserviceId, ulong livePuid, string key, XRLObject2 req)
        {
            ulong partitionHash = (livePuid == 0) ? (ulong)key.GetHashCode() : livePuid;
            return NewNativeCommandRequest(lcserviceId, livePuid, partitionHash, req);
        }

        private static LivecacheRequest NewNativeCommandRequest(LcserviceId lcserviceId, ulong livePuid, ulong partitionHash, XRLObject2 req)
        {
            return new LivecacheRequest(livePuid, 0, lcserviceId, req.GetBytes(), CreateHTTPAuthData(0, 0, lcserviceId, 0, 0, null), null, null, true, partitionHash, req);
        }

        // Use LocalLivecache to reduce round trips to the LiveCache server when multiple identical requests are made to 
        // LiveCache in the same request (managed by the context set through LocalLivecache.PerRequestContext)
        public new uint Send()
        {
            LocalLivecache local = LocalLivecache.GetCurrent();

            if (local == null)
            {
                // this can happen if context is null(ie: we're called outside of an httpcontext) or a 
                // LocalLivecache.PerRequestContext has not been defined
                // just call the base class and skip all local caching
                return base.Send();
            }

            bool shouldCache = local.ShouldCacheRequest(this);
            bool shouldThrottle = local.ShouldApplyPerUserThrottle(this);

            if (_hasInvalidation)
            {
                local.Clear();
            }
            else
            {
                if (shouldCache)
                {
                    // check cached results
                    if (local.ContainsKey(_cacheKey.Value))
                    {
                        LocalLivecacheEntry entry = local[_cacheKey.Value];
                        base.ResponseData = entry.ResponseData;
                        base.Hr = entry.Hr;
                        _logArea.LogVerbose("Locally cached LiveCache response returned for service ID {0:x}.", _lcServiceId);
                        return base.Hr;
                    }
                }
            }

            // first livecache request of each page view counts towards user's hourly quota
            // don't count anonymous or impersonated requests
            if (shouldThrottle)
            {
                if ((local.UserLivePuid != 0) && (local.UserLivePuid == _requestingUserId))
                {
                    if (!local.IsQuotaApplied)
                    {
                        this.RequestHeaders[LivecacheConst.LcHourlyQuotaHeader] = local.UserLivePuid.ToString("x");
                        local.IsQuotaApplied = true;
                    }
                }
            }

            // Add the AAInfo if one was added
            if (_aaInfo != null)
            {
                AAInfo.MarshallToHeaders(base.RequestHeaders, _aaInfo);
            }

            uint hr = base.Send();

            if (shouldThrottle && (hr == HResult.XONLINE_E_LIVECACHE_USER_OVERHEAT))
            {
                throw new LivecacheUserThrottledException(local.UserLivePuid);
            }

            if (!_hasInvalidation && shouldCache)
            {
                LocalLivecacheEntry entry = new LocalLivecacheEntry();
                entry.Hr = hr;
                entry.ResponseData = base.ResponseData;
                local.Add(_cacheKey.Value, entry);
            }

            return hr;
        }

        // HTTP expires header date/time value conforms to RFC 1123  which
        // prescribes english. Bug in .NET prevents parsing value when the
        // culture is "es-*" or "it-*".  Just parse the value  in  english.

        private static CultureInfo EnUsCultureInfo = new CultureInfo("en-US");

        public DateTime ResponseExpiry
        {
            get
            {
                string expiry = (base.ResponseHeaders == null) ? null : base.ResponseHeaders["expires"];
                return (expiry == null) ? DateTime.Now : DateTime.Parse(expiry, EnUsCultureInfo); 
            }
        }

        public void AddAAInfoToRequest(AAInfo info)
        {
            _aaInfo = info;
        }

        public string ToDiagString()
        {
            StringBuilder sb = new StringBuilder();

            switch (base.Hr)
            {
                case HResult.S_OK:
                    sb.Append("Livecache Request OK");
                    break;

                case HResult.XONLINE_E_LIVECACHE_USER_OVERHEAT:
                    sb.Append("Livecache per-user throttle limit reached");
                    break;

                case HResult.XONLINE_E_TASK_THROTTLED:
                    sb.Append("Livecache API throttle limit reached");
                    break;

                case HResult.XONLINE_E_LIVECACHE_FORWARD_FAILED:
                    sb.Append("LIVE service front door not responding");
                    break;

                case HResult.XONLINE_E_LIVECACHE_OFFLINE:
                    sb.Append("Livecache has been set offline through NPDB configuration setting");
                    break;

                default:
                    sb.Append("LIVE Service front door returned an error");
                    break;
            }

            sb.Append(", HResult=");
            sb.Append(base.Hr.ToString());

            string serviceName = Enum.GetName(typeof(XOService), _serviceInfo.LiveServiceId);
            if (!String.IsNullOrEmpty(serviceName))
            {
                sb.Append("\nCalling LIVE service front door: ");
                sb.Append(serviceName);
            }

            string apiName = Enum.GetName(typeof(LcserviceId), _lcServiceId);
            if (!String.IsNullOrEmpty(apiName))
            {
                sb.Append("\nfor API: ");
                sb.Append(apiName);
            }

            if (_isPrivate)
            {
                sb.Append("\n\nPrivate Data Suppressed\n\n");
            }
            else
            {
                sb.Append("\n\nRequest: ");
                if (_requestObjectForDbg != null)
                {
                    sb.Append(_requestObjectForDbg.ToString());
                }
                else if (base.PostData != null)
                {
                    sb.Append(DB400(base.PostData));
                }
                else
                {
                    sb.Append("null");
                }

                sb.Append("\n\nResponse: ");
                if (base.ResponseOb != null)
                {
                    sb.Append(base.ResponseOb.ToString());
                }
                else if (base.ResponseData != null)
                {
                    sb.Append(DB400(base.ResponseData));
                }
                else
                {
                    sb.Append("null");
                }
                sb.Append("\n\n");
            }

            return sb.ToString();
        }
        private object _requestObjectForDbg;

        public uint GetEventID()
        {
            if (base.Hr == HResult.XONLINE_E_LIVECACHE_USER_OVERHEAT)
            {
                return (uint)LcSysEventId.Livecache_ThrottledForSpam;
            }
            else if (base.Hr == HResult.XONLINE_E_TASK_THROTTLED)
            {
                return (uint)LcSysEventId.Livecache_ThrottledForTPS;
            }

            return _serviceInfo.EventId;
        }
        private LcserviceInfo _serviceInfo;
        private LcserviceId _lcServiceId = LcserviceId.Unknown;

        // dump first 400 bytes to string
        protected string DB400(byte[] raw)
        {
            int len = Math.Min(400, raw.Length);
            return BitConverter.ToString(raw, 0, len);
        }

        public static LivecacheLocaleHandler CurrentLocaleHandler;

        private static void OnInterfaceBucketChange(object sender, InterfaceBucketChangeEventArgs e)
        {
            // need no action
        }

        private static InterfaceBucketChangeEventHandler _interfaceBucketChangeEventHandler = null;

        private static IExtendedAuthDataProvider2 EnsureExtendedAuthData2(IAccountAuthDataProvider authProvider)
        {
            if (authProvider == null)
                return null;
            else if (authProvider is IExtendedAuthDataProvider2)
                return (IExtendedAuthDataProvider2)authProvider;
            else if(authProvider is IExtendedAuthDataProvider)
                return new ExtendedAuthWrapperForIExtendedAuthDataProvider((IExtendedAuthDataProvider)authProvider);
            else
                return new ExtendedAuthWrapperForIAccountAuthProvider(authProvider);
        }

        private bool _isPrivate = false;
        public bool IsPrivate
        {
            get { return _isPrivate; }
            set { _isPrivate = value; }
        }




        [Conditional("DEBUG")]
        private void AddBehaviorInjectionHeadersInDebug()
        {
            if (behaviorInjectionHeaders == null)
            {
                LookupBehaviorInjectionHeadersInDebug();
            }

            if (!string.IsNullOrEmpty(behaviorInjectionHeaders))
            {
                base.RequestHeaders.Add("BEHAVIOR_INJECTION_FORWARD", behaviorInjectionHeaders);
            }
        }

        private static object _initLockObject = new object();

        [Conditional("DEBUG")]
        private void LookupBehaviorInjectionHeadersInDebug()
        {
            lock (_initLockObject)
            {

                if (behaviorInjectionHeaders != null)
                {
                    return;
                }

                try
                {
                    if (System.IO.File.Exists(System.IO.Path.Combine(Environment.CurrentDirectory, "EnableBehaviorInjection.txt")))
                    {
                        // all behavior injection values should be specified on the first line of the file, all on one line as you want them to appear in the request header
                        string[] behaviors = System.IO.File.ReadAllLines(System.IO.Path.Combine(Environment.CurrentDirectory, "EnableBehaviorInjection.txt"));
                        if (behaviors.Length > 0)
                        {
                            behaviorInjectionHeaders = behaviors[0];
                        }
                    }
                }
                finally
                {
                    if (behaviorInjectionHeaders == null)
                    {
                        behaviorInjectionHeaders = string.Empty;
                    }
                }
            }
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\LcServiceInfo.cs ===
using System;
using System.Collections;
using System.Data.SqlClient;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.sql.sqlclient;

namespace xonline.common.webplatform.livecache
{
    public class LcserviceInfo
    {
        private static Object _lockObject = new Object();
        private static ILivecacheLogger _logArea = LivecacheClient.CreateLogger("LcserviceInfo", "WebPlatform_Livecache");

        private static Hashtable _serviceMappingTbl = null;
        private static byte _initializedClientType = 0xFF; // no client type specified yet

        public uint LiveServiceId;
        public LivecacheDependencyRequired ExpectedDependency;
        public LivecacheDependencyRequired ExpectedInvalidation;
        public bool CultureSensitive;
        public uint EventId;

        static LcserviceInfo()
        {
            Config.SettingChange += new SettingChangeEventHandler(Config_SettingChange);
            Config.GetSetting(Setting.livecache_lastModified); // tell Config we're insterested in this
        }

        public static LcserviceInfo Lookup(uint clientServiceId)
        {
            byte clientId = LivecacheUtil.GetClientId(clientServiceId);

            if (_initializedClientType != 0xFF && _initializedClientType != clientId)
            {
                string message = String.Format("Lookup was requested for a different client type than the one used in the first call to Lookup. Only one client type is allowed to be used in a single process. Initial client type = {0}, requested client type = {1}.",
                    Enum.GetName(typeof(LivecacheClientType), _initializedClientType),
                    Enum.GetName(typeof(LivecacheClientType), clientId));

                throw new LivecacheCodeErrorException(message);
            }

            if (_serviceMappingTbl == null)
            {
                _initializedClientType = clientId;
                InitLookupTable(false);
            }

            LcserviceInfo si = (LcserviceInfo)(_serviceMappingTbl[clientServiceId]);

            if (si == null)
            {
                throw new LivecacheConfigException("npdb..t_livecache_apis", string.Format("Request made for unknown Livecache API {0}({1}). Check npdb..t_livecache_apis.", 
                                                                                        (LcserviceId)LivecacheUtil.GetBaseServiceId(clientServiceId),
                                                                                        clientServiceId));
            }

            return si;
        }

        private static void InitLookupTable(bool force)
        {
            lock (_lockObject)
            {
                if (force || _serviceMappingTbl == null)
                {
                    _logArea.LogInfo("reloading livecache service info");
                    _serviceMappingTbl = LoadLivecacheServiceMapping();
                }
            }
        }

        private static void Config_SettingChange(object sender, SettingChangeEventArgs e)
        {
            if (e.Setting == Setting.livecache_lastModified)
            {
                if (_initializedClientType != 0xFF)
                {
                    // only force the reload if we've loaded at least once
                    InitLookupTable(true);
                }
            }
        }

        private static Hashtable LoadLivecacheServiceMapping()
        {
            Hashtable services = new Hashtable();
            Hashtable eventIDs = GetEventIdMappingTable();

            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "p_livecache_get_forward_service_list";
                SqlDataReader reader = cmd.Execute();

                while (reader.Read())
                {

                    uint lcserviceId = (uint)(int)reader["i_lcservice_id"];
                    string viName = (string)reader["vc_virtual_interface"];

                    // only load info for the initialized client type
                    if (LivecacheUtil.GetClientId(lcserviceId) == _initializedClientType)
                    {
                        try
                        {
                            IVirtualInterfaceInfo interfaceInfo;
                            try
                            {
                                interfaceInfo = Config.GetVirtualInterface(viName, Site.main);
                            }
                            catch (ArgumentException ex)
                            {
                                _logArea.LogError(LcSysEventId.LivecacheAPI_InvalidInterface,
                                    ex,
                                    "Invalid livecache service entry: {0} is not a valid virtual interface name.",
                                    viName);

                                continue;
                            }

                            LcserviceInfo si = new LcserviceInfo();
                            si.ExpectedDependency.Flags = (byte)reader["tn_required_dependency"];
                            si.ExpectedInvalidation.Flags = (byte)reader["tn_required_invalidation"];
                            si.CultureSensitive = (bool)reader["b_culture_sensitive"];
                            si.LiveServiceId = (uint)interfaceInfo.ServiceId;

                            try
                            {
                                si.EventId = (uint)eventIDs[LivecacheUtil.GetBaseServiceId(lcserviceId)];
                            }
                            catch (Exception ex)
                            {
                                _logArea.LogError(LcSysEventId.LivecacheAPI_EventMap, ex, "livecache API {0} needs event ID mapping", lcserviceId);
                                si.EventId = (uint)LcRequestEventId.Unknown;
                            }

                            services.Add(lcserviceId, si);
                        }
                        catch (Exception ex)
                        {
                            //
                            // log an error event but continue load the rest of the table.
                            // if we abort, we'll be called again on next request. before
                            // human intervention, we'll hit this error repeatedly while
                            // failing all requests. having some tolerance to the error
                            // seems the better choice.
                            //

                            _logArea.LogError(LcSysEventId.LivecacheAPI_Load,
                                ex,
                                "Error loading livecache API entry. Ignored.");
                        }
                    }
                }
            }

            // add native livecache services
            AddNativeCommand(services, eventIDs, LcserviceId.CacheInvalidate);
            AddNativeCommand(services, eventIDs, LcserviceId.LoadData);
            AddNativeCommand(services, eventIDs, LcserviceId.SaveData);
            AddNativeCommand(services, eventIDs, LcserviceId.ClearData);

            return services;
        }

        private static void AddNativeCommand(Hashtable services, Hashtable eventIDs, LcserviceId serviceId)
        {
            LcserviceInfo si = new LcserviceInfo();
            si.LiveServiceId = (uint)serviceId;
            si.EventId = (uint)eventIDs[(ushort)serviceId];
            si.CultureSensitive = false;
            services.Add((uint)serviceId, si);
        }

        private static Hashtable GetEventIdMappingTable()
        {
            Hashtable mapping = new Hashtable();

            mapping[(ushort)LcserviceId.CacheInvalidate] = LcRequestEventId.CacheInvalidate;
            mapping[(ushort)LcserviceId.LoadData] = LcRequestEventId.LoadData;
            mapping[(ushort)LcserviceId.SaveData] = LcRequestEventId.SaveData;
            mapping[(ushort)LcserviceId.ClearData] = LcRequestEventId.ClearData;

            mapping[(ushort)LcserviceId.GetFriends] = LcRequestEventId.GetFriends;
            mapping[(ushort)LcserviceId.GetPresenceInfo] = LcRequestEventId.GetPresenceInfo;
            mapping[(ushort)LcserviceId.AddFriend] = LcRequestEventId.AddFriend;
            mapping[(ushort)LcserviceId.DeleteFriend] = LcRequestEventId.DeleteFriend;
            mapping[(ushort)LcserviceId.AcceptFriendRequest] = LcRequestEventId.AcceptFriendRequest;
            mapping[(ushort)LcserviceId.RejectFriendRequest] = LcRequestEventId.RejectFriendRequest;
            mapping[(ushort)LcserviceId.QueryAffiliates] = LcRequestEventId.QueryAffiliates;
            mapping[(ushort)LcserviceId.GetPublicPresenceInfo] = LcRequestEventId.GetPublicPresenceInfo;
            mapping[(ushort)LcserviceId.WebAlive] = LcRequestEventId.WebAlive;
            mapping[(ushort)LcserviceId.WebAlive2] = LcRequestEventId.WebAlive2;
            mapping[(ushort)LcserviceId.GetFriendsOfFriend] = LcRequestEventId.GetFriendsOfFriend;
            mapping[(ushort)LcserviceId.AddFriendFromContact] = LcRequestEventId.AddFriendFromContact;
                
            mapping[(ushort)LcserviceId.VetString] = LcRequestEventId.VetString;
            mapping[(ushort)LcserviceId.StringLookup] = LcRequestEventId.StringLookup;

            mapping[(ushort)LcserviceId.LinkWebAccount] = LcRequestEventId.LinkWebAccount;
            mapping[(ushort)LcserviceId.CreateXboxComAccount] = LcRequestEventId.CreateXboxComAccount;
            mapping[(ushort)LcserviceId.CreateLiveAccount] = LcRequestEventId.CreateLiveAccount;
            mapping[(ushort)LcserviceId.UpsGetProfile] = LcRequestEventId.UpsGetProfile;
            mapping[(ushort)LcserviceId.UpsUpdateProfile] = LcRequestEventId.UpsUpdateProfile;
            mapping[(ushort)LcserviceId.ReserveName] = LcRequestEventId.ReserveName;
            mapping[(ushort)LcserviceId.UpdateXboxComActivity] = LcRequestEventId.UpdateXboxComActivity;
            mapping[(ushort)LcserviceId.GetUserWebInfo] = LcRequestEventId.GetUserWebInfo;
            mapping[(ushort)LcserviceId.GetLinkedGamertag] = LcRequestEventId.GetLinkedGamertag;
            mapping[(ushort)LcserviceId.GetUserType] = LcRequestEventId.GetUserType;
            mapping[(ushort)LcserviceId.GetAccountInfo] = LcRequestEventId.GetAccountInfo;
            mapping[(ushort)LcserviceId.SetAccountInfo] = LcRequestEventId.SetAccountInfo;
            mapping[(ushort)LcserviceId.MigrateXbox1User] = LcRequestEventId.MigrateXbox1User;
            mapping[(ushort)LcserviceId.MigrateXboxComUser] = LcRequestEventId.MigrateXboxComUser;
            mapping[(ushort)LcserviceId.VerifyBillingInfo] = LcRequestEventId.VerifyBillingInfo;
            mapping[(ushort)LcserviceId.GetUserSubscriptionDetails] = LcRequestEventId.GetUserSubscriptionDetails;
            mapping[(ushort)LcserviceId.GetPointsBalance] = LcRequestEventId.GetPointsBalance;
            mapping[(ushort)LcserviceId.AddPaymentInstrument] = LcRequestEventId.AddPaymentInstrument;
            mapping[(ushort)LcserviceId.RemovePaymentInstrument] = LcRequestEventId.RemovePaymentInstrument;
            mapping[(ushort)LcserviceId.UpdatePaymentInstrument] = LcRequestEventId.UpdatePaymentInstrument;
            mapping[(ushort)LcserviceId.GetPaymentInstruments] = LcRequestEventId.GetPaymentInstruments;
            mapping[(ushort)LcserviceId.CancelOffer] = LcRequestEventId.CancelOffer;
            mapping[(ushort)LcserviceId.VerifyParentCreditCard] = LcRequestEventId.VerifyParentCreditCard;
            mapping[(ushort)LcserviceId.UpdateParentalControls] = LcRequestEventId.UpdateParentalControls;
            mapping[(ushort)LcserviceId.PassportGetMemberName] = LcRequestEventId.PassportGetMemberName;
            mapping[(ushort)LcserviceId.ChangeSubscriptionPaymentInstrument] = LcRequestEventId.ChangeSubscriptionPaymentInstrument;
            mapping[(ushort)LcserviceId.GetGamerProfileTypes] = LcRequestEventId.GetGamerProfileTypes;
            mapping[(ushort)LcserviceId.TroubleshootAccount] = LcRequestEventId.TroubleshootAccount;
            mapping[(ushort)LcserviceId.ChangeGamerTag] = LcRequestEventId.ChangeGamerTag;
            mapping[(ushort)LcserviceId.AcceptTOU] = LcRequestEventId.AcceptTOU;
            mapping[(ushort)LcserviceId.LinkXbox1Account] = LcRequestEventId.LinkXbox1Account;
            mapping[(ushort)LcserviceId.PassportGetPuidFromMemberName] = LcRequestEventId.PassportGetPuidFromMemberName;
            mapping[(ushort)LcserviceId.AcceptTermsOfService] = LcRequestEventId.AcceptTermsOfService;
            mapping[(ushort)LcserviceId.GraduateUser] = LcRequestEventId.GraduateUser;
            mapping[(ushort)LcserviceId.GetCachedPointsBalance] = LcRequestEventId.GetCachedPointsBalance;

            mapping[(ushort)LcserviceId.SyncSettings] = LcRequestEventId.SyncSettings;
            mapping[(ushort)LcserviceId.ReadSettings] = LcRequestEventId.ReadSettings;
            mapping[(ushort)LcserviceId.EnumTitles] = LcRequestEventId.EnumTitles;
            mapping[(ushort)LcserviceId.AchievementEnum] = LcRequestEventId.AchievementEnum;
            mapping[(ushort)LcserviceId.PublicReadSettings] = LcRequestEventId.PublicReadSettings;
            mapping[(ushort)LcserviceId.PublicEnumTitles] = LcRequestEventId.PublicEnumTitles;
            mapping[(ushort)LcserviceId.SyncAchievements] = LcRequestEventId.SyncAchievements;
            mapping[(ushort)LcserviceId.SyncTitles] = LcRequestEventId.SyncTitles;
            mapping[(ushort)LcserviceId.AvatarAwardEnum] = LcRequestEventId.AvatarAwardEnum;
            mapping[(ushort)LcserviceId.ValidateAvatarManifest] = LcRequestEventId.ValidateAvatarManifest;
            mapping[(ushort)LcserviceId.SyncAvatarAssets] = LcRequestEventId.SyncAvatarAssets;

            mapping[(ushort)LcserviceId.SubscriptionEnum] = LcRequestEventId.SubscriptionEnum;
            mapping[(ushort)LcserviceId.SubscriptionDetails] = LcRequestEventId.SubscriptionDetails;
            mapping[(ushort)LcserviceId.OfferingVerifyToken] = LcRequestEventId.OfferingVerifyToken;
            mapping[(ushort)LcserviceId.PurchaseSubscription] = LcRequestEventId.PurchaseSubscription;
            mapping[(ushort)LcserviceId.PurchasePoints] = LcRequestEventId.PurchasePoints;
            mapping[(ushort)LcserviceId.ContentEnum] = LcRequestEventId.ContentEnum;
            mapping[(ushort)LcserviceId.ContentDetails] = LcRequestEventId.ContentDetails;
            mapping[(ushort)LcserviceId.PurchaseMediaOffers] = LcRequestEventId.PurchaseMediaOffers;
            mapping[(ushort)LcserviceId.FindMediaInstanceUrls] = LcRequestEventId.FindMediaInstanceUrls;
            mapping[(ushort)LcserviceId.PurchaseHistory] = LcRequestEventId.PurchaseHistory;
            mapping[(ushort)LcserviceId.VerifyToken] = LcRequestEventId.VerifyToken;
            mapping[(ushort)LcserviceId.CachedPurchaseHistory] = LcRequestEventId.CachedPurchaseHistory;
            mapping[(ushort)LcserviceId.CreateDownloadQueue] = LcRequestEventId.CreateDownloadQueue;
            mapping[(ushort)LcserviceId.QueryDownloadQueues] = LcRequestEventId.QueryDownloadQueues;
            mapping[(ushort)LcserviceId.QueryDownloadItems] = LcRequestEventId.QueryDownloadItems;
            mapping[(ushort)LcserviceId.InsertDownloadItems] = LcRequestEventId.InsertDownloadItems;
            mapping[(ushort)LcserviceId.DeleteDownloadItems] = LcRequestEventId.DeleteDownloadItems;
            mapping[(ushort)LcserviceId.MoveDownloadItems] = LcRequestEventId.MoveDownloadItems;
            mapping[(ushort)LcserviceId.ModifyDownloadItems] = LcRequestEventId.ModifyDownloadItems;
            mapping[(ushort)LcserviceId.QueryLists] = LcRequestEventId.QueryLists;
            mapping[(ushort)LcserviceId.QueryListItems] = LcRequestEventId.QueryListItems;
            mapping[(ushort)LcserviceId.QueryDownloadQueuesNonCached] = LcRequestEventId.QueryDownloadQueuesNonCached;

            mapping[(ushort)LcserviceId.StorageWrite] = LcRequestEventId.StorageWrite;
            mapping[(ushort)LcserviceId.StorageRemove] = LcRequestEventId.StorageRemove;
            mapping[(ushort)LcserviceId.StorageRead] = LcRequestEventId.StorageRead;
            mapping[(ushort)LcserviceId.StorageValidate] = LcRequestEventId.StorageValidate;

            mapping[(ushort)LcserviceId.EnumerateMessages] = LcRequestEventId.EnumerateMessages;
            mapping[(ushort)LcserviceId.GetMessageSummary] = LcRequestEventId.GetMessageSummary;
            mapping[(ushort)LcserviceId.GetMessageDetails] = LcRequestEventId.GetMessageDetails;
            mapping[(ushort)LcserviceId.DeleteMessage] = LcRequestEventId.DeleteMessage;
            mapping[(ushort)LcserviceId.SetMessageFlags] = LcRequestEventId.SetMessageFlags;
            mapping[(ushort)LcserviceId.SendMessage] = LcRequestEventId.SendMessage;
            mapping[(ushort)LcserviceId.EnumerateSystemMessages] = LcRequestEventId.EnumerateSystemMessages;
            mapping[(ushort)LcserviceId.GetSystemMessageDetails] = LcRequestEventId.GetSystemMessageDetails;
            mapping[(ushort)LcserviceId.SubmitComplaint] = LcRequestEventId.SubmitComplaint;

            mapping[(ushort)LcserviceId.GetLicenseTransferState] = LcRequestEventId.GetLicenseTransferState;
            mapping[(ushort)LcserviceId.UpdateLicenseTransferState] = LcRequestEventId.UpdateLicenseTransferState;
            mapping[(ushort)LcserviceId.RefreshGameLicense] = LcRequestEventId.RefreshGameLicense;
            mapping[(ushort)LcserviceId.GetSignedHeader] = LcRequestEventId.GetSignedHeader;
            mapping[(ushort)LcserviceId.SetBlacklistDigestState] = LcRequestEventId.SetBlacklistDigestState;

            mapping[(ushort)LcserviceId.GetUserAuthorization] = LcRequestEventId.GetUserAuthorization;

            mapping[(ushort)LcserviceId.RateMedia] = LcRequestEventId.RateMedia;
            mapping[(ushort)LcserviceId.GetUserRating] = LcRequestEventId.GetUserRating;

            mapping[(ushort)LcserviceId.AcknowledgeLicensesDelivery] = LcRequestEventId.AcknowledgeLicensesDelivery;
            mapping[(ushort)LcserviceId.AcquireMediaLicenses] = LcRequestEventId.AcquireMediaLicenses;
            mapping[(ushort)LcserviceId.AcquireMediaLicensesWeb] = LcRequestEventId.AcquireMediaLicensesWeb;
            mapping[(ushort)LcserviceId.CheckLicensesAvailability] = LcRequestEventId.CheckLicensesAvailability;

            mapping[(ushort)LcserviceId.PurchaseGamertag] = LcRequestEventId.PurchaseGamertag;

            mapping[(ushort)LcserviceId.GetSecurityTicket] = LcRequestEventId.GetSecurityTicket;
            mapping[(ushort)LcserviceId.GetPartnerSecurityTicket] = LcRequestEventId.GetPartnerSecurityTicket;

            mapping[(ushort)LcserviceId.AssetConsume] = LcRequestEventId.AssetConsume;
            mapping[(ushort)LcserviceId.AssetEnumerate] = LcRequestEventId.AssetEnumerate;

            mapping[(ushort)LcserviceId.PostLeaderboardResult] = LcRequestEventId.PostLeaderboardResult;
            mapping[(ushort)LcserviceId.GetFriendsLeaderboardInfo] = LcRequestEventId.GetFriendsLeaderboardInfo;

            mapping[(short)LcserviceId.IsConsoleIdAndSCodeBanned] = LcRequestEventId.IsConsoleIdAndSCodeBanned;

            return mapping;
        }

        internal static void ResetInitializedClientType( )
        {
            _initializedClientType = 0xFF;
            _serviceMappingTbl = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\LocalLivecache.cs ===
using System;
using System.Text;
using System.Collections;
using System.Reflection;
using System.Diagnostics;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;

namespace xonline.common.webplatform.livecache
{
    public class LocalLivecacheEntry
    {
        public uint Hr;
        public byte[] ResponseData;
    }

    public interface ILocalLivecacheContext : IContextItemProvider
    {
        bool ShouldCacheRequest(LivecacheRequest request);
        bool ShouldApplyPerUserThrottle(LivecacheRequest request);

        IAccountAuthDataProvider CurrentUser {get;}
    }

    /// <summary>
    /// client need to provide context for local livecache access
    /// </summary>
    public class LocalLivecache : System.Collections.Generic.Dictionary<string, LocalLivecacheEntry>
    {
        public static LocalLivecache GetCurrent()
        {
            ILocalLivecacheContext context = LivecacheClient.LocalLivecacheContext;

            if (context == null)
            {
                return null;
            }

            LocalLivecache local = context["LocalLivecache"] as LocalLivecache;
            if (local == null)
            {
                local = new LocalLivecache();
                context["LocalLivecache"] = local;
            }
            return context["LocalLivecache"] as LocalLivecache;
        }

        public bool IsQuotaApplied
        {
            get;
            set;
        }

        public ulong UserLivePuid
        {
            get
            {
                ulong userPuid = 0;
                ILocalLivecacheContext context = LivecacheClient.LocalLivecacheContext;

                if ((context != null) && (context.CurrentUser != null))
                {
                    userPuid = context.CurrentUser.LivePuid;
                }

                return userPuid;
            }
        }

        public bool ShouldCacheRequest(LivecacheRequest request)
        {
            bool shouldCache = false;

            ILocalLivecacheContext context = LivecacheClient.LocalLivecacheContext;
            if (context != null)
            {
                shouldCache = context.ShouldCacheRequest(request);
            }
            return shouldCache;
        }

        public bool ShouldApplyPerUserThrottle(LivecacheRequest request)
        {
            bool shouldThrottle = false;

            ILocalLivecacheContext context = LivecacheClient.LocalLivecacheContext;
            if (context != null)
            {
                shouldThrottle = context.ShouldApplyPerUserThrottle(request);
            }
            return shouldThrottle;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\LiveCacheLogger.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using xonline.common.mgmt;

namespace xonline.common.webplatform.livecache
{
    /// <summary>
    /// Abstract away the specifics of the logging library used. Allow consumers of Livecache to substitute in whichever logging system they use
    /// through LivecacheClient.RegisterCreateLoggerHandler()
    /// </summary>

    public interface ILivecacheLogger
    {
        void LogVerbose(string format, params object[] args);
        void LogInfo(string format, params object[] args);
        void LogInfo(Enum eventId, Exception ex, string format, params object[] args);
        void LogError(Enum eventId, Exception ex, string format, params object[] args);
        void LogError(Enum eventId, string format, params object[] args);
    }

    internal class LivecacheNullLogger : ILivecacheLogger
    {
        public LivecacheNullLogger()
        {
        }

        public LivecacheNullLogger(string area, string component)
        {
        }

        public void LogVerbose(string format, params object[] args)
        {
            // stub out logging (XomLogLevel.Low)
        }

        public void LogInfo(string format, params object[] args)
        {
            // stub out logging (XomLogLevel.Info)
        }

        public void LogInfo(Enum eventId, Exception ex, string format, params object[] args)
        {
            // stub out logging (XomLogLevel.Info)
        }

        public void LogError(Enum eventId, Exception ex, string format, params object[] args)
        {
            // stub out logging (XomLogLevel.Error)
        }

        public void LogError(Enum eventId, string format, params object[] args)
        {
            // stub out logging (XomLogLevel.Error)
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\client\Logic\LivecacheClient.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.common.webplatform.livecache
{
    public static class LivecacheClient
    {
        public delegate ILivecacheLogger CreateLoggerHandler(string area, string component);
        private static CreateLoggerHandler _createLoggerHandler = null;

        public static void RegisterCreateLoggerHandler(CreateLoggerHandler handler)
        {
            _createLoggerHandler = handler;
        }

        public static ILivecacheLogger CreateLogger(string area, string component)
        {
            if (_createLoggerHandler == null)
            {
                return new LivecacheNullLogger();
            }
            else
            {
                return _createLoggerHandler(area, component);
            }
        }

        public static ILocalLivecacheContext LocalLivecacheContext
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\dvt\LiveCacheSuite.cs ===
using System;
using System.Xml;
using System.Collections;

using ServerTestFramework;

namespace xonline.server.livecache.test.dvt
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\dll\livecacheapp.cs ===
using System;
using System.Net;

using xonline.common.config;
using xonline.common.service;
using xonline.common.xboxcom;
using xonline.common.mgmt;


namespace xonline.server.livecache.dll 
{
    public class LivecacheApp : FrontEndApp
    {
        protected override void OnApplicationStart()
        {
            ServicePointManager.DefaultConnectionLimit = Int32.Parse(Config.GetSetting(Setting.livecache_defaultConnectionLimit));
            ServicePointManager.Expect100Continue = false;

            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(Livecache.OnControlRequest);
            XBanc.Init();
            ServicesSettings.RegisterConfigEventHandlers();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\dvt\LiveCacheTest.cs ===
extern alias lcclient;
extern alias xboxcom;

using System;
using System.IO;
using System.Net;
using System.Text;
using System.Collections;

using ServerTestFramework;
using LiveService = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.diagnostics;
using xboxcom::xonline.common.service;
using xboxcom::xonline.common.protocol;

using xonline.common.mgmt;
using xonline.common.config;
using xboxcom::xonline.common.xboxcom;
using lcclient::xonline.common.webplatform.livecache;
using lcclient::xonline.common.webplatform.core.factory;

namespace xonline.server.livecache.test.dvt
{
    public class MyContextItemProvider : IContextItemProvider
    {
        public object this[string name] 
        {
            get
            {
                return _hash[name];
            }
            set
            {
                _hash[name] = value;
            }
        }

        private Hashtable _hash = new Hashtable();

    }


    /// <summary>
    /// Summary description for TestLiveCache.
    /// </summary>
    [TestGroup, DVT]
    class LiveCacheTest  : TestNode
    {
        private const uint TITLE_ID = XOn.WEB_TITLE_ID;

        private const uint CONTROLLER_INVERSION = 0x10040002;
        private const uint CONTROLLER_VIBRATION = 0x10040003;
        private const uint XPROFILE_GAMER_ZONE = 0x10040004;
        private const uint XPROFILE_GAMER_STOCK_TILE_URL = 0x4064000F;

        [TestCase]
        public void SendSyncSampleCode()
        {
            ulong userID1 = 0x0009FFFF00000000 + (ulong)(new Random()).Next();

            //
            // construct the request object for target API
            //
            SyncSettingsRequest syncReq = new SyncSettingsRequest();
            syncReq.TitleId = TITLE_ID;
            syncReq.UserId = userID1;
            syncReq.Version = XOn.MinDateTime;
            syncReq.StartinIndex = 0;
        
            syncReq.Settings = new UserSetting[3];
        
            syncReq.Settings[0] = new UserSetting();
            syncReq.Settings[0].Source = XOn.XSOURCE_DEFAULT;
            syncReq.Settings[0].UserId = userID1;
            syncReq.Settings[0].SettingId = XPROFILE_GAMER_ZONE;
            syncReq.Settings[0].Value = new byte[] { 0x1 };
        
            syncReq.Settings[1] = new UserSetting();
            syncReq.Settings[1].Source = XOn.XSOURCE_DEFAULT;
            syncReq.Settings[1].UserId = userID1;
            syncReq.Settings[1].SettingId = CONTROLLER_INVERSION;
            syncReq.Settings[1].Value = new byte[] { 0x2 };
        
            syncReq.Settings[2] = new UserSetting();
            syncReq.Settings[2].Source = XOn.XSOURCE_DEFAULT;
            syncReq.Settings[2].UserId = userID1;
            syncReq.Settings[2].SettingId = XPROFILE_GAMER_STOCK_TILE_URL;
            syncReq.Settings[2].Value = Encoding.ASCII.GetBytes("e:\\image");

            //
            // calling front door through livecache
            //
            Console.WriteLine("write settings...");      

            LivecacheDependency invalidates = new LivecacheDependency();
            invalidates.Puid = userID1;
            
            //LivecacheRequest lcReq = new LivecacheRequest(userID1, 
            //LcserviceId.SyncSettings, syncReq, null, invalidates);
            
            LivecacheRequest lcReq = new LivecacheRequest(
                userID1,
                LivecacheClientType.Xboxcom,
                LcserviceId.SyncSettings,
                syncReq,
                TITLE_ID,
                null,  // IAccountAuthDataProvider
                null,  // dependency
                invalidates);  // invalidates

            uint hr = lcReq.Send();

            //
            // verify result
            //
            Assert.IsTrue(hr == HResult.S_OK);
            
            SyncSettingsResponse syncResp = new SyncSettingsResponse();    
            syncResp.SetBytes(lcReq.ResponseData);
            Console.WriteLine("ver={0}, len={1}, total={2}", syncResp.Version, syncResp.SettingsLen, syncResp.TotalSettings);      
        }
    

#if false
        [TestCase]
        public void StatsSetting()
        {
            ulong userID1 = 0x0009FFFF00000000 + (ulong)(new Random()).Next();

            SyncSettingsRequest syncReq = new SyncSettingsRequest();
            syncReq.TitleId = TITLE_ID;
            syncReq.UserId = userID1;
            syncReq.Version = XOn.MinDateTime;
            syncReq.StartinIndex = 0;
        
            syncReq.Settings = new UserSetting[3];
        
            syncReq.Settings[0] = new UserSetting();
            syncReq.Settings[0].Source = XOn.XSOURCE_DEFAULT;
            syncReq.Settings[0].UserId = userID1;
            syncReq.Settings[0].SettingId = XPROFILE_GAMER_ZONE;
            syncReq.Settings[0].Value = new byte[] { 0x1 };
        
            syncReq.Settings[1] = new UserSetting();
            syncReq.Settings[1].Source = XOn.XSOURCE_DEFAULT;
            syncReq.Settings[1].UserId = userID1;
            syncReq.Settings[1].SettingId = CONTROLLER_INVERSION;
            syncReq.Settings[1].Value = new byte[] { 0x2 };
        
            syncReq.Settings[2] = new UserSetting();
            syncReq.Settings[2].Source = XOn.XSOURCE_DEFAULT;
            syncReq.Settings[2].UserId = userID1;
            syncReq.Settings[2].SettingId = XPROFILE_GAMER_STOCK_TILE_URL;
            syncReq.Settings[2].Value = Encoding.ASCII.GetBytes("e:\\image");
            
            Console.WriteLine("write settings...");      

            LivecacheDependency invalidates = new LivecacheDependency();
            invalidates.Puid = userID1;
            
            //LivecacheRequest lcReq = new LivecacheRequest(userID1, 
            //LcserviceId.SyncSettings, syncReq, null, invalidates);
            
            LivecacheRequest lcReq = new LivecacheRequest(
                userID1,
                LivecacheClientType.Xboxcom,
                LcserviceId.SyncSettings,
                syncReq,
                TITLE_ID,
                null,  // IAccountAuthDataProvider
                null,  // dependency
                invalidates);  // invalidates

            lcReq.SendAsync();
            
            //----------------------------------------------------------

            for (int index = 0; index < 10; index++)
            {
                Console.WriteLine("... and reading them back..");      
  
                ReadSettingsRequest readReq = new ReadSettingsRequest();
                readReq.UserId = userID1;
                readReq.TitleId = TITLE_ID;
                readReq.ForUserIds = new ulong[] { userID1 };
                readReq.SettingIds = new uint[] { XPROFILE_GAMER_ZONE, CONTROLLER_INVERSION, XPROFILE_GAMER_STOCK_TILE_URL };

//                 LivecacheDependency dependencies = new LivecacheDependency(new ulong[1]);
//                 dependencies.OnUsers[0] = userID1;
                LivecacheDependency dependencies = null;
                
                LivecacheRequest lcReq1 = new LivecacheRequest(userID1, LcserviceId.ReadSettings, readReq.GetBytes(), dependencies, null, readReq);
                LivecacheRequest lcReq2 = new LivecacheRequest(userID1, LcserviceId.ReadSettings, readReq.GetBytes(), dependencies, null, readReq);
                readReq.SettingIds[1] = 0xFFFF; // test negative responses
                LivecacheRequest lcReq3 = new LivecacheRequest(userID1, LcserviceId.ReadSettings, readReq, dependencies, null);

                lcReq1.SendAsync();
                lcReq2.SendAsync();
                lcReq3.Send();

                lcReq1.AsyncWaitHandle.WaitOne(3000, true);
                Assert.IsTrue(lcReq1.IsCompleted);
                Assert.IsTrue(lcReq1.AsyncException == null);

                lcReq2.AsyncWaitHandle.WaitOne(3000, true);
                Assert.IsTrue(lcReq2.IsCompleted);
                Assert.IsTrue(lcReq2.AsyncException == null);

                if (lcReq2.ResponseData.Length > 0)
                {
                    ReadSettingsResponse readResp = new ReadSettingsResponse();
                    readResp.SetBytes(lcReq2.ResponseData);
        
                    Assert.AreEqual(readResp.SettingsLen, 3);
                    Assert.AreEqual(readResp.Settings[0].SettingId, XPROFILE_GAMER_ZONE);
                    Assert.AreEqual(readResp.Settings[1].SettingId, CONTROLLER_INVERSION);
                    Assert.AreEqual(readResp.Settings[2].SettingId, XPROFILE_GAMER_STOCK_TILE_URL);

                    if (index>5)
                    {
                        Assert.AreEqual(readResp.Settings[0].Source, XOn.XSOURCE_DEFAULT);
                        Assert.AreEqual(readResp.Settings[1].Source, XOn.XSOURCE_DEFAULT);
                        Assert.AreEqual(readResp.Settings[2].Source, XOn.XSOURCE_DEFAULT);
                        Assert.AreEqual(readResp.Settings[0].Value, syncReq.Settings[0].Value );
                        Assert.AreEqual(readResp.Settings[1].Value, syncReq.Settings[1].Value );
                        Assert.AreEqual(readResp.Settings[2].Value, syncReq.Settings[2].Value );

                        if (index==8)
                        {
                            Console.WriteLine("waiting expire...");
                            TimeSpan t = lcReq2.ResponseExpiry - DateTime.Now;
                            System.Threading.Thread.Sleep((int)t.TotalMilliseconds + 3000);
                        }
                    }
                    
                    Console.WriteLine("data successfully retrieved from the server.");
                    Console.WriteLine("expires on {0}", lcReq2.ResponseExpiry);
                }
                else
                {
                    Console.WriteLine("No data at the server for this request.");
                }

                if (index==5)
                {
                    lcReq.AsyncWaitHandle.WaitOne(2000, true);

                    Assert.IsTrue(lcReq.IsCompleted);
                    Assert.IsTrue(lcReq.AsyncException == null);
                    
                    Console.WriteLine("async request finished.");
                }
            }

            SyncSettingsResponse syncResp = new SyncSettingsResponse();    
            syncResp.SetBytes(lcReq.ResponseData);
        }

#endif

        [TestCase]
        public void ClientType_XUACS_ReserveName()
        {
            ulong userID1   = 0x0009FFFF00000000 + (ulong)(new Random()).Next();

            //
            // construct the request object for target API. We are testing the client 
            // type, so the api chosen is arbitrary.
            //
            ReserveNameRequest req = new ReserveNameRequest();
            req.machinePuid = 0;
            req.countryId = 101;
            req.maxSuggestedNames = 1;
            req.gamertag = "lctestct1";
            req.gamertagLength = (ushort)req.gamertag.Length;  // add a number each time

            //
            // calling front door through livecache
            //
//             LivecacheDependency depends = LivecacheDependencies.UserAccount(userID1);
//             LivecacheDependency invalidates = LivecacheDependencies.UserAccount(userID1);

            MyContextItemProvider cip = new MyContextItemProvider();
            LivecacheRequest lcReq;
            uint hr;
            LivecacheClientType ct;

            // this will likely fail b/c this user doesn't exist. the important thing, for 
            // this highly hacky dvt, is to verify the front door got the correct client 
            // type. debug the front door or hack it up to log the client type like i did 
            // to accomplish this.
        
            ct = LivecacheClientType.Xboxcom;
            req.gamertag = "lctestct1";
            lcReq = new LivecacheRequest(
                0,
                ct,
                LcserviceId.ReserveName,
                req,
                TITLE_ID,
                null,          // IAccountAuthDataProvider
                null,       // dependency
                null);  // invalidates
            hr = lcReq.Send(cip);
            Global.RO.Debug("ClientType: {0}, hr = 0x{1}", ct, hr);

            ct = LivecacheClientType.Zune;
            req.gamertag = "lctestct2";
            lcReq = new LivecacheRequest(
                0,
                ct,
                LcserviceId.ReserveName,
                req,
                TITLE_ID,
                null,          // IAccountAuthDataProvider
                null,       // dependency
                null);  // invalidates
            hr = lcReq.Send(cip);
            Global.RO.Debug("ClientType: {0}, hr = 0x{1}", ct, hr);

            ct = LivecacheClientType.XNA;
            req.gamertag = "lctestct3";
            lcReq = new LivecacheRequest(
                0,
                ct,
                LcserviceId.ReserveName,
                req,
                TITLE_ID,
                null,          // IAccountAuthDataProvider
                null,       // dependency
                null);  // invalidates
            hr = lcReq.Send(cip);
            Global.RO.Debug("ClientType: {0}, hr = 0x{1}", ct, hr);

            ct = LivecacheClientType.WGX;
            req.gamertag = "lctestct4";
            lcReq = new LivecacheRequest(
                0,
                ct,
                LcserviceId.ReserveName,
                req,
                TITLE_ID,
                null,          // IAccountAuthDataProvider
                null,       // dependency
                null);  // invalidates
            hr = lcReq.Send(cip);
            Global.RO.Debug("ClientType: {0}, hr = 0x{1}", ct, hr);

        }
    

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\dll\perfcounters.cs ===
//
// PerfCounters.cs
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Threading;
using System.Diagnostics;
using System.ComponentModel;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.xboxcom;

namespace xonline.server.livecache.dll 
{
    [XomPerformanceCounterCategoryAttr( "Livecache FD", "Xbox Livecache Server: Overall perf counters" )]
    public class LivecachePerfCounters : XomPerformanceCounterCategory
    {
        // Requests.
        [XomPerformanceCounterAttr(
             "Requests per second", 
             "Number of requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Requests total", 
             "Total requests recorded in the current AppDomain", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
             "Requests failures per second", 
             "Number of failed requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Requests failures total", 
             "Total failed requests recorded in the current AppDomain", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailedRequestsTotal;

        // Forward requests.
        [XomPerformanceCounterAttr(
             "Forward requests per second", 
             "Number of forward requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ForwardRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Forward requests total", 
             "Total forward requests recorded in the current AppDomain", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ForwardRequestsTotal;

        [XomPerformanceCounterAttr(
             "Forward request failures per second", 
             "Number of failed forward requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedForwardRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Forward request failures total", 
             "Total failed forward requests recorded in the current AppDomain", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailedForwardRequestsTotal;

        //Cache 
        [XomPerformanceCounterAttr(
             "Cached results total", 
             "Total number of SPI responses currently cached", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CachedResultsTotal;

        [XomPerformanceCounterAttr(
             "Expired cache items flushed per second", 
             "Number of naturally expiring cache items flushed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ExpiredCacheItemsPerSecond;

        [XomPerformanceCounterAttr(
             "Expired cache items total", 
             "Total cached items expiring naturally in the current AppDomain", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ExpiredCacheItemsTotal;

        [XomPerformanceCounterAttr(
             "Underused cache items flushed per second", 
             "Number of underused cache items flushed per second due to memory pressure", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter UnderusedCacheItemsPerSecond;

        [XomPerformanceCounterAttr(
             "Underused cache items total", 
             "Total cached items removed due to memory pressure in the current AppDomain", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter UnderusedCacheItemsTotal;
        
        [XomPerformanceCounterAttr(
             "Cache hit per second", 
             "Number of cache hit per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CacheHitPerSecond;

        [XomPerformanceCounterAttr(
             "Cache hit total", 
             "Total cache hit in the current AppDomain", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheHitTotal;
        
        [XomPerformanceCounterAttr(
             "Cache miss per second", 
             "Number of cache miss per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CacheMissPerSecond;

        [XomPerformanceCounterAttr(
             "Cache miss total", 
             "Total cache miss in the current AppDomain", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheMissTotal;


        //Throttling
        [XomPerformanceCounterAttr(
             "Requests rejected based on max_reqs_per_sec per second", 
             "Number of requests rejected because the max_reqs_per_sec was reached per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RejectedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Requests rejected based on max_reqs_per_sec total", 
             "Total requests rejected because the max_reqs_per_sec was reached in the current AppDomain", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RejectedRequestsTotal;

        [XomPerformanceCounterAttr(
             "Failed Xbanc requests per second",
             "Number of requests allowed because of xbanc failure in request per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedXbancRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Failed Xbanc requests total",
             "Total requests allowed because of xbanc failure reached in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailedXbancRequestsTotal;
       

        public static LivecachePerfCounters Counters = new LivecachePerfCounters();

        public virtual LivecachePerfCounters this[string instanceName]
        {
            get
            {
                return (LivecachePerfCounters)GetInstance(instanceName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\dll\livecache.cs ===
//
// Livecache.cs
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Web;
using System.Net;
using System.Web.Caching;
using System.Threading;
using System.IO;
using System.Globalization;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.xboxcom;
using xonline.common.sql.sqlclient;
using xonline.common.installer;

[assembly: XomAreaDefinition(XomAreaName.livecachelog)]

[assembly: XomIisInstallerAttribute( Interface.livecache )]
[assembly: ConfigAttribute(xonline.common.config.Component.livecache)]

namespace xonline.server.livecache.dll 
{
    //-------------------------------------------------------
    //
    // Livecache class
    //

    public class Livecache : IHttpHandler
    {    
        /// <summary>
        /// IsReusable:
        /// </summary>
        public bool IsReusable
        {
            get { return true; }
        }

        private static UsageMeter _GuwiUsageMeter = new UsageMeter(2000);
        private const string BEHAVIOR_INJECTIONS_TO_FORWARD_HEADER ="BEHAVIOR_INJECTION_FORWARD";
        private const string BEHAVIOR_INJECTIONS_HEADER ="BEHAVIOR_INJECTIONS";
        

        internal static XBanc   XBancProxy = new XBanc();
        internal static byte[]  XBancPrefix = Encoding.ASCII.GetBytes("Livecache");
        internal const int      ThrottleDecay = 1;


        private LivecachePerfCounters _instanceCounters;
        private LivecachePerfCounters _totalCounters = LivecachePerfCounters.Counters;

        /// <summary>
        /// ProcessRequest:
        /// </summary>
        /// <param name="ctx">The Http context for this request.</param>
        public void ProcessRequest (
            HttpContext ctx
            )
        {
            int lcserviceId = -1;
            ulong userId = 0;
            byte[] lcResponse = null;
            HResult hr = HResult.E_FAIL;
            string lcserviceName = "?";
            _instanceCounters = LivecachePerfCounters.Counters["unknown"];

            HttpRequest request = ctx.Request;
            DateTime requestStartTime = DateTime.Now;
            string cacheHit = "NA";
            string action = null;
            string hourlyQuotaUsage = null;
            string clientType = null;
            string behaviorInjection = null;
            string serializedAAInfo = null;
            string webHeader = null;

            try 
            {
                string authData = request.Headers[XHttpHdr.HTTPAUTHDATA];
                string schemaVersion = request.Headers["X-Schema-Ver"];
                string dependency = request.Headers[LivecacheConst.LcDependHeader];
                string invalidation = request.Headers[LivecacheConst.LcUpdateHeader];
                byte[] postData = request.BinaryRead(request.ContentLength);
                
                action = request.Headers[LivecacheConst.LcserviceIdHeader];
                hourlyQuotaUsage = request.Headers[LivecacheConst.LcHourlyQuotaHeader];
                clientType = request.Headers[XHttpHdr.XPLT_I];
                behaviorInjection = request.Headers[BEHAVIOR_INJECTIONS_TO_FORWARD_HEADER]; // would prefer not to hardcode this value, but it looks like the const string in behaviorinjection.cs is private anyway.
                serializedAAInfo = request.Headers[XHttpHdr.AUTHZ];
                webHeader = request.Headers[XHttpHdr.HEADERCOLLECTION];

                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_LOW, "ProcessRequest: lcservice = " + action );

                //
                // simple validation
                //
                if (authData==null || authData.Length==0)
                {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.LIVECACHE_HACK_0, "auth data required.");
                }

                if (postData==null || postData.Length==0)
                {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.LIVECACHE_HACK_1, "post data required.");
                }

                if (String.IsNullOrEmpty(schemaVersion))
                {
                    schemaVersion = WireInfoAttribute.VersionToString(WireData.CurrentSchemaVersion);
                }

                CallSource.Check(VirtualInterface.livecache);

                uint titleId = XOn.WEB_TITLE_ID;
                SGInfo sgInfo = SGInfo.Current;
                if(sgInfo.TitleId != 0)
                {
                    titleId = sgInfo.TitleId;
                }
                //
                // get livecache service id
                //
                try
                {
                    lcserviceId = Int32.Parse(action);
                }
                catch(Exception e)
                {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.LIVECACHE_HACK_2, "bad request format.", e);
                }

                if (!String.IsNullOrEmpty(hourlyQuotaUsage))
                {
                    ulong quotaUserPuid = ulong.Parse(hourlyQuotaUsage, NumberStyles.AllowHexSpecifier);
                    uint limit = Livecache.MaxRequestRatePerUser;
                    if (limit!=0 && _GuwiUsageMeter.Increment(quotaUserPuid) > limit)
                    {
                        Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_LOW, "Rejecting request - user max'd out his hourly quota: " + quotaUserPuid.ToString("x") );
                        hr = HResult.XONLINE_E_LIVECACHE_USER_OVERHEAT;
                        XRLUtil.SetXRLResponse(ctx.Response, (XOService)0, titleId, hr, (byte[])null);
                        return;
                    }
                }

                //
                // see if we know about the desired service.
                // failure indicate we have errors in the client code. or we introduced a new
                // service which hasn't been registered with livecache service table.
                //
                ServiceNode sn = ServicesSettings.LookupService(lcserviceId);
                if ( sn == null )
                {
                    if (ProcessNativeCommands(lcserviceId, invalidation, postData, ref lcserviceName, out hr, out lcResponse))
                    {
                        _instanceCounters = LivecachePerfCounters.Counters[lcserviceName];
                        // sending zero byte array fails on .NET 2.0
                        if (lcResponse!=null && lcResponse.Length==0)
                        {
                            lcResponse = null;
                        }
                        XRLUtil.SetXRLResponse(ctx.Response, (XOService)0, titleId, hr, lcResponse);
                        return; // do logging too
                    }

                    string msg = string.Format("lcservice#{0} not found", lcserviceId);
                    throw new XRLException(HResult.XONLINE_E_INVALID_SERVICE_ID, XEvent.Id.LIVECACHE_HACK_3, msg);
                }

                lcserviceName = sn.Name;
                _instanceCounters = LivecachePerfCounters.Counters[sn.Name];

                //
                // extract user puid and title id from authData. should have only one user
                //
                userId = sgInfo.LogonUsers[0].qwUserID;
                
                if (userId == 0 && !sn.AllowAnonymousAccess)
                {
                    string msg = string.Format("Anonymous request not allowed for lcservice#{0}", lcserviceId);
                    throw new XRLException(HResult.XONLINE_E_USER_NOT_LOGGED_ON, XEvent.Id.LIVECACHE_HACK_4, msg);
                }

                //
                // build cache key and search it in cache
                //
                LivecacheKey key = new ServerLivecacheKey(lcserviceId, userId, postData, schemaVersion, clientType);
                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_LOW, "key: " + key.Value );

                LivecacheEntry cacheEntry = CacheLookup( key );
                
                if (cacheEntry != null)
                {
                    cacheHit = "hit";
                    _totalCounters.CacheHitPerSecond.Increment();
                    _instanceCounters.CacheHitPerSecond.Increment();
                    _totalCounters.CacheHitTotal.Increment();
                    _instanceCounters.CacheHitTotal.Increment();

                    Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_LOW, string.Format("found in cache. hr = {0}", cacheEntry.HResult));
                }
                else
                {
                    cacheHit = "miss";
                    _totalCounters.CacheMissPerSecond.Increment();
                    _instanceCounters.CacheMissPerSecond.Increment();
                    _totalCounters.CacheMissTotal.Increment();
                    _instanceCounters.CacheMissTotal.Increment();

                    //
                    // forward request to live service and cache the result
                    //
                    
                    cacheEntry = new LivecacheEntry();

                    try
                    {
                        Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_LOW, "forwarding" );

                        cacheEntry.Response = ForwardRequest(sn, authData, postData, schemaVersion, request.ContentType, clientType, behaviorInjection, serializedAAInfo,webHeader, out cacheEntry.HResult);

                        if (cacheEntry.HResult != HResult.S_OK)
                        {
                            uint retryDelay = Math.Min(ErrorResultCacheLife, sn.Duration);
                            cacheEntry.Expiry = DateTime.Now.AddSeconds(retryDelay);
                        }
                        else
                        {
                            cacheEntry.Expiry = DateTime.Now.AddSeconds(sn.Duration);
                        }
                    }
                    catch (XRLException e)
                    {
                        Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, e.Message + ", hr = " + e.HResult.ToString() );
                        
                        //
                        // In most cases there's nothing we can do here at livecache.
                        // There should be an event logged by the original live service.
                        // We just forward the error code. Error condidtions are cached
                        // for shorter period. Consider: Should we add "duration/error"
                        // for each ServiceNode?
                        //
                        uint retryDelay = Math.Min(ErrorResultCacheLife, sn.Duration);
                        cacheEntry.HResult = e.HResult;
                        cacheEntry.Expiry = DateTime.Now.AddSeconds(retryDelay);
                    }
                    catch (Exception e)
                    {
                        Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_HIGH, "forward request failed: " + e.Message);

                        _totalCounters.FailedForwardRequestsPerSecond.Increment();
                        _instanceCounters.FailedForwardRequestsPerSecond.Increment();
                        _totalCounters.FailedForwardRequestsTotal.Increment();
                        _instanceCounters.FailedForwardRequestsTotal.Increment();

                        //
                        // no one else would log this, so do it here
                        //
                        EventBuilder.LogEvent(XEvent.Id.LIVECACHE_COMM_0, "Livecache: failed forwarding request", e);

                        //
                        // hopefully the server will recover, retry after a short delay
                        //
                        cacheEntry.HResult = HResult.XONLINE_E_LIVECACHE_FORWARD_FAILED;
                        cacheEntry.Expiry = DateTime.Now.AddSeconds(ForwardFailureRetryInterval);
                    }

                    //
                    // response will not be cached if the request invalidates anything
                    //
                    if (invalidation==null)
                    {
                        CacheInsert( key, 
                            cacheEntry, 
                            requestStartTime,
                            dependency,
                            GetDefaultRemovedCallback());
                    }
                    else
                    {
                        CacheInvalidate(invalidation);
                    }
                }

                lcResponse = cacheEntry.Response;
                hr = cacheEntry.HResult;

                if ( HResult.Failed(cacheEntry.HResult) )
                {
                    XRLUtil.SetXRLResponse(ctx.Response, (XOService)0, titleId, (uint)cacheEntry.HResult, lcResponse);
                }
                else
                {
                    // optimized common path instead of calling SetXRLResponse
                    if (hr!=HResult.S_OK)
                    {
                        ctx.Response.AppendHeader("X-Err", ((uint) hr).ToString("x08"));
                    }
                    ctx.Response.StatusCode = 200;
                    ctx.Response.Cache.SetExpires(cacheEntry.Expiry);
                    if (lcResponse!=null && lcResponse.Length>0)
                    {
                        ctx.Response.BinaryWrite( lcResponse );
                    }
                }
            }
            finally
            {
                if (HResult.Failed(hr))
                {
                    _totalCounters.FailedRequestsPerSecond.Increment();
                    _instanceCounters.FailedRequestsPerSecond.Increment();
                    _totalCounters.FailedRequestsTotal.Increment();
                    _instanceCounters.FailedRequestsTotal.Increment();
                }

                _totalCounters.RequestsPerSecond.Increment();
                _instanceCounters.RequestsPerSecond.Increment();
                _totalCounters.RequestsTotal.Increment();
                _instanceCounters.RequestsTotal.Increment();

                StringBuilder sb = new StringBuilder();
                sb.Append("LCR|");
                sb.Append(hr.ToString());
                sb.Append('|');
                sb.Append(lcserviceName);
                sb.Append('|');
                sb.Append(userId.ToString("x16"));
                sb.Append('|');
                sb.Append((DateTime.Now-requestStartTime).TotalSeconds.ToString("f2"));
                sb.Append('|');
                sb.Append(cacheHit);
                sb.Append('|');
                sb.Append((request != null)? request.ContentLength : 0);
                sb.Append('|');
                sb.Append((lcResponse != null)? lcResponse.Length: 0);
                sb.Append('|');
                sb.Append(action);
                sb.Append('|');
                sb.Append(hourlyQuotaUsage);
                sb.Append('|');
                sb.Append(clientType);
                Xom.Log(XomAreaName.livecachelog, sb.ToString());
            }
        }


        private bool ProcessNativeCommands(int lcserviceId, string invalidation, byte[] postData, ref string lcserviceName, out HResult hr, out byte[] lcResponse)
        {
            hr = HResult.S_OK;
            lcResponse = null;

            if (lcserviceId == (int)LivecacheConst.SN_CacheInvalidate)
            {
                lcserviceName = "Invalidate";
                CacheInvalidate(invalidation);
                return true;
            }
            else if (lcserviceId == (int)LivecacheConst.SN_LoadData)
            {
                lcserviceName = "LoadData";
                LivecacheLoadDataRequest req = new LivecacheLoadDataRequest();
                req.SetBytes(postData);

                lcResponse = HttpContext.Current.Cache.Get(req.Key) as byte[];
                hr = (lcResponse==null)? HResult.XONLINE_E_LIVECACHE_INEXIST_KEY: HResult.S_OK;

                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_LOW, "LoadData:" + req.Key);
                return true;
            }
            else if (lcserviceId == (int)LivecacheConst.SN_SaveData)
            {
                lcserviceName = "SaveData";
                LivecacheSaveDataRequest req = new LivecacheSaveDataRequest();
                req.SetBytes(postData);

                HttpContext.Current.Cache.Insert(
                    req.Key, 
                    req.Value, 
                    null, 
                    Cache.NoAbsoluteExpiration,
                    TimeSpan.FromSeconds(req.SecondsToCache),
                    CacheItemPriority.NotRemovable,
                    null );

                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_LOW, "SaveData:" + req.Key);
                return true;
            }
            else if (lcserviceId == (int)LivecacheConst.SN_ClearData)
            {
                lcserviceName = "ClearData";
                LivecacheClearDataRequest req = new LivecacheClearDataRequest();
                req.SetBytes(postData);

                HttpContext.Current.Cache.Remove(req.Key);

                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_LOW, "ClearData:" + req.Key);
                return true;
            }

            return false;
        }

        private bool IsPastThreshold(ServiceNode sn)
        {
            ulong result = 0;

            // Special case, if no calls allowed, then just return.
            if (sn.MaxRequestThreshold == 0)
            {
                return true;
            }

            HResult hr = HResult.E_FAIL;
            try
            {
                hr = XBancProxy.Increment(sn.XBancKey, 1, ThrottleDecay, 0, 0, out result);
            }
            catch (Exception e)
            {
                hr = XRLException.DeepToHResult(e, hr);
                string msg = "Xbanc threw and exception during execution, failing open. err="+e.ToString();
                Xom.Trace(XomAreaName.livecachetrace, LogLevel.L_ERROR, msg);

            }

            if (HResult.Failed(hr))
            {
                // No reason to throw on fast fail, as the events are already being reported.
                if (hr != HResult.XONLINE_E_RESOURCE_UNAVAILABLE)
                {
                    // throw new Exception("XBanc is unavailable, hr="+hr.ToString());
                    string msg = "IsPastThreshold: xbanc returned failure, allowing call: api=" + sn.Name + ", err="+hr.ToString();
                    Xom.NtEvent(XEvent.Id.LIVECACHE_CODE_2, msg);
                }
                _totalCounters.FailedXbancRequestsPerSecond.Increment();
                _instanceCounters.FailedXbancRequestsPerSecond.Increment();
                _totalCounters.FailedXbancRequestsTotal.Increment();
                _instanceCounters.FailedXbancRequestsTotal.Increment();
            }

            bool res = result > sn.MaxRequestThreshold;
            if (res)
            {
                sn.BlockRequests = true;
            }

            return res;
        }

        private byte[] ForwardRequest(ServiceNode sn, string authData, byte[] postData, string schemaVersion, string contentType, string clientType, string behaviorInjection, string serializedAAInfo,string webHeader, out HResult hr)
        {
            //
            // request throttling
            //
            if (!ServiceEnabled)
            {
                _totalCounters.RejectedRequestsPerSecond.Increment();
                _instanceCounters.RejectedRequestsPerSecond.Increment();
                _totalCounters.RejectedRequestsTotal.Increment();
                _instanceCounters.RejectedRequestsTotal.Increment();
                
                string msg = "rejected request because livecache is set to offline";
                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, msg);
                
                throw new XRLException(HResult.XONLINE_E_LIVECACHE_OFFLINE, XEvent.Id.LIVECACHE_CODE_1, msg);
            }
            else if (sn.BlockRequests || IsPastThreshold(sn))
            {
                _totalCounters.RejectedRequestsPerSecond.Increment();
                _instanceCounters.RejectedRequestsPerSecond.Increment();
                _totalCounters.RejectedRequestsTotal.Increment();
                _instanceCounters.RejectedRequestsTotal.Increment();
                
                string msg = string.Format("ForwardRequest: lcservice#{0} reached TPS limit", sn.Id);
                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, msg);
                
                throw new XRLException(HResult.XONLINE_E_TASK_THROTTLED, XEvent.Id.LIVECACHE_CODE_2, msg);
            }

            _totalCounters.ForwardRequestsPerSecond.Increment();
            _instanceCounters.ForwardRequestsPerSecond.Increment();
            _totalCounters.ForwardRequestsTotal.Increment();
            _instanceCounters.ForwardRequestsTotal.Increment();

            //
            // Prepare the request for the front door
            //
            XrlRequest fdReq = new XrlRequest();

            fdReq.TargetVirtualInterface = sn.VirtInterface;
            fdReq.Path = sn.Xrl;
            fdReq.AuthData = authData;
            fdReq.PlatformType = sn.GetPlatformType();
            fdReq.PostData = postData;
            fdReq.SchemaVersion = WireInfoAttribute.StringToVersion(schemaVersion);
            fdReq.ContentTypeOverride = contentType;

            if (!String.IsNullOrEmpty(clientType))
            {
                fdReq.RequestHeaders.Add(XHttpHdr.XPLT_I, clientType);
            }
            if(!String.IsNullOrEmpty(behaviorInjection))
            {
                fdReq.RequestHeaders.Add(BEHAVIOR_INJECTIONS_HEADER, behaviorInjection);
            }
            if(!String.IsNullOrEmpty(serializedAAInfo))
            {
                fdReq.RequestHeaders.Add(XHttpHdr.AUTHZ, serializedAAInfo);
            }

            //
            //get the object back from string and add the header to the FD request
            //
            if (!string.IsNullOrEmpty(webHeader))
            {
                LiveCacheWebHeaderCollection headerCollection = new LiveCacheWebHeaderCollection();

                headerCollection.LoadFromString(webHeader);

                int liveCacheMaxHeaderCollectionCount = Config.GetIntSetting(Setting.livecache_maxHeaderCollectionCount);

                if (headerCollection.NameValuePairs.Count > liveCacheMaxHeaderCollectionCount)
                {
                    throw new XRLException(HResult.XONLINE_E_LIVECACHE_MAX_HEADER_COLLECTION_LIMIT, XEvent.Id.LIVECACHE_CODE_3, "Header collection count exceed maximum limit defined");
                }

                foreach (WebServiceNameValuePair item in headerCollection.NameValuePairs)
                {
                    //add header if not present.Do not touch anything which is already present
                    if (!string.IsNullOrEmpty(item.value) && string.IsNullOrEmpty(fdReq.RequestHeaders.Get(item.name)))
                    {
                        fdReq.RequestHeaders.Add(item.name, item.value);
                    }
                }
            }
            //
            // Send to the front door
            //
            hr = fdReq.Send();

            if ((fdReq.ResponseData == null) || (fdReq.ResponseData.Length == 0))
            {
                // this is not an error condition
            }

            return fdReq.ResponseData;
        }
        
        // 
        //  Mgmt Commands
        //

        public static void OnControlRequest(
            object sender, 
            ControlRequestEventArgs args
            )
        {
            switch(args.Command)
            {
                case "configflush":
                    ServicesSettings.Flush();
                    XomControlConnection.SendMessage(
                        "Livecache config flushed.  It will be reloaded on the next forward request.", args.RequestId);
                    args.Handled = true;
                    break;

                case "counterflush":
                    _GuwiUsageMeter.Recycle(DateTime.Now.GetHashCode());
                    XomControlConnection.SendMessage(
                        "User throttling counters flushed.", args.RequestId);
                    args.Handled = true;
                    break;

                case "svclist":
                    ServicesSettings.XmgmtListServices(args);
                    args.Handled = true;
                    break;

                case "help":
                    XomControlConnection.SendMessage("Livecache:\r\n"
                        +" svcList -- List service parameters loaded from t_livecache_apis.\r\n"
                        +" ConfigFlush -- Flushes t_livecache_apis parameters.\r\n"
                        +" CounterFlush -- Flushes user throttling counters.\r\n",
                        args.RequestId);
                    args.Handled = true;
                    break;
            }
        }        

        //
        // Cache
        //

        private void CacheInsert( 
            LivecacheKey key, 
            LivecacheEntry newEntry,
            DateTime requestStartTime,
            string dependency,
            CacheItemRemovedCallback onRemove
            )
        {
            //
            // don't insert items if it'll expire too soon (ServiceNode.Duration=0 or 1)
            //
            if (newEntry.Expiry < DateTime.Now.AddSeconds(2))
            {
                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, "not cached");
                return;
            }

            //
            // get the dependency cache items in place
            //
            CacheDependency cacheDepend = null;
            if (dependency!=null)
            {
                string[] values = dependency.Split(',');
                for (int i=0; i<values.Length; i++)
                {
                    if (HttpContext.Current.Cache.Get(values[i])==null)
                    {
                        HttpContext.Current.Cache.Insert(
                            values[i], 
                            values[i],
                            null,
                            Cache.NoAbsoluteExpiration,
                            TimeSpan.FromSeconds(ServicesSettings.DependencyCacheItemLife),
                            CacheItemPriority.High, 
                            null );
                    }
                }

                cacheDepend = new CacheDependency(null, values);
            }
            
            HttpContext.Current.Cache.Insert(
                key.Value, 
                newEntry, 
                cacheDepend, 
                newEntry.Expiry,
                Cache.NoSlidingExpiration,
                CacheItemPriority.Normal,
                onRemove );

            _totalCounters.CachedResultsTotal.Increment();
            _instanceCounters.CachedResultsTotal.Increment();

            if (!InvalidationTracker.IsEntryValid(requestStartTime, dependency))
            {
                // An invalidation took place against the cache for a related request after
                // this one was sent.  Undo that insert because it may be stale.
                //

                HttpContext.Current.Cache.Remove(key.Value);
                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, "not cached due to invalidation race hazard");
            }
            else
            {
                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, string.Format("cache insert: hr = {0}, data={1}bytes, expire={2:h:mm:ss}, key={3}", newEntry.HResult, ((newEntry.Response==null)? 0: newEntry.Response.Length), newEntry.Expiry, key.Value));
                if (dependency!=null)
                {
                    Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, string.Format("dependency={0}", dependency));
                }
            }
        }
        
        private void CacheInvalidate(
            string updates
            )
        {
            if (updates!=null)
            {
                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, string.Format("cache invalidate: updates={0}", updates));

                // stop caching if a request was started before we invalidate and
                // hasn't made it to CacheInsert yet
                InvalidationTracker.UpdateInvalidationTime(DateTime.Now, updates);

                string[] values = updates.Split(',');
                for (int i=0; i<values.Length; i++)
                {
                    HttpContext.Current.Cache.Remove(values[i]);
                }
            }
        }
        
        private LivecacheEntry CacheLookup( 
            LivecacheKey key 
            )
        {
            LivecacheEntry entry = HttpContext.Current.Cache.Get(key.Value) as LivecacheEntry;
            return entry ;
        }

        private static void RemovedCallback(
            string key,
            object value,
            CacheItemRemovedReason reason
            )
        {
            string serviceName = "unknown";
            try
            {
                int lcserviceId = LivecacheKey.QueryServiceId(key);
                ServiceNode sn = ServicesSettings.LookupService(lcserviceId);
                serviceName = sn.Name;
                LivecachePerfCounters.Counters.CachedResultsTotal.Decrement();
                LivecachePerfCounters.Counters[serviceName].CachedResultsTotal.Decrement();
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.LIVECACHE_CODE_0, e, "RemoveCallback: unrecognized key: " + key);
            }
            
            if (reason == CacheItemRemovedReason.Underused)
            {
                LivecachePerfCounters.Counters.UnderusedCacheItemsPerSecond.Increment();
                LivecachePerfCounters.Counters[serviceName].UnderusedCacheItemsPerSecond.Increment();
                LivecachePerfCounters.Counters.UnderusedCacheItemsTotal.Increment();
                LivecachePerfCounters.Counters[serviceName].UnderusedCacheItemsTotal.Increment();
            }
            else if (reason == CacheItemRemovedReason.Expired)
            {
                LivecachePerfCounters.Counters.ExpiredCacheItemsPerSecond.Increment();
                LivecachePerfCounters.Counters[serviceName].ExpiredCacheItemsPerSecond.Increment();
                LivecachePerfCounters.Counters.ExpiredCacheItemsTotal.Increment();
                LivecachePerfCounters.Counters[serviceName].ExpiredCacheItemsTotal.Increment();
            }
            else if (reason == CacheItemRemovedReason.DependencyChanged)
            {
                // Add a perf counter?
            }
            else if (reason == CacheItemRemovedReason.Removed)
            {
                // Add a perf counter?
            }
            else
            {
                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, "Item removed from Livecache due to " + reason.ToString());
            }

            Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, DateTime.Now + " " + reason.ToString() + " key: " + key );
        }

        static public CacheItemRemovedCallback GetDefaultRemovedCallback()
        {
            return _onRemove;
        }

        static private CacheItemRemovedCallback _onRemove = new CacheItemRemovedCallback(RemovedCallback);

        const int CacheInvalidateMaxWaitTime = 9000;  // wait no more than 9 seconds for peers to reply

        private static uint ForwardFailureRetryInterval // if forward failed due to generic network failure
        {
            get
            {
                return Config.GetUIntSetting(Setting.livecache_forwardRetryInterval);
            }
        }

        private static uint ErrorResultCacheLife // if error was returned from target live service
        {
            get
            {
                return Config.GetUIntSetting(Setting.livecache_errorResultTTL);
            }
        }
        
        private static bool ServiceEnabled
        {
            get
            {
                return Config.GetBoolSetting(Setting.livecache_serviceEnabled);
            }
        }

        private static uint MaxRequestRatePerUser
        {
            get
            {
                return Config.GetUIntSetting(Setting.livecache_MaxRequestRatePerUser);
            }
        }
    } 

    //-------------------------------------------------------
    //
    // UsageMeter class: thread-safe counter array that resets periodically
    //

    class UsageMeter
    {
        public UsageMeter(int initialSize)
        {
            _initialSize = initialSize;
        }

        public int Increment(object key)
        {
            lock(this)
            {
                //
                // reset when it's time, or initialize
                //
                if (DateTime.Now > _quotaRefillTime)
                {
                    Recycle(key.GetHashCode());
                }

                Counter cntr = (Counter)_counters[key];

                if (cntr == null)
                {
                    //
                    // add a new counter for the key
                    //
                    cntr = new Counter(0);
                    _counters.Add(key, cntr);
                    Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_LOW, "UsageMeter adding key " + key.ToString());
                }

                return ++cntr.val;
            }
        }

        public void Recycle(int random)
        {
            lock(this)
            {
                _counters = new Hashtable(_initialSize);
                _quotaRefillTime = DateTime.Now.AddMinutes(GetRecycleMinutes() + RandomDriftMinutes(random));
                Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, "UsageMeter reset, next reset at " + _quotaRefillTime.ToString());
            }
        }

        private double GetRecycleMinutes()
        {
            return Config.GetDoubleSetting(Setting.livecache_UserLimitInMinutes);
        }

        private int RandomDriftMinutes(int rn)
        {
            int range = Config.GetIntSetting(Setting.livecache_UserLimitRandMinutes);
            int rand = (rn % range) - (range / 2);
            Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, string.Format("UsageMeter.RandomDriftMinutes({0}) => {1} ", rn, rand));
            return rand;
        }

        private DateTime _quotaRefillTime = DateTime.MinValue;
        private Hashtable _counters = null;
        private int _initialSize;  // the initial number of counter slots

        //
        // avoid boxing
        //
        private class Counter
        {
            public int val;

            public Counter(int v)
            {
                val = v;
            }
        }
    }
    
    //-------------------------------------------------------
    //
    // ServicesSettings class
    //
    
    internal class ServicesSettings
    {
        private static Hashtable _serviceTable = null;
        private static System.Timers.Timer _tickTimer = null; // fires every second to refills CurrentBudget
        private static Object _classLock = new object();
        private static string[] _livecacheServerList = null;
        private static ServerListChangeEventHandler _serviceListEventHandler = null;
        private static SettingChangeEventHandler _settingChangeEventHandler = null;
        private static string _lastModifyTime;

        public static uint DependencyCacheItemLife = 0;

        internal static void RegisterConfigEventHandlers()
        {
            if (_serviceListEventHandler == null)
            {
                _serviceListEventHandler = new ServerListChangeEventHandler(OnServerListChange);
                Config.ServerListChange += _serviceListEventHandler;
            }

            if (_settingChangeEventHandler == null)
            {
                _settingChangeEventHandler = new SettingChangeEventHandler(OnSettingChange);
                Config.SettingChange += _settingChangeEventHandler;
            }
        }
        
        public static string[] LivecacheServerList
        {
            get
            {
                string[] serverList = _livecacheServerList;
                if (serverList==null)
                {
                    serverList = _livecacheServerList = Config.GetServerListByInterface(Interface.livecache);
                    Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, "Livecache: List of livecache servers:" + string.Join(",", LivecacheServerList) );
                }

                return serverList;
            }
        }

        public static ServiceNode LookupService(
            int lcserviceId
            )
        {
            Hashtable svcTbl;

            lock(_classLock)
            {
                if (_serviceTable == null)
                {
                    LoadServicesTable();
                }

                svcTbl = _serviceTable;
            }
 
            return ((ServiceNode)(svcTbl[lcserviceId]));
        }

        private static void OnServerListChange(  object sender, ServerListChangeEventArgs e)
        {
            _livecacheServerList=null;
            Flush();
        }

        public static void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            switch(eventArgs.Setting)
            {
                case Setting.livecache_lastModified:
                    Flush();
                    break;
            }
        }
        
        
        private static void LoadServicesTable()
        {
            Hashtable settings = new Hashtable();
            uint maxDuration = 0;
            
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "p_livecache_get_forward_service_list";
                SqlDataReader reader = cmd.Execute();
                
                while (reader.Read())
                {
                    ServiceNode newService = new ServiceNode();

                    newService.Id = (int)reader["i_lcservice_id"];
                    newService.Xrl = ((string)reader["vc_xrl"]);
                    newService.Name = ((string)reader["vc_name"]);
                    newService.Duration = (uint)(int)reader["i_duration"];
                    newService.MaxReqsPerSec = (uint)(int)reader["i_max_reqs_per_sec"];
                    newService.AllowAnonymousAccess = (bool)reader["b_allow_anonymous_access"];
                    string viName = (string)reader["vc_virtual_interface"];

                    byte[] idBytes = BitConverter.GetBytes(newService.Id);
                    newService.XBancKey = new byte[Livecache.XBancPrefix.Length+idBytes.Length];
                    Livecache.XBancPrefix.CopyTo(newService.XBancKey, 0);
                    idBytes.CopyTo(newService.XBancKey, Livecache.XBancPrefix.Length);

                    // MaxReqsPerSec is the total# of requests for all livecache servers. 
                    // newService.MaxReqsPerSec /= (uint)LivecacheServerList.Length;
                    
                    // Compute the threshold that will be compared to xbanc
                    newService.ComputeThreshold();

                    if (newService.Duration > maxDuration)
                    {
                        maxDuration = newService.Duration;
                    }

                    try
                    {
                        newService.VirtInterface= viName;
                        settings[newService.Id] = newService;
                    }
                    catch (ArgumentException)
                    {
                        //
                        // log an error event but continue load the rest of the table.
                        // if we abort, we'll be called again on next request. before
                        // human intervention, we'll hit this error repeatedly while
                        // failing all requests. having some tolerance to the error
                        // seems the better choice.
                        //

                        const string msgFmt = "Invalid livecache service entry: {0} is not a valid virtual interface name.";
                        string errMsg = string.Format(msgFmt, viName);

                        Debug.Fail(errMsg);
                        Xom.NtEvent(XEvent.Id.LIVECACHE_CONFIG_0, errMsg);
                    }
                }    
            }

            if (settings.Count==0)
            {
                Xom.NtEvent(XEvent.Id.LIVECACHE_CONFIG_1, "no valid entries found in api table");
            }

            _serviceTable = settings;
            DependencyCacheItemLife = maxDuration;

            _tickTimer = new System.Timers.Timer();
            _tickTimer.Interval = 200; // unit in ms
            _tickTimer.AutoReset = true;
            _tickTimer.Elapsed += new System.Timers.ElapsedEventHandler(UpdateThrottledCounters);
            _tickTimer.Start();

            _lastModifyTime = Config.GetSetting(Setting.livecache_lastModified);

            UpdateThrottledCounters(null, null);

            Xom.Trace(XomAreaName.livecachetrace, LogLevel.L_NORMAL, "Livecache: Config loaded: Number of services = " + _serviceTable.Count );
        }

        private static void UpdateThrottledCounters(object o, System.Timers.ElapsedEventArgs e) 
        {
            Hashtable svcTbl;

            lock(_classLock)
            {
                svcTbl = _serviceTable;
            }

            if (svcTbl != null)
            {

                foreach (DictionaryEntry entry in svcTbl)
                {
                    ServiceNode sn = entry.Value as ServiceNode;

                    if (sn.BlockRequests)
                    {
                        uint hr;
                        ulong result = 0;

                        hr = Livecache.XBancProxy.Increment(sn.XBancKey, 0, Livecache.ThrottleDecay, 0, 0, out result);

                        if (HResult.Succeeded(hr))
                        {
                            sn.BlockRequests = result > sn.MaxRequestThreshold;
                        }
                        else
                        {
                            // If XBANC fails the request, at some point we need to fail back open, so
                            // allow only a single XBANC failure to block requests, otherwise, allow
                            // the requests to continue again.
                            if (!sn.XBancFailed)
                            {
                                sn.XBancFailed = true;
                            }
                            else
                            {
                                sn.BlockRequests = false;
                                sn.XBancFailed = false;
                            }
                        }
                    }
                }
            }
        }

        public static void XmgmtListServices(ControlRequestEventArgs args) 
        {
            Hashtable svcTbl;

            lock(_classLock)
            {
                svcTbl = _serviceTable;
            }

            if (svcTbl != null)
            {
                XomControlConnection.SendMessage("ID\tName\tXrl\tVirtInterface\tDuration\tMaxReqsPerSec\tAllowAnonymousAccess\r\n", args.RequestId );
                int count = 0;

                foreach (DictionaryEntry entry in svcTbl)
                {
                    ServiceNode sn = entry.Value as ServiceNode;
                    count++;
                    string line = string.Format("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\r\n",
                        sn.Id,
                        sn.Name,
                        sn.Xrl,
                        sn.VirtInterface,
                        sn.Duration,
                        sn.MaxReqsPerSec,
                        sn.AllowAnonymousAccess);
                    XomControlConnection.SendMessage(line, args.RequestId);
                }

                XomControlConnection.SendMessage( "\r\n" + count + " services defined\r\n", args.RequestId );
            }
        }

        public static void Flush()
        {
            if (_tickTimer!=null)
            {
                _tickTimer.Stop();
                _tickTimer.Close();
            }
            _tickTimer = null;
            _serviceTable = null;

            Xom.Trace(XomAreaName.livecachetrace, LogLevel. L_NORMAL, "Livecache: Config flushed");
        }
    }

    internal class ServiceNode
    {
        public int               Id;
        public string            Name;
        public string            Xrl;
        public string            VirtInterface;
        public uint              Duration;
        public uint              MaxReqsPerSec;
        public bool              AllowAnonymousAccess;
        public bool              BlockRequests;
        public ulong             MaxRequestThreshold;
        public byte[]            XBancKey; // Key used to find this API in xbanc
        public bool              XBancFailed; // Tracks to see if Xbanc failed on a call to Increment(+0), so as to eventually fail open.

        // This is the factor that represents the multiplier over the TPS rate to properly represent the TPS value.
        public static readonly double ThresholdMultiplier = (double)Livecache.ThrottleDecay / Math.Log(2.0);

        private static Dictionary<int, byte> platformTypeMapping =
            new Dictionary<int,byte> {
                { LivecacheConst.LcClientType_XboxCom, XOn.XPLT_INTERNAL_XBOXCOM },
                { LivecacheConst.LcClientType_Zune, XOn.XPLT_INTERNAL_ZUNE },
                { LivecacheConst.LcClientType_XNA, XOn.XPLT_INTERNAL_XNA },
                { LivecacheConst.LcClientType_WGX, XOn.XPLT_INTERNAL_WGX },
                { LivecacheConst.LcClientType_LIVEn, XOn.XPLT_INTERNAL_LIVEN },
            };

        public byte GetPlatformType()
        {
            // The value of the Id will indicate who is making this call. We need to be 
            // consistent in assigning Id values in the t_livecache_apis tables, since 
            // there is nothing enforcing this except us.

            int lcService = (Id & LivecacheConst.LcClientTypeMask) >> LivecacheConst.LcClientTypeShift;

            byte platform = XOn.XPLT_INTERNAL;
            return platformTypeMapping.TryGetValue(lcService, out platform) ? platform : XOn.XPLT_INTERNAL;
        }

        public void ComputeThreshold()
        {
            MaxRequestThreshold = MaxReqsPerSec == 0 ? 0 : (ulong)((double)MaxReqsPerSec * ThresholdMultiplier) + 1; // + 1 'cause cast will floor value
        }
    }

    internal class LivecacheEntry
    {
        public byte[]      Response;
        public DateTime    Expiry;
        public HResult     HResult;
    }

    internal class ServerLivecacheKey : LivecacheKey
    {
        public ServerLivecacheKey( 
            int lcserviceId,
            ulong userId,
            byte[] postData,
            string schemaVersion,
            string clientType
            )
        {
            _keyString = string.Format("{0:d}|{1:x}|{2}|{3}|{4}",
                lcserviceId,
                userId,
                Convert.ToBase64String(postData),
                schemaVersion,
                clientType);
        }
    }

    internal static class InvalidationTracker 
    {
        private sealed class InvalidationTime
        {
            public InvalidationTime()
            {
                Invalidated = DateTime.MinValue;
            }

            public DateTime Invalidated;
        }

        internal static bool IsEntryValid(DateTime requestStart, string dependency)
        {
            string[] categories;

            // entries with no dependencies are not invalidated
            if (string.IsNullOrEmpty(dependency))
                return true;

            categories = ExtractCategories(dependency);

            for (int c=0; c<categories.Length; c++)
            {
                if (tracker[categories[c]].Invalidated > requestStart)
                    return false;
            }

            return true;
        }

        internal static void UpdateInvalidationTime(DateTime requestTime, string invalidation)
        {
            string[] categories;

            categories = ExtractCategories(invalidation);

            for (int c=0; c<categories.Length; c++)
                tracker[categories[c]].Invalidated = requestTime;
        }

        // extraction format XXXXX.name,XXXXX.name,XXXXX.name ...
        private static string[] ExtractCategories(string list) 
        {
            string[] results;

            var res = from e in list.Split(',')
                      select e.Split('.')[1];

            results = res.ToArray();
            return results;
        }

        // See client\logic\LcDependency:LiveCacheDependency.LiveCacheDependencyName
        private static Dictionary<string, InvalidationTime> tracker =
            new Dictionary<string,InvalidationTime> {
                { "u", new InvalidationTime() },
                { "p", new InvalidationTime() },
                { "m", new InvalidationTime() },
                { "f", new InvalidationTime() },
                { "s", new InvalidationTime() },
                { "t", new InvalidationTime() },
                { "l", new InvalidationTime() },
                { "a", new InvalidationTime() },
            };
    }
}   // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcGetParentalControlGroupTemplates.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.webplatform.livecache;

using xonline.common.config;
using xonline.common.billing;
using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.stfutil;
using xonline.common.user;
using xonline.common.utilities;

using XXOn = xonline.common.service.XOn;

//using live.common;
//using live.internaltest;
//using live.protocol;
//using live.client;
//using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

using StfUserAccount = ServerTestFramework.LiveService.UserAccount;

namespace LiveCacheFamilyTest
{
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), TestCasePriority(2)]
    public class GetParentalControlGroupTemplates : TestNode
    {
        class LiveClientSettings
        {
            public byte _clientPlatform;
            public LivecacheClientType _livecacheClientType;
            public uint _titleID;
            public ulong _machineID;
        }

        [TestCase, TestCasePriority(2)]
        class P_GetParentalControlGroupTemplates : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;

                // Create users
                XeUser user = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = ServerTestFramework.LiveService.XOn.XPLT_WEB;
                lcsetting._livecacheClientType = LivecacheClientType.Xboxcom;
                lcsetting._titleID = ServerTestFramework.LiveService.XOn.XENON_DASH_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                GetParentalControlGroupTemplatesRequest req = new GetParentalControlGroupTemplatesRequest();
                req.userPuid = user.UserPuid;

                LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                aadp._LivePuid = user.UserPuid;
                aadp._Tier = 3;
                aadp._Privileges = new uint[8];
                aadp._Privileges[0] = 0;
                aadp._Privileges[1] = 0;
                aadp._Privileges[2] = 0;
                aadp._Privileges[3] = 0;
                aadp._Privileges[4] = 0;
                aadp._Privileges[5] = 0;
                aadp._Privileges[6] = 0x10000000;
                aadp._Privileges[7] = 0x9bf924fc;
                aadp._ClientPlatform = ServerTestFramework.LiveService.XOn.XPLT_WEB;

                Global.RO.Info("Calling LiveCache");
                LcAccountCreation lcAC =
                    new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

                GetParentalControlGroupTemplatesResponse resp = lcAC.GetParentalControlGroupTemplates(req);

                Assert.AreEqual(resp.templates.Length, 3,
                    string.Format("Error validating templates! Got {0}. Expected {1}", resp.templates.Length, 3));

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcGetParentalControls.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.webplatform.livecache;

using xonline.common.config;
using xonline.common.billing;
using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.stfutil;
using xonline.common.user;
using xonline.common.utilities;

using XXOn = xonline.common.service.XOn;

//using live.common;
//using live.internaltest;
//using live.protocol;
//using live.client;
//using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

using StfUserAccount = ServerTestFramework.LiveService.UserAccount;

namespace LiveCacheFamilyTest
{
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), TestCasePriority(2)]
    public class GetParentalControls : TestNode
    {
        class LiveClientSettings
        {
            public byte _clientPlatform;
            public LivecacheClientType _livecacheClientType;
            public uint _titleID;
            public ulong _machineID;
        }

        [TestCase, TestCasePriority(2)]
        class P_GetParentalControls : UserTestBase
        {
            private void ValidateResults(uint[] expected, uint[] actual)
            {
                // For some reason hitting this through live cache causes some bad data
                // in index 0. Index 0 is not used by our parental controls.
                for (int idx = 1; idx < actual.Length; idx++)
                {
                    Assert.AreEqual(expected[idx],
                        actual[idx],
                        string.Format("Error validating values at index {0}! Got {1}. Expected {2}",
                            idx,
                            actual[idx],
                            expected[idx]));
                }
            }

            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;

                // Create users
                XeUser user = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = ServerTestFramework.LiveService.XOn.XPLT_WEB;
                lcsetting._livecacheClientType = LivecacheClientType.Xboxcom;
                lcsetting._titleID = ServerTestFramework.LiveService.XOn.XENON_DASH_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                GetParentalControlsRequest req = new GetParentalControlsRequest();
                req.userPuid = req.requestorPuid = user.UserPuid;

                LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                aadp._LivePuid = user.UserPuid;
                aadp._Tier = 3;
                aadp._Privileges = new uint[8];
                aadp._Privileges[0] = 0;
                aadp._Privileges[1] = 0;
                aadp._Privileges[2] = 0;
                aadp._Privileges[3] = 0;
                aadp._Privileges[4] = 0;
                aadp._Privileges[5] = 0;
                aadp._Privileges[6] = 0x10000000;
                aadp._Privileges[7] = 0x9bf924fc;
                aadp._ClientPlatform = ServerTestFramework.LiveService.XOn.XPLT_WEB;

                Global.RO.Info("Calling LiveCache");
                LcAccountCreation lcAC =
                    new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

                GetParentalControlsResponse resp = lcAC.GetParentalControls(req, aadp);

                Global.RO.Info("Validating results");
                //ValidateResults(userPrivilges.ToArray(), resp.userGrantPrivileges);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcUpdateParentalControlGroup.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.webplatform.livecache;

using xonline.common.config;
using xonline.common.billing;
using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.stfutil;
using xonline.common.user;
using xonline.common.utilities;

using XXOn = xonline.common.service.XOn;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

using StfUserAccount = ServerTestFramework.LiveService.UserAccount;

namespace LiveCacheFamilyTest
{
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), TestCasePriority(2)]
    public class UpdateParentalControlGroup : TestNode
    {
        class LiveClientSettings
        {
            public byte _clientPlatform;
            public LivecacheClientType _livecacheClientType;
            public uint _titleID;
            public ulong _machineID;
        }

        [TestCase, TestCasePriority(2)]
        class P_UpdateParentalControlGroup : UserTestBase
        {
            private void ValidateResults(xonline.common.protocol.UserParentalControlGroup[] groups, ulong userPuid)
            {
                Assert.AreEqual(groups.Length, 1,
                    string.Format("Error validating group length! Got {0}. Expected {1}", groups.Length, 1));

                Assert.AreEqual(groups[0].userPuid, userPuid,
                    string.Format("Error validating userPuid! Got {0}. Expected {1}", groups[0].userPuid, userPuid));

                Assert.AreEqual(groups[0].parentalControlGroupId, XXOn.PARENTAL_CONTROL_GROUP_RESTRICTED,
                    string.Format("Error validating parentalControlGroupId! Got {0}. Expected {1}", groups[0].parentalControlGroupId, XXOn.PARENTAL_CONTROL_GROUP_RESTRICTED));
            }

            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;

                // Create users
                XeUser user = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = ServerTestFramework.LiveService.XOn.XPLT_WEB;
                lcsetting._livecacheClientType = LivecacheClientType.Xboxcom;
                lcsetting._titleID = ServerTestFramework.LiveService.XOn.XENON_DASH_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                UpdateParentalControlGroupRequest req = new UpdateParentalControlGroupRequest();
                req.userPuid = user.UserPuid;
                req.parentalControlGroupId = XXOn.PARENTAL_CONTROL_GROUP_RESTRICTED;

                LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                aadp._LivePuid = user.UserPuid;
                aadp._Tier = 3;
                aadp._Privileges = new uint[8];
                aadp._Privileges[0] = 0;
                aadp._Privileges[1] = 0;
                aadp._Privileges[2] = 0;
                aadp._Privileges[3] = 0;
                aadp._Privileges[4] = 0;
                aadp._Privileges[5] = 0;
                aadp._Privileges[6] = 0x10000000;
                aadp._Privileges[7] = 0x9bf924fc;
                aadp._ClientPlatform = ServerTestFramework.LiveService.XOn.XPLT_WEB;

                Global.RO.Info("Calling LiveCache");
                LcAccountCreation lcAC =
                    new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

                lcAC.UpdateParentalControlGroup(req, aadp);

                Global.RO.Info("Validating results");
                GetUserParentalControlGroupRequest reqGet = new GetUserParentalControlGroupRequest();
                reqGet.requestorPuid = user.UserPuid;
                reqGet.userPuidCount = 1;
                reqGet.userPuids = new Puid[] { user.UserPuid };

                GetUserParentalControlGroupResponse respGet = lcAC.GetUserParentalControlGroup(reqGet, aadp);
                ValidateResults(respGet.users, user.UserPuid);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcXeAddDependent.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheFamilyTest
{
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), TestCasePriority(2)]
    public class XeAddIndependent : TestNode
    {
		[TestCase, TestCasePriority(2)]
		class P_XboxCom : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Xboxcom, XOn.XPLT_WEB, XOn.XENON_DASH_TITLE_ID);
                
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2)]
		class P_Zune : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Zune, XOn.XPLT_ZUNEV2, XOn.CRUX_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

        protected static void InnerExecute(LivecacheClientType clientType, byte clientPlatform, uint clientTitleId)
        {
            UacsCommon.LiveCacheResetInitializedClientType();

            // Create users
            XeUser parent = UacsCommon.CreateXenonUser(3);
            XeUser dependent1 = UacsCommon.CreateXenonUser(3);
            
            // Set expectedFamilyMembers
            ServerTestFramework.LiveService.UserAccount.FamilyMember[] expectedFamilyMembers = new ServerTestFramework.LiveService.UserAccount.FamilyMember[2];
            
            expectedFamilyMembers[0] = new ServerTestFramework.LiveService.UserAccount.FamilyMember(dependent1, 0);
            expectedFamilyMembers[1] = new ServerTestFramework.LiveService.UserAccount.FamilyMember(parent, ServerTestFramework.LiveService.UserAccount.FamilyDefs.FAMILY_OWNER);
            
            Global.RO.Info("AddDependent for user 0x" + dependent1.UserPuid.ToString("X"));
    
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
            
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = parent.UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
            aadp._XboxPuid = UacsCommon.RandomXenonMachineUid();;
    
            LcAccountCreation lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
    
            //
            // First call
            //
    
            // AddDependentRequest
            xonline.common.protocol.AddDependentRequest request = new xonline.common.protocol.AddDependentRequest();
            request.machinePuid = aadp._XboxPuid;
            //request.machinePuid = UacsCommon.RandomXenonMachineUid();
            request.userPuid = dependent1.UserPuid;
            request.signedOldOwnerPassportPuid = dependent1.PassportOwnerSessionToken;
            request.ownerPuid = parent.UserPuid;
    
            lcAC.AddDependent(request);;

            UacsCommon.WaitForXCache();
    
            //  Verify    
            XRLXeEnumFamilyMembersRequest req = new XRLXeEnumFamilyMembersRequest();
            req.requestorPuid = dependent1.UserPuid;

            XRLXeEnumFamilyMembersResponse resp;
            if (!req.Execute(out resp)) {
                throw new UnexpectedTestResultException(string.Format("EnumFamilyMembers failed: {0}", req.GetDumpString()));
            }
            if (req.XErr != 0) {
                throw new UnexpectedTestResultException(string.Format("EnumFamilyMembers returned XErr=0x{0:x}", req.XErr));
            }

            if (resp.numFamilyMembers != expectedFamilyMembers.Length)
            {
                throw new UnexpectedTestResultException(string.Format("resp.numFamilyMembers({0}) != expectedFamilyMembers.Length({1})", resp.numFamilyMembers, expectedFamilyMembers.Length));
            }
    
            // Scan results for each member
            foreach (ServerTestFramework.LiveService.UserAccount.FamilyMember member in expectedFamilyMembers)
            {
                int idx = Array.FindIndex(resp.familyMembers, c => c.userPuid == member.userPuid);
                if (idx == -1)
                {
                    throw new UnexpectedTestResultException(string.Format("EnumFamilyMembersResponse: user 0x{0:X} is missing from resp", member.userPuid));
                }
                else 
                {   
                    Global.RO.Info("user 0x{0:X} has a flag 0x{1:X}", resp.familyMembers[idx].userPuid, resp.familyMembers[idx].userFlags);
                    
                    if (resp.familyMembers[idx].userFlags != member.userFlags)
                        throw new UnexpectedTestResultException(string.Format("resp.familyMembers[idx].userFlags({0}) != member.userFlags({1})", resp.familyMembers[idx].userFlags, member.userFlags));
                    
                    if (resp.familyMembers[idx].gamertag != member.gamertag)
                        throw new UnexpectedTestResultException(string.Format("resp.familyMembers[idx].gamertag({0}) != member.gamertag({1})", resp.familyMembers[idx].gamertag, member.gamertag));
                }
            }
    
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcGetUserParentalControlGroup.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.webplatform.livecache;

using xonline.common.config;
using xonline.common.billing;
using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.stfutil;
using xonline.common.user;
using xonline.common.utilities;

using XXOn = xonline.common.service.XOn;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

using StfUserAccount = ServerTestFramework.LiveService.UserAccount;

namespace LiveCacheFamilyTest
{
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), TestCasePriority(2)]
    public class GetUserParentalControlGroup : TestNode
    {
        class LiveClientSettings
        {
            public byte _clientPlatform;
            public LivecacheClientType _livecacheClientType;
            public uint _titleID;
            public ulong _machineID;
        }

        [TestCase, TestCasePriority(2)]
        class P_GetUserParentalControlGroup : UserTestBase
        {
            private void ValidateResults(xonline.common.protocol.UserParentalControlGroup[] groups, ulong userPuid)
            {
                Assert.AreEqual(groups.Length, 1,
                    string.Format("Error validating group length! Got {0}. Expected {1}", groups.Length, 1));

                Assert.AreEqual(groups[0].userPuid, userPuid,
                    string.Format("Error validating userPuid! Got {0}. Expected {1}", groups[0].userPuid, userPuid));

                Assert.AreEqual(groups[0].parentalControlGroupId, XXOn.PARENTAL_CONTROL_GROUP_OPEN,
                    string.Format("Error validating parentalControlGroupId! Got {0}. Expected {1}", groups[0].parentalControlGroupId, XXOn.PARENTAL_CONTROL_GROUP_OPEN));
            }

            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;

                // Create users
                XeUser user = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = ServerTestFramework.LiveService.XOn.XPLT_WEB;
                lcsetting._livecacheClientType = LivecacheClientType.Xboxcom;
                lcsetting._titleID = ServerTestFramework.LiveService.XOn.XENON_DASH_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                GetUserParentalControlGroupRequest req = new GetUserParentalControlGroupRequest();
                req.requestorPuid = user.UserPuid;
                req.userPuidCount = 1;
                req.userPuids = new Puid[] { user.UserPuid };

                LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                aadp._LivePuid = user.UserPuid;
                aadp._Tier = 3;
                aadp._Privileges = new uint[8];
                aadp._Privileges[0] = 0;
                aadp._Privileges[1] = 0;
                aadp._Privileges[2] = 0;
                aadp._Privileges[3] = 0;
                aadp._Privileges[4] = 0;
                aadp._Privileges[5] = 0;
                aadp._Privileges[6] = 0x10000000;
                aadp._Privileges[7] = 0x9bf924fc;
                aadp._ClientPlatform = ServerTestFramework.LiveService.XOn.XPLT_WEB;

                Global.RO.Info("Calling LiveCache");
                LcAccountCreation lcAC =
                    new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

                GetUserParentalControlGroupResponse resp = lcAC.GetUserParentalControlGroup(req, aadp);

                Global.RO.Info("Validating results");
                ValidateResults(resp.users, user.UserPuid);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcXeEnumFamilyMembers.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheFamilyTest
{
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), TestCasePriority(2)]
    public class XeEnumFamilyMembers : TestNode
    {
		[TestCase, TestCasePriority(2)]
		class P_XboxCom : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Xboxcom, XOn.XPLT_WEB, XOn.XENON_DASH_TITLE_ID);
                
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2)]
		class P_Zune : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Zune, XOn.XPLT_ZUNEV2, XOn.CRUX_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

        protected static void InnerExecute(LivecacheClientType clientType, byte clientPlatform, uint clientTitleId)
        {
            UacsCommon.LiveCacheResetInitializedClientType();
            
            const int NUM_CHILDREN = 1;
            
            // Create a family with 1 child
            XeUser   parent;
            XeUser[] children;
            UacsCommon.CreateFamily(NUM_CHILDREN, out parent, out children);
            
            
            // Set expectedFamilyMembers
            ServerTestFramework.LiveService.UserAccount.FamilyMember[] expectedFamilyMembers = new ServerTestFramework.LiveService.UserAccount.FamilyMember[NUM_CHILDREN+1];
            
            for(int ii=0; ii<NUM_CHILDREN; ii++)
            {
                expectedFamilyMembers[ii] = new ServerTestFramework.LiveService.UserAccount.FamilyMember(children[ii], 0);
            }
            expectedFamilyMembers[NUM_CHILDREN] = new ServerTestFramework.LiveService.UserAccount.FamilyMember(parent, ServerTestFramework.LiveService.UserAccount.FamilyDefs.FAMILY_OWNER);
            
            UacsCommon.WaitForXCache();
    
            Global.RO.Info("XeEnumFamilyMembers for user 0x" + parent.UserPuid.ToString("X"));
    
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
            
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = parent.UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
    
            LcAccountCreation lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
    
            //
            // First call
            //
    
            // EnumFamilyMembersRequest
            xonline.common.protocol.EnumFamilyMembersRequest request = new xonline.common.protocol.EnumFamilyMembersRequest();
            request.userPuid = parent.UserPuid;
    
            xonline.common.protocol.EnumFamilyMembersResponse response = lcAC.EnumFamilyMembers(request);;
    
            //  Verify    
            if (response.numFamilyMembers != expectedFamilyMembers.Length)
            {
                throw new UnexpectedTestResultException(string.Format("response.numFamilyMembers({0}) != expectedFamilyMembers.Length({1})", response.numFamilyMembers, expectedFamilyMembers.Length));
            }
    
            // Scan results for each member
            foreach (ServerTestFramework.LiveService.UserAccount.FamilyMember member in expectedFamilyMembers)
            {
                int idx = Array.FindIndex(response.familyMembers, c => c.userPuid == member.userPuid);
                if (idx == -1)
                {
                    throw new UnexpectedTestResultException(string.Format("EnumFamilyMembersResponse: user 0x{0:X} is missing from response", member.userPuid));
                }
                else 
                {   
                    Global.RO.Info("user 0x{0:X} has a flag 0x{1:X}", response.familyMembers[idx].userPuid, response.familyMembers[idx].userFlags);
                    
                    if (response.familyMembers[idx].userFlags != member.userFlags)
                        throw new UnexpectedTestResultException(string.Format("response.familyMembers[idx].userFlags({0}) != member.userFlags({1})", response.familyMembers[idx].userFlags, member.userFlags));
                    
                    if (response.familyMembers[idx].gamertag != member.gamertag)
                        throw new UnexpectedTestResultException(string.Format("response.familyMembers[idx].gamertag({0}) != member.gamertag({1})", response.familyMembers[idx].gamertag, member.gamertag));
                }
            }
    
            //
            // Second call to see cache is working correctly
            //
    
            // EnumFamilyMembersRequest
            request = new xonline.common.protocol.EnumFamilyMembersRequest();
            request.userPuid = parent.UserPuid;
    
            response = lcAC.EnumFamilyMembers(request);;
    
            //  Verify    
            if (response.numFamilyMembers != expectedFamilyMembers.Length)
            {
                throw new UnexpectedTestResultException(string.Format("response.numFamilyMembers({0}) != expectedFamilyMembers.Length({1})", response.numFamilyMembers, expectedFamilyMembers.Length));
            }
    
            // Scan results for each member
            foreach (ServerTestFramework.LiveService.UserAccount.FamilyMember member in expectedFamilyMembers)
            {
                int idx = Array.FindIndex(response.familyMembers, c => c.userPuid == member.userPuid);
                if (idx == -1)
                {
                    throw new UnexpectedTestResultException(string.Format("EnumFamilyMembersResponse: user 0x{0:X} is missing from response", member.userPuid));
                }
                else 
                {   
                    Global.RO.Info("user 0x{0:X} has a flag 0x{1:X}", response.familyMembers[idx].userPuid, response.familyMembers[idx].userFlags);
                    
                    if (response.familyMembers[idx].userFlags != member.userFlags)
                        throw new UnexpectedTestResultException(string.Format("response.familyMembers[idx].userFlags({0}) != member.userFlags({1})", response.familyMembers[idx].userFlags, member.userFlags));
                    
                    if (response.familyMembers[idx].gamertag != member.gamertag)
                        throw new UnexpectedTestResultException(string.Format("response.familyMembers[idx].gamertag({0}) != member.gamertag({1})", response.familyMembers[idx].gamertag, member.gamertag));
                }
            }
    
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcXeRemoveDependent.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

using StfUserAccount = ServerTestFramework.LiveService.UserAccount;

namespace LiveCacheFamilyTest
{
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), TestCasePriority(2)]
    public class XeRemoveDependent : TestNode
    {
        class LiveClientSettings
        {
            public byte _clientPlatform;
            public LivecacheClientType _livecacheClientType;
            public uint _titleID;
            public ulong _machineID;
        }

        static void VerifyFamilyMembers(XeUser user, StfUserAccount.FamilyMember[] expectedFamilyMembers)
        {
            //  Verify    
            XRLXeEnumFamilyMembersRequest req = new XRLXeEnumFamilyMembersRequest();
            req.requestorPuid = user.UserPuid;

            XRLXeEnumFamilyMembersResponse resp;
            if (!req.Execute(out resp))
                throw new UnexpectedTestResultException(string.Format("EnumFamilyMembers failed: {0}", req.GetDumpString()));
            if (req.XErr != 0)
                throw new UnexpectedTestResultException(string.Format("EnumFamilyMembers returned XErr=0x{0:x}", req.XErr));
            if (resp.numFamilyMembers != expectedFamilyMembers.Length)
                throw new UnexpectedTestResultException(string.Format("resp.numFamilyMembers({0}) != expectedFamilyMembers.Length({1})", resp.numFamilyMembers, expectedFamilyMembers.Length));

            // Scan results for each member
            foreach (StfUserAccount.FamilyMember member in expectedFamilyMembers)
            {
                int idx = Array.FindIndex(resp.familyMembers, c => c.userPuid == member.userPuid);
                if (idx == -1)
                {
                    throw new UnexpectedTestResultException(string.Format("EnumFamilyMembersResponse: user 0x{0:X} is missing from resp", member.userPuid));
                }
                else
                {
                    Global.RO.Info("user 0x{0:X} has a flag 0x{1:X}", resp.familyMembers[idx].userPuid, resp.familyMembers[idx].userFlags);

                    if (resp.familyMembers[idx].userFlags != member.userFlags)
                        throw new UnexpectedTestResultException(string.Format("resp.familyMembers[idx].userFlags({0}) != member.userFlags({1})", resp.familyMembers[idx].userFlags, member.userFlags));

                    if (resp.familyMembers[idx].gamertag != member.gamertag)
                        throw new UnexpectedTestResultException(string.Format("resp.familyMembers[idx].gamertag({0}) != member.gamertag({1})", resp.familyMembers[idx].gamertag, member.gamertag));
                }
            }

        }
        static void AddDependent(XeUser owner, XeUser dependent, LiveClientSettings lcsetting)
        {

            Global.RO.Info("Adding dependent {0}", dependent.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = lcsetting._clientPlatform;
            aadp._XboxPuid = lcsetting._machineID;

            LcAccountCreation lcAC =
                new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

            xonline.common.protocol.AddDependentRequest req =
                new xonline.common.protocol.AddDependentRequest();
            req.userPuid = dependent.UserPuid;
            req.machinePuid = aadp._XboxPuid;
            req.signedOldOwnerPassportPuid = dependent.PassportOwnerSessionToken;
            req.ownerPuid = owner.UserPuid;

            lcAC.AddDependent(req);
            UacsCommon.WaitForXCache();
        }
        static void RemoveDependent(XeUser owner, XeUser dependent, LiveClientSettings lcsetting)
        {

            Global.RO.Info("Removing dependent {0}", dependent.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = lcsetting._clientPlatform;
            aadp._XboxPuid = lcsetting._machineID;

            LcAccountCreation lcAC =
                new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

            xonline.common.protocol.RemoveDependentRequest req =
                new xonline.common.protocol.RemoveDependentRequest();
            req.userPuid = dependent.UserPuid;
            req.ownerPuid = owner.UserPuid;
            req.machinePuid = aadp._XboxPuid;


            lcAC.RemoveDependent(req);
            UacsCommon.WaitForXCache();
        }

        [TestCase, TestCasePriority(2)]
        class P_RemoveDependentZune : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;
                // Create Zune Account
                XeUser owner = UacsCommon.CreateXenonUser(3);
                XeUser dependent = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = XOn.XPLT_ZUNEV2;
                lcsetting._livecacheClientType = LivecacheClientType.Zune;
                lcsetting._titleID = XOn.CRUX_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                AddDependent(owner, dependent, lcsetting);
                StfUserAccount.FamilyMember[] familyMembers = new StfUserAccount.FamilyMember[2];
                familyMembers[0] = new StfUserAccount.FamilyMember(dependent, 0);
                familyMembers[1] = new StfUserAccount.FamilyMember(owner, StfUserAccount.FamilyDefs.FAMILY_OWNER);
                VerifyFamilyMembers(dependent, familyMembers);

                RemoveDependent(owner, dependent, lcsetting);
                StfUserAccount.FamilyMember[] familyMembers2 = new StfUserAccount.FamilyMember[1];
                familyMembers2[0] = new StfUserAccount.FamilyMember(owner, StfUserAccount.FamilyDefs.FAMILY_OWNER);
                VerifyFamilyMembers(owner, familyMembers2);

                UacsCommon.WaitForXCache();
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, TestCasePriority(2)]
        class P_RemoveDependentXboxCom : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;
                // Create Xbox.com Account
                XeUser owner = UacsCommon.CreateXenonUser(3);
                XeUser dependent = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = XOn.XPLT_WEB;
                lcsetting._livecacheClientType = LivecacheClientType.Xboxcom;
                lcsetting._titleID = XOn.XENON_DASH_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                AddDependent(owner, dependent, lcsetting);
                StfUserAccount.FamilyMember[] familyMembers = new StfUserAccount.FamilyMember[2];
                familyMembers[0] = new StfUserAccount.FamilyMember(dependent, 0);
                familyMembers[1] = new StfUserAccount.FamilyMember(owner, StfUserAccount.FamilyDefs.FAMILY_OWNER);
                VerifyFamilyMembers(dependent, familyMembers);

                RemoveDependent(owner, dependent, lcsetting);
                StfUserAccount.FamilyMember[] familyMembers2 = new StfUserAccount.FamilyMember[1];
                familyMembers2[0] = new StfUserAccount.FamilyMember(owner, StfUserAccount.FamilyDefs.FAMILY_OWNER);
                VerifyFamilyMembers(owner, familyMembers2);

                UacsCommon.WaitForXCache();
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LiveCacheFamilyCommon.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using xonline.core.history;
using xonline.common.webplatform.livecache;
using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

namespace LiveCacheFamilyTest
{
    public class LiveCacheFamilyCommon
    {
        public static void MakePurchase(XeUser user, ulong[] offerIds, LivecacheClientType clientType, byte clientPlatform, uint clientTitleId, ulong clientMachineId)
        {
            Global.RO.Info("Purchase FamilyGold for user {0}", user.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = user.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(user.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
            aadp._XboxPuid = clientMachineId;

            xonline.common.protocol.XeOfferPurchaseRequest requestGold =
                        new xonline.common.protocol.XeOfferPurchaseRequest();
            requestGold.userPuid = user.UserPuid;
            requestGold.offerID = 0;
            requestGold.offerIDs = offerIds;
            requestGold.offerIDLength = (uint)requestGold.offerIDs.Length;
            requestGold.languageID = user.LanguageId;
            requestGold.countryID = user.CountryId;
            requestGold.tier = (byte)UodbWS.GetUserTier(user.UserPuid);
            requestGold.paymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard;
            requestGold.paymentInstrumentID = user.AddPaymentInstrumentVisa();
            requestGold.machinePuid = aadp._XboxPuid;

            LcBillingOffering lcBO =
                new LcBillingOffering(clientType, clientTitleId, aadp, false);
            uint hr = lcBO.PurchaseSubscription(requestGold);
            Global.RO.Info(String.Format("lcBO.PurchaseSubscription returned 0x{0:x}", hr));
            if (hr != ServerTestFramework.LiveService.HResult.S_OK)
                throw new UnexpectedTestResultException(string.Format("Purchase FamilyGold failed: {0}", hr.ToString("X")));
        }

        public static void AddDependent(XeUser owner, XeUser dependent, LivecacheClientType clientType, byte clientPlatform, uint clientTitleId, ulong clientMachineId)
        {
            Global.RO.Info("Adding dependent {0}", dependent.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
            aadp._XboxPuid = clientMachineId;

            LcAccountCreation lcAC =
                new LcAccountCreation(clientType, clientTitleId, aadp, false);

            xonline.common.protocol.AddDependentRequest req =
                new xonline.common.protocol.AddDependentRequest();
            req.userPuid = dependent.UserPuid;
            req.machinePuid = aadp._XboxPuid;
            req.signedOldOwnerPassportPuid = dependent.PassportOwnerSessionToken;
            req.ownerPuid = owner.UserPuid;

            lcAC.AddDependent(req);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcXeFamilySubscriptionAssignGoldSeat.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

using xonline.common.config;
using xonline.common.protocol;
using Microsoft.XBox.Live.Server.Emulators.Framework;
using Microsoft.XBox.Live.Server.Emulators.MusicNet;
using Microsoft.XBox.Live.Server.Emulators.Dmp;
using Microsoft.XBox.Live.Server.Emulators.Bdk;
using ServerTestFramework.LiveService.FakeSG;


using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
namespace LiveCacheFamilyTest
{

    [TestGroup, Owner("kkline"), TestCasePriority(1), TestFrequency("Regression"), EnvRequirement("Billing")]
    public class XeFamilySubscriptionAssignGoldSeat : TestNode
    {
        private static void AcceptTermsOfService(XeUser orphan)
        {
            XRLXeAcceptTermsOfService req = new XRLXeAcceptTermsOfService();

            req.userPuid = orphan.UserPuid;
            req.serviceType = 1; // XboxLive service type
            req.titleId = XOn.XENON_DASH_TITLE_ID;

            req.ManualPopulateSlot();
            req.Slot.titleId = req.titleId;

            if (!req.Execute())
            {
                throw new UnexpectedTestResultException(
                    "XeAcceptTermsOfService failed: " +
                    req.GetDumpString());
            }

            if (req.XErr != HResult.S_OK)
            {
                throw new UnexpectedTestResultException(
                    String.Format(
                        "XeAcceptTermsOfService returned XErr=0x{0:x}",
                        req.XErr));
            }
        }
        class LiveClientSettings
        {
            public byte _clientPlatform;
            public LivecacheClientType _livecacheClientType;
            public uint _titleID;
            public ulong _machineID;
        }

        private static UserPrivileges GetWebUserPrivileges(ulong userPuid)
        {
            XRLXeGetUserWebInfo requestWeb = new XRLXeGetUserWebInfo();
            XRLXeGetUserWebInfoResponse response =
                new XRLXeGetUserWebInfoResponse();

            requestWeb.UserPuid = userPuid;
            if (!requestWeb.Execute(out response))
            {
                throw new UnexpectedTestResultException("XRLXeGetUserWebInfo failed: " + requestWeb.GetDumpString());
            }

            if (requestWeb.XErr != HResult.S_OK)
            {
                throw new UnexpectedTestResultException(String.Format("XRLXeGetUserWebInfo returned XErr=0x{0:x}", requestWeb.XErr));
            }

            UserPrivileges currentPrivs =
                new UserPrivileges(response.UserPrivileges);

            return currentPrivs;
        }

        static void CheckPrivileges(XeUser user, int priv)
        {
            Global.RO.Info("CheckPrivileges for " + priv);
            UserPrivileges privs = GetWebUserPrivileges(user.UserPuid);

            ValueCheck.IsTrue(privs[(int)priv], "Missing Privilege: " + priv);

            Global.RO.Success("CheckDefaultPrivileges passed");
        }
        static void AddDependent(XeUser owner, XeUser dependent, LiveClientSettings lcsetting)
        {

            Global.RO.Info("Adding dependent {0}", dependent.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = lcsetting._clientPlatform;
            aadp._XboxPuid = lcsetting._machineID ;

            LcAccountCreation lcAC = 
                new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

            xonline.common.protocol.AddDependentRequest req =
                new xonline.common.protocol.AddDependentRequest();
            req.userPuid = dependent.UserPuid;
            req.machinePuid = aadp._XboxPuid;
            req.signedOldOwnerPassportPuid = dependent.PassportOwnerSessionToken;
            req.ownerPuid = owner.UserPuid;

            lcAC.AddDependent(req);
            //UacsCommon.WaitForXCache();
        }

        static void PurchaseFamilyGold(XeUser owner, LiveClientSettings lcsetting)
        {
            Global.RO.Info("Purchase FamilyGold for user {0}", owner.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(owner.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = lcsetting._clientPlatform;
            aadp._XboxPuid = lcsetting._machineID;

            ulong[] offerIds = new ulong[] {Offers.GetBaseOfferId(Offers.BaseOffers.FamilyGoldCC1Year)};
            xonline.common.protocol.XeOfferPurchaseRequest requestGold =
                        new xonline.common.protocol.XeOfferPurchaseRequest();
            requestGold.userPuid = owner.UserPuid;
            requestGold.offerID = 0;
            requestGold.offerIDs = offerIds;
            requestGold.offerIDLength = (uint)requestGold.offerIDs.Length;
            requestGold.languageID = owner.LanguageId;
            requestGold.countryID = owner.CountryId;
            requestGold.tier = (byte)UodbWS.GetUserTier(owner.UserPuid);
            requestGold.paymentType = (uint)PaymentTypeEnum.CreditCard;
            requestGold.paymentInstrumentID = owner.AddPaymentInstrumentVisa();
            requestGold.machinePuid = aadp._XboxPuid;

            LcBillingOffering lcBO = 
                new LcBillingOffering(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);
            uint hr = lcBO.PurchaseSubscription(requestGold);
            Global.RO.Info(String.Format("lcBO.PurchaseSubscription returned 0x{0:x}", hr));
            if (hr != HResult.S_OK)
                throw new UnexpectedTestResultException(string.Format("Purchase FamilyGold failed: {0}", hr.ToString("X")));
        }

        static void AssignFamilyGoldSeat(XeUser owner, XeUser dependent, LiveClientSettings lcsetting)
        {
            Global.RO.Info("Assigning GoldSeat to dependent {0}", dependent.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(dependent.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = lcsetting._clientPlatform;
            aadp._XboxPuid = lcsetting._machineID;

            LcAccountCreation lcAC =
                new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

            xonline.common.protocol.FamilySubscriptionAssignGoldUserRequest req =
                new xonline.common.protocol.FamilySubscriptionAssignGoldUserRequest();
            req.machinePuid = aadp._XboxPuid;
            req.ownerPuid = owner.UserPuid;
            req.userPuid = dependent.UserPuid;

            lcAC.FamilySubscriptionAssignGoldUser(req);
        }

        [TestCase, TestCasePriority(2)]
        class P_AssignGoldSeatZune : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;
                // Create Zune Account
                XeUser owner = UacsCommon.CreateXenonUser(3);
                XeUser dependent = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = XOn.XPLT_ZUNEV2;
                lcsetting._livecacheClientType = LivecacheClientType.Zune;
                lcsetting._titleID = XOn.CRUX_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                AddDependent(owner, dependent, lcsetting);
                PurchaseFamilyGold(owner, lcsetting);
                AssignFamilyGoldSeat(owner, dependent, lcsetting);
                AcceptTermsOfService(dependent);

                CheckPrivileges(dependent, UserPrivileges.XPRIVILEGE_FAMILY);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, TestCasePriority(2)]
        class P_AssignGoldSeatXboxCom : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;
                // Create Zune Account
                XeUser owner = UacsCommon.CreateXenonUser(3);
                XeUser dependent = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = XOn.XPLT_WEB;
                lcsetting._livecacheClientType = LivecacheClientType.Xboxcom;
                lcsetting._titleID = XOn.XENON_DASH_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                AddDependent(owner, dependent, lcsetting);
                PurchaseFamilyGold(owner, lcsetting);
                AssignFamilyGoldSeat(owner, dependent, lcsetting);
                AcceptTermsOfService(dependent);

                CheckPrivileges(dependent, UserPrivileges.XPRIVILEGE_FAMILY);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcXeFamilySubscriptionRemoveGoldUser.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using xonline.core.history;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheFamilyTest
{
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), TestCasePriority(2)]
    public class XeFamilySubscriptionRemoveGoldUser : TestNode
    {
		[TestCase, TestCasePriority(2)]
		class P_XboxCom : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Xboxcom, XOn.XPLT_WEB, XOn.XENON_DASH_TITLE_ID);
                
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2)]
		class P_Zune : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Zune, XOn.XPLT_ZUNEV2, XOn.CRUX_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

        protected static void InnerExecute(LivecacheClientType clientType, byte clientPlatform, uint clientTitleId)
        {
            UacsCommon.LiveCacheResetInitializedClientType();
			ServerTestFramework.LiveService.UserAccount.FamilyMember[] expectedFamilyMembers = new ServerTestFramework.LiveService.UserAccount.FamilyMember[2];

            const int NUM_CHILDREN = 1;

            // Create a family with 1 child
            XeUser   parent;
            XeUser[] children;
            UacsCommon.CreateFamily(NUM_CHILDREN, out parent, out children);

			// Purchase family gold subscription
			UacsCommon.PurchaseFamilyGold(parent);

			// Add gold seat
			UacsCommon.AssignGoldUser(parent, children[0]);

			expectedFamilyMembers[0] = new ServerTestFramework.LiveService.UserAccount.FamilyMember(parent, ServerTestFramework.LiveService.UserAccount.FamilyDefs.FAMILY_OWNER | ServerTestFramework.LiveService.UserAccount.FamilyDefs.FAMILY_SUBSCRIPTION_GOLD);
			expectedFamilyMembers[1] = new ServerTestFramework.LiveService.UserAccount.FamilyMember(children[0], ServerTestFramework.LiveService.UserAccount.FamilyDefs.FAMILY_SUBSCRIPTION_GOLD);

            UacsCommon.ValidateEnumFamilyMembers(parent.UserPuid, expectedFamilyMembers, UacsCommon.XCache.Wait);

            //
            Global.RO.Info("AddDependent for user 0x" + children[0].UserPuid.ToString("X"));
    
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
            
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = parent.UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
            aadp._XboxPuid = UacsCommon.RandomXenonMachineUid();;
    
            LcAccountCreation lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
    
            //
            // First call
            //
    
            // AddDependentRequest
            xonline.common.protocol.FamilySubscriptionRemoveGoldUserRequest request = new xonline.common.protocol.FamilySubscriptionRemoveGoldUserRequest();
            request.machinePuid = aadp._XboxPuid;
            request.userPuid = children[0].UserPuid;
            request.ownerPuid = parent.UserPuid;
    
            lcAC.FamilySubscriptionRemoveGoldUser(request);;

            UacsCommon.WaitForXCache();
    
            //  Verify    
            expectedFamilyMembers[0] = new ServerTestFramework.LiveService.UserAccount.FamilyMember(parent, ServerTestFramework.LiveService.UserAccount.FamilyDefs.FAMILY_OWNER | ServerTestFramework.LiveService.UserAccount.FamilyDefs.FAMILY_SUBSCRIPTION_GOLD);
			expectedFamilyMembers[1] = new ServerTestFramework.LiveService.UserAccount.FamilyMember(children[0], 0);

            XRLXeEnumFamilyMembersRequest req = new XRLXeEnumFamilyMembersRequest();
            req.requestorPuid = children[0].UserPuid;

            XRLXeEnumFamilyMembersResponse resp;
            if (!req.Execute(out resp)) {
                throw new UnexpectedTestResultException(string.Format("EnumFamilyMembers failed: {0}", req.GetDumpString()));
            }
            if (req.XErr != 0) {
                throw new UnexpectedTestResultException(string.Format("EnumFamilyMembers returned XErr=0x{0:x}", req.XErr));
            }

            if (resp.numFamilyMembers != expectedFamilyMembers.Length)
            {
                throw new UnexpectedTestResultException(string.Format("resp.numFamilyMembers({0}) != expectedFamilyMembers.Length({1})", resp.numFamilyMembers, expectedFamilyMembers.Length));
            }
    
            // Scan results for each member
            UacsCommon.ValidateEnumFamilyMembers(parent.UserPuid, expectedFamilyMembers, UacsCommon.XCache.Wait);

			UacsCommon.VerifyFamilyHistory(parent.PassportOwnerPuid, children[0].UserPuid, (int)HResult.S_OK, false, (byte) HistoryReason.RemoveFamilyGold);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\GamerTag\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\MainClass.cs ===
using System;
using System.Runtime.InteropServices;
using System.Xml;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

using xonline.common.webplatform.livecache;

[assembly: RootNode(typeof(LiveCacheFamilyTest.LiveCacheXUacs))]

namespace LiveCacheFamilyTest
{
    public class LiveCacheXUacs : TestNode
    {
        public class AccountAuthDataProvider :  IExtendedAuthDataProvider
        {
            public ulong LivePuid { get { return _LivePuid; } }
            public byte Tier{ get { return _Tier; } }
            public uint[] Privileges { get { return _Privileges; } }
            public IPEndPoint ClientIPEndPoint { get { return _ClientIPEndPoint; } }

            public ulong XboxPuid { get { return _XboxPuid; } }
            public byte ClientPlatform { get { return _ClientPlatform; } }

            public ulong _LivePuid;
            public byte _Tier;
            public uint[] _Privileges;
            public IPEndPoint _ClientIPEndPoint;

            public ulong _XboxPuid;
            public byte _ClientPlatform;
        }

        public static void DefaultLivecacheLocaleHandler(out uint language, out uint country)
        {
            language = 1;
            country = 103;
        }

        public static void setAADPPrivileges(LiveCacheXUacs.AccountAuthDataProvider aadp)
        {
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
        }

    	public override void PreRun()
    	{
                // set the ReceiveTimeout and SendTimeout for TCP and UDP connection
                // make it 130 seconds since some calls to CSAT (or billing 1box) can take a long time
                FDTransaction.sReceiveTimeOut = 65000 * 2;            
                //Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(Interface.xuacs, "e :xuacs configcacherefresh");
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\GamerTag\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\familyapi\LcXeFamilySubscriptionGoldSeatCount.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

using xonline.common.config;
using xonline.common.protocol;
using Microsoft.XBox.Live.Server.Emulators.Framework;
using Microsoft.XBox.Live.Server.Emulators.MusicNet;
using Microsoft.XBox.Live.Server.Emulators.Dmp;
using Microsoft.XBox.Live.Server.Emulators.Bdk;
using ServerTestFramework.LiveService.FakeSG;


using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
namespace LiveCacheFamilyTest
{

    [TestGroup, Owner("kkline"), TestCasePriority(1), TestFrequency("Regression"), EnvRequirement("Billing")]
    public class XeFamilySubscriptionGoldSeatCount : TestNode
    {
        class LiveClientSettings
        {
            public byte _clientPlatform;
            public LivecacheClientType _livecacheClientType;
            public uint _titleID;
            public ulong _machineID;
        }

        class ExpectCountValue
        {
            public ushort total;
            public ushort avail;
        }

        private static UserPrivileges GetWebUserPrivileges(ulong userPuid)
        {
            XRLXeGetUserWebInfo requestWeb = new XRLXeGetUserWebInfo();
            XRLXeGetUserWebInfoResponse response =
                new XRLXeGetUserWebInfoResponse();

            requestWeb.UserPuid = userPuid;
            if (!requestWeb.Execute(out response))
            {
                throw new UnexpectedTestResultException("XRLXeGetUserWebInfo failed: " + requestWeb.GetDumpString());
            }

            if (requestWeb.XErr != HResult.S_OK)
            {
                throw new UnexpectedTestResultException(String.Format("XRLXeGetUserWebInfo returned XErr=0x{0:x}", requestWeb.XErr));
            }

            UserPrivileges currentPrivs =
                new UserPrivileges(response.UserPrivileges);

            return currentPrivs;
        }

        static void AddDependent(XeUser owner, XeUser dependent, LiveClientSettings lcsetting)
        {

            Global.RO.Info("Adding dependent {0}", dependent.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = lcsetting._clientPlatform;
            aadp._XboxPuid = lcsetting._machineID ;

            LcAccountCreation lcAC = 
                new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

            xonline.common.protocol.AddDependentRequest req =
                new xonline.common.protocol.AddDependentRequest();
            req.userPuid = dependent.UserPuid;
            req.machinePuid = aadp._XboxPuid;
            req.signedOldOwnerPassportPuid = dependent.PassportOwnerSessionToken;
            req.ownerPuid = owner.UserPuid;

            lcAC.AddDependent(req);
            //UacsCommon.WaitForXCache();
        }

        static void PurchaseFamilyGold(XeUser owner, LiveClientSettings lcsetting)
        {
            Global.RO.Info("Purchase FamilyGold for user {0}", owner.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(owner.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = lcsetting._clientPlatform;
            aadp._XboxPuid = lcsetting._machineID;

            ulong[] offerIds = new ulong[] {Offers.GetBaseOfferId(Offers.BaseOffers.FamilyGoldCC1Year)};
            xonline.common.protocol.XeOfferPurchaseRequest requestGold =
                        new xonline.common.protocol.XeOfferPurchaseRequest();
            requestGold.userPuid = owner.UserPuid;
            requestGold.offerID = 0;
            requestGold.offerIDs = offerIds;
            requestGold.offerIDLength = (uint)requestGold.offerIDs.Length;
            requestGold.languageID = owner.LanguageId;
            requestGold.countryID = owner.CountryId;
            requestGold.tier = (byte)UodbWS.GetUserTier(owner.UserPuid);
            requestGold.paymentType = (uint)PaymentTypeEnum.CreditCard;
            requestGold.paymentInstrumentID = owner.AddPaymentInstrumentVisa();
            requestGold.machinePuid = aadp._XboxPuid;

            LcBillingOffering lcBO = 
                new LcBillingOffering(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);
            uint hr = lcBO.PurchaseSubscription(requestGold);
            Global.RO.Info(String.Format("lcBO.PurchaseSubscription returned 0x{0:x}", hr));
            if (hr != HResult.S_OK)
                throw new UnexpectedTestResultException(string.Format("Purchase FamilyGold failed: {0}", hr.ToString("X")));
        }

        static void AssignFamilyGoldSeat(XeUser owner, XeUser dependent, LiveClientSettings lcsetting)
        {
            Global.RO.Info("Assigning GoldSeat to dependent {0}", dependent.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(dependent.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = lcsetting._clientPlatform;
            aadp._XboxPuid = lcsetting._machineID;

            LcAccountCreation lcAC =
                new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

            xonline.common.protocol.FamilySubscriptionAssignGoldUserRequest req =
                new xonline.common.protocol.FamilySubscriptionAssignGoldUserRequest();
            req.machinePuid = aadp._XboxPuid;
            req.ownerPuid = owner.UserPuid;
            req.userPuid = dependent.UserPuid;

            lcAC.FamilySubscriptionAssignGoldUser(req);
        }

        static void CountFamilyGoldSeat(XeUser owner, LiveClientSettings lcsetting, ExpectCountValue countValue)
        {
            Global.RO.Info("Count GoldSeat to user {0}", owner.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(owner.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = lcsetting._clientPlatform;
            aadp._XboxPuid = lcsetting._machineID;

            LcAccountCreation lcAC =
                new LcAccountCreation(lcsetting._livecacheClientType, lcsetting._titleID, aadp, false);

            xonline.common.protocol.FamilySubscriptionGoldUserCountRequest req =
                new xonline.common.protocol.FamilySubscriptionGoldUserCountRequest();
            req.userPuid = owner.UserPuid;

            FamilySubscriptionGoldUserCountResponse response = lcAC.FamilySubscriptionGoldUserCount(req);

            if ((response.total != countValue.total) ||
                (response.available != countValue.avail))
                throw new UnexpectedTestResultException("GoldSeat count verification failed with total and available number as: "
                    + response.total.ToString() + " " + response.available.ToString());
        }

        [TestCase, TestCasePriority(2)]
        class P_CountGoldSeatZune : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;
                // Create Zune Account
                XeUser owner = UacsCommon.CreateXenonUser(3);
                XeUser dependent = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = XOn.XPLT_ZUNEV2;
                lcsetting._livecacheClientType = LivecacheClientType.Zune;
                lcsetting._titleID = XOn.CRUX_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                ExpectCountValue countValue = new ExpectCountValue();
                countValue.total = 4;
                countValue.avail = 3;

                AddDependent(owner, dependent, lcsetting);
                PurchaseFamilyGold(owner, lcsetting);
                CountFamilyGoldSeat(owner, lcsetting, countValue);
                AssignFamilyGoldSeat(owner, dependent, lcsetting);
                countValue.avail = 2;
                CountFamilyGoldSeat(owner, lcsetting, countValue);

                UacsCommon.WaitForXCache();
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_CountGoldSeatXboxCom : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;
                // Create Xbox.com Account
                XeUser owner = UacsCommon.CreateXenonUser(3);
                XeUser dependent = UacsCommon.CreateXenonUser(3);

                LiveClientSettings lcsetting = new LiveClientSettings();
                lcsetting._clientPlatform = XOn.XPLT_WEB;
                lcsetting._livecacheClientType = LivecacheClientType.Xboxcom;
                lcsetting._titleID = XOn.XENON_DASH_TITLE_ID;
                lcsetting._machineID = UacsCommon.RandomXenonMachineUid();

                ExpectCountValue countValue = new ExpectCountValue();
                countValue.total = 4;
                countValue.avail = 3;

                AddDependent(owner, dependent, lcsetting);
                PurchaseFamilyGold(owner, lcsetting);
                CountFamilyGoldSeat(owner, lcsetting, countValue);
                AssignFamilyGoldSeat(owner, dependent, lcsetting);
                countValue.avail = 2;
                CountFamilyGoldSeat(owner, lcsetting, countValue);

                UacsCommon.WaitForXCache();
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\Leaderboard\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\Leaderboard\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\GamerTag\LcXeReserveGamertag.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheGamerTagTest
{
    /// <summary>
    ///     Functional tests for the XeGetUserWebInfo request.
    /// </summary>
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), EnvRequirement("Billing"), TestCasePriority(2)]
    public class XeReserveGamertag : TestNode
    {

    	/// <summary>
    	/// 	Call  ReserveGamertag with LiveEn
    	/// </summary>
        [TestCase,TestCasePriority(2)]
        class P_ReserveGamertag_WM7User_LIVEnClient : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                // Content Enumerate for  Free Gamertag
                xonline.common.protocol.ReserveNameRequest request = new xonline.common.protocol.ReserveNameRequest();
                request.countryId =103;
                request.machinePuid = UacsCommon.CreateWM7MachineUid();
                request.gamertag =ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(5, 10);
                
                Global.RO.Info("ReserveNameRequest");

                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, false);
                xonline.common.protocol.ReserveNameSuggestedName[] response = lcAC.ReserveGamerTag(request);

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\GamerTag\MainClass.cs ===
using System;
using System.Runtime.InteropServices;
using System.Xml;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

using xonline.common.webplatform.livecache;

[assembly: RootNode(typeof(LiveCacheGamerTagTest.LiveCacheGamerTag))]

namespace LiveCacheGamerTagTest
{
    public class LiveCacheGamerTag : TestNode
    {
        public class AccountAuthDataProvider :  IExtendedAuthDataProvider
        {
            public ulong LivePuid { get { return _LivePuid; } }
            public byte Tier{ get { return _Tier; } }
            public uint[] Privileges { get { return _Privileges; } }
            public IPEndPoint ClientIPEndPoint { get { return _ClientIPEndPoint; } }

            public ulong XboxPuid { get { return _XboxPuid; } }
            public byte ClientPlatform { get { return _ClientPlatform; } }

            public ulong _LivePuid;
            public byte _Tier;
            public uint[] _Privileges;
            public IPEndPoint _ClientIPEndPoint;

            public ulong _XboxPuid;
            public byte _ClientPlatform;
        }

        public static void DefaultLivecacheLocaleHandler(out uint language, out uint country)
        {
            language = 1;
            country = 103;
        }

        public static void setAADPPrivileges(LiveCacheGamerTag.AccountAuthDataProvider aadp)
        {
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
        }

    	public override void PreRun()
    	{
                // set the ReceiveTimeout and SendTimeout for TCP and UDP connection
                // make it 130 seconds since some calls to CSAT (or billing 1box) can take a long time
                FDTransaction.sReceiveTimeOut = 65000 * 2;            
                //Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(Interface.xuacs, "e :xuacs configcacherefresh");
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\livecache\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\GamerTag\LcGenerateGamertag.cs ===
using System;
using System.Collections;
using System.Data;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.user;

namespace LiveCacheGamerTagTest
{
    /// <summary>
    ///     Functional tests for the GenerateGamertag request.
    /// </summary>
    [TestGroup, Owner("kkline"), TestFrequency("Regression"), TestCasePriority(2)]
    public class GenerateGamertag : TestNode
    {
        //Note: The functionality of the API is primarily tested by XeUacs.dll.  LiveCache is just another entry point to the same XRL call, so these tests are rather minimal.

        [TestGroup, Description("Tests for GenerateGamertag for different suggestion types, currently all xbox.com calls.")]
        [CompoundCase("NounAdjective", (int)GamertagSuggestionType.NounAdjectiveSuggestion)]
        [CompoundCase("SeedSuggestion", (int)GamertagSuggestionType.SeedSuggestion)]
        [CompoundCase("ForcedNameChange", (int)GamertagSuggestionType.UniqueNounAdjectiveSuggestion)]
        public class SuggestionTypes: TestNode
        {
            [TestCase]
            public void NoSeed()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                int suggestionType=(int)MyValues[0];

                xonline.common.protocol.GenerateGamertagRequest request=new xonline.common.protocol.GenerateGamertagRequest();
                request.gamertagSuggestionType=suggestionType;
                request.seed="";
                request.countryId=103;
                request.machinePuid=UacsCommon.CreateXboxcomMachineUid();

                LcAccountCreation lcAC=new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.XENON_DASH_TITLE_ID, false);
                xonline.common.protocol.GenerateGamertagResponse response=lcAC.GenerateGamertag(request);

                Global.RO.Debug("Response Gamertag: {0}", response.gamertag);
                ValidateName(response.gamertag);
            }

            [TestCase]
            public void SeedProvided()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                int suggestionType=(int)MyValues[0];

                xonline.common.protocol.GenerateGamertagRequest request=new xonline.common.protocol.GenerateGamertagRequest();
                request.gamertagSuggestionType=suggestionType;
                request.seed="Dog";
                request.countryId=103;
                request.machinePuid=UacsCommon.CreateXboxcomMachineUid();

                LcAccountCreation lcAC=new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.XENON_DASH_TITLE_ID, false);
                xonline.common.protocol.GenerateGamertagResponse response=lcAC.GenerateGamertag(request);

                Global.RO.Debug("Response Gamertag: {0}", response.gamertag);
                ValidateName(response.gamertag);
            }

        }

        public static void ValidateName(string name)
        {
            if (name.Length==0 || name.Length>15)
            {
                throw new UnexpectedTestResultException("Gamertag length is invalid.");
            }

            if (!System.Char.IsLetter(name[0]))
            {
                throw new UnexpectedTestResultException("Gamertag must start with a letter.");
            }
        }

        /// <summary>
        ///     Call  ReserveGamertag with Xboxcom, noun adjective type
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_NounAdjective_GenerateGamertag_WM7User_XboxcomClient : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                // Content Enumerate for  Free Gamertag
                xonline.common.protocol.GenerateGamertagRequest request = new xonline.common.protocol.GenerateGamertagRequest();
                request.countryId = 103;
                request.machinePuid = UacsCommon.CreateXboxcomMachineUid();
                request.gamertagSuggestionType = 0;

                Global.RO.Info("GenerateGamertagRequest, NounAdjective request type");

                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.XENON_DASH_TITLE_ID, false);
                xonline.common.protocol.GenerateGamertagResponse response = lcAC.GenerateGamertag(request);

                Global.RO.Info("Gamertag: {0}", response.gamertag);

                if (0 < response.gamertagLength)
                    this.ResultCode = TEST_RESULTS.PASSED;
                else
                    throw new UnexpectedTestResultException("GamertagLength invalid: " + response.gamertagLength);
            }
        }

        /// <summary>
        ///     Call  ReserveGamertag with Xboxcom, SeedSuggestion type
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_SeedSuggestion_GenerateGamertag_WM7User_XboxcomClient : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                Random random = new Random((int)DateTime.Now.Ticks);           
                int seedLength = random.Next(1,15);                
                StringBuilder builder = new StringBuilder();
                char ch;

                for (int i = 0; i < seedLength; i++)
                {
                    ch = Convert.ToChar(Convert.ToInt32(Math.Floor(26 * random.NextDouble() + 65)));
                    builder.Append(ch);
                }

                
                // Content Enumerate for  Free Gamertag
                xonline.common.protocol.GenerateGamertagRequest request = new xonline.common.protocol.GenerateGamertagRequest();
                request.countryId = 103;
                request.machinePuid = UacsCommon.CreateXboxcomMachineUid();
                request.gamertagSuggestionType = 1;
                request.seedLength = (ushort)seedLength;                                
                Global.RO.Info("seedLength = {0}; seed = {1}",seedLength,builder.ToString());
                request.seed = builder.ToString();

                Global.RO.Info("GenerateGamertagRequest, NoneAdjective request type");

                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.XENON_DASH_TITLE_ID, false);
                xonline.common.protocol.GenerateGamertagResponse response = lcAC.GenerateGamertag(request);

                Global.RO.Info("Gamertag: {0}", response.gamertag);

                if (0 < response.gamertagLength)
                    this.ResultCode = TEST_RESULTS.PASSED;
                else
                    throw new UnexpectedTestResultException("GamertagLength invalid: " + response.gamertagLength);
            }
        }

        /// <summary>
        ///     Call  ReserveGamertag with Xboxcom
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_DifferentTitleID_GenerateGamertag_WM7User_XboxcomClient : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                // Content Enumerate for  Free Gamertag
                xonline.common.protocol.GenerateGamertagRequest request = new xonline.common.protocol.GenerateGamertagRequest();
                request.countryId = 103;
                request.machinePuid = UacsCommon.CreateXboxcomMachineUid();
                request.gamertagSuggestionType = 2;

                Global.RO.Info("GenerateGamertagRequest");

                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, 0xFFFE07D2, false);
                xonline.common.protocol.GenerateGamertagResponse response = lcAC.GenerateGamertag(request);

                Global.RO.Info("Gamertag: {0}", response.gamertag);

                if (0 < response.gamertagLength)
                    this.ResultCode = TEST_RESULTS.PASSED;
                else
                    throw new UnexpectedTestResultException("GamertagLength invalid: " + response.gamertagLength);
            }
        }

        /****************************************************************
         * Negative Tests
         * **************************************************************/
        /// <summary>
        ///     Call  ReserveGamertag with Xboxcom
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class N_Invalid_GenerateGamertagRequestType_WM7User_XboxcomClient : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                // Content Enumerate for  Free Gamertag
                xonline.common.protocol.GenerateGamertagRequest request = new xonline.common.protocol.GenerateGamertagRequest();
                request.countryId = 103;
                request.machinePuid = UacsCommon.CreateXboxcomMachineUid();
                request.gamertagSuggestionType = 4;

                Global.RO.Info("GenerateGamertagRequest");
                              
                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.XENON_DASH_TITLE_ID, false);
                xonline.common.protocol.GenerateGamertagResponse response;
                
                try
                {
                    response = lcAC.GenerateGamertag(request);
                    if (null != response)
                        throw new UnexpectedTestResultException("livecache returned a response when it should have failed");
                }
                catch (xonline.common.webplatform.livecache.LivecacheResponseException e)
                {
                    string error = e.Message;
                    Global.RO.Info("exception: " + e.Message);
                    this.ResultCode = TEST_RESULTS.PASSED;
                }               
            }
        }

        /// <summary>
        ///     Call  ReserveGamertag with Xboxcom
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class N_InvalidClient_GenerateGamertag_WM7User_ZuneClient : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                // Content Enumerate for  Free Gamertag
                xonline.common.protocol.GenerateGamertagRequest request = new xonline.common.protocol.GenerateGamertagRequest();
                request.countryId = 103;
                request.machinePuid = UacsCommon.CreateXboxcomMachineUid();
                request.gamertagSuggestionType = 2;

                Global.RO.Info("GenerateGamertagRequest");
                
                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Zune, XOn.XENON_DASH_TITLE_ID, false);
                xonline.common.protocol.GenerateGamertagResponse response; 
                    
                try
                {
                    response = lcAC.GenerateGamertag(request);
                }
                catch (xonline.common.webplatform.livecache.LivecacheConfigException e)
                {
                    string error = e.Message;                    
                    if (error.Contains("Request made for unknown Livecache API GenerateGamertag"))
                    {
                        Global.RO.Info("exception: " + e.Message);
                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
                }

                   

            }
        }       


       /*

        /// <summary>
        ///    Title ID checks
        /// </summary>
        /// 
        /****************************************************************
         * list of title id's
         * 
         * 
         * public const uint WEB_TITLE_ID               = 0xFFED0000;
         * public const uint DASH_TITLE_ID              = 0xFFFE0000;
         * public const uint XENON_DASH_TITLE_ID        = 0xFFFE07D1;
         * public const uint XENON_LIVE_SIGNUP_TITLE_ID = 0xFFFE07DE;
         * public const uint FUSION_TITLE_ID            = 0xFFFE07D2;
         * public const uint XENON_LAUNCHER_TITLE_ID    = 0xFFFE07FF;
         * public const uint TITLE_FAMILY_MASK          = 0xffff0000;
         * public const uint XARCADE_TITLE_FAMILY       = 0x58410000;
         * public const uint X_CUSTOM_PICTURE_TITLEID   = 0xFFFE0700;
         * public const uint X_AVATAR_PICTURE_TITLEID   = 0xFFFE0854;
         * public const uint PC_DASH_TITLE_ID           = 0x585207d1;
         * **************************************************************/

        /*
        /// <summary>
        ///    client type checks
        /// </summary>
        /// 
        /****************************************************************
         * list of client types
         * 
         * 
         * public const int LcClientType_XboxCom  = 0;
         * public const int LcClientType_Zune     = 1;
         * public const int LcClientType_XNA      = 2;
         * public const int LcClientType_WGX      = 3;
         * public const int LcClientType_LIVEn    = 4;
         * **************************************************************/      


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\livecache\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\livecache\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\Presence\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\livecache\LiveCacheUtils.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.Collections.Generic;
using System.Text;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

using xonline.common.utilities;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using ServerTestFramework.Database;

using xonline.common.webplatform.livecache;

namespace LiveCache
{
    public enum FakeFDRequestType
    {
        HTTP,
        SOAP11,
        SOAP12,
    }

    public enum SyncSettingsRequestType
    {
        InvalidateCache,
        PrepUser
    }

    public class LiveCacheStressConst
    {
        static public int TitleStart = 11000;
        static public int TitleCount = 1000;
        static public int numPlayedTitles = 10;
        static public int max_settingstoSync = 10;
        static public int max_settings = 120;
    }

    public class RedSetReq
    {
        public uint title;
        public ulong user;
        public ulong[] forUsers;
        public uint[] sifds;
    }


    public static class LiveCacheStressSupport
    {
        public static LivecacheClientType clientType;
        public static int currentClientNumberForThisClientType = 0;
        
        public static RandomEx rand = new RandomEx();
            
        public static bool bCountersAvailable = true;
        private static PerformanceCounter pcTimeExpiring;
        private static PerformanceCounter pcTimeExpiringBase;

        public static xonline.common.webplatform.livecache.LcStats lcStats;
        public static Hashtable htSizeSpecificFakeFDStatsQueues = new Hashtable();
        public static Hashtable htSizeSpecificFakeFDUserAcctQueues = new Hashtable();
        public static Hashtable htSizeSpecificFakeFDFriendsQueues = new Hashtable();
        public static int[] responseSizes = { 500, 1000, 1500, 2000, 3000, 4000, 6000, 10000, 50000, 200000 };
        public static int[] settingsSizes = { 166, 333, 500, 666, 833, 1000 };
        public static Hashtable htResponseSizeToSettingsSizeMap = new Hashtable();
        public static bool AllUsersPrepared = false;

        public static void Init( )
        {
            if (SetupCategory())
            {
                bCountersAvailable = false;
                Global.RO.Fatal("Created Counter Category, exit and relaunch to use Counters!!");
            }
            else
            {
                CreateCounters();
            }
            LivecacheClientType type = clientType;
            int clientID = currentClientNumberForThisClientType;

            int cacheDurationFakeFDStats = 0;
            int cacheDurationFakeFDUserAcct = 0;
            int cacheDurationFakeFDFriends = 0;

            //TODO: pull these values from the database instead of setting them here and pushing them into the database
            switch (type)
            {
                case LivecacheClientType.Xboxcom:
                    cacheDurationFakeFDStats = 400;
                    cacheDurationFakeFDUserAcct = 400;
                    cacheDurationFakeFDFriends = 7200;
                    break;
                case LivecacheClientType.Zune:
                    cacheDurationFakeFDStats = 400;
                    cacheDurationFakeFDUserAcct = 400;
                    cacheDurationFakeFDFriends = 7200;
                    break;
                case LivecacheClientType.XNA:
                    cacheDurationFakeFDStats = 400;
                    cacheDurationFakeFDUserAcct = 400;
                    cacheDurationFakeFDFriends = 7200;
                    break;
                case LivecacheClientType.WGX:
                    cacheDurationFakeFDStats = 400;
                    cacheDurationFakeFDUserAcct = 400;
                    cacheDurationFakeFDFriends = 7200;
                    break;
            }

            // determine the base offset in user IDs per client
            uint totalUserSetSize = 0;
            foreach (int size in responseSizes)
            {
                BulkUserSet userSet = STFLiveGlobal.GetUserSet(GetTagNameForTargetResponseSize(type, clientID, size));
                totalUserSetSize += userSet.Count;
            }
            totalUserSetSize *= (uint)clientID;

            // create the user queues we'll use for actual running of tests (based on the same bulk user tags as as the setup queues)
            foreach (int size in responseSizes)
            {
                htSizeSpecificFakeFDStatsQueues.Add(size, new SimpleUserQueue(GetTagNameForTargetResponseSize(type, clientID, size), cacheDurationFakeFDStats, totalUserSetSize));
                htSizeSpecificFakeFDUserAcctQueues.Add(size, new SimpleUserQueue(GetTagNameForTargetResponseSize(type, clientID, size), cacheDurationFakeFDUserAcct, totalUserSetSize));
                htSizeSpecificFakeFDFriendsQueues.Add(size, new SimpleUserQueue(GetTagNameForTargetResponseSize(type, clientID, size), cacheDurationFakeFDFriends, totalUserSetSize));
            }

            lcStats = new LcStats(LiveCacheStressSupport.clientType, 11001);
        }

        public static void PickClientType()
        {
            //default here
            clientType = LivecacheClientType.Xboxcom;

            // then try to find the type based on the file found in the \suites\ folder
            for (int i = 0; i < 4; i++)
            {
                string targetClientMappingFile = System.IO.Path.Combine(Environment.CurrentDirectory, String.Format("suites\\clientType{0}.txt", i));

                if (System.IO.File.Exists(targetClientMappingFile))
                {
                    clientType = (LivecacheClientType)(byte)(i);
                    Global.RO.Debug("Taking clientType: {0}", clientType);
                    return;
                }
            }
            Global.RO.Debug("Defaulting to clientType: LivecacheClientType.Xboxcom");
        }

        public static void PickClientTypeID()
        {
            // try to check a network location for the mapping data, but if you can't do that, use the local file instead
            string targetClientMappingFile = String.Format(@"\\RRINFXWTTSQL101\RunFileShare\LiveCache\clientType{0}.txt", (int)clientType);
            string targetClientMappingMutexFile = targetClientMappingFile + ".mutex";

            if (!System.IO.File.Exists(targetClientMappingFile))
            {
                try
                {
                    System.IO.StreamWriter sw = System.IO.File.CreateText(targetClientMappingFile);
                    sw.Close();
                }
                catch (Exception e)
                {
                    Global.RO.Error("Failed to create file: {0}, using local map instead", targetClientMappingFile);
                    Global.RO.Error(e.ToString());
                    targetClientMappingFile = System.IO.Path.Combine(Environment.CurrentDirectory, String.Format("suites\\clientType{0}.txt", (int)clientType));
                    targetClientMappingMutexFile = targetClientMappingFile + ".mutex";
                }
            }
            if (System.IO.File.Exists(targetClientMappingFile))
            {
                bool bAlreadyInTheList = false;

                System.Collections.Hashtable assignedIDs = new Hashtable();
                LiveCacheStressSupport.currentClientNumberForThisClientType = 0;
                FileStream stream = null;
                while (stream == null)
                {
                    try
                    {
                        stream = File.Open(targetClientMappingMutexFile, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None);
                    }
                    catch (Exception e)
                    {
                        Global.RO.Debug("Failed to open mutex file {0} for exclusive reading... waiting to try again:\n{1}", targetClientMappingMutexFile, e.ToString());
                    }
                }

                System.IO.TextReader tr = System.IO.File.OpenText(targetClientMappingFile);

                // get the list of client IDs for this clientType
                string sClientIDMapping = tr.ReadToEnd();
                tr.Close(); 

                if (!string.IsNullOrEmpty(sClientIDMapping))
                {
                    // parse that list so that we know who is using what
                    string[] sClients = sClientIDMapping.Split(new char[] { ',' });
                    foreach (string client in sClients)
                    {
                        try
                        {
                            string[] parts = client.Split(new char[] { ':' });
                            {
                                assignedIDs.Add(System.Int32.Parse(parts[1]), parts[0].ToLower());
                                assignedIDs.Add(parts[0].ToLower(), System.Int32.Parse(parts[1]));
                            }
                        }
                        catch (Exception e)
                        {
                            Global.RO.Error("failed to parse clientType ID data from string: {0}", client);
                            Global.RO.Error(e.ToString());
                        }
                    }
                }
                if (assignedIDs.ContainsKey(Environment.MachineName.ToLower()))
                {
                    bAlreadyInTheList = true;
                    LiveCacheStressSupport.currentClientNumberForThisClientType = (int)assignedIDs[Environment.MachineName.ToLower()];
                }
                else
                {
                    for (int candidateID = 0; candidateID < 32; candidateID++)
                    {
                        if (!assignedIDs.ContainsKey(candidateID))
                        {
                            LiveCacheStressSupport.currentClientNumberForThisClientType = candidateID;
                            break;
                        }
                    }
                }

                // add ourselves to the list and update that list if necessary
                if (!bAlreadyInTheList)
                {
                    if (!string.IsNullOrEmpty(sClientIDMapping))
                    {
                        sClientIDMapping += ",";
                    }
                    sClientIDMapping += string.Format("{0}:{1}", Environment.MachineName.ToLower(), LiveCacheStressSupport.currentClientNumberForThisClientType);

                    System.IO.File.Delete(targetClientMappingFile);
                    System.IO.TextWriter tw = System.IO.File.CreateText(targetClientMappingFile);
                    tw.WriteLine(sClientIDMapping);
                    tw.Close();
                }
                stream.Close();
            }
            Global.RO.Debug("Taking client number: {0} for clientType {1}", LiveCacheStressSupport.currentClientNumberForThisClientType, clientType);
            return;
        }

        public static string GetTagNameForTargetResponseSize(LivecacheClientType type, int clientID, int targetResponseSize)
        {
            //return string.Format("{0}_{1}_{2}", type.ToString(), clientID, (int)htResponseSizeToSettingsSizeMap[targetResponseSize]).ToLower();
            return string.Format("{0}_{1}_{2}", "fakeFD", "base", targetResponseSize).ToLower();
        }

        public static string GetTagNameForTargetSettingsSize(LivecacheClientType type, int clientID, int targetSettingsSize)
        {
            return string.Format("{0}_{1}_{2}", type.ToString(), clientID, targetSettingsSize).ToLower();
        }

        public class SimpleUserQueue
        {
            public class User
            {
                public ulong puid;
                public DateTime Expires;
                public DateTime ActivationWindowStart;
                public DateTime ActivationWindowEnd;

                public User() {}
                
                public User(ulong id)
                {
                    puid = id;
                }
            }

            public System.Threading.Timer cautiousUserActivationTimer;
            public RandomEx rand = new RandomEx();
            public ulong UMask = 0;//0x900000151c9a6;  //old default value if not set
            public ulong TotalUsers = 0;
            public Object windowLock = new Object();
            public ulong currentActiveUserIndex = 0; //start at 0 and go to TotalUsers
            public int activeSecondsPerUser = 0; // this is the minimum value in t_livecache_apis
            public ulong usersBeingActivated = 0;
            // users who are known to have their responses in the cache
            public List<User> ActivatedUsers = new System.Collections.Generic.List<User>();
            // users who are known to NOT have their responses in the cache
            public List<User> UnactivatedUsers = new System.Collections.Generic.List<User>();
            public List<User> UnsafeUsers = new System.Collections.Generic.List<User>();
            public List<User> AlmostExpiredUsers = new System.Collections.Generic.List<User>();
            public DateTime lastWindowParsingTime = DateTime.UtcNow.AddDays(-1);
            
            public SimpleUserQueue(string name, int cacheDuration, uint offset)
            {
                BulkUserSet userSet = STFLiveGlobal.GetUserSet(name);
                TotalUsers = (ulong)userSet.Count;
                UMask = userSet.Base + offset;
                activeSecondsPerUser = cacheDuration;
            }

            public void ActivateUser(User u)
            {
                lock (windowLock)
                {
                    u.Expires = DateTime.Now.AddSeconds(activeSecondsPerUser);
                    ActivatedUsers.Add(u); 
                    usersBeingActivated--;
                    currentActiveUserIndex++;
                }

            }

            public void DeactivateUser(User u)
            {
                lock (windowLock)
                {
                    if (ActivatedUsers.Contains(u))
                    {
                        ActivatedUsers.Remove(u);
                    }
                    UnactivatedUsers.Add(u);
                }
            }

            public void MarkUserUnsafe(User u)
            {
                lock (windowLock)
                {
                    if (ActivatedUsers.Contains(u))
                    {
                        ActivatedUsers.Remove(u);
                    }
                    u.Expires = DateTime.Now.AddSeconds(activeSecondsPerUser);
                    UnsafeUsers.Add(u);
                }
            }

            // this may be slow, but it's the only way that ONE test can properly track the invalidations for both types of users
            // for example this is necessary to let syncsettings invalidate both readsettings and publicreadsettings, but still have the
            // users for each of those tests come from a different queue
            public void DeactivateUser(ulong userId)
            {
                User usr = new User(userId);
                lock (windowLock)
                {
                    foreach(User u in ActivatedUsers)
                    {
                        if (u.puid == usr.puid)
                        {
                            ActivatedUsers.Remove(u);
                            break;
                        }
                    }

                    UnactivatedUsers.Add(usr);
                }
            }

            public bool EndOfQueueReached()
            {
                return (currentActiveUserIndex + usersBeingActivated) >= TotalUsers;
            }

            public ulong GetNextUserIdToActivate()
            {
                ulong userID;

                lock (windowLock)
                {
                    // if we've reached max users, pull from the unactivated users queue again
                    if ((currentActiveUserIndex + usersBeingActivated) < TotalUsers)
                    {
                        userID = UMask + currentActiveUserIndex + usersBeingActivated;
                        usersBeingActivated++;
                    }
                    else
                    {
                        if (UnactivatedUsers.Count > 0)
                        {
                            userID = UnactivatedUsers[0].puid;
                            UnactivatedUsers.RemoveAt(0);
                        }
                        else
                        {
                            // if the unactivated queue is empty, then check for expired activated users
                            HandleExpiredUsers();

                            if (UnactivatedUsers.Count > 0)
                            {
                                userID = UnactivatedUsers[0].puid;
                                UnactivatedUsers.RemoveAt(0);
                            }
                            else
                            {
                                throw new Exception("Ran out of users to miss the cache with");
                            }
                        }

                    }
                }
                return userID;
            }

            /// <summary>
            /// gets a valid userID for this queue, but does NOT prepare the user for activation
            /// </summary>
            /// <returns></returns>
            public ulong[] GetContiguousUserSet(ulong startingUser, int numUsersNeeded)
            {
                ulong[] userIDs = new ulong[numUsersNeeded];
                int selectionMode = 0;

                switch (selectionMode)
                {
                    case 0:
                        // simple response that just returns the same user x times
                        for (int i = 0; i < numUsersNeeded; i++)
                        {
                            userIDs[i] = startingUser;
                        }
                        break;
                    case 1:
                        // return a set of unique deterministic users
                        int numTakenFromEnd = 0;
                        for (int i = 0; i < numUsersNeeded; i++)
                        {
                            if ((startingUser + (ulong)i) < (UMask + TotalUsers))
                            {

                                userIDs[i] = startingUser + (ulong)i;
                                numTakenFromEnd++;
                            }
                            else
                            {
                                userIDs[i] = UMask + (ulong)i - (ulong)numTakenFromEnd;
                            }
                        }
                        break;
                }
                return userIDs;
            }

            public ulong GetRandomActivatedUserID()
            {
                while (ActivatedUsers.Count == 0)
                {
                    System.Threading.Thread.Sleep(1000 * 1); // wait for someone to activate a user
                }

                int index = 0;
                User u = new User();
                u.puid = 0;

                lock (windowLock)
                {
                    // check the front of the list for expiration
                    HandleExpiredUsers();
                    index = rand.Next(0, ActivatedUsers.Count);
                    u = ActivatedUsers[index];
                }
                return u.puid;
            }

            public User GetRandomUserToInvalidate(LiveCacheStressSupport.SimpleUserQueue otherQueueToRemoveUserFrom)
            {
                while (ActivatedUsers.Count == 0)
                {
                    System.Threading.Thread.Sleep(1000 * 2); // wait for someone to activate a user
                }

                int index = 0;
                User u = new User();
                u.puid = 0;

                lock (windowLock)
                {
                    // check the front of the list for expiration
                    HandleExpiredUsers();
                    index = rand.Next(0, ActivatedUsers.Count);
                    u = ActivatedUsers[index];
                    ActivatedUsers.Remove(u);
                    //todo: move the shifting to the unactivated queue out of here, to after the cache invalidation.
                    UnactivatedUsers.Add(u);
                    if (null != otherQueueToRemoveUserFrom)
                    {
                        otherQueueToRemoveUserFrom.DeactivateUser(u.puid);
                    }
                }
                return u;
            }

            private void HandleExpiredUsers()
            {
                DateTime start = DateTime.UtcNow;
                // prepare to expire users up to 1 second before they would actually expire
                while (ActivatedUsers.Count > 0 && ActivatedUsers[0].Expires < System.DateTime.Now.AddSeconds(1))
                {
                    AlmostExpiredUsers.Add(ActivatedUsers[0]);
                    ActivatedUsers.RemoveAt(0);
                }

                // prepare to expire users up to 1 second before they would actually expire
                while (UnsafeUsers.Count > 0 && UnsafeUsers[0].Expires < System.DateTime.Now.AddSeconds(1))
                {
                    AlmostExpiredUsers.Add(UnsafeUsers[0]);
                    UnsafeUsers.RemoveAt(0);
                }

                // but don't actually put them in the cache miss queue until we knew they'll be gone from the cache
                while (AlmostExpiredUsers.Count > 0 && AlmostExpiredUsers[0].Expires < System.DateTime.Now)
                {
                    UnactivatedUsers.Add(AlmostExpiredUsers[0]);
                    AlmostExpiredUsers.RemoveAt(0);
                }
                TimeSpan timeSpent = DateTime.UtcNow.Subtract(start);
                if (bCountersAvailable)
                {
                    pcTimeExpiring.IncrementBy((long)timeSpent.TotalMilliseconds);
                    pcTimeExpiringBase.Increment();
                }
            }

            public User GetRandomActivatedUser()
            {
                while (ActivatedUsers.Count == 0)
                {
                    System.Threading.Thread.Sleep(1000 * 2); // wait for someone to activate a user
                }

                int index = 0;
                User u = new User();
                u.puid = 0;

                lock (windowLock)
                {
                    // check the front of the list for expiration
                    while (ActivatedUsers[0].Expires < System.DateTime.Now.AddSeconds(1))
                    {
                        //todo: see if this can be switched over to using DeactivateUser safely with the double locking
                        UnactivatedUsers.Add(ActivatedUsers[0]);
                        ActivatedUsers.RemoveAt(0);
                    }
                    index = rand.Next(0, ActivatedUsers.Count);
                    u = ActivatedUsers[index];
                }
                return u;
            }
        }

        private static bool SetupCategory()
        {
            if (!PerformanceCounterCategory.Exists("LiveCache Stress Tests"))
            {

                CounterCreationDataCollection CCDC = new CounterCreationDataCollection();

                // Add the counter.
                CounterCreationData averageCount64 = new CounterCreationData();
                averageCount64.CounterType = PerformanceCounterType.AverageCount64;
                averageCount64.CounterName = "Time Expiring Users";
                CCDC.Add(averageCount64);

                // Add the base counter.
                CounterCreationData averageCount64Base = new CounterCreationData();
                averageCount64Base.CounterType = PerformanceCounterType.AverageBase;
                averageCount64Base.CounterName = "Time Expiring Users Base";
                CCDC.Add(averageCount64Base);

                // Create the category.
                PerformanceCounterCategory.Create("LiveCache Stress Tests",
                    "Counters for evaluating the performance of the LiveCache stress tests.",
                    PerformanceCounterCategoryType.SingleInstance, CCDC);

                return (true);
            }
            else
            {
                Console.WriteLine("Performance Counter Category exists - LiveCache Stress Tests");
                return (false);
            }
        }

        private static void CreateCounters()
        {
            // Create the counters.

            pcTimeExpiring = new PerformanceCounter("LiveCache Stress Tests",
                "Time Expiring Users",
                false);


            pcTimeExpiringBase = new PerformanceCounter("LiveCache Stress Tests",
                "Time Expiring Users Base",
                false);


            pcTimeExpiring.RawValue = 0;
            pcTimeExpiringBase.RawValue = 0;
        }


    }

    public class LiveCacheUtils
    {
        public class MyContextItemProvider : IContextItemProvider
        {
            public object this[string name]
            {
                get
                {
                    return _hash[name];
                }
                set
                {
                    _hash[name] = value;
                }
            }
            private Hashtable _hash = new Hashtable();
        }

        public struct t_livecache_api_row
        {
            public String[] fields;
            public bool exists;
        }

        public static t_livecache_api_row Read_t_livecache_api_row(int _serviceId)
        {
            string rowString = "";
            //
            // Setup the connection to NPDB and execute the command
            //
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            System.Data.SqlClient.SqlDataReader reader;

            string sql = String.Format("SELECT * from t_livecache_apis WHERE i_lcservice_id = {0}", _serviceId);

            t_livecache_api_row row = new t_livecache_api_row();
            row.fields = new String[10];
            row.exists = false;

            npdb.ReadData(sql, out reader);
            while (reader.Read())
            {
                row.exists = true;
                for (int i = 0; i < reader.VisibleFieldCount; i++)
                {
                    rowString += String.Format("{0}|", ((string)reader[i].ToString()));
                    row.fields[i] = reader[i].ToString();
                }
                Global.RO.Fatal(rowString);

            }
            reader.Close();
            return row;
        }

        public static void Restore_t_livecache_api_row(t_livecache_api_row _row)
        {
            //
            // Setup the connection to NPDB and execute the command
            //
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            string sql = String.Format("UPDATE t_livecache_apis ");
            sql += String.Format("SET i_lcservice_id = {0} ", _row.fields[0]);
            sql += String.Format(",vc_virtual_interface = '{0}' ", _row.fields[1]);
            sql += String.Format(",vc_xrl = '{0}' ", _row.fields[2]);
            sql += String.Format(",vc_name = '{0}' ", _row.fields[3]);
            sql += String.Format(",i_duration = {0} ", _row.fields[4]);
            sql += String.Format(",i_max_reqs_per_sec = {0} ", _row.fields[5]);
            sql += String.Format(",b_culture_sensitive = '{0}' ", _row.fields[6]);
            sql += String.Format(",b_allow_anonymous_access = '{0}' ", _row.fields[7]);
            sql += String.Format(",tn_required_dependency = {0} ", _row.fields[8]);
            sql += String.Format(",tn_required_invalidation = {0} ", _row.fields[9]);
            sql += String.Format("WHERE i_lcservice_id = {0}", _row.fields[0]);

            Global.RO.Fatal("Setting row");
            Global.RO.Fatal(sql);
            npdb.ExecuteScalar(sql);

            Global.XEnv.ExecuteXmgmtCommand("livecache", "e :livecache ConfigFlush", 10);
        }

        public static string BuildRequestBody(int size, FakeFDRequestType type)
        {
            /*
                POST /SampleWebService.asmx HTTP/1.1
                Host: localhost
                Content-Type: text/xml; charset=utf-8
                Content-Length: length
                SOAPAction: "http://www.microsoft.com/GetData"
             */
            switch (type)
            {
                case FakeFDRequestType.SOAP12:
                    {
                        return string.Format(@"
<?xml version=" + "\"1.0\" encoding=\"utf-8\"?>" + @"
<soap:Envelope xmlns:xsi=" + "\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">" + @"
  <soap:Body>
    <GetData xmlns=" + "\"http://www.microsoft.com\">" + @"
      <responseSizeInBytes>{0}</responseSizeInBytes>
    </GetData>
  </soap:Body>
</soap:Envelope>", size);
                    }
                case FakeFDRequestType.HTTP:
                    return string.Format("responseSizeInBytes={0}", size);
            }
            throw new System.ArgumentException("Unknown FakeFDRequestType");
        }


        public static byte[] ConvertBodyToBytes(string requestBody)
        {
            System.Text.ASCIIEncoding enc = new ASCIIEncoding();
            return enc.GetBytes(requestBody);
        }

        public static void SetupLiveCacheTestAPIs()
        {
            ServerTestFramework.Database.Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            bool bChangeRequired = false;

            // the interfaces hardcoded below mean that these tests are always designed to run with an emulator on the stats machine
            // changing the interface in the db will work to re-direct that traffic, as these calls will not stomp existing data in the db
            // but to make it more dynamic from the very beginning both this code and the port in the emulator batch file need to pull the value from some central location
            // that would be nice because rebuilding the dll just to change where the emulator is running isn't a great thing to have do, but I'm not doing it now
            // an even better idea would be to maybe run the emulator on the test client, and insert a fake VIP for that emulator
            bChangeRequired = bChangeRequired | EnableTestAPI(LcserviceId.TestAPI, "testfd", "/SampleWebService.asmx/GetData", "TestAPI", 0, 3200, 0, 0);
            bChangeRequired = bChangeRequired | EnableTestAPI(LcserviceId.TestAPIWithStatsDependency, "testfd", "/SampleWebService.asmx/GetData", "TestAPIWithStatsDependency", 400, 3200, LiveCacheDependencyBitFlags.Stats, 0);
            bChangeRequired = bChangeRequired | EnableTestAPI(LcserviceId.TestAPIWithStatsInvalidation, "testfd", "/SampleWebService.asmx/GetData", "TestAPIWithStatsInvalidation", 400, 3200, 0, LiveCacheDependencyBitFlags.Stats);
            bChangeRequired = bChangeRequired | EnableTestAPI(LcserviceId.TestAPIWithUserAccountDependency, "testfd", "/SampleWebService.asmx/GetData", "TestAPIWithUserAcctDependency", 400, 3200, LiveCacheDependencyBitFlags.UserAccount, 0);
            bChangeRequired = bChangeRequired | EnableTestAPI(LcserviceId.TestAPIWithUserAccountInvalidation, "testfd", "/SampleWebService.asmx/GetData", "TestAPIWithUserAcctInvalidation", 400, 3200, 0, LiveCacheDependencyBitFlags.UserAccount);
            bChangeRequired = bChangeRequired | EnableTestAPI(LcserviceId.TestAPIWithFriendsDependency, "testfd", "/SampleWebService.asmx/GetData", "TestAPIWithFriendsDependency", 7200, 3200, LiveCacheDependencyBitFlags.Friends, 0);
            bChangeRequired = bChangeRequired | EnableTestAPI(LcserviceId.TestAPIWithFriendsInvalidation, "testfd", "/SampleWebService.asmx/GetData", "TestAPIWithFriendsInvalidation", 7200, 3200, 0, LiveCacheDependencyBitFlags.Friends);

            if (bChangeRequired)
            {
                Global.XEnv.ExecuteXmgmtCommand("livecache", "e :livecache ConfigFlush", 10);
            }
        }

        public static bool EnableTestAPI(LcserviceId serviceID, string interfaceName, string xrl, string name, int duration, int throttle, LiveCacheDependencyBitFlags dependency, LiveCacheDependencyBitFlags invalidates)
        {
            ServerTestFramework.Database.Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            
            bool bChangeRequired = false;
            t_livecache_api_row TestAPI = Read_t_livecache_api_row((int)serviceID);
            if (!TestAPI.exists) // todo: make this validate that all settings match instead of just checking for existence of the service id
            {
                bChangeRequired = true;
                string command = @"INSERT INTO [npdb].[dbo].[t_livecache_apis]
           ([i_lcservice_id]
           ,[vc_virtual_interface]
           ,[vc_xrl]
           ,[vc_name]
           ,[i_duration]
           ,[i_max_reqs_per_sec]
           ,[b_culture_sensitive]
           ,[b_allow_anonymous_access]
           ,[tn_required_dependency]
           ,[tn_required_invalidation])
     VALUES
           (" + (int)serviceID + @"
           ,'" + interfaceName + @"'
           ,'" + xrl + @"'
           ,'" + name + @"'
           ," + duration + @"
           ," + throttle + @"
           ,0
           ,1
           ," + (int)dependency + @"
           ," + (int)invalidates + @")";
                Global.RO.Debug(command);
                npdb.IssueCommand(command);
            }
            

            return bChangeRequired;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\Presence\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\livecache\LiveCache.cs ===

using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;

using System.Net;


using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Billing.WebBilling;
using ServerTestFramework.LiveService.Billing;
using xonline.common.config;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

[assembly: RootNode(typeof(LiveCache.Stress.LiveCacheStressAPIs))]

namespace LiveCache.Stress
{
    /// <summary>
    /// Internal class used to set Livecache privileges for access. The LiveCache client DLL only exposes the interface, and partner teams are expected 
    /// to implement the interface themselves to call any APIs that require authentication. This is an implementation for the test code that was created
    /// by copying the private implementation out of the client code.
    /// </summary>
    class AuthSettings : IExtendedAuthDataProvider
    {
        private ulong _livePuid;
        private byte _tier;
        private uint[] _privileges;
        private byte clientType;
        public ulong XboxPuid { get { return 0; } }
        public byte ClientPlatform { get { return clientType; } set { clientType = value; } }

        public AuthSettings()
        {
            _livePuid = LivecacheRequest.PublicRequestLivePuid;
            _tier = 0;

            // hard code privileges to baseline level
            _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
            AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
        }

        public AuthSettings(ulong puid, LivecacheClientType clientType)
        {
            _livePuid = puid;
            _tier = 0;

            // hard code privileges to baseline level
            _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
            AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
            ClientPlatform = (byte)clientType;
        }

        public AuthSettings(LivecacheClientType clientType)
        {
            _livePuid = LivecacheRequest.PublicRequestLivePuid;
            _tier = 0;

            // hard code privileges to baseline level
            _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
            AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            AddPrivilege(XOn.XPRIVILEGE_PROFILE_VIEWING);
            ClientPlatform = (byte)clientType;
        }

        private void AddPrivilege(int privilegeId)
        {
            uint mask = (uint)1 << (privilegeId % 32);
            _privileges[privilegeId / 32] |= mask;
        }

        public ulong LivePuid
        {
            get { return _livePuid; }
        }

        public byte Tier
        {
            get { return _tier; }
        }

        public uint[] Privileges
        {
            get { return _privileges; }
        }

        public IPEndPoint ClientIPEndPoint
        {
            get { return new IPEndPoint(0, 0); }
        }
    }

    /// <summary>
    /// Similar to the IExtendedAuthDataProvider interface and the above implementation, the IAccountAuthDataProvider interface gets 
    /// implemented by partner teams for calling into any APIs that require some level of authentication.
    /// </summary>
    class AuthPublicSettings : IAccountAuthDataProvider
    {
        private ulong _livePuid;
        private byte _tier;
        private uint[] _privileges;

        public AuthPublicSettings()
        {
            _livePuid = LivecacheRequest.PublicRequestLivePuid;
            _tier = 0;

            // hard code privileges to baseline level
            _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
            AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
        }

        public AuthPublicSettings(ulong puid)
        {
            _livePuid = puid;// LivecacheRequest.PublicRequestLivePuid;
            _tier = 0;

            // hard code privileges to baseline level
            _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
            AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
        }

        private void AddPrivilege(int privilegeId)
        {
            uint mask = (uint)1 << (privilegeId % 32);
            _privileges[privilegeId / 32] |= mask;
        }

        public ulong LivePuid
        {
            get { return _livePuid; }
        }

        public byte Tier
        {
            get { return _tier; }
        }

        public uint[] Privileges
        {
            get { return _privileges; }
        }

        public IPEndPoint ClientIPEndPoint
        {
            get { return new IPEndPoint(0, 0); }
        }
    }

    public class LiveCacheStressAPIs : TestNode
    {
        public override void OneTimeSetup(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            LiveCacheStressSupport.PickClientType();
            LiveCacheStressSupport.PickClientTypeID();
            LiveCacheStressSupport.Init();

            Config.ComponentName = "livecache";
            LiveCacheUtils.SetupLiveCacheTestAPIs();
        }

        [StressInstantiate]
        public class LiveCacheFakeFDTest : TestNode
        {
            public enum CacheExecutionType
            {
                CacheHit,
                CacheMiss,
                CacheInvalidation,
            }
            public delegate LivecacheDependency DependencyGeneratorDelagate(ulong ID);
            public delegate void ExecuteDelagate(int targetSize, ref Hashtable targetQueueType, LcserviceId service, DependencyGeneratorDelagate del);
            public ExecuteDelagate ExDel;

            public void MissCache(int targetSize, ref Hashtable targetQueueType, LcserviceId service, DependencyGeneratorDelagate del)
            {
                LiveCacheStressSupport.SimpleUserQueue targetQueue = (LiveCacheStressSupport.SimpleUserQueue)targetQueueType[targetSize];
                ulong callingUserID = targetQueue.GetNextUserIdToActivate();
                string requestBody = LiveCacheUtils.BuildRequestBody(targetSize, FakeFDRequestType.HTTP);
                //Global.RO.Debug(requestBody);
                byte[] requestBytes = LiveCacheUtils.ConvertBodyToBytes(requestBody);

                LiveCacheStressSupport.SimpleUserQueue.User u = new LiveCacheStressSupport.SimpleUserQueue.User(callingUserID);
                u.ActivationWindowStart = DateTime.UtcNow;
                byte[] response = null;
                try
                {
                    if (del != null)
                    {
                        LiveCacheStressSupport.lcStats.HitTestFDWithDependency(callingUserID, requestBytes, new AuthSettings(callingUserID, LiveCacheStressSupport.clientType), service, del(callingUserID), ref response);
                    }
                    else
                    {
                        LiveCacheStressSupport.lcStats.HitTestFD(callingUserID, requestBytes, new AuthSettings(callingUserID, LiveCacheStressSupport.clientType), service, ref response);
                    }
                    u.ActivationWindowEnd = DateTime.UtcNow;
                    targetQueue.ActivateUser(u);

                    if (response.Length < targetSize)
                    {
                        throw new UnexpectedTestResultException(string.Format("user: {0} response size: {1} expected size: {2}", callingUserID, response.Length, targetSize));
                    }
                }
                catch
                {
                    u.ActivationWindowEnd = DateTime.UtcNow;
                    targetQueue.MarkUserUnsafe(u);
                    throw;
                }
                if (response == null)
                {
                    throw new UnexpectedTestResultException("response is null");
                }
            }

            public void HitCache(int targetSize, ref Hashtable targetQueueType, LcserviceId service, DependencyGeneratorDelagate del)
            {
                LiveCacheStressSupport.SimpleUserQueue targetQueue = (LiveCacheStressSupport.SimpleUserQueue)targetQueueType[targetSize];
                ulong callingUserID = targetQueue.GetRandomActivatedUserID();

                string requestBody = LiveCacheUtils.BuildRequestBody(targetSize, FakeFDRequestType.HTTP);
                byte[] requestBytes = LiveCacheUtils.ConvertBodyToBytes(requestBody);

                byte[] response = null;
                if (del != null)
                {
                    LiveCacheStressSupport.lcStats.HitTestFDWithDependency(callingUserID, requestBytes, new AuthSettings(callingUserID, LiveCacheStressSupport.clientType), service, del(callingUserID), ref response);
                }
                else
                {
                    LiveCacheStressSupport.lcStats.HitTestFD(callingUserID, requestBytes, new AuthSettings(callingUserID, LiveCacheStressSupport.clientType), service, ref response);
                }

                if (response.Length < targetSize)
                {
                    throw new UnexpectedTestResultException(string.Format("user: {0} response size: {1} expected size: {2}", callingUserID, response.Length, targetSize));
                }
            }

            //TODO add more protection for this code around use in a way that turns expected cache hits into unexpected cache misses
            // right now it's only safe because the target sizes that I'm passing in only use non-shared user ranges (166 and 333 bytes/setting queues)
            // need to add some protection mechanism so that we don't just rely on that not changing to maintain valid behavior
            public void InvalidateCache(int targetSize, ref Hashtable targetQueueType, LcserviceId service, DependencyGeneratorDelagate del)
            {
                LiveCacheStressSupport.SimpleUserQueue targetQueue = (LiveCacheStressSupport.SimpleUserQueue)targetQueueType[targetSize];
                LiveCacheStressSupport.SimpleUserQueue.User callingUser = targetQueue.GetRandomUserToInvalidate(null);

                string requestBody = LiveCacheUtils.BuildRequestBody(targetSize, FakeFDRequestType.HTTP);
                byte[] requestBytes = LiveCacheUtils.ConvertBodyToBytes(requestBody);

                byte[] response = null;

                LiveCacheStressSupport.lcStats.InvalidateTestFD(callingUser.puid, requestBytes, new AuthSettings(callingUser.puid, LiveCacheStressSupport.clientType), service, del(callingUser.puid), ref response);
            }
        }

        [StressTest, Description("Call LiveCache with a stats dependency")]
        [CompoundCase("Miss_00500", 500, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_01000", 1000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_01500", 1500, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_02000", 2000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_03000", 3000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_04000", 4000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_06000", 6000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_10000", 10000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_50000", 50000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Hit_00500", 500, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_01000", 1000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_01500", 1500, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_02000", 2000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_03000", 3000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_04000", 4000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_06000", 6000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_10000", 10000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_50000", 50000, CacheExecutionType.CacheHit)]
        public class LiveCacheFakeFDStats : LiveCacheFakeFDTest
        {
            public override void Run()
            {
                int targetSize = (int)MyValues[0];
                CacheExecutionType type = (CacheExecutionType)MyValues[1];
                switch (type)
                {
                    case CacheExecutionType.CacheMiss:
                        ExDel = new ExecuteDelagate(base.MissCache);
                        break;
                    case CacheExecutionType.CacheHit:
                        ExDel = new ExecuteDelagate(base.HitCache);
                        break;
                    case CacheExecutionType.CacheInvalidation:
                        ExDel = new ExecuteDelagate(base.InvalidateCache);
                        break;
                }

                ExDel(targetSize, ref LiveCacheStressSupport.htSizeSpecificFakeFDStatsQueues, LcserviceId.TestAPIWithStatsDependency, new DependencyGeneratorDelagate(LivecacheDependencies.Stats));
            }
        }

        [StressTest, Description("Call LiveCache with a stats dependency")]
        [CompoundCase("Miss_200000", 200000, CacheExecutionType.CacheMiss)]
        public class LiveCacheFakeStatsNonCached : LiveCacheFakeFDTest
        {
            public override void Run()
            {
                int targetSize = (int)MyValues[0];
                CacheExecutionType type = (CacheExecutionType)MyValues[1];
                switch (type)
                {
                    case CacheExecutionType.CacheMiss:
                        ExDel = new ExecuteDelagate(base.MissCache);
                        break;
                    case CacheExecutionType.CacheHit:
                        ExDel = new ExecuteDelagate(base.HitCache);
                        break;
                    case CacheExecutionType.CacheInvalidation:
                        ExDel = new ExecuteDelagate(base.InvalidateCache);
                        break;
                }

                ExDel(targetSize, ref LiveCacheStressSupport.htSizeSpecificFakeFDStatsQueues, LcserviceId.TestAPI, new DependencyGeneratorDelagate(LivecacheDependencies.Stats));
            }
        }

        [StressTest, Description("Invalidate the cache with a stats dependency")]
        [CompoundCase("StatsInvalidate_500", 500)]
        public class LiveCacheFakeFDStatsInvalidate : LiveCacheFakeFDTest
        {
            public override void Run()
            {
                int targetSize = (int)MyValues[0];

                InvalidateCache(targetSize, ref LiveCacheStressSupport.htSizeSpecificFakeFDStatsQueues, LcserviceId.TestAPIWithStatsInvalidation, new DependencyGeneratorDelagate(LivecacheDependencies.Stats));
            }
        }


        [StressTest, Description("Miss the cache with a UserAccount dependency")]
        [CompoundCase("UserAcctMiss_500", 500)]
        public class LiveCacheFakeFDUserAccountMiss : LiveCacheFakeFDTest
        {
            public override void Run()
            {
                int targetSize = (int)MyValues[0];

                MissCache(targetSize, ref LiveCacheStressSupport.htSizeSpecificFakeFDUserAcctQueues, LcserviceId.TestAPIWithUserAccountDependency, new DependencyGeneratorDelagate(LivecacheDependencies.UserAccount));
            }
        }

        [StressTest, Description("Invalidate the cache with a UserAccount dependency")]
        [CompoundCase("UserAcctInvalidate_500", 500)]
        public class LiveCacheFakeFDUserAccountInvalidate : LiveCacheFakeFDTest
        {
            public override void Run()
            {
                int targetSize = (int)MyValues[0];

                InvalidateCache(targetSize, ref LiveCacheStressSupport.htSizeSpecificFakeFDUserAcctQueues, LcserviceId.TestAPIWithUserAccountInvalidation, new DependencyGeneratorDelagate(LivecacheDependencies.UserAccount));
            }
        }

        [StressTest, Description("Call LiveCache with a lists dependency")]
        [CompoundCase("Miss_00500", 500, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_01000", 1000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_01500", 1500, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_02000", 2000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_03000", 3000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_04000", 4000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_06000", 6000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_10000", 10000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Miss_50000", 50000, CacheExecutionType.CacheMiss)]
        [CompoundCase("Hit_00500", 500, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_01000", 1000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_01500", 1500, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_02000", 2000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_03000", 3000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_04000", 4000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_06000", 6000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_10000", 10000, CacheExecutionType.CacheHit)]
        [CompoundCase("Hit_50000", 50000, CacheExecutionType.CacheHit)]
        public class LiveCacheFakeFDFriends : LiveCacheFakeFDTest
        {
            public override void Run()
            {
                int targetSize = (int)MyValues[0];
                CacheExecutionType type = (CacheExecutionType)MyValues[1];
                switch (type)
                {
                    case CacheExecutionType.CacheMiss:
                        ExDel = new ExecuteDelagate(base.MissCache);
                        break;
                    case CacheExecutionType.CacheHit:
                        ExDel = new ExecuteDelagate(base.HitCache);
                        break;
                    case CacheExecutionType.CacheInvalidation:
                        ExDel = new ExecuteDelagate(base.InvalidateCache);
                        break;
                }

                ExDel(targetSize, ref LiveCacheStressSupport.htSizeSpecificFakeFDFriendsQueues, LcserviceId.TestAPIWithFriendsDependency, new DependencyGeneratorDelagate(LivecacheDependencies.Friends));
            }
        }

        [StressInstantiate]
        public class HitADHostDirectly : TestNode
        {
            public void execute(xonline.common.config.IInterfaceInfo target)
            {
                string requestBody = LiveCacheUtils.BuildRequestBody(500, FakeFDRequestType.HTTP);
                byte[] requestBytes = LiveCacheUtils.ConvertBodyToBytes(requestBody);

                XrlRequest fdReq = new XrlRequest();
                fdReq.TargetInterfaceInfo = target;

                fdReq.ContentTypeOverride = "application/x-www-form-urlencoded";
                fdReq.Path = "SampleWebService.asmx/GetData";
                fdReq.PostData = requestBytes;
                fdReq.AuthData = "NOT USED";
                fdReq.Send();
                byte[] ResponseData = fdReq.ResponseData;

                if (ResponseData == null)
                {
                    throw new UnexpectedTestResultException("ResponseData is null");
                }
            }

            public void execute(string targetVirtualInterface)
            {
                string requestBody = LiveCacheUtils.BuildRequestBody(500, FakeFDRequestType.HTTP);
                byte[] requestBytes = LiveCacheUtils.ConvertBodyToBytes(requestBody);

                XrlRequest fdReq = new XrlRequest();
                fdReq.TargetVirtualInterface = targetVirtualInterface;

                fdReq.ContentTypeOverride = "application/x-www-form-urlencoded";
                fdReq.Path = "SampleWebService.asmx/GetData";
                fdReq.PostData = requestBytes;
                fdReq.AuthData = "NOT USED";
                fdReq.Send();
                byte[] ResponseData = fdReq.ResponseData;

                if (ResponseData == null)
                {
                    throw new UnexpectedTestResultException("ResponseData is null");
                }
            }
        }

        [StressTest]
        public class HitADHost1 : HitADHostDirectly
        {
            public override void Run()
            {
                base.execute(xonline.common.config.Config.GetInterface("S1XBLSTATIIS001", "xstatsfd_int"));
            }
        }

        [StressTest]
        public class HitADHost2 : HitADHostDirectly
        {
            public override void Run()
            {
                base.execute(xonline.common.config.Config.GetInterface("S1XBLSTATIIS002", "xstatsfd_int"));
            }
        }

        [StressTest]
        public class HitADHostVIP : HitADHostDirectly
        {
            public override void Run()
            {
                base.execute("xstatsfd_int");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\Leaderboard\LcLeaderboard.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.Utilities;

using xonline.common.protocol;
using xonline.common.webplatform.livecache;
using StatsReadRequest = xonline.common.protocol.StatsReadRequest;
using StatsReadResponse = xonline.common.protocol.StatsReadResponse;
using StatsSpec = xonline.common.protocol.StatsSpec;

namespace ServerTestFramework.LiveCache.Test.Leaderboard
{
    // ColumnId values that are used by StatPost and StatRead 
    public static class ColumnId
    {
        // Column IDs
        public readonly static short Rating = -2;         //(65534)Special reserved ID
        public readonly static short Wins = 3;
        public readonly static short AttachmentSize = -6; //(65530)Special reserved ID
        public readonly static short Rank = -3;           //(65533)Special reserved ID
    }

    //StatReadTest encapsulate all StatsReadRequest data for testing
    public class StatReadTest
    {
        private StatsReadRequest ReadRequestData;
        private ulong _UserID;  // We only read one user data at a time.

        public StatReadTest(ulong pUserID, uint pTitleID, int pLbID, ushort[] pColumnIDs)
        {
            ReadRequestData = new StatsReadRequest();
            ReadRequestData.TitleId = pTitleID;
            ReadRequestData.UserCount = 1;
            ReadRequestData.Users = new ulong[1];
            ReadRequestData.Users[0] = pUserID;

            _UserID = pUserID;

            ReadRequestData.SpecCount = 1;
            ReadRequestData.Specs = new StatsSpec[1];
            ReadRequestData.Specs[0] = new StatsSpec();
            ReadRequestData.Specs[0].ViewId = (uint)pLbID;
            ReadRequestData.Specs[0].ColumnCount = 1;
            ReadRequestData.Specs[0].ColumnIds = new ushort[pColumnIDs.Length];
            ReadRequestData.Specs[0].ColumnIds = pColumnIDs;
        }

        public StatsReadResponse LcGetFriendsLeaderboardInfo()
        {            
            if (null == ReadRequestData)
            {
                throw new TestCaseException("StatsReadRequest data is not set or initialized");
            }

            LcLeaderboards lc_leaderboard = new LcLeaderboards();
            return lc_leaderboard.GetFriendsLeaderboardInfo(ReadRequestData, _UserID);         
        }

        //This function will get the current ColumnId_Rating value for a leaderboard.
        public static Int64 Get_Rating_Value_For_Leaderboard(ulong pUserID, uint pTitleID, int pLbID)
        {
            Int64 return_val = 0;         
            
            StatsReadRequest request = new StatsReadRequest();
            request.TitleId = pTitleID;
            request.UserCount = 1;
            request.Users = new ulong[1];
            request.Users[0] = pUserID;

            request.SpecCount = 1;
            request.Specs = new StatsSpec[1];
            request.Specs[0] = new StatsSpec();
            request.Specs[0].ViewId = (uint)pLbID;
            request.Specs[0].ColumnCount = 1;
            request.Specs[0].ColumnIds = new ushort[] { (ushort) ColumnId.Rating };

            LcLeaderboards lc_leaderboard = new LcLeaderboards();
            StatsReadResponse response = lc_leaderboard.GetFriendsLeaderboardInfo(request, pUserID);

            if (response != null)
            {
                if (response.ResultsCount == 1)
                {
                    if (response.Results[0].Rows[0].ColumnCount == 1)
                    {
                        return_val = (long)response.Results[0].Rows[0].Rating;
                    }
                }
            }

            return return_val;
        }

        //This function will get the current ColumnId_Rank value for a leaderboard.
        public static Int64 Get_Rank_Value_For_Leaderboard(ulong pUserID, uint pTitleID, int pLbID)
        {
            Int64 return_val = 0;

            StatsReadRequest request = new StatsReadRequest();
            request.TitleId = pTitleID;
            request.UserCount = 1;
            request.Users = new ulong[1];
            request.Users[0] = pUserID;

            request.SpecCount = 1;
            request.Specs = new StatsSpec[1];
            request.Specs[0] = new StatsSpec();
            request.Specs[0].ViewId = (uint)pLbID;
            request.Specs[0].ColumnCount = 1;
            request.Specs[0].ColumnIds = new ushort[] { (ushort)ColumnId.Rank };

            LcLeaderboards lc_leaderboard = new LcLeaderboards();
            StatsReadResponse response = lc_leaderboard.GetFriendsLeaderboardInfo(request, pUserID);

            if (response != null)
            {
                if (response.ResultsCount == 1)
                {
                    if (response.Results[0].Rows[0].ColumnCount == 1)
                    {
                        return_val = (long)response.Results[0].Rows[0].Rank;
                    }
                }
            }

            return return_val;
        }

        // This function will get the current value for a specified columnID for the leaderboard
        public static object Get_Column_Value_For_Leaderboard(ulong pUserID, uint pTitleID, int pLbID, short pColumnID)
        {
            object return_val = null;            

            StatsReadRequest request = new StatsReadRequest();
            request.TitleId = pTitleID;
            request.UserCount = 1;
            request.Users = new ulong[1];
            request.Users[0] = pUserID;

            request.SpecCount = 1;
            request.Specs = new StatsSpec[1];
            request.Specs[0] = new StatsSpec();
            request.Specs[0].ViewId = (uint)pLbID;
            request.Specs[0].ColumnCount = 2;
            request.Specs[0].ColumnIds = new ushort[] { (ushort)pColumnID };

            LcLeaderboards lc_leaderboard = new LcLeaderboards();
            StatsReadResponse response = lc_leaderboard.GetFriendsLeaderboardInfo(request, pUserID);

            if (response != null)
            {
                if (response.ResultsCount == 1)
                {
                    if (response.Results[0].Rows[0].ColumnCount == 1)
                    {
                        if (response.Results[0].Rows[0].Columns[0].ColumnId == (ushort)pColumnID)
                        {
                            return_val = response.Results[0].Rows[0].Columns[0].Data;
                        }
                    }
                }
            }

            return return_val;
        }

    }

    // StatPostTest encapsulates all ReqStatPost data for testing
    public class StatPostTest
    {
        // Proc ids
        public static ushort Proc_StatPostADD = 0x8003;
        public static ushort Proc_StatPostMin = 0x8009;
        public static ushort Proc_StatPostMax = 0x800B;
        public static ushort proc_StatPostReplace = 0x8001;

        //ParamType
        public const byte _PT_INT16 = 2;
        public const byte _PT_INT32 = 3;
        public const byte _PT_INT64 = 4;
        public const byte _PT_FLOAT = 5;
        public const byte _PT_PUID  = 7;
        public const Int16 _DEPEND = 0; //Proc variable <depend> is always set to 0 for leaderboard livecache calls.

        public ReqStatPost PostData;

        private ulong _UserID;

        public StatPostTest(ulong pUserID, uint pTitleID, ushort pProcCount)
        {
            PostData = new ReqStatPost();
            PostData._uiTitleId = pTitleID;
            PostData._usProcCount = pProcCount;
            PostData._procs = new MsgStatPostProcedureCall[pProcCount];
            PostData._teamTickets = SetDefaultTeamTickets(pUserID);
            _UserID = pUserID;
        }

        //NOTE: teamTickets data is filled basically to make request go through StatsFD, with the current StatsFD implementation it throws exception
        //without this data. So we just initialize it in our calls.
        public TeamTickets SetDefaultTeamTickets(ulong pUserID)
        {
            TeamTickets locTeamTickets;
            locTeamTickets = new TeamTickets();
            locTeamTickets.wType = TeamTickets.TEAM_TICKETS_TYPE;
            locTeamTickets.wLength = 14;
            locTeamTickets.cTickets = 1;
            locTeamTickets.teamTickets = new TeamTicket[1];
            locTeamTickets.teamTickets[0] = new TeamTicket(pUserID, 1);

            return locTeamTickets;
        }

        //Initialize proc sets the first 3 parameters for a proc at ordinals 0,1,2
        public void Initialize_Proc(int pProcOrdinal, ushort pMethod, ushort pParameterCount, int pLbID)
        {
            if (pProcOrdinal > PostData._usProcCount)
            {
                throw new TestCaseException("Proc ordinal parameter is greater than proc count which is "+ PostData._usProcCount);
            }

            if (pParameterCount < 3)
            {
                throw new TestCaseException("Initialize_Proc needs minimum 3 paramater_count to intialize procs");
            }            

            PostData._procs[pProcOrdinal] = new MsgStatPostProcedureCall();
            PostData._procs[pProcOrdinal]._usProcId = pMethod;
            PostData._procs[pProcOrdinal]._usParamCount = pParameterCount;
            PostData._procs[pProcOrdinal]._params = new MsgStatPostParameter[pParameterCount];

            //Set the first three parameters types and values for 0,1,2 with UserID, LeaderboardID and Depend respectively
            SetProcParamaterAndValue(pProcOrdinal, 0, _PT_PUID, _UserID);
            SetProcParamaterAndValue(pProcOrdinal, 1, _PT_INT32, pLbID);
            SetProcParamaterAndValue(pProcOrdinal, 2, _PT_INT16, _DEPEND);

        }

        // This method sets proc parameter type and value
        public void SetProcParamaterAndValue(int pProcOrdinal, int pParamColumnOrdinal, byte pParamType, object ColumnValue)
        {
            if (pProcOrdinal > PostData._usProcCount)
            {
                throw new TestCaseException("Proc ordinal parameter is greater than proc count which is " + PostData._usProcCount);
            }

            if (pParamColumnOrdinal > PostData._procs[pProcOrdinal]._usParamCount)
            {
                throw new TestCaseException(String.Format("Proc {0} parameter count is {1} and the input value {2} exceeds it", pProcOrdinal, PostData._procs[pProcOrdinal]._usParamCount, pParamColumnOrdinal));
            }

            PostData._procs[pProcOrdinal]._params[pParamColumnOrdinal] = new MsgStatPostParameter();
            PostData._procs[pProcOrdinal]._params[pParamColumnOrdinal]._bParamType = pParamType;
            PostData._procs[pProcOrdinal]._params[pParamColumnOrdinal]._data = ColumnValue;
        }

        // This is the livecache Post call
        public void LcPostLeaderboardResult()
        {
            if (null == PostData)
            {
                throw new TestCaseException("PostData is not initialized and is null ");
            }

            LcLeaderboards lc_leaderboard = new LcLeaderboards();
            lc_leaderboard.PostLeaderboardResult(PostData, _UserID);
        }

    }

    /// <summary>
    /// Livecache tests for Leaderboard livecache service
    /// </summary>
    [TestGroup, Owner("srkalyan"), TestFrequency("Regression"), TestCasePriority(2)]
    class LcLeaderboard_Tests
    {
        //Testcase data
        private const ulong USER_ID = 7007;
        private const uint  TITLE_ID = 0xFFFF0072; //This TITLE_ID should be present in the target Xblob in NPDB tables t_stats_leaderboard and t_interface_buckets
        private const int   LB_ID = 1;              //This LB_ID should be present in the target Xblob NPDB tables t_stats_leaderboard
        
        // Attachment parameters        
        private const byte COUNTRY_ID = 0; // 0 = XX, 103 = USA
        static private readonly string AttachmentPath = "//xestats/u:" + USER_ID.ToString("x") + "/" + TITLE_ID.ToString("x8") + "/" + LB_ID.ToString("x8");

        [TestCase, TestCasePriority(1), Description("PostStats rating using Proc_StatPostMax and verify if value is updated with MAX value")]
        public void Get_PostLeaderboard_Rating_MAX_new(TestNode self)
        {
            Int64 ratingValue_beforePost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);

            StatPostTest post = new StatPostTest(USER_ID,  TITLE_ID, 1);
            post.Initialize_Proc(0, StatPostTest.Proc_StatPostMax, 5, LB_ID);
            post.SetProcParamaterAndValue(0, 3, StatPostTest._PT_INT16, ColumnId.Rating);
            post.SetProcParamaterAndValue(0, 4, StatPostTest._PT_INT64, ratingValue_beforePost + 1);

            post.LcPostLeaderboardResult();

            Int64 ratingValue_afterPost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);

            if (ratingValue_afterPost != ratingValue_beforePost + 1)
            {
                throw new TestCaseException("PostLeaderboardResult for Proc_StatPostMax failed to update with MAX value");
            }
        }

        [TestCase, TestCasePriority(1), Description("PostStats rating using Proc_StatPostMin and verify if value is updated with MIN value")]
        public void Get_PostLeaderboard_Rating_MIN(TestNode self)
        {            
            Int64 ratingValue_beforePost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);

            StatPostTest post = new StatPostTest(USER_ID, TITLE_ID, 1);            
            post.Initialize_Proc(0, StatPostTest.Proc_StatPostMin, 5, LB_ID);
            post.SetProcParamaterAndValue(0, 3, StatPostTest._PT_INT16, ColumnId.Rating);
            post.SetProcParamaterAndValue(0, 4, StatPostTest._PT_INT64, ratingValue_beforePost - ratingValue_beforePost);

            post.LcPostLeaderboardResult();

            Int64 ratingValue_afterPost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);

            if (ratingValue_afterPost != 0)
            {
                throw new TestCaseException("PostLeaderboardResult for Proc_StatPostMin failed to update with MIN value (zero)");
            }
        }

        [TestCase, TestCasePriority(1), Description("PostStats rating using Proc_StatPostMAX and Wins Column using Proc_StatPostADD and verify values")]
        public void Get_PostLeaderboard_Rating_MAX_Wins_ADD(TestNode self)
        {
            Int64 ratingValue_beforePost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);    // Rating/BestScore value
            Int64 winsValue_beforePost = Int64.Parse(StatReadTest.Get_Column_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID, ColumnId.Wins).ToString());

            StatPostTest post = new StatPostTest(USER_ID, TITLE_ID, 2);

            //Initialize and set valuse for Proc[0]
            post.Initialize_Proc(0, StatPostTest.Proc_StatPostMax, 5,  LB_ID);
            post.SetProcParamaterAndValue(0, 3, StatPostTest._PT_INT16, ColumnId.Rating);
            post.SetProcParamaterAndValue(0, 4, StatPostTest._PT_INT64, ratingValue_beforePost+1);

            //Initialize and set valuse for Proc[1]
            post.Initialize_Proc(1, StatPostTest.Proc_StatPostADD, 5, LB_ID);
            post.SetProcParamaterAndValue(1, 3, StatPostTest._PT_INT16, ColumnId.Wins);
            post.SetProcParamaterAndValue(1, 4, StatPostTest._PT_INT64, (Int64) 3); //Increment by 3

            post.LcPostLeaderboardResult();

            Int64 ratingValue_afterPost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);
            Int64 winsValue_afterPost = Int64.Parse(StatReadTest.Get_Column_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID, ColumnId.Wins).ToString());

            if (ratingValue_afterPost != ratingValue_beforePost + 1)
            {
                throw new TestCaseException("PostLeaderboardResult for Proc_StatPostMax failed to update with MAX value");
            }

            if (winsValue_afterPost != winsValue_beforePost + 3)
            {
                throw new TestCaseException("PostLeaderboardResult failed to update with MAX value for for ColumnId_Wins Proc_StatPostMax");
            }
        }

        [TestCase, TestCasePriority(1), Description("PostStats rating using Proc_StatPostMAX and Wins Column using StatPostReplace and verify values")]
        public void Get_PostLeaderboard_Rating_MAX_Wins_REPLACE(TestNode self)
        {
            Int64 ratingValue_beforePost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);    // Rating/BestScore value
            Int64 winsValue_beforePost = Int64.Parse(StatReadTest.Get_Column_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID, ColumnId.Wins).ToString());


            StatPostTest post = new StatPostTest(USER_ID, TITLE_ID, 2);

            //Initialize and set valuse for Proc[0]
            post.Initialize_Proc(0, StatPostTest.Proc_StatPostMax, 5, LB_ID);
            post.SetProcParamaterAndValue(0, 3, StatPostTest._PT_INT16, ColumnId.Rating);
            post.SetProcParamaterAndValue(0, 4, StatPostTest._PT_INT64, ratingValue_beforePost + 1);

            //Initialize and set valuse for Proc[1]
            post.Initialize_Proc(1, StatPostTest.proc_StatPostReplace, 5, LB_ID);
            post.SetProcParamaterAndValue(1, 3, StatPostTest._PT_INT16, ColumnId.Wins);
            Random r = new Random();
            Int64 winsValue_random = r.Next(1, 500);
            post.SetProcParamaterAndValue(1, 4, StatPostTest._PT_INT64, winsValue_random); //Set a random value

            post.LcPostLeaderboardResult();

            Int64 ratingValue_afterPost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);
            Int64 winsValue_afterPost = Int64.Parse(StatReadTest.Get_Column_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID, ColumnId.Wins).ToString());

            if (ratingValue_afterPost != ratingValue_beforePost + 1)
            {
                throw new TestCaseException("PostLeaderboardResult for Proc_StatPostMax failed to update with MAX value");
            }

            if (winsValue_afterPost != winsValue_random)
            {
                throw new TestCaseException("PostLeaderboardResult failed to Replace the value for ColumnId_Wins StatPostReplace");
            }
        }

        [TestCase, TestCasePriority(1), Description("Verify StatsRead for a Rating column")]
        public void GetFriendsLeaderboardInfo_ColumnId_Rating(TestNode self)
        {

            StatReadTest read = new StatReadTest(USER_ID, TITLE_ID, LB_ID, new ushort[] { (ushort)ColumnId.Rating });
            StatsReadResponse response = read.LcGetFriendsLeaderboardInfo();

            if (response == null)
            {
                throw new TestCaseException("StatsReadResponse is NULL");
            }

            if (response.ResultsCount != 1)
            {
                throw new TestCaseException("StatsReadResponse.ResultCount do not match the expected value");
            }

            if (response.Results[0].Rows[0].ColumnCount != 1)
            {
                throw new TestCaseException("StatsReadResponse ColumnCount do not match the expected value");
            }

            if (response.Results[0].Rows[0].Columns[0].ColumnId != (ushort)ColumnId.Rating)
            {
                throw new TestCaseException("StatsReadResponse ColumnId do not match the expected value");
            }

            return;
        }

        [TestCase, TestCasePriority(1), Description("Verify StatsRead for a Rating and Wins columns")]
        public void GetFriendsLeaderboardInfo_ColumnId_Rating_Wins(TestNode self)
        {
            ushort[] ColumnIds = new ushort[] { (ushort)ColumnId.Rating, (ushort)ColumnId.Wins };

            StatReadTest read = new StatReadTest(USER_ID, TITLE_ID, LB_ID, ColumnIds);
            StatsReadResponse response = read.LcGetFriendsLeaderboardInfo();

            if (response == null)
            {
                throw new TestCaseException("StatsReadResponse is NULL");
            }

            if (response.ResultsCount != 1)
            {
                throw new TestCaseException("StatsReadResponse.ResultCount do not match the expected value");
            }

            if (response.Results[0].Rows[0].ColumnCount != 2)
            {
                throw new TestCaseException("StatsReadResponse ColumnCount do not match the expected value");
            }

            if (response.Results[0].Rows[0].Columns[0].ColumnId != (ushort)ColumnId.Rating)
            {
                throw new TestCaseException("StatsReadResponse Columns[1].ColumnID do not match the expected value");
            }

            if (response.Results[0].Rows[0].Columns[1].ColumnId != (ushort)ColumnId.Wins)
            {
                throw new TestCaseException("StatsReadResponse Columns[1].ColumnID do not match the expected value");
            }

            return;
        }

        [TestCase, TestCasePriority(1), Description("Verify PostStats using StatPostReplace for a AttachmentSize column")]
        public void Get_PostLeaderboard_ColumnId_AttachmentSize_REPLACE(TestNode self)
        {
            int attachmentSize_beforePost = int.Parse(StatReadTest.Get_Column_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID, ColumnId.AttachmentSize).ToString());

            StatPostTest post = new StatPostTest(USER_ID, TITLE_ID, 1);
            post.Initialize_Proc(0, StatPostTest.proc_StatPostReplace, 5, LB_ID);
            post.SetProcParamaterAndValue(0, 3, StatPostTest._PT_INT16, ColumnId.AttachmentSize);
            Random rnd = new Random();
            int attachmentSizeRandom = rnd.Next(1, 500);
            post.SetProcParamaterAndValue(0, 4, StatPostTest._PT_INT32, attachmentSizeRandom);

            post.LcPostLeaderboardResult();

            if (attachmentSizeRandom != int.Parse(StatReadTest.Get_Column_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID, ColumnId.AttachmentSize).ToString()))
            {
                throw new TestCaseException("PostLeaderboardResult with AttachmentSize did not update using proc StatPostReplace");
            }            
        }

        // Bug!!! We have a bug where StorageRead do not immediately reflect the StorageWrite data because of caching.
        [TestCase, TestCasePriority(1), Description("Verifies if StorageWrite and StorageRead works properly comparing the data lenght and content")]
        public void PostLeaderboardAttachment_And_TestStorage(TestNode self)
        {
            //We call below test to initialize the values.
            Get_PostLeaderboard_ColumnId_AttachmentSize_REPLACE(self);

            //Attachment size after the recent Post operation
            int attachmentSize = int.Parse(StatReadTest.Get_Column_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID, ColumnId.AttachmentSize).ToString());

            ////////////////////////////
            // Now write blob to storage
            ////////////////////////////
            LcTitleStorage storage = new LcTitleStorage();

            byte[] data = new byte[attachmentSize];
            for (int i = 0; i < attachmentSize; i++)
            {
                data[i] = (byte)i;
            }

            DateTime expirationDate = new DateTime(9999, 9, 9);
            storage.StorageWrite(USER_ID, AttachmentPath, data, expirationDate, COUNTRY_ID, LivecacheClientType.LIVEn, TITLE_ID);

            /////////////////////////////////////////
            // Now read blob from storage and verify 
            /////////////////////////////////////////
            byte[] attachmentData = storage.StorageRead(USER_ID, AttachmentPath, TITLE_ID, LivecacheClientType.LIVEn);


            if (attachmentData == null)
            {
                throw new TestCaseException("StorageRead is returning null and blob is empty, StroageWrite has failed");
            }

            //Verify the attachmentSize
            if (attachmentData.Length != attachmentSize)
            {
                throw new TestCaseException(String.Format("StorageRead is returning blob with incorrect attachmentSize value. Actual= {0}, Expected={1}", attachmentData.Length, attachmentSize));
            }

            //Verify the blob content
            for (int i = 0; i < attachmentData.Length; i++)
            {
                if (attachmentData[i] != (byte)i)
                {
                    throw new TestCaseException("Attachment data does not match expected value! Expected byte: " + i + " Actual: " + attachmentData[i]);
                }
            }            
        }

        [TestCase, TestCasePriority(1), Description("Verify if PostStats rating fails for invalid Leaderboard ID")]
        public void Get_PostLeaderboard_Rating_MAX_Invalid_LeaderboardID(TestNode self)
        {
            Int64 ratingValue_beforePost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);

            StatPostTest post = new StatPostTest(USER_ID, TITLE_ID, 1);
            post.Initialize_Proc(0, StatPostTest.Proc_StatPostMax, 5, 0); // LeaderboardID 0 is invalid
            post.SetProcParamaterAndValue(0, 3, StatPostTest._PT_INT16, ColumnId.Rating);
            post.SetProcParamaterAndValue(0, 4, StatPostTest._PT_INT64, ratingValue_beforePost + 1);

            try
            {
                post.LcPostLeaderboardResult();
            }
            catch (LivecacheResponseException)
            {
                Int64 ratingValue_afterPost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);

                if (ratingValue_afterPost != ratingValue_beforePost)
                {
                    throw new TestCaseException("PostLeaderboardResult for invalid (0) Leadeboard ID has updated the Rating value");
                }

                return;
            }
            throw new TestCaseException("PostLeaderboardResult with invalid (0) Leadeboard ID has PASSed");
        }

        [TestCase, TestCasePriority(1), Description("Verify if PostStats rating fails for invalid Title ID")]
        public void Get_PostLeaderboard_Rating_MAX_Invalid_TitleID(TestNode self)
        {
            Int64 ratingValue_beforePost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);

            StatPostTest post = new StatPostTest(USER_ID, 0, 1); // TitleID is set to 0 is invals
            post.Initialize_Proc(0, StatPostTest.Proc_StatPostMax, 5, LB_ID);
            post.SetProcParamaterAndValue(0, 3, StatPostTest._PT_INT16, ColumnId.Rating);
            post.SetProcParamaterAndValue(0, 4, StatPostTest._PT_INT64, ratingValue_beforePost + 1);

            try
            {
                post.LcPostLeaderboardResult();
            }
            catch (LivecacheResponseException)
            {
                Int64 ratingValue_afterPost = StatReadTest.Get_Rating_Value_For_Leaderboard(USER_ID, TITLE_ID, LB_ID);

                if (ratingValue_afterPost != ratingValue_beforePost)
                {
                    throw new TestCaseException("PostLeaderboardResult for invalid (0) TitleID has updated the Rating value");
                }

                return;
            }

            throw new TestCaseException("PostLeaderboardResult with invalid (0) TitleID has PASSed");
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\stressemulator\source\AppDomainHostConsole\Program.cs ===
#region Using directives

using System;
using System.IO;
using System.Web.Hosting;
using HttpListenerLibrary;
using System.Reflection;

#endregion

namespace AppDomainHostConsole
{
    class Program
    {
        private const int DEFAULTPORT = 8081;
        private static HttpListenerWrapper host = null;
        private static bool shutdown = false;

        //Program entry point
        static void Main(string[] args)
        {

            //Intercept control-c
            Console.CancelKeyPress += new ConsoleCancelEventHandler(myHandler);

            string portAndPath = DEFAULTPORT.ToString();

            //Parse command line arguements
            if (false == ParseParams(args, ref portAndPath)) return;

            //Setup listening prefixes
            string[] prefixes = new string[] { "http://+:" + portAndPath + "/" };

            //Recycle AppDomains on unloads until shutdown
            while (false == shutdown)
            {

                //Create a AppDomain host
                Console.WriteLine("Starting an AppDomain");
                host = (HttpListenerWrapper)ApplicationHost.CreateApplicationHost(typeof(HttpListenerWrapper), "/", Directory.GetCurrentDirectory());
                host.Configure(prefixes, "/", Directory.GetCurrentDirectory());
                host.Start();

                //User feedback
                foreach (string prefix in prefixes)
                {
                    Console.WriteLine("Listening on prefix: " + prefix);
                }

                //Process listening requests until shutdown
                while (false == shutdown)
                {
                    //Catch AppDomain unloads
                    try
                    {
                        host.ProcessRequest();
                    }
                    catch (AppDomainUnloadedException)
                    {
                        Console.WriteLine("AppDomain Unloaded");
                        break;
                    }
                }
            }

        }

        //Parse command line arguements
        static bool ParseParams(string[] args, ref string portAndPath)
        {
            if (null != args)
            {
                if (args.Length > 1)
                {
                    Usage();
                    return false;
                }
                if (args.Length == 1)
                {
                    portAndPath = args[0];
                }
            }
            return true;
        }

        //Show command line usage
        static void Usage()
        {
            Console.WriteLine("usage: AppDomainHostConsole <portnum>");
        }

        //Control-C handler
        protected static void myHandler(object sender, ConsoleCancelEventArgs args)
        {
            Console.WriteLine("User shutdown requested");
            shutdown = true;
            host.Stop();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\stressemulator\source\SampleWebService\SampleWebService.cs ===
#region Using directives

using System;
using System.Web.Services;

#endregion

namespace GenericSample
{

    [WebService(Name = "Generic Webservice Sample", Description = "This is a generic webservice sample", Namespace = "http://www.microsoft.com"/*"http://tempuri.org/"*/)]
    public class SampleWebService : System.Web.Services.WebService
    {
        public Random rand = new Random();
        public static System.Collections.Hashtable htStaticResponses = null;
        public int[] ResponsesSizes = new int[] { 10, 500, 1000, 1500, 2000, 3000, 4000, 6000, 10000, 50000 };
        public static string ReallyBigResponse200 = null;
        public SampleWebService()
        {
            if (htStaticResponses == null)
            {
                htStaticResponses = new System.Collections.Hashtable();
                foreach (int size in ResponsesSizes)
                {
                    string response = string.Format("[{0}bytes]", size);
                    while (response.Length < size)
                    {
                        // TODO: big perf gain to be had from making this a stringbuilder instead of just a string
                        // not a huge deal since it's a one time cost, but that would make the initial startup more speedy
                        response += rand.Next(0, 9).ToString(); 
                    }
                    htStaticResponses.Add(size, response);
                }
            }
            if (ReallyBigResponse200 == null)
            {
                string compoundResponse = (string)htStaticResponses[50000];
                ReallyBigResponse200 = compoundResponse + compoundResponse + compoundResponse + compoundResponse;
            }
        }

        #region WebMethods

        [System.Web.Services.WebMethodAttribute()]
        public string GetData(int responseSizeInBytes)
        {
            if (htStaticResponses.ContainsKey(responseSizeInBytes))
            {
                return (string)htStaticResponses[responseSizeInBytes];
            }
            else
            {
                if (responseSizeInBytes == 200000)
                {
                    return ReallyBigResponse200;
                }
                byte[] response = new byte[responseSizeInBytes];
                rand.NextBytes(response);
                return string.Format("size not found in cache: {0}", responseSizeInBytes);
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xbos\FuncXeOfferPurchaseGamertag.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

using xonline.common.config;

using Microsoft.XBox.Live.Server.Emulators.Framework;
using Microsoft.XBox.Live.Server.Emulators.MusicNet;
using Microsoft.XBox.Live.Server.Emulators.Dmp;
using Microsoft.XBox.Live.Server.Emulators.Bdk;

using XeXbos;

using xonline.common.webplatform.livecache;


namespace LiveCacheXbosTest
{

    //public const uint XONLINE_E_OFFERING_PURCHASE_GAMERTAG_ERROR                 = 0x80153051;  // non-specific (catch all) api error

    /// <summary>
    ///     Functional test cases for the XeOfferPurchaseGamertag API.
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(1), TestFrequency("Regression"), EnvRequirement("Billing")]
    public class XeOfferPurchaseGamertag : TestNode
    {
        public static uint InnerExecute( ulong xuid, LivecacheClientType clientType, uint clientTitleId, ulong offerID, ulong machinePuid, byte clientPlatform )
        {
            return InnerExecute( xuid, clientType, clientTitleId, offerID, machinePuid, clientPlatform, true );
        }

        public static uint InnerExecute( ulong xuid, LivecacheClientType clientType, uint clientTitleId, ulong offerID, ulong machinePuid, byte clientPlatform, bool retryNameTokenError )
        {
            UacsCommon.LiveCacheResetInitializedClientType();

            LivecacheRequest.CurrentLocaleHandler = LiveCacheXbos.DefaultLivecacheLocaleHandler;

            //
            // Purchase Free Gamertag
            //
            string oldGamertag = UodbWS.GetGamertag(xuid);

            RandomEx rnd = new RandomEx();
            string newGamerTag = rnd.GenerateRandomString("XEN", 15);

            xonline.common.protocol.XeOfferPurchaseGamertagRequest req = new xonline.common.protocol.XeOfferPurchaseGamertagRequest();
            req.userPuid = xuid;
            req.countryID = 103;
            req.tier = 3;
            req.machinePuid = machinePuid;
            req.offerID = offerID;  
            req.paymentType = (uint)PaymentTypeEnum.Points;  
            req.gamertag = newGamerTag;

            LiveCacheXbos.AccountAuthDataProvider aadp = new LiveCacheXbos.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;

            aadp._ClientPlatform = clientPlatform;

            uint hr = HResult.S_OK;
            // retry 3 time to work around the XONLINE_E_ACCOUNTS_NAME_TAKEN failure
            for ( int i = 0; i < 3; i++ )
            {
                Global.RO.Info( "Changing user 0x" + xuid.ToString( "X" ) + " gamertag from " + oldGamertag + " to " + newGamerTag );
                LcBillingOffering lcBO = new LcBillingOffering( clientType, clientTitleId, aadp, false );
                hr = lcBO.PurchaseGamerTag( req, aadp );
                Global.RO.Info( String.Format( "lcBO.PurchaseGamerTag returned 0x{0:x}", hr ) );

                if ( retryNameTokenError && hr == HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN )
                {
                    Global.RO.Info( "Try again due to XONLINE_E_ACCOUNTS_NAME_TAKEN." );
                    newGamerTag = rnd.GenerateRandomString("XEN", 15);
                    req.gamertag = newGamerTag;
                }
                else
                {
                    break;
                }
            }

            string currGamertag = UodbWS.GetGamertag(xuid);

            if ( hr == HResult.S_OK )
            {
                if (currGamertag != newGamerTag)
                  throw new UnexpectedTestResultException(String.Format("After change, gamertag is {0} not {1}", currGamertag, newGamerTag));
            }
            else
                {
                    if (currGamertag != oldGamertag)
                      throw new UnexpectedTestResultException(String.Format("After change failed, gamertag changed from {0} to {1}", oldGamertag, currGamertag));
                }

            return hr;
        }

	/// <summary>
	/// 	Create Zune user
	///         Purchase 1600 pts
	/// 	Purchase charged Zune gamertag change with Zune client Type
	/// </summary>
        //[TestCase, TestCasePriority(2), TestTag("Prerequisite", "title= 0xFFFE0777"),Ignore]
        class P_LIVEnClient_ZuneUser_ZuneGamerTag_ZunePlatform : UserTestBase
        {
            override protected void Execute()
            {
                // Create Zune Account
                XeUser user = new ArgoUser();
                XbosOffer.RewardUSUser1600Points(user);

                uint hr = InnerExecute(user.UserPuid, LivecacheClientType.LIVEn, XOn.CRUX_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.ZuneGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_ZUNE);

                if (hr != 0)
                  throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));
                
                this.ResultCode = TEST_RESULTS.PASSED;
            }
       }

	/// <summary>
	/// 	Create WM7 user
	/// 	Purchase free gamertag change on web in WM7 with LIVEn client Type
	/// </summary>
        [TestCase, TestCasePriority(1)]
        class P_LIVEnClient_WM7User_FreeGamerTag_LIVEnPlatform : UserTestBase
        {
            override protected void Execute()
            {
                // Create Moblie Account
                byte[] ownerPassportToken; 
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN);

                if (hr != 0)
                  throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));

                this.ResultCode = TEST_RESULTS.PASSED;
            }
		}


	/// <summary>
	/// 	Create WM7 user
	/// 	Purchase free gamertag change on web in WM7 with LIVEn client Type
	/// </summary>
        [TestCase, TestCasePriority(1)]
        class P_LIVEnClient_WM7User_FreeGamerTag_MOBILEPlatform : UserTestBase
        {
            override protected void Execute()
            {
                // Create Moblie Account
                byte[] ownerPassportToken; 
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_MOBILE);

                if (hr != 0)
                  throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));
               
		
                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }


	/// <summary>
	/// 	Create WM7 user
	/// 	Purchase free gamertag change on web in WM7 with LIVEn client Type
	/// 	Try one more time
	/// </summary>
        [TestCase, TestCasePriority(1)]
        class P_Twice : UserTestBase
        {
            override protected void Execute()
            {
                // Create Moblie Account
                byte[] ownerPassportToken; 
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, 
                    Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN);

                if (hr != 0)
                  throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));

                hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), 
                    UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN, false);

                if (hr == 0)
                  throw new UnexpectedTestResultException(String.Format("Second time should fail"));
               
		
                this.ResultCode = TEST_RESULTS.PASSED;
            }

        }


	/// <summary>
	/// 	Create WM7 user
	///         Purchase 1600 pts
	/// 	Purchase free gamertag change on web in WM7 with LIVEn client Type
	///         Make sure no pts charged
	/// </summary>
        [TestCase, TestCasePriority(1)]
        class P_LIVEnClient_WM7User_FreeGamerTag_LIVEnPlatform_WithPoints : UserTestBase
        {
            override protected void Execute()
            {
                // Create Moblie Account
                byte[] ownerPassportToken; 
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                //
                // SetAccountInfo
                //
                XRLXeSetAccountInfo saiRequest = new XRLXeSetAccountInfo();

                saiRequest.UserPuid = xuid;
                saiRequest.FirstName = "Tom";
                saiRequest.LastName = "Sawyer";
                saiRequest.Birthdate = DateTime.Now.AddYears(-21);

                ServerTestFramework.LiveService.UserAccount.AddressInfoData addr = new ServerTestFramework.LiveService.UserAccount.AddressInfoData();
                addr.SetDefaultAddress(XeUser.Country.US);
                saiRequest.AddressInfo = addr;

                ServerTestFramework.LiveService.UserAccount.PhoneInfoData phoneInfo = new ServerTestFramework.LiveService.UserAccount.PhoneInfoData();
                phoneInfo.PhonePrefix = "425";
                phoneInfo.PhoneNumber = "425-4244";
                saiRequest.PhoneInfo = phoneInfo;
                saiRequest.LanguageId = 1;

                if (!saiRequest.Execute())
                    throw new UnexpectedTestResultException("XeSetAccountInfo failed: " + saiRequest.GetDumpString());
                if (saiRequest.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XeSetAccountInfo returned XErr=0x{0:x}", saiRequest.XErr));

                Global.RO.Info("SetAccountInfo succeeded.");

                //
                // Purchase Points
                //
                XeUser user = new XeUser();
                user.UserPuid = xuid;
                user.CountryId = 103;
                user.MachinePuid = UacsCommon.RandomXenonMachineUid();

                XbosOffer.RewardUSUser1600Points(user);

                Global.RO.Info("RewardUSUser1600Points succeeded.");

                uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN);

                if (hr != 0)
                  throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));

                // Check PointsBalance after
                uint points_balance_after = user.GetPointsBalance();
                if (points_balance_after != 1600) 
                    throw new UnexpectedTestResultException(String.Format("points_balance_after is not 1600 but {0}", points_balance_after) );
               
		
                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

	    /// <summary>
	    /// 	Create WM7 user
	    /// 	Purchase free gamertag change on web in WM7 with Xboxcom client Type - Should fail
	    /// </summary>
        //[TestCase, TestCasePriority(2), Ignore]
        class N_LIVEnClient_WM7User_FreeGamerTag_XboxcomPlatform : UserTestBase
        {
            override protected void Execute()
            {
                // Create Moblie Account
                byte[] ownerPassportToken; 
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_XBOXCOM);

                if (hr == 0)
                  throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));
		
                this.ResultCode = TEST_RESULTS.PASSED;
            }

        }            


    /// <summary>
    /// 	Create WM7 user
    /// 	Purchase free gamertag change on web in WM7 with Xboxcom client Type - Should fail
    /// </summary>
    [TestCase, TestCasePriority(3), TestFrequency("Regression")]
        class P_XboxcomClient_WM7User_FreeGamerTag_XboxcomPlatform : UserTestBase
        {
            override protected void Execute()
            {
                // Create Moblie Account
                byte[] ownerPassportToken; 
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                uint hr = InnerExecute(xuid, LivecacheClientType.Xboxcom, XOn.XENON_DASH_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.CreateXboxcomMachineUid(), XOn.XPLT_INTERNAL_XBOXCOM);

                if (hr != 0)
                  throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }            

        /// <summary>
        ///     Create WM7 user
        ///     Purchase free gamertag change on web in WM7 with WEB_TITLE_ID
        /// </summary>
        [TestCase, TestCasePriority(1)]
            class P_LIVEnClient_WM7User_FreeGamerTag_LIVEnPlatform_WEB_TITLE_ID : UserTestBase
            {
                override protected void Execute()
                {
                    // Create Moblie Account
                    byte[] ownerPassportToken; 
                    ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                    uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.WEB_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN);

                    if (hr != 0)
                      throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));
    		
                    this.ResultCode = TEST_RESULTS.PASSED;
                }
            }            

            /// <summary>
            ///     Create WM7 user
            ///     Purchase charged gamertag change on web in WM7 with LIVEn client Type - should fail
            /// </summary>
                [TestCase, TestCasePriority(1)]
                class N_LIVEnClient_WM7User_ChargedGamerTag_LIVEnPlatform : UserTestBase
                {
                    override protected void Execute()
                    {
                        // Create Moblie Account
                        byte[] ownerPassportToken; 
                        ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
        
                        uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN);
        
                        if (hr != 0x80153007 )
                          throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));
                       
                
                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
                }

        /// <summary>
        ///     Create WM7 user
        ///     Purchase charged gamertag change on web in WM7 with LIVEn client Type but not WMMachineID - should fail
        /// </summary>
            [TestCase, TestCasePriority(1)]
            class N_LIVEnClient_WM7User_FreeGamerTag_LIVEnPlatform_NonWMMachineID : UserTestBase
            {
                override protected void Execute()
                {
                    // Create Moblie Account
                    byte[] ownerPassportToken; 
                    ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
        
                    uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.RandomXenonMachineUid(), XOn.XPLT_INTERNAL_LIVEN);
        
        if (hr != 0x80153007 )
                      throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));
                   
            
                    this.ResultCode = TEST_RESULTS.PASSED;
                }
            }

            /// <summary>
            ///     Create WM7 user
            ///     Purchase free gamertag change on web in WM7 with LIVEn client Type
            ///     Enumerate gamertag change offer on Xbox - should return paid one
            /// </summary>
           class P_WM7User_FreeGamerTag_LIVEn_Reflection : UserTestBase
            {
                override protected void Execute()
                {
                    //
                    // Create Moblie Account
                    //
                    byte[] ownerPassportToken; 
                    ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
    
                    string oldGamertag = UodbWS.GetGamertag(xuid);
            
                    //
                    // Purchase Free Gamertag
                    //
    
                    //LcBillingOffering lcBO = new LcBillingOffering(LivecacheClientType.LIVEn, TITLE_ID, false);
                    //uint hr = lcBO.PurchaseGamerTag(req,null);
    
                    //ExtendedAuthWrapper eaw = new ExtendedAuthWrapper();
                    //eaw.ClientPlatform = XOn.XPLT_INTERNAL_LIVEN;
    
    
                    string path = "xonline.common.webplatform.livecache.dll";
                    Assembly assem = Assembly.LoadFrom(path);
    
                    Type theLivecacheClientType = assem.GetType("xonline.common.webplatform.livecache.LivecacheClientType");
                    Object o = Activator.CreateInstance(theLivecacheClientType);
                    Type enumType = o.GetType();
                    System.Array values = Enum.GetValues(enumType);
                    object LiveCacheClientType_LIVEn = values.GetValue(4);      //  LIVEn        
    
                    Type Class_ExtendedAuthWrapper = assem.GetType("xonline.common.webplatform.livecache.ExtendedAuthWrapper");
                    Object Instance_ExtendedAuthWrapper = Activator.CreateInstance(Class_ExtendedAuthWrapper);
    
    
            
                    Type Class_LcBillingOffering = assem.GetType("xonline.common.webplatform.livecache.LcBillingOffering");
                    Object theObj = Activator.CreateInstance(Class_LcBillingOffering, new object[] { LiveCacheClientType_LIVEn, UacsCommon.DashTitleId_Xenon, Instance_ExtendedAuthWrapper,  false });
    
                    RandomEx rnd = new RandomEx();
                    string newGamerTag = rnd.GenerateRandomString("XEN", 15);
    
    
                    xonline.common.protocol.XeOfferPurchaseGamertagRequest req = new xonline.common.protocol.XeOfferPurchaseGamertagRequest();
                    req.userPuid = xuid;
                    req.gamertag = newGamerTag;
                    req.offerID = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);  
                    req.countryID = 103;
                    req.machinePuid = UacsCommon.CreateWM7MachineUid();
    
                    Type[] paramTypes = new Type[1];
                    paramTypes[0] = typeof(xonline.common.protocol.XeOfferPurchaseGamertagRequest);
                    MethodInfo PurchaseGamerTagInfo = Class_LcBillingOffering.GetMethod("PurchaseGamerTag", paramTypes);
    
                    Object[] parameters = new Object[1];
                    parameters[0] = req;
    
                    Global.RO.Info("Changing user 0x" + xuid.ToString("X") + " gamertag from " + oldGamertag + " to " + newGamerTag);
                    int hr =  (int) PurchaseGamerTagInfo.Invoke(theObj, parameters);
    
                    if (hr != 0)
                        throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchaseGamertag returned XErr=0x{0:x}", hr));
    
                   
            
                    this.ResultCode = TEST_RESULTS.PASSED;
                }
            }
            
            /// <summary>
            ///     Create Zune user
            ///         Purchase 1600 pts
            ///     Purchase charged Zune gamertag change with Zune client Type
            /// </summary>
                [TestCase, TestCasePriority(2), TestTag("Prerequisite", "title= 0xFFFE0777")]
                class P_ZuneClient_ZuneUser_ZuneGamerTag_ZunePlatform : UserTestBase
                {
                    override protected void Execute()
                    {
                        // Create Zune Account
                        XeUser user = new ArgoUser();
                        XbosOffer.RewardUSUser1600Points(user);
            
                        uint hr = InnerExecute(user.UserPuid, LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.ZuneGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_ZUNE);
            
                        if (hr != 0)
                          throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));

                        // Check PointsBalance after
                        uint points_balance_after = user.GetPointsBalance();
                        if (points_balance_after != 800) 
                            throw new UnexpectedTestResultException(String.Format("points_balance_after is not 1100 but {0}", points_balance_after) );
                        
                        
                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
               }
            
            /// <summary>
            ///     Create Zune user
            ///         Purchase 1600 pts
            ///     Purchase charged Zune gamertag change with Zune client Type
            /// </summary>
                [TestCase, TestCasePriority(2), TestTag("Prerequisite", "title= 0xFFFE0777")]
                class P_ZuneClient_WM7User_ZuneGamerTag_ZunePlatform : UserTestBase
                {
                    override protected void Execute()
                    {
                        // Create Moblie Account
                        byte[] ownerPassportToken; 
                        ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
            
                        uint hr = InnerExecute(xuid, LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.ZuneFreeGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_ZUNE);
            
                        if (hr != 0)
                          throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));

                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
               }
            
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xbos\MainClass.cs ===
using System;
using System.Runtime.InteropServices;
using System.Xml;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

using xonline.common.webplatform.livecache;

[assembly: RootNode(typeof(LiveCacheXbosTest.LiveCacheXbos))]

namespace LiveCacheXbosTest
{
    public class LiveCacheXbos : TestNode
    {
        public class AccountAuthDataProvider :  IExtendedAuthDataProvider
        {
            public ulong LivePuid { get { return _LivePuid; } }
            public byte Tier{ get { return _Tier; } }
            public uint[] Privileges { get { return _Privileges; } }
            public IPEndPoint ClientIPEndPoint { get { return _ClientIPEndPoint; } }

            public ulong XboxPuid { get { return _XboxPuid; } }
            public byte ClientPlatform { get { return _ClientPlatform; } }

            public ulong _LivePuid;
            public byte _Tier;
            public uint[] _Privileges;
            public IPEndPoint _ClientIPEndPoint;

            public ulong _XboxPuid;
            public byte _ClientPlatform;
        }

        public static void DefaultLivecacheLocaleHandler(out uint language, out uint country)
        {
            language = 1;
            country = 103;
        }

        public override void PreRun()
        {
            // set the ReceiveTimeout and SendTimeout for TCP and UDP connection
            // make it 130 seconds since some calls to CSAT (or billing 1box) can take a long time
            FDTransaction.sReceiveTimeOut = 65000 * 2;            
            //Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
            Global.XEnv.ExecuteXmgmtCommand(Interface.xbos_billing_offering, "e :xbos configcacherefresh");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\Presence\SendWebAlive2Test.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

using xonline.common.config;

//using Microsoft.XBox.Live.Server.Emulators.Framework;
//using Microsoft.XBox.Live.Server.Emulators.MusicNet;
//using Microsoft.XBox.Live.Server.Emulators.Dmp;
//using Microsoft.XBox.Live.Server.Emulators.Bdk;

using xonline.common.webplatform.livecache;
using xonline.common.protocol;


namespace LiveCachePresenceTest
{
    /// <summary>
    ///     Functional test cases for the LiveCache PurchaseMediaOffer API with Mobile products.
    /// </summary>
    [TestGroup, Owner("sujeetv"), TestCasePriority(1), TestFrequency("Regression")]
    public class SendWebAlive2 : TestNode
    {
        /// <summary>
        /// 	Create WM7 user
        /// 	Do a sample PH call
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class Presence_SendWebAlive2 : UserTestBase
        {
            override protected void Execute()
            {
                ulong xuid = 12345678;
                uint titleId = 222222;
                PresenceAccountAuthProvider aadp = new PresenceAccountAuthProvider();
                aadp.LivePuid = xuid;
                aadp.Tier = 3;
                aadp.ClientIPEndPoint = new IPEndPoint(0, 0);
                aadp.Privileges = new uint[8];
                aadp.Privileges[0] = 0;
                aadp.Privileges[1] = 0;
                aadp.Privileges[2] = 0;
                aadp.Privileges[3] = 0;
                aadp.Privileges[4] = 0;
                aadp.Privileges[5] = 0;
                aadp.Privileges[6] = 0x10000000;
                aadp.Privileges[7] = 0x9bf924fc;

                LcPresence lcPresence = new LcPresence(LivecacheClientType.LIVEn, titleId, null, aadp);

                try
                {
                    lcPresence.SendWebAlive2(xuid);
                }
                catch
                {
                    this.ResultCode = TEST_RESULTS.FAILED;
                }

                this.ResultCode = TEST_RESULTS.PASSED;
            }


            /// <summary>
            /// Provide account info
            /// </summary>
            public class PresenceAccountAuthProvider:IAccountAuthDataProvider
            {
                public ulong LivePuid { get; set; }
                public byte Tier { get; set; }
                public uint[] Privileges { get; set; }
                public IPEndPoint ClientIPEndPoint { get; set; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xbos\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xbos\FuncXeContentEnumerate2.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXbosTest
{
    /// <summary>
    ///     Functional tests for the XeContentEnumerate request.
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("Billing"), TestCasePriority(2)]
    public class XeContentEnumerate2 : TestNode
    {


	/// <summary>
	/// 	Create WM7 user 
	/// 	Enumerate free gamertag with LiveEn,  Dash Title
	/// </summary>
        [TestCase, TestCasePriority(1)]
        class P_GamertagChange_WM7User_LIVEnClient_DASHTitle : LiveCache_XeContentEnumerate_TestBase
        {
            protected override void Execute()
            {
                // Create Moblie Account
                byte[] ownerPassportToken; 
                xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                clientType=LivecacheClientType.LIVEn; 
                clientTitleId=XOn.XENON_DASH_TITLE_ID; 
                clientPlatform=XOn.XPLT_INTERNAL_LIVEN;

                xonline.common.protocol.ContentEnumerateResponse response = InnerExecute();
            
                Global.RO.Info("{0} gamertag offers returned", response.offersReturned);
            
                if(response.offersReturned != 1)
                    throw new UnexpectedTestResultException("Only one offer should be returned");
            
                for (int i = 0; i < response.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", response.infos[i].offerID.ToString("X"), response.infos[i].offerName);
                    if (response.infos[i].offerID != Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange))
                        throw new UnexpectedTestResultException("Free GamertagChange offer should be returned");
                }
            
                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        ///     Create WM7 user 
        ///     Enumerate free gamertag with LiveEn,  Dash Title
        ///     Enumerate free gamertag with LiveEn,  Dash Title one more time
        /// </summary>
            [TestCase, TestCasePriority(1)]
            class P_Twice : LiveCache_XeContentEnumerate_TestBase
            {
                protected override void Execute()
                {
                    // Create Moblie Account
                    byte[] ownerPassportToken; 
                    xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
        
                    clientType=LivecacheClientType.LIVEn; 
                    clientTitleId=XOn.XENON_DASH_TITLE_ID; 
                    clientPlatform=XOn.XPLT_INTERNAL_LIVEN;
        
                    xonline.common.protocol.ContentEnumerateResponse response = InnerExecute();
                
                    Global.RO.Info("{0} gamertag offers returned", response.offersReturned);
                
                if(response.offersReturned != 1)
                    throw new UnexpectedTestResultException("Only one offer should be returned");
                
                    for (int i = 0; i < response.offersReturned; i++)
                    {
                        Global.RO.Info("\t0x{0}  -  {1}", response.infos[i].offerID.ToString("X"), response.infos[i].offerName);
                        if (response.infos[i].offerID != Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange))
                            throw new UnexpectedTestResultException("Free GamertagChange offer should be returned");
                    }

                    // One more time
                    response = InnerExecute();
                
                    Global.RO.Info("{0} gamertag offers returned", response.offersReturned);
                
                if(response.offersReturned != 1)
                    throw new UnexpectedTestResultException("Only one offer should be returned");
                
                    for (int i = 0; i < response.offersReturned; i++)
                    {
                        Global.RO.Info("\t0x{0}  -  {1}", response.infos[i].offerID.ToString("X"), response.infos[i].offerName);
                        if (response.infos[i].offerID != Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange))
                            throw new UnexpectedTestResultException("Free GamertagChange offer should be returned");
                    }
                
                    this.ResultCode = TEST_RESULTS.PASSED;
                }
            }
        

        /// <summary>
        ///     Create WM7 user 
        ///     Purchase free gamertag
        ///     Enumerate charged gamertag with LiveEn, Dash Title
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class P_GamertagChange_WM7User_LIVEnClient_DASHTitle_SecondTime : LiveCache_XeContentEnumerate_TestBase
        {
            protected override void Execute()
            {
                LivecacheRequest.CurrentLocaleHandler = LiveCacheXbos.DefaultLivecacheLocaleHandler;
                
                // Create Moblie Account
                byte[] ownerPassportToken; 
                xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                // Purchase free gamertag
                uint hr = XeOfferPurchaseGamertag.InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN);
                
                if (hr != 0)
                  throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));
       
                // Content Enumerate for  Charged Gamertag
                clientType=LivecacheClientType.LIVEn; 
                clientTitleId=XOn.XENON_DASH_TITLE_ID; 
                clientPlatform=XOn.XPLT_INTERNAL_LIVEN;

                xonline.common.protocol.ContentEnumerateResponse response = InnerExecute();
        
        if(response.offersReturned != 1)
            throw new UnexpectedTestResultException("Only one offer should be returned");

                for (int i = 0; i < response.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", response.infos[i].offerID.ToString("X"), response.infos[i].offerName);
                    if (response.infos[i].offerID != Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange))
                        throw new UnexpectedTestResultException("Charged GamertagChange offer should be returned");
                }
        
                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

	/// <summary>
	/// 	Create WM7 user 
	/// 	Enumerate free gamertag with Zune, Crux Title
	/// </summary>
        [TestCase, TestCasePriority(2)]
        class P_GamertagChange_WM7User_LIVEnClient_CruxTitle_ZunePlatform : LiveCache_XeContentEnumerate_TestBase
        {
            protected override void Execute()
            {
                LivecacheRequest.CurrentLocaleHandler = LiveCacheXbos.DefaultLivecacheLocaleHandler;
                
                // Create Moblie Account
                byte[] ownerPassportToken; 
                xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
        
                // Content Enumerate for  Free Gamertag
                clientType=LivecacheClientType.LIVEn; 
                clientTitleId=XOn.CRUX_TITLE_ID; 
                clientPlatform=XOn.XPLT_INTERNAL_ZUNE;

                xonline.common.protocol.ContentEnumerateResponse response = InnerExecute();

                if(response.offersReturned != 1)
                    throw new UnexpectedTestResultException("Only one offer should be returned");

                for (int i = 0; i < response.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", response.infos[i].offerID.ToString("X"), response.infos[i].offerName);
                    if (response.infos[i].offerID != Offers.GetBaseOfferId(Offers.BaseOffers.ZuneFreeGamertagChange))
                        throw new UnexpectedTestResultException("Free GamertagChange offer should be returned");
                }
        
                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }
    
   
	/// <summary>
	/// 	Create Zune user 
	/// 	Enumerate free gamertag with Zune,  Crux Title
	/// </summary>
    [TestCase, TestCasePriority(2)]
        class P_GamertagChange_ZuneUser_LIVEnClient_CruxTitle_ZunePlatform : LiveCache_XeContentEnumerate_TestBase
        {
            protected override void Execute()
            {
                LivecacheRequest.CurrentLocaleHandler = LiveCacheXbos.DefaultLivecacheLocaleHandler;
                
                // Create Zune Account
                XeUser user = new ArgoUser();
                xuid = user.UserPuid;

                // Content Enumerate for  Free Gamertag
                clientType=LivecacheClientType.LIVEn; 
                clientTitleId=XOn.CRUX_TITLE_ID; 
                clientPlatform=XOn.XPLT_INTERNAL_ZUNE;

                xonline.common.protocol.ContentEnumerateResponse response = InnerExecute();

                if(response.offersReturned != 1)
                    throw new UnexpectedTestResultException("Only one offer should be returned");

                for (int i = 0; i < response.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", response.infos[i].offerID.ToString("X"), response.infos[i].offerName);
                    if (response.infos[i].offerID != Offers.GetBaseOfferId(Offers.BaseOffers.ZuneGamertagChange))
                        throw new UnexpectedTestResultException("Zune GamertagChange offer should be returned");
                }

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }


	/// <summary>
	/// 	Create WM7 user 
	/// 	Enumerate free gamertag with Zune, Crux Title
	/// </summary>
        [TestCase, TestCasePriority(2)]
        class P_GamertagChange_WM7User_ZuneClient_CruxTitle_ZunePlatform : LiveCache_XeContentEnumerate_TestBase
        {
            protected override void Execute()
            {
                LivecacheRequest.CurrentLocaleHandler = LiveCacheXbos.DefaultLivecacheLocaleHandler;
                
                // Create Moblie Account
                byte[] ownerPassportToken; 
                xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
        
                // Content Enumerate for  Free Gamertag
                clientType=LivecacheClientType.Zune; 
                clientTitleId=XOn.CRUX_TITLE_ID; 
                clientPlatform=XOn.XPLT_INTERNAL_ZUNE;

                xonline.common.protocol.ContentEnumerateResponse response = InnerExecute();

                if(response.offersReturned != 1)
                    throw new UnexpectedTestResultException("Only one offer should be returned");

                for (int i = 0; i < response.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", response.infos[i].offerID.ToString("X"), response.infos[i].offerName);
                    if (response.infos[i].offerID != Offers.GetBaseOfferId(Offers.BaseOffers.ZuneFreeGamertagChange))
                        throw new UnexpectedTestResultException("Free GamertagChange offer should be returned");
                }
        
                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }
    
        /// <summary>
        ///     Create WM7 user 
        ///     Purchase free gamertag
        ///     Enumerate charged gamertag with Zune, Crux Title
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_GamertagChange_WM7User_ZuneClient_CruxTitle_ZunePlatform_SecondTime : LiveCache_XeContentEnumerate_TestBase
        {
            protected override void Execute()
            {
                LivecacheRequest.CurrentLocaleHandler = LiveCacheXbos.DefaultLivecacheLocaleHandler;
                
                // Create Moblie Account
                byte[] ownerPassportToken; 
                xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
        
                // Purchase free gamertag
                uint hr = XeOfferPurchaseGamertag.InnerExecute(xuid, LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange), UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN);
                
                if (hr != 0)
                  throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseGamerTag returned 0x{0:x}", hr));
        
                // Content Enumerate for  Charged Gamertag
                clientType=LivecacheClientType.Zune; 
                clientTitleId=XOn.CRUX_TITLE_ID; 
                clientPlatform=XOn.XPLT_INTERNAL_ZUNE;

                xonline.common.protocol.ContentEnumerateResponse response = InnerExecute();
        
        if(response.offersReturned != 1)
            throw new UnexpectedTestResultException("Only one offer should be returned");

                for (int i = 0; i < response.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", response.infos[i].offerID.ToString("X"), response.infos[i].offerName);
                    if (response.infos[i].offerID != Offers.GetBaseOfferId(Offers.BaseOffers.ZuneGamertagChange))
                        throw new UnexpectedTestResultException("Charged ZuneGamertagChange offer should be returned");
                }
        
                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }
    
	/// <summary>
	/// 	Create Zune user 
	/// 	Enumerate free gamertag with Zune,  Crux Title
	/// </summary>
        [TestCase, TestCasePriority(2)]
        class P_GamertagChange_ZuneUser_ZuneClient_CruxTitle_ZunePlatform : LiveCache_XeContentEnumerate_TestBase
        {
            protected override void Execute()
            {
                LivecacheRequest.CurrentLocaleHandler = LiveCacheXbos.DefaultLivecacheLocaleHandler;
                
                // Create Zune Account
                XeUser user = new ArgoUser();
                xuid = user.UserPuid;

                // Content Enumerate for  Free Gamertag
                clientType=LivecacheClientType.Zune; 
                clientTitleId=XOn.CRUX_TITLE_ID; 
                clientPlatform=XOn.XPLT_INTERNAL_ZUNE;

                xonline.common.protocol.ContentEnumerateResponse response = InnerExecute();

                if(response.offersReturned != 1)
                    throw new UnexpectedTestResultException("Only one offer should be returned");

                for (int i = 0; i < response.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", response.infos[i].offerID.ToString("X"), response.infos[i].offerName);
                    if (response.infos[i].offerID != Offers.GetBaseOfferId(Offers.BaseOffers.ZuneGamertagChange))
                        throw new UnexpectedTestResultException("Zune GamertagChange offer should be returned");
                }

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        class LiveCache_XeContentEnumerate_TestBase : TestBase
        {
            protected ulong xuid; 
            protected LivecacheClientType clientType; 
            protected uint clientTitleId; 
            //protected ulong offerID; 
            //protected ulong machinePuid; 
            protected byte clientPlatform;
            
            protected xonline.common.protocol.ContentEnumerateResponse InnerExecute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();

                LivecacheRequest.CurrentLocaleHandler = LiveCacheXbos.DefaultLivecacheLocaleHandler;
                
                // Content Enumerate for  Free Gamertag
                xonline.common.protocol.ContentEnumerateRequest request = new xonline.common.protocol.ContentEnumerateRequest();
                request.userPuid = xuid;
                request.countryID = 103;
                request.languageID = 1;
                request.gameRating = 255;
                request.offerType = (uint)OfferingTypeEnum.GamertagChange;
                request.titleID = clientTitleId;
                request.startingIndex = 0;
                request.maxResults = 100;
                request.tierRequired = 3;
                request.paymentType = 0xffffffff;
                request.titleCategories = 0xffffffff;
                
                LiveCacheXbos.AccountAuthDataProvider aadp = new LiveCacheXbos.AccountAuthDataProvider();
                aadp._LivePuid = xuid;
                aadp._Tier = 3;
                aadp._Privileges = new uint[8];
                aadp._Privileges[0] = 0;
                aadp._Privileges[1] = 0;
                aadp._Privileges[2] = 0;
                aadp._Privileges[3] = 0;
                aadp._Privileges[4] = 0;
                aadp._Privileges[5] = 0;
                aadp._Privileges[6] = 0x10000000;
                aadp._Privileges[7] = 0x9bf924fc;
                aadp._ClientPlatform = clientPlatform;
                
                Global.RO.Info("ContentEnumerateRequest for user 0x" + xuid.ToString("X"));
                LcBillingOffering lcBO = new LcBillingOffering(clientType, clientTitleId, aadp, false);
                xonline.common.protocol.ContentEnumerateResponse response = lcBO.EnumerateContent(request);
                
                Global.RO.Info("{0} gamertag offers returned", response.offersReturned);

                return response;
            }
            
            protected override void Execute()
            {
                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xbos\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xbos\PreviewProductPurchase.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using TestUserAccount=ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using xonline.common.protocol;

using xonline.common.webplatform.livecache;
using System.Net;

namespace PreviewProductpurchase
{
    /// <summary>
    ///     Functional tests for the PreviewProductpurchase request.
    /// </summary>
    [TestGroup, Owner( "yuanfeiw" ), TestFrequency( "Regression" ), EnvRequirement( "Billing" ), TestCasePriority( 2 )]
    public class PreviewProductPurchaseGroup : TestNode
    {

        [TestCase, TestCasePriority(1)]
        class P_PreviewProductPurchase_Livecache_MainLine : TestBase
        {
            private LivecacheClientType clientType;

            private uint clientTitleId;

            private byte clientPlatform;

            protected override void Execute()
            {
                clientType = LivecacheClientType.Xboxcom;
                clientTitleId = XOn.XENON_DASH_TITLE_ID;
                clientPlatform = XOn.XPLT_INTERNAL_XBOXCOM;

                TestUserAccount.UacsCommon.LiveCacheResetInitializedClientType();

                ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.SilverFreeTrial);

                Global.RO.Info("Creating a user using offer 0x" + offerId.ToString("X") + " ... ");
                TestUserAccount.XeUser user = new TestUserAccount.XeUser();

                user.PaymentInstrumentType = TestUserAccount.PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
                user.CreditCardInfo = new TestUserAccount.CreditCardInfoData();
                user.CreditCardInfo.AccountHolderName = "Peter Griffon";
                user.CreditCardInfo.CardType = (byte)TestUserAccount.CreditCardInfoData.CreditCardType.Visa;
                user.CreditCardInfo.AccountNumber = CreditCardRandomizer.GetRandomAccountNumber("visa");
                user.CreditCardInfo.CcvNumber = "555";
                user.CreditCardInfo.ExpirationDate = DateTime.UtcNow.AddYears(2);

                user.OfferId = offerId;
                user.MachinePuid = PreviewProductUtils.GetRandomXenonMachineUid();

                user.Create();


                Guid[] offerIds = new Guid[] { Offers.GetLiveSubCatalogOfferGuid( Offers.BaseOffers.GoldCC1Year ) };
                int[] mediaTypes = new int[] { xonline.common.billing.MediaTypeInfo.LiveSubscription };//Live subscription

                PreviewProductPurchaseRequest req = new PreviewProductPurchaseRequest();

                req.machinePuid = user.MachinePuid;
                req.userPuid = user.UserPuid;

                xonline.common.protocol.OfferProductInfo[] offers = new xonline.common.protocol.OfferProductInfo[offerIds.Length];
                for (int ii = 0; ii < offerIds.Length; ii++)
                {
                    offers[ii] = new xonline.common.protocol.OfferProductInfo();
                    offers[ii].productTypeId = mediaTypes[ii];
                    offers[ii].offerId = offerIds[ii];
                }
                req.offers = offers;
                req.paymentType = (uint)1;
                req.paymentInstrumentID = user.GetPaymentInstruments()[0].PaymentInstrumentId;
                req.storeId = 1;

                //Build the Authdata
                LiveCacheAuthData authData= new LiveCacheAuthData();
                authData._LivePuid = user.UserPuid;
                authData._Tier = 6;
                authData._Privileges = new uint[8];
                authData._Privileges[0] = 0;
                authData._Privileges[1] = 0;
                authData._Privileges[2] = 0;
                authData._Privileges[3] = 0;
                authData._Privileges[4] = 0;
                authData._Privileges[5] = 0;
                authData._Privileges[6] = 0x10000000;
                authData._Privileges[7] = 0x9bf924fc;
                authData._ClientPlatform = clientPlatform;

                Global.RO.Info("calling previeProductPurchase for user 0x" + user.UserPuid.ToString("X"));

                LcBillingOffering lcBO = new LcBillingOffering(clientType, clientTitleId, authData, false);

                PreviewProductPurchaseResponse response = lcBO.PreviewProductPurchase(req);

                //No errors.Mark the test as passed
                if (response != null)
                {
                    this.ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }
    }
    public class PreviewProductUtils
    {
        private static Random m_rnd = new Random();
        public static ulong GetRandomULong()
        {
            int i = m_rnd.Next();
            int j = m_rnd.Next();
            return (((ulong)i) << 32) + (ulong)j;
        }
        public static ulong GetRandomXenonMachineUid()
        {
            return GetRandomULong() & 0x0000ffffffffffff | 0xfa00000000000000;
        }
    }

    public class LiveCacheAuthData : IExtendedAuthDataProvider
    {
        public ulong LivePuid { get { return _LivePuid; } }
        public byte Tier { get { return _Tier; } }
        public uint[] Privileges { get { return _Privileges; } }
        public IPEndPoint ClientIPEndPoint { get { return _ClientIPEndPoint; } }

        public ulong XboxPuid { get { return _XboxPuid; } }
        public byte ClientPlatform { get { return _ClientPlatform; } }

        public ulong _LivePuid;
        public byte _Tier;
        public uint[] _Privileges;
        public IPEndPoint _ClientIPEndPoint;

        public ulong _XboxPuid;
        public byte _ClientPlatform;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xbos\MobileOfferPurchase.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

using xonline.common.config;
using xonline.common.acctutil;

using Microsoft.XBox.Live.Server.Emulators.Framework;
using Microsoft.XBox.Live.Server.Emulators.MusicNet;
using Microsoft.XBox.Live.Server.Emulators.Dmp;
using Microsoft.XBox.Live.Server.Emulators.Bdk;
using XeXbos;

using xonline.common.webplatform.livecache;


namespace LiveCacheXbosTest
{
    /// <summary>
    ///     Functional test cases for the LiveCache PurchaseMediaOffer API with Mobile products.
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(1), TestFrequency("Regression"), EnvRequirement("Billing")]
    public class MobilePurchase : TestNode
    {
        private static Guid MobileOfferId = new Guid("30000003-0000-4010-8000-0000584107F6");
        private static string MobilePurchaseToken = "4KYRG-MOBIL-00TOK-PURCH-TEST1";

        public static bool VerifyPurchaseOriginAndTitle(ulong userPuid, byte _expectedOrigin, uint _expectedPurchaseTitle)
        {
            PurchaseTranasction transaction = UserCommercedbWS.GetDmpPurchaseTransaction(userPuid);
            if (transaction == null)
            {
                Global.RO.Warn("Nothing returned for ti_purchase_origin and i_purchase_title_id");
                return false;
            }

            byte purchaseOrigin = transaction.Origin;
            uint purchaseTitle = transaction.TitleId;
            if (purchaseOrigin == _expectedOrigin && purchaseTitle == _expectedPurchaseTitle)
            {
                Global.RO.Info("ti_purchase_origin : {0}", purchaseOrigin);
                Global.RO.Info("i_purchasing_title_id : 0x{0}", purchaseTitle.ToString("X"));
                return true;
            }
            else
            {
                Global.RO.Warn("ti_purchase_origin : {0} but _expectedOrigin :{1}", purchaseOrigin, _expectedOrigin);
                Global.RO.Warn("i_purchasing_title_id : 0x{0} but _expectedTitleId :0x{1}", purchaseTitle.ToString("X"), _expectedPurchaseTitle.ToString("X"));
                return false;
            }
        }

        public static uint InnerExecute(ulong xuid, LivecacheClientType clientType, uint clientTitleId, Guid offerID, live.common.PaymentTypeEnum paymentType, string token, uint expectedPrice, ulong machinePuid, byte clientPlatform)
        {
            UacsCommon.LiveCacheResetInitializedClientType();

            LivecacheRequest.CurrentLocaleHandler = LiveCacheXbos.DefaultLivecacheLocaleHandler;

            if (token == null)
                token = "";


            // payment info
            xonline.common.protocol.AddPaymentInstrumentRequest payment = new xonline.common.protocol.AddPaymentInstrumentRequest();
            payment.userPuid = xuid;
            payment.machinePuid = machinePuid;
            payment.paymentInstrumentType = (byte)xonline.common.billing.PaymentInstrumentTypeEnum.CreditCard;
            payment.addressInfo = AcctUtil.GenerateFakeAddress((byte)live.common.XOn.XONLINE_COUNTRY_UNITED_STATES);
            payment.phoneInfo = AcctUtil.GenerateFakePhone();
            payment.creditCardInfo = AcctUtil.GenerateFakeCCInfo();
            payment.directDebitInfo = new xonline.common.protocol.DirectDebitInfoData();

            // point purchase info
            xonline.common.protocol.XeOfferPurchaseRequest points = new xonline.common.protocol.XeOfferPurchaseRequest();
            points.userPuid = xuid;
            points.machinePuid = machinePuid;
            points.countryID = (byte)live.common.XOn.XONLINE_COUNTRY_UNITED_STATES; // should be 103
            points.languageID = (byte)1; // english
            points.paymentType = (uint)live.common.PaymentTypeEnum.CreditCard;
            points.tier = 3;
            // 1000 point offer
            points.offerIDs = new ulong[1] { (ulong)0xFFFE07D10FF00005 };

            // mobile offer info
            xonline.common.protocol.OfferMediaTypeExpectedPrice offer = new xonline.common.protocol.OfferMediaTypeExpectedPrice();
            offer.offerId = offerID;
            offer.mediaTypeId = 59;
            offer.expectedPriceWhole = expectedPrice;
            offer.expectedPriceFractional = 0u;

            // mobile offer purchase info
            xonline.common.protocol.PurchaseMediaOffersRequest req = new xonline.common.protocol.PurchaseMediaOffersRequest();
            req.userPuid = xuid;
            req.offers = new xonline.common.protocol.OfferMediaTypeExpectedPrice[1] { offer };
            req.machinePuid = machinePuid;
            req.paymentType = (uint)paymentType;
            req.storeId = 5;
            req.paymentInstrumentID = "";
            req.billingToken = token;

            // no subscription extensions
            req.subscriptionPurchaseInfo = new xonline.common.protocol.SubscriptionPurchaseInfo();

            // account auth info
            LiveCacheXbos.AccountAuthDataProvider aadp = new LiveCacheXbos.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._XboxPuid = machinePuid;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;

            aadp._ClientPlatform = clientPlatform;


            Global.RO.Info("Purchasing with user 0x" + xuid.ToString("X"));
            LcBillingOffering lcBO = new LcBillingOffering(clientType, clientTitleId, aadp, false);


            Global.RO.Info("Adding user payment info");
            // add payment info
            string paymentId;
            try
            {
                lcBO.AddPaymentInstrument(payment, out paymentId);
            }
            catch (Exception e)
            {
                throw new UnexpectedTestResultException(String.Format("Unable to add payment information."), e);
            }

            // need to set payment id info from the last add call
            points.paymentInstrumentID = paymentId;

            // purchase some points
            uint hr = lcBO.PurchasePoints(points);
            Global.RO.Info(String.Format("lcBO.PurchasePoints returned 0x{0:x}", hr));

            if (hr != 0)
            {
                throw new UnexpectedTestResultException(String.Format("Unable to purchase points."));
            }


            // purchase media offer
            hr = lcBO.PurchaseMediaOffers(req);
            Global.RO.Info(String.Format("lcBO.PurchaseMediaOffers returned 0x{0:x}", hr));

            if (hr != 0)
            {
                throw new UnexpectedTestResultException(String.Format("Purchase failed."));
            }

            return hr;
        }

        /// <summary>
        /// 	Create WM7 user
        /// 	Purchase Mobile PDLC using points
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class P_LIVEnClient_WM7User_PurchaseMobile_Point_LIVEnPlatform : UserTestBase
        {
            override protected void Execute()
            {
                // Create Moblie Account
                byte[] ownerPassportToken;
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, MobileOfferId, live.common.PaymentTypeEnum.Points, "", 800u, UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN);

                if (hr != 0)
                    throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseMediaOffers returned 0x{0:x}", hr));


                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// 	Create WM7 user
        /// 	Purchase Mobile PDLC using a token
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class P_LIVEnClient_WM7User_PurchaseMobile_Token_LIVEnPlatform : UserTestBase
        {
            override protected void Execute()
            {
                // Create Moblie Account
                byte[] ownerPassportToken;
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                uint hr = InnerExecute(xuid, LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, MobileOfferId, live.common.PaymentTypeEnum.Token, MobilePurchaseToken, 800u, UacsCommon.CreateWM7MachineUid(), XOn.XPLT_INTERNAL_LIVEN);
               
                if (hr != 0)
                    throw new UnexpectedTestResultException(String.Format("lcBO.PurchaseMediaOffers returned 0x{0:x}", hr));


                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xmachine\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xbos\provisionchange.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Net;
using System.Xml;
using System.Web.Services.Protocols; // SoapException
using System.Net.Sockets;
using System.IO;


using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.ZuneSignIn;

using ServerTestFramework.Utilities;
using stfu = ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.FakeSG;

using XblUserTier = live.common.XblUserTier;
using PassportType = live.common.PassportType;
using CountryId = live.common.CountryId;
using ServiceTypeEnum = live.protocol.ServiceTypeEnum;
using ClientTypeEnum = live.protocol.ClientTypeEnum;
using Microsoft.XBox.Live.Server.Emulators.Framework;
using Microsoft.XBox.Live.Server.Emulators.MusicNet;
using Microsoft.XBox.Live.Server.Emulators.Dmp;
using Microsoft.XBox.Live.Server.Emulators.Bdk;


using live.internaltest;
using live.protocol;
using live.client;
using live.server;
//using live.common;
using System.Threading;


namespace XeXbosPurchase.Functional
{
    //[TestGroup, Owner("PeFan"), TestFrequency("Regression"), EnvRequirement("Billing")]
    public class ProvisionChange : TestNode
    {

        public enum UserType : int
        {
            SILVER = 3,
            GOLD = 6
        };

        [TestGroupSetup]
        public void Setup()
        {
        }

        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        public const ulong MUSICNET_MONTHLY_SUB_OFFERID = 0xFFFE077788000000;

        [TestCase]
        public class P_XeOfferPurchase : UserTestBase
        {
            protected override void Execute()
            {
                XeUser user = XbosUser.XenonGoldUser();

                string paymentInstrumentId = user.AddPaymentInstrumentVisa();

                XRLXeOfferPurchase request = new XRLXeOfferPurchase();

                request.UserPuid = user.UserPuid;
                request.OfferID = MUSICNET_MONTHLY_SUB_OFFERID; // monthly cc offer
                //request.SchemaVersion = WireData.MakeSchemaVersion(1,0);
                request.LanguageID = user.LanguageId;
                request.CountryID = user.CountryId;
                request.Tier = (byte)UodbWS.GetUserTier(user.UserPuid);
                request.PaymentType = (uint)PaymentTypeEnum.CreditCard;
                request.PaymentInstrumentID = paymentInstrumentId; //paymentInstrumentId;

                request.CustomHeader += stfu.BehaviorInjection.AddNpdbOverride("musicnet_getServiceConfigurationUrl", "http//GARYT-DEV1/MusicNot.asmx?wsdl", false);
                request.CustomHeader += stfu.BehaviorInjection.AddNpdbOverride("crux_useMusicNetForProvisioning", "no", false);


                if (!request.Execute())
                    throw new UnexpectedTestResultException("XRLXeOfferPurchase failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x}", request.XErr));

                ResultCode = TEST_RESULTS.PASSED;
            }
        }


        [TestCase]
        class P_ArgoAccount : UserTestBase
        {
            override protected void Execute()
            {
                XeUser user0 = new XeUser(true);
                XRLXeCreateLiveAccount request = new XRLXeCreateLiveAccount();
                XRLXeCreateLiveAccountResponse response;
                XRLXeCreateLiveAccountExtra createLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                createLiveAccountExtra.CreateArgoProfile = true;

                UacsCommon.PassportUser passportUser = UACS.CreatePassportUser();

                request.MachinePuid = user0.MachinePuid;
                request.TitleId = 0xfffe07d1;
                request.FirstName = "John";
                request.LastName = "Smith";
                request.Gamertag = user0.Gamertag;
                request.SignedUserPassportPuid = passportUser.SessionToken;
                request.SignedOwnerPassportPuid = passportUser.SessionToken;
                request.OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.SilverFreeTrial);
                request.BillingToken = "";            // billing token?
                request.Birthdate = DateTime.Now.AddYears(-23);
                request.Email = passportUser.MemberName;
                request.LanguageId = 1;              // English
                request.CountryId = 103;             // US
                request.MsftOptIn = 0;
                request.PartnerOptIn = 0;

                request.AddressInfo = new ServerTestFramework.LiveService.UserAccount.AddressInfoData();
                request.AddressInfo.Street1 = "15 street";
                request.AddressInfo.State = "WA";
                request.AddressInfo.City = "Redmond";
                request.AddressInfo.PostalCode = "98052";

                request.PhoneInfo = new ServerTestFramework.LiveService.UserAccount.PhoneInfoData();
                request.PhoneInfo.PhonePrefix = "425";
                request.PhoneInfo.PhoneNumber = "123-4567";

                request.PaymentInstrumentType = (byte)ServerTestFramework.LiveService.UserAccount.PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.None;
                request.CreditCardInfo = new ServerTestFramework.LiveService.UserAccount.CreditCardInfoData();  // do we need to init these even if we're not using them?
                request.DirectDebitInfo = new ServerTestFramework.LiveService.UserAccount.DirectDebitInfoData();  // do we need to init these even if we're not using them?

                request.ReservedBytes = (byte[])createLiveAccountExtra;
                request.offlineXuid = 0;

                request.CustomHeader += stfu.BehaviorInjection.AddNpdbOverride("musicnet_getServiceConfigurationUrl", "http//GARYT-DEV/MusicNot.asmx?wsdl", false);
                request.CustomHeader +=stfu.BehaviorInjection.AddNpdbOverride("crux_useMusicNetForProvisioning", "no", false);

                if (!request.Execute(out response)) throw new UnexpectedTestResultException(request.GetDumpString());
                if (request.XErr != HResult.S_OK) throw new UnexpectedTestResultException(request.GetDumpString());

                Global.RO.Info("user 0x{0} created", response.UserPuid.ToString("X"));
                UserInfo info = UodbWS.GetUserInfo(response.UserPuid);
                ValueCheck.TestNonZero("offline_xuid", info.offlineXuid);
                

                ResultCode = TEST_RESULTS.PASSED;
            }
        }



        [TestCase]
        public class P_ZuneSignIn : LiveTestNode

        {
            private UacsCommon2 uacs = new UacsCommon2();

            public void OverrideZestSetting(WebRequest request)
            {
                request.Headers.Add("BEHAVIOR_INJECTIONS", "NpdbOverride;setting=musicnet_getServiceConfigurationUrl:value=http//GARYT-DEV1/MusicNot.asmx?wsdl;");

                request.Headers.Add("BEHAVIOR_INJECTIONS", "NpdbOverride;setting=crux_useMusicNetForProvisioning:value=no;");
            }


            public override void Execute()
            {
            XblUser user = uacs.CreateUser(ServerTestFramework.LiveService.UserAccount.UserType.Silver, true, true);
            PassportInfo pi = (new UacsCommon2()).GetUserPassportInfo(user);

            string ipv4addr = GetIPv4Address().ToString();



            Thread.Sleep(30000);
            UserAccountServiceWrapper xuacs =
                new UserAccountServiceWrapper(pi.PassportPuid, ipv4addr);

            xuacs.UpdateHttpHeader = OverrideZestSetting;

            SignInResults actualResults = xuacs.SignIn();

            
            ValueCheck.TestHR("HResult",
                              0,
                              actualResults.ErrorInfo.HResult);
            ResultCode = TEST_RESULTS.PASSED;
            }


            public static IPAddress GetIPv4Address()
            {
                foreach (IPAddress ipAddr in Dns.GetHostEntry(Dns.GetHostName()).AddressList)
                {
                    if (ipAddr.AddressFamily == AddressFamily.InterNetwork)
                    {
                        return ipAddr;
                    }
                }

                return null;
            }
       }


        [TestCase]
        public class P_GetUserAuthorization : LiveTestNode
        {
            public override void Execute()
            {
                live.common.XblUser user = live.internaltest.UserCreator.CreateUser(live.common.XblUserTier.Silver, PassportType.Real, CountryId.US, UserCreatorOption.Zune);
                ZuneClient client = new ZuneClient();

                client.OnPreSendRequest += Client_OnPreSendRequest;
                GetUserAuthorizationRequest req = new GetUserAuthorizationRequest();
                GetUserAuthorizationResponse resp = new GetUserAuthorizationResponse();

                req.serviceType = ServiceTypeEnum.Zune;
                req.titleId = XOn.CRUX_TITLE_ID;
                if (string.IsNullOrEmpty(client.CustomHeaders["X-ClientType"]))
                    client.CustomHeaders["X-ClientType"] = "dorado";

                uint hr = UACS.SendRequest(client, user, req, resp);
                live.common.Throw.IfXErrFailed(hr);
                ValueCheck.Test("XboxPuid", user.Puid, resp.AccountInfo.XboxPuid);

                ResultCode = TEST_RESULTS.PASSED;
            }
            //  public SettingState OverrideSetting(string component, string server, string _setting, string _settingValue, int siteId)
            void Client_OnPreSendRequest(object sender, live.common.OnPreSendRequestEventArgs e)
            {
                e.WebHeaders.Add(stfu.BehaviorInjection.AddNpdbOverride("musicnet_getServiceConfigurationUrl", "http//GARYT-DEV/MusicNot.asmx?wsdl", false));
                e.WebHeaders.Add(stfu.BehaviorInjection.AddNpdbOverride("crux_useMusicNetForProvisioning", "no", false));
            }
        }
        

        [TestCase]
        public class P_Cancel_Zune_FreeTrial_Gold :  UserTestBase
        {
            protected override void Execute()
            {


                ulong zuneOffer = 0xFFFE077788000001;//Zune 3 MOnth CC Pass
                ulong goldOffer = Offers.GetBaseOfferId(Offers.BaseOffers.GoldCC1Year);

                XRLXeSubscriptionEnumerate request = new XRLXeSubscriptionEnumerate();
                XRLXeSubscriptionEnumerateResponse response = new XRLXeSubscriptionEnumerateResponse();

                XeUser user = new XeUser(true);
                user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                user.CreateLiveAccountExtra.CreateArgoProfile = true;

                ulong puid = user.Create();


                /*XeSubscriptionEnumerate.XeSubEnumerateTestBase.*/PurchaseSubscription(user, zuneOffer);

                Global.RO.Info("Cancel live Subscription  ");

                XRLOfferingCancel cancel = new XRLOfferingCancel();
                cancel.userPuid = user.UserPuid;
                cancel.offeringId = zuneOffer;
              
                cancel.CustomHeader += stfu.BehaviorInjection.AddNpdbOverride("musicnet_getServiceConfigurationUrl", "http://GARYT-DEV/MusicNot.asmx?wsdl", false);
                cancel.CustomHeader += stfu.BehaviorInjection.AddNpdbOverride("crux_useMusicNetForProvisioning", "no", false);           

                
                if (!cancel.Execute())
                {
                    throw new UnexpectedTestResultException("Failed to cancel: " + cancel.GetDumpString());
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }




        //
        //  Handles the common portions of purchasing a subscription for both prepaid and CC subs.
        //
        public static XRLXeOfferPurchase InitOfferPurchaseRequest(XeUser user, ulong offerId)
        {
            XRLXeOfferPurchase request = new XRLXeOfferPurchase();
            request.SchemaVersion = live.protocol.WireData.MakeSchemaVersion(2, 0);
            request.UserPuid = user.UserPuid;

            //
            //  Set the user tier to Silver or Gold
            //
            if (user.IsSilverTier)
            {
                request.Tier = (int)UserType.SILVER;
            }
            else request.Tier = (int)UserType.GOLD;

            if (offerId == Offers.GetBaseOfferId(Offers.BaseOffers.GoldCC1Year))
                request.Tier = (int)UserType.GOLD;

            ulong[] offerIDs = new ulong[1];
            offerIDs[0] = offerId;

            request.OfferIDs = offerIDs;
            request.OfferIDLength = (uint)offerIDs.Length;
            return request;
        }



        //
        //  Execute a purchase request.  This also factors out common pieces of PurchaseSubscription.
        //
        public static void ExecutePurchaseRequest(XRLXeOfferPurchase request, ulong offerId)
        {
            Global.RO.Info("Purchasing Subscription offerid " + offerId.ToString("X"));
            if (!request.Execute())
            {
                throw new UnexpectedTestResultException("XRLXeOfferPurchase failed: " + request.GetDumpString());
            }
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x}",
                                                                      request.XErr));
        }

        //
        //  Purchase a subscription.  This is designed for redeeming prepaid vouchers only.
        //
        public static void PurchaseSubscription(XeUser user, ulong offerId, string voucher)
        {
            XRLXeOfferPurchase request = InitOfferPurchaseRequest(user, offerId);
            request.PaymentType = (uint)PaymentTypeEnum.Token;
            request.BillingToken = voucher;
            ExecutePurchaseRequest(request, offerId);
        }

        //
        //  Purchase a subscription.  Adds a Visa to the user as a side effect.  This is designed
        //  for credit card purchases only.
        //
        public static void PurchaseSubscription(XeUser user, ulong offerId)
        {
            XRLXeOfferPurchase request = InitOfferPurchaseRequest(user, offerId);

            string paymentInstrument = user.AddPaymentInstrumentVisa();
            request.PaymentType = (uint)PaymentTypeEnum.CreditCard;
            request.PaymentInstrumentID = paymentInstrument;

            ExecutePurchaseRequest(request, offerId);
        }
  

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xmachine\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xbos\PurchaseHistory.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

using xonline.common.config;
using xonline.common.acctutil;

using Microsoft.XBox.Live.Server.Emulators.Framework;
using Microsoft.XBox.Live.Server.Emulators.MusicNet;
using Microsoft.XBox.Live.Server.Emulators.Dmp;
using Microsoft.XBox.Live.Server.Emulators.Bdk;
using XeXbos;

using xonline.common.webplatform.livecache;
using xonline.common.protocol;


namespace LiveCacheXbosTest
{
    /// <summary>
    ///     Functional test cases for the LiveCache PurchaseMediaOffer API with Mobile products.
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(1), TestFrequency("Regression"), EnvRequirement("Billing")]
    public class PurchaseHistoryV2 : TestNode
    {

        /// <summary>
        /// 	Create WM7 user
        /// 	Do a sample PH call
        /// </summary>
        [TestCase, TestCasePriority(1)]
        class P_LIVEnClient_WM7User_Call_PurchaseHistory : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();

                // Create Moblie Account
                byte[] ownerPassportToken;
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);

                //Create a dummy PH request
                LivecacheWebSvcRequest purchaseHistoryRequest = new LivecacheWebSvcRequest();
                AddNameValuePairToRequest("DetailView", "5", purchaseHistoryRequest);
                AddNameValuePairToRequest("LegalLocale", "en-US", purchaseHistoryRequest);
                AddNameValuePairToRequest("Locale", "en-US", purchaseHistoryRequest);
                AddNameValuePairToRequest("MediaTypes", "24", purchaseHistoryRequest);
                AddNameValuePairToRequest("PageNum", "1", purchaseHistoryRequest);
                AddNameValuePairToRequest("PageSize", "1", purchaseHistoryRequest);
                AddNameValuePairToRequest("Store", "1", purchaseHistoryRequest);
                AddNameValuePairToRequest("TransactionIds", Guid.NewGuid().ToString(), purchaseHistoryRequest);
                AddNameValuePairToRequest("MinPurchaseDate", DateTime.Now.ToShortDateString(), purchaseHistoryRequest);
                AddNameValuePairToRequest("TitleId", "-129071", purchaseHistoryRequest);

                purchaseHistoryRequest.NameValuePairs.Add(new WebServiceNameValuePair("methodName","PurchaseHistoryV2"));
                purchaseHistoryRequest.NameValuePairs.Add(new WebServiceNameValuePair("UserPuid", xuid.ToString()));
                purchaseHistoryRequest.NameValuePairs.Add(new WebServiceNameValuePair("MachinePuid", "0"));

                LiveCacheXbos.AccountAuthDataProvider aadp = new LiveCacheXbos.AccountAuthDataProvider();
                aadp._LivePuid = xuid;
                aadp._Tier = 3;
                aadp._XboxPuid = UacsCommon.CreateWM7MachineUid();
                aadp._Privileges = new uint[8];
                aadp._Privileges[0] = 0;
                aadp._Privileges[1] = 0;
                aadp._Privileges[2] = 0;
                aadp._Privileges[3] = 0;
                aadp._Privileges[4] = 0;
                aadp._Privileges[5] = 0;
                aadp._Privileges[6] = 0x10000000;
                aadp._Privileges[7] = 0x9bf924fc;

                aadp._ClientPlatform = XOn.XPLT_INTERNAL_LIVEN;


                Global.RO.Info("Querying PH with user 0x" + xuid.ToString("X"));
                LcBillingOffering lcBO = new LcBillingOffering(LivecacheClientType.LIVEn, XOn.XENON_DASH_TITLE_ID, aadp, false);

                LiveCacheWebSvcResponse response=  lcBO.PurchaseHistory(xuid, purchaseHistoryRequest);

                if (response == null)
                    throw new UnexpectedTestResultException("lcBO.PurchaseHistory returned null response");

                this.ResultCode = TEST_RESULTS.PASSED;
            }
            private static void AddNameValuePairToRequest(string key, string value, LivecacheWebSvcRequest request)
            {
                request.NameValuePairs.Add(new WebServiceNameValuePair("Names", key));
                request.NameValuePairs.Add(new WebServiceNameValuePair("Values", value));
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcCreateLiveAccount.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcCreateLiveAccount : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            ulong xuid;

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);
    
            // 
            UacsCommon uc = new UacsCommon();
            UacsCommon.PassportUser passportUser = uc.CreatePassportUser();

            xonline.common.protocol.CreateLiveAccountRequest request = new xonline.common.protocol.CreateLiveAccountRequest();
            request.machinePuid = MachineEditor.CreateNew().Id;;
            request.titleId = clientTitleId;
            request.firstName = "John";
            request.lastName = "Smith";
            request.gamertag = "JS" + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(5,10);
            request.signedUserPassportPuid = passportUser.SessionToken;
            request.signedOwnerPassportPuid = passportUser.SessionToken;
            request.offerId = Offers.GetBaseOfferId(Offers.BaseOffers.SilverFreeTrial);
            request.billingToken = "";            // billing token?
            request.birthdate = DateTime.Now.AddYears(-23);
            request.email = passportUser.MemberName;
            request.languageId = 1;              // English
            request.countryId = 103;             // US
            request.msftOptIn = 0;
            request.partnerOptIn = 0;

            request.addressInfo = new xonline.common.protocol.AddressInfoData();
            request.addressInfo.street1 = "15 " + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(5,10) + " Str";
            request.addressInfo.state = "WA";
            request.addressInfo.city = "Redmond";
            request.addressInfo.postalCode = "98052";

            request.phoneInfo = new xonline.common.protocol.PhoneInfoData();
            request.phoneInfo.phonePrefix = "425";
            request.phoneInfo.phoneNumber = "123-4567";

            request.paymentInstrumentType = (byte)ServerTestFramework.LiveService.UserAccount.PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.None;
            request.creditCardInfo = new xonline.common.protocol.CreditCardInfoData();  // do we need to init these even if we're not using them?
            request.directDebitInfo = new xonline.common.protocol.DirectDebitInfoData();  // do we need to init these even if we're not using them?

            request.offlineXuid = 0;

            try
            {
                xuid = lcAC.CreateXboxLiveAccount(request);
                if(xuid == 0)
                {
                    throw new UnexpectedTestResultException("returned xuid is 0");
                }
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcCreateXboxComAccount.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcCreateXboxComAccount : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            ulong xuid;

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);
    
            // 
            UacsCommon uc = new UacsCommon();
            UacsCommon.PassportUser passportUser = uc.CreatePassportUser();

            xonline.common.protocol.CreateXboxComAccountRequest request = new xonline.common.protocol.CreateXboxComAccountRequest();
            request.firstName = "John";
            request.lastName = "Smith";
            request.gamertag = "JS" + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(5,10);
            request.userPassportPuid = passportUser.PassportPuid;
            request.ownerPassportPuid = passportUser.PassportPuid;
            request.birthdate = DateTime.Now.AddYears(-23);
            request.email = passportUser.MemberName;
            request.languageId = 1;              // English
            request.countryId = 103;             // US
            request.msftOptIn = 0;
            request.partnerOptIn = 0;

            request.addressInfo = new xonline.common.protocol.AddressInfoData();
            request.addressInfo.street1 = "15 " + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(5,10) + " Str";
            request.addressInfo.state = "WA";
            request.addressInfo.city = "Redmond";
            request.addressInfo.postalCode = "98052";

            request.phoneInfo = new xonline.common.protocol.PhoneInfoData();
            request.phoneInfo.phonePrefix = "425";
            request.phoneInfo.phoneNumber = "123-4567";

            request.paymentInstrumentType = (byte)ServerTestFramework.LiveService.UserAccount.PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.None;
            request.creditCardInfo = new xonline.common.protocol.CreditCardInfoData();  // do we need to init these even if we're not using them?
            request.directDebitInfo = new xonline.common.protocol.DirectDebitInfoData();  // do we need to init these even if we're not using them?

            try
            {
                xuid = lcAC.CreateXboxComAccount(request);
                if(xuid == 0)
                {
                    throw new UnexpectedTestResultException("returned xuid is 0");
                }
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcGetAccountInfo.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("shwetap"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcGetAccountInfo : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, true)]
        [CompoundCase("LIVEn",  LivecacheClientType.LIVEn, XOn.XPLT_INTERNAL_LIVEN, XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, false)]
        [CompoundCase("LIVEn_noAADP",  LivecacheClientType.LIVEn, XOn.XPLT_INTERNAL_LIVEN, XOn.XENON_DASH_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);    
            // 
            xonline.common.protocol.XeGetAccountInfoRequest request = new xonline.common.protocol.XeGetAccountInfoRequest();
            request.userPuid = xuid;
   
            xonline.common.protocol.XeGetAccountInfoResponse response;
            try
            {
                response = lcAC.GetAccountInfo(request);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }        
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcAcceptTermsOfService.cs ===
using System;
using System.Collections;
using System.Data;
using System.Reflection;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcAcceptTermsOfService : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.CRUX_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.CRUX_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.XENON_DASH_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);
    
            // 
            xonline.common.protocol.AcceptTermsOfServiceRequest request = new xonline.common.protocol.AcceptTermsOfServiceRequest();
            request.userPuid = xuid;
            request.machinePuid = 0xfa00000012341234;
            if(clientType == LivecacheClientType.Zune)
            {
                request.serviceType = 2;
            }
            else
            {
                request.serviceType = 1;
            }
   
            try
            {
                lcAC.AcceptTermsOfService(request);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }        
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xmachine\LcIsConsoleIdAndSCodeBanned.cs ===
using System;
using System.Text;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace LiveCacheXmachineTest
{
    /// <summary>
    /// Livecache tests for the LcIsConsoleIdAndSCodeBanned request. 
    /// The actual functional tests are under the main xmachine test suite. (private\server\xmachine)
    /// </summary>
    [TestGroup, Owner("wisgt"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcIsConsoleIdAndSCodeBanned_Tests
    {

        /// <summary>
        /// Creates an Xbox360 machine.
        /// </summary>
        /// <returns></returns>
        public static ulong CreateXbox360Machine()
        {
            KdcClientXbox360 client = new KdcClientXbox360();
            client.ExecuteXmacs(true);

            ulong puid = client.XmacsOutput.MachineId;
            Global.RO.Debug("Created Xbox360: MachineId=0x{0:X} ConsoleId={1} CertHash=0x{2}", puid, client.XmacsOutput.ConsoleId, Hexer.tohex(client.XmacsRequest.Input.FindConsoleCertificateInPreauths().ComputeHash()));
            return puid;
        }

        /// <summary>
        /// Gets the truncated secondary id. This is the one that will be presented to the user in the dashboard. It is calculated off of the full 
        /// cert hash.
        /// </summary>
        /// <param name="secondaryIdentifier"></param>
        /// <returns></returns>
        public static byte[] GetTruncatedSecondaryID(byte[] secondaryIdentifier)
        {
            if (secondaryIdentifier == null)
                return null;

            byte[] truncId = new byte[8];

            byte lowNibble = 0, highNibble = 0;
            for (int k = 0; k < 7; k++)
            {
                lowNibble += (byte)(secondaryIdentifier[k] & 0x0F);
                lowNibble &= 0x0F;

                highNibble += (byte)(secondaryIdentifier[k] & 0xF0);
                highNibble &= 0xF0;

                truncId[k] = secondaryIdentifier[k];
            }

            truncId[7] = (byte)(lowNibble | highNibble);
            lowNibble = (byte)(truncId[7] & 0x0F);
            highNibble = (byte)(truncId[7] & 0xF0);

            Console.WriteLine("Checksum: {0}, High Nibble: {1}, Low Nibble: {2}, TruncatedSecondaryIdentifier: {3}",
                truncId[7], highNibble, lowNibble, (xonline.common.utilities2.Blob)truncId);

            return truncId;
        }

        /// <summary>
        /// //NOTE: This was ripped out of the base Livecache stress tests.
        /// Similar to the IExtendedAuthDataProvider interface and the above implementation, the IAccountAuthDataProvider interface gets 
        /// implemented by partner teams for calling into any APIs that require some level of authentication.        /// 
        /// </summary>
        class AuthPublicSettings : IAccountAuthDataProvider
        {
            private ulong _livePuid;
            private byte _tier;
            private uint[] _privileges;
            
            public AuthPublicSettings()
            {
                _livePuid = 0;
                _tier = 0;

                // hard code privileges to baseline level
                _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
                AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            }

            public AuthPublicSettings(ulong puid)
            {
                _livePuid = puid;// 0;
                _tier = 0;

                // hard code privileges to baseline level
                _privileges = new uint[XOn.PRIVILEGE_DWORD_LENGTH];
                AddPrivilege(XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            }

            private void AddPrivilege(int privilegeId)
            {
                uint mask = (uint)1 << (privilegeId % 32);
                _privileges[privilegeId / 32] |= mask;
            }

            public ulong LivePuid
            {
                get { return _livePuid; }
            }

            public byte Tier
            {
                get { return _tier; }
            }

            public uint[] Privileges
            {
                get { return _privileges; }
            }

            public IPEndPoint ClientIPEndPoint
            {
                get { return new IPEndPoint(0, 0); }
            }
        }


        [TestCase, TestCasePriority(1)]
        public void LcIsConsoleIdAndSCodeBanned(TestNode self)
        {            
            AuthPublicSettings adp = new AuthPublicSettings();            
            LcXMachine lcXmachine = new LcXMachine(LivecacheClientType.Xboxcom, adp);
            MachineEditor mach = MachineEditor.FromId(CreateXbox360Machine());
            ConsoleBanEditor banEditor = ConsoleBanEditor.FromConsoleId(mach.ConsoleId);
            
            //Ban this guy forever because he beat me in the Halos.
            mach.BanMachine(unchecked((int)0x80000001), DateTime.UtcNow.AddHours(-1), DateTime.MaxValue);
            banEditor.BanConsole(unchecked((int)0x80000001), DateTime.UtcNow.AddHours(-1));
            //LiveCacheWebSvcResponse resp = lcXmachine.IsConsoleIdAndScodeBanned(mach.ConsoleId, ((xonline.common.utilities2.Blob)GetTruncatedSecondaryID(mach.CertHash)).ToString());
            bool resp = lcXmachine.IsConsoleIdAndScodeBanned(mach.ConsoleId, ((xonline.common.utilities2.Blob)GetTruncatedSecondaryID(mach.CertHash)).ToString());
            ValueCheck.Test("Livecache respond did not match what was expected.", true, resp);
        }

        [TestCase, TestCasePriority(1)]
        public void LcIsConsoleIdAndSCodeBannedHyphens(TestNode self)
        {
            AuthPublicSettings adp = new AuthPublicSettings();
            LcXMachine lcXmachine = new LcXMachine(LivecacheClientType.Xboxcom, adp);
            MachineEditor mach = MachineEditor.FromId(CreateXbox360Machine());
            ConsoleBanEditor banEditor = ConsoleBanEditor.FromConsoleId(mach.ConsoleId);
            StringBuilder SCode = new StringBuilder(((xonline.common.utilities2.Blob)GetTruncatedSecondaryID(mach.CertHash)).ToString());

            for (int k = 4; k < SCode.Length; k += 4)
                SCode.Insert(k++, "-");

            //Ban this guy forever because he beat me in the Halos.
            mach.BanMachine(unchecked((int)0x80000001), DateTime.UtcNow.AddHours(-1), DateTime.MaxValue);
            banEditor.BanConsole(unchecked((int)0x80000001), DateTime.UtcNow.AddHours(-1));
            bool resp = lcXmachine.IsConsoleIdAndScodeBanned(mach.ConsoleId, SCode.ToString());
            ValueCheck.Test("Livecache respond did not match what was expected.", true, resp);
        }

        [TestCase, Description("Invalid console ids"), TestCasePriority(2)]
        [CompoundCase("InvalidString", "!@!@#@!#")]
        [CompoundCase("LongString", "aaaaaaaaaaaaaaaaa")]
        [CompoundCase("360Zero", "XE.0")]
        [CompoundCase("360Negative", "XE.-01111111119")]
        [CompoundCase("PCZero", "PC.0")]
        [CompoundCase("PCNegative", "PC.-01111111119")]
        [CompoundCase("X1Zero", "SN.0")]
        [CompoundCase("X1Negative", "SN.-01111111119")]
        [CompoundCase("Zero", "0")]
        [CompoundCase("Negative", "-1")]        
        public void LcInvalidConsoleId(TestNode self)
        {
            string inputString = (string)self.MyValues[0];

            AuthPublicSettings adp = new AuthPublicSettings();
            LcXMachine lcXmachine = new LcXMachine(LivecacheClientType.Xboxcom, adp);
            MachineEditor mach = MachineEditor.FromId(CreateXbox360Machine());

            bool resp = lcXmachine.IsConsoleIdAndScodeBanned(inputString, ((xonline.common.utilities2.Blob)GetTruncatedSecondaryID(mach.CertHash)).ToString());
            ValueCheck.Test("Livecache respond did not match what was expected.", false, resp);
        }        

        [TestCase, Description("Invalid cert hash"), TestCasePriority(2)]
        [CompoundCase("TooShort", "01")]
        [CompoundCase("TooShortZero", "00")]
        [CompoundCase("MaxedOut", "FFFFFFFFFFFFFFFF")]
        [CompoundCase("MaxedOutHyphens", "FFFF-FFFF-FFFF-FFFF")]
        [CompoundCase("Empty", "")]
        public void LcInvalidCertHash(TestNode self)
        {
            string inputString = (string)self.MyValues[0];

            AuthPublicSettings adp = new AuthPublicSettings();
            LcXMachine lcXmachine = new LcXMachine(LivecacheClientType.Xboxcom, adp);
            MachineEditor mach = MachineEditor.FromId(CreateXbox360Machine());

            bool resp = lcXmachine.IsConsoleIdAndScodeBanned(mach.ConsoleId, inputString);
            ValueCheck.Test("Livecache respond did not match what was expected.", false, resp);
        }
        
        [TestCase, Description("Invalid cert hash"), TestCasePriority(2)]        
        public void LcInvalidHexCharacterOnHash(TestNode self)
        {
            string inputString = "!@!@#@!#";

            AuthPublicSettings adp = new AuthPublicSettings();
            LcXMachine lcXmachine = new LcXMachine(LivecacheClientType.Xboxcom, adp);
            MachineEditor mach = MachineEditor.FromId(CreateXbox360Machine());

            try
            {
                bool resp = lcXmachine.IsConsoleIdAndScodeBanned(mach.ConsoleId, inputString);
            }
            catch (Exception ex)
            {
                if (!ex.Message.ToLower().Contains("invalid hex character"))
                    throw;
            }                
        }


        [TestCase, Description("Null cert hash"), TestCasePriority(2)]
        public void LcNullCerthash(TestNode self)
        {
            AuthPublicSettings adp = new AuthPublicSettings();
            LcXMachine lcXmachine = new LcXMachine(LivecacheClientType.Xboxcom, adp);
            MachineEditor mach = MachineEditor.FromId(CreateXbox360Machine());
            ConsoleBanEditor banEditor = ConsoleBanEditor.FromConsoleId(mach.ConsoleId);

            //Ban this guy forever because he beat me in the Halos.
            mach.BanMachine(unchecked((int)0x80000001), DateTime.UtcNow.AddHours(-1), DateTime.MaxValue);
            banEditor.BanConsole(unchecked((int)0x80000001), DateTime.UtcNow.AddHours(-1));
            //LiveCacheWebSvcResponse resp = lcXmachine.IsConsoleIdAndScodeBanned(mach.ConsoleId, ((xonline.common.utilities2.Blob)GetTruncatedSecondaryID(mach.CertHash)).ToString());
            bool resp = lcXmachine.IsConsoleIdAndScodeBanned(mach.ConsoleId, null);
            ValueCheck.Test("Livecache respond did not match what was expected.", true, resp);
        }

        [TestCase, Description("Sentinel value cert hash ({ 0x00 })"), TestCasePriority(2)]
        public void SentinelCerthash(TestNode self)
        {
            AuthPublicSettings adp = new AuthPublicSettings();
            LcXMachine lcXmachine = new LcXMachine(LivecacheClientType.Xboxcom, adp);
            MachineEditor mach = MachineEditor.FromId(CreateXbox360Machine());
            ConsoleBanEditor banEditor = ConsoleBanEditor.FromConsoleId(mach.ConsoleId);

            //Ban this guy forever because he beat me in the Halos.
            mach.BanMachine(unchecked((int)0x80000001), DateTime.UtcNow.AddHours(-1), DateTime.MaxValue);
            banEditor.BanConsole(unchecked((int)0x80000001), DateTime.UtcNow.AddHours(-1));
            //LiveCacheWebSvcResponse resp = lcXmachine.IsConsoleIdAndScodeBanned(mach.ConsoleId, ((xonline.common.utilities2.Blob)GetTruncatedSecondaryID(mach.CertHash)).ToString());
            bool resp = lcXmachine.IsConsoleIdAndScodeBanned(mach.ConsoleId, "00");
            ValueCheck.Test("Livecache respond did not match what was expected.", true, resp);
        }

        [TestCase, Description("Null consoleid"), TestCasePriority(2)]
        public void LcNullConsoleId(TestNode self)        
        {
            AuthPublicSettings adp = new AuthPublicSettings();
            LcXMachine lcXmachine = new LcXMachine(LivecacheClientType.Xboxcom, adp);
            MachineEditor mach = MachineEditor.FromId(CreateXbox360Machine());

            try
            {
                bool resp = lcXmachine.IsConsoleIdAndScodeBanned(null, ((xonline.common.utilities2.Blob)GetTruncatedSecondaryID(mach.CertHash)).ToString());
            }
            catch (Exception ex)
            {
                if (!ex.Message.ToLower().Contains("cannot be null"))
                    throw;
            }
        }

        [TestCase, Description("Empty console id"), TestCasePriority(2)]
        public void LcEmptyConsoleId(TestNode self)
        {
            AuthPublicSettings adp = new AuthPublicSettings();
            LcXMachine lcXmachine = new LcXMachine(LivecacheClientType.Xboxcom, adp);
            MachineEditor mach = MachineEditor.FromId(CreateXbox360Machine());

            try
            {
                bool resp = lcXmachine.IsConsoleIdAndScodeBanned(String.Empty, ((xonline.common.utilities2.Blob)GetTruncatedSecondaryID(mach.CertHash)).ToString());
            }
            catch (Exception ex)
            {
                if (!ex.Message.ToLower().Contains("cannot be null"))
                    throw;
            }
        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcGetDependentPointsBalance.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using xonline.core.history;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using System.Xml;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class GetDependentPointsBalance : TestNode
    {
        [TestCase, TestCasePriority(2)]
        class P_XboxCom : TestBase
        {
            protected override void Execute()
            {
                this.ResultCode = TEST_RESULTS.FAILED;

                InnerExecute(LivecacheClientType.Xboxcom, XOn.XPLT_INTERNAL_XBOXCOM, XOn.XENON_DASH_TITLE_ID, UacsCommon.RandomXenonMachineUid());

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        protected static void InnerExecute(LivecacheClientType clientType, byte clientPlatform, uint clientTitleId, ulong clientMachineId)
        {
            UacsCommon.LiveCacheResetInitializedClientType();
            XeUser parent = UacsCommon.CreateXenonUser(3);
            XeUser dependent1 = UacsCommon.CreateXenonUser(3);

            ulong[] offerIds = new ulong[] { Offers.GetPointsOfferId(Offers.PointsOffers.CC500US) };
            LiveCacheXUacsCommon.MakePurchase(dependent1, offerIds, clientType, clientPlatform, clientTitleId, clientMachineId);
            LiveCacheXUacsCommon.AddDependent(parent, dependent1, clientType, clientPlatform, clientTitleId, clientMachineId);

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = parent.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(parent.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
            aadp._XboxPuid = clientMachineId;

            LcBillingOffering lcBO =
                new LcBillingOffering(clientType, clientTitleId, aadp, false);
            LiveCacheWebSvcResponse response = lcBO.GetDependentPointsBalance(parent.UserPuid, dependent1.UserPuid);
            Global.RO.Info("response is:\r\n{0}", response.response);
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(response.response);
            XmlNodeList nodeList = xmlDoc.GetElementsByTagName("pointbalance");
            if (nodeList == null || nodeList[0] == null)
            {
                throw new UnexpectedTestResultException("Cannot find pointbalance element");
            }

            int pointbalance = Int32.Parse(nodeList[0].InnerText);
            if (pointbalance != 500)
            {
                throw new UnexpectedTestResultException("Dependent should have 500 points");
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcCreateUserAndBillableAccount.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    /// <summary>
    ///     Functional tests for the XeGetUserWebInfo request.
    /// </summary>
    [TestGroup, Owner("stevewar"), TestFrequency("Regression"), EnvRequirement("Billing"), TestCasePriority(2)]
    public class CreateUserAndBillableAccount : TestNode
    {
        /// <summary>
        ///     Call  ReserveGamertag with Xboxcom
        /// </summary>
        [TestCase,TestCasePriority(3),TestFrequency("Regression")]
        class P_UniqueNounAdjective_CreateUserAndBillableAccount_XboxcomClient : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();

                ulong userPuid = 0;
                RandomEx rnd = new RandomEx();
                UacsCommon uc = new UacsCommon();
                
                UacsCommon.PassportUser passportUser = uc.CreatePassportUser(103);
                //PassportMemberName = passportUser.MemberName;
                //PassportPassword= passportUser.Password;
                //m_passportUserSessionToken = passportUser.SessionToken;
                //m_passportOwnerSessionToken = passportUser.SessionToken;
                
                // Content Enumerate for  Free Gamertag
                xonline.common.protocol.CreateUserAndBillableAccountRequest request = new xonline.common.protocol.CreateUserAndBillableAccountRequest();
                request.machinePuid = UacsCommon.CreateXboxcomMachineUid();
                request.gamertag = rnd.GenerateRandomString("XEN", 15);
                request.signedUserPassportPuid = passportUser.SessionToken;
                request.signedOwnerPassportPuid = passportUser.SessionToken;
                request.birthdate = DateTime.UtcNow.AddYears(-30);
                request.countryId =103;
                request.languageId = CountryLanguage.GetFirstLanguageFromCountry(request.countryId);
                request.msftOptIn = false;
                request.partnerOptIn = false;
                request.email = "blamo" + Global.PassportMemberDomain;
                request.isFreeGamertagChangeEligible = true;
                
                Global.RO.Info("CreateUserAndBillableAccountRequest");

                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, xonline.common.service.XOn.WEB_TITLE_ID, false);
                try
                {
                    userPuid = lcAC.CreateUserAndBillableAccount(request);
                }
                catch( XRLException e )
                {
                    if ( xonline.common.service.HResult.XONLINE_E_SERVICE_KEY_NOT_FOUND == XRLException.ToHResult( e, 0 ))
                    {
                        Global.RO.Warn("Looks like you are running this test on a machine that doesn't have the MasterKey!  Try installing the MasterKey and rerun the test.");
                        // drop\debug\tools\xkeymgr\xkeymgr.exe STOREMK private\op\sitecfg\xblob\secure\MasterKeyV1.prv
                    }
                    throw;
                }

                Global.RO.Info("CreateUserAndBillableAccount returned userPuid: {0}", userPuid);

                if ( 0 < userPuid )
                    this.ResultCode = TEST_RESULTS.PASSED;
                else
                    throw new UnexpectedTestResultException("UserPuid invalid: " + userPuid);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcGetSupportedCountries.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;
using System.Xml;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcGetSupportedCountries : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase( "XboxCom", LivecacheClientType.Xboxcom, XOn.XPLT_WEB, XOn.WEB_TITLE_ID )]        
        public void P_GetXboxLiveCountries(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];            
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint)me.MyValues[2];

            XeUser user = UacsCommon.XeUserCreationHelper.CreateXeSilverUser();

            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = user.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(user.UserPuid);
            LiveCacheXUacs.setAADPPrivileges( aadp );
            aadp._ClientPlatform = clientPlatform;

            UacsCommon.LiveCacheResetInitializedClientType();
            LcAccountCreation lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
                        
            LiveCacheWebSvcResponse response = lcAC.GetSupportedCountries( user.UserPuid, (int)xonline.common.protocol.ServiceTypeEnum.XboxLive, (byte)clientPlatform );
            Global.RO.Info( "response is {0}", response.response );
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml( response.response );
            XmlNodeList nodeList = xmlDoc.GetElementsByTagName( "CountryInfo" );

            ValueCheck.Test( "response.country.Count", 36, nodeList.Count );  
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcGetGamerProfileTypes.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcGetGamerProfileTypes : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, true)]
        [CompoundCase("LIVEn",  LivecacheClientType.LIVEn, XOn.XPLT_INTERNAL_LIVEN, XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, false)]
        [CompoundCase("LIVEn_noAADP",  LivecacheClientType.LIVEn, XOn.XPLT_INTERNAL_LIVEN, XOn.XENON_DASH_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);    
    
            // 
            int settingId = 0x10040004;
            string sql =String.Format("insert into t_user_settings (bi_user_puid, i_title_id, i_setting_id, vb_value, dt_Change_datetime) values({0}, {1}, {2}, {3}, '{4}')", (long)xuid,  (int)clientTitleId, (int)settingId, 0x1000, DateTime.UtcNow);
            UodbWS.ExecuteSQLNonQuery(sql, xuid);
            
            xonline.common.protocol.XeGetUserTypeRequest request = new xonline.common.protocol.XeGetUserTypeRequest();
            request.gamertag= user.Gamertag;

            xonline.common.protocol.XeGetUserTypeResponse response=null;

            try
            {
                response = lcAC.GetGamerProfileTypes(request, xuid);

                ValueCheck.Test("HasUserProfile", false, ((byte)response.UserType & 0x80) !=0);
                ValueCheck.Test("UserType", (byte)XRLXeGetUserType.UserTypeEnum.XenonUser, response.UserType & ~0x80);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }        
            
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcGetUserType.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcGetUserType : TestNode
    {
		[TestCase, TestCasePriority(2)]
		class P_XboxCom : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Xboxcom, XOn.XPLT_WEB, XOn.XENON_DASH_TITLE_ID);
                
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_Zune : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Zune, XOn.XPLT_ZUNEV2, XOn.CRUX_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_XNA : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    InnerExecute(LivecacheClientType.XNA, XOn.XPLT_INTERNAL_XNA, XOn.XENON_DASH_TITLE_ID);
                }
                catch(Exception ex)
                {
                    Global.RO.Info(ex.ToString());
                    if(ex.ToString().Contains("80150011"))
                    {
                        Global.RO.Info("got exception with 0x80150011 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("got exception but error code is not 0x80150011");
                    }                    
                    this.ResultCode = TEST_RESULTS.PASSED;
                }

                if(this.ResultCode != TEST_RESULTS.PASSED)
                    Global.RO.Warn("should get exception 0x80150011");
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_WGX : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.WGX, XOn.XPLT_INTERNAL_WGX, XOn.XENON_DASH_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_LiveEn : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.LIVEn, XOn.XPLT_INTERNAL_LIVEN, XOn.XENON_DASH_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

        protected static void InnerExecute(LivecacheClientType clientType, byte clientPlatform, uint clientTitleId)
        {
            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
    
            // 
            xonline.common.protocol.XeGetUserTypeRequest request = new xonline.common.protocol.XeGetUserTypeRequest();
            request.gamertag= user.Gamertag;

            xonline.common.protocol.XeGetUserTypeResponse response = lcAC.GetUserType(request);

            ValueCheck.Test("HasUserProfile", false, ((byte)response.UserType & 0x80) !=0);
            ValueCheck.Test("UserType", (byte)XRLXeGetUserType.UserTypeEnum.XenonUser, response.UserType & ~0x80);
            
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcGraduateUser.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    /// <summary>
    ///     Functional tests for the XeGetUserWebInfo request.
    /// </summary>
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), EnvRequirement("Billing"), TestCasePriority(2)]
    public class LcGraduateUser : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, true)]
        //[CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        //[CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        //[CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            XeUser parent;
            XeUser[] children;

            UacsCommon.CreateFamily(1, out  parent, out children, false);

            XRLXeSetAccountInfo SAIrequest = new XRLXeSetAccountInfo();
            SAIrequest.UserPuid = children[0].UserPuid;
            SAIrequest.FirstName = "Tom";
            SAIrequest.LastName = "Sawyer";
            SAIrequest.Birthdate = DateTime.UtcNow.AddYears(-19);
            SAIrequest.Email = children[0].Email;
            SAIrequest.AddressInfo = children[0].AddressInfo;
            SAIrequest.PhoneInfo = children[0].PhoneInfo;
            SAIrequest.LanguageId = 1;
            SAIrequest.MsftOptIn = 0;
            SAIrequest.PartnerOptIn = 0;

            if (!SAIrequest.Execute())
                throw new UnexpectedTestResultException("XeSetAccountInfo failed: " + SAIrequest.GetDumpString());
            if (SAIrequest.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XeSetAccountInfo returned XErr=0x{0:x}", SAIrequest.XErr));

            UacsCommon.SetPrivilege(children[0], 225);

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = children[0].UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);    
    
    
            // GraduateUserRequest
            xonline.common.protocol.GraduateUserRequest request = new xonline.common.protocol.GraduateUserRequest();
            request.userPuid = children[0].UserPuid;
            request.addressInfo = new xonline.common.protocol.AddressInfoData();
            request.addressInfo.street1 = "15 " + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(5,10) + " Str";
            request.addressInfo.state = "WA";
            request.addressInfo.city = "Redmond";
            request.addressInfo.postalCode = "98052";

            request.phoneInfo = new xonline.common.protocol.PhoneInfoData();
            request.phoneInfo.phonePrefix = "425";
            request.phoneInfo.phoneNumber = "123-4567";

            request.paymentInstrumentType = (byte)ServerTestFramework.LiveService.UserAccount.PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.None;
            request.creditCardInfo = new xonline.common.protocol.CreditCardInfoData();  // do we need to init these even if we're not using them?
            request.directDebitInfo = new xonline.common.protocol.DirectDebitInfoData();  // do we need to init these even if we're not using them?

            lcAC.GraduateUser(request);
        }

        public static void setAADPPrivileges(LiveCacheXUacs.AccountAuthDataProvider aadp)
        {
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fe; // graduation
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcGetLinkedGamerTag.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcGetLinkedGamerTag : TestNode
    {
		[TestCase, TestCasePriority(2)]
		class P_XboxCom : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Xboxcom, XOn.XPLT_WEB, XOn.XENON_DASH_TITLE_ID);
                
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_Zune : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Zune, XOn.XPLT_ZUNEV2, XOn.CRUX_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_XNA : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    InnerExecute(LivecacheClientType.XNA, XOn.XPLT_INTERNAL_XNA, XOn.XENON_DASH_TITLE_ID);
                }
                catch(Exception ex)
                {
                    Global.RO.Info(ex.ToString());
                    if(ex.ToString().Contains("80150011"))
                    {
                        Global.RO.Info("got exception with 0x80150011 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("got exception but error code is not 0x80150011");
                    }                    
                    this.ResultCode = TEST_RESULTS.PASSED;
                }

                if(this.ResultCode != TEST_RESULTS.PASSED)
                    Global.RO.Warn("should get exception 0x80150011");
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_WGX : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.WGX, XOn.XPLT_INTERNAL_WGX, XOn.XENON_DASH_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

        protected static void InnerExecute(LivecacheClientType clientType, byte clientPlatform, uint clientTitleId)
        {
            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
    
            // 
            ulong livePuid;
            string gamertag;            
   
            bool bRet = lcAC.GetLinkedGamertag(user.PassportUserPuid, out livePuid, out  gamertag);
            Global.RO.Info("lcAC.GetLinkedGamertag returned {0}", bRet);
			if(bRet == false)
				throw new UnexpectedTestResultException("lcAC.GetLinkedGamertag returned false.");

            Global.RO.Info("returned xuid is {0}", livePuid);
			if(xuid != livePuid)
				throw new UnexpectedTestResultException("wrong xuid is returned.");
            

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcMigrateXboxComUser.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcMigrateXboxComUser : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a xboxcome user
            string GamerTag;
            UacsCommon.PassportUser ppUser;
            
            ulong xuid = UacsCommon.CreateXboxComUser(true, (byte)XeUser.Country.US, out GamerTag, out ppUser);
            Global.RO.Info("XboxCom User created with : 0x{0:X}", xuid);

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);    
    
            // 
            xonline.common.protocol.MigrateXboxComUserRequest request = new xonline.common.protocol.MigrateXboxComUserRequest();
            request.signedPassportPuid = ppUser.SessionToken;

            request.firstName = "John";
            request.lastName = "Smith";
            request.countryId = (byte)XeUser.Country.US;
            request.languageId = (ushort)XeUser.Language.en;

            request.addressInfo = new xonline.common.protocol.AddressInfoData();
            request.addressInfo.street1 = "15 " + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(5,10) + " Str";
            request.addressInfo.state = "WA";
            request.addressInfo.city = "Redmond";
            request.addressInfo.postalCode = "98052";

            request.phoneInfo = new xonline.common.protocol.PhoneInfoData();
            request.phoneInfo.phonePrefix = "425";
            request.phoneInfo.phoneNumber = "123-4567";

            request.paymentInstrumentType = (byte)ServerTestFramework.LiveService.UserAccount.PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.None;
            request.creditCardInfo = new xonline.common.protocol.CreditCardInfoData();  // do we need to init these even if we're not using them?
            request.directDebitInfo = new xonline.common.protocol.DirectDebitInfoData();  // do we need to init these even if we're not using them?

            xonline.common.protocol.MigrateXboxComUserResponse response;
            try
            {
                response = lcAC.MigrateXboxcomUser(xuid, request);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }        

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcPassportCreateGenerated.cs ===
using System;
using System.Collections;
using System.Data;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.core.wiredata;

using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    /// <summary>
    ///     Functional tests for the XeGetUserWebInfo request.
    /// </summary>
    [TestGroup, Owner("stevewar"), TestFrequency("Regression"), EnvRequirement("Billing"), TestCasePriority(2)]
    public class PassportCreateGenerated : TestNode
    {
        /// <summary>
        ///     Call  ReserveGamertag with Xboxcom
        /// </summary>
        [TestCase,TestCasePriority(3),TestFrequency("Regression")]
        class P_UniqueNounAdjective_PassportCreateGenerated_XboxcomClient : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ASCIIEncoding ascii = new ASCIIEncoding();
                SymmetricKey symmetricKey = new SymmetricKey();
                
                // Content Enumerate for  Free Gamertag
                xonline.common.protocol.PassportCreateGeneratedRequest request = new xonline.common.protocol.PassportCreateGeneratedRequest();
                request.sessionKey  = symmetricKey.Key;
                request.sessionIV   = symmetricKey.IV;
                request.machinePuid = UacsCommon.CreateXboxcomMachineUid();
                request.birthdate   = DateTime.UtcNow.AddYears(-5);
                request.countryId   = 103;
                
                Global.RO.Info("PassportCreateGeneratedRequest");

                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, xonline.common.service.XOn.XENON_DASH_TITLE_ID, false);

                PassportCreateGeneratedResponse response = lcAC.PassportCreateGenerated(request);

                Global.RO.Info("PassportCreateGenerated returned userPuid: {0}", response.memberName);
                
                byte[] bytePassword = symmetricKey.Decrypt( response.encryptedPassword );
                string password = ascii.GetString( bytePassword );
                
                Global.RO.Info("PassportCreateGenerated returned password: {0}", password);

                if ( 0 < response.memberName.Length )
                    this.ResultCode = TEST_RESULTS.PASSED;
                else
                    throw new UnexpectedTestResultException("memberName invalid: " + response.memberName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcPassportGetMemberName.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("stevewar"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcPassportGetMemberName : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);    
    
            // 
            xonline.common.protocol.XePassportGetMemberNameResponse response;
            try
            {
                response = lcAC.PassportGetMemberName(xuid, aadp);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }        
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcMergeUserEntitlements.cs ===
using System;
using System.Collections;
using System.Data;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Billing;


using xonline.common.webplatform.livecache;

using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

using StfUserAccount = ServerTestFramework.LiveService.UserAccount;

namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcMergeUserEntitlements : TestNode
    {
        private static void VerifyGamertag(byte[] PassportSessionToken, ulong UserPuid, string Gamertag)
        {
            XRLXeGetLinkedGamertag request = new XRLXeGetLinkedGamertag();
            XRLXeGetLinkedGamertagResponse response = new XRLXeGetLinkedGamertagResponse();

            request.signedPassportPuid = PassportSessionToken;

            bool result = request.Execute(out response);
            ValueCheck.IsTrue(result, "XRLXeGetLinkedGamertag should succeed");
            ValueCheck.TestHR("request.XErr", HResult.S_OK, request.XErr);

            ValueCheck.Test("response.Gamertag", Gamertag.ToUpper(), response.Gamertag.ToUpper());
            ValueCheck.Test("response.UserPuid", UserPuid, response.UserPuid);
        }
        
        public enum UserType : byte
        {
            SILVER = 3,
            GOLD = 6
        };

        public enum ResponseFlag : int
        {
            ISSUBSCRIBED = 1,
            HASCANCELLED = 2
        };

        private static void VerifySubscription(uint titleId, ushort requestFlags, UserType tier, ulong UserPuid, ulong[] offerIds)
        {
            XRLXeSubscriptionEnumerate request = new XRLXeSubscriptionEnumerate();
            XRLXeSubscriptionEnumerateResponse response = new XRLXeSubscriptionEnumerateResponse();

            request.UserPuid = UserPuid;
            request.UserTier = (byte)tier;
            request.PaymentType = (uint)PaymentTypeEnum.CreditCard;
            request.OfferType = (uint)OfferingTypeEnum.Subscription | (uint)OfferingTypeEnum.Renewal;
            request.RequestFlags = requestFlags;
            request.TitleID = titleId;


            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeSubscriptionEnumerate failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeSubscriptionEnumerate returned XErr=0x{0:x}",
                                                                      request.XErr));

            foreach (ulong offerId in offerIds)
            {
                bool bFound = false;

                for (int ii = 0; ii < response.OffersReturned; ii++)
                {
                    if (response.Subscriptions[ii].OfferID == offerId)
                    {
                        bFound = true;
                        break;
                    }
                }

                ValueCheck.IsTrue(bFound, String.Format("Offer 0x{0:X} not found", offerId));
            }
        }

        private static void VerifyDetails(ulong UserPuid, ulong offerId, DateTime endDate)
        {
            XRLXeGetUserSubscriptionDetails request = new XRLXeGetUserSubscriptionDetails();
            XRLXeGetUserSubscriptionDetailsResponse response = new XRLXeGetUserSubscriptionDetailsResponse();

            request.UserPuid = UserPuid;
            request.OfferId = offerId;
            request.InstanceId = UodbWS.GetUsersSubscriptionInstanceId(UserPuid, offerId);

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeGetUserSubscriptionDetails failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeGetUserSubscriptionDetails returned XErr=0x{0:x}",
                                                                      request.XErr));

            TimeSpan span = response.EndDate - endDate;
            // If merge happens at the end of month, expiration date will be expanded a month. It's by design in CTP
            if( span.TotalDays > 35 || (span.TotalDays > 5 && span.TotalDays < 25)|| span.TotalDays < -5)
                throw new UnexpectedTestResultException(String.Format("Expected end date {0} is quite different from returned end date {1}", endDate, response.EndDate));
        }

        private static XeUser CreateZuneAccount(XeUser.Country countryId)
        {
            string crux_useMusicNetForProvisioning = GetMusicNetForProvisioningValue();
            SetMusicNetForProvisioningValue("false");

            try
            {
                XeUser user = new XeUser(true, countryId);
                user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                user.CreateLiveAccountExtra.CreateArgoProfile = true;

                ulong xuid = user.Create();
                ValueCheck.TestNonZero("xuid", xuid);

                return user;
            }
            finally
            {
                SetMusicNetForProvisioningValue(crux_useMusicNetForProvisioning);
            }
        }

        private static string GetMusicNetForProvisioningValue()
        {
            Global.RO.Info("Overriding on crux_useMusicNetForProvisioning");
            return Global.XEnv.GetSetting("crux_useMusicNetForProvisioning");
        }

        private static void SetMusicNetForProvisioningValue(string value)
        {
            Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", Convert.ToString(value), -1);
            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xuacs configcacherefresh");
        }

        public static bool bMerged = false;

        [TestCase, TestCasePriority(2)]
        class P_Mainline : UserTestBase
        {
            public enum QueryType : ushort
            {
                NEW = 0x0001,
                RENEWAL = 0x0002,
                CURRENT = 0x0004,
                EXPIRED = 0x0008,
                SUSPENDED = 0x0010
            };

            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;

                // User A - Gold 12 mo CC
                XeUser userA = UacsCommon.XeUserCreationHelper.CreateXeSilverUser(XeUser.Country.US);
                UacsCommon.PurchaseCCOffer(userA, Offers.BaseOffers.GoldCC1Year);
                UacsCommon.WaitForCSAT(userA.UserPuid, false);

                // User B - Zune Pass 3mo CC
                XeUser userB = CreateZuneAccount(XeUser.Country.US);
                UacsCommon.PurchaseCCOffer(userB, Offers.GetOfferId(Offers.MusicNetOffers.QuarterlyCC));

                ulong migrationOfferId = Offers.GetMigraionOffer(Offers.GetBaseOfferId(Offers.BaseOffers.GoldCC1Year));

                xonline.common.protocol.useraccount.MergeUserEntitlementsRequest request = new xonline.common.protocol.useraccount.MergeUserEntitlementsRequest();

                request.srcUserPuid = userA.UserPuid;
                request.signedUserPassportPuidToDrop = userA.PassportSessionToken;

                request.destUserPuid = userB.UserPuid;
                request.signedUserPassportPuidToKeep = userB.PassportSessionToken;

                request.trackingGuid = Guid.NewGuid();
                request.transferPoints = true;


                Global.RO.Info("Calling LiveCache");
                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.WEB_TITLE_ID, false);

                //Uncomment and change name when LiveCache entry point is create in LiveCache client
                lcAC.MergeUserEntitlements(request);

                UacsCommon.WaitForXCache();

                // Verify gamertag
                Global.RO.Info("Verifying gamertag");
                VerifyGamertag(userB.PassportSessionToken, userB.UserPuid, userB.Gamertag);

                // Verify subscriptions
                Global.RO.Info("Verifying current subscription");
                ulong[] offerIds = new ulong[1];
                offerIds[0] = migrationOfferId;
                VerifySubscription(XOn.XENON_DASH_TITLE_ID, (ushort)QueryType.CURRENT, UserType.GOLD, userB.UserPuid, offerIds);

                offerIds = new ulong[1];
                offerIds[0] = Offers.GetOfferId(Offers.MusicNetOffers.QuarterlyCC);
                VerifySubscription(XOn.CRUX_TITLE_ID, (ushort)QueryType.CURRENT, UserType.GOLD, userB.UserPuid, offerIds);

                // Verify remaining days
                Global.RO.Info("Verifying remaining days");
                VerifyDetails(userB.UserPuid, migrationOfferId, DateTime.Today.AddDays(365));
                VerifyDetails(userB.UserPuid, Offers.GetOfferId(Offers.MusicNetOffers.QuarterlyCC), DateTime.Today.AddDays(91));

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcPreviewSwitchUserCountry.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.protocol.useraccount;
using xonline.common.webplatform.livecache;

namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcPreviewSwitchUserCountry : TestNode
    {
        [TestCase, TestCasePriority(2)]
        class P_Mainline : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;

                // Create silver US account
                XeUser user = UacsCommon.CreateXenonUser(3);

                byte newCountryId = (byte)XeUser.Country.CA;
                
                PreviewSwitchUserCountryRequest req = new PreviewSwitchUserCountryRequest();
                req.userPuid = user.UserPuid;
                req.countryId = newCountryId;
                req.cultureId = CountryLanguage.GetCultureId(newCountryId, user.LanguageId);

                Global.RO.Info("Calling LiveCache");
                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.WEB_TITLE_ID, false);
                PreviewSwitchUserCountryResponse response = lcAC.PreviewSwitchUserCountry(req);
                ValueCheck.TestHR("response.expectedHResult", HResult.S_OK, response.expectedHResult);
                ValueCheck.Test("subscriptionsToMigrateLength wrong.", 0, response.subscriptionsToMigrateLength);
                ValueCheck.Test("subscriptionsToCancelLength wrong", 0, response.subscriptionsToCancelLength);

                UacsCommon.WaitForXCache();
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcPassportGetPuidFromMemberName.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("stevewar"), TestFrequency("Regression"), TestCasePriority(2)]
    public class PassportGetPuidFromMemberName : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.PC_DASH_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);    
    
            // 
            xonline.common.protocol.XePassportGetPuidFromMemberNameRequest request = new xonline.common.protocol.XePassportGetPuidFromMemberNameRequest();
            request.memberName = user.Email;

            xonline.common.protocol.XePassportGetPuidFromMemberNameResponse response;
            try
            {
                response = lcAC.PassportGetPuidFromMemberName(request);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }        

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcPreviewMergeSubscription.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using xonline.core.history;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using System.Xml;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class PreviewMergeSubscription : TestNode
    {
        [TestCase, TestCasePriority(2)]
        class P_XboxCom : TestBase
        {
            protected override void Execute()
            {
                this.ResultCode = TEST_RESULTS.FAILED;

                InnerExecute(LivecacheClientType.Xboxcom, XOn.XPLT_INTERNAL_XBOXCOM, XOn.XENON_DASH_TITLE_ID, UacsCommon.RandomXenonMachineUid());

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        protected static void InnerExecute(LivecacheClientType clientType, byte clientPlatform, uint clientTitleId, ulong clientMachineId)
        {
            UacsCommon.LiveCacheResetInitializedClientType();
            XeUser parent = UacsCommon.CreateXenonUser(3);
            string parentPaymentInstrumentId = parent.AddPaymentInstrumentVisa();
            XeUser dependent1 = UacsCommon.CreateXenonUser(3);
            string dependentPaymentInstrumentId = dependent1.AddPaymentInstrumentVisa();

            ulong[] offerIds1 = new ulong[] { Offers.GetBaseOfferId(Offers.BaseOffers.FamilyGoldCC1Year) };
            LiveCacheXUacsCommon.MakePurchase(parent, offerIds1, clientType, clientPlatform, clientTitleId, clientMachineId);
            ulong[] offerIds2 = new ulong[] { Offers.GetBaseOfferId(Offers.BaseOffers.GoldCC1Year) };
            LiveCacheXUacsCommon.MakePurchase(dependent1, offerIds2, clientType, clientPlatform, clientTitleId, clientMachineId);
            LiveCacheXUacsCommon.AddDependent(parent, dependent1, clientType, clientPlatform, clientTitleId, clientMachineId);

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = parent.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(parent.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
            aadp._XboxPuid = clientMachineId;

            LcBillingOffering lcBO = new LcBillingOffering(clientType, clientTitleId, aadp, false);
            xonline.common.protocol.PreviewMergeSubscriptionRequest request = new xonline.common.protocol.PreviewMergeSubscriptionRequest();
            request.primaryUserPuid = parent.UserPuid;
            request.secondaryUserPuid = dependent1.UserPuid;
            // dependent is already in family, so passport token is not needed
            request.ownerPassportTokenLength = 0;
            request.ownerPassportToken = null;
            xonline.common.protocol.PreviewMergeSubscriptionResponse response = lcBO.PreviewMergeSubscription(request);
            if (response == null)
            {
                throw new UnexpectedTestResultException(string.Format("PreviewMergeSubscriptionFailed returned a null response.This is not expected"));
            }

            DateTime endDate = UacsCommon.GetUserSubscriptionDetails(parent.UserPuid, UodbWS.GetUsersSubscriptionOfferId(parent.UserPuid)).EndDate;
            decimal ratio = 0;
            Decimal.TryParse(Config.GetSetting(Setting.xuacs_FamilyGoldConvertionRatio), out ratio);
            ValueCheck.Test("monthsTransferred", 12*ratio, response.monthsTransferred);
            ValueCheck.Test("nextChargeDate", endDate.AddMonths((int)response.monthsTransferred), response.nextChargeDate);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcSetAccountInfo.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("shwetap"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcSetAccountInfo : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);
    
            // 
            xonline.common.protocol.XeSetAccountInfoRequest request = new xonline.common.protocol.XeSetAccountInfoRequest();
            request.userPuid =  xuid;
            request.firstName = "Tom";
            request.lastName = "Sawyer";
            request.birthdate = user.BirthDate;
            request.email = user.Email;
            request.addressInfo = new xonline.common.protocol.AddressInfoData();
            request.addressInfo.street1 = "15 " + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(5,10) + " Str";
            request.addressInfo.state = "WA";
            request.addressInfo.city = "Redmond";
            request.addressInfo.postalCode = "98052";

            request.phoneInfo = new xonline.common.protocol.PhoneInfoData();
            request.phoneInfo.phonePrefix = "425";
            request.phoneInfo.phoneNumber = "123-4567";
            request.languageId = 1;
            request.msftOptIn = 0;
            request.partnerOptIn = 0;

            try
            {
                lcAC.UpdateXboxAccount(request, aadp);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcUpsGetProfile.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcUpsGetProfile : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);
    
            // 
            xonline.common.protocol.XeUpsGetProfileRequest request = new xonline.common.protocol.XeUpsGetProfileRequest();
            request.puid = user.PassportUserPuid;
            request.attributes = string.Join(",", new string[] {
                "xbox.dayphone",
                "xbox.email",
                "xbox.gamertag"});

            xonline.common.billing.UpsProfile response;
            try
            {
                response = lcAC.UpsGetProfile(request);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcUpsUpdateProfile.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcUpsUpdateProfile : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);
    
            // 
            UpsProfile coreProfile = new UpsProfile();
            coreProfile.FirstName = user.FirstName;
            coreProfile.LastName = user.LastName;
            coreProfile.BirthDate = user.BirthDate;
            coreProfile.Street1 = user.AddressInfo.Street1;
            coreProfile.Street2 = user.AddressInfo.Street2;
            coreProfile.City = user.AddressInfo.City;
            coreProfile.County = user.AddressInfo.District;
            coreProfile.Region = user.AddressInfo.State;
            coreProfile.PostalCode = user.AddressInfo.PostalCode;
            coreProfile.Country = UpsProfile.CountryCodeFromCountryId(user.CountryId);

            string xml = coreProfile.ReturnUpsProfileXML(user.PassportUserPuid);

            xonline.common.billing.UpsProfile request = new xonline.common.billing.UpsProfile(xml);

            try
            {
                lcAC.UpsUpdateProfile(request);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcSwitchUserCountryV2.cs ===
using System;
using System.Collections;
using System.Data;

using ServerTestFramework;
using ServerTestFramework.LiveService;
//using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

using StfUserAccount = ServerTestFramework.LiveService.UserAccount;

namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcSwitchUserCountryV2 : TestNode
    {
        [TestCase, TestCasePriority(2)]
        class P_Mainline : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;

                // Create silver US account
                XeUser user = UacsCommon.CreateXenonUser(3);

                byte newCountryId = (byte) XeUser.Country.CA;

                var newAddress = xonline.common.stfutil.AccountsUtil.CreateAddressInfo(newCountryId);

                SwitchUserCountryRequest req = new SwitchUserCountryRequest();
                req.trackingGuid = Guid.NewGuid();
                req.userPuid = user.UserPuid;
                req.addressInfo = newAddress;
                req.countryId = newCountryId;
                req.cultureId = CountryLanguage.GetCultureId(newCountryId, user.LanguageId);

                Global.RO.Info("Calling LiveCache");
                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.WEB_TITLE_ID, false);
                lcAC.SwitchUserCountryV2(req);

                UacsCommon.WaitForXCache();
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcTransferPointsBalance.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using xonline.core.history;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using System.Xml;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class TransferPointsBalance : TestNode
    {
        [TestCase, TestCasePriority(2)]
        class P_XboxCom : TestBase
        {
            protected override void Execute()
            {
                this.ResultCode = TEST_RESULTS.FAILED;

                InnerExecute(LivecacheClientType.Xboxcom, XOn.XPLT_INTERNAL_XBOXCOM, XOn.XENON_DASH_TITLE_ID, UacsCommon.RandomXenonMachineUid());

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        protected static void InnerExecute(LivecacheClientType clientType, byte clientPlatform, uint clientTitleId, ulong clientMachineId)
        {
            UacsCommon.LiveCacheResetInitializedClientType();
            XeUser parent = UacsCommon.CreateXenonUser(3);
            XeUser dependent1 = UacsCommon.CreateXenonUser(3);

            ulong[] offerIds = new ulong[] { Offers.GetPointsOfferId(Offers.PointsOffers.CC500US) };
            LiveCacheXUacsCommon.MakePurchase(parent, offerIds, clientType, clientPlatform, clientTitleId, clientMachineId);
            LiveCacheXUacsCommon.AddDependent(parent, dependent1, clientType, clientPlatform, clientTitleId, clientMachineId);

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = parent.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(parent.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
            aadp._XboxPuid = clientMachineId;

            LcBillingOffering lcBO =
                new LcBillingOffering(clientType, clientTitleId, aadp, false);
            LiveCacheWebSvcResponse response = lcBO.TransferPointsBalance(parent.UserPuid, dependent1.UserPuid, 100);
            Global.RO.Info("response is:\r\n{0}", response.response);
            uint points = dependent1.GetPointsBalance();
            if (points != 100)
                throw new UnexpectedTestResultException(String.Format("points_balance_after is not 100 but {0}", points));
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcTroubleshootAccount.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcTroubleshootAccount : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.CRUX_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.CRUX_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.XENON_DASH_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser(false);
            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);
    
            // 
            xonline.common.protocol.XeTroubleshootAccountRequest request = new xonline.common.protocol.XeTroubleshootAccountRequest();
            request.userPuid = user.UserPuid;

            xonline.common.protocol.XeTroubleshootAccountResponse response;
            try
            {
                response = lcAC.TroubleshootAccount(request);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcUserAccountAuthorize.cs ===
using System;
using System.Collections;
using System.Data;
using System.Xml;

using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using xonline.common.webplatform.livecache;

using Microsoft.Webstore.WstClient;

namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(2)]
    public class GetUserAccountAuthorize : TestNode
    {

        [TestCase, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_GetUserAccountAuthorize : TestBase
        {


            public static XeUser CreateXenonUser(bool createPassport)
            {
                XeUser user = new XeUser(createPassport);
                if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
                Global.RO.Info("User 0x{0:x} created.", user.UserPuid);

                return user;
            }

            public static XeUser CreateChildXenonUser(XeUser parent)
            {
                XeUser user = new XeUser(true);
                if (user.CreateMinor(parent, true) == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
                Global.RO.Info("Child user 0x{0:x} created.", user.UserPuid);

                return user;
            }

            protected override void Execute()
            {
                try
                {
                    UacsCommon.LiveCacheResetInitializedClientType();

                    // Create Account
                    XeUser user = CreateChildXenonUser(CreateXenonUser(false));

                    ulong xuid = user.UserPuid;
                    ValueCheck.TestNonZero("xuid", xuid);

                    ResultCode = TEST_RESULTS.PASSED;

                    Global.RO.Info("GetUserAccountAuthorization for user 0x" + xuid.ToString("X"));

                    LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

                    LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                    aadp._LivePuid = xuid;
                    aadp._Tier = 1; // That's Gold, right?
                    setAADPPrivileges(aadp);
                    aadp._ClientPlatform = XOn.XPLT_WEB;

                    LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.WEB_TITLE_ID, aadp, false);
                    LiveCacheWebSvcResponse response = lcAC.UserAccountAuthorize(xuid,
                        (int)xonline.common.protocol.ServiceTypeEnum.XboxLive,
                        xonline.common.service.XOn.WEB_TITLE_ID);

                    Global.RO.Info("response is {0}", response.response);

                    XmlDocument xmlDoc = new XmlDocument();
                    xmlDoc.LoadXml(response.response);
                    XmlNodeList nodeList = xmlDoc.GetElementsByTagName("HResult");
                    uint hr = uint.Parse(nodeList[0].InnerText);
                    Global.RO.Info("GetUserAccountAuthorization returned 0x{0:X}", hr);

                    if (hr != HResult.S_OK)
                    {
                        Global.RO.Error("GetUserAccountAuthorization should fail");
                        this.ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }

                    nodeList = xmlDoc.GetElementsByTagName("ParentallyControlled");

                    if (nodeList == null || nodeList[0] == null)
                    {
                        Global.RO.Error("Cannot find IsParentallyControlled element");
                        this.ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }

                    bool parentallyControlled = bool.Parse(nodeList[0].InnerText);
                    if (!parentallyControlled)
                    {
                        Global.RO.Error("User should be parentally controlled");
                        this.ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }

                    this.ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                { }

            }

            protected static void setAADPPrivileges(LiveCacheXUacs.AccountAuthDataProvider aadp)
            {
                aadp._Privileges = new uint[8];
                aadp._Privileges[0] = 0;
                aadp._Privileges[1] = 0;
                aadp._Privileges[2] = 0;
                aadp._Privileges[3] = 0;
                aadp._Privileges[4] = 0;
                aadp._Privileges[5] = 0;
                aadp._Privileges[6] = 0x10000000;
                aadp._Privileges[7] = 0x9bf924fc;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcSwitchUserCountry.cs ===
using System;
using System.Collections;
using System.Data;

using ServerTestFramework;
using ServerTestFramework.LiveService;
//using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

using StfUserAccount = ServerTestFramework.LiveService.UserAccount;

namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("yixuanl"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcSwitchUserCountry : TestNode
    {
        [TestCase, TestCasePriority(2)]
        class P_Mainline : UserTestBase
        {
            override protected void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ResultCode = TEST_RESULTS.FAILED;

                // Create silver US account
                XeUser user = UacsCommon.CreateXenonUser(3);

                byte newCountryId = (byte) XeUser.Country.CA;

                var newAddress = xonline.common.stfutil.AccountsUtil.CreateAddressInfo(newCountryId);

                SwitchUserCountryRequest req = new SwitchUserCountryRequest();
                req.trackingGuid = Guid.NewGuid();
                req.userPuid = user.UserPuid;
                req.addressInfo = newAddress;
                req.countryId = newCountryId;
                req.cultureId = CountryLanguage.GetCultureId(newCountryId, user.LanguageId);

                Global.RO.Info("Calling LiveCache");
                LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Xboxcom, XOn.WEB_TITLE_ID, false);
                lcAC.SwitchUserCountry(req);

                UacsCommon.WaitForXCache();
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcVerifyBillingInfo.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    [TestGroup, Owner("shwetap"), TestFrequency("Regression"), TestCasePriority(2)]
    public class LcVerifyBillingInfo : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create a user
            XeUser user = new XeUser();

            user.PaymentInstrumentType = ServerTestFramework.LiveService.UserAccount.PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;

            user.CreditCardInfo = new ServerTestFramework.LiveService.UserAccount.CreditCardInfoData();
            user.CreditCardInfo.AccountHolderName = "Jack Straw";
            user.CreditCardInfo.AccountNumber = CreditCardRandomizer.GetRandomAccountNumber("visa");
            user.CreditCardInfo.CardType = (byte)ServerTestFramework.LiveService.UserAccount.CreditCardInfoData.CreditCardType.Visa;
            user.CreditCardInfo.CcvNumber = "123";
            user.CreditCardInfo.ExpirationDate = DateTime.UtcNow.AddMonths(10);
            user.OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.GoldCC1Month);

            user.PhoneInfo = new ServerTestFramework.LiveService.UserAccount.PhoneInfoData();
            user.PhoneInfo.PhonePrefix = "425";
            user.PhoneInfo.PhoneNumber = "123-4567";

            user.AddressInfo = new ServerTestFramework.LiveService.UserAccount.AddressInfoData();
            user.AddressInfo.SetDefaultAddress(XeUser.Country.US);

            ulong xuid = user.Create();

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);
    
            // 
            xonline.common.protocol.VerifyBillingInfoRequest request = new xonline.common.protocol.VerifyBillingInfoRequest();
            request.gamertag = user.Gamertag;
            request.phonePrefix = user.PhoneInfo.PhonePrefix;
            request.phoneExtension = user.PhoneInfo.PhoneExtension;
            request.phoneNumber = user.PhoneInfo.PhoneNumber;
            request.postalCode = user.AddressInfo.PostalCode;
            request.cardHolder = user.CreditCardInfo.AccountHolderName;
            request.cardNumber = user.CreditCardInfo.AccountNumber;

            xonline.common.protocol.VerifyBillingInfoResponse response;
            try
            {
                response = lcAC.VerifyBillingInfo(xuid, request);
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LiveCacheXuacsCommon.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using xonline.core.history;
using xonline.common.webplatform.livecache;
using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

namespace LiveCacheXUacsTest
{
    public class LiveCacheXUacsCommon
    {
        public static void MakePurchase(XeUser user, ulong[] offerIds, LivecacheClientType clientType, byte clientPlatform, uint clientTitleId, ulong clientMachineId)
        {
            Global.RO.Info("Purchase FamilyGold for user {0}", user.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = user.UserPuid;
            aadp._Tier = UodbWS.GetUserTier(user.UserPuid);
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
            aadp._XboxPuid = clientMachineId;

            xonline.common.protocol.XeOfferPurchaseRequest requestGold =
                        new xonline.common.protocol.XeOfferPurchaseRequest();
            requestGold.userPuid = user.UserPuid;
            requestGold.offerID = 0;
            requestGold.offerIDs = offerIds;
            requestGold.offerIDLength = (uint)requestGold.offerIDs.Length;
            requestGold.languageID = user.LanguageId;
            requestGold.countryID = user.CountryId;
            requestGold.tier = (byte)UodbWS.GetUserTier(user.UserPuid);
            requestGold.paymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard;
            requestGold.paymentInstrumentID = user.AddPaymentInstrumentVisa();
            requestGold.machinePuid = aadp._XboxPuid;

            LcBillingOffering lcBO =
                new LcBillingOffering(clientType, clientTitleId, aadp, false);
            uint hr = lcBO.PurchaseSubscription(requestGold);
            Global.RO.Info(String.Format("lcBO.PurchaseSubscription returned 0x{0:x}", hr));
            if (hr != ServerTestFramework.LiveService.HResult.S_OK)
                throw new UnexpectedTestResultException(string.Format("Purchase FamilyGold failed: {0}", hr.ToString("X")));
        }

        public static void AddDependent(XeUser owner, XeUser dependent, LivecacheClientType clientType, byte clientPlatform, uint clientTitleId, ulong clientMachineId)
        {
            Global.RO.Info("Adding dependent {0}", dependent.UserPuid.ToString("X"));
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = owner.UserPuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
            aadp._ClientPlatform = clientPlatform;
            aadp._XboxPuid = clientMachineId;

            LcAccountCreation lcAC =
                new LcAccountCreation(clientType, clientTitleId, aadp, false);

            xonline.common.protocol.AddDependentRequest req =
                new xonline.common.protocol.AddDependentRequest();
            req.userPuid = dependent.UserPuid;
            req.machinePuid = aadp._XboxPuid;
            req.signedOldOwnerPassportPuid = dependent.PassportOwnerSessionToken;
            req.ownerPuid = owner.UserPuid;

            lcAC.AddDependent(req);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\client\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\client\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\MainClass.cs ===
using System;
using System.Runtime.InteropServices;
using System.Xml;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

using xonline.common.webplatform.livecache;

[assembly: RootNode(typeof(LiveCacheXUacsTest.LiveCacheXUacs))]

namespace LiveCacheXUacsTest
{
    public class LiveCacheXUacs : TestNode
    {
        public class AccountAuthDataProvider :  IExtendedAuthDataProvider
        {
            public ulong LivePuid { get { return _LivePuid; } }
            public byte Tier{ get { return _Tier; } }
            public uint[] Privileges { get { return _Privileges; } }
            public IPEndPoint ClientIPEndPoint { get { return _ClientIPEndPoint; } }

            public ulong XboxPuid { get { return _XboxPuid; } }
            public byte ClientPlatform { get { return _ClientPlatform; } }

            public ulong _LivePuid;
            public byte _Tier;
            public uint[] _Privileges;
            public IPEndPoint _ClientIPEndPoint;

            public ulong _XboxPuid;
            public byte _ClientPlatform;
        }

        public static void DefaultLivecacheLocaleHandler(out uint language, out uint country)
        {
            language = 1;
            country = 103;
        }

        public static void setAADPPrivileges(LiveCacheXUacs.AccountAuthDataProvider aadp)
        {
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
        }

    	public override void PreRun()
    	{
                // set the ReceiveTimeout and SendTimeout for TCP and UDP connection
                // make it 130 seconds since some calls to CSAT (or billing 1box) can take a long time
                FDTransaction.sReceiveTimeOut = 65000 * 2;            
                //Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(Interface.xuacs, "e :xuacs configcacherefresh");
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcXeGetUserWebInfo.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    /// <summary>
    ///     Functional tests for the XeGetUserWebInfo request.
    /// </summary>
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), EnvRequirement("Billing"), TestCasePriority(2)]
    public class XeGetUserWebInfo : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [CompoundCase("XboxCom",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, true)]
        [CompoundCase("Zune",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, true)]
        [CompoundCase("XNA",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, true)]
        [CompoundCase("WGX",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, true)]
        [CompoundCase("LivEn",    LivecacheClientType.LIVEn,    XOn.XPLT_INTERNAL_LIVEN,  XOn.WEB_TITLE_ID, true)]
        [CompoundCase("XboxCom_noAADP",LivecacheClientType.Xboxcom,XOn.XPLT_WEB,           XOn.WEB_TITLE_ID, false)]
        [CompoundCase("Zune_noAADP",   LivecacheClientType.Zune,   XOn.XPLT_ZUNEV2,        XOn.ZUNE_TITLE_ID, false)]
        [CompoundCase("XNA_noAADP",    LivecacheClientType.XNA,    XOn.XPLT_INTERNAL_XNA,  XOn.XENON_DASH_TITLE_ID, false)]
        [CompoundCase("WGX_noAADP",    LivecacheClientType.WGX,    XOn.XPLT_INTERNAL_WGX,  XOn.WEB_TITLE_ID, false)]
        [CompoundCase("LivEn_noAADP",  LivecacheClientType.LIVEn,  XOn.XPLT_INTERNAL_LIVEN,  XOn.WEB_TITLE_ID, false)]
        public void P_Mainline(TestNode me)
        {
            LivecacheClientType clientType = (LivecacheClientType) me.MyValues[0];
            byte clientPlatform = (byte) me.MyValues[1];
            uint clientTitleId = (uint) me.MyValues[2];
            bool bUseAADP = (bool) me.MyValues[3];

            UacsCommon.LiveCacheResetInitializedClientType();
            ulong xuid;
            
            // Create a user
            if(clientType == LivecacheClientType.LIVEn)
            {
                // Create Moblie Account
                byte[] ownerPassportToken; 
                xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
            }
            else
            {
                XeUser user = new XeUser(false);
                xuid = user.Create();
            }

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC;
            if(bUseAADP)
                lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
            else
                lcAC = new LcAccountCreation(clientType, clientTitleId, false);
    
            // XeGetUserWebInfoRequest
            xonline.common.protocol.XeGetUserWebInfoRequest request = new xonline.common.protocol.XeGetUserWebInfoRequest();
            request.userPuid = xuid;

            Global.RO.Info("XeGetUserWebInfoRequest for user 0x" + xuid.ToString("X"));

            xonline.common.protocol.XeGetUserWebInfoResponse response;
            try
            {
                response = lcAC.GetUserWebInfo(request);
                Global.RO.Info("response.isFreeGamertagChangeEligible is {0}", response.isFreeGamertagChangeEligible);
                
                if(clientType == LivecacheClientType.LIVEn && response.isFreeGamertagChangeEligible != true)
                    throw new UnexpectedTestResultException("response.isFreeGamertagChangeEligible should be true.");
            }
            catch(Exception ex)
            {
                Global.RO.Info(ex.ToString());

                if(clientType != LivecacheClientType.XNA)
                    throw;
                    
                if(ex.ToString().Contains("80150011"))
                {
                    Global.RO.Info("got exception with 0x80150011 as expected");
                }
                else
                {
                    Global.RO.Warn("got exception but error code is not 0x80150011");
                }                    
            }

            
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\livecache\test\xuacs\LcXeGetUserAuthorization.cs ===
using System;
using System.Collections;
using System.Data;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.webplatform.livecache;

//using live.common;
using live.internaltest;
using live.protocol;
using live.client;
using live.server;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;


namespace LiveCacheXUacsTest
{
    /// <summary>
    ///     Functional tests for the XeContentEnumerate request.
    /// </summary>
    [TestGroup, Owner("styoo"), TestFrequency("Regression"), TestCasePriority(2)]
    public class GetUserAuthorization : TestNode
    {
		[TestCase, TestCasePriority(2)]
		class P_XboxCom : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Xboxcom, XOn.XPLT_WEB, XOn.XENON_DASH_TITLE_ID);
                
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_Zune : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.Zune, XOn.XPLT_ZUNEV2, XOn.CRUX_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_XNA : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;

                InnerExecute(LivecacheClientType.XNA, XOn.XPLT_INTERNAL_XNA, XOn.XENON_DASH_TITLE_ID);

                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, TestCasePriority(2),TestFrequency("Regression")]
		class P_WGX : TestBase
		{
			protected override void Execute()
			{
                this.ResultCode = TEST_RESULTS.FAILED;
                
                InnerExecute(LivecacheClientType.WGX, XOn.XPLT_INTERNAL_WGX, XOn.XENON_DASH_TITLE_ID);
                    
                this.ResultCode = TEST_RESULTS.PASSED;
			}
		}

        protected static void InnerExecute(LivecacheClientType clientType, byte clientPlatform, uint clientTitleId)
        {
            UacsCommon.LiveCacheResetInitializedClientType();
            
            // Create Zune Account
            XeUser user = new XeUser(true);
            user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
            user.CreateLiveAccountExtra.CreateArgoProfile = true;

            ulong xuid = user.Create();
            ValueCheck.TestNonZero("xuid", xuid);

            //
            LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;

            // AccountAuthDataProvider
            LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
            aadp._LivePuid = xuid;
            aadp._Tier = 3;
            aadp._Privileges = new uint[8];
            aadp._ClientPlatform = clientPlatform;
            LiveCacheXUacs.setAADPPrivileges(aadp);

            //
            LcAccountCreation lcAC = new LcAccountCreation(clientType, clientTitleId, aadp, false);
    
            // 
			LiveCacheWebSvcResponse response = lcAC.GetUserAuthorization(xuid, 2);
            
			Global.RO.Info("response is {0}", response.response);
        }
        
		[TestCase, TestCasePriority(2)]
		class P_ZuneUser_ZuneClient_XPLT_ZUNEV2 : TestBase
		{
			protected override void Execute()
			{
                UacsCommon.LiveCacheResetInitializedClientType();
                string crux_useMusicNetForProvisioning = null;
                Global.RO.Info("Overriding on crux_useMusicNetForProvisioning");

                crux_useMusicNetForProvisioning = Global.XEnv.GetSetting("crux_useMusicNetForProvisioning");

                Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xuacs configcacherefresh");

                try
                {
                    // Create Zune Account
                    XeUser user = new XeUser(true);
                    user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                    user.CreateLiveAccountExtra.CreateArgoProfile = true;

                    ulong xuid = user.Create();
                    ValueCheck.TestNonZero("xuid", xuid);

                    ResultCode = TEST_RESULTS.PASSED;

					Global.RO.Info("GetUserAuthorization for user 0x" + xuid.ToString("X"));

					LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
					
					LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
					aadp._LivePuid = xuid;
					aadp._Tier = 3;
                    setAADPPrivileges(aadp);
					aadp._ClientPlatform = XOn.XPLT_ZUNEV2;

					LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, aadp, false);
					LiveCacheWebSvcResponse response = lcAC.GetUserAuthorization(xuid, 2);

					Global.RO.Info("response is {0}", response.response);

					// Verify client type
					byte clientType;
					string sql = String.Format("select ti_client_type from t_user_per_client_type_data where bi_user_puid = {0}", xuid);
					using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
					{
						ws.PartitionType = WstPartitionType.Logical;
						ws.SetHashVal(xuid);
						ws.CommandSql = sql;
				
		                object obj = ws.ExecuteScalar();
		                if (obj == null) 
		                    throw new UnexpectedTestResultException("No ti_client_type found.");

		                clientType = (byte)obj;
					}

                    Global.RO.Info("clientType = {0} in t_user_per_client_type_data", clientType);
					if(clientType != 16)
						throw new UnexpectedTestResultException("clientType should be 16.");
				
					this.ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Global.RO.Info("Remove overriding on musicnet_purchaseTransactionExpiredSeconds");
                    Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", Convert.ToString(crux_useMusicNetForProvisioning), -1);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xuacs, "e :xuacs configcacherefresh");
                }

			}
		}

	/// <summary>
	/// 	Call  GetUserAuthorization
	/// </summary>
		[TestCase, TestCasePriority(2)]
		class P_ZuneUser_ZuneClient_XPLT_WEB : TestBase
		{
			protected override void Execute()
			{
                UacsCommon.LiveCacheResetInitializedClientType();
                // Create Zune Account
                //XeUser user = new ArgoUser();
                //ulong xuid = user.UserPuid;
                //live.common.XblUser user = UserCreator.CreateUser(live.common.XblUserTier.Silver, live.common.PassportType.Real, live.common.CountryId.US, UserCreatorOption.Zune);
                //ulong xuid = user.Puid;

                string crux_useMusicNetForProvisioning = null;
                Global.RO.Info("Overriding on crux_useMusicNetForProvisioning");

                crux_useMusicNetForProvisioning = Global.XEnv.GetSetting("crux_useMusicNetForProvisioning");

                Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xuacs configcacherefresh");

                try
                {
                    XeUser user = new XeUser(true);
                    user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                    user.CreateLiveAccountExtra.CreateArgoProfile = true;

                    ulong xuid = user.Create();
                    ValueCheck.TestNonZero("xuid", xuid);

                    ResultCode = TEST_RESULTS.PASSED;

					Global.RO.Info("GetUserAuthorization for user 0x" + xuid.ToString("X"));

					LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
					
					LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
					aadp._LivePuid = xuid;
					aadp._Tier = 3;
                    setAADPPrivileges(aadp);
					aadp._ClientPlatform = XOn.XPLT_WEB;

					LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, aadp, false);
					LiveCacheWebSvcResponse response = lcAC.GetUserAuthorization(xuid, 2);

					Global.RO.Info("response is {0}", response.response);
				
					// Verify client type
					byte clientType;
					string sql = String.Format("select ti_client_type from t_user_per_client_type_data where bi_user_puid = {0}", xuid);
					using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
					{
						ws.PartitionType = WstPartitionType.Logical;
						ws.SetHashVal(xuid);
						ws.CommandSql = sql;
					
						object obj = ws.ExecuteScalar();
						if (obj == null) 
							throw new UnexpectedTestResultException("No ti_client_type found.");
					
						clientType = (byte)obj;
					}
					
					Global.RO.Info("clientType = {0} in t_user_per_client_type_data", clientType);
					if(clientType != 8)
						throw new UnexpectedTestResultException("clientType should be 8.");

					this.ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    Global.RO.Info("Remove overriding on musicnet_purchaseTransactionExpiredSeconds");
                    Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", Convert.ToString(crux_useMusicNetForProvisioning), -1);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xuacs, "e :xuacs configcacherefresh");
                }

			}
		}

        public class CountryInfo
        {
            public byte countryId;
            public string countryCode;
            public bool bDorado;
            public bool bMobille;
            public bool bPMX;
            public bool bDevice;
            public bool bC9;
            public bool bLynx;

            public CountryInfo(byte _countryId, string _countryCode, bool _bDorado, bool _bMobille, bool _bPMX, bool _bDevice, bool _bC9, bool _bLynx)
            {
                countryId = _countryId;
                countryCode = _countryCode;
                bDorado = _bDorado;
                bMobille = _bMobille;
                bPMX = _bPMX;
                bDevice = _bDevice;
                bC9 = _bC9;
                bLynx = _bLynx;
            }
        }

        static CountryInfo[] ZuneCountryInfo = {
            new CountryInfo(5,"AT",  true, true, false,false,true, true),
            new CountryInfo(6,"AU",  true, true, false,false,true, true),
            new CountryInfo(8,"BE",  true, true, false,false,true, true),
            new CountryInfo(16,"CA", true, true, false,false,true, true),
            new CountryInfo(18,"CH", true, true, false,false,true, true),
            new CountryInfo(24,"DE", true, true, true, false,true, true),
            new CountryInfo(25,"DK", true,true,false,false,true, true),
            new CountryInfo(31,"ES", true, true, true, false,true, true),
            new CountryInfo(32,"FI", true,true,false,false,true, true),
            new CountryInfo(34,"FR", true, true, true, false,true, true),
            new CountryInfo(35,"GB", true, true, true, false,true, true),
            new CountryInfo(39,"HK", true, true, false,false,false,true),
            new CountryInfo(44,"IE", true, true, true, false,true, true),
            new CountryInfo(46,"IN", true, true, false,false,false,true),
            new CountryInfo(50,"IT", true, true, true, false,true, true),
            new CountryInfo(53,"JP", true,true,false,false,true, true),
            new CountryInfo(56,"KR", true,true,false,false,false,true),
            new CountryInfo(71,"MX", true, true, false,false,true, true),
            new CountryInfo(74,"NL", true, true,true, false,true, true),
            new CountryInfo(75,"NO", true,true,false,false,true, true),
            new CountryInfo(76,"NZ", true, true, false,false,true, true),
            new CountryInfo(90,"SE", true,true,false,false,true, true),
            new CountryInfo(91,"SG", true, true, false,false,false,true),
            new CountryInfo(103,"US",true, true, true, true, true, true)
        };

		[TestCase, TestCasePriority(2)]
        class P_XenonUser_ZuneClient_XPLT_ZUNEV2_AllCountries : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ulong xuid;
                this.ResultCode = TEST_RESULTS.PASSED;

                string crux_useMusicNetForProvisioning = null;
                Global.RO.Info("Overriding on crux_useMusicNetForProvisioning");
        
                crux_useMusicNetForProvisioning = Global.XEnv.GetSetting("crux_useMusicNetForProvisioning");
        
                Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xuacs configcacherefresh");
        
                try
                {
                    foreach ( CountryInfo cInfo in ZuneCountryInfo)
                    {
                        // Create Account
                        XeUser user = new XeUser(false, (XeUser.Country)cInfo.countryId);
                        user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                        user.CreateLiveAccountExtra.CreateArgoProfile = true;
                        
                        xuid = user.Create();
                        ValueCheck.TestNonZero("xuid", xuid);
                        
                        Global.RO.Info(String.Format("GetUserAuthorization for user 0x{0:X} in {1}",xuid.ToString("X"), cInfo.countryCode));
                    
        
                        LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
                        
                        LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                        setAADPPrivileges(aadp);
                        aadp._LivePuid = xuid;
                        aadp._Tier = 3;
                        aadp._ClientPlatform = XOn.XPLT_ZUNEV2;
            
                        LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, aadp, false);
                        LiveCacheWebSvcResponse response = lcAC.GetUserAuthorization(xuid, 2);
                        //Global.RO.Info("response is {0}", response.response);

                        XmlDocument xmlDoc = new XmlDocument();
                        xmlDoc.LoadXml(response.response);
                        XmlNodeList nodeList = xmlDoc.GetElementsByTagName("HResult");
                        uint hr = uint.Parse(nodeList[0].InnerText);
                        Global.RO.Info("GetUserAuthorization returned 0x{0:X}", hr);

                        if(hr == HResult.S_OK)
                        {
                            if(cInfo.bDorado == false)
                            {
                                Global.RO.Error("GetUserAuthorization should fail");
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if(cInfo.bDorado == true)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                            else if(cInfo.bDorado == false && hr != HResult.XONLINE_E_ACCOUNTS_COUNTRY_NOT_AUTHORIZED)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                }
                finally
                {
                    Global.RO.Info("Remove overriding on musicnet_purchaseTransactionExpiredSeconds");
                    Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", Convert.ToString(crux_useMusicNetForProvisioning), -1);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xuacs, "e :xuacs configcacherefresh");
                }
        
            }
        }

		[TestCase, TestCasePriority(2)]
        class P_XenonUser_ZuneClient_XPLT_MOBILE_AllCountries : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ulong xuid;
                this.ResultCode = TEST_RESULTS.PASSED;

                string crux_useMusicNetForProvisioning = null;
                Global.RO.Info("Overriding on crux_useMusicNetForProvisioning");
        
                crux_useMusicNetForProvisioning = Global.XEnv.GetSetting("crux_useMusicNetForProvisioning");
        
                Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xuacs configcacherefresh");
        
                try
                {
                    foreach ( CountryInfo cInfo in ZuneCountryInfo)
                    {
                        // Create Account
                        XeUser user = new XeUser(false, (XeUser.Country)cInfo.countryId);
                        user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                        user.CreateLiveAccountExtra.CreateArgoProfile = true;
                        
                        xuid = user.Create();
                        ValueCheck.TestNonZero("xuid", xuid);
                        
                        Global.RO.Info(String.Format("GetUserAuthorization for user 0x{0:X} in {1}",xuid.ToString("X"), cInfo.countryCode));
                    
        
                        LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
                        
                        LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                        setAADPPrivileges(aadp);
                        aadp._LivePuid = xuid;
                        aadp._Tier = 3;
                        aadp._ClientPlatform = XOn.XPLT_MOBILE;
            
                        LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, aadp, false);
                        LiveCacheWebSvcResponse response = lcAC.GetUserAuthorization(xuid, 2);
                        //Global.RO.Info("response is {0}", response.response);

                        XmlDocument xmlDoc = new XmlDocument();
                        xmlDoc.LoadXml(response.response);
                        XmlNodeList nodeList = xmlDoc.GetElementsByTagName("HResult");
                        uint hr = uint.Parse(nodeList[0].InnerText);
                        Global.RO.Info("GetUserAuthorization returned 0x{0:X}", hr);

                        if(hr == HResult.S_OK)
                        {
                            if(cInfo.bMobille == false)
                            {
                                Global.RO.Error("GetUserAuthorization should fail");
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if(cInfo.bMobille == true)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                            else if(cInfo.bMobille == false && hr != HResult.XONLINE_E_ACCOUNTS_COUNTRY_NOT_AUTHORIZED)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                }
                finally
                {
                    Global.RO.Info("Remove overriding on musicnet_purchaseTransactionExpiredSeconds");
                    Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", Convert.ToString(crux_useMusicNetForProvisioning), -1);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xuacs, "e :xuacs configcacherefresh");
                }
        
            }
        }
        
		[TestCase, TestCasePriority(2)]
        class P_XenonUser_ZuneClient_XPLT_ZUNE_MOBILE_AllCountries : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ulong xuid;
                this.ResultCode = TEST_RESULTS.PASSED;

                string crux_useMusicNetForProvisioning = null;
                Global.RO.Info("Overriding on crux_useMusicNetForProvisioning");
        
                crux_useMusicNetForProvisioning = Global.XEnv.GetSetting("crux_useMusicNetForProvisioning");
        
                Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xuacs configcacherefresh");
        
                try
                {
                    foreach ( CountryInfo cInfo in ZuneCountryInfo)
                    {
                        // Create Account
                        XeUser user = new XeUser(false, (XeUser.Country)cInfo.countryId);
                        user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                        user.CreateLiveAccountExtra.CreateArgoProfile = true;
                        
                        xuid = user.Create();
                        ValueCheck.TestNonZero("xuid", xuid);
                        
                        Global.RO.Info(String.Format("GetUserAuthorization for user 0x{0:X} in {1}",xuid.ToString("X"), cInfo.countryCode));
                    
        
                        LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
                        
                        LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                        setAADPPrivileges(aadp);
                        aadp._LivePuid = xuid;
                        aadp._Tier = 3;
                        aadp._ClientPlatform = XOn.XPLT_ZUNE_MOBILE;
            
                        LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, aadp, false);
                        LiveCacheWebSvcResponse response = lcAC.GetUserAuthorization(xuid, 2);
                        //Global.RO.Info("response is {0}", response.response);

                        XmlDocument xmlDoc = new XmlDocument();
                        xmlDoc.LoadXml(response.response);
                        XmlNodeList nodeList = xmlDoc.GetElementsByTagName("HResult");
                        uint hr = uint.Parse(nodeList[0].InnerText);
                        Global.RO.Info("GetUserAuthorization returned 0x{0:X}", hr);

                        if(hr == HResult.S_OK)
                        {
                            if(cInfo.bLynx == false)
                            {
                                Global.RO.Error("GetUserAuthorization should fail");
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if(cInfo.bLynx == true)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                            else if(cInfo.bLynx == false && hr != HResult.XONLINE_E_ACCOUNTS_COUNTRY_NOT_AUTHORIZED)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                }
                finally
                {
                    Global.RO.Info("Remove overriding on musicnet_purchaseTransactionExpiredSeconds");
                    Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", Convert.ToString(crux_useMusicNetForProvisioning), -1);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xuacs, "e :xuacs configcacherefresh");
                }
        
            }
        }

		[TestCase, TestCasePriority(2)]
        class P_XenonUser_ZuneClient_XPLT_ZUNEV3_AllCountries : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ulong xuid;
                this.ResultCode = TEST_RESULTS.PASSED;

                string crux_useMusicNetForProvisioning = null;
                Global.RO.Info("Overriding on crux_useMusicNetForProvisioning");
        
                crux_useMusicNetForProvisioning = Global.XEnv.GetSetting("crux_useMusicNetForProvisioning");
        
                Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xuacs configcacherefresh");
        
                try
                {
                    foreach ( CountryInfo cInfo in ZuneCountryInfo)
                    {
                        // Create Account
                        XeUser user = new XeUser(false, (XeUser.Country)cInfo.countryId);
                        user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                        user.CreateLiveAccountExtra.CreateArgoProfile = true;
                        
                        xuid = user.Create();
                        ValueCheck.TestNonZero("xuid", xuid);
                        
                        Global.RO.Info(String.Format("GetUserAuthorization for user 0x{0:X} in {1}",xuid.ToString("X"), cInfo.countryCode));
                    
        
                        LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
                        
                        LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                        setAADPPrivileges(aadp);
                        aadp._LivePuid = xuid;
                        aadp._Tier = 3;
                        aadp._ClientPlatform = XOn.XPLT_ZUNEV3;
            
                        LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, aadp, false);
                        LiveCacheWebSvcResponse response = lcAC.GetUserAuthorization(xuid, 2);
                        //Global.RO.Info("response is {0}", response.response);

                        XmlDocument xmlDoc = new XmlDocument();
                        xmlDoc.LoadXml(response.response);
                        XmlNodeList nodeList = xmlDoc.GetElementsByTagName("HResult");
                        uint hr = uint.Parse(nodeList[0].InnerText);
                        Global.RO.Info("GetUserAuthorization returned 0x{0:X}", hr);

                        if(hr == HResult.S_OK)
                        {
                            if(cInfo.bLynx == false)
                            {
                                Global.RO.Error("GetUserAuthorization should fail");
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if(cInfo.bLynx == true)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                            else if(cInfo.bLynx == false && hr != HResult.XONLINE_E_ACCOUNTS_COUNTRY_NOT_AUTHORIZED)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                }
                finally
                {
                    Global.RO.Info("Remove overriding on musicnet_purchaseTransactionExpiredSeconds");
                    Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", Convert.ToString(crux_useMusicNetForProvisioning), -1);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xuacs, "e :xuacs configcacherefresh");
                }
        
            }
        }

		[TestCase, TestCasePriority(2)]
        class P_XenonUser_ZuneClient_XPLT_XBOX360_AllCountries : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ulong xuid;
                this.ResultCode = TEST_RESULTS.PASSED;

                string crux_useMusicNetForProvisioning = null;
                Global.RO.Info("Overriding on crux_useMusicNetForProvisioning");
        
                crux_useMusicNetForProvisioning = Global.XEnv.GetSetting("crux_useMusicNetForProvisioning");
        
                Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xuacs configcacherefresh");

                bool useCache = false;
                try
                {
                    foreach ( CountryInfo cInfo in ZuneCountryInfo)
                    {
                        // toggle the cache setting to confirm both paths work.
                        useCache = !useCache;

                        // Create Account
                        XeUser user = new XeUser(false, (XeUser.Country)cInfo.countryId);
                        user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                        user.CreateLiveAccountExtra.CreateArgoProfile = true;
                        
                        xuid = user.Create();
                        ValueCheck.TestNonZero("xuid", xuid);
                        
                        Global.RO.Info(String.Format("GetUserAuthorization for user 0x{0:X} in {1}, useCache={2}",xuid.ToString("X"), cInfo.countryCode, useCache));
                    
        
                        LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
                        
                        LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                        setAADPPrivileges(aadp);
                        aadp._LivePuid = xuid;
                        aadp._Tier = 3;
                        aadp._ClientPlatform = XOn.XPLT_XBOX360;
            
                        LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, aadp, false);
                        LiveCacheWebSvcResponse response = lcAC.GetUserAuthorization(xuid, 2, useCache);
                        //Global.RO.Info("response is {0}", response.response);

                        XmlDocument xmlDoc = new XmlDocument();
                        xmlDoc.LoadXml(response.response);
                        XmlNodeList nodeList = xmlDoc.GetElementsByTagName("HResult");
                        uint hr = uint.Parse(nodeList[0].InnerText);
                        Global.RO.Info("GetUserAuthorization returned 0x{0:X}", hr);

                        if(hr == HResult.S_OK)
                        {
                            if(cInfo.bC9 == false)
                            {
                                Global.RO.Error("GetUserAuthorization should fail");
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if(cInfo.bC9 == true)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                            else if(cInfo.bC9 == false && hr != HResult.XONLINE_E_ACCOUNTS_COUNTRY_NOT_AUTHORIZED)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                }
                finally
                {
                    Global.RO.Info("Remove overriding on musicnet_purchaseTransactionExpiredSeconds");
                    Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", Convert.ToString(crux_useMusicNetForProvisioning), -1);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xuacs, "e :xuacs configcacherefresh");
                }
        
            }
        }

		[TestCase, TestCasePriority(2)]
        class P_XenonUser_ZuneClient_XPLT_WEB_AllCountries : TestBase
        {
            protected override void Execute()
            {
                UacsCommon.LiveCacheResetInitializedClientType();
                ulong xuid;
                this.ResultCode = TEST_RESULTS.PASSED;

                string crux_useMusicNetForProvisioning = null;
                Global.RO.Info("Overriding on crux_useMusicNetForProvisioning");
        
                crux_useMusicNetForProvisioning = Global.XEnv.GetSetting("crux_useMusicNetForProvisioning");
        
                Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", "false", -1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xuacs configcacherefresh");
        
                try
                {
                    foreach ( CountryInfo cInfo in ZuneCountryInfo)
                    {
                        // Create Account
                        XeUser user = new XeUser(false, (XeUser.Country)cInfo.countryId);
                        user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                        user.CreateLiveAccountExtra.CreateArgoProfile = true;
                        
                        xuid = user.Create();
                        ValueCheck.TestNonZero("xuid", xuid);
                        
                        Global.RO.Info(String.Format("GetUserAuthorization for user 0x{0:X} in {1}",xuid.ToString("X"), cInfo.countryCode));
                    
        
                        LivecacheRequest.CurrentLocaleHandler = LiveCacheXUacs.DefaultLivecacheLocaleHandler;
                        
                        LiveCacheXUacs.AccountAuthDataProvider aadp = new LiveCacheXUacs.AccountAuthDataProvider();
                        setAADPPrivileges(aadp);
                        aadp._LivePuid = xuid;
                        aadp._Tier = 3;
                        aadp._ClientPlatform = XOn.XPLT_WEB;
            
                        LcAccountCreation lcAC = new LcAccountCreation(LivecacheClientType.Zune, XOn.CRUX_TITLE_ID, aadp, false);
                        LiveCacheWebSvcResponse response = lcAC.GetUserAuthorization(xuid, 2);
                        //Global.RO.Info("response is {0}", response.response);

                        XmlDocument xmlDoc = new XmlDocument();
                        xmlDoc.LoadXml(response.response);
                        XmlNodeList nodeList = xmlDoc.GetElementsByTagName("HResult");
                        uint hr = uint.Parse(nodeList[0].InnerText);
                        Global.RO.Info("GetUserAuthorization returned 0x{0:X}", hr);

                        if(hr == HResult.S_OK)
                        {
                            if(cInfo.bLynx == false)
                            {
                                Global.RO.Error("GetUserAuthorization should fail");
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                        else
                        {
                            if(cInfo.bLynx == true)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                            else if(cInfo.bLynx == false && hr != HResult.XONLINE_E_ACCOUNTS_COUNTRY_NOT_AUTHORIZED)
                            {
                                Global.RO.Error("GetUserAuthorization failed with 0x{0:X}", hr);
                                this.ResultCode = TEST_RESULTS.FAILED;
                            }
                        }
                    }
                }
                finally
                {
                    Global.RO.Info("Remove overriding on musicnet_purchaseTransactionExpiredSeconds");
                    Global.XEnv.OverrideSetting("ALL", "ALL", "crux_useMusicNetForProvisioning", Convert.ToString(crux_useMusicNetForProvisioning), -1);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xbos_billing_offering, "e :xbos configcacherefresh");
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xuacs, "e :xuacs configcacherefresh");
                }
        
            }
        }


        protected static void setAADPPrivileges(LiveCacheXUacs.AccountAuthDataProvider aadp)
        {
            aadp._Privileges = new uint[8];
            aadp._Privileges[0] = 0;
            aadp._Privileges[1] = 0;
            aadp._Privileges[2] = 0;
            aadp._Privileges[3] = 0;
            aadp._Privileges[4] = 0;
            aadp._Privileges[5] = 0;
            aadp._Privileges[6] = 0x10000000;
            aadp._Privileges[7] = 0x9bf924fc;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\client\LiveInfoClient.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;

using xonline.common.exceptions;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;
using xonline.common.tools;
using xonline.common.sql.sqlclient;

namespace xonline.server.liveinfo.client
{
    public class LiveInfoConfig
    {
        public enum PlatformType : byte
        {
            xenon
        }

        public LiveInfoConfig()
        {

        }

        public LiveInfoConfig(string config)
        {
            try
            {
                string[] configParts = config.Split('.');

                switch(configParts.Length)
                {
                    case 1: // Just the platform name.
                        Platform = (PlatformType)Enum.Parse(typeof(PlatformType), configParts[0]);
                        break;
                    case 4: // Platform.Build.Qfe.BetaGroupId
                        Platform = (PlatformType)Enum.Parse(typeof(PlatformType), configParts[0]);
                        Build = (ushort?)Int32.Parse(configParts[1]);
                        Qfe = (ushort?)Int32.Parse(configParts[2]);
                        BetaGroupId = new Guid(configParts[3]);
                        break;
                    default:
                        // I could put a little more effort into this, but it'll just be caught below...
                        throw new Exception("Invalid config string.  String needs to be either a platform or Platform.Build.Qfe.BetaGroupId format.");
                }
            }
            catch(Exception e)
            {
                throw new XRLException(
                    HResult.XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG,
                    XEvent.Id.LIVEINFO_CLIENT_ERROR,
                    "Problem parsing the config string.  Look inside for more details.",
                    e);
            }
        }

        public void VerifyValidConfig()
        {
            // My horse for an XOR.
            if((Build.HasValue && !Qfe.HasValue) || (!Build.HasValue && Qfe.HasValue))
            {
                throw new XRLException(
                    HResult.XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG,
                    XEvent.Id.LIVEINFO_CLIENT_ERROR,
                    "Invalid config.  Build and qfe must both be supplied or both omitted.");
            }

            if(!Build.HasValue && !Qfe.HasValue && (BetaGroupId != Guid.Empty))
            {
                throw new XRLException(
                    HResult.XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG,
                    XEvent.Id.LIVEINFO_CLIENT_ERROR,
                    "Invalid config.  A beta group cannot be supplied when build and qfe are null.");
            }
        }

        public PlatformType Platform;
        public ushort? Build;
        public ushort? Qfe;
        public Guid BetaGroupId;

        public string ConfigString
        {
            get
            {
                VerifyValidConfig();

                if(!Build.HasValue && !Qfe.HasValue)
                {
                    return Enum.GetName(typeof(PlatformType), Platform);
                }
                else
                {
                    return String.Format("{0}.{1}.{2}.{3}",
                        Enum.GetName(typeof(PlatformType), Platform),
                        Build.ToString(),
                        Qfe.ToString(),
                        BetaGroupId.ToString());
                }
            }
        }
    }

    public class LiveInfoSetting
    {
        public LiveInfoConfig Config;
        public string Name;
        public string Value;
    }

    public static class LiveInfoClient
    {
        public static void RefreshFrontdoors()
        {
            string[] liveinfoFDs = Config.GetServerListByInterface(Interface.liveinfo);

            if(liveinfoFDs.Length == 0)
            {
                throw new XRLException(
                        HResult.XONLINE_E_LIVEINFO_CLIENT_ERROR,
                        XEvent.Id.LIVEINFO_CLIENT_ERROR,
                        "No frontdoors found to refresh.  Check service configuration");
            }

            foreach(string liveinfoFD in liveinfoFDs)
            {
                string output = CMgmtCommand.RunCommand(liveinfoFD, "exec :liveinfo reloadlivehive\r\n");

                if(!output.Equals("LiveInfo - Data reloaded from NPDB"))
                {
                    string exceptionString = String.Format(
                            "Unexpected return from :liveinfo reloadlivehive on server [{0}].  Got [{1}]",
                            liveinfoFD,
                            output);

                    throw new XRLException(
                            HResult.XONLINE_E_LIVEINFO_CLIENT_ERROR,
                            XEvent.Id.LIVEINFO_CLIENT_ERROR,
                            exceptionString);
                }
            }
        }

        public static List<LiveInfoSetting> GetSettings(LiveInfoConfig key)
        {
            // Make the request
            GetLiveConfigIntRequest request = new GetLiveConfigIntRequest();
            request.configname = key.ConfigString;

            // Call over to LiveInfo
            GetLiveConfigIntResponse resp = new GetLiveConfigIntResponse();

            // Make up a fake sg info for the cross center call...
            HTTPAuthData authData = new HTTPAuthData();

            XRLObject2 xrl = resp as XRLObject2;

            HResult hr = XRLUtil.PostXrlRequest(
                    VirtualInterface.liveinfo_int,
                    request.Xrl,
                    authData.GetBase64EncodedString(),
                    request,
                    ref xrl);

            if(HResult.Failed(hr))
            {
                throw new XblException(
                        hr,
                        "Proxy call to LiveInfo failed with error {0}.",
                        hr);
            }

            List<LiveInfoSetting> settings = new List<LiveInfoSetting>();

            foreach(LiveConfigSetting s in resp.settings)
            {
                LiveInfoSetting set = new LiveInfoSetting();
                set.Config = new LiveInfoConfig(s.configname);
                set.Name = s.name;
                set.Value = s.value;

                settings.Add(set);
            }

            return settings;
        }

        public static void SetSetting(LiveInfoConfig config, LiveInfoSetting setting)
        {
            config.VerifyValidConfig();

            try
            {
                using (SqlClient sql = new SqlClient(Interface.npdb))
                {
                    sql.StoredProc = "p_live_registry_set_setting";

                    sql.AddParameter("@vc_environment", Config.Environment);
                    sql.AddParameter("@vc_client_config", Enum.GetName(typeof(LiveInfoConfig.PlatformType), config.Platform));
                    sql.AddParameter("@guid_beta_group_id", config.BetaGroupId);
                    sql.AddParameter("@vc_setting", setting.Name);
                    sql.AddParameter("@vc_value", setting.Value);

                    if(config.Build.HasValue)
                    {
                        sql.AddParameter("@si_build", (ushort)config.Build);
                    }
                    else
                    {
                        sql.AddParameterObject("@si_build", DBNull.Value);
                    }

                    if(config.Qfe.HasValue)
                    {
                        sql.AddParameter("@si_qfe", (ushort)config.Qfe);
                    }
                    else
                    {
                        sql.AddParameterObject("@si_qfe", DBNull.Value);
                    }

                    sql.ExecuteNonQuery();
                }
            }
            catch(Exception e)
            {
                throw new XRLException(
                    HResult.XONLINE_E_LIVEINFO_CLIENT_ERROR,
                    XEvent.Id.LIVEINFO_CLIENT_ERROR,
                    e,
                    "SetSetting failed with exception.  See inner exception for details.");
            }
        }

        public static void RemoveSetting(LiveInfoConfig config, LiveInfoSetting setting)
        {
            try
            {
                using (SqlClient sql = new SqlClient(Interface.npdb))
                {
                    sql.StoredProc = "p_live_registry_remove_setting";

                    sql.AddParameter("@vc_environment", Config.Environment);
                    sql.AddParameter("@vc_client_config", Enum.GetName(typeof(LiveInfoConfig.PlatformType), config.Platform));
                    sql.AddParameter("@guid_beta_group_id", config.BetaGroupId);
                    sql.AddParameter("@vc_setting", setting.Name);

                    if(config.Build.HasValue)
                    {
                        sql.AddParameter("@si_build", (ushort)config.Build);
                    }
                    else
                    {
                        sql.AddParameterObject("@si_build", DBNull.Value);
                    }

                    if(config.Qfe.HasValue)
                    {
                        sql.AddParameter("@si_qfe", (ushort)config.Qfe);
                    }
                    else
                    {
                        sql.AddParameterObject("@si_qfe", DBNull.Value);
                    }

                    sql.ExecuteNonQuery();
                }
            }
            catch(Exception e)
            {
                throw new XRLException(
                    HResult.XONLINE_E_LIVEINFO_CLIENT_ERROR,
                    XEvent.Id.LIVEINFO_CLIENT_ERROR,
                    e,
                    "RemoveSetting failed with exception.  See inner exception for details.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\fd\GetNetworkAuthorizationList.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * Xbox Network Authorization List
 *
 * GetNetworkAuthorizationList.cs
 *
 * Implementation of GetNetworkAuthorization request
 *
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Caching;
using System.Xml.Serialization;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.feapp;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.health;
using xonline.common.sql.webstore;

using xonline.config.sts.interfaces;
using xonline.config.sts.databaseconfig;

[assembly: XomAreaDefinition(XomAreaName.glcTrace)]

namespace xonline.server.liveinfo.fd
{
    public sealed class GetNetworkAuthorizationList : FrontEndHandler<GetNetworkAuthorizationListRequest, GetNetworkAuthorizationListResponse>
    {
        private const ushort MAX_ENDPOINT_LIST = 200;
        private static bool _bSuccessfulLoad = true;
        private static List<UInt32> _misconfiguredList = new List<UInt32>();
        private static Dictionary<UInt32, GetNetworkAuthorizationListResponse> _responseCache = new Dictionary<UInt32, GetNetworkAuthorizationListResponse>();
        private static Dictionary<UInt32, List<Guid>> _businessPartnerTitles = new Dictionary<uint, List<Guid>>();

        public static bool Reload()
        {
            _misconfiguredList.Clear();
            Dictionary<UInt32, GetNetworkAuthorizationListResponse> newResponseCache = new Dictionary<UInt32, GetNetworkAuthorizationListResponse>();
            Dictionary<UInt32, List<Guid>> newBusinessPartnerTitles = new Dictionary<UInt32, List<Guid>>();

            try
            {
                DatabaseConfigurationProvider provider = new DatabaseConfigurationProvider();
                provider.Load();

                foreach(IIEBBusinessPartner partner in provider.IEBBusinessPartners.Values)
                {
                    foreach(ITitle title in partner.Titles.Values)
                    {
                        try
                        {
                            newResponseCache.Add(title.TitleID, BuildResponse(title));
                            
                            if (!newBusinessPartnerTitles.ContainsKey(title.TitleID))
                            {
                                newBusinessPartnerTitles.Add(title.TitleID, new List<Guid>());
                            }
                            newBusinessPartnerTitles[title.TitleID].Add(partner.Id);
                        }
                        catch(Exception e)
                        {
                            Xom.NtEvent(XEvent.Id.GET_NETWORK_AUTHORIZATION_LIST_CONFIG_ERROR, e,
                                    "Failed to load title {0}.  Check internal exception for details.  Loading will continue.",
                                    title.TitleID.ToString());

                            _misconfiguredList.Add(title.TitleID);
                        }
                    }
                }

                _responseCache = newResponseCache;
                _businessPartnerTitles = newBusinessPartnerTitles;
                _bSuccessfulLoad = true;
            }
            catch(Exception e)
            {
                _bSuccessfulLoad = false;
                Xom.NtEvent(XEvent.Id.GET_NETWORK_AUTHORIZATION_LIST_CONFIG_ERROR, e,
                    "Failed to load database configuration.  Check internal exception for more details.");
            }

            return _bSuccessfulLoad;
        }

        public static bool IsLoadedSuccessfully()
        {
            return _bSuccessfulLoad;
        }

        public static string ListTitle(uint titleId)
        {
            StringBuilder sb = new StringBuilder();
            GetNetworkAuthorizationListResponse resp;

            if (_misconfiguredList.Contains(titleId))
            {
                sb.AppendLine("    This title is in the misconfigured titles list. This means");
                sb.AppendLine("    that it is *not* functional. Look at the event log after a");
                sb.AppendLine("    reload for more details.");
            }
            else
            {
                if (!_responseCache.TryGetValue(titleId, out resp) || resp.authorizationList.Length <= 0)
                {
                    sb.AppendLine("    No matching endpoint configuration.");
                }
                else
                {
                    sb.AppendLine("    AppliesTo|Host|Path|FromIp|ToIp|Port|Protocol");

                    foreach (NetworkAuthorizationListItem item in resp.authorizationList)
                    {
                        sb.AppendFormat(String.Format("    {0}|{1}|{2}|{3}|{4}|{5}|{6}", (item.appliesTo == null) ? "<NULL>" : item.appliesTo, 
                                                        item.server, item.path, item.fromIP, item.toIP, item.port, item.protocol));
                        sb.AppendLine();
                    }
                }

                sb.AppendLine();
                sb.AppendLine();

                sb.AppendLine("Business partners configured for this title:");
                if (!_businessPartnerTitles.ContainsKey(titleId) || _businessPartnerTitles[titleId].Count <= 0)
                {
                    sb.AppendLine("    No matching business partner configuration.");
                }
                else
                {
                    foreach (Guid g in _businessPartnerTitles[titleId])
                    {
                        sb.AppendLine("    " + g.ToString());
                    }
                }
            }
         
            return sb.ToString();
        }

        public static List<uint> GetLoadedTitleList()
        {
            return new List<uint>(_responseCache.Keys);
        }

        public static List<uint> GetMisconfiguredTitleList()
        {
            return _misconfiguredList;
        }

        private static GetNetworkAuthorizationListResponse BuildResponse(ITitle title)
        {
            List<NetworkAuthorizationListItem> endpoints = new List<NetworkAuthorizationListItem>();

            if(title.Endpoints.Count > MAX_ENDPOINT_LIST)
            {
                // This is the maximum number of items that can be in there.  Anything more is a config error.
                throw new XRLException(
                    HResult.E_FAIL,
                    XEvent.Id.GET_NETWORK_AUTHORIZATION_LIST_CONFIG_ERROR,
                    "Title ID {0} has too many endpoints.",
                    title.TitleID);
            }
            foreach(IEndpoint endpoint in title.Endpoints)
            {
                NetworkAuthorizationListItem endpointItem = new NetworkAuthorizationListItem();

                endpointItem.port = (ushort)endpoint.Port;
                endpointItem.server = endpoint.Hostname;
                endpointItem.path = endpoint.Path;
                endpointItem.appliesTo = endpoint.AppliesTo != null ? endpoint.AppliesTo.AppliesToUri.ToString() : "";

                //xbox console is expecting the ip to be in 
                //network byte order, so needs to have the byte order reversed
                endpointItem.fromIP = LiveInfoUtil.ReverseBytes(endpoint.FromIP);
                endpointItem.toIP = LiveInfoUtil.ReverseBytes(endpoint.ToIP);
                endpointItem.protocol = endpoint.ProtocolID;

                endpoints.Add(endpointItem);
            }           

            GetNetworkAuthorizationListResponse resp = new GetNetworkAuthorizationListResponse();
            endpoints.Sort(new Comparison<NetworkAuthorizationListItem>(CompareNALIs));
            resp.authorizationList = endpoints.ToArray();

            return resp;
        }

        public override HResult ProcessRequest(HttpContext ctx, GetNetworkAuthorizationListRequest req, out GetNetworkAuthorizationListResponse resp)
        {
            HResult hr = HResult.S_OK;
            resp = null;
            uint titleId = 0;

            try
            {
                titleId = SGInfo.Current.TitleId;

                if(!_responseCache.TryGetValue(titleId, out resp))
                {
                    throw new XRLException(
                            HResult.E_FAIL,
                            XEvent.Id.GET_NETWORK_AUTHORIZATION_LIST_TITLE_NOT_ALLOWED,
                            "Title ID {0} has no network authorization list.  Perhaps a race condition or maligned title.",
                            titleId);
                }
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;

                throw new XRLException(
                    HResult.E_FAIL,
                    XEvent.Id.GET_NETWORK_AUTHORIZATION_LIST_ERROR,
                    "Exception running GetNetworkAuthorizationList",
                    e);
            }
            finally
            {
                string[] logParts = new string[] {
                    "GNAL",
                    titleId.ToString(),
                    hr.ToString()
                };

                string logMsg = String.Join("|", logParts);

                Xom.Log(XomAreaName.log, logMsg);
            }

            return hr;
        }

        //See TFS #149104
        //The client does not do any processing on the data it receives. It scans through the
        //received list of endpoints, and selects the first match it finds. This means that a case such as:
        //*.google.com vs youtube.google.com, the wildcard match might win despite being less specific,
        //simply because it was first on the list. This comparison sorts the list according to an agreed set of rules,
        //so that the first match the client will hit is the one we want.
        private static int CompareNALIs(NetworkAuthorizationListItem lhs, NetworkAuthorizationListItem rhs)
        {
            //Handle ip address range entries with no hostname. If both are empty their order doesn't
            //matter. Empty entries get floated to the top since IP is more specific.
            if (String.IsNullOrEmpty(lhs.server) && String.IsNullOrEmpty(rhs.server))
                return 0;
            else if (String.IsNullOrEmpty(lhs.server))
                return -1;
            else if (String.IsNullOrEmpty(rhs.server))
                return 1;

            char lhsTop = lhs.server[0];
            char rhsTop = rhs.server[0];

            if (rhsTop == lhsTop)
            {
                if (lhsTop == '*')
                {
                    int lengthRes = rhs.server.Length.CompareTo(lhs.server.Length);

                    //If we are looking at dual wildcards, make sure the most specific wins.                                
                    //Ex: a.y.z.com can match *.z.com as well as *.y.z.com.                     
                    if (lengthRes != 0)
                    {
                        return lengthRes;
                    }
                }

                //If not wild cards, or equal length, sort according to most specific path.                
                return rhs.path.Length.CompareTo(lhs.path.Length);
            }

            //If we simply have different elements, wildcards lose.
            if (lhsTop == '*')
            {
                return 1;
            }

            if (rhsTop == '*')
            {
                return -1;
            }

            //If neither are wildcards, we don't really care about the order. We still want to return
            //a consistent value to distinguish between different "specific" entries during sorting.
            return rhsTop.CompareTo(lhsTop);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\fd\liveinfomgmt.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * Xbox Hive Front-Door (xhive)
 *
 * XHiveMgmt.cs
 *
 * Implementation of XMGMT apis
 *
 */

using System;
using System.Collections;
using System.Collections.Generic;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.health;

[assembly: XomIisInstallerAttribute( Interface.liveinfo )]
[assembly: XomIisInstallerAttribute( Interface.liveinfo_int )]
[assembly: ConfigAttribute(Component.liveinfo)]

[assembly: FrontEndAppInitialization(typeof(xonline.server.liveinfo.fd.LiveInfoMgmt), "Init")]
[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.server.liveinfo.fd
{
    public class LiveInfoMgmt
    {
        private static void Init()
        {
            // Register XMGMT
            XomControl.ControlRequestEvent += new
                XomControl.ControlRequestEventHandler(
                    LiveInfoMgmt.OnControlRequest
                    );

            // Load from NPDB
            GetLiveConfig.LoadLiveHive( );

            // Register for any new setting changes
            Config.LiveRegistrySettingsChange += new
                LiveRegistrySettingsChangeEventHandler(
                    OnLiveRegistrySettingsChange
                    );

            // Register for any multi-setting changes
            Config.MultiSettingChange += new
                MultiSettingChangeEventHandler(
                    OnMultiSettingsChanged
                    );

            // Load GetNetworkAuthorizationList data
            GetNetworkAuthorizationList.Reload();
        }

        public static void OnLiveRegistrySettingsChange(object sender, EventArgs eventArgs)
        {
            // Someone changed the t_live_registry_settings table. Lets do a
            // an automatic reload
            GetLiveConfig.LoadLiveHive();
        }

        public static void OnMultiSettingsChanged(object sender, MultiSettingChangeEventArgs eventArgs)
        {
            switch (eventArgs.MultiSetting)
            {
            case MultiSetting.liveinfo_allowed_shared_config_names:
                // Someone changed the list of configs that are allowed to be
                // shared. The only way to process this is to reload the hive
                GetLiveConfig.LoadLiveHive();
                break;
            }
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            string cmd = args.Command.ToLower();
            switch (args.Command)
            {
                case "help":
                    XomControlConnection.SendMessage(
                        "LiveInfo Server Help\r\n"+
                        "  ReloadNetworkAuthorizationList - Reload the network authorization list\r\n"+
                        "  ReloadNACL                     - Short form of ReloadNetworkAuthorizationList\r\n"+
                        "  ReloadLiveHive                 - Reload the Live Hive\r\n"+
                        "  ListLiveHive                   - Display the contents of the Live Hive\r\n"+
                        "  ListLiveHiveConfig ConfigName  - Display just the top level config, use\r\n"+
                        "                                   ConfigName to get specific name/value\r\n"+
                        "                                   included\r\n"+
                        "  ListLiveSetting SettingName    - Display just the specified setting\r\n"+
                        "  ListTitleNacl titleId          - Displays the endpoints and business\r\n"+
                        "                                   partners configured for this title\r\n", 
                        args.RequestId
                        );
                    args.Handled = true;
                    break;
                case "reloadlivehive":
                    ProcessReloadLiveHive(args);                        
                    args.Handled = true;
                    break;
                case "listlivehive":
                    ProcessListLiveHive(args);
                    args.Handled = true;
                    break;
                case "listlivehiveconfig":
                    ProcessListLiveHiveConfig(args);
                    args.Handled = true;
                    break;
                case "listlivesetting":
                    ProcessListLiveSetting(args);
                    args.Handled = true;
                    break;
                case "reloadnacl":
                case "reloadnetworkauthorizationlist":
                    ProcessReloadNacl(args);
                    args.Handled = true;
                    break;
                case "listtitlenacl":
                    ProcessListTitleNacl(args);
                    args.Handled = true;
                    break;
            }
        }

        public static void ProcessListTitleNacl(ControlRequestEventArgs args)
        {
            UInt32 titleId;
            if (UInt32.TryParse(args.CommandArgs[0], out titleId))
            {
                XomControlConnection.SendMessage(GetNetworkAuthorizationList.ListTitle(titleId), args.RequestId);
            }
            else
            {
                XomControlConnection.SendMessage(String.Format("Invalid titleId. Received:{0}", args.CommandArgs[0]), args.RequestId);
            }
        }

        public static void ProcessReloadNacl(ControlRequestEventArgs args)
        {
            if (GetNetworkAuthorizationList.Reload())
            {
                XomControlConnection.SendMessage("Network Authorization List Cache Reloaded", args.RequestId);
            }
            else
            {
                XomControlConnection.SendMessage("Error reloading network authorization list.  Check eventlog for details.", args.RequestId);
            }
        }

        public static void ProcessReloadLiveHive(ControlRequestEventArgs args)
        {
            HResult hr = GetLiveConfig.LoadLiveHive();
            if (hr == HResult.S_OK)
            {
                XomControlConnection.SendMessage("LiveInfo - Data reloaded from NPDB\r\n", args.RequestId);
            }
            XomControlConnection.SendMessage("LiveInfo - Data reloading failed. Check eventlog\r\n", args.RequestId);
        }

        public static void   ProcessListLiveHive(ControlRequestEventArgs args)
        {
            Dictionary<string, byte[]> rawConfigs = GetLiveConfig.RawConfigs;
            List<LiveHiveConfig>       hiveConfigs = GetLiveConfig.ClientConfigs;
            string                     tempString;
            uint                       hiveCount   = GetLiveConfig.ClientConfigCount;

            tempString = string.Format(
                "Hive contains {0} configurations\r\n",
                hiveCount
                );
            XomControlConnection.SendMessage(
                tempString,
                args.RequestId
                );
            
            // dump each config
            foreach (LiveHiveConfig hiveConfig in hiveConfigs)
            {
                int    length = 0;
                byte[] rawResponse;

                if (rawConfigs.TryGetValue( hiveConfig.Config, out rawResponse) == true)
                {
                    length = rawResponse.Length;
                }

                tempString = string.Format("{0} - {1} bytes\r\n", hiveConfig.Config,length);
                XomControlConnection.SendMessage(
                    tempString,
                    args.RequestId
                    );
            }
        }

        public static void ProcessListLiveHiveConfig(ControlRequestEventArgs args)
        {
            string tempString;
            List<LiveHiveConfig> hiveConfigs = GetLiveConfig.ClientConfigs;
            uint hiveCount                   = GetLiveConfig.ClientConfigCount;
            string configName                = null;

            tempString = string.Format(
                "Hive contains {0} configurations\r\n",
                hiveCount
                );
            XomControlConnection.SendMessage(
                tempString,
                args.RequestId
                );

            if (args.CommandArgs.Length > 0 && string.IsNullOrEmpty(args.CommandArgs[0]) == false)
            {
                configName = args.CommandArgs[0].ToLower();
            }


            bool locatedConfig = false;

            //if we have not defined a specific config name
            //then iterate through all the hiveconfigs
            //if you defined a config name then we
            //will only display that config and exit out of loop
            foreach (LiveHiveConfig hiveConfig in hiveConfigs)
            {
                if (String.IsNullOrEmpty(configName) || (hiveConfig.Config.ToLower() == configName))
                {
                    tempString = string.Format("\r\n{0}\r\n", hiveConfig.Config);
                    XomControlConnection.SendMessage(
                        tempString,
                        args.RequestId
                        );
                }
                
                if (hiveConfig.Config.ToLower() == configName)
                {
                    foreach (NameValuePair nvp in hiveConfig.Settings)
                    {
                            tempString = string.Format(
                                "{0}={1}\r\n",
                                nvp.Name,
                                nvp.Value
                                );
                            XomControlConnection.SendMessage(
                                tempString,
                                args.RequestId
                                );
                    }
                    
                    //we found the one we were looking for
                    //indicate and break out of outer loop
                    locatedConfig = true;
                    break;
                }
            }

            //We were supplied a configName but didnt find it
            if (locatedConfig == false && string.IsNullOrEmpty(configName) == false)
            {
                tempString = string.Format("Config string: \"{0}\" not found\r\n", configName);
                XomControlConnection.SendMessage(
                            tempString,
                            args.RequestId
                            );
            }
        }

        public static void ProcessListLiveSetting(ControlRequestEventArgs args)
        {
            string tempString;
            List<LiveHiveConfig> hiveConfigs = GetLiveConfig.ClientConfigs;
            uint hiveCount                   = GetLiveConfig.ClientConfigCount;
            string settingName               = null;

            tempString = string.Format(
                "Hive contains {0} configurations\r\n",
                hiveCount
                );
            XomControlConnection.SendMessage(
                tempString,
                args.RequestId
                );

            if (args.CommandArgs.Length > 0 && string.IsNullOrEmpty(args.CommandArgs[0]) == false)
            {
                settingName = args.CommandArgs[0].ToLower();
            }
            else
            {
                 XomControlConnection.SendMessage(
                    "No setting name supplied in request for 'listlivesetting'\r\n",
                    args.RequestId
                    );
                 return;
            }

            bool locatedSetting = false;

            //if we have not defined a specific setting name
            //then iterate through all the hiveconfigs
            //if you defined a setting name then we
            //will only display that config name and settings detail
            foreach (LiveHiveConfig hiveConfig in hiveConfigs)
            {
                foreach (NameValuePair nvp in hiveConfig.Settings)
                {
                    if (nvp.Name.ToLower() == settingName)
                    {
                        //send out the main config name
                        tempString = string.Format("\r\n{0}\r\n", hiveConfig.Config);
                            XomControlConnection.SendMessage(
                                tempString,
                                args.RequestId
                                );
            
                        //send out the setting name that matches the specified
                        //name
                        tempString = string.Format(
                            "{0}={1}\r\n",
                            nvp.Name,
                            nvp.Value
                            );
                        XomControlConnection.SendMessage(
                            tempString,
                            args.RequestId
                            );

                        locatedSetting = true;
                        break;
                    }
                } 
            }

            //We were supplied a configName but didnt find it
            if (locatedSetting == false && string.IsNullOrEmpty(settingName) == false)
            {
                tempString = string.Format("Config setting string: \"{0}\" not found\r\n", settingName);
                XomControlConnection.SendMessage(
                            tempString,
                            args.RequestId
                            );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\fd\HealthCheck.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * LiveInfo FD Service
 *
 * HealthCHeck.cs
 *
 * Implementation of HealthCheck for LiveInfo FD
 *
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;

using xonline.common.config;
using xonline.common.health;

namespace xonline.server.liveinfo.fd
{
    public class LiveInfoHealthCheck : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(
            HealthBlockManager  blockManager,
            NameValueCollection blockParams,
            HealthReport        report
            )
        {
            // Allocate structure for LiveInfo specific Health report
            LiveInfoHealthCheckReport myReport = new LiveInfoHealthCheckReport();

            // Make sure that the standard report points to the custom
            // report as well
            report.ExtendedReport = myReport;

            // File in the report with the interesting data
            myReport.ClientConfigCount              = GetLiveConfig.ClientConfigCount;
            myReport.ClientConfigRefreshTime        = GetLiveConfig.ClientConfigRefreshTime.ToString();
            myReport.ClientConfigRefreshFailedTime  = GetLiveConfig.ClientConfigRefreshFailedTime.ToString();
            myReport.ClientConfigRefreshCount       = GetLiveConfig.ClientConfigRefreshCount;
            myReport.ClientConfigRefreshFailedCount = GetLiveConfig.ClientConfigRefreshFailedCount;
            myReport.ClientHealthCheckConfigs       = GetLiveConfig.ClientHealthCheckConfigs;
            myReport.NACLLoadedTitles               = GetNetworkAuthorizationList.GetLoadedTitleList();
            myReport.NACLMisconfiguredTitles        = GetNetworkAuthorizationList.GetMisconfiguredTitleList();

            // Assume that we are healthy and then change that latter
            report.HealthStatus = HealthStatusEnum.Green;

            if(!GetNetworkAuthorizationList.IsLoadedSuccessfully() || myReport.NACLMisconfiguredTitles.Count > 0)
            {
                report.ErrorDetails = "NACL had problems loading from the database  Check the endpoints for tht titles in the misconfigured list.";
                report.HealthStatus = HealthStatusEnum.Red;
            }

            // Failure to re-load the NPDB database means something has gone wrong
            if (GetLiveConfig.ClientConfigRefreshTime < GetLiveConfig.ClientConfigRefreshFailedTime)
            {
                report.ErrorDetails = "A failed reload from NPDB has occurred more recently than a successful load from NPDB. Exception=: " + GetLiveConfig.ClientConfigRefreshException.Message;
                report.HealthStatus = HealthStatusEnum.Yellow;
            }

            if (myReport.ClientConfigCount > GetLiveConfig.ClientConfigLimit)
            {
                report.ErrorDetails = "The client config count: " + myReport.ClientConfigCount.ToString() +  " limit: " + GetLiveConfig.ClientConfigLimit.ToString() + " has been exceeded: " + GetLiveConfig.ClientConfigRefreshException.Message;
                report.HealthStatus = HealthStatusEnum.Yellow;
            }
        }
    }

    // Custom Healthcheck report for the LiveInfoHealthCHeck block
    public class LiveInfoHealthCheckReport : IExtendedHealthReport
    {
        public uint                 ClientConfigCount;
        public string               ClientConfigRefreshTime;
        public string               ClientConfigRefreshFailedTime;
        public uint                 ClientConfigRefreshCount;
        public uint                 ClientConfigRefreshFailedCount;
        public List<LiveHiveConfig> ClientHealthCheckConfigs;
        public List<uint>           NACLLoadedTitles;
        public List<uint>           NACLMisconfiguredTitles;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\fd\LiveInfoUtil.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * LiveInfo FD Service Utilities
 *
 * LiveInfoUtil.cs
 *
 * Implementation of LiveInfoUtil for LiveInfo FD Service
 *
 */

using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.liveinfo.fd
{
    public static class LiveInfoUtil
    {
        public static string EscapeLiveRegistryString(string s)
        {
            return s.Replace("^", "^^").Replace("=", "^=").Replace(";", "^;");
        }

        public static string UnescapeLiveRegistryString(string s)
        {
            return s.Replace("^^", "^").Replace("^=", "=").Replace("^;", ";");
        }

        public static uint ReverseBytes(uint inValue)
        {
            return (inValue & 0x000000FFU) << 24 | (inValue & 0x0000FF00U) << 8 |
                   (inValue & 0x00FF0000U) >> 8 | (inValue & 0xFF000000U) >> 24;
        }
    }
} // namespace xonline.server.liveinfo.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\fd\PerfCounters.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * LiveInfo FD Service
 *
 * PerfCounters.cs
 *
 * Implementation of PerfCounters for LiveInfo FD Service
 *
 */

using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.liveinfo.fd
{
    [XomPerformanceCounterCategoryAttr( "LiveInfo FD", "Xbox Live LiveInfo Service Performance Counters" )]
    public class LiveInfoCounters : XomPerformanceCounterCategory
    {
        static public LiveInfoCounters Counters = new LiveInfoCounters();

        public virtual LiveInfoCounters this[string instance]
        {
            get
            {
                return (LiveInfoCounters) GetInstance(instance);
            }
        }

        // Totals across all requests served by the gateway
        [XomPerformanceCounterAttr(
             "LoadFromNpdb: Total",
             "Total number of times reloaded from NPDB",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalLoadFromNpdb;

        [XomPerformanceCounterAttr(
             "LoadFromNpdb: Failed",
             "Failed number of times reloading from NPDB",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalFailedLoadFromNpdb;

        [XomPerformanceCounterAttr(
             "LoadFromNpdb: Succeeded",
             "Succeeded number of times reloading from NPDB",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalSucceededLoadFromNpdb;

    }


} // namespace xonline.server.liveinfo.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\fd\GetLiveConfigInt.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * Xbox Live Info Front-Door (Live Info)
 *
 * GetLiveConfig.cs
 *
 * Implementation of GetLiveConfig request
 *
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Caching;
using System.Xml.Serialization;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.health;
using xonline.common.sql.webstore;

[assembly: XomAreaDefinition(XomAreaName.glcTrace)]

namespace xonline.server.liveinfo.fd
{
    public sealed class GetLiveConfigInt : IHttpHandler
    {
        public void ProcessRequest(HttpContext ctx)
        {
            HResult hr = HResult.S_OK;

            GetLiveConfigIntRequest req = new GetLiveConfigIntRequest();
            GetLiveConfigIntResponse resp = new GetLiveConfigIntResponse();
            Dictionary<string, LiveConfigSetting> settings = new Dictionary<string, LiveConfigSetting>();

            Xom.Trace(XomAreaName.glcTrace, LogLevel.L_LOW, "GetLiveConfigInt: entered.");

            // Parse request
            try
            {
                req.ReadFromRequest(ctx.Request);

                string[] configParts = req.configname.Split('.');

                switch(configParts.Length)
                {
                    case 1: // Just the platform name.
                        ExtractSettings(configParts[0], ref settings);
                        break;
                    case 4: // Platform.Build.Qfe.BetaGroupId
                        // First, take the settings for the platform.
                        ExtractSettings(configParts[0], ref settings);

                        // Now take the settings for that build, but no group
                        string buildConfig = String.Format(
                                "{0}.{1}.{2}.{3}",
                                configParts[0],
                                configParts[1],
                                configParts[2],
                                Guid.Empty);

                        ExtractSettings(buildConfig, ref settings);

                        // Now get their beta settingsx
                        if(new Guid(configParts[3]) != Guid.Empty)
                        {
                            ExtractSettings(req.configname, ref settings);
                        }
                        break;

                    default:
                    // I could put a little more effort into this, but it'll just be caught below...
                    throw new Exception("Invalid config string.  String needs to be either a platform or Platform.Build.Qfe.BetaGroupId format.");
                }
            }
            catch (Exception e)
            {
                // We deliberately hand back the same error here as the
                // case where we could parse the request, so that the attacker
                // doesn't know that they caused an exception
                hr = HResult.XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG;

                Xom.NtEvent(XEvent.Id.LIVEINFO_HIVE_HACK_ERROR_PROCESSING_REQUEST, e,
                    "Invalid GetLiveConfigInt request"
                );
            }
            finally
            {
                if (HResult.Failed(hr))
                {
                    XRLUtil.SetXRLResponse(
                        ctx.Response,
                        XOService.Liveinfo,
                        0,
                        hr
                        );
                }
                else
                {
                    // Set up the response
                    resp.settings = new LiveConfigSetting[settings.Values.Count];
                    settings.Values.CopyTo(resp.settings, 0);

                    XRLUtil.SetXRLResponse(
                        ctx.Response,
                        XOService.Liveinfo,
                        0,
                        hr,
                        resp);
                }

                string[] logParts = new string[] {
                    "GLCI",
                    req.configname,
                    hr.ToString()
                };

                string logMsg = String.Join("|", logParts);

                Xom.Log(XomAreaName.log, logMsg);

                Xom.Trace(XomAreaName.glcTrace, LogLevel.L_LOW, "GetLiveConfigInt: exiting.");
            }
        }

        public static void ExtractSettings(string config, ref Dictionary<string, LiveConfigSetting> dict)
        {
            // Note that if there's no settings, this doesn't throw an error.  That's fine.
            foreach(LiveHiveConfig c in GetLiveConfig.ClientConfigs)
            {
                if(c.Config == config)
                {
                    foreach(NameValuePair nvp in c.Settings)
                    {
                        LiveConfigSetting set = new LiveConfigSetting();
                        set.configname = c.Config;
                        set.name = LiveInfoUtil.UnescapeLiveRegistryString(nvp.Name);
                        set.value = LiveInfoUtil.UnescapeLiveRegistryString(nvp.Value);

                        dict[set.name] = set;
                    }
                }
            }
        }

        //
        // Can this instance be reused?
        // Since we hold no state in the requests, then the answer is yes.
        //
        public bool IsReusable { get { return true; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\Hive\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\fd\GetLiveConfig.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * Xbox Live Info Front-Door (Live Info)
 *
 * GetLiveConfig.cs
 *
 * Implementation of GetLiveConfig request
 *
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Caching;
using System.Xml.Serialization;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.health;
using xonline.common.sql.webstore;

[assembly: XomAreaDefinition(XomAreaName.glcTrace)]

namespace xonline.server.liveinfo.fd
{
    public sealed class GetLiveConfig : IHttpHandler
    {
        public void ProcessRequest(HttpContext ctx)
        {
            Dictionary<string, byte[]> localHive = LiveHive;
            GetLiveConfigRequest req = new GetLiveConfigRequest();
            string configname = "[Not Specified]";
            HResult hr = HResult.S_OK;
            byte[] rawResponse = null;

            Xom.Trace(XomAreaName.glcTrace, LogLevel.L_LOW, "GetLiveConfig: entered.");

            // Parse request
            try
            {
                req.ReadFromRequest(ctx.Request);
                Xom.Trace(
                    "glcTrace",
                    LogLevel.L_NORMAL,
                    "GetLiveConfig: request parsed:" + req.ToString()
                    );

                // Iterate through the ordered list of possible config names. By the end of this either we have the right settings or there are no settings.
                foreach (string possibleConfigName in GetConfigNames(req.configname, SGInfo.Current.BuildNumber.ToString(), SGInfo.Current.QFENumber.ToString(), new SGMachineBetaGroupMgr()))
                {
                    if (localHive.TryGetValue(possibleConfigName, out rawResponse))
                    {
                        configname = possibleConfigName;
                        break;
                    }
                }

                // Did we find some bytes to send back?
                if (rawResponse != null)
                {
                    // Send reply
                    XRLUtil.SetXRLResponse(
                        ctx.Response,
                        XOService.Liveinfo,
                        hr,
                        rawResponse
                        );
                    Xom.Trace(
                        "glcTrace",
                        LogLevel.L_LOW,
                        "GetLiveConfig: completed successfully."
                        );
                }
                else
                {
                    hr = HResult.XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG;
                }

            }
            catch (Exception e)
            {
                // We deliberately hand back the same error here as the
                // case where we could parse the request, so that the attacker
                // doesn't know that they caused an exception
                hr = HResult.XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG;

                Xom.NtEvent(XEvent.Id.LIVEINFO_HIVE_HACK_ERROR_PROCESSING_REQUEST, e,
                    "Invalid GetLiveConfig request"
                );
            }
            finally
            {
                string logMsg =
                    "GLC" + "|" +
                    SGInfo.Current.MachineId.ToString("X") + "|" +
                    configname + "|" +
                    hr + "|" +
                    SGInfo.Current.Nonce.ToString("X");
                Xom.Log(XomAreaName.log, logMsg);

                if (HResult.Failed(hr))
                {
                    XRLUtil.SetXRLResponse(
                        ctx.Response,
                        XOService.Liveinfo,
                        hr
                        );
                    Xom.Trace(
                        "glcTrace",
                        LogLevel.L_HIGH,
                        logMsg
                        );
                }
            }

            Xom.Trace(XomAreaName.glcTrace, LogLevel.L_LOW, "GetLiveConfig: exiting.");
            return;
        }

        //
        // Can this instance be reused?
        // Since we hold no state in the requests, then the answer is yes.
        //
        public bool IsReusable { get { return true; } }

        //
        // Configuration portions
        //
        public static HResult LoadLiveHive()
        {
            HResult hr = HResult.S_OK;
            try
            {
                _LoadLiveHive(ref LiveHive, ref LiveHiveConfigs, ref LiveHiveHealthCheckConfigs);
                LiveHiveRefreshTime = DateTime.Now;
                Interlocked.Increment(ref LiveHiveRefreshCount);
                LiveInfoCounters.Counters.TotalSucceededLoadFromNpdb.Increment();
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.LIVEINFO_HIVE_CONFIG_ERROR_LOADING, e,
                    "NPDB stored procedure p_live_registry_get_all_settings failed."
                );

                hr = HResult.XONLINE_E_LIVEINFO_HIVE_ERROR_LOADING_CONFIG;
                Interlocked.Increment(ref LiveHiveRefreshFailedCount);
                LiveInfoCounters.Counters.TotalFailedLoadFromNpdb.Increment();
                LiveHiveRefreshException = e;
                LiveHiveRefreshFailedTime = DateTime.Now;

            }
            finally
            {
                LiveInfoCounters.Counters.TotalLoadFromNpdb.Increment();
            }
            return hr;
        }

        private static void _LoadLiveHive(
            ref Dictionary<string, byte[]> localLiveHive,
            ref List<LiveHiveConfig> localLiveHiveConfigs,
            ref List<LiveHiveConfig> localLiveHiveHealthConfigs
            )
        {
            // Local variable for the final dictionary
            // [config_name.build_num.qfe_num] = byte[]
            Dictionary<string, byte[]> finalHive;

            // Local variable for the intermediate dictionary
            // [config_name.build_num.qfe_num] = string
            // [config_name] = string
            Dictionary<string, string> intermediateHive;

            // Local variable for the main working-set dictionary. This is
            // the dictionary that we will use to build the final directionary
            // [config_name][build_num.qfe_num][setting] = string
            Dictionary<string, Dictionary<string, Dictionary<string, string>>> mainHive;

            // Local variable for the beta group working set dictionary. This
            // dictionary differs from the mainHive in that all of the entries
            // here belong only to machines in beta groups
            // [config_name][group_id][build_num.qfe_num][setting] = string
            Dictionary<string, Dictionary<string, Dictionary<string, Dictionary<string, string>>>> betaGroupHive;

            // Local variable for the non-build specific settings. This is
            // the dictionary whose contents we will merge into the working-set
            // dictionary to produce the final working-set dictionary
            // [config_name][setting] = string
            Dictionary<string, Dictionary<string, string>> secondaryHive;

            // Local variable to store the multi-setting dictionary that will
            // allow the FD to determine whether a config can be access by both
            // config.build.qfe and by config
            // [config_name] = bool
            Dictionary<string, bool> sharedConfigNames;

            // Local variable to hold the hive config
            List<LiveHiveConfig> hiveConfigs;
            List<LiveHiveConfig> hiveHealthConfigs;

            // Local variable to store the multi-setting we got back from config
            string[] multiSetting;

            // Local variable to help us build strings
            StringBuilder localSettings;

            Xom.Trace(XomAreaName.glcTrace, LogLevel.L_HIGH, "GetLiveConfig: Loading Settings from NPDB");

            // Padding for readability
            intermediateHive = new Dictionary<string, string>(
                StringComparer.InvariantCultureIgnoreCase
                );
            sharedConfigNames = new Dictionary<string, bool>(
                StringComparer.InvariantCultureIgnoreCase
                );
            hiveConfigs       = new List<LiveHiveConfig>();
            hiveHealthConfigs = new List<LiveHiveConfig>();

            BuildInitialHives(out mainHive, out betaGroupHive, out secondaryHive);

            // Obtain the list of configs that are allowed to be accessed by
            // both the canonical format of config.build.qfe and by the short
            // format of just config.
            multiSetting = Config.GetMultiSetting(
                MultiSetting.liveinfo_allowed_shared_config_names
                );
            foreach (string setting in multiSetting)
            {
                sharedConfigNames[setting] = true;
            }

            // For every setting that we have in the secondary hive, make sure
            // that this setting/value is present in the leaf of the main hive
            foreach (KeyValuePair<string, Dictionary<string, Dictionary<string, string>>> kvpConfig in mainHive)
            {
                // Loop over all the build_qfe
                foreach (KeyValuePair<string, Dictionary<string, string>> kvpBuildQfe in kvpConfig.Value)
                {
                    // Loop over all the named configs in the secondary hive
                    foreach (KeyValuePair<string, Dictionary<string, string>> kvpSecondary in secondaryHive)
                    {
                        // We can skip if this config doesn't have settings that
                        // applies to the main hive
                        if (kvpSecondary.Key != kvpConfig.Key)
                        {
                            continue;
                        }

                        // Loop over all the settings in the secondary named
                        // config of the secondary hive
                        foreach (KeyValuePair<string, string> kvpSetting in kvpSecondary.Value)
                        {
                            // Does this setting exist in the specified config
                            // and build? If not, then add it
                            if (kvpBuildQfe.Value.ContainsKey(kvpSetting.Key) == false)
                            {
                                kvpBuildQfe.Value[kvpSetting.Key] =
                                    kvpSetting.Value;
                            }
                        }
                    }

                    // Do the beta hives support this config? If not, then nothing to do
                    if (betaGroupHive.ContainsKey(kvpConfig.Key) == false)
                    {
                        continue;
                    }

                    // Take the opportunity to backfill any missing settings
                    // into the beta-machine hive
                    foreach (KeyValuePair<string, string> kvpSetting in kvpBuildQfe.Value)
                    {
                        // Loop over all the beta groups
                        foreach (KeyValuePair<string, Dictionary<string, Dictionary<string, string>>> kvpBetaGroups in betaGroupHive[kvpConfig.Key])
                        {
                            // If this beta group doesn't support this build, then ignore it
                            if (kvpBetaGroups.Value.ContainsKey(kvpBuildQfe.Key) == false)
                            {
                                continue;
                            }

                            // Don't overwrite the beta setting
                            if (kvpBetaGroups.Value[kvpBuildQfe.Key].ContainsKey(kvpSetting.Key) == false)
                            {
                                kvpBetaGroups.Value[kvpBuildQfe.Key][kvpSetting.Key] = kvpSetting.Value;
                            }
                        }
                    }
                }
            }

            // For every setting that we have in the secondary hive, make sure
            // that this setting/value is present in the leaf of the beta hives
            foreach (KeyValuePair<string, Dictionary<string, Dictionary<string, Dictionary<string, string>>>> kvpConfig in betaGroupHive)
            {
                // Loop over all the beta groups
                foreach (KeyValuePair<string, Dictionary<string, Dictionary<string, string>>> kvpBetaGroup in kvpConfig.Value)
                {
                    // Loop over all the build_qfe
                    foreach (KeyValuePair<string, Dictionary<string, string>> kvpBuildQfe in kvpBetaGroup.Value)
                    {
                        // Loop over all the named configs in the secondary hive
                        foreach (KeyValuePair<string, Dictionary<string, string>> kvpSecondary in secondaryHive)
                        {
                            // We can skip if this config doesn't have settings that
                            // applies to the main hive
                            if (kvpSecondary.Key != kvpConfig.Key)
                            {
                                continue;
                            }

                            // Loop over all the settings in the secondary named
                            // config of the secondary hive
                            foreach (KeyValuePair<string, string> kvpSetting in kvpSecondary.Value)
                            {
                                // Does this setting exist in the specified config
                                // and build? If not, then add it
                                if (kvpBuildQfe.Value.ContainsKey(kvpSetting.Key) == false)
                                {
                                    kvpBuildQfe.Value[kvpSetting.Key] =
                                        kvpSetting.Value;
                                }
                            }
                        }
                    }
                }
            }

            // At this point, the main hive should have all the elements that it
            // needs, so it is time to start building the final dictionary
            foreach (KeyValuePair<string, Dictionary<string, Dictionary<string, string>>> kvpConfig in mainHive)
            {
                // Loop over all the build_qfe
                foreach (KeyValuePair<string, Dictionary<string, string>> kvpBuildQfe in kvpConfig.Value)
                {
                    string configName = string.Format(
                        "{0}.{1}.{2}",
                        kvpConfig.Key,
                        kvpBuildQfe.Key,
                        LiveHiveTableEntry.NO_GROUP
                        );
                    string setting;

                    // Allocate a new liveHiveConfig so that we can store the
                    // details of this config for the healthcheck
                    LiveHiveConfig hiveConfig       = new LiveHiveConfig(configName);
                    LiveHiveConfig hiveHealthConfig = new LiveHiveConfig(configName);
                    hiveConfigs.Add(hiveConfig);
                    hiveHealthConfigs.Add(hiveHealthConfig);

                    // Allocate the setting string
                    localSettings = new StringBuilder();

                    // Build up the setting string by iterating over all the
                    // key and values
                    foreach (KeyValuePair<string, string> kvpSetting in kvpBuildQfe.Value)
                    {
                        setting = string.Format(
                            "{0}={1};",
                            kvpSetting.Key,
                            kvpSetting.Value
                            );
                        localSettings.Append(setting);
                        hiveConfig.AddSetting(kvpSetting.Key, kvpSetting.Value);
                    }

                    // Store the entry in the intermediate dictionary
                    intermediateHive[configName] = localSettings.ToString();
                }
            }

            // The beta machine hive should have all the elements that it needs
            // so add those to the final dictionary
            foreach (KeyValuePair<string, Dictionary<string, Dictionary<string, Dictionary<string, string>>>> kvpConfig in betaGroupHive)
            {
                // Loop over all the beta groups
                foreach (KeyValuePair<string, Dictionary<string, Dictionary<string, string>>> kvpBetaGroup in kvpConfig.Value)
                {
                    // Loop over all the build_qfe
                    foreach (KeyValuePair<string, Dictionary<string, string>> kvpBuildQfe in kvpBetaGroup.Value)
                    {
                        string configName = string.Format(
                            "{0}.{1}.{2}",
                            kvpConfig.Key,
                            kvpBuildQfe.Key,
                            kvpBetaGroup.Key
                            );
                        string setting;

                        // Allocate a new liveHiveConfig so that we can store the
                        // details of this config for the healthcheck
                        LiveHiveConfig hiveConfig       = new LiveHiveConfig(configName);
                        LiveHiveConfig hiveHealthConfig = new LiveHiveConfig(configName);
                        hiveConfigs.Add(hiveConfig);
                        hiveHealthConfigs.Add(hiveHealthConfig);

                        // Allocate the setting string
                        localSettings = new StringBuilder();

                        // Build up the setting string by iterating over all the
                        // key and values
                        foreach (KeyValuePair<string, string> kvpSetting in kvpBuildQfe.Value)
                        {
                            setting = string.Format(
                                "{0}={1};",
                                kvpSetting.Key,
                                kvpSetting.Value
                                );
                            localSettings.Append(setting);
                            hiveConfig.AddSetting(kvpSetting.Key, kvpSetting.Value);
                        }

                        // Store the entry in the intermediate dictionary
                        intermediateHive[configName] = localSettings.ToString();
                    }
                }
            }

            // We need to do another pass over the entries in the secondaryHive
            // and add the entries that are in the sharedConfigNames dictionary
            // to also be in the final hive
            foreach (KeyValuePair<string, Dictionary<string, string>> kvpConfig in secondaryHive)
            {
                string configName = kvpConfig.Key;

                if (sharedConfigNames.ContainsKey(configName) == false)
                {
                    continue;
                }

                string setting;

                // Allocate a new liveHiveConfig so that we can store the
                // details of this config for the healthcheck
                LiveHiveConfig hiveConfig = new LiveHiveConfig(configName);
                LiveHiveConfig hiveHeathConfig = new LiveHiveConfig(configName);
                hiveConfigs.Add(hiveConfig);
                hiveHealthConfigs.Add(hiveHeathConfig);

                // Allocate the setting string
                localSettings = new StringBuilder();

                // Build up the setting string by iterating over all the
                // key and values
                foreach (KeyValuePair<string, string> kvpSetting in kvpConfig.Value)
                {
                    setting = string.Format(
                        "{0}={1};",
                        kvpSetting.Key,
                        kvpSetting.Value
                        );
                    localSettings.Append(setting);
                    hiveConfig.AddSetting(kvpSetting.Key, kvpSetting.Value);
                }

                // Store the entry in the intermediate dictionary
                intermediateHive[configName] = localSettings.ToString();
            }

            // The final pass is to turn all the entries in the intermediate
            // dictionary into the final dictionary. The reason that we build
            // the intermediate dictionary in several passes was so that we
            // could avoid having to run the code that builds the final
            // dictionary in multiple places
            DictionaryStringValueSerializer finalSerializer = new DictionaryStringValueSerializer(intermediateHive);
            finalHive = finalSerializer.Serialize();

            // Return a Hive in the form of strings for keys and byte[]
            // for values.
            localLiveHive              = finalHive;
            localLiveHiveConfigs       = hiveConfigs;
            localLiveHiveHealthConfigs = hiveHealthConfigs;
        }

        // Accessor functions
        public static uint ClientConfigCount
        {
            get { return (uint)LiveHive.Count; }
        }

        public static DateTime ClientConfigRefreshTime
        {
            get { return LiveHiveRefreshTime; }
        }

        public static DateTime ClientConfigRefreshFailedTime
        {
            get { return LiveHiveRefreshFailedTime; }
        }

        public static Exception ClientConfigRefreshException
        {
            get { return LiveHiveRefreshException; }
        }

        public static uint ClientConfigRefreshCount
        {
            get { return (uint)LiveHiveRefreshCount; }
        }

        public static uint ClientConfigRefreshFailedCount
        {
            get { return (uint)LiveHiveRefreshFailedCount; }
        }

        public static List<LiveHiveConfig> ClientConfigs
        {
            get { return LiveHiveConfigs; }
        }

        public static List<LiveHiveConfig> ClientHealthCheckConfigs
        {
            get { return LiveHiveHealthCheckConfigs; }
        }

        public static uint ClientConfigLimit
        {
            get { return (uint)int.Parse(Config.GetSetting(Setting.liveinfo_clientconfiglimit)); }
        }

        public static Dictionary<string, byte[]> RawConfigs
        {
            get { return LiveHive; }
        }

        // The Hive
        private static Dictionary<string, byte[]> LiveHive = new Dictionary<string, byte[]>(StringComparer.InvariantCultureIgnoreCase);

        // The Hive Details as Name Value Pairs
        private static List<LiveHiveConfig> LiveHiveConfigs = new List<LiveHiveConfig>();

        // The Hive Details as Name Value Pairs
        private static List<LiveHiveConfig> LiveHiveHealthCheckConfigs = new List<LiveHiveConfig>();

        // The last update time of the hive
        private static DateTime LiveHiveRefreshTime = DateTime.MinValue;

        // The last failed update time of the hive
        private static DateTime LiveHiveRefreshFailedTime = DateTime.MinValue;

        // The last exception
        private static Exception LiveHiveRefreshException = new Exception();

        // The number of times that we succeeded reloading the hive
        private static int LiveHiveRefreshCount = 0;

        // The number of times that we failed reloading the hive
        private static int LiveHiveRefreshFailedCount = 0;

        private static void BuildInitialHives(
            out Dictionary<string, Dictionary<string, Dictionary<string, string>>> mainHive,
            out Dictionary<string, Dictionary<string, Dictionary<string, Dictionary<string, string>>>> betaGroupHive,
            out Dictionary<string, Dictionary<string, string>> secondaryHive)
        {
            mainHive = new Dictionary<string, Dictionary<string, Dictionary<string, string>>>(
                StringComparer.InvariantCultureIgnoreCase
                );
            betaGroupHive = new Dictionary<string, Dictionary<string, Dictionary<string, Dictionary<string, string>>>>(
                StringComparer.InvariantCultureIgnoreCase
                );
            secondaryHive = new Dictionary<string, Dictionary<string, string>>(
                StringComparer.InvariantCultureIgnoreCase
                );

            foreach (LiveHiveTableEntry entry in GetLiveHiveEntries())
            {
                // Do we have non-null build and QFE?
                // Note that the constaints on the table enforce
                // that both ushorts are non-null or they are both
                // null
                if (entry.IsBuildAndQfeValid)
                {
                    // Generate the string we will use
                    string build_qfe = String.Format("{0}.{1}", entry.Build, entry.Qfe);

                    // Is this a beta setting or not?
                    if (!entry.IsBetaMachine)
                    {   
                        // Make sure that we have allocated all the dictionariesthat we need in mainHive.
                        EnsureDictionaryEntry(mainHive, entry.ClientConfig, StringToStringStringCreator);
                        EnsureDictionaryEntry(mainHive[entry.ClientConfig], build_qfe, StringToStringCreator);  

                        // No, it is not. Store it in the main hive
                        mainHive[entry.ClientConfig][build_qfe][entry.Setting] = entry.Value;
                    }
                    else
                    {       
                        // Make sure we have allocated all the dictionaries that we need in the beta hive too.
                        EnsureDictionaryEntry(betaGroupHive, entry.ClientConfig, StringToStringStringStringCreator);
                        EnsureDictionaryEntry(betaGroupHive[entry.ClientConfig], entry.BetaGroupId.ToString(), StringToStringStringCreator);
                        EnsureDictionaryEntry(betaGroupHive[entry.ClientConfig][entry.BetaGroupId.ToString()], build_qfe, StringToStringCreator);

                        // Yes, it is. Store it in the beta group hive
                        betaGroupHive[entry.ClientConfig][entry.BetaGroupId.ToString()][build_qfe][entry.Setting] = entry.Value;
                    }
                }
                else
                {
                    // Make sure that we have allocated all the dicationary
                    // that we need
                    EnsureDictionaryEntry(secondaryHive, entry.ClientConfig, StringToStringCreator);

                    // Remember the setting
                    secondaryHive[entry.ClientConfig][entry.Setting] = entry.Value;
                }
            }
        }

        private static IEnumerable<string> GetFlashBetaGroups()
        {
            List<string> groups = new List<string>();

            groups.Add(LiveHiveTableEntry.INITIAL_BETA_GROUP.ToString());
            groups.Add((new Guid("314e6d77-fa85-49f1-9e48-3c46a22c653a")).ToString());

            return groups;
        }

        private class DictionaryStringValueSerializer
        {
            public DictionaryStringValueSerializer(Dictionary<string, string> orig)
            {
                _orig = orig;
            }

            public Dictionary<string, byte[]> Serialize()
            {
                Dictionary<string, byte[]> final = new Dictionary<string, byte[]>(_orig.Count, StringComparer.InvariantCultureIgnoreCase);

                foreach (KeyValuePair<string, string> kvpConfig in _orig)
                {
                    if (!String.IsNullOrEmpty(kvpConfig.Value))
                    {
                        final[kvpConfig.Key] = SerializeLiveConfigValue(kvpConfig.Key, kvpConfig.Value);
                    }
                }

                return final;
            }

            private byte[] SerializeLiveConfigValue(string configName, string value)
            {
                // Turn the string builder object into the final byte
                // array that we will need
                byte[] b = _utf8Encoding.GetBytes(value);

                // At this point, we should be able to build a live
                // response object so that we can turn that into a
                // byte array
                GetLiveConfigResponse resp = new GetLiveConfigResponse();

                // Fill in the absolute number of bytes in the string
                resp.configLen = (uint)b.Length;

                // Turn the reponse into a set of generic blocks
                BlockSerializer serializer = new BlockSerializer(
                    b,
                    1,
                    GetLiveConfigResponse.CONFIG_BLOCK_MAX_COUNT
                    );
                if (serializer.IsEmptyBlockCount)
                {
                    throw new XRLException(
                        HResult.E_FAIL,
                        XEvent.Id.LIVEINFO_HIVE_CONFIG_ERROR_EMPTY_RESPONSE,
                        "Config {0} is Empty.",
                        configName
                        );
                }
                if (serializer.IsBlockCountOutOfRange)
                {
                    throw new XRLException(
                        HResult.E_FAIL,
                        XEvent.Id.LIVEINFO_HIVE_CONFIG_ERROR_TOO_LARGE_RESPONSE,
                        "Config {0} uses more than {1} Blocks",
                        configName,
                        GetLiveConfigResponse.CONFIG_BLOCK_MAX_COUNT
                        );
                }

                // Set the blocks for the response
                resp.configBlocks = serializer.Serialize();
                resp.configBlockCount = (ushort)resp.configBlocks.Length;

                return resp.GetBytes();
            }

            private Dictionary<string, string> _orig;
            UTF8Encoding _utf8Encoding = new UTF8Encoding();
        }

        private delegate TValue ValueCreator<TValue>();

        private static Dictionary<string, Dictionary<string, string>> StringToStringStringCreator()
        {
            return new Dictionary<string, Dictionary<string, string>>(StringComparer.InvariantCultureIgnoreCase);
        }

        private static Dictionary<string, Dictionary<string, Dictionary<string, string>>> StringToStringStringStringCreator()
        {
            return new Dictionary<string, Dictionary<string, Dictionary<string, string>>>(StringComparer.InvariantCultureIgnoreCase);
        }

        private static Dictionary<string, string> StringToStringCreator()
        {
            return new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
        }

        private static void EnsureDictionaryEntry<TKey, TValue>(Dictionary<TKey, TValue> dictionary, TKey key, ValueCreator<TValue> creator)
        {
            if (!dictionary.ContainsKey(key))
            {
                dictionary[key] = creator();
            }
        }

        private sealed class SGMachineBetaGroupMgr
        {
            public bool TryGetBetaGroup(out string groupId)
            {
                groupId = String.Empty;
                if (SGInfo.IsBeta())
                {
                    using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                    {
                        ws.StoredProc = "dbo.p_beta_group_machine_get_groups";
                        ws.AddParameter(ParamType.INPUT, "@bi_machine_puid", SGInfo.Current.MachineId);
                        ws.SetHashVal(SGInfo.Current.MachineId);

                        using (WstDataReader reader = ws.Execute())
                        {
                            // There should only be one record
                            if (reader.Read())
                            {
                                groupId = ((Guid)reader["uid_group_id"]).ToString();
                            }
                        }
                    }
                }

                return !String.IsNullOrEmpty(groupId);
            }
        }

        private static IEnumerable<string> GetConfigNames(string rawConfigName, string build, string qfe, SGMachineBetaGroupMgr mgr)
        {
            string betaGroupId;
            if (mgr.TryGetBetaGroup(out betaGroupId))
            {
                yield return String.Format("{0}.{1}.{2}.{3}", rawConfigName, build, qfe, betaGroupId);
            }

            yield return String.Format("{0}.{1}.{2}.{3}", rawConfigName, build, qfe, LiveHiveTableEntry.NO_GROUP.ToString());
            yield return rawConfigName;
        }

        private sealed class LiveHiveTableEntry
        {
            public string ClientConfig { get { return _clientConfig; } }
            public ushort Build { get { return _build; } }
            public ushort Qfe { get { return _qfe; } }
            public string Setting { get { return _setting; } }
            public string Value { get { return _value; } }
            public Guid BetaGroupId { get { return _betaGroupId; } }
            public bool IsBetaMachine { get { return _isBetaMachine; } }
            public bool IsBuildAndQfeValid { get { return _isBuildAndQfeValid; } }

            public LiveHiveTableEntry(string clientConfig, ushort? build, ushort? qfe, byte betaMachine, string setting, string value, Guid betaGroupId)
            {
                // There is a SQL constraint that ensures that build and qfe are either both null or both non-null
                // so we don't validate that here.
                _clientConfig = clientConfig;
                _isBuildAndQfeValid = build.HasValue && qfe.HasValue;
                if (_isBuildAndQfeValid)
                {
                    _build = build.Value;
                    _qfe = qfe.Value;
                }
                else
                {
                    build = 0;
                    _qfe = 0;
                }
                _setting = setting;
                _value = value;
                _betaGroupId = betaGroupId;
                _isBetaMachine = _betaGroupId != NO_GROUP;
            }

            public static Guid INITIAL_BETA_GROUP = new Guid("1A75281C-6B30-4BA8-80C6-66B339F2BA89");
            public static Guid NO_GROUP = Guid.Empty;
            private readonly string _clientConfig;
            private readonly ushort _build;
            private readonly ushort _qfe;
            private readonly string _setting;
            private readonly string _value;
            private readonly Guid _betaGroupId;
            private readonly bool _isBuildAndQfeValid;
            private readonly bool _isBetaMachine;
        }

        private static IEnumerable<LiveHiveTableEntry> GetLiveHiveEntries()
        {
            using (SqlClient client = new SqlClient(Interface.npdb))
            {
                client.StoredProc = "p_live_registry_get_all_settings";
                client.AddParameter("@vc_environment", Config.Environment);


                using (SqlDataReader reader = client.Execute())
                {
                    while (reader.Read())
                    {
                        string clientConfig = (string)reader["vc_client_config"];
                        string setting = (string)reader["vc_setting"];
                        string value = (string)reader["vc_value"];
                        ushort? build = null;
                        ushort? qfe = null;
                        byte betaMachine = (byte)reader["ti_beta_machine"];
                        Guid betaGroupId = (Guid)reader["guid_beta_group_id"];

                        // We don't tolerate '.' in the client config
                        if (clientConfig.Contains(".") == true)
                        {
                            throw new XRLException(
                                HResult.E_FAIL,
                                XEvent.Id.LIVEINFO_HIVE_CONFIG_ERROR_BAD_CONFIG_NAME,
                                "Config {0} contains a '.' in the name.",
                                clientConfig
                                );
                        }

                        // Do the escape sequence replacement on the key string
                        setting = LiveInfoUtil.EscapeLiveRegistryString(setting);

                        // Remove leading/trailing spaces from the setting
                        setting = setting.Trim();

                        // Do the escape sequence replacement on the value string
                        value = LiveInfoUtil.EscapeLiveRegistryString(value);

                        if (reader.IsDBNull(reader.GetOrdinal("si_build")) == false)
                        {
                            // Grab the build number for future reference
                            build = (ushort)(short)reader["si_build"];

                            // Grab the qfe number for future reference
                            qfe = (ushort)(short)reader["si_qfe"];
                        }

                        yield return new LiveHiveTableEntry(clientConfig, build, qfe, betaMachine, setting, value, betaGroupId);
                    }
                }
            }
        }
    }

    public class LiveHiveConfig
    {
        // Name of the config
        [XmlAttribute]
        public string               Config;

        // Name / Value Pairs for the settings
        public List<NameValuePair>  Settings;

        // Method to add a new NVP
        public void AddSetting(string n, string v)
        {
            NameValuePair info = new NameValuePair();
            info.Name = n;
            info.Value = v;

            Settings.Add(info);
        }

        public LiveHiveConfig(string c)
        {
            Config = c;
            Settings = new List<NameValuePair>();
        }

        public  LiveHiveConfig()
        {
            Settings = new List<NameValuePair>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\Hive\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\Hive\HiveClient.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;
using System.Net;

using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.LiveInfo;
using ServerTestFramework.LiveService.Billing.WebBilling;
using ServerTestFramework.Database;

using xonline.common.config;

using xonline.server.liveinfo.client;

namespace Hive.Client
{
    [TestGroup]
    public class LiveHiveClient : TestNode
    {
        [TestCase, Description("Test client lib GetSettings by getting all xenon settings.")]
        [Owner("chrisban"), TestFrequency("Weekly"), TestCasePriority(1)]
        public class ClientGetSettings : TestNode
        {
            public override void Run()
            {
                // Get all the Xenon settings across all builds.
                LiveInfoConfig config = new LiveInfoConfig();
                config.Build = null;
                config.Qfe = null;
                config.BetaGroupId = Guid.Empty;
                config.Platform = LiveInfoConfig.PlatformType.xenon;

                LiveInfoClient.GetSettings(config);
            }
        }

        [TestCase, Description("Test Set / Remove Settinsg")]
        [Owner("chrisban"), TestFrequency("Weekly"), TestCasePriority(1)]
        public class ClientSetRemoveSettings : TestNode
        {
            public override void Run()
            {
                bool bPassing = false;

                LiveInfoConfig config = new LiveInfoConfig();
                config.Build = 12345;
                config.Qfe = 12345;
                config.BetaGroupId = Guid.NewGuid();
                config.Platform = LiveInfoConfig.PlatformType.xenon;

                LiveInfoSetting set = new LiveInfoSetting();
                set.Name = "ClientLibTestSetting-TEST";
                set.Value = "1";

                // Set a setting.
                LiveInfoClient.SetSetting(config, set);

                // Make sure it takes effect
                LiveInfoClient.RefreshFrontdoors();

                // Make sure we get it.
                List<LiveInfoSetting> lis = LiveInfoClient.GetSettings(config);

                if(lis.Count == 0)
                {
                    throw new UnexpectedTestResultException("GetSettings didn't return any settings for this config, but we just added one!");
                }

                Global.RO.Info("Found settings...");

                foreach(LiveInfoSetting setting in lis)
                {
                    if(setting.Name == set.Name)
                    {
                        bPassing = true;

                        if(setting.Value == set.Value)
                        {
                            Global.RO.Success("Found the setting we made!");
                        }
                        else
                        {
                            Global.RO.Error("Found the setting we made, but it didn't have the value we expected.  Value is {0}", setting.Value);
                        }
                    }
                }

                if(!bPassing)
                {
                    throw new UnexpectedTestResultException("Unable to find added settings.");
                }


                Global.RO.Success("We found the setting!  Now removing it.");
                LiveInfoClient.RemoveSetting(config, set);
                LiveInfoClient.RefreshFrontdoors();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\Hive\HiveStress.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;
using System.Net;

using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.LiveInfo;
using ServerTestFramework.LiveService.Billing.WebBilling;
using ServerTestFramework.Database;

using xonline.common.config;

namespace Hive.Stress
{
    [TestGroup]
    public class LiveHiveStress : TestNode
    {
        /// <summary>
        /// Stress test for GetLiveConfig. This test validates that the server can meet
        /// meet expected TPS (Transactions Per Second) by continually running the test
        /// based on the criteria set in the GUI. 
        /// </summary>
        /// 
        /// <remarks>
        ///     <scenarios>
        ///     <b>Stress:</b> A request is made over and over and the results are validated
        ///     to ensure quality and efficiency of the GetLiveInfo API.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     This test fills the database with over 1000 fake settings to make the
        ///     calls more realistic. Most of our testing is done with very few settings
        ///     in the database. This way we can tell how we will perform with less 
        ///     optimal database/setting configuration
        ///     </section>
        ///
        ///     <dependencies>
        ///     None.
        ///     </dependencies>
        /// </remarks>
        [StressTest(TargetTPS = 1800), Owner("BenRan")]
        public class GetLiveConfigXRL : Hive.Functional.HiveTestNode
        {
            public string expected = "";
            public ServerTestFramework.XeGenericBlock[] blocks = null;
            public uint configLen = 0;
            public override void PreRun(RUN_TYPE runType)
            {
                //
                // Fill the database with settings some valid, some dummy
                // Only if there are no settings now.
                //
                Npdb npdb = new Npdb();
                npdb.ConnectToServer();
                string sql = "SELECT * from t_live_registry_settings WHERE vc_client_config ='stress'";
                System.Data.SqlClient.SqlDataReader reader;

                npdb.ReadData(sql, out reader);
                if (!reader.HasRows)
                {
                    Utils.EmptyConfigDatabase("", "dummy");
                    Utils.EmptyConfigDatabase("", "dummy2");
                    Utils.EmptyConfigDatabase("", "stress");
                    Utils.FillConfigDatabase(500, "dummy", 50, 7777, 1, Utils.NO_GROUP);
                    Utils.FillConfigDatabase(500, "dummy2", 50, 7777, 1, Utils.NO_GROUP);
                    Utils.FillConfigDatabase(280, "stress", 100, 7777, 1, Utils.NO_GROUP);
                    Utils.ReloadLiveRegistry();
                }
                reader.Close();

                //
                // Make the first request to get the correct config string
                // Set the Build and QFE correctly
                //
                XRLGetLiveConfig xrl=CreateXRL("stress");
                xrl.SetClientVersion(2, 0, 7777, 1);
                ExecuteXrl(xrl);

                //
                // Convert the config block to the string to store for 
                // validation.
                //
                expected = xrl.Response.config;
                Global.RO.Success(expected);
                Global.RO.Info("Result Length: {0}", expected.Length);
            }

            public override void Run()
            {
                XRLGetLiveConfig xrl=CreateXRL("stress");
                xrl.SetClientVersion(2, 0, 7777, 1);
                ExecuteXrl(xrl);

                ValueCheck.Test("config value", expected, xrl.Response.config);
            }

            public override void PostRun(RUN_TYPE runType)
            {
                //
                // Clean up all the junk that was inserted into the database
                //
                Utils.EmptyConfigDatabase("", "dummy");
                Utils.EmptyConfigDatabase("", "dummy2");
                Utils.EmptyConfigDatabase("", "stress");
                Utils.ReloadLiveRegistry();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\Hive\Hive.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Xml.Linq;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.LiveInfo;

using xonline.common.config;

namespace Hive.Functional
{
    ///<HighLevel>
    ///The goal of this test plan is define the test coverage for the LIVE HIVE. Included you will find API descriptions, a test matrix, and signoff criteria.
    ///
    ///<b>What is LIVE HIVE?</b>
    ///Thought of as a LIVE Registry, the Xbox LIVE Hive stores client configuration settings that affect symbolic references to online resources, and various knobs that change a client's behavior towards Live. Clients call into a GetClientConfig API that returns relevant values based on the context in which they are requested. Currently this is targeted exclusively towards the Xbox 360. 
    ///
    ///<b>How it works?</b>
    ///The HIVE is a fairly simple concept. The HIVE contains a settings table exists in NPDB, the table name is t_live_registry_settings. 
    ///
    /// <center>
    ///    <Table>
    ///        <tr align="center" bgcolor="#FFFFF0">
    ///            <td>guid_setting</td>
    ///            <td>vc_environment</td>
    ///            <td>vc_client_config</td>
    ///            <td>si_build</td>
    ///            <td>si_qfe</td>
    ///            <td>ti_beta_machine</td>
    ///            <td>vc_setting</td>
    ///            <td>vc_value</td>
    ///        </tr>
    ///        <tr>
    ///           <td>954ed4c9-9a5c-494d-b116-6fa72dd5ee81</td>	
    ///           <td>testnet</td>
    ///           <td>xenon</td>
    ///           <td>NULL</td>
    ///           <td>NULL</td>
    ///           <td>0	</td>
    ///           <td>AdCenterUri</td>	
    ///           <td>http://mfs.msn-int.com/mfs/mfs.aspx</td>
    ///        </tr>
    ///    </Table>
    ///</center>
    ///
    ///GetLiveConfig only has one input value, and that is the config name. The config name is used to gather up all the settings that need to be sent back. The frontdoor code walks through all of the rows in the table and builds a cache for each config name it sees. When a client makes a request, a simple lookup and return is done on the passed in config name. 
    ///
    ///The plan is to put in place some code that picks up on changes and flushes the cache so that the new settings are always available.
    ///
    ///The returned item is a string of name=value pairs.
    ///
    ///Setting1=foo
    ///Setting2=bar
    ///</HighLevel>
    ///<Goals>
    /// 	Verify that requesting info for a specific config name returns only the info for that config name.
    /// 	Verify that sending invalid data will not cause and problems.
    /// 	Verify that database changes are picked up and cached automatically.
    /// 	Verify that performance meets minimum requirements.
    ///</Goals>
    ///<NonGoals>
    /// 	Test NPDB
    ///</NonGoals>
    ///<Implementation>
    ///    <code>
    ///     // GetLiveConfigRequest
    ///     public class GetLiveConfigRequest : XRLObject2
    ///     {
    ///         [WireInfoAttribute(Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH*XOn.UTF8_MULT)]
    ///         public ushort confignameLen;
    ///
    ///         [WireInfoAttribute(SizeParam="confignameLen", Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH)]
    ///         public string configname;
    ///
    ///         public override string Xrl
    ///         {
    ///             get { return "/stfd/getliveconfig.ashx"; }
    ///         }
    ///     }
    ///
    ///     // GetLiveConfigResponse
    ///     public class GetLiveConfigResponse: XRLObject2
    ///     {
    ///         public uint configLen;
    ///
    ///         [WireInfoAttribute(SizeParam="configLen")]
    ///         public string config;
    ///     }
    ///    </code>
    ///    <code>
    ///     public static GetLiveConfigResponse GetLiveConfig(IClient _client, 
    ///                                                         XblUser _user, 
    ///                                                         string _configType)
    ///     {
    ///         GetLiveConfigRequest request = new GetLiveConfigRequest();
    ///         GetLiveConfigResponse response = new GetLiveConfigResponse();
    ///
    ///         request.configname = _configType;
    ///
    ///         uint hr = SendRequest(_client, _user, request, response);
    ///         Throw.IfXErrFailed(hr);
    ///
    ///         return response;
    ///     }
    ///     </code>
    ///</Implementation>
    ///
    public class Doc
    {
    }

    public class HiveTestNode: TestNode
    {
        public ulong MachinePuid;

        public virtual void Setup() {}
        public virtual void Cleanup() {}

        public override void PreRun()
        {
            MachinePuid=MachineEditor.CreateNew().Id;
            Global.RO.Debug("MachinePuid=0x{0}", MachinePuid);

            Setup();
        }

        public override void PostRun()
        {
            Cleanup();
        }

        public XRLGetLiveConfig CreateXRL(string client)
        {
            XRLGetLiveConfig xrl=new XRLGetLiveConfig();
            xrl.Request.configname=client;
            xrl.Slot.machinePuid=MachinePuid;
            xrl.SetClientVersion(2, 0, 0, 0);
            xrl.SetBetaGroupFlag(false);

            return xrl;
        }

        public static void ExecuteXrl(XRLGetLiveConfig xrl)
        {
            if (!xrl.Execute())
            {
                throw new UnexpectedTestResultException("XRLGetLiveConfig error response: "+xrl.ErrorStatusMessage);
            }
        }

        public static void ExecuteXrlExpectingFailure(XRLGetLiveConfig xrl, uint hrError)
        {
            if (xrl.Execute())
            {
                throw new UnexpectedTestResultException("XRLGetLiveConfig unexpectedly succeeded.");
            }

            if (xrl.XErr!=hrError)
            {
                throw new UnexpectedTestResultException("XRLGetLiveConfig failed with the wrong error.  Expected "+Global.XErrToString(hrError)+" but got "+Global.XErrToString(xrl.XErr));
            }
        }
    };

    [TestGroup]
    public class LiveHive : TestNode
    {
        public override void OneTimeSetup()
        {
            //add the setting
            string[] sharedConfigs = {"Test1", 
                                         "Test2", 
                                         "Test3", 
                                         "Test5", 
                                         "TestGen1", 
                                         "TestGen2", 
                                         "TestGen3", 
                                         "TestGen4", 
                                         "TestGen5", 
                                         "Multi", 
                                         "Special", 
                                         "dummy", 
                                         "V2WIQHB1QBX84WLRRSHL5T7SXF9F1YFPLU6SNLMYEO6MUNOBN5J9E243V4KC9WZS", //64 Chars
                                         "V2WIQHB1QBX84WLRRSHL5T7SXF9F1YFPLU6SNLMYEO6MUNOBN5J9E243V4KC9WZST", // 65 Chars
                                         "BuildQfeTest", 
                                         "BuildQfeBetaTest"};
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            String env = xonline.common.config.Config.Environment;
            string sql = "";
            string sql2 = "";

            foreach (string config in sharedConfigs)
            {
                sql += "INSERT INTO t_multisetting_overrides (vc_environment, vc_component, i_site_id, vc_server, vc_multisetting, vc_value) " +
                       "VALUES ('" + env + "', 'ALL', -1, 'ALL', 'liveinfo_allowed_shared_config_names', '" + config + "') \n";
                sql2 += "DELETE FROM t_multisetting_overrides WHERE vc_value = '" + config + "'";
            }

            npdb.IssueCommand(sql2);
            if (0 != npdb.IssueCommand(sql))
            {
                Global.RO.Debug(sql);
            }
            else
            {
                Global.RO.Error(sql);
            }

            //force the component to pick up the change
            Global.XEnv.ExecuteXmgmtCommand("liveinfo", "e :liveinfo configcacherefresh");
        }

        /// <summary>
        /// BVT that verifies that a result is returned from GetLiveConfig. A normal console will
        /// call the GetLiveConfig with just the 'Xenon' parameter. That is exactly what this test
        /// does, the difference is that this will end up pulling up the results for the 'Xenon'
        /// config rather than the results for 'Xenon.Build.QFE' which is what the server actually
        /// requests using the console auth data. While this test case does not validate a real-world
        /// scenario, it provides functional validation that the service is responsive.
        /// <b>Sean is so fun.</b>
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     BVT: A request is made with no Build or QFE Number
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     This test does no validation, it only verifies that a response is returned.
        ///     </section>
        /// </remarks>
        [TestCase, Description("BVT verifies that a result is returned from GetLiveConfig")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(0)]
        public class P_Xenon : HiveTestNode
        {
            public override void Run()
            {
                XRLGetLiveConfig xrl=CreateXRL("xenon");
                ExecuteXrl(xrl);
                Global.RO.Debug("config:\n"+xrl.Response.config);
            }
        }

        /// <summary>
        /// Deeper BVT that really verifies that all of the different configurations in 
        /// an envrionment are valid, rather than just verifying that a response is
        /// returned.
        ///
        /// This test goes through the database, and finds the config names for all
        /// of the current configs. It then calls GetLiveConfig with each of those
        /// configs and compares the result to what it expects. If a value is incorrect
        /// it will spit it out so the tester can investigate.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made to any of the currently loaded configs returns the
        ///     correct result.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     This test does not follow the standard that the xenon console will use to
        ///     call GetLiveConfig, which is Xenon.Build.QFE. This test only validates that
        ///     the main roots are valid and the results are correct.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Verifies that all config names in the database return the correct data")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(0)]
        public class P_GetLiveConfigBvt : HiveTestNode
        {
            public override void Run()
            {
                Utils.EmptyConfigDatabase();
                Utils.FillConfigDatabase(10, "TestGen1", 50);
                Utils.FillConfigDatabase(10, "TestGen2", 50);
                Utils.FillConfigDatabase(10, "TestGen3", 50);
                Utils.FillConfigDatabase(10, "TestGen4", 50);
                Utils.FillConfigDatabase(10, "TestGen5", 50);
                Utils.ReloadLiveRegistry();

                List<string> configNames = Utils.GetAllConfigNames();

                //
                // Loop through each of the config names and check that
                // the values match the expected
                //
                foreach(string name in configNames)
                {
                    Global.RO.Info("Validating: " + name);

                    XRLGetLiveConfig xrl=CreateXRL(name);
                    ExecuteXrl(xrl);

                    if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                    {
                        Global.RO.Success("Verified HIVE for [{0}]", name);
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                    }
                }
            }

            public override void Cleanup()
            {
                Utils.EmptyConfigDatabase("", "TestGen1");
                Utils.EmptyConfigDatabase("", "TestGen2");
                Utils.EmptyConfigDatabase("", "TestGen3");
                Utils.EmptyConfigDatabase("", "TestGen4");
                Utils.EmptyConfigDatabase("", "TestGen5");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates that configuration names are not case sensitive. Just in case in the
        /// future someone fat-fingers XenOn instead of xenon into the database we need
        /// to be 100% sure that it will make no difference in the result that is returned
        /// when the xenon configuration is requested.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made to any of to a loaded configuration with
        ///     incorrect case should result in the case-insensitive result to be returned.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     This test does not follow the standard that the xenon console will use to
        ///     call GetLiveConfig, which is Xenon.Build.QFE. This test only validates that
        ///     the main roots are valid and the results are correct.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Requests the most used configname[xEnOn] case insensitive and verifies that the results match expected values.")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_Xenon_Request_Case : HiveTestNode
        {
            public override void Run()
            {
                XRLGetLiveConfig xrl=CreateXRL("xEnOn");
                ExecuteXrl(xrl);

                if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", xrl.Request.configname);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", xrl.Request.configname));
                }
            }
        }

        /// <summary>
        /// Validates that a more realistic usage of the Hive works as expected. Normally
        /// there will be more than a handful of settings in the hive for any given configuration. 
        /// This test will setup 1000 individual settings of length 30 and then request them and 
        /// verify that the result matches what was inserted.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made using the configuration name that has ~1000 
        ///     settings returns a valid result that contains each of those settings.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     This test does not follow the standard that the xenon console will use to
        ///     call GetLiveConfig, which is Xenon.Build.QFE. This test only validates that
        ///     the main roots are valid and the results are correct.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Fills the database with settings, and then requests that large number of settings.")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_Request_Large_Num_Settings : HiveTestNode
        {
            public override void Run()
            {
                string name = "Multi";
                Utils.EmptyConfigDatabase("", "Multi");

                for (int i = 1; i <= 1000; i *= 5)
                {
                    Utils.FillConfigDatabase(i, name, 30);
                    Utils.ReloadLiveRegistry();

                    XRLGetLiveConfig xrl=CreateXRL(name);
                    ExecuteXrl(xrl);

                    if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP))
                    {
                        Global.RO.Success("Verified HIVE for [{0}], {1} Settings", name, i);
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}], {1} Settings", name, i));
                    }
                }
            }
            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "Multi");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates that a configuration that has settings that contains one of the escape
        /// characters is returned with the correct values escaped.
        ///
        /// For example:
        ///     If the setting were- Test=^awesome
        ///     The result that comes back should be- Test=^^awesome
        ///         Basically the escape character ^ is used to escape the
        ///         ^ that is in the orignal setting.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made using the configuration name that contains
        ///     a valid escape character is returned with the escape character escaped so that
        ///     the client can read it.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     This test does not follow the standard that the xenon console will use to
        ///     call GetLiveConfig, which is Xenon.Build.QFE. This test only validates that
        ///     the main roots are valid and the results are correct.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Verifies that a cofiguration that has escape charaters in it, is correctly handled.")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_Escaped_Char_Request : HiveTestNode
        {
            public override void Run()
            {
                string name = "Special";

                Utils.EmptyConfigDatabase(name, name);
                Utils.AddConfigDatabaseSetting(name, "foo=bar;foo2=ba^r;", name, xonline.common.config.Config.Environment);
                Utils.ReloadLiveRegistry();

                //
                // Loop through each of the config names and check that
                // the values match the expected
                //
                XRLGetLiveConfig xrl=CreateXRL(name);
                ExecuteXrl(xrl);
                string configString = xrl.Response.config;

                Global.RO.Info("Actual: {0}", configString);
                Global.RO.Info("Expected: Special=foo^=bar^;foo2^=ba^^r^;;");

                if (configString == "Special=foo^=bar^;foo2^=ba^^r^;;")
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "Special");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates that when calling GetLiveConfig with an invalid configuration name
        /// the correct error code is returned.
        ///
        /// The correct failure code is
        /// <code>8015C101: XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG</code>
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with an invalid (not setup) configuration
        ///     name fails with the correct/expected error code.
        ///     </scenarios>
        /// </remarks>
        [TestCase, Description("Makes the call for a config set that does not exist")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
        public class N_Bad_Request : HiveTestNode
        {
            public override void Run()
            {
                string name = "IDontExist";

                //
                // Make sure no settings exist with the IDontExist config name
                //
                Utils.EmptyConfigDatabase("", name);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                ExecuteXrlExpectingFailure(xrl, 0x8015C101); //XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG
            }
        }

        /// <summary>
        /// Validates that when calling GetLiveConfig with an empty configuration name
        /// the correct error code is returned.
        ///
        /// The correct failure code is
        /// <code>8015C101: XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG</code>
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with an empty configuration
        ///     name fails with the correct/expected error code.
        ///     </scenarios>
        /// </remarks>
        [TestCase, Description("Makes the call with no config name set, or just a null terminator")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
        public class N_Empty_Request : HiveTestNode
        {
            public override void Run()
            {
                XRLGetLiveConfig xrl=CreateXRL("");
                ExecuteXrlExpectingFailure(xrl, 0x8015C101); //XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG
            }
        }

        /// <summary>
        /// Validates that when calling GetLiveConfig with an configuration string that
        /// is exactly the maximum size (64), nothing breaks.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration string that is
        ///     the maximum length allowed still returns valid results that can be
        ///     verified.
        ///     </scenarios>
        /// </remarks>
        [TestCase, Description("Makes the call with a string that is exactly witin the allowed buffer.")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
        public class N_Long_Request_64 : HiveTestNode
        {
            public override void Run()
            {
                string name = "V2WIQHB1QBX84WLRRSHL5T7SXF9F1YFPLU6SNLMYEO6MUNOBN5J9E243V4KC9WZS";
                Utils.FillConfigDatabase(10, name, 50);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                ExecuteXrl(xrl);

                if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.EmptyConfigDatabase("", "V2WIQHB1QBX84WLRRSHL5T7SXF9F1YFPLU6SNLMYEO6MUNOBN5J9E243V4KC9WZS");
            }
        }

        /// <summary>
        /// Validates that when calling GetLiveConfig with an configuration string that
        /// is exactly one over the maximum size (64), an exception is thrown.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration string that is
        ///     the maximum length allowed plus one fails with an exception being
        ///     thrown.
        ///     </scenarios>
        /// </remarks>
        [TestCase, Description("Makes the call with a string that is exactly one more than the allowed buffer.")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
        [Ignore("Currently XRLScan is set to limit the request size to 66 (2 byte length + 64 char string) so this just returns a 404")]
        public class N_Long_Request_65 : HiveTestNode
        {
            public override void Run()
            {
                string name = "V2WIQHB1QBX84WLRRSHL5T7SXF9F1YFPLU6SNLMYEO6MUNOBN5J9E243V4KC9WZST";


                XRLGetLiveConfig xrl=CreateXRL(name);
                ExecuteXrlExpectingFailure(xrl, 0x8015C101); //XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG
                //NOTE: This test assumes that i_max_content_length in t_xrl_virtual_interface_mappings is 64.
            }
        }

        /// <summary>
        /// Validates that when calling GetLiveConfig with a congfiguration that has an
        /// expected result that is exactly 5000 characters a valid result is returned.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration whose expected
        ///     result is exactly 5000 characters gets back all 5000 characters and the
        ///     values retured match the ones in the database.
        ///     </scenarios>
        /// </remarks>
        [TestCase, Description("Fills in the database with configName Test1 that should return a string of exactly 5000 length")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_5000_Char_result : HiveTestNode
        {
            public override void Run()
            {
                string name = "Test1";
                int length = 5000;

                // This should build a series of settings that
                // when retrieved will be exactly 5000 characters.
                Utils.EmptyConfigDatabase("", "Test1");
                Utils.FillConfigDatabase(length / 100, name, 100);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Info("Config Length:" + configString.Length);
                Global.RO.Debug(configString);

                if (configString.Length != length)
                {
                    throw new UnexpectedTestResultException("Resp.config.Length was not = " + length + ". Retuned length was " + configString.Length);
                }

                if (!Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP))
                {
                    throw new UnexpectedTestResultException("Response settings verification failed.");
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "Test1");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates that when calling GetLiveConfig with a congfiguration that has an
        /// expected result that is exactly 29,999 characters a valid result is returned.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration whose expected
        ///     result is exactly 29,999 characters gets back all 29,999 characters and the
        ///     values retured match the ones in the database.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     The maximum value for the length of the return string is 30,000.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Fills in the database with configName Test2 that should return a string of exactly 29999 length")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_29999_Char_result : HiveTestNode
        {
            public override void Run()
            {
                string name = "Test2";
                int length = 29999;

                // This should build a series of settings that
                // when retrieved will be exactly 29999 characters.
                Utils.RemoveConfigDatabaseSetting("", name);
                Utils.FillConfigDatabase(299, name, 100);//29900
                Utils.FillConfigDatabase(1, name, 94);//29994
                Utils.AddConfigDatabaseSetting("a", "10", name, xonline.common.config.Config.Environment); //a=10

                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl = CreateXRL(name);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Info("Config Length:" + configString.Length);
                Global.RO.Debug(configString);

                if (configString.Length != length)
                {
                    throw new UnexpectedTestResultException("Resp.config.Length was not = " + length + ". Retuned length was " + configString.Length);
                }
                else if (!Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP))
                {
                    throw new UnexpectedTestResultException("Response settings verification failed.");
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "Test2");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates that when calling GetLiveConfig with a congfiguration that has an
        /// expected result that is exactly 30,000 characters a valid result is returned.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration whose expected
        ///     result is exactly 30,000 characters gets back all 30,000 characters and the
        ///     values retured match the ones in the database.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     The maximum value for the length of the return string is 30,000.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Fills in the database with configName Test3 that should return a string of exactly 30000 length")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_30000_Char_result : HiveTestNode
        {
            public override void Run()
            {
                string name = "Test3";
                int length = 30000;

                // This should build a series of settings that
                // when retrieved will be exactly 29999 characters.
                Utils.RemoveConfigDatabaseSetting("", name);
                Utils.FillConfigDatabase(length / 100, name, 100);

                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Info("Config Length:" + configString.Length);
                Global.RO.Debug(configString);

                if (configString.Length != length)
                {
                    throw new UnexpectedTestResultException("Resp.config.Length was not = " + length + ". Retuned length was " + configString.Length);
                }
                else if (!Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP))
                {
                    throw new UnexpectedTestResultException("Response settings verification failed.");
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "Test3");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates that when calling GetLiveConfig with a congfiguration that has an
        /// expected result that is exactly 30,001 characters an exception is thrown.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration whose expected
        ///     result is exactly 30,001 fails due to an exception being thrown.
        ///     </scenarios>
        /// 
        ///     <section name="Notes">
        ///     The maximum value for the length of the return string is 30,000.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Fills in the database with configName Test3 that should fail because the string is 1 byte too long")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_30001_Char_result : HiveTestNode
        {
            public override void Run()
            {
                string name = "Test2";

                // This should build a series of settings that
                // when retrieved will be exactly 29999 characters.
                Utils.RemoveConfigDatabaseSetting("", name);
                Utils.FillConfigDatabase(299, name, 100); //29900
                Utils.FillConfigDatabase(1, name, 64); //29964
                Utils.AddConfigDatabaseSetting("a", "0123456789012345678901234567890123", name, xonline.common.config.Config.Environment); //a=0123456789012345678901234567890123;

                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                ExecuteXrlExpectingFailure(xrl, 0x8015C101); //XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "Test2");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates that when calling GetLiveConfig with a configuration that has
        /// setting that contain UTF-8 characters, they are returned as UTF-8 characters.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration whose expected
        ///     result contains settings that contiant UTF-8 characters gets those
        ///     characters returned as UTF-8 and not as an ASCII string.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Last time we saw this fail, it was due to having the wrong convert
        ///     vall in our code that was sending the request.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Verifies that UTF-8 strings are working")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_UTF8_Char : HiveTestNode
        {
            public override void Setup()
            {
                Utils.EnsureMachineInGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }

            public override void Run()
            {
                string name = "Test5";
                Utils.EmptyConfigDatabase("", name);
                Utils.ReloadLiveRegistry();
                //
                // Setup the connection to NPDB and execute the command
                //
                Npdb npdb = new Npdb();
                npdb.ConnectToServer();

                Byte[] utf = new Byte[] { 0x6A, 0xC3, 0xA6, 0xC3, 0xBF };
                string utf8 = UTF8Encoding.UTF8.GetString(utf);

                string sql = String.Format("INSERT INTO {0} (guid_setting, vc_environment, vc_client_config, si_build, si_qfe, vc_setting, vc_value) VALUES ('{1}', '{2}', '{3}', {4}, {5}, '{6}', '{7}')",
                                                "t_live_registry_settings",
                                                System.Guid.NewGuid(),
                                                xonline.common.config.Config.Environment,
                                                name,
                                                "6690",
                                                "1",
                                                "UTF8",
                                                utf8
                                                );

                if (0 != npdb.IssueCommand(sql))
                {
                    Global.RO.Debug(sql);
                }
                else
                {
                    Global.RO.Error(sql);
                }

                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6690, 1);
                xrl.SetBetaGroupFlag(true);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug(configString);

                if (!Utils.VerifyHiveSettings(xrl, Utils.INITIAL_BETA_GROUP, true))
                {
                    throw new UnexpectedTestResultException("Hive settings verification failed.");
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "Test5");
                Utils.ReloadLiveRegistry();
                Utils.RemoveMachineAndGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }
        }

        /// <summary>
        /// Validates that when LiveInfo loads settings from the database, it only generates
        /// the expected set of configs.  This ensures that other combinations of build/qfe/
        /// beta group don't get unexpected settings because a non-required config was
        /// generated.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> When any individual setting is added to the database, it 
        ///     should not cause more than one new config to be created.  This test just adds
        ///     settings under a variety of build, qfe, betagroup combinations, and then 
        ///     retrieves the list of configs from the LiveHive front door.  It then checks
        ///     that there are no extraneous configurations generated.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     This was created to verify a fix to a bug that was causing a config to be 
        ///     generated for every combination of build+qfe/betagroup.  This was causing
        ///     an explosion of configs on production, most of which would never be used.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Verifies that LiveInfo generates the correct number of configs for a given set of settings")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_ExpectedConfigCount : HiveTestNode
        {
            private List<String> expectedConfigs;

            public override void Setup()
            {
                expectedConfigs = new List<string>();
                Utils.EmptyConfigDatabase();
            }

            public void AddConfig(String configName, Int32? build, Int32? qfe, Guid? betaGroup)
            {
                StringBuilder expectedName = new StringBuilder(configName);

                if (betaGroup == null)
                {
                    betaGroup = Utils.NO_GROUP;
                }

                if (build != null && qfe != null)
                {
                    expectedName.Append(".");
                    expectedName.Append(build);
                    expectedName.Append(".");
                    expectedName.Append(qfe);
                    expectedName.Append(".");
                    expectedName.Append(betaGroup);
                }

                Utils.FillConfigDatabase(10, configName, 50, build == null ? -1 : build.Value, qfe == null ? -1 : qfe.Value, betaGroup.Value);
                Utils.ReloadLiveRegistry();

                String expectedNameString = expectedName.ToString().ToLower();
                if (!expectedConfigs.Contains(expectedNameString))
                {
                    expectedConfigs.Add(expectedNameString);
                }
            }

            public override void Run()
            {
                String prefix = "TestGen1";

                Global.RO.Info("Adding non-build/qfe settings");
                AddConfig(prefix, null, null, null);
                VerifyExpectedConfigs(prefix, expectedConfigs);

                Guid betaGroup = Guid.NewGuid();
                Global.RO.Info("Adding beta group settings");
                AddConfig(prefix, 1234, 0, betaGroup);
                VerifyExpectedConfigs(prefix, expectedConfigs);

                Global.RO.Info("Adding beta group settings with different build");
                AddConfig(prefix, 3456, 0, betaGroup);
                VerifyExpectedConfigs(prefix, expectedConfigs);

                Global.RO.Info("Adding beta group settings with different beta");
                AddConfig(prefix, 3456, 0, betaGroup);
                VerifyExpectedConfigs(prefix, expectedConfigs);

                Global.RO.Info("Adding qfe 0 settings");
                AddConfig(prefix, 1234, 0, null);
                VerifyExpectedConfigs(prefix, expectedConfigs);

                Global.RO.Info("Adding qfe 1 settings");
                AddConfig(prefix, 1234, 1, null);
                VerifyExpectedConfigs(prefix, expectedConfigs);

                Global.RO.Info("Adding different build settings");
                AddConfig(prefix, 2345, 0, null);
                VerifyExpectedConfigs(prefix, expectedConfigs);

                Global.RO.Info("Adding NO_GROUP beta group settings");
                AddConfig(prefix, 2345, 0, Guid.Empty);
                VerifyExpectedConfigs(prefix, expectedConfigs);
            }

            public void VerifyExpectedConfigs(String configPrefix, List<String> expectedConfigs)
            {
                Boolean failed = false;
                foreach (var resp in ManagementConsole.ExecuteOnAll(Interface.liveinfo, "e :liveinfo ListLiveHiveConfig"))
                {
                    var configs = resp.Response.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
                                      .Skip(1)
                                      .Where(c => c.StartsWith(configPrefix, StringComparison.OrdinalIgnoreCase))
                                      .OrderBy(c => c);

                    if (configs.Count() != expectedConfigs.Count)
                    {
                        Global.RO.Warn("Unexpected number of configs returned.");
                    }

                    foreach (var c in configs)
                    {
                        if (!expectedConfigs.Contains(c, StringComparer.OrdinalIgnoreCase))
                        {
                            Global.RO.Error("Found config {0} not expected", c);
                            failed = true;
                        }
                        else
                        {
                            Global.RO.Success("Found config {0} as expected", c);
                        }
                    }
                }

                if (failed)
                {
                    throw new UnexpectedTestResultException("Unexpected configs were generated");
                }
            }

            public override void Cleanup()
            {
                Utils.EmptyConfigDatabase("", "TestGen1");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates the real mainline scenario, calling GetLiveConfig with the same
        /// string that the console would normally call it with. That means that it is
        /// of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
        /// fakeSG auth data with build numbers that we expect in the database.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration which matches
        ///     what the Xbox360 console will send gets the correct result for that
        ///     config name.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Build and QFE cannot be defined individually, if you define one you must define the other.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Verifies that simple requests with base build and qfe work correctly")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_Xenon_Build_QFE : HiveTestNode
        {
            public override void Run()
            {
                string name = "BuildQfeTest";

                Utils.FillConfigDatabase(10, name, 50, 6699, 1, Utils.NO_GROUP);
                Utils.FillConfigDatabase(10, name, 50, 6698, 1, Utils.NO_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6699, 1);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeTest");
                Utils.ReloadLiveRegistry();
            }
        }

        [TestCase, Description("Verifies that all config names in the database are returned to the healthcheck")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(0)]
        public class P_LiveHiveHealthcheck : HiveTestNode
        {
            private static readonly String configPrefx = "TestGen";
            private List<String> healthcheckUrls;

            public override void PreRun()
            {
                Utils.EmptyConfigDatabase();
                for (int i = 1; i <= 5; i++)
                {
                    Utils.FillConfigDatabase(10, configPrefx + i, 30);
                }
                Utils.ReloadLiveRegistry();

                List<string> configNames = Utils.GetAllConfigNames();

                using (NpdbHealthchecks npdb = new NpdbHealthchecks())
                {
                    npdb.ConnectToServer();

                    healthcheckUrls = npdb.GetServerHealthchecks(null, "liveinfo");
                }
            }

            public override void Run()
            {
                Global.RO.Info("Getting healthchecks");

                UriBuilder healthcheckUri = new UriBuilder(healthcheckUrls[0]);
                // This will force an updated healthcheck
                healthcheckUri.Query = "op=status";

                var req = HttpWebRequest.Create(healthcheckUri.Uri);
                var resp = req.GetResponse();
                StreamReader reader = new StreamReader(resp.GetResponseStream());
                XElement healthcheckResp = XElement.Parse(reader.ReadToEnd());

                var healthcheckConfigs = from c in healthcheckResp.Descendants("LiveInfoHealthCheckReport")
                                                                  .Descendants("LiveHiveConfig")
                                         select new
                                         {
                                             Config = c.Attribute("Config").Value,
                                             SettingCount = c.Descendants("Setting").Count(),
                                         };

                var configNames = Utils.GetAllConfigNames();

                foreach (var configName in configNames)
                {
                    if (!healthcheckConfigs.Any(c => c.Config == configName))
                    {
                        throw new UnexpectedTestResultException("Healthcheck Configs did not contain expected config name " + configName);
                    }
                }
            }

            public override void Cleanup()
            {
                for (int i = 1; i <= 5; i++)
                {
                    Utils.EmptyConfigDatabase("", configPrefx + i);
                }
                Utils.ReloadLiveRegistry();
            }
        }

        [TestCase, Description("Verifies that the ListLiveHiveConfig xmgmt command returns all the available configs")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(0)]
        public class P_Xmgmt_ListLiveHiveConfig: HiveTestNode
        {
            public override void PreRun()
            {
                Utils.EmptyConfigDatabase();
                Utils.FillConfigDatabase(10, "Test1", 30);
                Utils.ReloadLiveRegistry();
            }

            public override void Run()
            {
                // Bleh, STFs XConfig doesn't have an easy way to get the output of the an Xmgmt command
                // I'm just going to test that these execute successfully right now
                Global.XEnv.ExecuteXmgmtCommand(Interface.liveinfo, "e :liveinfo ListLiveHiveConfig");
                Global.XEnv.ExecuteXmgmtCommand(Interface.liveinfo, "e :liveinfo ListLiveHiveConfig Test1");
                Global.XEnv.ExecuteXmgmtCommand(Interface.liveinfo, "e :liveinfo ListLiveSetting CatalogUriRoot");
            }

            public override void Cleanup()
            {
                Utils.EmptyConfigDatabase("", "Test1");
                Utils.ReloadLiveRegistry();
            }
        }


        /// <summary>
        /// Validates the real mainline scenario, calling GetLiveConfig with the same
        /// string that the console would normally call it with. That means that it is
        /// of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
        /// fakeSG auth data with build numbers that we expect in the database.
        /// For this test we use the initial beta group.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration which matches
        ///     what the Xbox360 console will send gets the correct result for that
        ///     config name.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Beta cannot be defined if Build and QFE are not both defined.
        ///     </section>
        /// </remarks>
        [CompoundCase("InBeta", true)]
        [CompoundCase("OutOfBeta", false)]
        [TestCase, Description("Verifies that simple requests with base build, qfe, and beta group works correctly")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_Xenon_Build_QFE_BetaOne : HiveTestNode
        {
            public override void Setup()
            {
                if ((bool)MyValues[0])
                {
                    Utils.EnsureMachineInGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
                }
            }

            public override void Run()
            {
                string name = "BuildQfeBetaTest";

                Utils.FillConfigDatabase(4, name, 50, 6699, 1, Utils.INITIAL_BETA_GROUP);
                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "settingInBoth", "2", Utils.INITIAL_BETA_GROUP);
                Utils.FillConfigDatabase(4, name, 50, 6699, 1, Utils.NO_GROUP);
                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "settingInBoth", "1", Utils.NO_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6699, 1);
                xrl.SetBetaGroupFlag((bool)MyValues[0]);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                if (Utils.VerifyHiveSettings(xrl, ((bool)MyValues[0]?Utils.INITIAL_BETA_GROUP:Utils.NO_GROUP), true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
                Utils.RemoveMachineAndGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }
        }

        [TestCase]
        [Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_Xenon_NoBase_QFE_AND_Group : HiveTestNode
        {
            private string ClientName { get { return Name+"Client"; }}
            private string NameUnrelated { get { return Name+"X"; }}
            private string Name0 { get { return Name+"0"; }}
            private string Name1 { get { return Name+"1"; }}

            public override void Run()
            {
                Utils.AddConfigDatabaseSetting2(ClientName, 18964, 0, Name0, "A", Utils.NO_GROUP);