

    STDMETHODIMP
    GetIcmpSettings(
        HNET_FW_ICMP_SETTINGS **ppSettings
        );

    STDMETHODIMP
    SetIcmpSettings(
        HNET_FW_ICMP_SETTINGS *pSettings
        );

    STDMETHODIMP
    ShowAutoconfigBalloon(
        BOOLEAN *pfShowBalloon
        );

    STDMETHODIMP
    DeleteRasConnectionEntry();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnicsprv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N I C S P R V . H
//
//  Contents:   CHNIcsPrivateConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNIcsPrivateConn :
    public CHNetConn,
    public IHNetIcsPrivateConnection
{
public:

    BEGIN_COM_MAP(CHNIcsPrivateConn)
        COM_INTERFACE_ENTRY(IHNetIcsPrivateConnection)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // IHNetIcsPrivateConnection methods
    //

    STDMETHODIMP
    RemoveFromIcs();
};

typedef CHNCEnum<
            IEnumHNetIcsPrivateConnections,
            IHNetIcsPrivateConnection,
            CHNIcsPrivateConn
            >
        CEnumHNetIcsPrivateConnections;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnicspub.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N I C S P U B . H
//
//  Contents:   CHNIcsPublicConn declarations
//
//  Notes:
//
//  Author:     jonburs 23 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNIcsPublicConn :
    public IHNetIcsPublicConnection,
    public CHNetConn
{
public:

    BEGIN_COM_MAP(CHNIcsPublicConn)
        COM_INTERFACE_ENTRY(IHNetIcsPublicConnection)
        COM_INTERFACE_ENTRY_CHAIN(CHNetConn)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // IHNetIcsPublicConnection methods
    //

    STDMETHODIMP
    Unshare();
};

typedef CHNCEnum<
            IEnumHNetIcsPublicConnections,
            IHNetIcsPublicConnection,
            CHNIcsPublicConn
            >
        CEnumHNetIcsPublicConnections;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnprtmap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N P R T M A P . H
//
//  Contents:   CHNetPortMappingProtocol declarations
//
//  Notes:
//
//  Author:     jonburs 22 June 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "hnprivate.h"

class ATL_NO_VTABLE CHNetPortMappingProtocol :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IHNetPortMappingProtocol,
    public IHNetPrivate
{
private:

    //
    // IWbemServices for our namespace
    //

    IWbemServices *m_piwsHomenet;

    //
    // Path to WMI instance
    //

    BSTR m_bstrProtocol;

    //
    // True if this is a built-in protocol. We cache
    // this value as it will be used quite often, and
    // will never change for the instance.
    //

    BOOLEAN m_fBuiltIn;

    //
    // Commonly used BSTR
    //

    BSTR m_bstrWQL;

    //
    // Get protocol object from cached path
    //

    HRESULT
    GetProtocolObject(
        IWbemClassObject **ppwcoInstance
        );

    //
    // Sends an update notification for connections with
    // enabled bindings to this protocol.
    //

    HRESULT
    SendUpdateNotification();

    //
    // Queries for bindings for this protocol that are
    // enabled
    //

    HRESULT
    GetEnabledBindingEnumeration(
        IEnumHNetPortMappingBindings **ppEnum
        );

public:

    BEGIN_COM_MAP(CHNetPortMappingProtocol)
        COM_INTERFACE_ENTRY(IHNetPortMappingProtocol)
        COM_INTERFACE_ENTRY(IHNetPrivate)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline constructor.
    //
    
    CHNetPortMappingProtocol()
    {
        m_piwsHomenet = NULL;
        m_bstrProtocol = NULL;
        m_fBuiltIn = FALSE;
        m_bstrWQL = NULL;
    };
    
    //
    // Atl methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // Object initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoInstance
        );

    //
    // IHNetPortMappingProtocol methods
    //

    STDMETHODIMP
    GetName(
        OLECHAR **ppszwName
        );

    STDMETHODIMP
    SetName(
        OLECHAR *pszwName
        );

    STDMETHODIMP
    GetIPProtocol(
        UCHAR *pucProtocol
        );

    STDMETHODIMP
    SetIPProtocol(
        UCHAR ucProtocol
        );

    STDMETHODIMP
    GetPort(
        USHORT *pusPort
        );

    STDMETHODIMP
    SetPort(
        USHORT usPort
        );

    STDMETHODIMP
    GetBuiltIn(
        BOOLEAN *pfBuiltIn
        );

    STDMETHODIMP
    Delete();

    STDMETHODIMP
    GetGuid(
        GUID **ppGuid
        );

    //
    // IHNetPrivate methods
    //

    STDMETHODIMP
    GetObjectPath(
        BSTR *pbstrPath
        );


};

//
// Type to use for our enumeration class
//

typedef CHNCEnum<
            IEnumHNetPortMappingProtocols,
            IHNetPortMappingProtocol,
            CHNetPortMappingProtocol
            >
        CEnumHNetPortMappingProtocols;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\natem.h ===
// NATEM.h : Declaration of the CNATDynamicPortMappingService

#ifndef __NATEVENTMANAGER_H_
#define __NATEVENTMANAGER_H_

#include <upnp.h>
#include <upnpp.h>
#include <netcon.h>

#include <list>

/////////////////////////////////////////////////////////////////////////////
// CNATEventManager
class ATL_NO_VTABLE CNATEventManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CNATEventManager, &CLSID_NATEventManager>,
	public IDispatchImpl<INATEventManager, &IID_INATEventManager, &LIBID_NATUPNPLib>
{
private:
   CComPtr<IUPnPServiceCallbackPrivate> m_spUPSCP;
   std::list<DWORD> m_listOfCookies;

public:
	CNATEventManager()
	{
	}
  ~CNATEventManager()
   {
      // run through list of cookies and remove each callback
      std::list<DWORD>::iterator iterCookies = m_listOfCookies.begin();
      for (DWORD dwCookie = *iterCookies;
           iterCookies != m_listOfCookies.end();
           dwCookie = *++iterCookies) {
         HRESULT hr = m_spUPSCP->RemoveTransientCallback (dwCookie);
         _ASSERT (hr == S_OK);
      }
      m_listOfCookies.clear();
   }

//DECLARE_REGISTRY_RESOURCEID(IDR_NATEVENTMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNATEventManager)
	COM_INTERFACE_ENTRY(INATEventManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// INATEventManager
public:
   STDMETHOD(put_ExternalIPAddressCallback)(/*[in]*/ IUnknown * pUnk);
   STDMETHOD(put_NumberOfEntriesCallback)(/*[in]*/ IUnknown * pUnk);

// CNATEventManager
public:
   HRESULT Initialize (IUPnPService * pUPS)
   {
       if (!pUPS)
           return E_INVALIDARG;
   
       _ASSERT (m_spUPSCP == NULL);
       return pUPS->QueryInterface (__uuidof(IUPnPServiceCallbackPrivate),
                                    (void**)&m_spUPSCP);
   }
   HRESULT AddTransientCallback (IUnknown * punk)
   {
      DWORD dwCookie = 0;
      HRESULT hr = m_spUPSCP->AddTransientCallback (punk, &dwCookie);
      if (SUCCEEDED(hr)) {
         // add cookie to list
         m_listOfCookies.push_back (dwCookie);
      }
      return hr;
   }
};

class ATL_NO_VTABLE CExternalIPAddressCallback :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IUPnPServiceCallback
{
private:
   CComPtr<IUnknown> m_spUnk;

public:
    BEGIN_COM_MAP(CExternalIPAddressCallback)
        COM_INTERFACE_ENTRY(IUPnPServiceCallback)
    END_COM_MAP()

// IUPnPServiceCallback
public:
    STDMETHODIMP StateVariableChanged(IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue);
    STDMETHODIMP ServiceInstanceDied(IUPnPService *pus);

// CExternalIPAddressCallback
public:
   HRESULT Initialize (IUnknown * punk)
   { 
      _ASSERT (m_spUnk == NULL);
      m_spUnk = punk;
      return S_OK;
   }
};

class ATL_NO_VTABLE CNumberOfEntriesCallback :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IUPnPServiceCallback
{
private:
   CComPtr<IUnknown> m_spUnk;

public:
    BEGIN_COM_MAP(CNumberOfEntriesCallback)
        COM_INTERFACE_ENTRY(IUPnPServiceCallback)
    END_COM_MAP()

// IUPnPServiceCallback
public:
    STDMETHODIMP StateVariableChanged(IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue);
    STDMETHODIMP ServiceInstanceDied(IUPnPService *pus);

// CNumberOfEntriesCallback
public:
   HRESULT Initialize (IUnknown * punk)
   { 
      _ASSERT (m_spUnk == NULL);
      m_spUnk = punk;
      return S_OK;
   }
};


#endif //__NATEVENTMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\natutils.h ===
#ifndef __UPNPNAT_UTILS_H_
#define __UPNPNAT_UTILS_H_

#include <upnp.h>

HRESULT GetNumberOfEntries (IUPnPService * pUS, ULONG * pul);
HRESULT GetExternalIPAddress (IUPnPService * pUS, BSTR * pbstr);

HRESULT InvokeAction      (IUPnPService * pUPS, CComBSTR & bstrActionName, VARIANT pvIn, VARIANT * pvOut, VARIANT * pvRet);
HRESULT AddPortMapping    (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, long lInternalPort, BSTR bstrInternalClient, VARIANT_BOOL vbEnabled, BSTR bstrDescription, long lLeaseDurationDesired);
HRESULT DeletePortMapping (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol);

HRESULT GetOnlyVariantElementFromVariantSafeArray (VARIANT * pvSA, VARIANT * pv);
HRESULT AddToSafeArray (SAFEARRAY * psa, VARIANT * pv, long lIndex);
HRESULT GetBSTRFromSafeArray (SAFEARRAY * psa, BSTR * pbstr, long lIndex);
HRESULT GetLongFromSafeArray (SAFEARRAY * psa, long * pl, long lIndex);
HRESULT GetBoolFromSafeArray (SAFEARRAY * psa, VARIANT_BOOL  * pvb, long lIndex);

NETCON_MEDIATYPE GetMediaType (INetConnection * pNC);

//HRESULT GetOnlyChildDevice (IUPnPDevice * pParent, IUPnPDevice ** ppChild);
//HRESULT FindDeviceByType (IUPnPDevices * pUPDs, BSTR bstrType, IUPnPDevice ** ppUPD);

#endif //__UPNPNAT_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hnprtbnd.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N P R T M A P . H
//
//  Contents:   CHNetPortMappingBinding declarations
//
//  Notes:
//
//  Author:     jonburs 22 June 2000
//
//----------------------------------------------------------------------------

#pragma once

class ATL_NO_VTABLE CHNetPortMappingBinding :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IHNetPortMappingBinding
{
private:

    //
    // IWbemServices for our namespace
    //

    IWbemServices *m_piwsHomenet;

    //
    // Path to WMI instance.
    //

    BSTR m_bstrBinding;

    //
    // Commonly used BSTR
    //

    BSTR m_bstrWQL;

    //
    // Generate a target address w/in our DHCP scope when using
    // a name-based port mapping
    //

    HRESULT
    GenerateTargetAddress(
        LPCWSTR pszwTargetName,
        ULONG *pulAddress
        );

    //
    // Get the object corresponding to our stored path
    //
    
    HRESULT
    GetBindingObject(
        IWbemClassObject **ppwcoInstance
        );

    //
    // Sends an update notification to SharedAccess (if the
    // service is running).
    //

    HRESULT
    SendUpdateNotification();

public:

    BEGIN_COM_MAP(CHNetPortMappingBinding)
        COM_INTERFACE_ENTRY(IHNetPortMappingBinding)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline constructor.
    //
    
    CHNetPortMappingBinding()
    {
        m_piwsHomenet = NULL;
        m_bstrBinding = NULL;
        m_bstrWQL = NULL;
    };
    
    //
    // Atl methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // Object initialization
    //

    HRESULT
    Initialize(
        IWbemServices *piwsNamespace,
        IWbemClassObject *pwcoInstance
        );

    //
    // IHNetPortMappingBinding methods
    //

    STDMETHODIMP
    GetConnection(
        IHNetConnection **ppConnection
        );

    STDMETHODIMP
    GetProtocol(
        IHNetPortMappingProtocol **ppProtocol
        );

    STDMETHODIMP
    GetEnabled(
        BOOLEAN *pfEnabled
        );

    STDMETHODIMP
    SetEnabled(
        BOOLEAN fEnable
        );

    STDMETHODIMP
    GetCurrentMethod(
        BOOLEAN *pfUseName
        );

    STDMETHODIMP
    GetTargetComputerName(
        OLECHAR **ppszwName
        );

    STDMETHODIMP
    SetTargetComputerName(
        OLECHAR *pszwName
        );

    STDMETHODIMP
    GetTargetComputerAddress(
        ULONG *pulAddress
        );

    STDMETHODIMP
    SetTargetComputerAddress(
        ULONG ulAddress
        );

    STDMETHODIMP
    GetTargetPort(
        USHORT *pusPort
        );

    STDMETHODIMP
    SetTargetPort(
        USHORT usPort
        );
};

//
// Type to use for our enumeration class
//

typedef CHNCEnum<
            IEnumHNetPortMappingBindings,
            IHNetPortMappingBinding,
            CHNetPortMappingBinding
            >
        CEnumHNetPortMappingBindings;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\upnpnat.h ===
// UPnPNAT.h : Declaration of the CUPnPNAT

#ifndef __UPNPNAT_H_
#define __UPNPNAT_H_

#include <upnp.h>
#include <netcon.h>

#include "hncres.h"

extern void EnableNATExceptionHandling();
extern void DisableNATExceptionHandling();

/////////////////////////////////////////////////////////////////////////////
// CUPnPNAT
class ATL_NO_VTABLE CUPnPNAT : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CUPnPNAT, &CLSID_UPnPNAT>,
	public IDispatchImpl<IUPnPNAT, &IID_IUPnPNAT, &LIBID_NATUPNPLib>
{
public:
	CUPnPNAT()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_UPNPNAT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUPnPNAT)
	COM_INTERFACE_ENTRY(IUPnPNAT)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IUPnPNAT
public:
   STDMETHOD(get_StaticPortMappingCollection) (/*[out, retval]*/ IStaticPortMappingCollection ** ppSPMC);
   STDMETHOD(get_DynamicPortMappingCollection)(/*[out, retval]*/ IDynamicPortMappingCollection ** ppDPMC);
   STDMETHOD(get_NATEventManager)             (/*[out, retval]*/ INATEventManager ** ppNEM);

// CUPnPNAT
public:
};

#endif //__UPNPNAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\hncstrs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       H N C S T R S . H
//
//  Contents:   extern constant string declarations
//
//  Notes:
//
//  Author:     jonburs 21 June 2000
//
//----------------------------------------------------------------------------

#pragma once

extern const OLECHAR c_wszNamespace[];
extern const OLECHAR c_wszWQL[];
extern const OLECHAR c_wszStar[];
extern const OLECHAR c_wszHnetConnection[];
extern const OLECHAR c_wszHnetProperties[];
extern const OLECHAR c_wszHnetApplicationProtocol[];
extern const OLECHAR c_wszHnetPortMappingProtocol[];
extern const OLECHAR c_wszHnetConnectionPortMapping[];
extern const OLECHAR c_wszHnetFWLoggingSettings[];
extern const OLECHAR c_wszHnetIcsSettings[];
extern const OLECHAR c_wszHnetResponseRange[];
extern const OLECHAR c_wszPath[];
extern const OLECHAR c_wszMaxFileSize[];
extern const OLECHAR c_wszLogDroppedPackets[];
extern const OLECHAR c_wszLogConnections[];
extern const OLECHAR c_wszDhcpEnabled[];
extern const OLECHAR c_wszDnsEnabled[];

extern const OLECHAR c_wszName[];
extern const OLECHAR c_wszDeviceName[];
extern const OLECHAR c_wszEnabled[];
extern const OLECHAR c_wszBuiltIn[];
extern const OLECHAR c_wszOutgoingIPProtocol[];
extern const OLECHAR c_wszOutgoingPort[];
extern const OLECHAR c_wszResponseCount[];
extern const OLECHAR c_wszResponseArray[];
extern const OLECHAR c_wszIPProtocol[];
extern const OLECHAR c_wszStartPort[];
extern const OLECHAR c_wszEndPort[];
extern const OLECHAR c_wszPort[];
extern const OLECHAR c_wszId[];

extern const OLECHAR c_wszConnection[];
extern const OLECHAR c_wszProtocol[];
extern const OLECHAR c_wszTargetName[];
extern const OLECHAR c_wszTargetIPAddress[];
extern const OLECHAR c_wszTargetPort[];
extern const OLECHAR c_wszNameActive[];

extern const OLECHAR c_wszIsLanConnection[];
extern const OLECHAR c_wszIsFirewalled[];
extern const OLECHAR c_wszIsIcsPublic[];
extern const OLECHAR c_wszIsIcsPrivate[];
extern const OLECHAR c_wszIsBridgeMember[];
extern const OLECHAR c_wszIsBridge[];
extern const OLECHAR c_wszPhonebookPath[];
extern const OLECHAR c_wszGuid[];

extern const OLECHAR c_wszHnetFwIcmpSettings[];
extern const OLECHAR c_wszAllowOutboundDestinationUnreachable[];
extern const OLECHAR c_wszAllowOutboundSourceQuench[];
extern const OLECHAR c_wszAllowRedirect[];
extern const OLECHAR c_wszAllowInboundEchoRequest[];
extern const OLECHAR c_wszAllowInboundRouterRequest[];
extern const OLECHAR c_wszAllowOutboundTimeExceeded[];
extern const OLECHAR c_wszAllowOutboundParameterProblem[];
extern const OLECHAR c_wszAllowInboundTimestampRequest[];
extern const OLECHAR c_wszAllowInboundMaskRequest[];
extern const OLECHAR c_wszDefault[];
extern const OLECHAR c_wszDefaultIcmpSettingsPath[];

extern const OLECHAR c_wszHnetConnectionIcmpSetting[];
extern const OLECHAR c_wszIcmpSettings[];

extern const OLECHAR c_wszHnetBridgeMember[];
extern const OLECHAR c_wszBridge[];
extern const OLECHAR c_wszMember[];

extern const OLECHAR c_wszSelect[];
extern const OLECHAR c_wszFrom[];
extern const OLECHAR c_wszWhere[];
extern const OLECHAR c_wsz__Path[];
extern const OLECHAR c_wszReferencesOf[];
extern const OLECHAR c_wszWhereResultClass[];
extern const OLECHAR c_wszAssociatorsOf[];
extern const OLECHAR c_wszWhereAssocClass[];

extern const OLECHAR c_wszPortMappingProtocolQueryFormat[];
extern const OLECHAR c_wszApplicationProtocolQueryFormat[];
extern const OLECHAR c_wszConnectionPropertiesPathFormat[];

extern const OLECHAR c_wszBackupIpConfiguration[];
extern const OLECHAR c_wszEnableDHCP[];
extern const OLECHAR c_wszInterfaces[];
extern const OLECHAR c_wszIPAddress[];
extern const OLECHAR c_wszSubnetMask[];
extern const OLECHAR c_wszDefaultGateway[];
extern const OLECHAR c_wszTcpipParametersKey[];
extern const OLECHAR c_wszZeroIpAddress[];

extern const OLECHAR c_wszSharedAccess[];
extern const OLECHAR c_wszDevice[];
extern const OLECHAR c_wszServiceCheckQuery[];

extern const OLECHAR c_wszHnetConnectionAutoconfig[];

extern const OLECHAR c_wszIcsUpgradeEventName[];

//
// Commonly used string lengths. Generating these at compile time
// saves us a large number of wcslen calls. On debug builds, these
// values are compared with the output of wcslen, and an assertion is
// raised if the values do not match.
//

extern const ULONG c_cchSelect;
extern const ULONG c_cchFrom;
extern const ULONG c_cchWhere;
extern const ULONG c_cchReferencesOf;
extern const ULONG c_cchWhereResultClass;
extern const ULONG c_cchAssociatorsOf;
extern const ULONG c_cchWhereAssocClass;
extern const ULONG c_cchConnection;
extern const ULONG c_cchConnectionPropertiesPathFormat;

//
// Bindings-related strings
//

extern const WCHAR c_wszSBridgeMPID[];
extern const WCHAR c_wszSBridgeSID[];
extern const WCHAR *c_pwszBridgeBindExceptions[];

extern const CHAR c_szMprConfigBufferFree[];
extern const CHAR c_szMprConfigServerConnect[];
extern const CHAR c_szMprConfigServerDisconnect[];
extern const CHAR c_szMprConfigTransportGetHandle[];
extern const CHAR c_szMprConfigTransportGetInfo[];
extern const CHAR c_szMprInfoBlockFind[];
extern const WCHAR c_wszMprapiDll[];

extern const TCHAR c_szEnableFirewall[];
extern const TCHAR c_szYes[];
extern const TCHAR c_szNo[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\sportmap.h ===
// SPortMap.h : Declaration of the CStaticPortMapping

#ifndef __STATICPORTMAPPING_H_
#define __STATICPORTMAPPING_H_

#include <upnp.h>
#include "dportmap.h"

/////////////////////////////////////////////////////////////////////////////
// CStaticPortMapping
class ATL_NO_VTABLE CStaticPortMapping : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CStaticPortMapping, &CLSID_StaticPortMapping>,
	public IDispatchImpl<IStaticPortMapping, &IID_IStaticPortMapping, &LIBID_NATUPNPLib>
{
private:
   CComPtr<IDynamicPortMapping> m_spDPM;

public:
	CStaticPortMapping()
	{
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_STATICPORTMAPPING)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStaticPortMapping)
	COM_INTERFACE_ENTRY(IStaticPortMapping)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IStaticPortMapping
public:
   STDMETHOD(get_ExternalIPAddress)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_ExternalPort)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_Protocol)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_InternalPort)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_InternalClient)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(get_Enabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
   STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(EditInternalClient)(/*[in]*/ BSTR bstrInternalClient);
   STDMETHOD(Enable)(/*[in]*/ VARIANT_BOOL vb);
   STDMETHOD(EditDescription)(/*[in]*/ BSTR bstrDescription);
   STDMETHOD(EditInternalPort)(/*[in]*/ long lInternalPort);

// CStaticPortMapping
public:
   HRESULT Initialize (IDynamicPortMapping * pDPM)
   {
      _ASSERT (m_spDPM == NULL);
      m_spDPM = pDPM;
      return S_OK;
   }

   static IStaticPortMapping * CreateInstance (IDynamicPortMapping * pDPM)
   {
      CComObject<CStaticPortMapping> * spm = NULL;
      HRESULT hr = CComObject<CStaticPortMapping>::CreateInstance (&spm);
      if (!spm)
         return NULL;

      IStaticPortMapping * pSPM = NULL;
      spm->AddRef();
      hr = spm->Initialize (pDPM);
      if (SUCCEEDED(hr))
         spm->QueryInterface (__uuidof(IStaticPortMapping), (void**)&pSPM);
      spm->Release();
      return pSPM;
   }
};

#endif //__STATICPORTMAPPING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\inc\sprtmapc.h ===
// SPrtMapC.h : Declaration of the CStaticPortMappingCollection

#ifndef __STATICPORTMAPPINGCOLLECTION_H_
#define __STATICPORTMAPPINGCOLLECTION_H_

#include "dprtmapc.h"   // everything goes through CEnumDynamicPortMappingCollection
#include "sportmap.h"

/////////////////////////////////////////////////////////////////////////////
// CStaticPortMappingCollection
class ATL_NO_VTABLE CStaticPortMappingCollection : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CStaticPortMappingCollection, &CLSID_StaticPortMappingCollection>,
	public IDispatchImpl<IStaticPortMappingCollection, &IID_IStaticPortMappingCollection, &LIBID_NATUPNPLib>
{
private:
   CComPtr<IUPnPService> m_spUPS;

public:
	CStaticPortMappingCollection()
	{
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_STATICPORTMAPPINGCOLLECTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStaticPortMappingCollection)
	COM_INTERFACE_ENTRY(IStaticPortMappingCollection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IStaticPortMappingCollection
public:
   STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown* *pVal);
   STDMETHOD(get_Item)(/*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol, /*[out, retval]*/ IStaticPortMapping ** ppSPM);
   STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
   STDMETHOD(Remove)(/*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol);
   STDMETHOD(Add)(/*[in]*/ long lExternalPort, /*[in]*/ BSTR bstrProtocol, /*[in]*/ long lInternalPort, /*[in]*/ BSTR bstrInternalClient, /*[in]*/ VARIANT_BOOL bEnabled, /*[in]*/ BSTR bstrDescription, /*[out, retval]*/ IStaticPortMapping ** ppSPM);

// CStaticPortMappingCollection
public:
   HRESULT Initialize (IUPnPService * pUPS);
};

// quickie enumerator
class CEnumStaticPortMappingCollection : public IEnumVARIANT
{
private:
   CComPtr<IEnumVARIANT> m_spEV;
   CComPtr<IUPnPService> m_spUPS;
   long m_index, m_refs;

   CEnumStaticPortMappingCollection ()
   {
      m_refs = 0;
      m_index = 0;
   }

   HRESULT Init (IUPnPService * pUPS)
   {
      m_spUPS = pUPS;   // we need to hang onto this for the Clone method

      CComPtr<IEnumVARIANT> spEV = 
                CEnumDynamicPortMappingCollection::CreateInstance (pUPS);
      if (!spEV)
         return E_OUTOFMEMORY;

      m_spEV = spEV;
      return S_OK;
   }

public:
   static IEnumVARIANT * CreateInstance (IUPnPService * pUPS)
   {
      CEnumStaticPortMappingCollection * pCEV = new CEnumStaticPortMappingCollection ();
      if (!pCEV)
         return NULL;
      HRESULT hr = pCEV->Init (pUPS);
      if (FAILED(hr)) {
         delete pCEV;
         return NULL;
      }

      IEnumVARIANT * pIEV = NULL;
      pCEV->AddRef();
      pCEV->QueryInterface (IID_IEnumVARIANT, (void**)&pIEV);
      pCEV->Release();
      return pIEV;
   }

// IUnknown
   virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riid, void ** ppvObject)
   {
      NAT_API_ENTER

      if (ppvObject)
         *ppvObject = NULL;
      else
         return E_POINTER;

      HRESULT hr = S_OK;
      if ((riid == IID_IUnknown) ||
         (riid == IID_IEnumVARIANT) ){
         AddRef();
         *ppvObject = (void *)this;
      } else
         hr = E_NOINTERFACE;
      return hr;

      NAT_API_LEAVE
   }
   virtual ULONG STDMETHODCALLTYPE AddRef ()
   {
      return InterlockedIncrement ((PLONG)&m_refs);
   }
   virtual ULONG STDMETHODCALLTYPE Release ()
   {
      ULONG l = InterlockedDecrement ((PLONG)&m_refs);
      if (l == 0)
         delete this;
      return l;
   }

// IEnumVARIANT
   virtual HRESULT STDMETHODCALLTYPE Next (/*[in]*/ ULONG celt, /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar, /*[out]*/ ULONG * pCeltFetched)
   {
      NAT_API_ENTER

      // pass everything to contained dynamic portmapping enumerator

      // clear stuff being passed in (just in case)
      if (pCeltFetched)   *pCeltFetched = 0;
      for (ULONG i=0; i<celt; i++)
         VariantInit (&rgVar[i]);

      HRESULT hr = S_OK;

      // get the next celt elements
      for (i=0; i<celt; i++) {

         CComVariant cv;
         hr = m_spEV->Next (1, &cv, NULL);
         if (hr != S_OK)
            break;

         // all static port mappings are in the beginning of NAT's array:
         // we can stop as soon as we hit a dynamic one.

         CComPtr<IDynamicPortMapping> spDPM = NULL;
         V_DISPATCH (&cv)->QueryInterface (__uuidof(IDynamicPortMapping),
                                           (void**)&spDPM);
         _ASSERT (spDPM != NULL);   // can't fail

         if (!IsStaticPortMapping (spDPM))
            i--;  // try next one.
         else {
            // create a static port map object out of a dynamic object.
            CComPtr<IStaticPortMapping> spSPM =
                                 CStaticPortMapping::CreateInstance (spDPM);
            if (!spSPM) {
               hr = E_OUTOFMEMORY;
               break;
            }

            V_VT (&rgVar[i]) = VT_DISPATCH;
            spSPM->QueryInterface (__uuidof(IDispatch),
                                   (void**)&V_DISPATCH (&rgVar[i]));
         }
      }
      if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
         hr = S_OK;  // no more; will return S_FALSE below

      if (FAILED(hr)) {
         // on error clear variant array....
         for (ULONG j=0; j<i; j++)
            VariantClear (&rgVar[j]);
         return hr;
      }

      // now update index
      m_index += i;

      // fill out how many we're returning
      if (pCeltFetched)
         *pCeltFetched = i;
      return i < celt ? S_FALSE : S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Skip (/*[in]*/ ULONG celt)
   {
      NAT_API_ENTER

      HRESULT hr = S_OK;

      for (ULONG i=0; i<celt; i++) {
         CComVariant cv;
         hr = Next (1, &cv, NULL);
         if (hr != S_OK)
            break;
      }

      m_index += i;

      if (FAILED(hr))
         return hr;
      if (i != celt)
         return S_FALSE;
      return S_OK;

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Reset ()
   {
      NAT_API_ENTER

      m_index = 0;
      return m_spEV->Reset ();

      NAT_API_LEAVE
   }

   virtual HRESULT STDMETHODCALLTYPE Clone (/*[out]*/ IEnumVARIANT ** ppEnum)
   {
      NAT_API_ENTER

      if (!ppEnum)
         return E_POINTER;

      if (!(*ppEnum = CreateInstance (m_spUPS)))
         return E_OUTOFMEMORY;

      return (*ppEnum)->Skip (m_index);

      NAT_API_LEAVE
   }

private:
   static BOOL IsStaticPortMapping (IDynamicPortMapping * pDPM)
   {
      /* is it dynamic?
         lease must be infinite (i.e. 0)
         remote host must be wildcard (i.e. "")
         ports must match
      */
      long lLease = -1;
      HRESULT hr = pDPM->get_LeaseDuration (&lLease);
      if (FAILED(hr))
         return FALSE;
      if (lLease != 0)
         return FALSE;

      CComBSTR cbRemoteHost;
      hr = pDPM->get_RemoteHost (&cbRemoteHost);
      if (FAILED(hr))
         return FALSE;
      if (wcscmp(cbRemoteHost, L""))
         return FALSE;

      // still here?  must be static!
      return TRUE;
   }

};

#endif //__STATICPORTMAPPINGCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\mof\makefile.inc ===
#
# generate binary mof file (bmf)
#

clean:
    del HNetCfg.bmf 

HNetCfg.bmf: HNetCfg.mof
    mofcomp -B:$(O)\HNetCfg.bmf HNetCfg.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\dprtmapc.cpp ===
// DPrtMapC.cpp : Implementation of CDynamicPortMappingCollection
#include "stdafx.h"
#pragma hdrstop

#include "NATUPnP.h"
#include "DPrtMapC.h"
#include "DPortMap.h"

/////////////////////////////////////////////////////////////////////////////
// CDynamicPortMappingCollection

STDMETHODIMP CDynamicPortMappingCollection::get_Item (BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, IDynamicPortMapping ** ppDPM)
{
    NAT_API_ENTER

    if (!ppDPM)
        return E_POINTER;
    *ppDPM = NULL;

    return CDynamicPortMapping::CreateInstance (m_spUPS, bstrRemoteHost, lExternalPort, bstrProtocol, ppDPM);

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMappingCollection::get_Count(long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    ULONG ul = 0;
    HRESULT hr = GetNumberOfEntries (m_spUPS, &ul);
    if (SUCCEEDED(hr))
        *pVal = (long)ul;
    return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMappingCollection::Remove(BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol)
{
    NAT_API_ENTER

    return DeletePortMapping (m_spUPS, bstrRemoteHost, lExternalPort, bstrProtocol);

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMappingCollection::Add(BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, long lInternalPort, BSTR bstrInternalClient, VARIANT_BOOL bEnabled, BSTR bstrDescription, long lLeaseDuration, IDynamicPortMapping ** ppDPM)
{
    NAT_API_ENTER

    if (!ppDPM)
        return E_POINTER;
    *ppDPM = NULL;

    if (!bstrRemoteHost)
        return E_INVALIDARG;
    if ((lExternalPort < 0) || (lExternalPort > 65535))
        return E_INVALIDARG;
    if (!bstrProtocol)
        return E_INVALIDARG;
    if (wcscmp (bstrProtocol, L"TCP") && wcscmp (bstrProtocol, L"UDP"))
        return E_INVALIDARG;
    if ((lInternalPort < 0) || (lInternalPort > 65535))
        return E_INVALIDARG;
    if (!bstrInternalClient)
        return E_INVALIDARG;
    if (!bstrDescription)
        return E_INVALIDARG;
    if ((lLeaseDuration < 0) || (lLeaseDuration > 65535))
        return E_INVALIDARG;

    HRESULT hr = AddPortMapping (m_spUPS, 
                                 bstrRemoteHost,
                                 lExternalPort,
                                 bstrProtocol,
                                 lInternalPort,
                                 bstrInternalClient,
                                 bEnabled,
                                 bstrDescription,
                                 lLeaseDuration);
    if (SUCCEEDED(hr)) {
        hr = CDynamicPortMapping::CreateInstance (
                    m_spUPS, bstrRemoteHost,lExternalPort,
                    bstrProtocol, ppDPM);
    }
	return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMappingCollection::get__NewEnum(IUnknown **ppVal)
{
    NAT_API_ENTER

    if (!ppVal)
        return E_POINTER;
    *ppVal = NULL;

    CComPtr<IEnumVARIANT> spEV = 
                CEnumDynamicPortMappingCollection::CreateInstance (m_spUPS);
    if (!spEV)
        return E_OUTOFMEMORY;
    return spEV->QueryInterface (__uuidof(IUnknown), (void**)ppVal);

    NAT_API_LEAVE
}

HRESULT CDynamicPortMappingCollection::Initialize (IUPnPService * pUPS)
{
    _ASSERT (pUPS);
    _ASSERT (m_spUPS == NULL);

    m_spUPS = pUPS;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\igfclsid.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File: IGFClsId.c
//
//----------------------------------------------------------------------------

#define INITGUID
#include <guiddef.h>

// dup'd from ..\..\beacon\client\internetgatewayfinder.h
DEFINE_GUID(CLSID_CInternetGatewayFinder, 
0x4d3f9715, 0x73da, 0x4506, 0x89, 0x33, 0x1e, 0xe, 0x17, 0x18, 0xba, 0x3b);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\dportmap.cpp ===
// DPortMap.cpp : Implementation of CDynamicPortMapping
#include "stdafx.h"
#pragma hdrstop

#include "NATUPnP.h"
#include "DPortMap.h"

/////////////////////////////////////////////////////////////////////////////
// CDynamicPortMapping

STDMETHODIMP CDynamicPortMapping::get_ExternalIPAddress (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    return GetExternalIPAddress (m_spUPS, pVal);

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_LeaseDuration (long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    // live
    return GetAllData (pVal);

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_RemoteHost (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = SysAllocString (m_cbRemoteHost);    // "" == wildcard (for static)
    if (!*pVal)
        return E_OUTOFMEMORY;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_ExternalPort (long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = m_lExternalPort;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_Protocol (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = SysAllocString (m_cbProtocol);  // "TCP" or "UDP"
    if (!*pVal)
        return E_OUTOFMEMORY;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_InternalPort (long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = m_lInternalPort;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_InternalClient (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = SysAllocString (m_cbInternalClient);
    if (!*pVal)
        return E_OUTOFMEMORY;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_Enabled (VARIANT_BOOL *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = VARIANT_FALSE;  // REVIEW: true?

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = m_vbEnabled;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::get_Description (BSTR *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = NULL;

    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    *pVal = SysAllocString (m_cbDescription);
    if (!*pVal)
        return E_OUTOFMEMORY;
    return S_OK;

    NAT_API_LEAVE
}

STDMETHODIMP CDynamicPortMapping::RenewLease (long lLeaseDurationDesired, long * pLeaseDurationReturned)
{
    NAT_API_ENTER

    if (!pLeaseDurationReturned)
        return E_POINTER;
    *pLeaseDurationReturned = 0;

    HRESULT hr;
    if (m_eComplete != eAllData) {
        HRESULT hr = GetAllData ();
        if (FAILED(hr))
            return hr;
    }

    hr = AddPortMapping (m_spUPS,
                         m_cbRemoteHost,
                         m_lExternalPort,
                         m_cbProtocol,
                         m_lInternalPort,
                         m_cbInternalClient,
                         m_vbEnabled,
                         m_cbDescription,
                         lLeaseDurationDesired);
    if (SUCCEEDED(hr))
        hr = get_LeaseDuration (pLeaseDurationReturned);
    
    return hr;

    NAT_API_LEAVE
}

static BOOL IsBuiltIn (BSTR bstrDescription)
{
    #define BUILTIN_KEY L" [MICROSOFT]"
    OLECHAR * tmp = wcsstr (bstrDescription, BUILTIN_KEY);
    if (tmp && (tmp[wcslen(BUILTIN_KEY)] == 0))
        return TRUE;
    return FALSE;
}

HRESULT CDynamicPortMapping::EditInternalClient (BSTR bstrInternalClient)
{
    NAT_API_ENTER

    if (!bstrInternalClient)
        return E_INVALIDARG;

    long lLease = 0;
    HRESULT hr = get_LeaseDuration (&lLease);
    if (SUCCEEDED(hr)) {
        if (IsBuiltIn (m_cbDescription)) {
            // built-in mappings can't be deleted.

            // if enabled, I won't be able to edit the internal client.
            // so, disable it first.  Note that this must be done after 
            // the call to get_LeaseDuration so that all the data is up-to-date.
            VARIANT_BOOL vbEnabled = m_vbEnabled;   // put in local variable, so I can change it back
            if (m_vbEnabled == VARIANT_TRUE)
                hr = Enable (VARIANT_FALSE);
            
            if (SUCCEEDED(hr)) {
                hr = AddPortMapping (m_spUPS,
                                     m_cbRemoteHost,
                                     m_lExternalPort,
                                     m_cbProtocol,
                                     m_lInternalPort,
                                     bstrInternalClient,
                                     vbEnabled,
                                     m_cbDescription,
                                     lLease);
                if (SUCCEEDED(hr))
                    m_vbEnabled = vbEnabled;
            }
        } else {
            hr = DeletePortMapping (m_spUPS,
                                    m_cbRemoteHost,
                                    m_lExternalPort,
                                    m_cbProtocol);
            if (SUCCEEDED(hr))
                hr = AddPortMapping (m_spUPS,
                                     m_cbRemoteHost,
                                     m_lExternalPort,
                                     m_cbProtocol,
                                     m_lInternalPort,
                                     bstrInternalClient,
                                     m_vbEnabled,
                                     m_cbDescription,
                                     lLease);
        }
        if (SUCCEEDED(hr)) {
            m_cbInternalClient = bstrInternalClient;
            if (!m_cbInternalClient.m_str)
                return E_OUTOFMEMORY;
        }
    }
    return hr;
    
    NAT_API_LEAVE
}

HRESULT CDynamicPortMapping::Enable (VARIANT_BOOL vb)
{
    NAT_API_ENTER

    long lLease = 0;
    HRESULT hr = get_LeaseDuration (&lLease);

    if (SUCCEEDED(hr)) {
        hr = AddPortMapping (m_spUPS,
                             m_cbRemoteHost,
                             m_lExternalPort,
                             m_cbProtocol,
                             m_lInternalPort,
                             m_cbInternalClient,
                             vb,
                             m_cbDescription,
                             lLease);
        if (SUCCEEDED(hr))
            m_vbEnabled = vb;
    }

    return hr;

    NAT_API_LEAVE
}

HRESULT CDynamicPortMapping::EditDescription (BSTR bstrDescription)
{
    NAT_API_ENTER

    if (!bstrDescription)
        return E_INVALIDARG;

    long lLease = 0;
    HRESULT hr = get_LeaseDuration (&lLease);
    if (SUCCEEDED(hr)) {
        hr = AddPortMapping (m_spUPS,
                             m_cbRemoteHost,
                             m_lExternalPort,
                             m_cbProtocol,
                             m_lInternalPort,
                             m_cbInternalClient,
                             m_vbEnabled,
                             bstrDescription,
                             lLease);
        if (SUCCEEDED(hr)) {
            m_cbDescription = bstrDescription;
            if (!m_cbDescription.m_str)
                return E_OUTOFMEMORY;
        }
    }

    return hr;
    
    NAT_API_LEAVE
}

HRESULT CDynamicPortMapping::EditInternalPort (long lInternalPort)
{
    NAT_API_ENTER

    if ((lInternalPort < 0) || (lInternalPort > 65535))
        return E_INVALIDARG;

    long lLease = 0;
    HRESULT hr = get_LeaseDuration (&lLease);

    if (SUCCEEDED(hr)) {
        hr = AddPortMapping (m_spUPS,
                             m_cbRemoteHost,
                             m_lExternalPort,
                             m_cbProtocol,
                               lInternalPort,
                             m_cbInternalClient,
                             m_vbEnabled,
                             m_cbDescription,
                             lLease);
        if (SUCCEEDED(hr))
            m_lInternalPort = lInternalPort;
    }

    return hr;

    NAT_API_LEAVE
}

HRESULT CDynamicPortMapping::GetAllData (long * pLease)
{
    if (pLease)
       *pLease = NULL;

    _ASSERT (m_cbRemoteHost);
    _ASSERT (m_lExternalPort != 0);
    _ASSERT (m_cbProtocol);

    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 3;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    HRESULT
        hr = AddToSafeArray (psa, &CComVariant(m_cbRemoteHost), 0);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(m_lExternalPort), 1);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(m_cbProtocol),     2);

    if (SUCCEEDED(hr)) {
        CComVariant cvOut, cvRet;
        hr = InvokeAction (m_spUPS, CComBSTR(L"GetSpecificPortMappingEntry"), cvIn, &cvOut, &cvRet);
        if (SUCCEEDED(hr)) {
            if (V_VT (&cvOut) != (VT_VARIANT | VT_ARRAY))   {
                _ASSERT (0 && "InvokeAction didn't fill out a [out] parameter (properly)!");
                hr = E_UNEXPECTED;
            } else {
                SAFEARRAY * pSA = V_ARRAY (&cvOut);
                _ASSERT (pSA);

                long lLower = 0, lUpper = -1;
                SafeArrayGetLBound (pSA, 1, &lLower);
                SafeArrayGetUBound (pSA, 1, &lUpper);
                if (lUpper - lLower != 5 - 1)
                    hr = E_UNEXPECTED;
                else {
                    hr = GetLongFromSafeArray (pSA, &m_lInternalPort, 0);
                    if (SUCCEEDED(hr)) {
                        m_cbInternalClient.Empty();
                        hr = GetBSTRFromSafeArray (pSA, &m_cbInternalClient, 1);
                        if (SUCCEEDED(hr)) {
                            hr = GetBoolFromSafeArray (pSA, &m_vbEnabled,      2);
                            if (SUCCEEDED(hr)) {
                                m_cbDescription.Empty();
                                hr = GetBSTRFromSafeArray (pSA, &m_cbDescription, 3);
                                if (SUCCEEDED(hr)) {
                                    if (pLease)
                                        hr = GetLongFromSafeArray (pSA, pLease,   4);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (SUCCEEDED(hr))
        m_eComplete = eAllData;
    return hr;
}

HRESULT CDynamicPortMapping::CreateInstance (IUPnPService * pUPS, long lIndex, IDynamicPortMapping ** ppDPM)
{
    if (ppDPM)
        *ppDPM = NULL;

    if (!pUPS)
        return E_INVALIDARG;
    if (!ppDPM)
        return E_POINTER;

    CComObject<CDynamicPortMapping> * pDPM = NULL;
    HRESULT hr = CComObject<CDynamicPortMapping>::CreateInstance (&pDPM);
    if (pDPM) {
        pDPM->AddRef();

        hr = pDPM->Initialize (pUPS, lIndex);
        if (SUCCEEDED(hr))
            hr = pDPM->QueryInterface (__uuidof(IDynamicPortMapping),
                                      (void**)ppDPM);
        pDPM->Release();
    }
    return hr;
}
            
HRESULT CDynamicPortMapping::Initialize (IUPnPService * pUPS, long lIndex)
{
    _ASSERT (m_spUPS == NULL);
    _ASSERT (m_eComplete == eNoData);

    m_spUPS = pUPS;

    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 1;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    HRESULT hr = AddToSafeArray (psa, &CComVariant(lIndex), 0);
    if (SUCCEEDED(hr)) {
        CComVariant cvOut, cvRet;
        hr = InvokeAction (m_spUPS, CComBSTR(L"GetGenericPortMappingEntry"), cvIn, &cvOut, &cvRet);

        if (0) {
            long l = 0;
            HRESULT hr1 = m_spUPS->get_LastTransportStatus (&l);
            _ASSERT (l == 200);
        }

        if (SUCCEEDED(hr)) {
            if (V_VT (&cvOut) != (VT_VARIANT | VT_ARRAY))   {
                _ASSERT (0 && "InvokeAction didn't fill out a [out] parameter (properly)!");
                hr = E_UNEXPECTED;
            } else {
                SAFEARRAY * pSA = V_ARRAY (&cvOut);
                _ASSERT (pSA);

                long lLower = 0, lUpper = -1;
                SafeArrayGetLBound (pSA, 1, &lLower);
                SafeArrayGetUBound (pSA, 1, &lUpper);
                if (lUpper - lLower != 8 - 1)
                    hr = E_UNEXPECTED;
                else {
                        hr = GetBSTRFromSafeArray (pSA, &m_cbRemoteHost, 0);
                    if (SUCCEEDED(hr))
                        hr = GetLongFromSafeArray (pSA, &m_lExternalPort, 1);
                    if (SUCCEEDED(hr))
                        hr = GetBSTRFromSafeArray (pSA, &m_cbProtocol,     2);
                    if (SUCCEEDED(hr))
                        hr = GetLongFromSafeArray (pSA, &m_lInternalPort,   3);
                    if (SUCCEEDED(hr))
                        hr = GetBSTRFromSafeArray (pSA, &m_cbInternalClient, 4);
                    if (SUCCEEDED(hr))
                        hr = GetBoolFromSafeArray (pSA, &m_vbEnabled,       5);
                    if (SUCCEEDED(hr))
                        hr = GetBSTRFromSafeArray (pSA, &m_cbDescription,  6);
                    // skip lease duration, since it's live and we get it every time.
                }
            }
        }
    }
    return hr;
}

HRESULT CDynamicPortMapping::CreateInstance (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol, IDynamicPortMapping ** ppDPM)
{
    if (ppDPM)
        *ppDPM = NULL;

    if (!pUPS)
        return E_INVALIDARG;
    if (!ppDPM)
        return E_POINTER;

    CComObject<CDynamicPortMapping> * pDPM = NULL;
    HRESULT hr = CComObject<CDynamicPortMapping>::CreateInstance (&pDPM);
    if (pDPM) {
        pDPM->AddRef();

        hr = pDPM->Initialize (pUPS, bstrRemoteHost, lExternalPort, bstrProtocol);
        if (SUCCEEDED(hr))
            hr = pDPM->QueryInterface (__uuidof(IDynamicPortMapping),
                                       (void**)ppDPM);
        pDPM->Release();
    }
    return hr;
}

HRESULT CDynamicPortMapping::Initialize (IUPnPService * pUPS, BSTR bstrRemoteHost, long lExternalPort, BSTR bstrProtocol)
{
    if (!pUPS)
        return E_INVALIDARG;
    if (!bstrRemoteHost)
        return E_INVALIDARG;
    if ((lExternalPort < 0) || (lExternalPort > 65535))
        return E_INVALIDARG;
    if (!bstrProtocol)
        return E_INVALIDARG;
    if (wcscmp (bstrProtocol, L"TCP") && wcscmp (bstrProtocol, L"UDP"))
        return E_INVALIDARG;

    _ASSERT (m_spUPS == NULL);
    _ASSERT (m_eComplete == eNoData);

    m_spUPS = pUPS;
    
    m_cbRemoteHost  = bstrRemoteHost;
    m_lExternalPort = lExternalPort;
    m_cbProtocol    = bstrProtocol;

    if (!m_cbRemoteHost || !m_cbProtocol)
        return E_OUTOFMEMORY;
    else
        return GetAllData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\sportmap.cpp ===
// SPortMap.cpp : Implementation of CStaticPortMapping
#include "stdafx.h"
#pragma hdrstop

#include "NATUPnP.h"
#include "SPortMap.h"

/////////////////////////////////////////////////////////////////////////////
// CStaticPortMapping

STDMETHODIMP CStaticPortMapping::get_ExternalIPAddress (BSTR *pVal)
{
    return m_spDPM->get_ExternalIPAddress (pVal);
}

STDMETHODIMP CStaticPortMapping::get_Description(BSTR *pVal)
{
    return m_spDPM->get_Description (pVal);
}

STDMETHODIMP CStaticPortMapping::get_ExternalPort(long *pVal)
{
    return m_spDPM->get_ExternalPort (pVal);
}

STDMETHODIMP CStaticPortMapping::get_Protocol(BSTR *pVal)
{
    return m_spDPM->get_Protocol (pVal);
}

STDMETHODIMP CStaticPortMapping::get_InternalPort(long *pVal)
{
    return m_spDPM->get_InternalPort (pVal);
}

STDMETHODIMP CStaticPortMapping::get_InternalClient(BSTR *pVal)
{
    return m_spDPM->get_InternalClient (pVal);
}

STDMETHODIMP CStaticPortMapping::get_Enabled(VARIANT_BOOL *pVal)
{
    return m_spDPM->get_Enabled (pVal);
}

STDMETHODIMP CStaticPortMapping::EditInternalClient (BSTR bstrInternalClient)
{
    return m_spDPM->EditInternalClient (bstrInternalClient);
}

STDMETHODIMP CStaticPortMapping::Enable (VARIANT_BOOL vb)
{
    return m_spDPM->Enable (vb);
}

STDMETHODIMP CStaticPortMapping::EditDescription (BSTR bstrDescription)
{
    return m_spDPM->EditDescription (bstrDescription);
}
 
STDMETHODIMP CStaticPortMapping::EditInternalPort (long lInternalPort)
{
    return m_spDPM->EditInternalPort (lInternalPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\natem.cpp ===
// NATDPMS.cpp : Implementation of CNATEventManager
#include "stdafx.h"
#pragma hdrstop

#include "NATEM.h"

/////////////////////////////////////////////////////////////////////////////
// CNATEventManager


STDMETHODIMP CNATEventManager::put_ExternalIPAddressCallback(IUnknown * pUnk)
{
    NAT_API_ENTER

    if (!m_spUPSCP)
        return E_UNEXPECTED;
    if (!pUnk)
        return E_INVALIDARG;

    // create a IUPnPServiceCallback
    CComObject<CExternalIPAddressCallback> * pEIAC = NULL;
    HRESULT hr = CComObject<CExternalIPAddressCallback>::CreateInstance (&pEIAC);
    if (pEIAC) {
        pEIAC->AddRef();

        hr = pEIAC->Initialize (pUnk);
        if (SUCCEEDED(hr)) {
            CComPtr<IUnknown> spUnk = NULL;
            hr = pEIAC->QueryInterface (__uuidof(IUnknown), (void**)&spUnk);
            if (spUnk)
                hr = AddTransientCallback (spUnk);
        }

        pEIAC->Release();
    }
	return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CNATEventManager::put_NumberOfEntriesCallback(IUnknown * pUnk)
{
    NAT_API_ENTER

    if (!m_spUPSCP)
        return E_UNEXPECTED;
    if (!pUnk)
        return E_INVALIDARG;

    // create a IUPnPServiceCallback
    CComObject<CNumberOfEntriesCallback> * pEIAC = NULL;
    HRESULT hr = CComObject<CNumberOfEntriesCallback>::CreateInstance (&pEIAC);
    if (pEIAC) {
        pEIAC->AddRef();

        hr = pEIAC->Initialize (pUnk);
        if (SUCCEEDED(hr)) {
            CComPtr<IUnknown> spUnk = NULL;
            hr = pEIAC->QueryInterface (__uuidof(IUnknown), (void**)&spUnk);
            if (spUnk)
                hr = AddTransientCallback (spUnk);
        }

        pEIAC->Release();
    }
	return hr;

    NAT_API_LEAVE
}

// cut-n-pasted from ...\nt\net\upnp\upnp\api\upnpservice.cpp
// fixed up leaks
HRESULT
HrInvokeDispatchCallback(IDispatch * pdispCallback, // user-supplied IDispatch
                         LPCWSTR pszCallbackType,   // L"ServiceDied", or L"StateVariableChanged"
                         IDispatch * pdispThis,     // IDispatch of service
                         LPCWSTR pszStateVarName,   // name of variable
                         VARIANT * lpvarValue)      // new value of variable
{
    HRESULT hr = S_OK;
    VARIANT     ary_vaArgs[4];

    ::VariantInit(&ary_vaArgs[0]);
    ::VariantInit(&ary_vaArgs[1]);
    ::VariantInit(&ary_vaArgs[2]);
    ::VariantInit(&ary_vaArgs[3]);

    // Fourth argument is the value.
    if (lpvarValue)
    {
        hr = VariantCopy(&ary_vaArgs[0], lpvarValue);
        if (FAILED(hr))
        {
            ::VariantInit(&ary_vaArgs[0]);
            goto Cleanup;
        }
    }

    // Third argument is the state variable name.
    // Copy this in case our caller parties on it.

    if (pszStateVarName)
    {
        BSTR bstrVarName;

        bstrVarName = ::SysAllocString(pszStateVarName);
        if (!bstrVarName)
        {
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }

        V_VT(&ary_vaArgs[1]) = VT_BSTR;
        V_BSTR(&ary_vaArgs[1]) = bstrVarName;
    }

    // Second argument is the pointer to the service object.
    pdispThis->AddRef();

    V_VT(&ary_vaArgs[2]) = VT_DISPATCH;
    V_DISPATCH(&ary_vaArgs[2]) = pdispThis;

    // First argument is the string defining the type
    // of callback.
    {
        BSTR bstrCallbackType;

        bstrCallbackType = ::SysAllocString(pszCallbackType);
        if (!bstrCallbackType)
        {
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }

        V_VT(&ary_vaArgs[3]) = VT_BSTR;
        V_BSTR(&ary_vaArgs[3]) = bstrCallbackType;
    }

    {
        VARIANT     vaResult;
        DISPPARAMS  dispParams = {ary_vaArgs, NULL, 4, 0};

        VariantInit(&vaResult);

        hr = pdispCallback->Invoke(0,
                                   IID_NULL,
                                   LOCALE_USER_DEFAULT,
                                   DISPATCH_METHOD,
                                   &dispParams,
                                   &vaResult,
                                   NULL,
                                   NULL);

        if (FAILED(hr))
        {
        }
    }

Cleanup:
    if ((VT_ARRAY | VT_UI1) == V_VT(&ary_vaArgs[0]))
    {
        SafeArrayDestroy(V_ARRAY(&ary_vaArgs[0]));
    }
    else
    {
        ::VariantClear(&ary_vaArgs[0]);
    }
    ::VariantClear(&ary_vaArgs[1]);
    ::VariantClear(&ary_vaArgs[2]);
    ::VariantClear(&ary_vaArgs[3]);

    return hr;
}

HRESULT Callback (IUnknown * punk, IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue)
{
    /*
       IUnknown is either INATExternalIPAddressCallback, 
       INATNumberOfEntriesCallback, or an IDispatch.
       If the latter, call "Invoke" with dispid 0, and all the rest of
       the parameters are the same as for StateVariableChanged.
       Er, except there's an extra BSTR parameter specifying whether
       it's a variable state change or a service died thingy.
    */

    CComPtr<IDispatch> spDisp = NULL;
    punk->QueryInterface (__uuidof(IDispatch), (void**)&spDisp);
    if (spDisp) {
        CComPtr<IDispatch> spDispService = NULL;
        pus->QueryInterface (__uuidof(IDispatch), (void**)&spDispService);
        if (spDispService) {
            HrInvokeDispatchCallback (spDisp,
                                      L"VARIABLE_UPDATE",
                                      spDispService,
                                      pcwszStateVarName,
                                      &vaValue);
            return S_OK;
        }
    }

    // UPnP ignores the error
    return S_OK;
}

HRESULT CExternalIPAddressCallback::StateVariableChanged (IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue)
{
    NAT_API_ENTER

    if (wcscmp (pcwszStateVarName, L"ExternalIPAddress"))
        return S_OK;    // not interested

    CComPtr<INATExternalIPAddressCallback> spEIAC = NULL;
    m_spUnk->QueryInterface (__uuidof(INATExternalIPAddressCallback), (void**)&spEIAC);
    if (spEIAC) {
        _ASSERT (V_VT (&vaValue) == VT_BSTR);
        spEIAC->NewExternalIPAddress (V_BSTR (&vaValue));
        return S_OK;
    }

    return Callback (m_spUnk, pus, pcwszStateVarName, vaValue);

    NAT_API_LEAVE
}
HRESULT CExternalIPAddressCallback::ServiceInstanceDied(IUPnPService *pus)
{
    return S_OK;    // not interested
}

HRESULT CNumberOfEntriesCallback::StateVariableChanged (IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue)
{
    NAT_API_ENTER

    if (wcscmp (pcwszStateVarName, L"PortMappingNumberOfEntries"))
        return S_OK;    // not interested

    CComPtr<INATNumberOfEntriesCallback> spNOEC = NULL;
    m_spUnk->QueryInterface (__uuidof(INATNumberOfEntriesCallback), (void**)&spNOEC);
    if (spNOEC) {
        _ASSERT ((V_VT (&vaValue) == VT_I4) ||
                 (V_VT (&vaValue) == VT_UI4) );
        spNOEC->NewNumberOfEntries (V_I4 (&vaValue));
        return S_OK;
    }

    return Callback (m_spUnk, pus, pcwszStateVarName, vaValue);

    NAT_API_LEAVE
}

HRESULT CNumberOfEntriesCallback::ServiceInstanceDied(IUPnPService *pus)
{
    return S_OK;    // not interested
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\makefile.inc ===
TARGETPATH=obj$(BUILD_ALT_DIR)

C_DEFINES=$(C_DEFINES) -DWIN32 -DUNICODE -D_UNICODE -D_NTSDK=1 -DMPR50=1

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_OPTION=/Yu /Fp$(O)\stdafx.pch
PRECOMPILED_TARGET=$(O)\stdafx.pch
PRECOMPILED_OBJ=$(O)\stdafx.obj

RCOPTIONS=-N
UMTYPE=windows
ATL_VER=30
USE_STATIC_ATL=1
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\natutils.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include <winsock.h>

// upnp functions
HRESULT TranslateError (HRESULT hr)
{
    if ((hr >= UPNP_E_ACTION_SPECIFIC_BASE) &&
        (hr <= UPNP_E_ACTION_SPECIFIC_MAX)) {

        int iError = FAULT_ACTION_SPECIFIC_BASE - 0x300 + (int)(0xFFFF & hr);
        switch (iError) {
        case 401: // FAULT_INVALID_ACTION            
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_FUNCTION);
            break;

        case 402: // FAULT_INVALID_ARG               
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);
            break;

        case 403: // FAULT_INVALID_SEQUENCE_NUMBER   
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_SIGNAL_NUMBER);
            break;

        case 404: // FAULT_INVALID_VARIABLE          
            hr = HRESULT_FROM_WIN32 (ERROR_PROC_NOT_FOUND);
            break;

        case 501: // FAULT_DEVICE_INTERNAL_ERROR     
            hr = HRESULT_FROM_WIN32 (ERROR_GEN_FAILURE);
            break;

        default:
            _ASSERT (0 && "unknown error");
            // fall thru
        case 701: // ValueAlreadySpecified: The value specified in the action is already available in the list and is consequently ignored.
        case 703: // InactiveConnectionStateRequired: Current value of ConnectionStatus should be either Disconnected or Unconfigured to permit this action.
        case 704: // ConnectionSetupFailed: There was a failure in setting up the IP or PPP connection with the service provider.  See LastConnectoinError for more details.
        case 705: // ConnectionSetupInProgress: The connection is already in the process of being setup
        case 706: // ConnectionNotConfigured: Current ConnectionStatus is Unconfigured
        case 707: // DisconnectInProgress: The connection is in the process of being torn down.
        case 708: // InvalidLayer2Address: Corresponding Link Config service has an invalid VPI/VPC or phone number.
        case 709: // InternetAccessDisabled: The EnabledForInternet flag is set to 0.
        case 710: // InvalidConnectionType: This command is valid only when ConnectionType is IP-Routed
        case 711: // ConnectionAlreadyTerminated: An attempt was made to terminate a connection that is no longer active.
        case 715: // WildCardNoPermitedInSrcIP: The source IP address cannot be wild-carded
        case 716: // WildCardNotPermittedInExtPort: The external port cannot be wild-carded

        case 719: // ActionDisallowedWhenAutoConfigEnabled: The specified action is not permitted when auto configuration is enabled on the modem.
        case 720: // InvalidDeviceUUID: the UUID of a device specified in the action arguments is invalid.
        case 721: // InvalidServiceID: The Service ID of a service specified in the action arguments in invalid.

        case 723: // InvalidConnServiceSelection: The selected connection service instance cannot be set as a default connection.
            hr = HRESULT_FROM_WIN32 (ERROR_SERVICE_SPECIFIC_ERROR);
            break;

        case 702: // ValueSpecifiedIsInvalid:  The specified value is not present in the list
            hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
            break;

        case 712: // The specified array index holds a NULL value
            hr = E_UNEXPECTED;  // ?? shouldn't the array compact?
            break;

        case 713: // The specified array index is out of bounds
        case 714: // NoSuchEntryInArray: The specified value does not exist in the array
            hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
            break;

        case 718: // ConflictInMappingEntry: The service mapping entry specified conflicts with a mapping assigned previously to another client
            hr = HRESULT_FROM_WIN32 (ERROR_BUSY);
            break;

        case 724: // SamePortValuesRequired: Internal and External port valuse must be the same.
        case 725: // OnlyPermanentLeasesSupported: The NAT implementation only supports permanent lease times on port mappings
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);
            break;

        }
    }
    return hr;
}

HRESULT InvokeAction (IUPnPService * pUPS, CComBSTR & bstrActionName, VARIANT pvIn, VARIANT * pvOut, VARIANT * pvRet)
{
    if (!bstrActionName.m_str)
        return E_OUTOFMEMORY;

    HRESULT hr = pUPS->InvokeAction (bstrActionName, pvIn, pvOut, pvRet);
    if (FAILED(hr))
        hr = TranslateError (hr);
    return hr;
}

HRESULT QueryStateVariable (IUPnPService * pUPS, CComBSTR & bstrVariableName, VARIANT * pvOut)
{
    if (!bstrVariableName.m_str)
        return E_OUTOFMEMORY;

    HRESULT hr = pUPS->QueryStateVariable (bstrVariableName, pvOut);
    if (FAILED(hr))
        hr = TranslateError (hr);
    return hr;
}

HRESULT GetNumberOfEntries (IUPnPService * pUS, ULONG * pul)
{
    if (!pul)
        return E_POINTER;
    *pul = 0;

    CComVariant cv;
    HRESULT hr = QueryStateVariable (pUS, CComBSTR(L"PortMappingNumberOfEntries"), &cv);
    if (SUCCEEDED (hr)) {

        if ((V_VT (&cv) != VT_I4) &&
            (V_VT (&cv) != VT_UI4)) {
            _ASSERT (0 && "bad type from QueryStateVariable (PortMappingNumberOfEntries, ...)?");
            hr = E_UNEXPECTED;
        } else
            *pul = V_UI4 (&cv);  // it's a union, so this works in either case
    }
    return hr;
}

HRESULT GetExternalIPAddress (IUPnPService * pUPS, BSTR * pbstr)
{
    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 0;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    CComVariant cvOut, cvRet;
    HRESULT hr = InvokeAction (pUPS, CComBSTR(L"GetExternalIPAddress"), cvIn, &cvOut, &cvRet);
    if (SUCCEEDED (hr)) {
        if (V_VT (&cvOut) != (VT_VARIANT | VT_ARRAY))   {
            _ASSERT (0 && "InvokeAction didn't fill out a [out] parameter (properly)!");
            hr = E_UNEXPECTED;
        } else {
            SAFEARRAY * pSA = V_ARRAY (&cvOut);
            _ASSERT (pSA);

            long lLower = 0, lUpper = -1;
            SafeArrayGetLBound (pSA, 1, &lLower);
            SafeArrayGetUBound (pSA, 1, &lUpper);
            if (lUpper - lLower != 1 - 1)
                hr = E_UNEXPECTED;
            else {
                hr = GetBSTRFromSafeArray (pSA, pbstr, 0);
            }
        }
    }
    return hr;
}

// some utils
HRESULT GetOnlyVariantElementFromVariantSafeArray (VARIANT * pvSA, VARIANT * pv)
{
    HRESULT hr = S_OK;
                      
    if (V_VT (pvSA) != (VT_VARIANT | VT_ARRAY))   {
        _ASSERT (0 && "InvokeAction didn't fill out a [out,retval] parameter (properly)!");
        hr = E_UNEXPECTED;
    } else {
        SAFEARRAY * pSA = V_ARRAY (pvSA);
        _ASSERT (pSA);
        // this should contain a VARIANT that's really a BSTR
        long lLower = 0, lUpper = -1;
        SafeArrayGetLBound (pSA, 1, &lLower);
        SafeArrayGetUBound (pSA, 1, &lUpper);
        if (lUpper != lLower)
            hr = E_UNEXPECTED;
        else
            hr = SafeArrayGetElement (pSA, &lLower, (void*)pv);
    }
    return hr;
}

HRESULT AddToSafeArray (SAFEARRAY * psa, VARIANT * pv, long lIndex)
{
    if (V_VT (pv) == VT_ERROR)
        return V_ERROR (pv);
    return SafeArrayPutElement (psa, &lIndex, (void*)pv);
}

HRESULT GetBSTRFromSafeArray (SAFEARRAY * psa, BSTR * pbstr, long lIndex)
{
    *pbstr = NULL;

    CComVariant cv;
    HRESULT hr = SafeArrayGetElement (psa, &lIndex, (void*)&cv);
    if (SUCCEEDED(hr)) {
        if (V_VT (&cv) != VT_BSTR)
            hr = E_UNEXPECTED;
        else {
            *pbstr = SysAllocString (V_BSTR (&cv));
            if (!*pbstr)
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT GetLongFromSafeArray (SAFEARRAY * psa, long * pl, long lIndex)
{
    *pl = 0;

    CComVariant cv;
    HRESULT hr = SafeArrayGetElement (psa, &lIndex, (void*)&cv);
    if (SUCCEEDED(hr)) {
        if ((V_VT (&cv) == VT_I4) || (V_VT (&cv) == VT_UI4))
            *pl = V_I4 (&cv);   // it's a union, so this works in either case
        else
        if ((V_VT (&cv) == VT_I2) || (V_VT (&cv) == VT_UI2))
            *pl = V_UI2 (&cv);  // it's a union, so this works in either case
        else
            hr = E_UNEXPECTED;
    }
    return hr;
}

HRESULT GetBoolFromSafeArray (SAFEARRAY * psa, VARIANT_BOOL  * pvb, long lIndex)
{
    *pvb = 0;

    CComVariant cv;
    HRESULT hr = SafeArrayGetElement (psa, &lIndex, (void*)&cv);
    if (SUCCEEDED(hr)) {
        if (V_VT (&cv) != VT_BOOL)
            hr = E_UNEXPECTED;
        else
            *pvb = V_BOOL (&cv);
    }
    return hr;
}

#ifdef KEEP
HRESULT FindDeviceByType (IUPnPDevices * pUPDs, BSTR bstrType, IUPnPDevice ** ppUPD)
{   // finds a device in a collection of devices, by type.

    CComPtr<IUnknown> spUnk = NULL;
    HRESULT hr = pUPDs->get__NewEnum (&spUnk);
    if (spUnk) {
        CComPtr<IEnumVARIANT> spEV = NULL;
        hr = spUnk->QueryInterface (__uuidof(IEnumVARIANT), (void**)&spEV);
        spUnk = NULL;   // don't need this anymore
        if (spEV) {
            CComVariant cv;
            while (S_OK == (hr = spEV->Next (1, &cv, NULL))) {
                if (V_VT (&cv) == VT_DISPATCH) {
                    CComPtr<IUPnPDevice> spUPD = NULL;
                    hr = V_DISPATCH (&cv)->QueryInterface (
                                                __uuidof(IUPnPDevice),
                                                (void**)&spUPD);
                    if (spUPD) {
                        // see if this device is of the right type
                        CComBSTR cb;
                        spUPD->get_Type (&cb);
                        if (cb == bstrType) {
                            // found it!
                            return spUPD->QueryInterface (
                                                    __uuidof(IUPnPDevice),
                                                    (void**)ppUPD);
                        }
                    }
                }
                cv.Clear();
            }
        }
    }
    // if we got here, we either didn't find it, or there was an error
    if (SUCCEEDED(hr))
        hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
    return hr;
}

HRESULT GetOnlyChildDevice (IUPnPDevice * pParent, IUPnPDevice ** ppChild)
{
    *ppChild = NULL;

    CComPtr<IUPnPDevices> spUPDs = NULL;
    HRESULT hr = pParent->get_Children (&spUPDs);
    if (spUPDs) {
        long lCount = 0;
        spUPDs->get_Count (&lCount);
        if (lCount != 1)
            return E_INVALIDARG;

        CComPtr<IUnknown> spUnk = NULL;
        hr = spUPDs->get__NewEnum (&spUnk);
        if (spUnk) {
            CComPtr<IEnumVARIANT> spEV = NULL;
            hr = spUnk->QueryInterface (__uuidof(IEnumVARIANT), (void**)&spEV);
            if (spEV) {
                spEV->Reset();  // probably not necessary

                CComVariant cv;
                hr = spEV->Next (1, &cv, NULL);
                if (hr == S_OK) {
                    if (V_VT (&cv) != VT_DISPATCH)
                        hr = E_FAIL;
                    else {
                        hr = V_DISPATCH (&cv)->QueryInterface (
                                                    __uuidof(IUPnPDevice),
                                                    (void**)ppChild);
                    }
                }
            }
        }
    }
    return hr;
}
#endif

NETCON_MEDIATYPE GetMediaType (INetConnection * pNC)
{
    NETCON_PROPERTIES* pProps = NULL;
    pNC->GetProperties (&pProps);
    if (pProps) {
        NETCON_MEDIATYPE MediaType = pProps->MediaType;
        NcFreeNetconProperties (pProps);
        return MediaType;
    }
    return NCM_NONE;
}

HRESULT AddPortMapping (IUPnPService * pUPS, 
                        BSTR bstrRemoteHost,
                        long lExternalPort,
                        BSTR bstrProtocol,
                        long lInternalPort,
                        BSTR bstrInternalClient,
                        VARIANT_BOOL vbEnabled,
                        BSTR bstrDescription,
                        long lLeaseDurationDesired)
{
    // special handling for loopback and localhost
    CComBSTR cbInternalClient;
    USES_CONVERSION;
    #define LOOPBACK_ADDR 0x0100007f
    if ((LOOPBACK_ADDR == inet_addr (OLE2A (bstrInternalClient))) ||
        (!_wcsicmp (bstrInternalClient, L"localhost"))) {
        // use computer name, using A version
        CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize       = MAX_COMPUTERNAME_LENGTH+1;
        if (!GetComputerNameA (szComputerName, &dwSize))
            return HRESULT_FROM_WIN32(GetLastError());
        else {
            cbInternalClient = A2OLE(szComputerName);
        }
    } else {
        cbInternalClient = bstrInternalClient;
    }
    if (!cbInternalClient.m_str)
        return E_OUTOFMEMORY;

    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 8;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    HRESULT
        hr = AddToSafeArray (psa, &CComVariant(bstrRemoteHost), 0);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(lExternalPort),   1);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(bstrProtocol),     2);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(lInternalPort),     3);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(cbInternalClient),   4);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant((bool)!!vbEnabled),   5);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(bstrDescription),      6);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(lLeaseDurationDesired), 7);

    if (SUCCEEDED(hr)) {
        CComVariant cvOut, cvRet;
        hr = InvokeAction (pUPS, CComBSTR(L"AddPortMapping"), cvIn, &cvOut, &cvRet);
    }
    return hr;
}

HRESULT DeletePortMapping (IUPnPService * pUPS,
                           BSTR bstrRemoteHost,
                           long lExternalPort,
                           BSTR bstrProtocol)
{
    if (!bstrRemoteHost)
        return E_INVALIDARG;
    if ((lExternalPort < 0) || (lExternalPort > 65535))
        return E_INVALIDARG;
    if (!bstrProtocol)
        return E_INVALIDARG;
    if (wcscmp (bstrProtocol, L"TCP") && wcscmp (bstrProtocol, L"UDP"))
        return E_INVALIDARG;

    SAFEARRAYBOUND rgsaBound[1];
    rgsaBound[0].lLbound   = 0;
    rgsaBound[0].cElements = 3;
    SAFEARRAY * psa = SafeArrayCreate (VT_VARIANT, 1, rgsaBound);
    if (!psa)
        return E_OUTOFMEMORY;

    CComVariant cvIn;
    V_VT    (&cvIn) = VT_VARIANT | VT_ARRAY;
    V_ARRAY (&cvIn) = psa;  // psa will be freed in dtor

    HRESULT
        hr = AddToSafeArray (psa, &CComVariant(bstrRemoteHost), 0);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(lExternalPort), 1);
    if (SUCCEEDED(hr))
        hr = AddToSafeArray (psa, &CComVariant(bstrProtocol), 2);

    if (SUCCEEDED(hr)) {
        CComVariant cvOut, cvRet;
        hr = InvokeAction (pUPS, CComBSTR(L"DeletePortMapping"), cvIn, &cvOut, &cvRet);
        // no [out] or [out,retval] paramters
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\sprtmapc.cpp ===
// SPrtMapC.cpp : Implementation of CStaticPortMappingCollection
#include "stdafx.h"
#pragma hdrstop

#include "NATUPnP.h"
#include "SPrtMapC.h"
#include "SPortMap.h"

static HRESULT CreateDynamicCollection (IUPnPService * pUPS, IDynamicPortMappingCollection ** ppDPMC)
{
    CComObject<CDynamicPortMappingCollection> * pDPMC = NULL;
    HRESULT hr = CComObject<CDynamicPortMappingCollection>::CreateInstance (&pDPMC);
    if (pDPMC) {
        pDPMC->AddRef();
        // init
        hr = pDPMC->Initialize (pUPS);
        if (SUCCEEDED(hr))
            hr = pDPMC->QueryInterface (__uuidof(IDynamicPortMappingCollection), (void**)ppDPMC);
        pDPMC->Release();
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CStaticPortMappingCollection

STDMETHODIMP CStaticPortMappingCollection::get_Item(long lExternalPort, BSTR bstrProtocol, IStaticPortMapping ** ppSPM)
{
    NAT_API_ENTER

    if (!ppSPM)
        return E_POINTER;
    *ppSPM = NULL;

    CComPtr<IDynamicPortMappingCollection> spDPMC = NULL;
    HRESULT hr = CreateDynamicCollection (m_spUPS, &spDPMC);
    if (spDPMC) {
        CComPtr<IDynamicPortMapping> spDPM = NULL;
        hr = spDPMC->get_Item (L"", lExternalPort, bstrProtocol, &spDPM);
        if (spDPM) {
            *ppSPM = CStaticPortMapping::CreateInstance (spDPM);
            if (!*ppSPM)
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CStaticPortMappingCollection::get_Count(long *pVal)
{
    NAT_API_ENTER

    if (!pVal)
        return E_POINTER;
    *pVal = 0;

    long lCount = 0;

    CComPtr<IUnknown> spUnk = NULL;
    HRESULT hr = get__NewEnum (&spUnk);
    if (spUnk) {
        CComPtr<IEnumVARIANT> spEV = NULL;
        hr = spUnk->QueryInterface (__uuidof(IEnumVARIANT), (void**)&spEV);
        if (spEV) {
            spEV->Reset();
            CComVariant cv;
            while (S_OK == spEV->Next (1, &cv, NULL)) {
                lCount++;
                cv.Clear();
            }
        }
    }

    *pVal = lCount;
	return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CStaticPortMappingCollection::Remove(long lExternalPort, BSTR bstrProtocol)
{
    NAT_API_ENTER

    CComPtr<IDynamicPortMappingCollection> spDPMC = NULL;
    HRESULT hr = CreateDynamicCollection (m_spUPS, &spDPMC);
    if (spDPMC)
        hr = spDPMC->Remove (L"", lExternalPort, bstrProtocol);

    return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CStaticPortMappingCollection::Add(long lExternalPort, BSTR bstrProtocol, long lInternalPort, BSTR bstrInternalClient, VARIANT_BOOL bEnabled, BSTR bstrDescription, IStaticPortMapping ** ppSPM)
{
    NAT_API_ENTER

    if (!ppSPM)
        return E_POINTER;
    *ppSPM = NULL;

    CComPtr<IDynamicPortMappingCollection> spDPMC = NULL;
    HRESULT hr = CreateDynamicCollection (m_spUPS, &spDPMC);
    if (spDPMC) {
        CComPtr<IDynamicPortMapping> spDPM = NULL;
        hr = spDPMC->Add (L"", lExternalPort, bstrProtocol, lInternalPort, bstrInternalClient, bEnabled, bstrDescription, 0L, &spDPM);
        if (spDPM) {
            *ppSPM = CStaticPortMapping::CreateInstance (spDPM);
            if (!*ppSPM)
                hr = E_OUTOFMEMORY;
        }
    }
	return hr;

    NAT_API_LEAVE
}

STDMETHODIMP CStaticPortMappingCollection::get__NewEnum(IUnknown **ppVal)
{
    NAT_API_ENTER

    if (!ppVal)
        return E_POINTER;
    *ppVal = NULL;

    CComPtr<IEnumVARIANT> spEV =
                   CEnumStaticPortMappingCollection::CreateInstance (m_spUPS);
    if (!spEV)
        return E_OUTOFMEMORY;
    return spEV->QueryInterface (__uuidof(IUnknown), (void**)ppVal);

    NAT_API_LEAVE
}

HRESULT CStaticPortMappingCollection::Initialize (IUPnPService * pUPS)
{
    _ASSERT (pUPS);
    _ASSERT (m_spUPS == NULL);

    m_spUPS = pUPS;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\upnpnat.cpp ===
// UPnPNAT.cpp : Implementation of CUPnPNAT
#include "stdafx.h"
#pragma hdrstop

#include "UPnPNAT.h"
#include "NATEM.h"
#include "dprtmapc.h"
#include "sprtmapc.h"

DEFINE_GUID(CLSID_CInternetGatewayFinder, 
0x4d3f9715, 0x73da, 0x4506, 0x89, 0x33, 0x1e, 0xe, 0x17, 0x18, 0xba, 0x3b);

void __cdecl nat_trans_func (unsigned int uSECode, EXCEPTION_POINTERS* pExp)
{
   throw NAT_SEH_Exception (uSECode);
}
void EnableNATExceptionHandling()
{
   _set_se_translator (nat_trans_func);
}
void DisableNATExceptionHandling()
{
   _set_se_translator (NULL);
}

HRESULT GetServiceFromINetConnection (IUnknown * pUnk, IUPnPService ** ppUPS)
{
    CComPtr<INetConnection> spNC = NULL;
    HRESULT hr = pUnk->QueryInterface (__uuidof(INetConnection), (void**)&spNC);
    if (!spNC)
        return E_INVALIDARG;

    SAHOST_SERVICES sas;

    // make sure we have either
    // NCM_SHAREDACCESSHOST_LAN or NCM_SHAREDACCESSHOST_RAS
    switch (GetMediaType (spNC)) {
    case NCM_SHAREDACCESSHOST_LAN:
        sas = SAHOST_SERVICE_WANIPCONNECTION;
        break;
    case NCM_SHAREDACCESSHOST_RAS:
        sas = SAHOST_SERVICE_WANPPPCONNECTION;
        break;
    default:
        return E_INVALIDARG;
    }

    CComPtr<INetSharedAccessConnection> spNSAC = NULL;
    hr = pUnk->QueryInterface (__uuidof(INetSharedAccessConnection), (void**)&spNSAC);
    if (spNSAC)
        hr = spNSAC->GetService (sas, ppUPS);
	return hr;
}

HRESULT GetServiceFromFinder (IInternetGatewayFinder * pIGF, IUPnPService ** ppUPS)
{
    CComPtr<IInternetGateway> spIG = NULL;
    HRESULT hr = pIGF->GetInternetGateway (NULL, &spIG);    // NULL gets default.
    if (spIG) {
        NETCON_MEDIATYPE MediaType = NCM_NONE;
        hr = spIG->GetMediaType (&MediaType);
        if (SUCCEEDED(hr)) {
            switch (MediaType) {
            case NCM_SHAREDACCESSHOST_LAN:
                hr = spIG->GetService (SAHOST_SERVICE_WANIPCONNECTION, ppUPS);
                break;
            case NCM_SHAREDACCESSHOST_RAS:
                hr = spIG->GetService (SAHOST_SERVICE_WANPPPCONNECTION, ppUPS);
                break;
            default:
                return E_UNEXPECTED;
            }
        }
    }
    return hr;
}

HRESULT GetService (IUPnPService ** ppUPS)
{
    if (!ppUPS)
        return E_POINTER;
    *ppUPS = NULL;

    // either enum all netconnections, or
    // for downlevel, use Ken's object

    CComPtr<INetConnectionManager> spNCM = NULL;
    HRESULT hr = ::CoCreateInstance (CLSID_ConnectionManager,
                                     NULL,
                                     CLSCTX_ALL,
                                     __uuidof(INetConnectionManager),
                                     (void**)&spNCM);
    if (spNCM) {
        CComPtr<IUnknown> spUnk = NULL;
        CComPtr<IEnumNetConnection> spENC = NULL;
        hr = spNCM->EnumConnections (NCME_DEFAULT, &spENC);
        if (spENC) {
            ULONG ul = 0;
            CComPtr<INetConnection> spNC = NULL;
            while (S_OK == spENC->Next (1, &spNC, &ul)) {
                NETCON_PROPERTIES * pProps = NULL;
                spNC->GetProperties (&pProps);
                if (pProps) {
                    NETCON_MEDIATYPE MediaType = pProps->MediaType;
                    NcFreeNetconProperties (pProps);
                    if ((MediaType == NCM_SHAREDACCESSHOST_LAN) ||
                        (MediaType == NCM_SHAREDACCESSHOST_RAS) ){
                        // found it
                        spNC->QueryInterface (__uuidof(IUnknown),
                                              (void**)&spUnk);
                        break;
                    }
                }
                spNC = NULL;
            }
        }
        if (spUnk)
            hr = GetServiceFromINetConnection (spUnk, ppUPS);
    } else {
        // downlevel
        CComPtr<IInternetGatewayFinder> spIGF = NULL;
        hr = ::CoCreateInstance (CLSID_CInternetGatewayFinder,
                                 NULL,
                                 CLSCTX_ALL,
                                 __uuidof(IInternetGatewayFinder),
                                 (void**)&spIGF);
        if (spIGF)
            hr = GetServiceFromFinder (spIGF, ppUPS);
    }
    return hr;
}

template<class C, class I> class UN {
public:
    HRESULT Create (I ** ppI)
    {
        if (ppI)
            *ppI = NULL;

        if (!ppI)
            return E_POINTER;

        CComPtr<IUPnPService> spUPS = NULL;
        HRESULT hr = GetService (&spUPS);
        if (spUPS) {
            // create class so that I can initialize it
            CComObject<C> * pC = NULL;
            hr = CComObject<C>::CreateInstance (&pC);
            if (pC) {
                pC->AddRef();
                // init
                hr = pC->Initialize (spUPS);
                if (SUCCEEDED(hr))
                    hr = pC->QueryInterface (__uuidof(I), (void**)ppI);
                pC->Release();
            }
        }
		return hr;
    }
};

/////////////////////////////////////////////////////////////////////////////
// CUPnPNAT

STDMETHODIMP CUPnPNAT::get_NATEventManager(INATEventManager ** ppNEM)
{
    NAT_API_ENTER

    UN<CNATEventManager, INATEventManager> un;
    return un.Create (ppNEM);

    NAT_API_LEAVE
}

STDMETHODIMP CUPnPNAT::get_DynamicPortMappingCollection (IDynamicPortMappingCollection ** ppDPMC)
{
    NAT_API_ENTER

    // remove the section below when turning dynamic port mappings back on
    if (!ppDPMC)
        return E_POINTER;
    *ppDPMC = NULL;
    return E_NOTIMPL;
    // remove the section above when turning dynamic port mappings back on

    UN<CDynamicPortMappingCollection, IDynamicPortMappingCollection> un;
    return un.Create (ppDPMC);

    NAT_API_LEAVE
}

STDMETHODIMP CUPnPNAT::get_StaticPortMappingCollection (IStaticPortMappingCollection ** ppSPMC)
{
    NAT_API_ENTER

    UN<CStaticPortMappingCollection, IStaticPortMappingCollection> un;
    return un.Create (ppSPMC);

    NAT_API_LEAVE
}

// private method(s)
HRESULT GetOSInfoService (IUPnPService ** ppUPS)
{
    if (!ppUPS)
        return E_POINTER;
    *ppUPS = NULL;

    // either enum all netconnections, or
    // for downlevel, use Ken's object

    CComPtr<INetConnectionManager> spNCM = NULL;
    HRESULT hr = ::CoCreateInstance (CLSID_ConnectionManager,
                                     NULL,
                                     CLSCTX_ALL,
                                     __uuidof(INetConnectionManager),
                                     (void**)&spNCM);
    if (spNCM) {
        CComPtr<IEnumNetConnection> spENC = NULL;
        hr = spNCM->EnumConnections (NCME_DEFAULT, &spENC);
        if (spENC) {
            ULONG ul = 0;
            CComPtr<INetConnection> spNC = NULL;
            while (S_OK == spENC->Next (1, &spNC, &ul)) {
                NETCON_PROPERTIES * pProps = NULL;
                spNC->GetProperties (&pProps);
                if (pProps) {
                    NETCON_MEDIATYPE MediaType = pProps->MediaType;
                    NcFreeNetconProperties (pProps);
                    if ((MediaType == NCM_SHAREDACCESSHOST_LAN) ||
                        (MediaType == NCM_SHAREDACCESSHOST_RAS) ){
                        // found it
                        break;
                    }
                }
                spNC = NULL;
            }
            if (spNC) {
                CComPtr<INetSharedAccessConnection> spNSAC = NULL;
                hr = spNC->QueryInterface (__uuidof(INetSharedAccessConnection), (void**)&spNSAC);
                if (spNSAC)
                    hr = spNSAC->GetService (SAHOST_SERVICE_OSINFO, ppUPS);
            } else
                hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
        }
    } else {
        // downlevel
        CComPtr<IInternetGatewayFinder> spIGF = NULL;
        hr = ::CoCreateInstance (CLSID_CInternetGatewayFinder,
                                 NULL,
                                 CLSCTX_ALL,
                                 __uuidof(IInternetGatewayFinder),
                                 (void**)&spIGF);
        if (spIGF) {
            CComPtr<IInternetGateway> spIG = NULL;
            hr = spIGF->GetInternetGateway (NULL, &spIG);    // NULL gets default.
            if (spIG)
                hr = spIG->GetService (SAHOST_SERVICE_OSINFO, ppUPS);
        }
    }
    return hr;
}
BOOL IsICSHost ()
{
    CComPtr<IUPnPService> spOSI = NULL;
    GetOSInfoService (&spOSI);
    if (spOSI)
        return TRUE;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\bridge.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : bridge.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

extern ULONG            g_ulBridgeNumTopCmds;
extern ULONG            g_ulBridgeNumGroups;
extern CMD_ENTRY        g_BridgeCmds[];
extern CMD_GROUP_ENTRY  g_BridgeCmdGroups[];

FN_HANDLE_CMD  HandleBridgeSetAdapter;
FN_HANDLE_CMD  HandleBridgeShowAdapter;
FN_HANDLE_CMD  HandleBridgeInstall;
FN_HANDLE_CMD  HandleBridgeUninstall;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\fwlogger\precomp.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file for firewall console logger.

Author:

    Jonathan Burstein (jonburs)     12-April-2000

Revision History:

--*/

#include <windows.h>
#include <wmistr.h>
#include <evntrace.h>
#include <stdio.h>
#include <tchar.h>
#include <process.h>
#include <winsock2.h>

#include "natschma.h"

#define NAT_PROTOCOL_ICMP       0x01
#define NAT_PROTOCOL_IGMP       0x02
#define NAT_PROTOCOL_TCP        0x06
#define NAT_PROTOCOL_UDP        0x11
#define NAT_PROTOCOL_PPTP       0x2F

#define TCP_FLAG_FIN                0x0100
#define TCP_FLAG_SYN                0x0200
#define TCP_FLAG_RST                0x0400
#define TCP_FLAG_PSH                0x0800
#define TCP_FLAG_ACK                0x1000
#define TCP_FLAG_URG                0x2000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\config\natupnp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3055FA29_74C3_4E43_A83A_2054CA60B628__INCLUDED_)
#define AFX_STDAFX_H__3055FA29_74C3_4E43_A83A_2054CA60B628__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <netcon.h>
#include <upnp.h>
#include <NATUPnP.h>

#include <netconp.h>
#include "natupnpp.h"
#include "NATUtils.h"

#define NAT_API_ENTER try {
#define NAT_API_LEAVE } catch (...) { return DISP_E_EXCEPTION; }

#include <eh.h>
class NAT_SEH_Exception 
{
private:
    unsigned int m_uSECode;
public:
   NAT_SEH_Exception(unsigned int uSECode) : m_uSECode(uSECode) {}
   NAT_SEH_Exception() {}
  ~NAT_SEH_Exception() {}
   unsigned int getSeHNumber() { return m_uSECode; }
};
void __cdecl nat_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp );
void EnableNATExceptionHandling();
void DisableNATExceptionHandling();

#endif // !defined(AFX_STDAFX_H__3055FA29_74C3_4E43_A83A_2054CA60B628__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\bridge.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : bridge.cpp
//
//  Contents  : bridge context specific code
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

const TCHAR c_stRegKeyBridgeAdapters[]  =
    _T("SYSTEM\\CurrentControlSet\\Services\\Bridge\\Parameters\\Adapters");
const TCHAR c_stFCMode[]     = _T("ForceCompatibilityMode");


CMD_ENTRY  g_BridgeSetCmdTable[] = {
    CREATE_CMD_ENTRY(BRIDGE_SET_ADAPTER, HandleBridgeSetAdapter),
};

CMD_ENTRY  g_BridgeShowCmdTable[] = {
    CREATE_CMD_ENTRY(BRIDGE_SHOW_ADAPTER, HandleBridgeShowAdapter),
};


CMD_GROUP_ENTRY g_BridgeCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_BridgeSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_BridgeShowCmdTable),
};

ULONG g_ulBridgeNumGroups = sizeof(g_BridgeCmdGroups)/sizeof(CMD_GROUP_ENTRY);



CMD_ENTRY g_BridgeCmds[] =
{
    CREATE_CMD_ENTRY(INSTALL, HandleBridgeInstall),
    CREATE_CMD_ENTRY(UNINSTALL, HandleBridgeUninstall),
};

ULONG g_ulBridgeNumTopCmds = sizeof(g_BridgeCmds)/sizeof(CMD_ENTRY);


DWORD WINAPI
BridgeDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    //
    // Output the string that shows our settings.
    // The idea here is to spit out a script that,
    // when run from the command line (netsh -f script)
    // will cause your component to be configured
    // exactly as it is when this dump command was run.
    //
    PrintMessageFromModule(
        g_hModule,
        DMP_BRIDGE_HEADER
        );
        
    PrintMessageFromModule(
        g_hModule,
        DMP_BRIDGE_FOOTER
        );

    return NO_ERROR;
    
} 



HRESULT
HrCycleBridge(
    IHNetBridge *pIHNetBridge
    )
{
    HRESULT hr = S_OK;
    
    //
    // Check to see if the bridge is up and running.
    // If it is, then disable and reenable
    //

    do
    {
        //
        // Get the pointer to IID_IHNetConnection interface of this
        // bridged connection
        //
        CComPtr<IHNetConnection> spIHNConn;

        hr = pIHNetBridge->QueryInterface(
                 IID_PPV_ARG(IHNetConnection, &spIHNConn)
                 );

        assert(SUCCEEDED(hr));
    
        if (FAILED(hr))
        {
            break;
        }

        INetConnection *pINetConn;

        hr = spIHNConn->GetINetConnection(&pINetConn);

        if (SUCCEEDED(hr))
        {
            NETCON_PROPERTIES* pNCProps;

            hr = pINetConn->GetProperties(&pNCProps);

            if(SUCCEEDED(hr))
            {
                //
                // check status - restart only if already running
                //
                if (pNCProps->Status == NCS_CONNECTED ||
                    pNCProps->Status == NCS_CONNECTING)
                {
                    pINetConn->Disconnect();

                    pINetConn->Connect();
                }
                
                NcFreeNetconProperties(pNCProps);
            }

            ReleaseObj(pINetConn);
        }
        
    } while(FALSE);
    
    return hr;
}


DWORD
SetBridgeAdapterInfo(
    DWORD   adapterId,
    BOOL    bFlag
    )
{
    DWORD           dwErr        = NO_ERROR;
    IHNetCfgMgr*    pIHNetCfgMgr = NULL;
    HRESULT         hr           = S_OK;

    hr = HrInitializeHomenetConfig(
             &g_fInitCom,
             &pIHNetCfgMgr
             );

    if (SUCCEEDED(hr))
    {
        //
        // Get the IHNetBridgeSettings
        //
        CComPtr<IHNetBridgeSettings> spIHNetBridgeSettings;

        hr = pIHNetCfgMgr->QueryInterface(
                 IID_PPV_ARG(IHNetBridgeSettings, &spIHNetBridgeSettings)
                 );

        if (SUCCEEDED(hr))
        {
            //
            // Get the IEnumHNetBridges
            //
            CComPtr<IEnumHNetBridges> spehBridges;

            if ((hr = spIHNetBridgeSettings->EnumBridges(&spehBridges)) == S_OK)
            {
                //
                // Get the first IHNetBridge
                //
                CComPtr<IHNetBridge> spIHNetBridge;

                if ((hr = spehBridges->Next(1, &spIHNetBridge, NULL)) == S_OK)
                {
                    {
                        //
                        // We currently should have only one bridge;
                        // this may change in the future. The
                        // code here is just to catch future instances
                        // where this function would have to change in case
                        // there is more than one bridge.
                        //
                        CComPtr<IHNetBridge> spIHNetBridge2;

                        if ((hr = spehBridges->Next(1, &spIHNetBridge2, NULL)) == S_OK)
                        {
                            assert(FALSE);
                        }
                    }

                    //
                    // Get the IEnumHNetBridgedConnections
                    //
                    CComPtr<IEnumHNetBridgedConnections> spehBrdgConns;

                    if ((hr = spIHNetBridge->EnumMembers(&spehBrdgConns)) == S_OK)
                    {
                        //
                        // enumerate all the IHNetBridgedConnections
                        //                        
                        DWORD                   id = 0;
                        IHNetBridgedConnection* pIHNetBConn;

                        spehBrdgConns->Reset();
                        
                        while (S_OK == spehBrdgConns->Next(1, &pIHNetBConn, NULL))
                        {
                            id++;

                            if (id != adapterId)
                            {   
                                //
                                // release the IHNetBridgedConnection
                                //
                                ReleaseObj(pIHNetBConn);
                                continue;
                            }
                            
                            //
                            // Get the pointer to IID_IHNetConnection interface of this
                            // bridged connection
                            //
                            CComPtr<IHNetConnection> spIHNConn;

                            hr = pIHNetBConn->QueryInterface(
                                     IID_PPV_ARG(IHNetConnection, &spIHNConn)
                                     );
                            
                            assert(SUCCEEDED(hr));
                            
                            if (SUCCEEDED(hr))
                            {
                                GUID *pGuid = NULL;

                                hr = spIHNConn->GetGuid(&pGuid);

                                if (SUCCEEDED(hr) && (NULL != pGuid))
                                {
                                    PTCHAR pwszKey = NULL;
                                    int    keyLen;
                                    TCHAR  wszGuid[128];
                                    HKEY   hKey = NULL;
                                    DWORD  dwDisp = 0;
                                    BOOL   bCycleBridge = TRUE;
                                    DWORD  dwOldValue;
                                    DWORD  dwNewValue = (bFlag) ? 1 : 0;

                                    do
                                    {
                                        
                                        ZeroMemory(wszGuid, sizeof(wszGuid));

                                        StringFromGUID2(
                                            *pGuid,
                                            wszGuid,
                                            ARRAYSIZE(wszGuid)
                                            );

                                        keyLen = _tcslen(c_stRegKeyBridgeAdapters) +
                                                 _tcslen(_T("\\"))                 +
                                                 _tcslen(wszGuid)                  +
                                                 1;

                                        pwszKey = (TCHAR *) HeapAlloc(
                                                                GetProcessHeap(),
                                                                0,
                                                                keyLen * sizeof(TCHAR)
                                                                );
                                        if (!pwszKey)
                                        {
                                            break;
                                        }

                                        ZeroMemory(pwszKey, sizeof(pwszKey));
                                        _tcscpy(pwszKey, c_stRegKeyBridgeAdapters);
                                        _tcscat(pwszKey, _T("\\"));
                                        _tcscat(pwszKey, wszGuid);

                                        dwErr = RegCreateKeyEx(
                                                    HKEY_LOCAL_MACHINE,
                                                    pwszKey,
                                                    0,
                                                    NULL,
                                                    REG_OPTION_NON_VOLATILE,
                                                    KEY_ALL_ACCESS,
                                                    NULL,
                                                    &hKey,
                                                    &dwDisp
                                                    );

                                        if (ERROR_SUCCESS != dwErr)
                                        {
                                            break;
                                        }

                                        //
                                        // if the key was old, get its value

                                        // and compare to see if we need to
                                        // cycle the bridge
                                        //
                                        if (dwDisp &&
                                            dwDisp == REG_OPENED_EXISTING_KEY)
                                        {
                                            DWORD dwSize = sizeof(dwOldValue);
                    
                                            if (ERROR_SUCCESS == RegQueryValueEx(
                                                                     hKey,
                                                                     c_stFCMode,
                                                                     NULL,
                                                                     NULL,
                                                                     (LPBYTE)&dwOldValue,
                                                                     &dwSize))
                                            {
                                                if (dwOldValue == dwNewValue)
                                                {
                                                    //
                                                    // no need to cycle the bridge
                                                    //
                                                    bCycleBridge = FALSE;
                                                }
                                            }
                                        
                                        }
                                            
                                        dwErr = RegSetValueEx(
                                                    hKey,
                                                    c_stFCMode,
                                                    0,
                                                    REG_DWORD,
                                                    (LPBYTE) &dwNewValue,
                                                    sizeof(dwNewValue)
                                                    );

                                        if (ERROR_SUCCESS != dwErr)
                                        {
                                            break;
                                        }

                                        if (bCycleBridge)
                                        {
                                            //
                                            // cycle the (respective) bridge
                                            //
                                            hr = HrCycleBridge(
                                                     spIHNetBridge
                                                     );
                                        }

                                    } while(FALSE);

                                    //
                                    // cleanup
                                    //
                                    if (hKey)
                                    {
                                        RegCloseKey(hKey);
                                    }

                                    if (pwszKey)
                                    {
                                        HeapFree(GetProcessHeap(), 0, pwszKey);
                                    }

                                    CoTaskMemFree(pGuid);
                                }
                            }

                            //
                            // release the IHNetBridgedConnection
                            //
                            ReleaseObj(pIHNetBConn);

                            break;
                        } //while
                    }
                }
            }
        }

        //
        // we are done completely
        //
        hr = HrUninitializeHomenetConfig(
                 g_fInitCom,
                 pIHNetCfgMgr
                 );
    }

    return (hr==S_OK) ? dwErr : hr;
}



DWORD
WINAPI
HandleBridgeSetAdapter(
    IN      LPCWSTR pwszMachine,
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      DWORD   dwFlags,
    IN      LPCVOID pvData,
    OUT     BOOL    *pbDone
    )
{
    DWORD           dwRet        = NO_ERROR;
    PDWORD          pdwTagType   = NULL;
    DWORD           dwNumOpt;
    DWORD           dwNumArg;
    DWORD           dwRes;
    DWORD           dwErrIndex   =-1,
                    i;

    //
    // default values
    //
    DWORD           id           = 0;
    DWORD           bFCMode      = FALSE;
    
    TAG_TYPE    pttTags[] =
    {
        {TOKEN_OPT_ID, NS_REQ_PRESENT, FALSE},
        {TOKEN_OPT_FCMODE, NS_REQ_ZERO, FALSE} // not required to allow for
                                               // addition of future flags
    };

    
    if (dwCurrentIndex >= dwArgCount)
    {
        // No arguments specified. At least interface name should be specified.

        return ERROR_INVALID_SYNTAX;
    }
        
    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = (DWORD *) HeapAlloc(
                               GetProcessHeap(),
                               0,
                               dwNumArg * sizeof(DWORD)
                               );

    if (NULL == pdwTagType)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwRet = PreprocessCommand(
                g_hModule,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pttTags,
                ARRAYSIZE(pttTags),
                1,                  // min args
                2,                  // max args
                pdwTagType
                );

    if (NO_ERROR != dwRet)
    {
        HeapFree(GetProcessHeap(), 0, pdwTagType);

        if (ERROR_INVALID_OPTION_TAG == dwRet)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwRet;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0:
            {
                //
                // refers to the 'id' field
                //
                id = _tcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
                break;
            }
            case 1:
            {
                //
                // refers to the 'forcecompatmode' field
                // possible values are : enable or disable
                //

                TOKEN_VALUE rgEnums[] = 
                {
                    {TOKEN_OPT_VALUE_ENABLE, TRUE},
                    {TOKEN_OPT_VALUE_DISABLE, FALSE}
                };
               
                dwRet = MatchEnumTag(
                            g_hModule,
                            ppwcArguments[i + dwCurrentIndex],
                            ARRAYSIZE(rgEnums),
                            rgEnums,
                            &dwRes
                            );         

                if (dwRet != NO_ERROR)
                {
                    dwErrIndex = i;
                    i = dwNumArg;
                    dwRet = ERROR_INVALID_PARAMETER;
                    break;
                }    

                switch (dwRes)
                {
                    case 0:
                        bFCMode = FALSE;
                        break;

                    case 1:
                        bFCMode = TRUE;
                        break;
                }

                break;
            }
            default:
            {
                i = dwNumArg;
                dwRet = ERROR_INVALID_PARAMETER;
                break;
            }
        
        } //switch

        if (dwRet != NO_ERROR)
        {
            break ;
        }
            
    } //for

    //
    // adapter id MUST be present
    //
    
    if (!pttTags[0].bPresent)
    {
        dwRet = ERROR_INVALID_SYNTAX;
    }

    
    switch(dwRet)
    {
        case NO_ERROR:
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                PrintError(
                    g_hModule,
                    EMSG_BAD_OPTION_VALUE,
                    ppwcArguments[dwErrIndex + dwCurrentIndex],
                    pttTags[pdwTagType[dwErrIndex]].pwszTag
                    );
            }
            dwRet = ERROR_SUPPRESS_OUTPUT;
            break;
            
        default:
            //
            // error message already printed
            //
            break;
    }

    if (pdwTagType)
    {
        HeapFree(GetProcessHeap(), 0, pdwTagType);
    }

    if (NO_ERROR != dwRet)
    {
        return dwRet;
    }

    //
    // we have the requisite info - process them
    //

    //
    // since we may or may not have flag info, check for it
    //
    if (pttTags[1].bPresent)
    {
        dwRet = SetBridgeAdapterInfo(
                    id,
                    bFCMode
                    );
    }

    return dwRet;
}



DWORD
ShowBridgeAdapterInfo(
    DWORD            id,
    IHNetConnection  *pIHNConn
    )
{
    HRESULT hr;

    //
    // print out the bridged connections details
    //
    PWSTR pwszName = NULL;
    PWSTR pwszState = NULL;
    
    hr = pIHNConn->GetName(&pwszName);

    if (SUCCEEDED(hr) && (NULL != pwszName))
    {
        GUID *pGuid = NULL;

        hr = pIHNConn->GetGuid(&pGuid);

        if (SUCCEEDED(hr) && (NULL != pGuid))
        {
            WCHAR wszGuid[128];
            ZeroMemory(wszGuid, sizeof(wszGuid));
            StringFromGUID2(*pGuid, wszGuid, ARRAYSIZE(wszGuid));

            //
            // check to see if registry settings present
            //
            // for forcecompatmode:
            // + if   key is not present --> disabled
            // + if   key is     present
            //                   0x1     --> enabled
            //                   0x0     --> disabled
            // + all other errors        --> unknown
            //


            {
                HKEY    hBAKey;
                DWORD   msgState = STRING_UNKNOWN;

                if (ERROR_SUCCESS == RegOpenKeyEx(
                                         HKEY_LOCAL_MACHINE,
                                         c_stRegKeyBridgeAdapters,
                                         0,
                                         KEY_READ,
                                         &hBAKey))
                {
                    HKEY hBCKey;
                    
                    if (ERROR_SUCCESS == RegOpenKeyEx(
                                         hBAKey,
                                         wszGuid,
                                         0,
                                         KEY_READ,
                                         &hBCKey))
                    {
                        DWORD dwFCModeState = 0;
                        DWORD dwSize = sizeof(dwFCModeState);
                        
                        if (ERROR_SUCCESS == RegQueryValueEx(
                                                 hBCKey,
                                                 c_stFCMode,
                                                 NULL,
                                                 NULL,
                                                 (LPBYTE)&dwFCModeState,
                                                 &dwSize))
                        {
                            switch (dwFCModeState)
                            {
                                case 0:
                                    msgState = STRING_DISABLED;
                                    break;
                                case 1:
                                    msgState = STRING_ENABLED;
                                    break;
                                default:
                                    msgState = STRING_UNKNOWN;
                            }
                        }
                        else
                        {
                            //
                            // value not present
                            //
                            msgState = STRING_DISABLED;
                        }

                        RegCloseKey(hBCKey);
                    }
                    else
                    {
                        //
                        // bridged connection guid key not present
                        //
                        msgState = STRING_DISABLED;
                    }

                    RegCloseKey(hBAKey);
                }

                pwszState = MakeString(g_hModule, msgState);
            }


            PrintMessage(
                L" %1!2d! %2!-27s! %3!s!%n",
                id,
                pwszName,
                pwszState
                );

            if (pwszState)
            {
                FreeString(pwszState);
            }


            CoTaskMemFree(pGuid);
        }

        CoTaskMemFree(pwszName);
    }

    return NO_ERROR;
}



DWORD
ShowBridgeAllAdapterInfo(
    BOOL    bShowAll,               // TRUE to show all
    DWORD   adapterId               // valid only if bShowAll is FALSE
    )
{
    IHNetCfgMgr*    pIHNetCfgMgr = NULL;
    HRESULT         hr = S_OK;

    hr = HrInitializeHomenetConfig(
             &g_fInitCom,
             &pIHNetCfgMgr
             );

    if (SUCCEEDED(hr))
    {
        //
        // Get the IHNetBridgeSettings
        //
        CComPtr<IHNetBridgeSettings> spIHNetBridgeSettings;

        hr = pIHNetCfgMgr->QueryInterface(
                 IID_PPV_ARG(IHNetBridgeSettings, &spIHNetBridgeSettings)
                 );

        if (SUCCEEDED(hr))
        {
            //
            // Get the IEnumHNetBridges
            //
            CComPtr<IEnumHNetBridges> spehBridges;

            if ((hr = spIHNetBridgeSettings->EnumBridges(&spehBridges)) == S_OK)
            {
                //
                // Get the first IHNetBridge
                //
                CComPtr<IHNetBridge> spIHNetBridge;

                if ((hr = spehBridges->Next(1, &spIHNetBridge, NULL)) == S_OK)
                {
                    {
                        //
                        // We currently should have only one bridge;
                        // this may change in the future. The
                        // code here is just to catch future instances
                        // where this function would have to change in case
                        // there is more than one bridge.
                        //
                        CComPtr<IHNetBridge> spIHNetBridge2;

                        if ((hr = spehBridges->Next(1, &spIHNetBridge2, NULL)) == S_OK)
                        {
                            assert(FALSE);
                        }
                    }

                    //
                    // Get the IEnumHNetBridgedConnections
                    //
                    CComPtr<IEnumHNetBridgedConnections> spehBrdgConns;

                    if ((hr = spIHNetBridge->EnumMembers(&spehBrdgConns)) == S_OK)
                    {
                        //
                        // spit out header for displaying the list
                        //
                        PrintMessageFromModule(
                            g_hModule,
                            MSG_BRIDGE_ADAPTER_INFO_HDR
                            );
                    
                        //
                        // enumerate all the IHNetBridgedConnections
                        //                        
                        DWORD                   id = 0;
                        IHNetBridgedConnection* pIHNetBConn;

                        spehBrdgConns->Reset();
                        
                        while (S_OK == spehBrdgConns->Next(1, &pIHNetBConn, NULL))
                        {
                            id++;

                            //
                            // check if we are looking for a specific id
                            //
                            if (FALSE == bShowAll && id != adapterId)
                            {   
                                //
                                // release the IHNetBridgedConnection
                                //
                                ReleaseObj(pIHNetBConn);
                                continue;
                            }
                            
                            //
                            // Get the pointer to IID_IHNetConnection interface of this
                            // bridged connection
                            //
                            CComPtr<IHNetConnection> spIHNConn;

                            hr = pIHNetBConn->QueryInterface(
                                     IID_PPV_ARG(IHNetConnection, &spIHNConn)
                                     );
                            
                            assert(SUCCEEDED(hr));
                            
                            if (SUCCEEDED(hr))
                            {
                                ShowBridgeAdapterInfo(
                                    id,
                                    spIHNConn
                                    );
                            }

                            //
                            // release the IHNetBridgedConnection
                            //
                            ReleaseObj(pIHNetBConn);

                            //
                            // if we reached here and we were looking for a
                            // specific id, our work is done - break out
                            //
                            if (FALSE == bShowAll)
                            {
                                break;
                            }
                        }

                        //
                        // spit out footer for displaying the list
                        //
                        PrintMessageFromModule(
                            g_hModule,
                            TABLE_SEPARATOR
                            );
                    }
                }
            }
        }

        //
        // we are done completely
        //
        hr = HrUninitializeHomenetConfig(
                 g_fInitCom,
                 pIHNetCfgMgr
                 );
    }

    return (hr==S_OK) ? NO_ERROR : hr;

}



DWORD
WINAPI
HandleBridgeShowAdapter(
    IN      LPCWSTR pwszMachine,
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      DWORD   dwFlags,
    IN      LPCVOID pvData,
    OUT     BOOL    *pbDone
    )
/*++

Routine Description:

    Gets options for showing bridge adapter info

Arguements:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    IHNetCfgMgr*    pIHNetCfgMgr = NULL;
    HRESULT         hr = S_OK;
    BOOL            bShowAll = FALSE;
    DWORD           id = 0,
                    i,
                    dwRet = NO_ERROR,
                    dwNumOpt,
                    dwNumArg,
                    dwSize,
                    dwRes;
    PDWORD          pdwTagType = NULL;

    TAG_TYPE      pttTags[] = 
    {
        {TOKEN_OPT_ID, NS_REQ_ZERO, FALSE}
    };

    if (dwCurrentIndex > dwArgCount)
    {
        //
        // No arguments specified
        //
        return ERROR_INVALID_SYNTAX;
    }

    if (dwCurrentIndex == dwArgCount)
    {
        bShowAll = TRUE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = (DWORD *) HeapAlloc(
                               GetProcessHeap(),
                               0,
                               dwNumArg * sizeof(DWORD)
                               );

    if (dwNumArg && NULL == pdwTagType)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwRet = PreprocessCommand(
                g_hModule,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pttTags,
                ARRAYSIZE(pttTags),
                0,                  // min args
                1,                  // max args
                pdwTagType
                );

    if (NO_ERROR == dwRet)
    {
        //
        // process each argument...
        //
        for (i = 0; i < (dwArgCount - dwCurrentIndex); i++)
        {
            //
            // Check its corresponding value in the pdwTagType array.
            //
            switch (pdwTagType[i])
            {
                case 0:
                    //
                    // refers to the 'id' field
                    //
                    id = _tcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
                    break;
                default:
                    //
                    // Since there is only one valid value, means the arg
                    // wasn't recognized. Shouldn't reach this point because
                    // PreprocessCommand wouldn't have returned NO_ERROR if
                    // this was the case.
                    //
                    dwRet = ERROR_INVALID_SYNTAX;
                    break;
            }
        }

        dwRet = ShowBridgeAllAdapterInfo(
                    bShowAll,
                    id
                    ) ;        
    }
    else
    {
        dwRet = ERROR_SHOW_USAGE;
    }

    //
    // cleanup
    //
    if (pdwTagType)
    {
        HeapFree(GetProcessHeap(), 0, pdwTagType);
    }

    return dwRet;
}



DWORD
WINAPI
HandleBridgeInstall(
    IN      LPCWSTR pwszMachine,
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      DWORD   dwFlags,
    IN      LPCVOID pvData,
    OUT     BOOL    *pbDone
    )
{

    PrintMessageFromModule(
        g_hModule,
        HLP_BRIDGE_USE_GUI,
        CMD_INSTALL
        );

    return NO_ERROR;
}



DWORD
WINAPI
HandleBridgeUninstall(
    IN      LPCWSTR pwszMachine,
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      DWORD   dwFlags,
    IN      LPCVOID pvData,
    OUT     BOOL    *pbDone
    )
{
    PrintMessageFromModule(
        g_hModule,
        HLP_BRIDGE_USE_GUI,
        CMD_UNINSTALL
        );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\fwlogger\fwlogger.cpp ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    FwLogger.cpp

Abstract:

    Simple console logger for the personal firewall.

Author:

    Jonathan Burstein (jonburs)     12-April-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Name of the event trace session
//

_TCHAR cszLogSession[] = _T("FirewallLogSession");

//
// Event counters
//

LONG g_lDropped = 0;
LONG g_lCCreated = 0;
LONG g_lCDeleted = 0;

//
// GUIDs corresponding to the firewall trace events
//

GUID ConnectionCreationEventGuid = MSIPNAT_ConnectionCreationEventGuid;
GUID ConnectionDeletionEventGuid = MSIPNAT_ConnectionDeletionEventGuid;
GUID PacketDroppedEventGuid = MSIPNAT_PacketDroppedEventGuid;

//
// Event to signal for shutdown
//

HANDLE g_hShutdownEvent;

//
// Function prototypes
//

VOID
CALLBACK
ConnectionCreationCallback(
    PEVENT_TRACE pEvent
    );

VOID
CALLBACK
ConnectionDeletionCallback(
    PEVENT_TRACE pEvent
    );

BOOL
WINAPI
ControlHandler(
    DWORD dwCtrlType
    );

VOID
CALLBACK
PacketDroppedCallback(
    PEVENT_TRACE pEvent
    );

UINT
WINAPI
ProcessTraceRoutine(
    PVOID pvThreadParam
    );


int
__cdecl
main(
    int argc,
    _TCHAR **argv
    )

/*++

Routine Description:

    Program entry point. Starts the logging session and launches the
    processing thread.
    
Arguments:

    argc -- count of command line arguments.

    argv -- command line arguments

Return Value:

    Error code.

--*/

{
    TRACEHANDLE             hSession;
    HANDLE                  hThread;
    HANDLE                  rghWaitHandles[2];
    PEVENT_TRACE_PROPERTIES pProperties;
    ULONG                   ulError;
    ULONG                   ulSize;
    UINT                    uiThreadId;
    BOOL                    fWaitForThread = FALSE;

    //
    // Create the event used to signal that the program should exit
    //

    g_hShutdownEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( NULL == g_hShutdownEvent )
    {
        _tprintf( _T("FwLogger: CreateEvent returned NULL (%08x)\n"),
            GetLastError() );
        return -1;
    }

    //
    // Set our control handler. The handler will signal the shutdown event;
    //

    if( !SetConsoleCtrlHandler( ControlHandler, TRUE ))
    {
        _tprintf( _T("FwLogger: SetConsoleCtrlHandler failed (%08x)\n"),
            GetLastError() );
        CloseHandle( g_hShutdownEvent );
        return -1;
    }

    //
    // Initialize our trace properties and start the tracing session.
    //

    ulSize = sizeof(*pProperties)
        + (_tcslen( cszLogSession ) + 1) * sizeof(_TCHAR);
        
    pProperties = (PEVENT_TRACE_PROPERTIES) HeapAlloc(
                                                GetProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                ulSize
                                                );
    if( NULL == pProperties )
    {
        _tprintf( _T("FwLogger: allocation failed\n" ));
        CloseHandle( g_hShutdownEvent );
        return -1;
    }

    pProperties->Wnode.BufferSize = ulSize;
    pProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    pProperties->LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
    pProperties->FlushTimer = 1;
    pProperties->BufferSize = 4;
    ulError = StartTrace( &hSession, cszLogSession, pProperties );
    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: StartTrace returned 0x%08x\n"), ulError );
        CloseHandle( g_hShutdownEvent );
        HeapFree( GetProcessHeap(), 0, pProperties );
        return -1;
    }

    //
    // Enable the trace control guids
    //

    ulError = EnableTrace(
                TRUE,
                0,
                0,
                &PacketDroppedEventGuid,
                hSession
                );

    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: EnableTrace (PacketDropped) returned 0x%08x\n"),
            ulError );
        goto StopTrace;
    }

    ulError = EnableTrace(
                TRUE,
                0,
                0,
                &ConnectionCreationEventGuid,
                hSession
                );

    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: EnableTrace (ConnectionCreation) returned 0x%08x\n"),
            ulError );
        goto StopTrace;
    }


    //
    // Launch a thread to process the trace data. This needs to happen in a
    // separate thread as ProcessTrace blocks.
    //

    hThread = (HANDLE) _beginthreadex(
                            NULL,
                            0,
                            ProcessTraceRoutine,
                            NULL,
                            0,
                            &uiThreadId
                            );

    if( NULL == hThread )
    {
        _tprintf( _T("FwLogger: Unable to create thread (0x%08x)\n"),
            GetLastError() );
        goto StopTrace;
    }

    //
    // Wait for the shutdown event to be signalled, or for our
    // thread to exit.
    //

    rghWaitHandles[0] = g_hShutdownEvent;
    rghWaitHandles[1] = hThread;

    ulError = WaitForMultipleObjects( 2, rghWaitHandles, FALSE, INFINITE );
    if( WAIT_OBJECT_0 == ulError )
    {
        //
        // User wants program to finish. After we shutdownt the trace session,
        // we'll need to wait for the processing thread to cleanup and exit.
        //

        fWaitForThread = TRUE;
        _tprintf( _T("FwLogger: Shutdown event signaled\n") );
    }
    else if( WAIT_OBJECT_0 + 1 == ulError )
    {
        //
        // Thread exited early, due to some problem...
        //

        _tprintf( _T("FwLogger: Trace process thread finished early.\n") );
    }

StopTrace:

    //
    // Disable the events we previously enabled
    //

    ulError = EnableTrace(
                FALSE,
                0,
                0,
                &PacketDroppedEventGuid,
                hSession
                );

    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: EnableTrace (PacketDropped - FALSE) returned 0x%08x\n"),
            ulError );
    }

    ulError = EnableTrace(
                FALSE,
                0,
                0,
                &ConnectionCreationEventGuid,
                hSession
                );

    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: EnableTrace (ConnectionCreation - FALSE) returned 0x%08x\n"),
            ulError );
    }

    //
    // Stop the trace
    //

    ZeroMemory( pProperties, ulSize );
    pProperties->Wnode.BufferSize = ulSize;
    ulError = StopTrace( hSession, NULL, pProperties );
    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: StopTrace returned 0x%08x\n"), ulError );
    }
    else
    {
        _tprintf( _T("FwLogger: Trace stopped\n\n") );

        //
        // Print out statistics
        //

        _tprintf( _T("**Packets dropped: %i\n"), g_lDropped );
        _tprintf( _T("**Connections created: %i\n"), g_lCCreated );
        _tprintf( _T("**Connections deleted: %i\n"), g_lCDeleted );
        _tprintf( _T("**Events lost: %u\n"), pProperties->EventsLost );
        _tprintf( _T("**Buffers lost: %u\n"), pProperties->LogBuffersLost );
        _tprintf( _T("**Realtime buffers lost: %u\n\n"),
            pProperties->RealTimeBuffersLost );
    }
        
        

    //
    // Give processing thread 15 seconds to finish
    //

    if( fWaitForThread )
    {
        _tprintf( _T("FwLogger: Waiting for thread to exit...\n") );
        ulError = WaitForSingleObject( hThread, 15 * 1000 );
        if( WAIT_OBJECT_0 != ulError )
        {
            _tprintf( _T("FwLogger: Wait failed (timeout = %s)\n"),
                WAIT_TIMEOUT == ulError ? _T("true") : _T("false") );
        }
    }

    CloseHandle( g_hShutdownEvent );
    CloseHandle( hThread );
    HeapFree( GetProcessHeap(), 0, pProperties );
    return 0;
}


VOID
CALLBACK
ConnectionCreationCallback(
    PEVENT_TRACE pEvent
    )

/*++

Routine Description:

    Called when a ConnectionCreationEvent occurs.
    
Arguments:

    pEvent -- pointer to the event trace structure

Return Value:

    None.

--*/

{
    FILETIME ftUtcTime;
    FILETIME ftLocalTime;
    SYSTEMTIME stLocalTime;
    PMSIPNAT_ConnectionCreationEvent pEventData;
    struct in_addr inAddr;

    InterlockedIncrement( &g_lCCreated );
    pEventData = (PMSIPNAT_ConnectionCreationEvent) pEvent->MofData;

    //
    // Convert the event timestamp to local systemtime structure
    //

    ftUtcTime.dwLowDateTime = pEvent->Header.TimeStamp.LowPart;
    ftUtcTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
    if( !FileTimeToLocalFileTime( &ftUtcTime, &ftLocalTime )
        || !FileTimeToSystemTime( &ftLocalTime, &stLocalTime ))
    {
        //
        // Conversion failed -- use zero time
        //
        ZeroMemory( &stLocalTime, sizeof( SYSTEMTIME ));
    }

    //
    // Print timestamp (yyyy/mm/dd hh:mm:ss)
    //
    
    _tprintf(
        _T("%i/%02i/%02i %02i:%02i:%02i ++"),
        stLocalTime.wYear,
        stLocalTime.wMonth,
        stLocalTime.wDay,
        stLocalTime.wHour,
        stLocalTime.wMinute,
        stLocalTime.wSecond
        );

    //
    // Connection details.
    //

    if( NAT_PROTOCOL_TCP == pEventData->Protocol )
    {
        _tprintf( _T("TCP ") );
    }
    else
    {
        _tprintf( _T("UDP ") );
    }

    if( pEventData->InboundConnection )
    {
        _tprintf( _T("inbound ") );
    }
    else
    {
        _tprintf( _T("outbound ") );
    }

    inAddr.s_addr = pEventData->LocalAddress;
    printf( inet_ntoa( inAddr ));
    
    _tprintf(
        _T("/%u :: "),
        ntohs( (u_short) pEventData->LocalPort )
        );

    inAddr.s_addr = pEventData->RemoteAddress;
    printf( inet_ntoa( inAddr ));

    _tprintf(
        _T("/%u\n"),
        ntohs( (u_short) pEventData->RemotePort )
        );
}


VOID
CALLBACK
ConnectionDeletionCallback(
    PEVENT_TRACE pEvent
    )

/*++

Routine Description:

    Called when a ConnectionDeletionEvent occurs.
    
Arguments:

    pEvent -- pointer to the event trace structure

Return Value:

    None.

--*/

{
    FILETIME ftUtcTime;
    FILETIME ftLocalTime;
    SYSTEMTIME stLocalTime;
    PMSIPNAT_ConnectionDeletionEvent pEventData;
    struct in_addr inAddr;

    InterlockedIncrement( &g_lCDeleted );
    pEventData = (PMSIPNAT_ConnectionDeletionEvent) pEvent->MofData;

    //
    // Convert the event timestamp to local systemtime structure
    //

    ftUtcTime.dwLowDateTime = pEvent->Header.TimeStamp.LowPart;
    ftUtcTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
    if( !FileTimeToLocalFileTime( &ftUtcTime, &ftLocalTime )
        || !FileTimeToSystemTime( &ftLocalTime, &stLocalTime ))
    {
        //
        // Conversion failed -- use zero time
        //
        ZeroMemory( &stLocalTime, sizeof( SYSTEMTIME ));
    }

    //
    // Print timestamp (yyyy/mm/dd hh:mm:ss)
    //
    
    _tprintf(
        _T("%i/%02i/%02i %02i:%02i:%02i --"),
        stLocalTime.wYear,
        stLocalTime.wMonth,
        stLocalTime.wDay,
        stLocalTime.wHour,
        stLocalTime.wMinute,
        stLocalTime.wSecond
        );

    //
    // Connection details.
    //

    if( NAT_PROTOCOL_TCP == pEventData->Protocol )
    {
        _tprintf( _T("TCP ") );
    }
    else
    {
        _tprintf( _T("UDP ") );
    }

    inAddr.s_addr = pEventData->LocalAddress;
    printf( inet_ntoa( inAddr ));
    
    _tprintf(
        _T("/%u :: "),
        ntohs( (u_short) pEventData->LocalPort )
        );

    inAddr.s_addr = pEventData->RemoteAddress;
    printf( inet_ntoa( inAddr ));

    _tprintf(
        _T("/%u\n"),
        ntohs( (u_short) pEventData->RemotePort )
        );
}


VOID
CALLBACK
PacketDroppedCallback(
    PEVENT_TRACE pEvent
    )

/*++

Routine Description:

    Called when a PacketDroppedEvent occurs.
    
Arguments:

    pEvent -- pointer to the event trace structure

Return Value:

    None.

--*/

{
    FILETIME ftUtcTime;
    FILETIME ftLocalTime;
    SYSTEMTIME stLocalTime;
    PMSIPNAT_PacketDroppedEvent pEventData;
    struct in_addr inAddr;

    InterlockedIncrement( &g_lDropped );
    pEventData = (PMSIPNAT_PacketDroppedEvent) pEvent->MofData;

    //
    // Convert the event timestamp to local systemtime structure
    //

    ftUtcTime.dwLowDateTime = pEvent->Header.TimeStamp.LowPart;
    ftUtcTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
    if( !FileTimeToLocalFileTime( &ftUtcTime, &ftLocalTime )
        || !FileTimeToSystemTime( &ftLocalTime, &stLocalTime ))
    {
        //
        // Conversion failed -- use zero time
        //
        ZeroMemory( &stLocalTime, sizeof( SYSTEMTIME ));
    }

    //
    // Print timestamp (yyyy/mm/dd hh:mm:ss)
    //
    
    _tprintf(
        _T("%i/%02i/%02i %02i:%02i:%02i - "),
        stLocalTime.wYear,
        stLocalTime.wMonth,
        stLocalTime.wDay,
        stLocalTime.wHour,
        stLocalTime.wMinute,
        stLocalTime.wSecond
        );
    

    switch( pEventData->Protocol )
    {
        case NAT_PROTOCOL_TCP:
        {
            _tprintf( _T("TCP: ") );
    
            inAddr.s_addr = pEventData->SourceAddress;
            printf( inet_ntoa( inAddr ));
            
            _tprintf(
                _T("/%u -> "),
                ntohs( (u_short) pEventData->SourceIdentifier )
                );

            inAddr.s_addr = pEventData->DestinationAddress;
            printf( inet_ntoa( inAddr ));

            _tprintf(
                _T("/%u "),
                ntohs( (u_short) pEventData->DestinationIdentifier )
                );

            if( pEventData->ProtocolData4 & TCP_FLAG_SYN )
            {
                _tprintf( _T("S") );
            }

            if( pEventData->ProtocolData4 & TCP_FLAG_FIN )
            {
                _tprintf( _T("F") );
            }

            if( pEventData->ProtocolData4 & TCP_FLAG_ACK )
            {
                _tprintf( _T("A") );
            }
            
            if( pEventData->ProtocolData4 & TCP_FLAG_RST )
            {
                _tprintf( _T("R") );
            }
            
            if( pEventData->ProtocolData4 & TCP_FLAG_URG )
            {
                _tprintf( _T("U") );
            }

            if( pEventData->ProtocolData4 & TCP_FLAG_PSH )
            {
                _tprintf( _T("P") );
            }

            _tprintf( _T("\n") );
            
            break;
        }

        case NAT_PROTOCOL_UDP:
        {
            _tprintf( _T("UDP: ") );
    
            inAddr.s_addr = pEventData->SourceAddress;
            printf( inet_ntoa( inAddr ));
            
            _tprintf(
                _T("/%u -> "),
                ntohs( (u_short) pEventData->SourceIdentifier )
                );

            inAddr.s_addr = pEventData->DestinationAddress;
            printf( inet_ntoa( inAddr ));

            _tprintf(
                _T("/%u\n"),
                ntohs( (u_short) pEventData->DestinationIdentifier )
                );
            break;
        }

        case NAT_PROTOCOL_ICMP:
        {
            _tprintf( _T("ICMP: ") );
    
            inAddr.s_addr = pEventData->SourceAddress;
            printf( inet_ntoa( inAddr ));
            
            _tprintf( _T(" -> ") );

            inAddr.s_addr = pEventData->DestinationAddress;
            printf( "%s\n", inet_ntoa( inAddr ));

            break;
        }

        default:
        {
            _tprintf( _T("Prot. %i: "), pEventData->Protocol );
            inAddr.s_addr = pEventData->SourceAddress;
            printf( inet_ntoa( inAddr ));
            
            _tprintf( _T(" -> ") );

            inAddr.s_addr = pEventData->DestinationAddress;
            printf( "%s\n", inet_ntoa( inAddr ));
        }
        
    }
    
}


UINT
WINAPI
ProcessTraceRoutine(
    PVOID pvThreadParam
    )

/*++

Routine Description:

    Thread routine for trace processing.
    
Arguments:

    pvThreadParam -- unused.
    
Return Value:

    Thread exit code.

--*/

{
    TRACEHANDLE             hStream;
    EVENT_TRACE_LOGFILE     LogFile;
    ULONG                   ulError;
    
    //
    // Register our trace callbacks
    //

    ulError = SetTraceCallback( &PacketDroppedEventGuid, PacketDroppedCallback );
    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: SetTraceCallback (PacketDropped) returned 0x%08x\n"),
            ulError );
        return -1;
    }

    ulError = SetTraceCallback( &ConnectionCreationEventGuid, ConnectionCreationCallback );
    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: SetTraceCallback (ConnectionCreation) returned 0x%08x\n"),
            ulError );
        return -1;
    }

    ulError = SetTraceCallback( &ConnectionDeletionEventGuid, ConnectionDeletionCallback );
    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: SetTraceCallback (ConnectionDeletion) returned 0x%08x\n"),
            ulError );
        return -1;
    }


    //
    // Open the event stream.
    //

    ZeroMemory( &LogFile, sizeof(LogFile) );
    LogFile.LoggerName = cszLogSession;
    LogFile.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;

    hStream = OpenTrace( &LogFile );
    if( (TRACEHANDLE)INVALID_HANDLE_VALUE == hStream )
    {
        _tprintf( _T("FwLogger: OpenTrace returned 0x%08x\n"), GetLastError() );
        return -1;
    }

    //
    // Process the trace stream
    //

    _tprintf( _T("FwLogger: Calling ProcessTrace...\n") );
    ulError = ProcessTrace( &hStream, 1, NULL, NULL );
    if( ERROR_SUCCESS != ulError )
    {
        _tprintf( _T("FwLogger: ProcessTrace returned 0x%08x\n"), ulError );
        CloseTrace( hStream );
        return -1;
    }

    //
    // Close the stream and exit
    //

    CloseTrace( hStream );
    return 0;
}


BOOL
WINAPI
ControlHandler(
    DWORD dwCtrlType
    )

/*++

Routine Description:

    Signals our shutdown event when the user wants to exit.
    
Arguments:

    dwCtrlType -- control signal type

Return Value:

    TRUE if we handled the control signal.

--*/

{
    if( CTRL_LOGOFF_EVENT != dwCtrlType )
    {
        SetEvent( g_hShutdownEvent );
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\hnetmon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : hnetmon.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

#define BRIDGEMON_HELPER_VERSION               1

//
// We need separate GUID's for each context we are registering,
// because each context has a different parent.  Contexts that
// have identical parents need not have differing GUID's
//
const GUID g_BridgeGuid = { /* 00770721-44ea-11d5-93ba-00b0d022dd1f */
    0x00770721,
    0x44ea,
    0x11d5,
    {0x93, 0xba, 0x00, 0xb0, 0xd0, 0x22, 0xdd, 0x1f}
  };

const GUID g_RootGuid   =   NETSH_ROOT_GUID;

//
// Function prototypes.
//
DWORD
WINAPI
InitHelperDll(
    IN      DWORD           dwNetshVersion,
    OUT     PVOID           pReserved
    );
    
DWORD
WINAPI
BridgeStartHelper(
    IN      CONST GUID *    pguidParent,
    IN      DWORD           dwVersion
    );

DWORD
WINAPI
BridgeStopHelper(
    IN  DWORD   dwReserved
    );

DWORD
WINAPI
BridgeCommit(
    IN  DWORD   dwAction
    );

DWORD
WINAPI
BridgeConnect(
    IN  LPCWSTR pwszMachine
    );

DWORD
WINAPI
BridgeDump(
    IN      LPCWSTR         pwszRouter,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwArgCount,
    IN      LPCVOID         pvData
    );


//
// externs
//
extern HANDLE g_hModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\hnmbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : hnmbase.h
//
//  Contents  : Base include file for HNetMon. Includes ATL stuff.
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------
#pragma once

#ifndef __HNMBASE_H_
#define __HNMBASE_H_

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>

#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))


#ifndef AddRefObj
#define AddRefObj (obj)  (( obj ) ? (obj)->AddRef () : 0)
#endif

#ifndef ReleaseObj
#define ReleaseObj(obj)  (( obj ) ? (obj)->Release() : 0)
#endif



#endif  // __HNMBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\hnmstring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : hnmstring.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 10 May 2001
//
//----------------------------------------------------------------------------

#define MSG_HELP_START L"%1!-14s! - "
#define MSG_NEWLINE _T("\n")

//
// The following are context names.
//
#define TOKEN_BRIDGE                           _T("bridge")


    // tokens for commands
#define TOKEN_COMMAND_ADD                      _T("add")
#define TOKEN_COMMAND_DELETE                   _T("delete")
#define TOKEN_COMMAND_SET                      _T("set")
#define TOKEN_COMMAND_SHOW                     _T("show")
#define TOKEN_COMMAND_HELP                     _T("help")
#define TOKEN_COMMAND_INSTALL                  _T("install")
#define TOKEN_COMMAND_UNINSTALL                _T("uninstall")

#define TOKEN_COMMAND_HELP1                    _T("/?")
#define TOKEN_COMMAND_HELP2                    _T("-?")

   // Bridge Adapter Options
#define TOKEN_OPT_ID                           _T("id")
#define TOKEN_OPT_FCMODE                       _T("forcecompatmode")

   // Bridge Adapter flag modes

   // Misc. option vlues
#define TOKEN_OPT_VALUE_INPUT                  _T("INPUT")
#define TOKEN_OPT_VALUE_OUTPUT                 _T("OUTPUT")

#define TOKEN_OPT_VALUE_ENABLE                 _T("enable")
#define TOKEN_OPT_VALUE_DISABLE                _T("disable")
#define TOKEN_OPT_VALUE_DEFAULT                _T("default")

#define TOKEN_OPT_VALUE_FULL                   _T("FULL")
#define TOKEN_OPT_VALUE_YES                    _T("YES")
#define TOKEN_OPT_VALUE_NO                     _T("NO")

#define TOKEN_HLPER_BRIDGE                     _T("bridge")

    // Commands for configuring the various protocols

    // tokens for commands required by most protocols

#define CMD_GROUP_ADD                          _T("add")
#define CMD_GROUP_DELETE                       _T("delete")
#define CMD_GROUP_SET                          _T("set")
#define CMD_GROUP_SHOW                         _T("show")

#define CMD_SHOW_HELPER                        _T("show helper")
#define CMD_INSTALL                            _T("install")
#define CMD_UNINSTALL                          _T("uninstall")
#define CMD_DUMP                               _T("dump")
#define CMD_HELP1                              _T("help")
#define CMD_HELP2                              _T("?")
#define CMD_ADD_HELPER                         _T("add helper")
#define CMD_DEL_HELPER                         _T("delete helper")

    // Bridge commands

    // Bridge add commands

#define CMD_BRIDGE_ADD_ADAPTER                 _T("adapter")

    // Bridge delete commands

#define CMD_BRIDGE_DEL_ADAPTER                 _T("adapter")

    // Bridge set commands

#define CMD_BRIDGE_SET_ADAPTER                 _T("adapter")

    // Bridge show commands

#define CMD_BRIDGE_SHOW_ADAPTER                _T("adapter")


    // Common dump commands

#define DMP_POPD                                L"\n\npopd\n"
#define DMP_UNINSTALL                           L"uninstall\n"

    // Bridge dump commands

#define DMP_BRIDGE_PUSHD                        L"\
pushd bridge\n"

#define DMP_BRIDGE_INSTALL                      _T("\
install\n")

#define DMP_BRIDGE_UNINSTALL                    _T("\
uninstall\n")

#define DMP_BRIDGE_DELETE_ADAPTER               _T("\
delete adapter name=%1!s! \n")

#define DMP_BRIDGE_ADD_ADAPTER                  _T("\
add adapter name=%1!s! \n")

#define DMP_BRIDGE_SET_ADAPTER                  _T("\
set adapter name=%1!s!\
 forcecompatmode=%2!d!\n")

    // Other strings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <assert.h>
#include <winsock2.h>
#include <netsh.h>
#include <hnetcfg.h>

#include "strdefs.h"
#include "hnmstring.h"
#include "hnmbase.h"
#include "bridge.h"
#include "hnetmon.h"
#include "utils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\strdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : strdefs.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 10 May 2001
//
//----------------------------------------------------------------------------

#ifndef __STRDEFS_H__
#define __STRDEFS_H__


// The string table entries that are identified here are arranged
// in a hierachy as follows

    // common hlp messages

    // command usage messages per protocol
        // show command usage
        // add command usage
        // delete command usage
        // set command usage

    // Output messages
        // Bridge messages
        // Miscellaneous messages

    // Strings
        // Protocol types
        // Miscellaneous strings

    // Error Messages
        // Bridge error messages

#define MSG_NULL                                1000

// commmon hlp messages

#define HLP_HELP                                2100
#define HLP_HELP_EX                             2101
#define HLP_HELP1                               HLP_HELP
#define HLP_HELP1_EX                            HLP_HELP_EX
#define HLP_HELP2                               HLP_HELP
#define HLP_HELP2_EX                            HLP_HELP_EX
#define HLP_INSTALL                             2110
#define HLP_INSTALL_EX                          2111
#define HLP_UNINSTALL                           2112
#define HLP_UNINSTALL_EX                        2113
#define HLP_DUMP                                2120
#define HLP_DUMP_EX                             2121
#define HLP_GROUP_SET                           2150
#define HLP_GROUP_SHOW                          2151


// BRIDGE

// bridge install/uninstall
#define HLP_BRIDGE_INSTALL                      5000
#define HLP_BRIDGE_INSTALL_EX                   5001
#define HLP_BRIDGE_UNINSTALL                    5002
#define HLP_BRIDGE_UNINSTALL_EX                 5003
#define HLP_BRIDGE_USE_GUI                      5004

// bridge dump

#define DMP_BRIDGE_HEADER                       5010
#define DMP_BRIDGE_FOOTER                       5011

// bridge set hlp

#define HLP_BRIDGE_SET_ADAPTER                  5110
#define HLP_BRIDGE_SET_ADAPTER_EX               5111

// bridge show hlp

#define HLP_BRIDGE_SHOW_ADAPTER                 5210
#define HLP_BRIDGE_SHOW_ADAPTER_EX              5211


// Output messages

        // Bridge messages
#define MSG_BRIDGE_GLOBAL_INFO                  20501

#define MSG_BRIDGE_ADAPTER_INFO_HDR             20551
#define MSG_BRIDGE_ADAPTER_INFO                 20552

#define MSG_BRIDGE_FLAGS                        20553


        // Miscellaneous messages
#define MSG_OK                                  30001
#define MSG_NO_HELPER                           30002
#define MSG_NO_HELPERS                          30003
#define MSG_CTRL_C_TO_QUIT                      30004


// Strings

    // Protocol types
#define STRING_PROTO_OTHER                      31001
#define STRING_PROTO_BRIDGE                     31002

    // Miscellaneous strings
#define STRING_CREATED                          32001
#define STRING_DELETED                          32002
#define STRING_ENABLED                          32003
#define STRING_DISABLED                         32004

#define STRING_YES                              32011
#define STRING_NO                               32012
#define STRING_Y                                32013
#define STRING_N                                32014

#define STRING_UNKNOWN                          32100

#define TABLE_SEPARATOR                         32200

// Error messages

    // Bridge error messages
#define MSG_BRIDGE_PRESENT                      40100
#define MSG_BRIDGE_NOT_PRESENT                  40101

    // Miscellaneous messages
#define EMSG_BAD_OPTION_VALUE                   50100

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\hnetmon.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : hnetmon.cpp
//
//  Contents  : helper initialization code
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

//
// Global variables.
//
HANDLE g_hModule = 0;



BOOL
WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{
    HANDLE     hDll;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            //DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            //
            // Clean up any structures used for commit
            //

            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}



DWORD
WINAPI
InitHelperDll(
    IN      DWORD           dwNetshVersion,
    OUT     PVOID           pReserved
    )
{   
    DWORD                   dwRet;
    NS_HELPER_ATTRIBUTES    attMyAttributes;

    //
    // Register helpers
    // We have a single helper only (BRIDGE)
    //
    
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    attMyAttributes.dwVersion      = BRIDGEMON_HELPER_VERSION;
    attMyAttributes.pfnStart       = BridgeStartHelper;
    attMyAttributes.pfnStop        = BridgeStopHelper;
    attMyAttributes.guidHelper     = g_BridgeGuid;
    
    //
    // Specify g_RootGuid as the parent helper to indicate 
    // that any contexts registered by this helper will be top 
    // level contexts.
    //
    dwRet = RegisterHelper(
                &g_RootGuid,
                &attMyAttributes
                );
                
    return dwRet;
}



DWORD
WINAPI
BridgeStartHelper(
    IN      CONST GUID *    pguidParent,
    IN      DWORD           dwVersion
    )
{
    DWORD                   dwRet = ERROR_INVALID_PARAMETER;
    NS_CONTEXT_ATTRIBUTES   attMyContextAttributes;

    ZeroMemory(&attMyContextAttributes, sizeof(attMyContextAttributes));
    
    attMyContextAttributes.dwVersion    = BRIDGEMON_HELPER_VERSION;
    attMyContextAttributes.dwFlags      = 0;
    attMyContextAttributes.ulPriority   = DEFAULT_CONTEXT_PRIORITY;
    attMyContextAttributes.pwszContext  = TOKEN_BRIDGE;
    attMyContextAttributes.guidHelper   = g_BridgeGuid;
    attMyContextAttributes.ulNumTopCmds = g_ulBridgeNumTopCmds;
    attMyContextAttributes.pTopCmds     = (CMD_ENTRY (*)[])g_BridgeCmds;
    attMyContextAttributes.ulNumGroups  = g_ulBridgeNumGroups;
    attMyContextAttributes.pCmdGroups   = (CMD_GROUP_ENTRY (*)[])g_BridgeCmdGroups;
    attMyContextAttributes.pfnCommitFn  = BridgeCommit;
    attMyContextAttributes.pfnConnectFn = BridgeConnect;
    attMyContextAttributes.pfnDumpFn    = BridgeDump;

    dwRet = RegisterContext(&attMyContextAttributes);
    
    return dwRet;
}



DWORD
WINAPI
BridgeStopHelper(
    IN  DWORD   dwReserved
    )
{
    return NO_ERROR;   
}



DWORD
WINAPI
BridgeCommit(
    IN  DWORD   dwAction
    )
{
    //
    // The handling of this action is admittedly simple in this example.
    // We simply have two copies of the data that we persist and consider
    // one the "online" set of data and one the "offline" set of data.
    // However, since neither the offline nor online sets of data need to
    // be "applied" to anything, it makes the distinction between them
    // somewhat meaningless.  The scheme used to support online/offline modes
    // is generally left up to the developer.
    //
    switch (dwAction)
    {
        case NETSH_COMMIT:
            //
            // Change to commit mode, otherwise known as online.
            //
            break;
            
        case NETSH_UNCOMMIT:
            //
            // Change to uncommit mode, otherwise known as offline.
            //
            break;
            
        case NETSH_FLUSH:
            //
            // Flush all uncommitted changes.
            //
            break;
            
        case NETSH_SAVE:
            //
            // Save all uncommitted changes.
            //            
            break;
            
        default:
            //
            // Not supported.
            //
            break;
    }       
    return NO_ERROR;
}



DWORD
WINAPI
BridgeConnect(
    IN  LPCWSTR pwszMachine
    )
{
    //
    // This function is called whenever the machine name changes.
    // If the context this was called for (you can specify a connect
    // function on a per context basis, see RegisterContext) is
    // supposed to be remotable, then the helper should verify
    // connectivity to the machine specified by pwszMachine and 
    // return an error if unable to reach the machine.
    //
    
    //
    // This is also where the helper might want to call RegisterContext
    // again on a context to remove or add commands at will.  This allows
    // the commands in your context to be dynamic, that is, commands
    // may be added and removed at will.  However, the versioning
    // functions tend to make a dynamic context unnecessary, as most
    // dynamic command changes are needed because of differing OS's the
    // commands are used on.  Note that NULL for pwszMachine indicates
    // that the machine to be connected to is the local machine.  When
    // and if the connect function returns an error code, the command
    // that was going to be executed (whether a context command or 
    // entering a context) will fail.
    //
    
    //
    // Uncomment this line to see how often the Connect function is called
    // and what gets passed to it.
    //
    //PrintMessageFromModule(g_hModule, GEN_CONNECT_SHOWSTRING, pwszMachine);
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\sources.inc ===
TARGETPATH=obj

IASDIR=$(PROJECT_ROOT)\ias

PASS0_HEADERDIR=$(IASDIR)\inc\$(O)

!ifndef IAS_NO_PCH
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(IASDIR)\inc\ias.h
PRECOMPILED_OPTION=/Yuias.h /Fp$(O)\pch.pch
PRECOMPILED_TARGET=$(O)\pch.pch
PRECOMPILED_OBJ=$(O)\pch.obj
!endif

USE_ATL=1
USE_MSVCRT=1
USE_NATIVE_EH=1
USE_VCCOM=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\utils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : utils.h
//
//  Contents  :
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

extern BOOL g_fInitCom;


HRESULT
HrInitializeHomenetConfig(
    BOOL*           pfInitCom,
    IHNetCfgMgr**   pphnc
    );

HRESULT
HrUninitializeHomenetConfig(
    BOOL            fUninitCom,
    IHNetCfgMgr*    phnc
    );

//
// useful extern functions
//

extern "C"
{

// from \rras\netsh\shell

LPWSTR
WINAPI
MakeString(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

VOID
WINAPI
FreeString(
    IN  LPWSTR pwszMadeString
    );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dll\iasdb.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasdb.cpp
//
// SYNOPSIS
//
//    Defines functions for accessing OLE-DB databases.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <iasdb.h>
#include <oledb.h>
#include <msjetoledb.h>
#include <atlbase.h>
#include <iastrace.h>

VOID
WINAPI
IASCreateTmpDirectory()
{
   // JetInit fails if the TMP directory doesn't exist, so we'll try to
   // create it just in case.
   DWORD needed = GetEnvironmentVariableW(L"TMP", NULL, 0);
   if (needed)
   {
      PWCHAR buf = (PWCHAR)_alloca(needed * sizeof(WCHAR));
      DWORD actual = GetEnvironmentVariableW(L"TMP", buf, needed);
      if (actual > 0 && actual < needed)
      {
         CreateDirectoryW(buf, NULL);
      }
   }
}

HRESULT
WINAPI
IASCreateJetProvider(
    OUT IDBInitialize** provider
    ) throw ()
{
   IASCreateTmpDirectory();

   // Convert the ProgID to a ClsID.
   CLSID clsid;
   HRESULT hr = CLSIDFromProgID(
                    L"Microsoft.Jet.OLEDB.4.0",
                    &clsid
                    );
   if (SUCCEEDED(hr))
   {
      // Create the OLE DB provider.
      hr = CoCreateInstance(
               clsid,
               NULL,
               CLSCTX_INPROC_SERVER,
               __uuidof(IDBInitialize),
               (PVOID*)provider
               );
   }
   return hr;
}


HRESULT
WINAPI
IASOpenJetDatabase(
    IN PCWSTR path,
    IN BOOL readOnly,
    OUT LPUNKNOWN* session
    )
{
   IASTracePrintf("INFO Enter IASOpenJetDatabase. path = %S readonly = %d",
      path, readOnly);

   // Initialize the out parameter.
   if (session == NULL) { return E_POINTER; }
   *session = NULL;
 
   HRESULT hr;
   do
   {
      // Create the OLE DB provider.
      CComPtr<IDBInitialize> connection;
      hr = IASCreateJetProvider(&connection);
      if (FAILED(hr)) { break; }

      //////////
      // Set the properties for the data source.
      //////////

      CComPtr<IDBProperties> properties;
      hr = connection->QueryInterface(
                           __uuidof(IDBProperties),
                           (PVOID*)&properties
                           );
      if (FAILED(hr)) { break; }

      CComBSTR bstrPath = SysAllocString(path);
      if (!bstrPath) 
      { 
         hr = E_OUTOFMEMORY; 
         break; 
      }

      DBPROP dbprop[2];
      dbprop[0].dwPropertyID    = DBPROP_INIT_MODE;
      dbprop[0].dwOptions       = DBPROPOPTIONS_REQUIRED;
      dbprop[0].colid           = DB_NULLID;
      dbprop[0].vValue.vt       = VT_I4;
      dbprop[0].vValue.lVal     = readOnly ? DB_MODE_READ : DB_MODE_READWRITE;

      dbprop[1].dwPropertyID    = DBPROP_INIT_DATASOURCE;
      dbprop[1].dwOptions       = DBPROPOPTIONS_REQUIRED;
      dbprop[1].colid           = DB_NULLID;
      dbprop[1].vValue.vt       = VT_BSTR;
      dbprop[1].vValue.bstrVal  = bstrPath;

      DBPROPSET dbpropSet;
      dbpropSet.guidPropertySet = DBPROPSET_DBINIT;
      dbpropSet.cProperties     = 2;
      dbpropSet.rgProperties    = dbprop;

      hr = properties->SetProperties(1, &dbpropSet);
      if (FAILED(hr))
      {
         hr = IASTraceJetError("IDBProperties::SetProperties", hr);
         break;
      }

      //////////
      // Set the Jet specific properties for the data source.
      //////////

      dbprop[0].dwPropertyID    = DBPROP_JETOLEDB_DATABASELOCKMODE;
      dbprop[0].dwOptions       = DBPROPOPTIONS_REQUIRED;
      dbprop[0].colid           = DB_NULLID;
      dbprop[0].vValue.vt       = VT_I4;
      dbprop[0].vValue.lVal     = (LONG)DBPROPVAL_DL_OLDMODE;

      dbpropSet.guidPropertySet = DBPROPSET_JETOLEDB_DBINIT;
      dbpropSet.cProperties     = 1;
      dbpropSet.rgProperties    = dbprop;

      hr = properties->SetProperties(1, &dbpropSet);
      if (FAILED(hr))
      {
         hr = IASTraceJetError("IDBProperties::SetProperties", hr);
         break;
      }

      //////////
      // Initialize the connection.
      //////////

      // This is a bit of a hack. The right approach would be to either (1) always
      // connect to the local database and use DCOM handle the remoting or (2)
      // always impersonate the client. Unfortunately, both of these would require
      // considerable changes to the existing client code. Instead, we'll only
      // impersonate the client when running under the local system account AND
      // opening a remote database. We know this will always fail if we don't
      // impersonate, so we can't lose anything by attempting to impersonate.
      bool revert = false;
   
      if ( !IASIsInprocServer() &&
           path[0] == L'\\' &&
           path[1] == L'\\' )
      {
         HRESULT hr = CoImpersonateClient();
         if ( FAILED(hr) )
         {
            IASTraceFailure("CoImpersonateClient", hr);
            break;
         }
         else
         {
            revert = true;
         }
      }

      hr = connection->Initialize();

      if (revert) { CoRevertToSelf(); }

      if (FAILED(hr))
      {
         hr =  IASTraceJetError("IDBInitialize::Initialize", hr);
         break;
      }

      //////////
      // Create a session.
      //////////

      CComPtr<IDBCreateSession> creator;
      hr = connection->QueryInterface(
                           __uuidof(IDBCreateSession),
                           (PVOID*)&creator
                           );
      if (FAILED(hr)) { break; }

      hr = creator->CreateSession(
                        NULL,
                        __uuidof(IUnknown),
                        session
                        );
      if (FAILED(hr))
      {
         hr = IASTraceJetError("IDBCreateSession::CreateSession", hr);
         break;
      }
   }
   while(false);

   IASTracePrintf("INFO Leave IASOpenJetDatabase. hr = 0x%08X", hr);
   return hr;
}

HRESULT
WINAPI
IASExecuteSQLCommand(
    IN LPUNKNOWN session,
    IN PCWSTR commandText,
    OUT IRowset** result
    )
{
   IASTracePrintf("INFO IASExecuteSQLCommand. Command = %S", commandText);

   // Initialize the out parameter.
   if (result) { *result = NULL; }

   HRESULT hr;
   CComPtr<IDBCreateCommand> creator;
   hr = session->QueryInterface(
                     __uuidof(IDBCreateCommand),
                     (PVOID*)&creator
                     );
   if (FAILED(hr)) { return hr; }

   CComPtr<ICommandText> command;
   hr = creator->CreateCommand(
                     NULL,
                     __uuidof(ICommandText),
                     (IUnknown**)&command
                     );
   if (FAILED(hr))
   {
      return IASTraceJetError("IDBCreateCommand::CreateCommand", hr);
   }

   hr = command->SetCommandText(
                     DBGUID_DBSQL,
                     commandText
                     );
   if (FAILED(hr))
   {
      return IASTraceJetError("ICommandText::SetCommandText", hr);
   }

   hr = command->Execute(
                     NULL,
                     (result ? __uuidof(IRowset) : IID_NULL),
                     NULL,
                     NULL,
                     (IUnknown**)result
                     );
   if (FAILED(hr))
   {
      return IASTraceJetError("ICommand::Execute", hr);
   }

   return S_OK;
}

HRESULT
WINAPI
IASExecuteSQLFunction(
    IN LPUNKNOWN session,
    IN PCWSTR functionText,
    OUT LONG* result
    )
{
   // Initialize the out parameter.
   if (result == NULL) { return E_POINTER; }
   *result = 0;

   // Execute the function.
   HRESULT hr;
   CComPtr<IRowset> rowset;
   hr = IASExecuteSQLCommand(
            session,
            functionText,
            &rowset
            );
   if (FAILED(hr)) { return hr; }

   CComPtr<IAccessor> accessor;
   hr = rowset->QueryInterface(
                    __uuidof(IAccessor),
                    (PVOID*)&accessor
                    );
   if (FAILED(hr)) { return hr; }

   // Get the result row.
   DBCOUNTITEM numRows;
   HROW hRow;
   HROW* pRow = &hRow;
   hr = rowset->GetNextRows(
                    NULL,
                    0,
                    1,
                    &numRows,
                    &pRow
                    );
   if (FAILED(hr))
   {
      return IASTraceJetError("IRowset::GetNextRows", hr);
   }

   if (numRows == 0) { return E_FAIL; }

   /////////
   // Create an accessor.
   /////////

   DBBINDING bind;
   memset(&bind, 0, sizeof(bind));
   bind.iOrdinal = 1;
   bind.dwPart   = DBPART_VALUE;
   bind.wType    = DBTYPE_I4;
   bind.cbMaxLen = 4;

   HACCESSOR hAccess;
   hr = accessor->CreateAccessor(
                      DBACCESSOR_ROWDATA,
                      1,
                      &bind,
                      4,
                      &hAccess,
                      NULL
                      );
   if (SUCCEEDED(hr))
   {
      // Get the data.
      hr = rowset->GetData(
                       hRow,
                       hAccess,
                       result
                       );
      if (FAILED(hr))
      {
         hr = IASTraceJetError("IRowset::GetData", hr);
      }

      accessor->ReleaseAccessor(hAccess, NULL);
   }
   else
   {
      hr = IASTraceJetError("IAccessor::CreateAccessor", hr);
   }

   rowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);

   return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IASCreateDatabase
//////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
IASCreateJetDatabase(
	 IN PCWSTR dataSource
	 )
{
   // Create the OLE DB provider.
   CComPtr<IDBInitialize> connection;
   HRESULT hr = IASCreateJetProvider(&connection);
   if (FAILED(hr)) { return hr; }

   //////////
   // Set the properties for the data source.
   //////////

   CComPtr<IDBProperties> properties;
   hr = connection->QueryInterface(
                        __uuidof(IDBProperties),
                        (PVOID*)&properties
                        );
   if (FAILED(hr)) { return hr; }

   CComBSTR bstrDataSource(dataSource);
   if ( !bstrDataSource) { return E_OUTOFMEMORY; }

   DBPROP dbprop[2];
   dbprop[0].dwPropertyID    = DBPROP_INIT_DATASOURCE;
   dbprop[0].dwOptions       = DBPROPOPTIONS_REQUIRED;
   dbprop[0].colid           = DB_NULLID;
   dbprop[0].vValue.vt       = VT_BSTR;
   dbprop[0].vValue.bstrVal  = bstrDataSource;

   dbprop[1].dwPropertyID    = DBPROP_INIT_LOCATION;
   dbprop[1].dwOptions       = DBPROPOPTIONS_OPTIONAL;
   dbprop[1].colid           = DB_NULLID;
   dbprop[1].vValue.vt       = VT_BSTR;
   dbprop[1].vValue.lVal     = VT_NULL;

   DBPROPSET dbpropSet;
   dbpropSet.guidPropertySet = DBPROPSET_DBINIT;
   dbpropSet.cProperties     = 2;
   dbpropSet.rgProperties    = dbprop;

   hr = properties->SetProperties(1, &dbpropSet);
   if (FAILED(hr))
   {
      return IASTraceJetError("IDBProperties::SetProperties", hr);
   }

   // Create the Data Source
   CComPtr<IDBDataSourceAdmin> admin;
   hr = connection->QueryInterface(
                        __uuidof(IDBDataSourceAdmin),
                        (PVOID*)&admin
                        );
   if (FAILED(hr)) { return hr; }

   hr = admin->CreateDataSource(
                   1,
                   &dbpropSet,
                   NULL,
                   __uuidof(IDBCreateSession),
                   NULL
                   );
   if (FAILED(hr))
   {
      return IASTraceJetError("IDBDataSourceAdmin::CreateDataSource", hr);
   }

   return S_OK;
}

// Internal Jet error codes from msjeterr.h
#define JET_errFileAccessDenied     -1032
#define JET_errKeyDuplicate         -1605

HRESULT
WINAPI
IASTraceJetError(
    PCSTR functionName,
    HRESULT errorCode
    )
{
   IASTracePrintf("%s failed; return value = 0x%08X", functionName, errorCode);
   IErrorInfo* errInfo;
   if (GetErrorInfo(0, &errInfo) == S_OK)
   {
      BSTR description;
      if (SUCCEEDED(errInfo->GetDescription(&description)))
      {
         IASTracePrintf("\tDescription: %S", description);
         SysFreeString(description);
      }

      IErrorRecords* errRecords;
      if (SUCCEEDED(errInfo->QueryInterface(
                                 __uuidof(IErrorRecords),
                                 (PVOID*)&errRecords
                                 )))
      {
         ULONG numRecords = 0;
         errRecords->GetRecordCount(&numRecords);

         for (ULONG i = 0; i < numRecords; ++i)
         {
            ERRORINFO info;
            if (SUCCEEDED(errRecords->GetBasicErrorInfo(i, &info)))
            {
               IASTracePrintf(
                   "\tRecord %lu: hrError = 0x%08X; dwMinor = 0x%08X",
                   i, info.hrError, info.dwMinor
                   );

               // Jolt does a poor job of mapping Jet error codes to HRESULTs,
               // so we handle a few ourselves. The Jet error code is the low
               // order 16 bits treated as a signed integer.
               switch ((WORD)info.dwMinor)
               {
                  case JET_errFileAccessDenied:
                     errorCode = E_ACCESSDENIED;
                     break;

                  case JET_errKeyDuplicate:
                     errorCode = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
                     break;
               }
            }
         }

         errRecords->Release();
      }

      errInfo->Release();
   }

   return errorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\netsh\utils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File      : utils.cpp
//
//  Contents  : Common utilities required by helper.
//
//  Notes     :
//
//  Author    : Raghu Gatta (rgatta) 11 May 2001
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

BOOL g_fInitCom = TRUE;


HRESULT
HrInitializeHomenetConfig(
    BOOL*           pfInitCom,
    IHNetCfgMgr**   pphnc
    )
/*++

Routine Description

    Cocreate and initialize the root IHNetCfgMgr object.  This will
    optionally initialize COM for the caller too.

Arguments

    pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
                               returns TRUE if COM was successfully
                               initialized FALSE if not.
                               If NULL, means don't initialize COM.
    pphnc           [out]      The returned IHNetCfgMgr object.
    
Return Value

    S_OK or an error code.
    
--*/
{
    HRESULT hr;
    

    //
    // Initialize the output parameter.
    //
    *pphnc = NULL;


    //
    // Initialize COM if the caller requested.
    //
    hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx(
                 NULL,
                 COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED
                 );

        if (RPC_E_CHANGED_MODE == hr)
        {
            //
            // we have already been initialized in a different model
            //
            hr = S_OK;
            *pfInitCom = FALSE;
        }
    }
    
    if (SUCCEEDED(hr))
    {

        //
        // Create Homenet Configuration Manager COM Instance
        //
        hr = CoCreateInstance(
                 CLSID_HNetCfgMgr,
                 NULL,
                 CLSCTX_INPROC_SERVER,
                 IID_PPV_ARG(IHNetCfgMgr, pphnc)
                 );

        if (SUCCEEDED(hr))
        {
            //
            // great! dont need to anything more here...
            //
        }

        //
        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize();
        }

    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeHomenetConfig
//
//  Purpose:    Unintialize and release an IHNetCfgMgr object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the IHNetCfgMgr is
//                      uninitialized and released.
//      phnc       [in] The IHNetCfgMgr object.
//
//  Returns:    S_OK or an error code.
//
//  Author:     rgatta 11 May 2001
//
//----------------------------------------------------------------------------
HRESULT
HrUninitializeHomenetConfig(
    BOOL            fUninitCom,
    IHNetCfgMgr*    phnc
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    assert(phnc);
    HRESULT hr = S_OK;

    if (phnc)
    {
        phnc->Release();
    }
    
    phnc = NULL;

    if (fUninitCom)
    {
        CoUninitialize ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dll\iasjet.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasjet.cpp
//
// SYNOPSIS
//
//    Implementation of DLL exports for an ATL in proc server.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>

#include <resource.h>
#include <attrdnary.h>
#include <iasdb.h>
#include <oledbstore.h>
#include <netshhelper.h>
#include <setup.h>

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(__uuidof(AttributeDictionary), AttributeDictionary)
   OBJECT_ENTRY(__uuidof(OleDBDataStore), OleDBDataStore)
   OBJECT_ENTRY(__uuidof(CIASNetshJetHelper), CIASNetshJetHelper)
END_OBJECT_MAP()

//////////
// DLL Entry Point
//////////
BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
     _Module.Init(ObjectMap, hInstance);

     DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
     _Module.Term();
   }

   return TRUE;
}


//////////
// Used to determine whether the DLL can be unloaded by OLE
//////////
STDAPI DllCanUnloadNow()
{
   return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


//////////
// Returns a class factory to create an object of the requested type.
//////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   return _Module.GetClassObject(rclsid, riid, ppv);
}


//////////
// DllRegisterServer - Adds entries to the system registry
//////////
STDAPI DllRegisterServer()
{
   HRESULT hr = _Module.UpdateRegistryFromResource(
                      IDR_REGISTRY,
                      TRUE,
                      NULL
                      );
   ////////////////////////////////////////////////////////////////////
   // Do the upgrade even if the registration failed. the upgrade code
   // does not rely on the registration.
   ////////////////////////////////////////////////////////////////////
   CIASUpgrade  Upgrade;
   // ignore return value, FALSE = not called from Netshell
   Upgrade.IASUpgrade(FALSE); 
   return hr;
}


//////////
// DllUnregisterServer - Removes entries from the system registry
//////////
STDAPI DllUnregisterServer()
{
   _Module.UpdateRegistryFromResource(
               IDR_REGISTRY,
               FALSE,
               NULL
               );

   return S_OK;
}

// Flag indicating whether we are running in-proc.
BOOL theInprocFlag = TRUE;

BOOL
WINAPI
IASIsInprocServer()
{
   return theInprocFlag;
}

// The AppID for IAS Jet Database Access.
struct __declspec(uuid("{A5CEB593-CCC3-486B-AB91-9C5C5ED4C9E1}")) theAppID;

// Event used to signal the service to stop.
HANDLE theStopEvent;

// Service control handler.
VOID
WINAPI
ServiceHandler(
    DWORD fdwControl   // requested control code
    )
{
   switch (fdwControl)
   {
      case SERVICE_CONTROL_SHUTDOWN:
      case SERVICE_CONTROL_STOP:
         SetEvent(theStopEvent);
   }
}

// Service Main.
VOID
WINAPI
ServiceMain(
    DWORD /* dwArgc */,
    LPWSTR* /* lpszArgv */
    )
{
   // We're being used as a service.
   theInprocFlag = FALSE;

   SERVICE_STATUS status =
   {
      SERVICE_WIN32_OWN_PROCESS, // dwServiceType;
      SERVICE_START_PENDING,     // dwCurrentState;
      SERVICE_ACCEPT_STOP |
      SERVICE_ACCEPT_SHUTDOWN,   // dwControlsAccepted;
      NO_ERROR,                  // dwWin32ExitCode;
      0,                         // dwServiceSpecificExitCode;
      0,                         // dwCheckPoint;
      0                          // dwWaitHint;
   };

   // Register the service control handler.
   SERVICE_STATUS_HANDLE statusHandle = RegisterServiceCtrlHandlerW(
                                            L"IASJet",
                                            ServiceHandler
                                            );

   // Let the SCM know we're starting.
   SetServiceStatus(statusHandle, &status);

   // Create the stop event.
   theStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
   if (theStopEvent)
   {
      // Initialize the COM run-time.
      HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
      if (SUCCEEDED(hr))
      {
         // Get the security settings from our AppID key in the registry.
         hr = CoInitializeSecurity(
                  (PVOID)&__uuidof(theAppID),
                   -1,
                   NULL,
                   NULL,
                   0,
                   0,
                   NULL,
                   EOAC_APPID,
                   NULL
                   );
         if (SUCCEEDED(hr))
         {
            // Register the class objects we support.
            hr = _Module.RegisterClassObjects(
                             CLSCTX_LOCAL_SERVER,
                             REGCLS_MULTIPLEUSE
                             );
            if (SUCCEEDED(hr))
            {
               // Let the SCM know we're running.
               status.dwCurrentState = SERVICE_RUNNING;
               SetServiceStatus(statusHandle, &status);

               // Wait until someone tells us to stop.
               WaitForSingleObject(theStopEvent, INFINITE);

               status.dwCurrentState = SERVICE_STOP_PENDING;
               SetServiceStatus(statusHandle, &status);

               // Revoke the class objects.
               _Module.RevokeClassObjects();
            }
         }

         // Shutdown the COM runtime.
         CoUninitialize();
      }

      // Clean-up the stop event.
      CloseHandle(theStopEvent);
      theStopEvent = NULL;

      status.dwWin32ExitCode = hr;
   }
   else
   {
      status.dwWin32ExitCode = GetLastError();
   }

   // We're stopped.
   status.dwCurrentState = SERVICE_STOPPED;
   SetServiceStatus(statusHandle, &status);
}

#include <newop.cpp>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dnary\attrdnary.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attrdnary.h
//
// SYNOPSIS
//
//    Declares the class AttributeDictionary.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ATTRDNARY_H
#define ATTRDNARY_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <datastore2.h>
#include <iasuuid.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    AttributeDictionary
//
// DESCRIPTION
//
//    Provides an Automation compatible wrapper around the IAS attribute
//    dictionary.
//
///////////////////////////////////////////////////////////////////////////////
class AttributeDictionary
   : public CComObjectRootEx< CComMultiThreadModelNoCS >,
     public CComCoClass< AttributeDictionary, &__uuidof(AttributeDictionary) >,
     public IAttributeDictionary
{
public:
   DECLARE_NO_REGISTRY()
   DECLARE_NOT_AGGREGATABLE(AttributeDictionary)

BEGIN_COM_MAP(AttributeDictionary)
   COM_INTERFACE_ENTRY_IID(__uuidof(IAttributeDictionary), IAttributeDictionary)
END_COM_MAP()

   // IAttributeDictionary
   STDMETHOD(GetDictionary)(
                 BSTR bstrPath,
                 VARIANT* pVal
                 );
};

#endif // ATTRDNARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dll\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    resource.h
//
// SYNOPSIS
//
//    Resource declarations.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef RESOURCE_H
#define RESOURCE_H
#if _MSC_VER >= 1000
#pragma once
#endif

#define IDR_REGISTRY    101

#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dnary\attrdnary.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attrdnary.cpp
//
// SYNOPSIS
//
//    Defines the class AttributeDictionary.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>

#include <attrdnary.h>
#include <enumerators.h>

#include <iasdb.h>
#include <oledberr.h>
#include <simtable.h>

typedef struct _IASTable {
    ULONG numColumns;
    ULONG numRows;
    BSTR* columnNames;
    VARTYPE* columnTypes;
    VARIANT* table;
} IASTable;

// Command to retrieve attributes of interest.
const WCHAR LEGACY_COMMAND_TEXT[] =
   L"SELECT ID, Name, Syntax, MultiValued, "
   L"       VendorID, VendorTypeID, VendorTypeWidth, VendorLengthWidth, "
   L"       [Exclude from NT4 IAS Log], [ODBC Log Ordinal], "
   L"       IsAllowedInProfile, IsAllowedInCondition, "
   L"       IsAllowedInProfile, IsAllowedInCondition, "
   L"       Description, LDAPName "
   L"FROM Attributes;";

const WCHAR COMMAND_TEXT[] =
   L"SELECT ID, Name, Syntax, MultiValued, "
   L"       VendorID, VendorTypeID, VendorTypeWidth, VendorLengthWidth, "
   L"       [Exclude from NT4 IAS Log], [ODBC Log Ordinal], "
   L"       IsAllowedInProfile, IsAllowedInCondition, "
   L"       IsAllowedInProxyProfile, IsAllowedInProxyCondition, "
   L"       Description, LDAPName "
   L"FROM Attributes;";


//////////
// Allocates memory to store an IASTable struct and stores it in a VARIANT.
//////////
HRESULT
WINAPI
IASAllocateTable(
    IN ULONG cols,
    IN ULONG rows,
    OUT IASTable& table,
    OUT VARIANT& tableVariant
    ) throw ()
{
   //Initialize the out parameters.
   memset(&table, 0, sizeof(table));
   VariantInit(&tableVariant);

   // Save the dimensions.
   table.numColumns = cols;
   table.numRows = rows;

   SAFEARRAYBOUND bound[2];
   bound[0].lLbound = bound[1].lLbound = 0;

   // The outer array has three elements:
   //    (1) column names, (2) column types, and (3) table data.
   CComVariant value;
   bound[0].cElements = 3;
   V_ARRAY(&value) = SafeArrayCreate(VT_VARIANT, 1, bound);
   if (!V_ARRAY(&value)) { return E_OUTOFMEMORY; }
   V_VT(&value) = VT_ARRAY | VT_VARIANT;

   VARIANT* data = (VARIANT*)V_ARRAY(&value)->pvData;

   // First element is a vector of BSTRs for the column names.
   bound[0].cElements = table.numColumns;
   V_ARRAY(data) = SafeArrayCreate(VT_BSTR, 1, bound);
   if (!V_ARRAY(data)) { return E_OUTOFMEMORY; }
   V_VT(data) = VT_ARRAY | VT_BSTR;

   // Get the raw vector.
   table.columnNames = (BSTR*)V_ARRAY(data)->pvData;

   ++data;

   // Second element is a vector of USHORTs for the column names.
   bound[0].cElements = table.numColumns;
   V_ARRAY(data) = SafeArrayCreate(VT_UI2, 1, bound);
   if (!V_ARRAY(data)) { return E_OUTOFMEMORY; }
   V_VT(data) = VT_ARRAY | VT_UI2;

   // Get the raw vector.
   table.columnTypes = (USHORT*)V_ARRAY(data)->pvData;

   ++data;

   // Third element is a 2D matrix of VARIANTs for the table data.
   bound[0].cElements = table.numRows;
   bound[1].cElements = table.numColumns;
   V_ARRAY(data) = SafeArrayCreate(VT_VARIANT, 2, bound);
   if (!V_ARRAY(data)) { return E_OUTOFMEMORY; }
   V_VT(data) = VT_ARRAY | VT_VARIANT;

   // Get the raw table.
   table.table = (VARIANT*)V_ARRAY(data)->pvData;

   return value.Detach(&tableVariant);
}

STDMETHODIMP AttributeDictionary::GetDictionary(
                                      BSTR bstrPath,
                                      VARIANT* pVal
                                      )
{
   HRESULT hr;

   // Initialize out parameter.
   if (pVal == NULL) { return E_POINTER; }
   VariantInit(pVal);

   // Validate in parameter.
   if (bstrPath == NULL) { return E_INVALIDARG; }

   // Open the database.
   CComPtr<IUnknown> session;
   hr = IASOpenJetDatabase(
            bstrPath,
            TRUE,
            &session
            );
   if (FAILED(hr)) { return hr; }

   // Process the enumerators table.
   Enumerators enums;
   hr = enums.initialize(session);
   if (FAILED(hr)) { return hr; }

   // Process the attributes table.
   ULONG rows;
   hr = IASExecuteSQLFunction(
            session,
            L"SELECT Count(*) AS X From Attributes;",
            (PLONG)&rows
            );
   if (FAILED(hr)) { return hr; }

   CComPtr<IRowset> rowset;
   hr = IASExecuteSQLCommand(
            session,
            COMMAND_TEXT,
            &rowset
            );
   if (hr == DB_E_PARAMNOTOPTIONAL)
   {
      hr = IASExecuteSQLCommand(
               session,
               LEGACY_COMMAND_TEXT,
               &rowset
               );
   }
   if (FAILED(hr)) { return hr; }

   CSimpleTable attrs;
   hr = attrs.Attach(rowset);
   if (FAILED(hr)) { return hr; }

   ULONG columns = (ULONG)attrs.GetColumnCount() + 2;

   // Allocate the IASTableObject.
   IASTable table;
   CComVariant tableVariant;
   hr = IASAllocateTable(
            columns,
            rows,
            table,
            tableVariant
            );
   if (FAILED(hr)) { return hr; }

   // Populate the column names and types.  First from the rowset schema ...
   DBORDINAL i;
   BSTR* name  = table.columnNames;
   VARTYPE* vt = table.columnTypes;
   for (i = 1; i <= attrs.GetColumnCount(); ++i, ++name, ++vt)
   {
      *name = SysAllocString(attrs.GetColumnName(i));
      if (!*name) { return E_OUTOFMEMORY; }

      switch (attrs.GetColumnType(i))
      {
         case DBTYPE_I4:
            *vt = VT_I4;
            break;
         case DBTYPE_BOOL:
            *vt = VT_BOOL;
            break;
         case DBTYPE_WSTR:
            *vt = VT_BSTR;
            break;
         default:
            *vt = VT_EMPTY;
            break;
      }
   }

   // ... and then the two derived columns.
   *name = SysAllocString(L"EnumNames");
   if (!*name) { return E_OUTOFMEMORY; }
   *vt = VT_ARRAY | VT_VARIANT;

   ++name;
   ++vt;

   *name = SysAllocString(L"EnumValues");
   if (!*name) { return E_OUTOFMEMORY; }
   *vt = VT_ARRAY | VT_VARIANT;

   // Populate the table data.
   VARIANT *v, *end = table.table + columns * rows;
   for (v = table.table; v != end && !attrs.MoveNext(); )
   {
      // Handle the ID separately since we need it later.
      LONG id = *(LONG*)attrs.GetValue(1);
      V_VT(v) = VT_I4;
      V_I4(v) = id;
      ++v;

      // Get the remaining columns from the rowset.
      for (DBORDINAL i = 2; i <= attrs.GetColumnCount(); ++i, ++v)
      {
         VariantInit(v);

         if (attrs.GetLength(i))
         {
            switch (attrs.GetColumnType(i))
            {
               case DBTYPE_I4:
               {
                  V_I4(v) = *(LONG*)attrs.GetValue(i);
                  V_VT(v) = VT_I4;
                  break;
               }

               case DBTYPE_BOOL:
               {
                  V_BOOL(v) = *(VARIANT_BOOL*)attrs.GetValue(i)
                                 ? VARIANT_TRUE : VARIANT_FALSE;
                  V_VT(v) = VT_BOOL;
                  break;
               }

               case DBTYPE_WSTR:
               {
                  V_BSTR(v) = SysAllocString((PCWSTR)attrs.GetValue(i));
                  if (!V_BSTR(v)) { return E_OUTOFMEMORY; }
                  V_VT(v) = VT_BSTR;
                  break;
               }
            }
         }
      }

      // Get the enumeration SAFEARRAYs.
      hr = enums.getEnumerators(id, v, v + 1);
      if (FAILED(hr)) { return hr; }
      v += 2;
   }

   // All went well so return the VARIANT to the caller.
   return tableVariant.Detach(pVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dnary\enumerators.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    enumerators.h
//
// SYNOPSIS
//
//    Declares the class Enumerators.
//
// MODIFICATION HISTORY
//
//    02/25/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ENUMERATORS_H
#define ENUMERATORS_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <ole2.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Enumerators
//
// DESCRIPTION
//
//    Processes the Enumerators table from the dictionary database.
//
///////////////////////////////////////////////////////////////////////////////
class Enumerators
{
public:
   Enumerators() throw ()
      : begin(NULL), next(NULL), end(NULL)
   { }

   ~Enumerators() throw ();

   HRESULT initialize(IUnknown* session) throw ();

   // Must be called exactly once for each attribute ID.
   // Attribute IDs must be passed in ascending order.
   HRESULT getEnumerators(
               LONG id,
               VARIANT* pNames,
               VARIANT* pValues
               ) throw ();

protected:
   // Must be called exactly once for each attribute ID.
   // Attribute IDs must be passed in ascending order.
   HRESULT getEnumerators(
               LONG id,
               LPSAFEARRAY* pNames,
               LPSAFEARRAY* pValues
               ) throw ();

private:

   // Stores one row from the Enumerators table.
   struct Enumeration
   {
      LONG enumerates;
      LONG value;
      BSTR name;
   };

   Enumeration* begin;  // Begin of cached rows.
   Enumeration* next;   // Next row to be processed.
   Enumeration* end;    // End of cached rows.

   // Not implemented.
   Enumerators(const Enumerators&);
   Enumerators& operator=(const Enumerators&);
};

#endif  // ENUMERATORS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\bind.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    bind.cpp
//
// SYNOPSIS
//
//    This file defines various helper functions for binding an OLE-DB
//    accessor to the members of a class.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <oledb.h>
#include <bind.h>

DBLENGTH Bind::getRowSize(
                   DBCOUNTITEM cBindings,
                   const DBBINDING rgBindings[]
                   ) throw ()
{
   DBLENGTH rowSize = 0;

   while (cBindings--)
   {
      DBLENGTH end = rgBindings->obValue + rgBindings->cbMaxLen;

      if (end > rowSize) { rowSize = end; }

      ++rgBindings;
   }

   return rowSize;
}

HACCESSOR Bind::createAccessor(IUnknown* pUnk,
                               DBACCESSORFLAGS dwAccessorFlags,
                               DBCOUNTITEM cBindings,
                               const DBBINDING rgBindings[],
                               DBLENGTH cbRowSize)
{
   using _com_util::CheckError;

   CComPtr<IAccessor> accessor;
   CheckError(pUnk->QueryInterface(__uuidof(IAccessor), (PVOID*)&accessor));

   HACCESSOR h;
   CheckError(accessor->CreateAccessor(dwAccessorFlags,
                                       cBindings,
                                       rgBindings,
                                       cbRowSize,
                                       &h,
                                       NULL));

   return h;
}


   // Releases an accessor on the pUnk object.
void Bind::releaseAccessor(IUnknown* pUnk, HACCESSOR hAccessor) throw ()
{
   if (pUnk && hAccessor)
   {
      IAccessor* accessor;

      HRESULT hr = pUnk->QueryInterface(__uuidof(IAccessor),
                                        (PVOID*)&accessor);

     if (SUCCEEDED(hr))
     {
        accessor->ReleaseAccessor(hAccessor, NULL);

        accessor->Release();
     }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dnary\enumerators.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    enumerators.cpp
//
// SYNOPSIS
//
//    Defines the class Enumerators.
//
// MODIFICATION HISTORY
//
//    02/25/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <enumerators.h>
#include <iasdb.h>
#include <simtable.h>

Enumerators::~Enumerators() throw ()
{
   for ( ; next != end; ++next)
   {
      SysFreeString(next->name);
   }

   CoTaskMemFree(begin);
}

HRESULT Enumerators::getEnumerators(
                         LONG id,
                         VARIANT* pNames,
                         VARIANT* pValues
                         ) throw ()
{
   VariantInit(pNames);
   VariantInit(pValues);

   HRESULT hr = getEnumerators(
                    id,
                    &V_ARRAY(pNames),
                    &V_ARRAY(pValues)
                    );

   if (SUCCEEDED(hr) && V_ARRAY(pNames))
   {
      V_VT(pNames)  = VT_ARRAY | VT_VARIANT;
      V_VT(pValues) = VT_ARRAY | VT_VARIANT;
   }

   return hr;
}

HRESULT Enumerators::getEnumerators(
                         LONG id,
                         LPSAFEARRAY* pNames,
                         LPSAFEARRAY* pValues
                         ) throw ()
{
   // Initialize the out parameters.
   *pNames = *pValues = NULL;

   // If this is less than next, it must not be an enumerator.
   if (id < next->enumerates) { return S_OK; }

   // If this is greater than next, we skipped one.
   if (id > next->enumerates) { return E_INVALIDARG; }

   // Find the range of enumerations for this id.
   Enumeration* last = next;
   do { ++last; } while (last->enumerates == id);
   ULONG num = (ULONG)(last - next);

   // Create a SAFEARRAY to hold the names.
   *pNames  = SafeArrayCreateVector(VT_VARIANT, 0, num);
   if (*pNames == NULL) { return E_OUTOFMEMORY; }

   // Create a SAFEARRAY to hold the values.
   *pValues = SafeArrayCreateVector(VT_VARIANT, 0, num);
   if (*pValues == NULL)
   {
      SafeArrayDestroy(*pNames);
      *pNames = NULL;
      return E_OUTOFMEMORY;
   }

   // Fill in the VARIANTs in the array.
   VARIANT* name = (VARIANT*)(*pNames)->pvData;
   VARIANT* value = (VARIANT*)(*pValues)->pvData;
   for ( ; next != last; ++next, ++name, ++value)
   {
      VariantInit(name);
      V_VT(name) = VT_BSTR;
      V_BSTR(name) = next->name;

      VariantInit(value);
      V_VT(value) = VT_I4;
      V_I4(value) = next->value;
   }

   return S_OK;
}

HRESULT Enumerators::initialize(IUnknown* session) throw ()
{
   HRESULT hr;
   LONG count;
   hr = IASExecuteSQLFunction(
            session,
            L"SELECT Count(*) AS X From Enumerators;",
            &count
            );
   if (FAILED(hr)) { return hr; }

   CComPtr<IRowset> rowset;
   hr = IASExecuteSQLCommand(
            session,
            L"SELECT Name, Enumerates, Value FROM Enumerators "
            L"ORDER BY Enumerates, Value;",
            &rowset
            );
   if (FAILED(hr)) { return hr; }

   CSimpleTable table;
   hr = table.Attach(rowset);
   if (FAILED(hr)) { return hr; }

   // Allocate one extra slot for the sentinel.
   begin = (Enumeration*)CoTaskMemAlloc((count + 1) * sizeof(Enumeration));
   if (!begin) { return E_OUTOFMEMORY; }

   // Iterate through the rowset.
   for (end = begin; count-- && !table.MoveNext(); ++end)
   {
      end->enumerates = *(PLONG)table.GetValue(2);
      end->value      = *(PLONG)table.GetValue(3);
      end->name       = SysAllocString((PCWSTR)table.GetValue(1));
      if (!end->name) { return E_OUTOFMEMORY; }
   }

   // Set the sentinel.
   end->enumerates = 0;

   // We start at the beginning.
   next = begin;

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dnary\simtable.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    SimTable.h
//
// SYNOPSIS
//
//    This file describes the class CSimpleTable
//
// MODIFICATION HISTORY
//
//    10/31/1997    Original version.
//    02/09/1998    Reorganized some things to make is easier to extend.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _SIMTABLE_H_
#define _SIMTABLE_H_

#include <atlbase.h>
#include <oledb.h>

#include <bitvec.h>
struct DBBinding;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CSimpleTable
//
// DESCRIPTION
//
//    This class provides a simple read-only wrapper for iterating through a
//    rowset and retrieving information.  The interface is based on the ATL
//    CTable<> class. I kept all the function signatures the same, so the two
//    should be almost interchangeable. The main difference is that CTable<>
//    opens a table and retrieves a rowset, while CSimpleTable is handed a
//    rowset that was retrieved elsewhere.
//
///////////////////////////////////////////////////////////////////////////////
class CSimpleTable
{
public:

   CSimpleTable();
   ~CSimpleTable();

   HRESULT Attach(IRowset* pRowset);
   IRowset* Detach();

   HRESULT MoveFirst();
   HRESULT MoveNext();

   HRESULT Insert();
   HRESULT Delete();
   HRESULT SetData();

   void DiscardChanges()
   {
      dirty.reset();
   }

   DBORDINAL GetColumnCount() const
   {
      return numColumns;
   }

   DBCOLUMNFLAGS GetColumnFlags(DBORDINAL nOrdinal) const
   {
      return columnInfo[OrdinalToColumn(nOrdinal)].dwFlags;
   }

   LPCWSTR GetColumnName(DBORDINAL nOrdinal) const
   {
      return columnInfo[OrdinalToColumn(nOrdinal)].pwszName;
   }

   DBTYPE GetColumnType(DBORDINAL nOrdinal) const
   {
      return columnInfo[OrdinalToColumn(nOrdinal)].wType;
   }

   DBLENGTH GetLength(DBORDINAL nOrdinal) const;

   bool GetOrdinal(LPCWSTR szColumnName, DBORDINAL* pOrdinal) const;

   DBSTATUS GetStatus(DBORDINAL nOrdinal) const;

   const void* GetValue(DBORDINAL nOrdinal) const
   {
      return _GetDataPtr(nOrdinal);
   }

   template <class T>
   void SetValue(DBORDINAL nOrdinal, const T& t)
   {
      *(T*)_GetDataPtr(nOrdinal) = t;
   }

   template <>
   void SetValue(DBORDINAL nOrdinal, PCSTR szValue)
   {
      strcpy((PSTR)_GetDataPtr(nOrdinal), szValue);
   }

   template <>
   void SetValue(DBORDINAL nOrdinal, PSTR szValue)
   {
      strcpy((PSTR)_GetDataPtr(nOrdinal), szValue);
   }

   bool HasBookmark() const
   {
      return (numColumns > 0) && (columnInfo->iOrdinal == 0);
   }

protected:

   enum { FETCH_QUANTUM = 256 };   // The number of rows fetched at a time.

   HRESULT CreateAccessorForWrite(HACCESSOR* phAccessor);

   void* _GetDataPtr(DBORDINAL nOrdinal);

   const void* _GetDataPtr(DBORDINAL nOrdinal) const
   {
      return buffer +
             (ULONG_PTR)columnInfo[OrdinalToColumn(nOrdinal)].pTypeInfo;
   }

   HRESULT ReleaseRows();

   DBORDINAL OrdinalToColumn(DBORDINAL nOrdinal) const
   {
      return nOrdinal -= columnInfo->iOrdinal;
   }

   // Various representations of the rowset being manipulated.
   CComPtr<IRowset> rowset;
   CComPtr<IAccessor> accessor;
   CComPtr<IRowsetChange> rowsetChange;

   DBORDINAL numColumns;      // Number of columns in the table.
   DBCOLUMNINFO* columnInfo;  // Column info.
   OLECHAR* stringsBuffer;    // Buffer used by columnInfo.
   DBBinding* columnBinding;  // Column bindings.
   HACCESSOR readAccess;      // Handle for read accessor.
   PBYTE buffer;              // Accessor buffer.
   DBLENGTH bufferLength;     // Length of accessor buffer.
   HROW row[FETCH_QUANTUM];   // Array of row handles.
   DBCOUNTITEM numRows;       // Number of rows in the row array.
   DBCOUNTITEM currentRow;    // Current row being accessed.
   BitVector dirty;           // Columns that have been modified.
   bool endOfRowset;          // True if we've reached the end of the rowset.
};

#endif  // _SIMTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\bind.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    bind.h
//
// SYNOPSIS
//
//    This file declares various macros and helper functions for binding
//    an OLE-DB accessor to the members of a class.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _BIND_H_
#define _BIND_H_

#include <oledb.h>

namespace Bind
{
   // Returns the buffer size required for a given DBBINDING array.
   DBLENGTH getRowSize(DBCOUNTITEM cBindings,
                       const DBBINDING rgBindings[]) throw ();

   // Creates an accessor on the pUnk object.
   HACCESSOR createAccessor(IUnknown* pUnk,
                            DBACCESSORFLAGS dwAccessorFlags,
                            DBCOUNTITEM cBindings,
                            const DBBINDING rgBindings[],
                            DBLENGTH cbRowSize);

   // Releases an accessor on the pUnk object.
   void releaseAccessor(IUnknown* pUnk,
                        HACCESSOR hAccessor) throw ();
}

//////////
// Marks the beginning of DBBINDING map.
//////////
#define BEGIN_BIND_MAP(class, name, flags) \
HACCESSOR create ## name(IUnknown* p) const \
{ typedef class _theClass; \
  const DBACCESSORFLAGS dbFlags = flags; \
  static const DBBINDING binding[] = {

//////////
// Terminates a DBBINDING map.
//////////
#define END_BIND_MAP() \
  }; const DBCOUNTITEM count = sizeof(binding)/sizeof(DBBINDING); \
  static const DBLENGTH rowsize = Bind::getRowSize(count, binding); \
  return Bind::createAccessor(p, dbFlags, count, binding, rowsize); \
}

//////////
// Entry in a DBBINDING map. Entries must be separated by commas.
//////////
#define BIND_COLUMN(member, ordinal, type) \
  { ordinal, offsetof(_theClass, member), 0, 0, NULL, NULL, NULL, \
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, \
    (dbFlags == DBACCESSOR_ROWDATA ? DBPARAMIO_NOTPARAM : DBPARAMIO_INPUT), \
    sizeof(_theClass :: member), 0, type, 0, 0 }

#endif  // _BIND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dnary\simtable.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    SimTable.cpp
//
// SYNOPSIS
//
//    This file implements the class CSimpleTable
//
// MODIFICATION HISTORY
//
//    10/31/1997    Original version.
//    02/09/1998    Reorganized some things to make is easier to extend.
//    02/27/1998    Changes to support moving it into the iasutil.lib
//    10/16/1998    Support DBTYPE_WSTR.
//
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <comdef.h>
#include <iasutil.h>
#include <oledberr.h>
#include <SimTable.h>

//////////
// Stack version of the new operator.
//////////
#define stack_new(obj, num) new (_alloca(sizeof(obj)*num)) obj[num]


///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    DBBinding
//
// DESCRIPTION
//
//    This struct extends the DBBINDING struct to provide functionality
//    to initialize the struct from a DBCOLUMNINFO struct.
//
///////////////////////////////////////////////////////////////////////////////
struct DBBinding : DBBINDING
{
   //////////
   // 'offset' is the offset in bytes of this column's data within the
   //  row buffer.
   //////////
   void Initialize(DBCOLUMNINFO& columnInfo, DBBYTEOFFSET& offset)
   {
      iOrdinal   = columnInfo.iOrdinal;
      obValue    = offset;
      obLength   = offset + columnInfo.ulColumnSize;
      obStatus   = obLength + sizeof(DBLENGTH);
      pTypeInfo  = NULL;
      pObject    = NULL;
      pBindExt   = NULL;
      dwPart     = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
      eParamIO   = DBPARAMIO_NOTPARAM;
      dwMemOwner = (columnInfo.wType & DBTYPE_BYREF) ? DBMEMOWNER_PROVIDEROWNED
                                                     : DBMEMOWNER_CLIENTOWNED;
      cbMaxLen   = columnInfo.ulColumnSize;
      dwFlags    = 0;
      wType      = columnInfo.wType;
      bPrecision = columnInfo.bPrecision;
      bScale     = columnInfo.bScale;

      offset = obStatus + sizeof(DBSTATUS);
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::CSimpleTable
//
// DESCRIPTION
//
//    Constructor.
//
///////////////////////////////////////////////////////////////////////////////
CSimpleTable::CSimpleTable()
   : numColumns(0),
     columnInfo(NULL),
     stringsBuffer(NULL),
     columnBinding(NULL),
     readAccess(NULL),
     buffer(NULL),
     numRows(0),
     currentRow(0),
     endOfRowset(false)
{
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::~CSimpleTable
//
// DESCRIPTION
//
//    Destructor.
//
///////////////////////////////////////////////////////////////////////////////
CSimpleTable::~CSimpleTable()
{
   Detach();
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Attach
//
// DESCRIPTION
//
//    This method binds the table object to a new rowset. The previous rowset
//    (if any) will be detached.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::Attach(IRowset* pRowset)
{
   // Make sure we didn't get a null pointer.
   if (!pRowset) { return E_POINTER; }

   // Detach the current rowset.
   Detach();

   // We don't care if this returns an error. It will just prevent
   // the user from updating.
   pRowset->QueryInterface(IID_IRowsetChange, (void**)&rowsetChange);

   //////////
   // Get the column information for the table.
   //////////

   CComPtr<IColumnsInfo> ColumnsInfo;
   RETURN_ERROR(pRowset->QueryInterface(IID_IColumnsInfo,
                                        (void**)&ColumnsInfo));

   RETURN_ERROR(ColumnsInfo->GetColumnInfo(&numColumns,
                                           &columnInfo,
                                           &stringsBuffer));

   //////////
   // Allocate the per-column data.
   //////////

   try
   {
      columnBinding = new DBBinding[numColumns];

      dirty.resize(numColumns);
   }
   catch (std::bad_alloc)
   {
      return E_OUTOFMEMORY;
   }

   //////////
   // Create a binding for each column.
   //////////

   bufferLength = 0;

   for (DBORDINAL i = 0; i < numColumns; ++i)
   {
      // Compute the width of the column.
      DBLENGTH width = columnInfo[i].ulColumnSize;

      // Add room for the null terminator.
      if (columnInfo[i].wType == DBTYPE_STR)
      {
         width += 1;
      }
      else if (columnInfo[i].wType == DBTYPE_WSTR)
      {
         width = (width + 1) * sizeof(WCHAR);
      }

      // Round to an 8-byte boundary (could peek ahead and be more efficient).
      width = (width + 7) >> 3 << 3;

      columnInfo[i].ulColumnSize = width;

      // We're using the pTypeInfo element to store the offset to our data.
      // We have to store the offset now, since it will be overwritten by
      // DBBinding::Initialize.
      columnInfo[i].pTypeInfo = (ITypeInfo*)bufferLength;

      columnBinding[i].Initialize(columnInfo[i], bufferLength);
   }

   //////////
   // Allocate a buffer for the row data.
   //////////

   buffer = new (std::nothrow) BYTE[bufferLength];

   if (!buffer) { return E_OUTOFMEMORY; }

   //////////
   // Create an accessor.
   //////////

   RETURN_ERROR(pRowset->QueryInterface(IID_IAccessor,
                                        (void**)&accessor));

   RETURN_ERROR(accessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                         numColumns,
                                         columnBinding,
                                         bufferLength,
                                         &readAccess,
                                         NULL));

   // I used this hokey method of assigning the pointer to avoid a
   // dependency on atlimpl.cpp
   //
   // We do this assignment last, so that the presence of a rowset means the
   // entire initialization succeeded.
   (rowset.p = pRowset)->AddRef();

   endOfRowset = false;

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Detach
//
// DESCRIPTION
//
//    Frees all the resources associated with the current rowset.
//
///////////////////////////////////////////////////////////////////////////////
IRowset* CSimpleTable::Detach()
{
   ReleaseRows();

   delete[] buffer;
   buffer = NULL;

   delete[] columnBinding;
   columnBinding = NULL;

   CoTaskMemFree(columnInfo);
   columnInfo = NULL;

   CoTaskMemFree(stringsBuffer);
   stringsBuffer = NULL;

   accessor.Release();
   rowsetChange.Release();

   IRowset* temp = rowset;
   rowset.Release();
   return temp;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::MoveFirst
//
// DESCRIPTION
//
//    Positions the cursor over the first row in the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::MoveFirst()
{
   if (rowset == NULL) return E_FAIL;

   ReleaseRows();

   RETURN_ERROR(rowset->RestartPosition(NULL));

   endOfRowset = false;

   return MoveNext();
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::MoveNext
//
// DESCRIPTION
//
//    Positions the cursor over the next row in the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::MoveNext()
{
   // If the data wasn't opened successfully then fail
   if (rowset == NULL) return E_FAIL;

   // Too late to save any changes.
   DiscardChanges();

   // If we've used all the rows from the last fetch, then get some more.
   if (++currentRow >= numRows)
   {
      ReleaseRows();

      // We have to do this check here, since some providers automatically
      // reset to the beginning of the rowset.
      if (endOfRowset) { return DB_S_ENDOFROWSET; }

      HROW* pRow = row;
      HRESULT hr = rowset->GetNextRows(NULL,
                                       0,
                                       FETCH_QUANTUM,
                                       &numRows,
                                       &pRow);

      if (hr == DB_S_ENDOFROWSET)
      {
         // Mark that we've reached the end of the rowset.
         endOfRowset = true;

         // If we didn't get any rows, then we're really at the end.
         if (numRows == 0) { return DB_S_ENDOFROWSET; }
      }
      else if (FAILED(hr))
      {
         return hr;
      }
   }

   // Load the data into the buffer.
   RETURN_ERROR(rowset->GetData(row[currentRow], readAccess, buffer));

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Insert
//
// DESCRIPTION
//
//    Inserts the contents of the accessor buffer into the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::Insert()
{
   // Is a rowset attached?
   if (!rowset) { return E_FAIL; }

   // Does this rowset support changes?
   if (!rowsetChange) { return E_NOINTERFACE; }

   // Get an accessor for the dirty columns.
   HACCESSOR writeAccess;
   RETURN_ERROR(CreateAccessorForWrite(&writeAccess));

   // Release the existing rows to make room for the new one.
   ReleaseRows();

   HRESULT hr = rowsetChange->InsertRow(NULL, writeAccess, buffer, row);

   if (SUCCEEDED(hr))
   {
      // The changes were save successfully, so reset the dirty vector.
      DiscardChanges();

      // We now have exactly one row in our buffer.
      numRows = 1;
   }

   // Release the accessor.
   accessor->ReleaseAccessor(writeAccess, NULL);

   return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Delete
//
// DESCRIPTION
//
//    Deletes the current row from the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::Delete()
{
   // Are we positioned over a valid row?
   if (!rowset || currentRow >= numRows) { return E_FAIL; }

   // Does this rowset support changes?
   if (!rowsetChange) { return E_NOINTERFACE; }

   DBROWSTATUS rowStatus[1];

   return rowsetChange->DeleteRows(NULL, 1, row + currentRow, rowStatus);
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::SetData
//
// DESCRIPTION
//
//    Updates the current row with the data in the accessor buffer.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::SetData()
{
   // Are we positioned over a valid row?
   if (!rowset || currentRow >= numRows) { return E_FAIL; }

   // Does this rowset support changes?
   if (!rowsetChange) { return E_NOINTERFACE; }

   // Get an accessor for the dirty columns.
   HACCESSOR writeAccess;
   RETURN_ERROR(CreateAccessorForWrite(&writeAccess));

   HRESULT hr = rowsetChange->SetData(row[currentRow], writeAccess, buffer);

   if (SUCCEEDED(hr))
   {
      // The changes were save successfully, so reset the dirty vector.
      DiscardChanges();
   }

   // Release the accessor.
   accessor->ReleaseAccessor(writeAccess, NULL);

   return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::GetLength
//
// DESCRIPTION
//
//    Returns the length of the current value for a given column.
//
///////////////////////////////////////////////////////////////////////////////
DBLENGTH CSimpleTable::GetLength(DBORDINAL nOrdinal) const
{
   return *(DBLENGTH*)((BYTE*)_GetDataPtr(nOrdinal) +
                       columnInfo[OrdinalToColumn(nOrdinal)].ulColumnSize);
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::GetOrdinal
//
// DESCRIPTION
//
//    Returns the ordinal for a given column name.
//
///////////////////////////////////////////////////////////////////////////////
bool CSimpleTable::GetOrdinal(LPCWSTR szColumnName, DBORDINAL* pOrdinal) const
{
   for (DBORDINAL i = 0; i < numColumns; ++i)
   {
      if (lstrcmpW(columnInfo[i].pwszName, szColumnName) == 0)
      {
         *pOrdinal = columnInfo[i].iOrdinal;

         return true;
      }
   }

   return false;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::GetStatus
//
// DESCRIPTION
//
//    Returns the status code associated with the current value of a column.
//
///////////////////////////////////////////////////////////////////////////////
DBSTATUS CSimpleTable::GetStatus(DBORDINAL nOrdinal) const
{
   return *(DBSTATUS*)((BYTE*)_GetDataPtr(nOrdinal) +
                       columnInfo[OrdinalToColumn(nOrdinal)].ulColumnSize +
                       sizeof(DBLENGTH));
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::CreateAccessorForWrite
//
// DESCRIPTION
//
//    Creates an accessor that is only to bound to columns that have been
//    modified.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::CreateAccessorForWrite(HACCESSOR* phAccessor)
{
   //////////
   // Allocate temporary space for the bindings.
   //////////

   DBBINDING* writeBind = stack_new(DBBINDING, dirty.count());

   //////////
   // Load in all the dirty columns.
   //////////

   size_t total = 0;

   for (size_t i = 0; total < dirty.count(); ++i)
   {
      if (dirty.test(i))
      {
         // We only want to bind the value.
         (writeBind[total++] = columnBinding[i]).dwPart = DBPART_VALUE;
      }
   }

   //////////
   // Create the accessor.
   //////////

   return accessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                   dirty.count(),
                                   writeBind,
                                   bufferLength,
                                   phAccessor,
                                   NULL);
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::_GetDataPtr
//
// DESCRIPTION
//
//    Non-const version of _GetDataPtr. Marks the target column as dirty.
//
///////////////////////////////////////////////////////////////////////////////
void* CSimpleTable::_GetDataPtr(DBORDINAL nOrdinal)
{
   DBORDINAL nColumn = OrdinalToColumn(nOrdinal);

   dirty.set(nColumn);

   return buffer + (ULONG_PTR)columnInfo[nColumn].pTypeInfo;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::ReleaseRows
//
// DESCRIPTION
//
//    Releases all the rows returned by the last fetch.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::ReleaseRows()
{
   if (rowset != NULL)
   {
      HRESULT hr = rowset->ReleaseRows(numRows, row, NULL, NULL, NULL);

      currentRow = numRows = 0;

      return hr;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\cmdbase.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    cmdbase.h
//
// SYNOPSIS
//
//    This file declares the class CommandBase.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    02/15/1999    Make commands MT safe.
//    02/19/1999    Move definition of CommandBase::Execute to propcmd.cpp
//    05/30/2000    Add trace support.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _CMDBASE_H_
#define _CMDBASE_H_

#include <bind.h>
#include <guard.h>
#include <nocopy.h>
#include <oledb.h>

void CheckOleDBError(PCSTR functionName, HRESULT errorCode);

//////////
// The maximum length of a stringized LONG.
//////////
const size_t SZLONG_LENGTH = 12;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CommandBase
//
// DESCRIPTION
//
//    This class provides serves as an abstract base class for paremeterized,
//    prepared, text SQL commands.
//
///////////////////////////////////////////////////////////////////////////////
class CommandBase : NonCopyable, protected Guardable
{
public:

   CommandBase() throw ();
   virtual ~CommandBase() throw ();

   void initialize(IUnknown* session);
   void finalize() throw ();

protected:

   // Executes the command.
   void execute(REFIID refiid = IID_NULL, IUnknown** result = NULL);

   // Releases an accessor associated with this command.
   void releaseAccessor(HACCESSOR h) throw ()
   {
      Bind::releaseAccessor(command, h);
   }

   // Sets and prepares the command text.
   void setCommandText(PCWSTR commandText);

   // Sets the parameter data buffer.
   void setParameterData(PVOID data) throw ()
   {
      dbParams.pData = data;
   }

   // Sets the parameter accessor for the command.
   void setParamIO(HACCESSOR accessor) throw ()
   {
      dbParams.cParamSets = 1;

      dbParams.hAccessor = accessor;
   }

   // Associates a session with the command. This triggers the actual creation
   // of the underlying OLE-DB command object.
   void setSession(IUnknown* session);

   // Defined in the sub-class to create a parameter accessor.
   virtual HACCESSOR createParamIO(IUnknown* session) const = 0;

   // Defined in the sub-class to return the SQL text.
   virtual PCWSTR getCommandText() const throw () = 0;

   CComPtr<ICommandText> command;  // The OLE-DB command object.
   DBPARAMS dbParams;              // Parameter data.
};

#endif  // _CMDBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\cmdbase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    cmdbase.cpp
//
// SYNOPSIS
//
//    This file defines the class CommandBase.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    02/15/1999    Make commands MT safe.
//    05/30/2000    Add trace support.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasdb.h>
#include <cmdbase.h>

CommandBase::CommandBase() throw ()
{
   dbParams.pData = NULL;
   dbParams.cParamSets = 0;
   dbParams.hAccessor = 0;
}

CommandBase::~CommandBase() throw ()
{
   finalize();
}

void CommandBase::initialize(IUnknown* session)
{
    setSession(session);

    setCommandText(getCommandText());

    setParamIO(createParamIO(command));

    setParameterData(this);
}

void CommandBase::finalize() throw ()
{
   releaseAccessor(dbParams.hAccessor);

   command.Release();
}

void CommandBase::setCommandText(PCWSTR commandText)
{
   CheckOleDBError(
       "ICommandText::SetCommandText",
       command->SetCommandText(DBGUID_DBSQL, commandText)
       );

   CComPtr<ICommandPrepare> prepare;
   _com_util::CheckError(
                   command->QueryInterface(
                                __uuidof(ICommandPrepare),
                                (PVOID*)&prepare
                                )
                   );

   CheckOleDBError(
       "ICommandPrepare::Prepare",
       prepare->Prepare(0)
       );
}

void CommandBase::setSession(IUnknown* session)
{
   CComPtr<IDBCreateCommand> creator;
   _com_util::CheckError(
                   session->QueryInterface(
                                __uuidof(IDBCreateCommand),
                                (PVOID*)&creator
                                )
                   );

   CheckOleDBError(
       "IDBCreateCommand::CreateCommand",
       creator->CreateCommand(
                    NULL,
                    __uuidof(ICommandText),
                    (IUnknown**)&command
                    )
       );
}

void CheckOleDBError(PCSTR functionName, HRESULT errorCode)
{
   if (FAILED(errorCode))
   {
      _com_issue_error(IASTraceJetError(functionName, errorCode));
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\dsenum.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsenum.h
//
// SYNOPSIS
//
//    This file declares the class DBEnumerator.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DSENUM_H_
#define _DSENUM_H_

#include <dsobject.h>
#include <objcmd.h>
#include <oledbstore.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DBEnumerator
//
// DESCRIPTION
//
//    This class implements IEnumVARIANT for a rowset of objects.
//
///////////////////////////////////////////////////////////////////////////////
class DBEnumerator : public IEnumVARIANT
{
public:

   DBEnumerator(DBObject* container, IRowset* members);
   ~DBEnumerator() { Bind::releaseAccessor(items, readAccess); }

//////////
// IUnknown
//////////
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();
   STDMETHOD(QueryInterface)(const IID& iid, void** ppv);

//////////
// IEnumVARIANT
//////////
   STDMETHOD(Next)(/*[in]*/ ULONG celt,
                   /*[length_is][size_is][out]*/ VARIANT* rgVar,
                   /*[out]*/ ULONG* pCeltFetched);
   STDMETHOD(Skip)(/*[in]*/ ULONG celt);
   STDMETHOD(Reset)();
   STDMETHOD(Clone)(/*[out]*/ IEnumVARIANT** ppEnum);

protected:
   LONG refCount;                  // Interface ref count.
   CComPtr<DBObject> parent;       // The container being enumerated.
   Rowset items;                   // Items in the container.
   HACCESSOR readAccess;           // Accessor for reading rows.
   ULONG identity;                 // Identity buffer.
   WCHAR name[OBJECT_NAME_LENGTH]; // Name buffer.

BEGIN_BIND_MAP(DBEnumerator, ReadAccessor, DBACCESSOR_ROWDATA)
   BIND_COLUMN(identity, 1, DBTYPE_I4),
   BIND_COLUMN(name,     2, DBTYPE_WSTR)
END_BIND_MAP()
};

#endif  // _DSENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\dsobject.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsobject.h
//
// SYNOPSIS
//
//    This file declares the class DBObject.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    10/02/1998    Allow rename through PutValue.
//    04/13/2000    Port to ATL 3.0
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DSOBJECT_H_
#define _DSOBJECT_H_

#include <dsproperty.h>
#include <dstorex.h>
#include <propbag.h>

//////////
// 'Secret' UUID used to cast an interface to the implementing DBObject.
//////////
class __declspec(uuid("7677647C-AA27-11D1-BB27-00C04FC2E20D")) DBObject;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DBObject
//
// DESCRIPTION
//
//    This class implements an object in an OLE-DB database.  All objects
//    are also containers.
//
///////////////////////////////////////////////////////////////////////////////
class DBObject
   : public CComObjectRootEx< CComMultiThreadModel >,
     public IDispatchImpl< IDataStoreObjectEx,
                           &__uuidof(IDataStoreObject),
                           &__uuidof(DataStore2Lib) >,
     public IDispatchImpl< IDataStoreContainerEx,
                           &__uuidof(IDataStoreContainer),
                           &__uuidof(DataStore2Lib) >
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(DBObject)
   COM_INTERFACE_ENTRY_IID(__uuidof(DBObject), DBObject)
   COM_INTERFACE_ENTRY_IID(__uuidof(IDataStoreObject), IDataStoreObject)
   COM_INTERFACE_ENTRY_IID(__uuidof(IDataStoreContainer), IDataStoreContainer)
   COM_INTERFACE_ENTRY2(IDispatch, IDataStoreObject)
END_COM_MAP()

   // Create a new DBObject
   static DBObject* createInstance(
                        OleDBDataStore* owner,
                        IDataStoreContainer* container,
                        ULONG uniqueID,
                        PCWSTR relativeName
                        );

   // Create a child DBObject.
   IDataStoreObject* spawn(ULONG childID, BSTR childName);

//////////
// IDataStoreObject
//////////
   STDMETHOD(get_Name)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Class)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_GUID)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Container)(/*[out, retval]*/ IDataStoreContainer** pVal);      
   STDMETHOD(GetValue)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(GetValueEx)(/*[in]*/ BSTR bstrName,
                         /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(PutValue)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT* pVal);
   STDMETHOD(Update)();
   STDMETHOD(Restore)();
   STDMETHOD(Item)(BSTR bstrName, IDataStoreProperty** pVal);

//////////
// IDataStoreObjectEx
//////////
   STDMETHOD(get_PropertyCount)(long* pVal);
   STDMETHOD(get_NewPropertyEnum)(IUnknown** pVal);

//////////
// IDataStoreContainer
//////////
   STDMETHOD(Item)(/*[in]*/ BSTR bstrName,
                   /*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(Create)(/*[in]*/ BSTR bstrClass,
                     /*[in]*/ BSTR bstrName,
                     /*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(MoveHere)(/*[in]*/ IDataStoreObject* pObject,
                       /*[in]*/ BSTR bstrNewName);
   STDMETHOD(Remove)(/*[in]*/ BSTR bstrClass, /*[in]*/ BSTR bstrName);

//////////
// IDataStoreContainerEx
//////////
   STDMETHOD(get_ChildCount)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_NewChildEnum)(/*[out, retval]*/ IUnknown** pVal);

protected:
   // Initialize a newly allocated DBObject. Used by createInstance.
   void initialize(
            OleDBDataStore* owner,
            IDataStoreContainer* container,
            ULONG uniqueID,
            PCWSTR relativeName
            );

   // Narrows a COM Interface to the implementing DBObject.
   static DBObject* narrow(IUnknown* p);

   CComPtr<OleDBDataStore> store;       // DataStore where this object lives.
   CComPtr<IDataStoreContainer> parent; // Parent container.
   ULONG identity;                      // Unique identity.
   _bstr_t name;                        // Relative name of this object.
   bool nameDirty;                      // true if the object has been renamed.
   PropertyBag properties;              // Bag of associated properties.
};

#endif  // _DSOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\dsenum.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsenum.cpp
//
// SYNOPSIS
//
//    This file defines the class DBEnumerator.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    04/15/1998    Initialize refCount to zero in constructor.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <dsenum.h>

DBEnumerator::DBEnumerator(DBObject* container, IRowset* members)
   : refCount(0),
     parent(container),
     items(members),
     readAccess(createReadAccessor(members))
{ }

STDMETHODIMP_(ULONG) DBEnumerator::AddRef()
{
   return InterlockedIncrement(&refCount);
}

STDMETHODIMP_(ULONG) DBEnumerator::Release()
{
   LONG l = InterlockedDecrement(&refCount);

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP DBEnumerator::QueryInterface(const IID& iid, void** ppv)
{
   if (iid == __uuidof(IUnknown))
   {
      *ppv = static_cast<IUnknown*>(this);
   }
   else if (iid == __uuidof(IEnumVARIANT))
   {
      *ppv = static_cast<IEnumVARIANT*>(this);
   }
   else
   {
      return E_NOINTERFACE;
   }

   InterlockedIncrement(&refCount);

   return S_OK;
}

STDMETHODIMP DBEnumerator::Next(ULONG celt,
                                VARIANT* rgVar,
                                ULONG* pCeltFetched)
{

   if (rgVar == NULL) { return E_INVALIDARG; }

   ////////// 
   // Initialize the out parameters.
   ////////// 

   if (pCeltFetched != NULL) { *pCeltFetched = celt; }

   for (ULONG i=0; i<celt; ++i) { VariantInit(rgVar + i); }

   try
   {
      ////////// 
      // Move through the items at most 'celt' times.
      ////////// 

      while (celt && items.moveNext())
      {
         // Get the row data.
         items.getData(readAccess, this);

         // Never return the root from an enumerator.
         if (identity == 1) { continue; }

         // Create an object.
         V_DISPATCH(rgVar) = parent->spawn(identity, name);
         V_VT(rgVar) = VT_DISPATCH;

         // Update the state.
         --celt;
         ++rgVar;
      }
   }
   catch (...)
   { }

   // Subtract off any elements that weren't fetched.
   if (pCeltFetched) { *pCeltFetched -= celt; }

   return celt ? S_FALSE : S_OK;
}

STDMETHODIMP DBEnumerator::Skip(ULONG celt)
{
   try
   {
      while (celt && items.moveNext()) { --celt; }
   }
   CATCH_AND_RETURN()

   return celt ? S_FALSE : S_OK;
}

STDMETHODIMP DBEnumerator::Reset()
{
   try
   {
      items.reset();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBEnumerator::Clone(IEnumVARIANT** ppEnum)
{
   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\dstorex.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dstorex.h
//
// SYNOPSIS
//
//    Defines the classes IDataStoreObjectEx and IDataStoreContainerEx.
//
// MODIFICATION HISTORY
//
//    03/02/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DSTOREX_H
#define _DSTOREX_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <datastore2.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IDataStoreObjectEx
//
// DESCRIPTION
//
//    This class extends IDataStoreObject in order to map the collection
//    related properties to alternate names. This allows a sub-class to
//    implement both IDataStoreObject and IDataStoreContainer without name
//    collisions.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(novtable) IDataStoreObjectEx
   : public IDataStoreObject
{
public:

//////////
// IDataStoreObject members that are mapped to new names.
//////////

   STDMETHOD(get_Count)(long* pVal)
   {
      return get_PropertyCount(pVal);
   }

   STDMETHOD(get__NewEnum)(IUnknown** pVal)
   {
      return get_NewPropertyEnum(pVal);
   }

//////////
// Versions that are overriden in the derived class.
//////////

   STDMETHOD(get_PropertyCount)(long* pVal)
   {
      return E_NOTIMPL;
   }

   STDMETHOD(get_NewPropertyEnum)(IUnknown** pVal)
   {
      return E_NOTIMPL;
   }

   STDMETHOD(Item)(BSTR bstrName, IDataStoreProperty** pVal)
   {
      return E_NOTIMPL;
   }

};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IDataStoreContainerEx
//
// DESCRIPTION
//
//    This class extends IDataStoreContainer in order to map the collection
//    related properties to alternate names. This allows a sub-class to
//    implement both IDataStoreObject and IDataStoreContainer without name
//    collisions.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(novtable) IDataStoreContainerEx
   : public IDataStoreContainer
{
public:

//////////
// IDataStoreContainer members that are mapped to new names.
//////////

   STDMETHOD(get_Count)(long* pVal)
   {
      return get_ChildCount(pVal);
   }

   STDMETHOD(get__NewEnum)(IUnknown** pVal)
   {
      return get_NewChildEnum(pVal);
   }

//////////
// Alternate versions that are overriden in the derived class.
//////////

   STDMETHOD(get_ChildCount)(long* pVal)
   {
      return E_NOTIMPL;
   }

   STDMETHOD(get_NewChildEnum)(IUnknown** pVal)
   {
      return E_NOTIMPL;
   }

   STDMETHOD(Item)(BSTR bstrName, IDataStoreObject** pVal)
   {
      return E_NOTIMPL;
   }

};

#endif  // _DSTOREX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\dsproperty.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsproperty.h
//
// SYNOPSIS
//
//    This file defines the class DSProperty.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//    04/13/2000    Port to ATL 3.0
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <dsproperty.h>
#include <varvec.h>
#include <memory>

DSProperty* DSProperty::createInstance(
                            const _bstr_t& propName,
                            const _variant_t& propValue,
                            IDataStoreObject* memberOf
                            )
{
   // Create a new CComObject.
   CComObject<DSProperty>* newObj;
   _com_util::CheckError(CComObject<DSProperty>::CreateInstance(&newObj));

   // Cast to a DBObject and store it in an auto_ptr in case we throw an
   // exception.
   std::auto_ptr<DSProperty> prop(newObj);

   // Set the members.
   prop->name = propName;
   prop->value = propValue;
   prop->owner = memberOf;

   // Release and return.
   return prop.release();
}

STDMETHODIMP DSProperty::get_Name(BSTR* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }
   *pVal = SysAllocString(name);
   return *pVal ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP DSProperty::get_Value(VARIANT* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }
   return VariantCopy(pVal, &value);
}

STDMETHODIMP DSProperty::get_ValueEx(VARIANT* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   // Is the value an array ?
   if (V_VT(&value) != (VT_VARIANT | VT_ARRAY))
   {
      // No, so we have to convert it to one.

      try
      {
         // Make sure we can sucessfully copy the VARIANT, ...
         _variant_t tmp(value);

         // ... then allocate a SAFEARRAY with a single element.
         CVariantVector<VARIANT> multi(pVal, 1);

         // Load the single value in.
         multi[0] = tmp.Detach();
      }
      CATCH_AND_RETURN()

      return S_OK;
   }

   return VariantCopy(pVal, &value);
}

STDMETHODIMP DSProperty::get_Owner(IDataStoreObject** pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }
   if (*pVal = owner) { (*pVal)->AddRef(); }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\dsobject.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 - 2000 , Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsobject.cpp
//
// SYNOPSIS
//
//    This file defines the class DBObject.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    10/02/1998    Allow rename through PutValue.
//    04/13/2000    Port to ATL 3.0
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>

#include <dsenum.h>
#include <dsobject.h>
#include <localtxn.h>
#include <oledbstore.h>

#include <guard.h>
#include <varvec.h>
#include <memory>

//////////
//  ATL implementation of IEnumVARIANT
//////////
typedef CComEnum< IEnumVARIANT,
                  &__uuidof(IEnumVARIANT),
                  VARIANT,
                  _Copy<VARIANT>,
                  CComMultiThreadModelNoCS
                > EnumVARIANT;

//////////
// Test if a property is the special 'name' property.
//////////
inline bool isNameProperty(PCWSTR p) throw ()
{
   return (*p == L'N' || *p == L'n') ? !_wcsicmp(p, L"NAME") : false;
}

//////////
// Macro to acquire a scoped lock on the global data store.
//////////
#define LOCK_STORE() \
Guard< CComObjectRootEx< CComMultiThreadModel > >__GUARD__(*store)

//////////
// Macros to begin and commit transactions on the global session.
//////////
#define BEGIN_WRITE_TXN() \
LOCK_STORE(); \
LocalTransaction __TXN__(store->session)

#define COMMIT_WRITE_TXN() \
__TXN__.commit()

DBObject* DBObject::createInstance(
                        OleDBDataStore* owner,
                        IDataStoreContainer* container,
                        ULONG uniqueID,
                        PCWSTR relativeName
                        )
{
   // Create a new CComObject.
   CComObject<DBObject>* newObj;
   _com_util::CheckError(CComObject<DBObject>::CreateInstance(&newObj));

   // Cast to a DBObject and store it in an auto_ptr in case initialize throws
   // an exception.
   std::auto_ptr<DBObject> obj(newObj);

   // Initialize the object.
   obj->initialize(owner, container, uniqueID, relativeName);

   // Release and return.
   return obj.release();
}

IDataStoreObject* DBObject::spawn(ULONG childID, BSTR childName)
{
   DBObject* child = DBObject::createInstance(store, this, childID, childName);

   child->InternalAddRef();

   return child;
}

STDMETHODIMP DBObject::get_Name(BSTR* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   return (*pVal = SysAllocString(name)) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP DBObject::get_Class(BSTR* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   return (*pVal = SysAllocString(L"OLE-DB Object")) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP DBObject::get_GUID(BSTR* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   WCHAR sz[SZLONG_LENGTH];

   _ultow(identity, sz, 10);

   return (*pVal = SysAllocString(sz)) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP DBObject::get_Container(IDataStoreContainer** pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   if (*pVal = parent) { (*pVal)->AddRef(); }

   return S_OK;
}

STDMETHODIMP DBObject::GetValue(BSTR bstrName, VARIANT* pVal)
{
   if (bstrName == NULL || pVal == NULL) { return E_INVALIDARG; }

   VariantInit(pVal);

   if (isNameProperty(bstrName))
   {
      V_BSTR(pVal) = SysAllocString(name);

      return (V_BSTR(pVal)) ? (V_VT(pVal) = VT_BSTR), S_OK : E_OUTOFMEMORY;
   }

   HRESULT hr;

   try
   {
      hr = properties.getValue(bstrName, pVal) ? S_OK : DISP_E_MEMBERNOTFOUND;
   }
   CATCH_AND_RETURN()

   return hr;
}

STDMETHODIMP DBObject::GetValueEx(BSTR bstrName, VARIANT* pVal)
{
   RETURN_ERROR(GetValue(bstrName, pVal));

   // Is it an array ?
   if (V_VT(pVal) != (VT_VARIANT | VT_ARRAY))
   {
      // No, so we have to convert it to one.

      try
      {
         // Save the single value.
         _variant_t single(*pVal, false);

         // Create a SAFEARRAY with a single element.
         CVariantVector<VARIANT> multi(pVal, 1);

         // Load the single value in.
         multi[0] = single.Detach();
      }
      CATCH_AND_RETURN()
   }

   return S_OK;
}

STDMETHODIMP DBObject::PutValue(BSTR bstrName, VARIANT* pVal)
{
   if (bstrName == NULL || pVal == NULL) { return E_INVALIDARG; }

   try
   {
      if (isNameProperty(bstrName))
      {
         // 'name' property must be a BSTR.
         if (V_VT(pVal) != VT_BSTR) { return DISP_E_TYPEMISMATCH; }

         // 'name' property must be non-null.
         if (V_BSTR(pVal) == NULL)  { return E_INVALIDARG; }

         // Did it actually change?
         if (wcscmp(name, V_BSTR(pVal)) != 0)
         {
            // Yes, so save the new value ...
            name = V_BSTR(pVal);
            // ... and set the dirty flag.
            nameDirty = true;
         }
      }
      else if (V_VT(pVal) != VT_EMPTY)
      {
         properties.updateValue(bstrName, pVal);
      }
      else
      {
         // If the variant is empty, just erase the property.
         properties.erase(bstrName);
      }
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::Update()
{
   try
   {
      BEGIN_WRITE_TXN();

      // maybe someone created that same object before the update is called
      // (concurent MMC scenario)
      DBObject* owner = narrow(parent);
      if (identity == 0)
      {
         identity = store->find.execute(owner->identity, name);
      }

      if (identity == 0)
      {
         // If we're newly created, then we have to update our record in
         // the Objects table.

         // An object always has an owner.
         _ASSERT(owner != NULL);

         store->create.execute(owner->identity, name);

         identity = store->find.execute(owner->identity, name);

         // This should never happen since the create succeeded.
         _ASSERT(identity != 0);
      }
      else if (nameDirty)
      {
         store->update.execute(identity, name, narrow(parent)->identity);
      }

      // Reset the dirty flag.
      nameDirty = false;

      store->erase.execute(identity);

      store->set.execute(identity, properties);

      COMMIT_WRITE_TXN();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::Restore()
{
   try
   {
      properties.clear();

      LOCK_STORE();

      store->get.execute(identity, properties);
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::Item(BSTR bstrName, IDataStoreProperty** pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   *pVal = NULL;

   _variant_t v;

   RETURN_ERROR(GetValue(bstrName, &v));

   try
   {
      // Create a new property object.
      (*pVal = DSProperty::createInstance(bstrName, v, this))->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::get_PropertyCount(long* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   // Add one for the special 'name' property.
   *pVal = properties.size() + 1;

   return S_OK;
}

STDMETHODIMP DBObject::get_NewPropertyEnum(IUnknown** pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   *pVal = NULL;

   try
   {
      // Create a temporary array of items.
      std::vector<_variant_t> items(properties.size() + 1);

      //////////
      // Load the special 'name' property.
      //////////

      std::vector<_variant_t>::iterator i = items.begin();

      *i = DSProperty::createInstance(L"name", name, this);

      ++i;

      //////////
      // Load the regular properties into the temporary array.
      //////////

      PropertyBag::const_iterator j = properties.begin();

      for ( ; j != properties.end(); ++i, ++j)
      {
         _variant_t value;

         j->second.get(&value);

         *i = DSProperty::createInstance(j->first, value, this);
      }

      //////////
      // Create and initialize an enumerator for the items.
      //////////

      CComPtr<EnumVARIANT> newEnum(new CComObject<EnumVARIANT>);

      _com_util::CheckError(newEnum->Init(items.begin(),
                                          items.end(),
                                          NULL,
                                          AtlFlagCopy));

      // Return it to the caller.
      (*pVal = newEnum)->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::Item(BSTR bstrName, IDataStoreObject** ppObject)
{
   if (bstrName == NULL || ppObject == NULL) { return E_INVALIDARG; }

   *ppObject = NULL;

   try
   {
      LOCK_STORE();

      ULONG childID = store->find.execute(identity, bstrName);

      if (childID == 0) { return HRESULT_FROM_WIN32(ERROR_NOT_FOUND); }

      *ppObject = spawn(childID, bstrName);

   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::Create(BSTR /* bstrClass */,
                              BSTR bstrName,
                              IDataStoreObject** ppObject)
{
   if (bstrName == NULL || ppObject == NULL) { return E_INVALIDARG; }

   *ppObject = NULL;

   try
   {
      *ppObject = spawn(0, bstrName);
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::MoveHere(IDataStoreObject* pObject,
                                BSTR bstrNewName)
{
   if (pObject == NULL) { return E_INVALIDARG; }

   try
   {
      // Convert the subject to a DBObject.
      DBObject* object = narrow(pObject);

      // Can't do this unless the object has been persisted.
      if (object->identity == 0) { return E_FAIL; }

      // Compute the (possibly changed) RDN of the object.
      PCWSTR rdn = bstrNewName ? bstrNewName : object->name;

      // Write the new parent ID and possibly name to the database.
      BEGIN_WRITE_TXN();
         store->update.execute(object->identity, rdn, identity);
      COMMIT_WRITE_TXN();

      // It succeeded, so save the new name if necessary ...
      if (bstrNewName) { object->name = bstrNewName; }

      // ... and switch the parent pointer.
      object->parent.Release();
      object->parent = this;
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::Remove(BSTR /* bstrClass */, BSTR bstrName)
{
   if (bstrName == NULL) { return E_INVALIDARG; }

   try
   {
      BEGIN_WRITE_TXN();
         store->destroy.execute(identity, bstrName);
      COMMIT_WRITE_TXN();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::get_ChildCount(long *pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   try
   {
      Rowset rowset;

      LOCK_STORE();

      store->members.execute(identity, &rowset);

      long count = 0;

      while (rowset.moveNext()) { ++count; }

      // If this is the root, we have to subtract one since the root is a
      // child of itself.
      if (identity == 1) { --count; }

      *pVal = count;
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DBObject::get_NewChildEnum(IUnknown** pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   try
   {
      Rowset rowset;

      LOCK_STORE();

      store->members.execute(identity, &rowset);

      (*pVal = new DBEnumerator(this, rowset))->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

void DBObject::initialize(
                   OleDBDataStore* owner,
                   IDataStoreContainer* container,
                   ULONG uniqueID,
                   PCWSTR relativeName
                   )
{
   // Set the class members.
   store = owner;
   parent = container;
   identity = uniqueID;
   name = relativeName;
   nameDirty = false;

   // If this object exists in the persistent store, then get its properties.
   if (identity != 0)
   {
      LOCK_STORE();

      store->get.execute(identity, properties);
   }
}

DBObject* DBObject::narrow(IUnknown* p)
{
   DBObject* object;

   using _com_util::CheckError;

   CheckError(p->QueryInterface(__uuidof(DBObject), (PVOID*)&object));

   // We can get away with InternalRelease since the caller must still
   // have a reference to this object.
   object->InternalRelease();

   return object;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\dsproperty.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsproperty.h
//
// SYNOPSIS
//
//    This file declares the class DSProperty.
//
// MODIFICATION HISTORY
//
//    03/02/1998    Original version.
//    04/13/2000    Port to ATL 3.0
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DSPROPERTY_H_
#define _DSPROPERTY_H_

#include <datastore2.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DSProperty
//
// DESCRIPTION
//
//    This class implements the IDataStoreProperty interface. It represents
//    a single property of an IDataStoreObject.
//
///////////////////////////////////////////////////////////////////////////////
class DSProperty : 
   public CComObjectRootEx< CComMultiThreadModelNoCS >,
   public IDispatchImpl<
              IDataStoreProperty,
              &__uuidof(IDataStoreProperty),
              &__uuidof(DataStore2Lib)
              >
{
public:

BEGIN_COM_MAP(DSProperty)
   COM_INTERFACE_ENTRY_IID(__uuidof(IDataStoreProperty), IDataStoreProperty)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

   // Create a new DSProperty object.
   static DSProperty* createInstance(
                          const _bstr_t& propName,
                          const _variant_t& propValue,
                          IDataStoreObject* memberOf
                          );

//////////
// IDataStoreProperty
//////////
   STDMETHOD(get_Name)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Value)(/*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(get_ValueEx)(/*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(get_Owner)(/*[out, retval]*/ IDataStoreObject** pVal);

protected:
   _bstr_t name;                     // Property name.
   _variant_t value;                 // Property value.
   CComPtr<IDataStoreObject> owner;  // Object to which this property belongs.
};

#endif  // _DSPROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\localtxn.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    localtxn.h
//
// SYNOPSIS
//
//    This file declares the class LocalTransaction.
//
// MODIFICATION HISTORY
//
//    03/14/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _LOCALTXN_H_
#define _LOCALTXN_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <nocopy.h>
#include <oledb.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    LocalTransaction
//
// DESCRIPTION
//
//    This class creates a scoped transaction on an OLE-DB session. If the
//    transaction is not committed before the object goes out of scope, it
//    will be aborted.
//
///////////////////////////////////////////////////////////////////////////////
class LocalTransaction
   : NonCopyable
{
public:
   explicit LocalTransaction(IUnknown* session,
                             ISOLEVEL isoLevel = ISOLATIONLEVEL_READCOMMITTED)
   {
      using _com_util::CheckError;

      CheckError(session->QueryInterface(__uuidof(ITransactionLocal),
                                         (PVOID*)&txn));

      CheckError(txn->StartTransaction(isoLevel, 0, NULL, NULL));
   }

   ~LocalTransaction() throw ()
   {
      if (txn != NULL)
      {
         txn->Abort(NULL, FALSE, FALSE);
      }
   }

   void commit()
   {
      _com_util::CheckError(txn->Commit(FALSE, XACTTC_SYNC, 0));

      txn.Release();
   }

protected:
   CComPtr<ITransactionLocal> txn;
};


#endif  // _LOCALTXN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\objcmd.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    objcmd.h
//
// SYNOPSIS
//
//    This file defines commands for manipulating the Objects table.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    04/03/1998    Bind integers as DBTYPE_I4.
//                  Add PARAMETERS clause to all commands.
//    02/15/1999    Make commands MT safe.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _OBJCMD_H_
#define _OBJCMD_H_

#include <cmdbase.h>
#include <rowset.h>

//////////
// The width of the Name column including null-terminator (i.e., the Jet
// column size + 1).
//////////
const size_t OBJECT_NAME_LENGTH = 256;

//////////
// Command to find all the members of a container.
//////////
class FindMembers : public CommandBase
{
public:
   void execute(ULONG parentKey, IRowset** members)
   {
      _serialize

      parent = parentKey;

      CommandBase::execute(__uuidof(IRowset), (IUnknown**)members);
   }

   PCWSTR getCommandText() const throw ()
   {
      return L"PARAMETERS X LONG;"
             L"SELECT Identity, Name FROM Objects WHERE Parent = X;";
   }

protected:
   ULONG parent;

BEGIN_BIND_MAP(FindMembers, ParamIO, DBACCESSOR_PARAMETERDATA)
   BIND_COLUMN(parent, 1, DBTYPE_I4),
END_BIND_MAP()
};


//////////
// Base class for commands that key off the parent and the name. This is
// similar to the "one level" scope in LDAP.
//////////
class OneLevel : public CommandBase
{
public:
   void execute(ULONG parentKey, PCWSTR nameKey)
   {
      _serialize

      parent = parentKey;

      wcsncpy(name, nameKey, sizeof(name)/sizeof(WCHAR));

      CommandBase::execute();
   }

protected:
   ULONG parent;
   WCHAR name[OBJECT_NAME_LENGTH];

BEGIN_BIND_MAP(OneLevel, ParamIO, DBACCESSOR_PARAMETERDATA)
   BIND_COLUMN(parent, 1, DBTYPE_I4),
   BIND_COLUMN(name,   2, DBTYPE_WSTR)
END_BIND_MAP()
};


//////////
// Creates a new object in a container.
//////////
class CreateObject : public OneLevel
{
public:
   PCWSTR getCommandText() const throw ()
   {
      return L"PARAMETERS X LONG, Y TEXT;"
             L"INSERT INTO Objects (Parent, Name) VALUES (X, Y);";
   }
};


//////////
// Destroys an object in a container.
//////////
class DestroyObject : public OneLevel
{
public:
   PCWSTR getCommandText() const throw ()
   {
      return L"PARAMETERS X LONG, Y TEXT;"
             L"DELETE FROM Objects WHERE Parent = X AND Name = Y;";
   }
};


//////////
// Finds an object in a container and returns its identity.
//////////
class FindObject : public OneLevel
{
public:
   ~FindObject()
   {
      finalize();
   }

   ULONG execute(ULONG parentKey, PCWSTR nameKey)
   {
      _serialize

      // Load the parameters.
      parent = parentKey;
      wcsncpy(name, nameKey, sizeof(name)/sizeof(WCHAR));

      // Execute the command and get the answer set.
      Rowset rowset;
      CommandBase::execute(__uuidof(IRowset), (IUnknown**)&rowset);

      // Did we get anything?
      if (rowset.moveNext())
      {
         // Yes, so load the identity.
         rowset.getData(readAccess, this);

         // We should retrieved at most one record.
         _ASSERT(!rowset.moveNext());

         return identity;
      }

      // Zero represents 'not found'. I didn't want to throw an exception,
      // since this isn't very exceptional.
      return 0;
   }

   PCWSTR getCommandText() const throw ()
   {
      return L"PARAMETERS X LONG, Y TEXT;"
             L"SELECT Identity FROM Objects WHERE Parent = X AND Name = Y;";
   }

   void initialize(IUnknown* session)
   {
      OneLevel::initialize(session);

      readAccess = createReadAccessor(command);
   }

   void finalize() throw ()
   {
      releaseAccessor(readAccess);

      OneLevel::finalize();
   }

protected:
   HACCESSOR readAccess;
   ULONG identity;

BEGIN_BIND_MAP(FindObject, ReadAccessor, DBACCESSOR_ROWDATA)
   BIND_COLUMN(identity, 1, DBTYPE_I4),
END_BIND_MAP()
};


//////////
// Updates the Name and Parent of an object.
//////////
class UpdateObject : public CommandBase
{
public:
   void execute(ULONG identityKey, PCWSTR nameValue, ULONG parentValue)
   {
      _serialize

      parent = parentValue;

      wcsncpy(name, nameValue, sizeof(name)/sizeof(WCHAR));

      identity = identityKey;

      CommandBase::execute();
   }

   PCWSTR getCommandText() const throw ()
   {
      return L"PARAMETERS X LONG, Y TEXT, Z LONG;"
             L"UPDATE Objects SET Parent = X, Name = Y WHERE Identity = Z;";
   }

protected:
   ULONG parent;
   WCHAR name[OBJECT_NAME_LENGTH];
   ULONG identity;

BEGIN_BIND_MAP(UpdateObject, ParamIO, DBACCESSOR_PARAMETERDATA)
   BIND_COLUMN(parent,   1, DBTYPE_I4),
   BIND_COLUMN(name,     2, DBTYPE_WSTR),
   BIND_COLUMN(identity, 3, DBTYPE_I4)
END_BIND_MAP()
};

#endif  // _OBJCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\oledbstore.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    oledbstore.cpp
//
// SYNOPSIS
//
//    This file defines the class OleDBDataStore.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    03/17/1999    Create TMP dir before calling IDBInitialize::Initialize.
//    05/05/1999    Disable row-level locking.
//    05/25/1999    Check version when connecting.
//    01/25/2000    Increase MAX_VERSION to 1.
//    05/30/2000    Convert to iasdb API.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasdb.h>
#include <iasutil.h>

#include <dsobject.h>
#include <oledbstore.h>
#include <propset.h>

#include <msjetoledb.h>
#include <oledberr.h>

//////////
// Current versions supported.
//////////
const LONG MIN_VERSION = IAS_WIN2K_VERSION;
const LONG MAX_VERSION = IAS_WHISTLER_BETA2_VERSION;

STDMETHODIMP OleDBDataStore::get_Root(IDataStoreObject** ppObject)
{
   if (ppObject == NULL) { return E_INVALIDARG; }

   if (*ppObject = root) { (*ppObject)->AddRef(); }

   return S_OK;
}

STDMETHODIMP OleDBDataStore::Initialize(BSTR bstrDSName,
                                        BSTR bstrUserName,
                                        BSTR bstrPassword)
{
   // Are we already initialized?
   if (root != NULL) { HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED); }

   // Open the database.
   HRESULT hr = IASOpenJetDatabase(bstrDSName, FALSE, &session);
   if (FAILED(hr)) { return hr; }

   //////////
   // Check the version.
   //////////

   LONG version;
   hr = IASExecuteSQLFunction(
            session,
            L"SELECT Version FROM Version",
            &version
            );

   // If the table doesn't exist, then version is zero.
   if (hr == DB_E_NOTABLE)
   {
      version = 0;
   }
   else if (FAILED(hr))
   {
      return hr;
   }

   // Is it out of bounds?
   if (version < MIN_VERSION || version > MAX_VERSION)
   {
      return HRESULT_FROM_WIN32(ERROR_REVISION_MISMATCH);
   }

   try
   {
      //////////
      // Initialize all the command objects.
      //////////

      members.initialize(session);
      create.initialize(session);
      destroy.initialize(session);
      find.initialize(session);
      update.initialize(session);
      erase.initialize(session);
      get.initialize(session);
      set.initialize(session);

      // Create the root object.
      root = DBObject::createInstance(this, NULL, 1, L"top");
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP OleDBDataStore::OpenObject(BSTR bstrPath,
                                        IDataStoreObject** ppObject)
{
   return E_NOTIMPL;
}

STDMETHODIMP OleDBDataStore::Shutdown()
{
   //////////
   // Release the root.
   //////////

   root.Release();

   //////////
   // Finalize the commands.
   //////////

   set.finalize();
   get.finalize();
   erase.finalize();
   update.finalize();
   find.finalize();
   destroy.finalize();
   create.finalize();
   members.finalize();

   //////////
   // Release the data source connection.
   //////////

   session.Release();

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\oledbstore.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    oledbstore.h
//
// SYNOPSIS
//
//    This file declares the class OleDBDataStore.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    05/30/2000    Remove unnecessary connection member.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _OLEDBSTORE_H_
#define _OLEDBSTORE_H_

#include <objcmd.h>
#include <propcmd.h>
#include <resource.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    OleDBDataStore
//
// DESCRIPTION
//
//    This class implements IDataStore2 and provides the gateway into the
//    OLE-DB object space.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE OleDBDataStore
   : public CComObjectRootEx< CComMultiThreadModel >,
     public CComCoClass< OleDBDataStore, &__uuidof(OleDBDataStore) >,
     public IDispatchImpl< IDataStore2,
                           &__uuidof(IDataStore2),
                           &__uuidof(DataStore2Lib) >
{
public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(OleDBDataStore)

BEGIN_COM_MAP(OleDBDataStore)
   COM_INTERFACE_ENTRY(IDataStore2)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//////////
// IDataStore2
//////////
   STDMETHOD(get_Root)(/*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(Initialize)(
                 /*[in]*/ BSTR bstrDSName,
                 /*[in]*/ BSTR bstrUserName,
                 /*[in]*/ BSTR bstrPassword
                 );
   STDMETHOD(OpenObject)(
                 /*[in]*/ BSTR bstrPath,
                 /*[out, retval]*/ IDataStoreObject** ppObject
                 );
   STDMETHOD(Shutdown)();

////////// 
// Various OLE-DB commands. These are made public so all OLE-DB objects can
// user them.
////////// 
   FindMembers   members;
   CreateObject  create;
   DestroyObject destroy;
   FindObject    find;
   UpdateObject  update;
   EraseBag      erase;
   GetBag        get;
   SetBag        set;

public:
   CComPtr<IUnknown> session;          // Open session.
   CComPtr<IDataStoreObject> root;     // The root object in the store.
};

#endif  // _OLEDBSTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\propcmd.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    propcmd.cpp
//
// SYNOPSIS
//
//    This file defines commands for manipulating the Objects table.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    04/03/1998    Bind integers as DBTYPE_I4.
//    02/15/1999    Make commands MT safe.
//    02/19/1999    Added definition of CommandBase::Execute
//    05/30/2000    Add trace support.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <propcmd.h>

void GetBag::execute(ULONG bagKey, PropertyBag& output)
{
   _serialize

   bag = bagKey;

   Rowset rowset;

   CommandBase::execute(__uuidof(IRowset), (IUnknown**)&rowset);

   // Iterate through the rowset and insert the properties into the bag.
   while (rowset.moveNext())
   {
      rowset.getData(readAccess, this);

      // Make a variant from the row data.
      _variant_t v(value);

      // Convert it to the appropriate type.
      v.ChangeType(type);

      // Add it to the PropertyBag
      output.appendValue(name, &v);
   }
}


void SetBag::execute(ULONG bagKey, PropertyBag& input)
{
   _serialize

   bag = bagKey;

   PropertyBag::const_iterator i;

   // Iterate through all the properties.
   for (i = input.begin(); i != input.end(); ++i)
   {
      // Store the property name.
      wcsncpy(name, i->first, sizeof(name)/sizeof(WCHAR));

      PropertyValue::const_iterator j;

      // Iterate through all the values.
      for (j = i->second.begin(); j != i->second.end(); ++j)
      {
         // Set the type.
         type = V_VT(j);

         // Copy the value VARIANT.
         _variant_t v(*j);

         // Convert it to a BSTR.
         v.ChangeType(VT_BSTR);

         // Copy it into the parameter buffer.
         if (wcslen(V_BSTR(&v)) >= sizeof(value)/sizeof(WCHAR))
         {
            // Too big. Throw an exception.
            _com_issue_error(E_INVALIDARG);
         }
         else
         {
            wcscpy(value, V_BSTR(&v));
         }

         // Load the row data into the table.
         CommandBase::execute();
      }
   }
}

void CommandBase::execute(REFIID refiid, IUnknown** result)
{
   CheckOleDBError(
       "ICommand::Execute",
       command->Execute(NULL, refiid, &dbParams, NULL, result)
       );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\propbag.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    propbag.h
//
// SYNOPSIS
//
//    This file declares the classes PropertyValue, Property, and PropertyBag.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    03/03/1998    Changed PropertyValue to a vector.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _PROPBAG_H_
#define _PROPBAG_H_

#include <map>
#include <vector>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PropertyValue
//
// DESCRIPTION
//
//    This class encapsulates the value portion of a multi-valued property.
//
///////////////////////////////////////////////////////////////////////////////
class PropertyValue : public std::vector<_variant_t>
{
public:
   ////////// 
   // Various constructors.
   ////////// 
   PropertyValue() { } 
   PropertyValue(const VARIANT* v);
   PropertyValue(const PropertyValue& val) : _Myt(val) { }

   // Append a new value to the existing values.
   void append(const VARIANT* v);

   // Get all the values.
   void get(VARIANT* v) const;

   // Replace all the values.
   void update(const VARIANT* v)
   {
      swap(PropertyValue(v));
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PropertyBag
//
// DESCRIPTION
//
//    This class implements a generic property bag consisting of (name, value)
//    pairs. It has a special feature in that it supports multi-valued
//    attributes. These are put/get as a SafeArray of VARIANT's.
//
///////////////////////////////////////////////////////////////////////////////
class PropertyBag : public std::map<_bstr_t, PropertyValue>
{
public:
   using _Myt::insert;

   void appendValue(const _bstr_t& name, const VARIANT* value);

   bool getValue(const _bstr_t& name, VARIANT* value) const;

   void updateValue(const _bstr_t& name, const VARIANT* value);
};

typedef PropertyBag::value_type Property;


#endif // _PROPBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\propbag.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    propbag.cpp
//
// SYNOPSIS
//
//    This file defines the class PropertyBag.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <propbag.h>
#include <varvec.h>

PropertyValue::PropertyValue(const VARIANT* v)
{
   // Is this a single-valued property?
   if (V_VT(v) != (VT_VARIANT | VT_ARRAY))
   {
      push_back(v);
   }
   else
   {
      // Multi-valued, so get the array ...
      CVariantVector<VARIANT> array(const_cast<VARIANT*>(v));

      resize(array.size());

      // ... and assign each element separately.
      for (size_t i = 0; i < array.size(); ++i)
      {
         operator[](i) = array[i];
      }
   }
}

void PropertyValue::append(const VARIANT* v)
{
   // Copy the supplied VARIANT.
   variant_t tmp(v);

   // Make room in the vector.
   resize(size() + 1);

   // Assign the copy.
   back() = tmp.Detach();
}

void PropertyValue::get(VARIANT* v) const
{
   VariantInit(v);

   if (size() == 1)
   {
      // Single-valued so just copy the front element.
      _com_util::CheckError(VariantCopy(v, const_cast<_variant_t*>(&front())));
   }
   else if (!empty())
   {
      // Copy all the values.
      PropertyValue tmp(*this);

      // Create an array of VARIANT's to hold the returned copies.
      CVariantVector<VARIANT> array(v, size());

      // Assign the copies.
      for (size_t i = 0; i < size(); ++i)
      {
         array[i] = tmp[i].Detach();
      }
   }
}

void PropertyBag::appendValue(const _bstr_t& name, const VARIANT* value)
{
   iterator i = find(name);

   (i != end()) ?  i->second.append(value) : updateValue(name, value);
}

bool PropertyBag::getValue(const _bstr_t& name, VARIANT* value) const
{
   const_iterator i = find(name);

   return (i != end()) ? i->second.get(value), true : false;
}

void PropertyBag::updateValue(const _bstr_t& name, const VARIANT* value)
{
   PropertyValue tmp(value);

   operator[](name).swap(tmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\inc\iasdb.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasdb.h
//
// SYNOPSIS
//
//    Declares functions for accessing OLE-DB databases.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IASDB_H
#define IASDB_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <unknwn.h>
typedef struct IRowset IRowset;

#ifdef __cplusplus
extern "C" {
#endif

// Const values used in different places
const LONG IAS_WIN2K_VERSION     = 0;
const LONG IAS_WHISTLER1_VERSION = 1;
const LONG IAS_WHISTLER_BETA1_VERSION = 2;
const LONG IAS_WHISTLER_BETA2_VERSION = 3;


VOID
WINAPI
IASCreateTmpDirectory();

HRESULT
WINAPI
IASOpenJetDatabase(
    IN PCWSTR path,
    IN BOOL readOnly,
    OUT LPUNKNOWN* session
    );

HRESULT
WINAPI
IASExecuteSQLCommand(
    IN LPUNKNOWN session,
    IN PCWSTR commandText,
    OUT IRowset** result
    );

HRESULT
WINAPI
IASExecuteSQLFunction(
    IN LPUNKNOWN session,
    IN PCWSTR functionText,
    OUT LONG* result
    );

HRESULT
WINAPI
IASCreateJetDatabase( 
    IN PCWSTR dataSource 
    );

HRESULT
WINAPI
IASTraceJetError(
    PCSTR functionName,
    HRESULT errorCode
    );

BOOL
WINAPI
IASIsInprocServer();

#ifdef __cplusplus
}
#endif
#endif // IASDB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\propcmd.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    propcmd.h
//
// SYNOPSIS
//
//    This file defines commands for manipulating the Objects table.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    04/03/1998    Increase property value length from 64 to 4096.
//                  Bind integers as DBTYPE_I4.
//                  Add PARAMETERS clause to all commands.
//    02/15/1999    Make commands MT safe.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _PROPCMD_H_
#define _PROPCMD_H_

#include <cmdbase.h>
#include <propbag.h>
#include <rowset.h>

//////////
// Column widths including null-terminator (i.e., Jet column size + 1).
//////////
const size_t PROPERTY_NAME_LENGTH  =  256;
const size_t PROPERTY_VALUE_LENGTH = 4096;

//////////
// Command to erase the contents of a property bag.
//////////
class EraseBag : public CommandBase
{
public:
   void execute(ULONG bagKey)
   {
      _serialize

      bag = bagKey;

      CommandBase::execute();
   }

   PCWSTR getCommandText() const throw ()
   {
      return L"PARAMETERS X LONG;"
             L"DELETE FROM Properties WHERE Bag = X;";
   }

protected:
   ULONG bag;

BEGIN_BIND_MAP(EraseBag, ParamIO, DBACCESSOR_PARAMETERDATA)
   BIND_COLUMN(bag, 1, DBTYPE_I4),
END_BIND_MAP()
};


//////////
// Command to retrieve a property bag.
//////////
class GetBag : public CommandBase
{
public:
   ~GetBag()
   {
      finalize();
   }

   void execute(ULONG bagKey, PropertyBag& output);

   PCWSTR getCommandText() const throw ()
   {
      return L"PARAMETERS X LONG;"
             L"SELECT Name, Type, StrVal FROM Properties WHERE Bag = X;";
   }

   void initialize(IUnknown* session)
   {
      CommandBase::initialize(session);

      readAccess = createReadAccessor(command);
   }

   void finalize() throw ()
   {
      releaseAccessor(readAccess);

      CommandBase::finalize();
   }

protected:
   ULONG bag;
   WCHAR name[PROPERTY_NAME_LENGTH];
   ULONG type;
   WCHAR value[PROPERTY_VALUE_LENGTH];
   HACCESSOR readAccess;

BEGIN_BIND_MAP(GetBag, ParamIO, DBACCESSOR_PARAMETERDATA)
   BIND_COLUMN(bag, 1, DBTYPE_I4),
END_BIND_MAP()

BEGIN_BIND_MAP(GetBag, ReadAccessor, DBACCESSOR_ROWDATA)
   BIND_COLUMN(name,  1, DBTYPE_WSTR),
   BIND_COLUMN(type,  2, DBTYPE_I4),
   BIND_COLUMN(value, 3, DBTYPE_WSTR),
END_BIND_MAP()
};


//////////
// Command to save a property bag.
//////////
class SetBag : public CommandBase
{
public:
   void execute(ULONG bagKey, PropertyBag& input);

   PCWSTR getCommandText() const throw ()
   {
      return L"PARAMETERS W LONG, X TEXT, Y LONG, Z LONGTEXT;"
             L"INSERT INTO Properties (Bag, Name, Type, StrVal) VALUES (W, X, Y, Z);";
   }

protected:
   ULONG bag;
   WCHAR name[PROPERTY_NAME_LENGTH];
   ULONG type;
   WCHAR value[PROPERTY_VALUE_LENGTH];

BEGIN_BIND_MAP(SetBag, ParamIO, DBACCESSOR_PARAMETERDATA)
   BIND_COLUMN(bag,   1, DBTYPE_I4),
   BIND_COLUMN(name,  2, DBTYPE_WSTR),
   BIND_COLUMN(type,  3, DBTYPE_I4),
   BIND_COLUMN(value, 4, DBTYPE_WSTR),
END_BIND_MAP()
};

#endif  // _PROPCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\rowset.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    rowset.h
//
// SYNOPSIS
//
//    This file declares the class Rowset.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _ROWSET_H_
#define _ROWSET_H_

#include <nocopy.h>
#include <oledb.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Rowset
//
// DESCRIPTION
//
//    This class provides a lightweight, C++ friendly wrapper around an
//    OLE-DB IRowset interface.
//
///////////////////////////////////////////////////////////////////////////////
class Rowset : NonCopyable
{
public:
   Rowset() throw ()
      : row(0) { }

   Rowset(IRowset* p) throw ()
      : rowset(p), row(0) { }

   ~Rowset() throw ()
   {
      releaseRow();
   }

   void getData(HACCESSOR hAccessor, void* pData)
   {
      _com_util::CheckError(rowset->GetData(row, hAccessor, pData));
   }

   bool moveNext();

   void release() throw ()
   {
      releaseRow();

      rowset.Release();
   }

   void reset()
   {
      _com_util::CheckError(rowset->RestartPosition(NULL));
   }

   operator IRowset*() throw ()
   {
      return rowset;
   }

   IRowset** operator&() throw ()
   {
      return &rowset;
   }

protected:

   HRESULT releaseRow() throw ();

   CComPtr<IRowset> rowset;  // The rowset being adapted.
   HROW row;                 // The current row handle.
};

#endif  // _ROWSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\dstore\rowset.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    rowset.cpp
//
// SYNOPSIS
//
//    This file defines the class Rowset.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    04/21/1998    Get rid of unnecessary row assignment in moveNext().
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <rowset.h>

bool Rowset::moveNext()
{
   _com_util::CheckError(releaseRow());

   DBCOUNTITEM numRows = 0;

   HROW* pRow = &row;

   HRESULT hr = rowset->GetNextRows(NULL, 0, 1, &numRows, &pRow);

   _com_util::CheckError(hr);

   return hr == S_OK && numRows == 1;
}

HRESULT Rowset::releaseRow() throw ()
{
   if (row != NULL)
   {
      HRESULT hr = rowset->ReleaseRows(1, &row, NULL, NULL, NULL);

      row = NULL;

      return hr;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\netsh\netshhelper.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    netshhelper.cpp
//
// SYNOPSIS
//
//    Implement the class CIASNetshJetHelper.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//    06/13/2000    parameter TRUE added for IASUpgrade
//
// NOTE
//        
// OpenJetDatabase MUST be called BEFORE calling any other method.
//
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>

#include "netshhelper.h"
#include <iasdb.h>
#include "setup.h"

//////////////////////////////////////////////////////////////////////////////
// CIASNetshJetHelper
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// OpenJetDatabase
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNetshJetHelper::OpenJetDatabase(
                                                    BSTR         Path,
                                                    VARIANT_BOOL ReadOnly
                                                )
{
    return IASOpenJetDatabase(Path, ReadOnly, &m_Session);
}


//////////////////////////////////////////////////////////////////////////////
// IASExecuteSQLFunction
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNetshJetHelper::ExecuteSQLFunction(BSTR Command, LONG *Result)
{
    return IASExecuteSQLFunction(m_Session, Command, Result);

}


//////////////////////////////////////////////////////////////////////////////
// ExecuteSQLCommand
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNetshJetHelper::ExecuteSQLCommand(BSTR Command)
{
    return IASExecuteSQLCommand(m_Session, Command, NULL);
}


//////////////////////////////////////////////////////////////////////////////
// CreateJetDatabase
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNetshJetHelper::CreateJetDatabase(BSTR Path)
{
    return IASCreateJetDatabase(Path);
}


//////////////////////////////////////////////////////////////////////////////
// CloseJetDatabase
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNetshJetHelper::CloseJetDatabase()
{
    m_Session.Release();
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// UpgradeDatabase
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNetshJetHelper::UpgradeDatabase()
{
    CIASUpgrade     Upgrade;
    return Upgrade.IASUpgrade(TRUE); // TRUE = "called from Netshell"
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\netsh\netshhelper.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    netshhelper.h
//
// SYNOPSIS
//
//    Declares the class CIASNetshJetHelper.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//
// NOTE: That class was created only to be used from the netsh aaaa helper dll
///////////////////////////////////////////////////////////////////////////////
#ifndef _NETSH_HELPER_H_
#define _NETSH_HELPER_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <datastore2.h>
#include <iasuuid.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//      CIASNetshJetHelper
//
// DESCRIPTION
//
//    Provides an Automation compatible wrapper around the Jet Commands used by
//    netsh aaaa.
//
///////////////////////////////////////////////////////////////////////////////
class CIASNetshJetHelper : 
    public CComObjectRootEx< CComMultiThreadModelNoCS >,
    public CComCoClass< CIASNetshJetHelper, &__uuidof(CIASNetshJetHelper) >,
    public IIASNetshJetHelper
{
public:
    DECLARE_NO_REGISTRY()
    DECLARE_NOT_AGGREGATABLE(CIASNetshJetHelper)

BEGIN_COM_MAP(CIASNetshJetHelper)
    COM_INTERFACE_ENTRY_IID(__uuidof(IIASNetshJetHelper), IIASNetshJetHelper) 
END_COM_MAP()

// IIASNetshJetHelper

    STDMETHOD(CloseJetDatabase)();
    STDMETHOD(CreateJetDatabase)(BSTR Path);
    STDMETHOD(ExecuteSQLCommand)(BSTR Command);
    STDMETHOD(ExecuteSQLFunction)(BSTR Command, LONG* Result);
    STDMETHOD(OpenJetDatabase)(BSTR  Path, VARIANT_BOOL ReadOnly);
    STDMETHOD(UpgradeDatabase)();

private:
    CComPtr<IUnknown>   m_Session;
};

#endif // _NETSH_HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\attributes.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Attributes.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Implementation of the CAttributes class (dnary.mdb)
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Attributes.h"


CAttributes::CAttributes(CSession& Session)
{
    Init(Session);
}

//////////////////////////////////////////////////////////////////////////
// GetAttribute
//////////////////////////////////////////////////////////////////////////
HRESULT CAttributes::GetAttribute(
                        LONG            ID,
                        _bstr_t&        LDAPName,
                        LONG&           Syntax,
                        BOOL&           IsMultiValued
                    )
{
    m_IDParam = ID;

    // Used if you have previously created the command
    HRESULT hr  = BaseExecute();
    if ( hr == S_OK )
    {
        LDAPName      = m_LDAPName;
        Syntax        = m_Syntax;
        IsMultiValued = m_MultiValued;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\doupgrade.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      DoUpgrade.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of CDoNT4OrCleanUpgrade, CUpgradeWin2k 
//              and CUpgradeNT4
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//              06/13/2000 Execute returns void, 
//                         private functions moved from CUpgradeWin2k 
//                         to CMigrateContent
//                         CDoUpgrade used for "clean or NT4 upgrades" only.
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "DoUpgrade.h"
#include "migratemdb.h"
#include "migratecontent.h"
#include "Version.h"
#include "iasdb.h"

//////////////////////////////////////////////////////////////////////////////
// Execute
// Does either a clean NT4 upgrade or nothing (clean install)
//////////////////////////////////////////////////////////////////////////////
void CDoNT4OrCleanUpgrade::Execute()
{
    if ( m_Utils.IsNT4Corp() || m_Utils.IsNT4Isp() )
    {
        CUpgradeNT4         UpgradeNT4;
        UpgradeNT4.Execute();
    }
    // else this is a clean install: nothing to do
}


//////////////////////////////////////////////////////////////////////////////
// GetVersionNumber
//////////////////////////////////////////////////////////////////////////////
LONG CUpgradeWin2k::GetVersionNumber()
{
    return m_GlobalData.m_pRefVersion->GetVersion();
}


//////////////////////////////////////////////////////////////////////////////
// CLASS CUpgradeWin2k
// expects the files:
// iasold.mdb as a Whistler before proxy or a Win2k mdb file
// ias.mdb to be a Whistler file (already good)
//////////////////////////////////////////////////////////////////////////////

///////////////
// Constructor
///////////////
CUpgradeWin2k::CUpgradeWin2k()
                :m_Outcome(E_FAIL),
                 m_GlobalTransaction(CGlobalTransaction::Instance()),
                 m_Utils(CUtils::Instance())
{
    /////////////////////////////////////////////////
    // Check %TMP% and create a directory if needed
    // That's to fix a bug with JET
    /////////////////////////////////////////////////
    IASCreateTmpDirectory();

    // Create the paths to the mdb files
    LONG    Result = m_Utils.GetIAS2Directory(m_IASWhistlerPath);
    if ( Result != ERROR_SUCCESS )
    {
        _com_util::CheckError(HRESULT_FROM_WIN32(Result));
    }
    m_IASOldPath = m_IASWhistlerPath;

    m_IASOldPath      += L"\\iasold.mdb";
    m_IASWhistlerPath += L"\\ias.mdb";

    //////////////////
    // Database inits
    //////////////////

    // Open the DataSource and session for ias.mdb
    // and Initialize the GlobalTransaction
    m_GlobalTransaction.OpenStdDataSource(m_IASWhistlerPath);

    // Open the DataSource and session for iasnew.mdb
    m_GlobalTransaction.OpenRefDataSource(m_IASOldPath);

    // create instances of CObjects and CProperties
    m_GlobalData.InitStandard(m_GlobalTransaction.GetStdSession());

    // create instances of CObjects and CProperties for the Ref database
    m_GlobalData.InitRef(m_GlobalTransaction.GetRefSession());
};


//////////////
// Destructor
//////////////
CUpgradeWin2k::~CUpgradeWin2k()
{
    m_GlobalData.Clean();

    if ( FAILED(m_Outcome) )
    {
        /////////////////////////
        // Abort the transaction
        /////////////////////////
        m_GlobalTransaction.Abort();

        SetLastError(E_FAIL);
    }
    else
    {
        ///////////
        // Success
        ///////////
        m_GlobalTransaction.Commit();

    }
    /////////////////////////////////////////////
    // close the session and then the datasource
    /////////////////////////////////////////////
    m_GlobalTransaction.MyCloseDataSources();
};


/////////////////////////////
// Execute
// IAS_WIN2K_VERSION     = 0;
// IAS_WHISTLER1_VERSION = 1;
// IAS_WHISTLER_BETA1_VERSION = 2;
// IAS_WHISTLER_BETA2_VERSION = 3;
/////////////////////////////
void CUpgradeWin2k::Execute()
{
    CMigrateContent    MigrateContent(m_Utils, m_GlobalData);

    ////////////////////////////////////////////////////
    // Check the version number (of iasold.mdb)
    ////////////////////////////////////////////////////
    LONG CurrentVersion = GetVersionNumber();
    ////////////////////////////////////////////////////
    // Migrate the content from iasold.mdb into ias.mdb
    ////////////////////////////////////////////////////
    switch (CurrentVersion)
    {
    case IAS_WIN2K_VERSION:
    case IAS_WHISTLER1_VERSION:
       {
          MigrateContent.Migrate();
          // Everything is ok. Set m_Outcome = S_OK to Commit the IAS.mdb
          m_Outcome = S_OK;
          break;
       }
    case IAS_WHISTLER_BETA1_VERSION:           
       {
          // Update the MSChap Authentication types (password)
          MigrateContent.UpdateWhistler(true);
          // Everything is ok. Set m_Outcome = S_OK to Commit the IAS.mdb
          m_Outcome = S_OK;
          break;
       }
    case IAS_WHISTLER_BETA2_VERSION:           
       {
          // do not touch the MSChap Authentication types (password)
          MigrateContent.UpdateWhistler(false);
          // Everything is ok. Set m_Outcome = S_OK to Commit the IAS.mdb
          m_Outcome = S_OK;
          break;
       }
    default:
       {
       }
    }
}


//////////////////////////////////////////////////////////////////////////////
// CLASS CUpgradeNT4
//////////////////////////////////////////////////////////////////////////////

///////////////
// Constructor
///////////////
CUpgradeNT4::CUpgradeNT4()
        :m_Outcome(E_FAIL),
         m_GlobalTransaction(CGlobalTransaction::Instance()),
         m_Utils(CUtils::Instance())
{
    const WCHAR IAS_MDB_NAME[]      = L"\\ias.mdb";
    const WCHAR DNARY_MDB_NAME[]    = L"\\dnary.mdb";
 
    /////////////////////////////////////////////////
    // Check %TMP% and create a directory if needed
    // That's to fix a bug with JET
    /////////////////////////////////////////////////
    IASCreateTmpDirectory();
    
    ///////////////////////////////
    // Backup the pristine ias.mdb
    ///////////////////////////////
    LONG Result = m_Utils.GetIAS2Directory(m_Ias2MdbString);
    if ( Result != ERROR_SUCCESS )
    {
        _com_issue_error(HRESULT_FROM_WIN32(Result));
    }

    m_DnaryMdbString  = m_Ias2MdbString;
    m_DnaryMdbString += DNARY_MDB_NAME;
    
    m_Ias2MdbString  += IAS_MDB_NAME;

    Result = m_Utils.GetAuthSrvDirectory(m_AuthSrvMdbString);
    if ( Result != ERROR_SUCCESS )
    {
        _com_issue_error(HRESULT_FROM_WIN32(Result));
    }
    m_AuthSrvMdbString += L"\\_adminui.mdb";

    m_IASNT4Path      = m_AuthSrvMdbString;
    m_IASWhistlerPath = m_Ias2MdbString;

    // Open the DataSource and session for _adminui.mdb
    m_GlobalTransaction.OpenNT4DataSource(m_IASNT4Path);

    // create instances of CRemoteRadiusServers and CRealms 
    m_GlobalData.InitNT4(m_GlobalTransaction.GetNT4Session());

    // Open the DataSource and session for ias.mdb
    // and Initialize the GlobalTransaction
    m_GlobalTransaction.OpenStdDataSource(m_IASWhistlerPath);

    // create instances of CObjects and CProperties
    m_GlobalData.InitStandard(m_GlobalTransaction.GetStdSession());

    m_GlobalTransaction.OpenDnaryDataSource(m_DnaryMdbString);

    m_GlobalData.InitDnary(m_GlobalTransaction.GetDnarySession());
};


//////////////
// Destructor
//////////////
CUpgradeNT4::~CUpgradeNT4()
{
    //////////
    // Clean
    //////////

    // Abort or Commit depending on Result

    m_GlobalData.Clean();

    if ( SUCCEEDED(m_Outcome) )
    {
        m_GlobalTransaction.Commit();  // ignore return value
    }
    else
    {
        m_GlobalTransaction.Abort();    // ignore return value
        SetLastError(E_FAIL);
    }

    // close the sessions and then the datasources
    // for ias.mdb iasnew.mdb and _adminui.mdb
    m_GlobalTransaction.MyCloseDataSources();

    // Restore the pristine ias.mdb if the migration failed
    if ( SUCCEEDED(m_Outcome) )
    {
        // Success, the old files are deleted
        m_Utils.DeleteOldIASFiles();
    }
};


///////////
// Execute
///////////
void CUpgradeNT4::Execute()
{
    CMigrateMdb     MigrateMdb(m_Utils, m_GlobalData);
    ////////////////////////////////////////
    // Migrate the MDB file
    // including the proxy servers
    ////////////////////////////////////////
    // Perform the migration into ias.mdb
    MigrateMdb.NewMigrate(); 

    // Set m_Outcome = S_OK to allow the Commit on the DB... in the 
    // destructor
    m_Outcome = S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\inc\setup.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    setup.h
//
// SYNOPSIS
//
//    exported function
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//    06/13/2000    class CIASUpgrade added
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _SETUP_H_
#define _SETUP_H_

#if _MSC_VER >= 1000
#pragma once
#endif

class CIASUpgrade
{
public:
    CIASUpgrade();
    HRESULT IASUpgrade(BOOL FromNetshell = FALSE);

protected:
    LONG GetVersionNumber(LPCWSTR DatabaseName);
    void DoWin2kUpgradeFromNetshell();
    void DoNT4UpgradeOrCleanInstall();
    void DoWin2kUpgrade();
    void DoWhistlerUpgrade();

    enum _UpgradeType
    {
        Win2kUpgradeFromNetshell,
        NT4UpgradeOrCleanInstall,
        Win2kUpgrade,
        WhistlerUpgrade
    } UpgradeType;

    _bstr_t  m_pIASNewMdb, m_pIASMdb, m_pIASOldMdb;
};

#endif // _SETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\doupgrade.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      DoUpgrade.h 
//
// Project:     Windows 2000 IAS
//
// Description: Declaration of CDoNT4OrCleanUpgrade, CUpgradeWin2k 
//              and CUpgradeNT4
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//              06/13/2000 Execute returns void, 
//                         private functions moved from CUpgradeWin2k 
//                         to CMigrateContent
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _DOUPGRADE_H_FC532313_DB66_459d_B499_482834B55EC2
#define _DOUPGRADE_H_FC532313_DB66_459d_B499_482834B55EC2

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "globaltransaction.h"
#include "GlobalData.h"
#include "nocopy.h"

/////////////////////////////////////////////////////////////////////////////
// CDoUpgrade
class CDoNT4OrCleanUpgrade : private NonCopyable
{
public:
    CDoNT4OrCleanUpgrade():m_Utils(CUtils::Instance())
    {
    }

    void        Execute();

private:
    CUtils&     m_Utils;
};


//////////////////////////////////////////////////////////////////////////////
// class   CUpgradeWin2k 
//////////////////////////////////////////////////////////////////////////////
class   CUpgradeWin2k 
{
public:
    CUpgradeWin2k();
    ~CUpgradeWin2k();
    void        Execute();

private:
    LONG        GetVersionNumber();

    CUtils&                 m_Utils;
    CGlobalTransaction&     m_GlobalTransaction; 
    CGlobalData             m_GlobalData;

    _bstr_t                 m_IASWhistlerPath;
    _bstr_t                 m_IASOldPath;

    HRESULT                 m_Outcome;
};


//////////////////////////////////////////////////////////////////////////////
// class   CUpgradeNT4 
//////////////////////////////////////////////////////////////////////////////
class   CUpgradeNT4 
{
public:
    CUpgradeNT4();
    ~CUpgradeNT4() throw();
    void        Execute();

private:
    void        FinishNewNT4Migration(LONG Result);

    CUtils&                 m_Utils;
    CGlobalTransaction&     m_GlobalTransaction; 
    CGlobalData             m_GlobalData;
    HRESULT                 m_Outcome;

    _bstr_t                 m_IASNT4Path;
    _bstr_t                 m_IasMdbTemp;
    _bstr_t                 m_Ias2MdbString;
    _bstr_t                 m_DnaryMdbString;
    _bstr_t                 m_AuthSrvMdbString;
    _bstr_t                 m_IASWhistlerPath;
};


#endif //_DOUPGRADE_H_FC532313_DB66_459d_B499_482834B55EC2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\globaldata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      GlobalData.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of the CGlobalData struct
//
// Author:      tperraut
//
// Revision     03/22/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "GlobalData.h"
#include "Attributes.h"
#include "Clients.h"
#include "DefaultProvider.h"
#include "Objects.h"
#include "ProfileAttributeList.h"
#include "Profiles.h"
#include "Properties.h"
#include "Providers.h"
#include "RADIUSAttributeValues.h"
#include "Realms.h"
#include "RemoteRadiusServers.h"
#include "ServiceConfiguration.h"
#include "Version.h"



void CGlobalData::InitStandard(CSession& Session) 
{
    m_pObjects      = new CObjects(Session);
    m_pProperties   = new CProperties(Session);
};

void CGlobalData::InitRef(CSession& Session) 
{
    m_pRefObjects    = new CObjects(Session);
    m_pRefProperties = new CProperties(Session);
    m_pRefVersion    = new CVersion(Session);
};

void CGlobalData::InitNT4(CSession& Session) 
{
    m_pClients              = new CClients(Session);
    m_pDefaultProvider      = new CDefaultProvider(Session);
    m_pProfileAttributeList = new CProfileAttributeList(Session);
    m_pProfiles             = new CProfiles(Session);
    m_pProviders            = new CProviders(Session);
    m_pRADIUSAttributeValues= new CRADIUSAttributeValues(Session);
    m_pRadiusServers        = new CRemoteRadiusServers(Session);
    m_pRealms               = new CRealms(Session);
    m_pServiceConfiguration = new CServiceConfiguration(Session);
}   

void CGlobalData::InitDnary(CSession& Session) 
{
    m_pAttributes           = new CAttributes(Session);
};

void CGlobalData::Clean() throw()
{
    delete  m_pAttributes;
    m_pAttributes = NULL;
    delete  m_pClients;
    m_pClients = NULL;
    delete  m_pDefaultProvider;
    m_pDefaultProvider = NULL;
    delete  m_pObjects;
    m_pObjects = NULL;
    delete  m_pProfiles;
    m_pProfiles = NULL;
    delete  m_pProfileAttributeList;
    m_pProfileAttributeList = NULL;
    delete  m_pProperties;
    m_pProperties = NULL;
    delete  m_pProviders;
    m_pProviders = NULL;
    delete  m_pRADIUSAttributeValues;
    m_pRADIUSAttributeValues = NULL;
    delete  m_pRadiusServers;
    m_pRadiusServers = NULL;
    delete  m_pRealms;
    m_pRealms = NULL;
    delete  m_pRefObjects;
    m_pRefObjects = NULL;
    delete  m_pRefProperties;
    m_pRefProperties = NULL;
    delete m_pRefVersion;
    m_pRefVersion = NULL;
    delete m_pServiceConfiguration;
    m_pServiceConfiguration = NULL;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\defaultprovider.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      DefaultProvider.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of the CDefaultProvider class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "DefaultProvider.h"

//////////////////////////////////////////////////////////////////////////
// GetDefaultProvider
//////////////////////////////////////////////////////////////////////////
HRESULT CDefaultProvider::GetDefaultProvider(
                              _bstr_t&        UserDefinedName,
                              _bstr_t&        Profile,
                              VARIANT_BOOL&   ForwardAccounting,
                              VARIANT_BOOL&   SupressAccounting,
                              VARIANT_BOOL&   LogoutAccounting
                          )
{
    HRESULT hr = BaseExecute();
    if ( SUCCEEDED(hr) )
    {
        UserDefinedName   = m_UserDefinedName;
        Profile           = m_Profile;
        ForwardAccounting = m_ForwardAccounting;
        SupressAccounting = m_SupressAccounting;
        LogoutAccounting  = m_LogoutAccounting;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\migratecontent.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      migratecontent.cpp
//
// Project:     Windows 2000 IAS
//
// Description: Win2k and early Whistler mdb to Whistler Migration 
//              class CMigrateContent 
//
// Author:      tperraut 06/08/2000
//
// Revision     
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _MIGRATECONTENT_H_66418310_AD32_4e40_867E_1705E4373A5A
#define _MIGRATECONTENT_H_66418310_AD32_4e40_867E_1705E4373A5A

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"

class CMigrateContent : private NonCopyable
{
public:
    explicit CMigrateContent(
                              CUtils&         pUtils,
                              CGlobalData&    pGlobalData
                            )
                            : m_Utils(pUtils),
                              m_GlobalData(pGlobalData)
    {
    }

    void        Migrate();
    void        UpdateWhistler(const bool UpdateChapPasswords);

private:
    HRESULT     CopyTree(LONG  RefId, LONG ParentParam);

    void        MigrateWin2kRealms();
    void        MigrateClients();
    void        MigrateProfilesPolicies();
    void        MigrateProxyProfilesPolicies();
    void        MigrateAccounting(); 
    void        MigrateEventLog();
    void        MigrateService();
    void        MigrateServerGroups();

    CUtils&                  m_Utils;
    CGlobalData&             m_GlobalData;
};

#endif // _MIGRATECONTENT_H_66418310_AD32_4e40_867E_1705E4373A5A
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\migratecontent.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      migratecontent.cpp
//
// Project:     Windows 2000 IAS
//
// Description: Win2k and early Whistler DB to Whistler DB Migration 
//
// Author:      tperraut 06/08/2000
//
// Revision     
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "GlobalData.h"
#include "migratecontent.h"
#include "Objects.h"
#include "Properties.h"
#include "updatemschap.h"


//////////////////////////////////////////////////////////////////////////////
// CopyTree
//
// Param: 
//  - the Id in the Reference (Ref) database: place to read from (iasold.mdb)
//  - the parent of that same node but in the Standard (Std) database:
//    the place to write to (ias.mdb)
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CMigrateContent::CopyTree(LONG  RefId, LONG ParentParam)
{
    /////////////////////////////////////////
    // get the name and Parent in the Ref DB
    /////////////////////////////////////////
    _bstr_t     Name;
    LONG        Parent;
    HRESULT hr = m_GlobalData.m_pRefObjects->GetObjectIdentity(
                                                                 Name,
                                                                 Parent,
                                                                 RefId
                                                               );
    if ( FAILED(hr) )
    {
        return hr;
    }

    ///////////////////////////////////////////////////////
    // insert the object (gives an Identity) in the Std DB
    ///////////////////////////////////////////////////////
    LONG    NewIdentity;

    BOOL InsertOk = m_GlobalData.m_pObjects->InsertObject(
                                                 Name,
                                                 ParentParam, 
                                                 NewIdentity
                                             );
    if ( !InsertOk )
    {
        ///////////////////////////////////////////////
        // the object already exists don't do anything
        ///////////////////////////////////////////////
        return S_OK;
    }

    _bstr_t     PropertyName;
    _bstr_t     StrVal;
    LONG        Type;

    /////////////////////////////////////////////////////////////////
    // Copy the properties of that object from the Ref to the Std DB
    /////////////////////////////////////////////////////////////////
    hr = m_GlobalData.m_pRefProperties->GetProperty(
                                                       RefId,
                                                       PropertyName,
                                                       Type,
                                                       StrVal
                                                   );
    LONG    IndexProperty = 1;
    while ( hr == S_OK )    
    {
        m_GlobalData.m_pProperties->InsertProperty(
                                                           NewIdentity,
                                                           PropertyName,
                                                           Type,
                                                           StrVal
                                                        );
        hr = m_GlobalData.m_pRefProperties->GetNextProperty(
                                                              RefId,
                                                              PropertyName,
                                                              Type,
                                                              StrVal,
                                                              IndexProperty
                                                           );
        ++IndexProperty;

    }
    // here safely ignore hr

    //////////////////////////////////////////////////////////
    // get all the childs of the object in the Ref DB (RefId)
    //////////////////////////////////////////////////////////
    _bstr_t     ObjectName;
    LONG        ObjectIdentity;
    hr = m_GlobalData.m_pRefObjects->GetObject(
                                                 ObjectName,
                                                 ObjectIdentity,
                                                 RefId
                                              );
    LONG    IndexObject = 1;
    while ( SUCCEEDED(hr) )
    {
        ///////////////////////////////////////////////////////////
        // and for each, call CopyTree(ChildIdentity, NewIdentity)
        ///////////////////////////////////////////////////////////
        hr = CopyTree(ObjectIdentity, NewIdentity);
        if ( FAILED(hr) ){return hr;}

        hr = m_GlobalData.m_pRefObjects->GetNextObject(
                                                         ObjectName,
                                                         ObjectIdentity,
                                                         RefId,
                                                         IndexObject
                                                      );
        ++IndexObject;
    }

    ///////////////////////////////////////////////
    // if no child: return S_Ok. hr safely ignored
    ///////////////////////////////////////////////
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// MigrateXXX functions
// Description:
//      These functions follow the same model:
//      - Get the ID of a container in iasold.mdb
//      - Get the ID of the same container in ias.mdb
//      - Get the ID of that container's parent in ias.mdb
//      - Recursively deletes the container in ias.mdb
//      - Then copy the content of that container from iasold.mdb into ias.mdb
//        using the parent's container as the place to attach the result.
//      
//      Some functions also update some specific properties without doing 
//      a full copy
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// MigrateClients 
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::MigrateClients()
{
    const WCHAR ClientPath[] = L"Root\0"
                               L"Microsoft Internet Authentication Service\0"
                               L"Protocols\0"
                               L"Microsoft Radius Protocol\0"
                               L"Clients\0";

    LONG        ClientIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(ClientPath, ClientIdentity);

    const WCHAR RadiusProtocolPath[] = 
                                L"Root\0"
                                L"Microsoft Internet Authentication Service\0"
                                L"Protocols\0"
                                L"Microsoft Radius Protocol\0";

    LONG        RadiusProtocolIdentity;
    m_GlobalData.m_pObjects->WalkPath(
                                         RadiusProtocolPath, 
                                         RadiusProtocolIdentity
                                     );

    // delete the clients container and its content 
    LONG        DestClientIdentity;
    m_GlobalData.m_pObjects->WalkPath(ClientPath, DestClientIdentity);

    _com_util::CheckError(m_GlobalData.m_pObjects->DeleteObject(
                                             DestClientIdentity));

    // for each client in src, copy it in dest with its properties.
    _com_util::CheckError(CopyTree(ClientIdentity, RadiusProtocolIdentity)); 
}


//////////////////////////////////////////////////////////////////////////////
// MigrateProfilesPolicies
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::MigrateProfilesPolicies()
{
    const WCHAR ProfilesPath[] = 
                                L"Root\0"
                                L"Microsoft Internet Authentication Service\0"
                                L"RadiusProfiles\0";

    LONG        DestProfilesIdentity;
    m_GlobalData.m_pObjects->WalkPath(ProfilesPath, DestProfilesIdentity);

    const WCHAR PoliciesPath[] = 
                                L"Root\0"
                                L"Microsoft Internet Authentication Service\0"
                                L"NetworkPolicy\0";

    LONG        DestPoliciesIdentity;
    m_GlobalData.m_pObjects->WalkPath(PoliciesPath, DestPoliciesIdentity);


    // Delete the profiles and policies containers from ias.mdb 
    _com_util::CheckError(m_GlobalData.m_pObjects->DeleteObject(
                                             DestProfilesIdentity));

    _com_util::CheckError(m_GlobalData.m_pObjects->DeleteObject(
                                             DestPoliciesIdentity));

    // default profiles and policies deleted from now on

    LONG        ProfilesIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(ProfilesPath, ProfilesIdentity);

    LONG        PoliciesIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(PoliciesPath, PoliciesIdentity);

    const WCHAR IASPath[] = L"Root\0"
                            L"Microsoft Internet Authentication Service\0";

    LONG        IASIdentity;
    m_GlobalData.m_pObjects->WalkPath(IASPath, IASIdentity);
    
    // for each profiles and policies in iasold.mdb, 
    // copy it in dest with its properties.
    _com_util::CheckError(CopyTree(ProfilesIdentity, IASIdentity)); 
    _com_util::CheckError(CopyTree(PoliciesIdentity, IASIdentity)); 
}


//////////////////////////////////////////////////////////////////////////////
// MigrateProxyProfilesPolicies
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::MigrateProxyProfilesPolicies()
{
    const WCHAR ProfilesPath[] = 
                                L"Root\0"
                                L"Microsoft Internet Authentication Service\0"
                                L"Proxy Profiles\0";

    LONG        DestProfilesIdentity;
    m_GlobalData.m_pObjects->WalkPath(ProfilesPath, DestProfilesIdentity);

    const WCHAR PoliciesPath[] = 
                                L"Root\0"
                                L"Microsoft Internet Authentication Service\0"
                                L"Proxy Policies\0";

    LONG        DestPoliciesIdentity;
    m_GlobalData.m_pObjects->WalkPath(PoliciesPath, DestPoliciesIdentity);


    // Delete the profiles and policies containers from ias.mdb 
    _com_util::CheckError(m_GlobalData.m_pObjects->DeleteObject(
                                             DestProfilesIdentity));

    _com_util::CheckError(m_GlobalData.m_pObjects->DeleteObject(
                                             DestPoliciesIdentity));

    // default profiles and policies deleted from now on

    LONG        ProfilesIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(ProfilesPath, ProfilesIdentity);

    LONG        PoliciesIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(PoliciesPath, PoliciesIdentity);

    const WCHAR IASPath[] = L"Root\0"
                            L"Microsoft Internet Authentication Service\0";

    LONG        IASIdentity;
    m_GlobalData.m_pObjects->WalkPath(IASPath, IASIdentity);
    
    // for each profiles and policies in iasold.mdb, 
    // copy it in dest with its properties.
    _com_util::CheckError(CopyTree(ProfilesIdentity, IASIdentity)); 
    _com_util::CheckError(CopyTree(PoliciesIdentity, IASIdentity)); 
}


//////////////////////////////////////////////////////////////////////////////
// MigrateAccounting
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::MigrateAccounting()
{
    const WCHAR AccountingPath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"RequestHandlers\0"
                            L"Microsoft Accounting\0";

    LONG        AccountingIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(AccountingPath, AccountingIdentity);

    const WCHAR RequestHandlerPath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"RequestHandlers\0";

    LONG        RequestHandlerIdentity;
    m_GlobalData.m_pObjects->WalkPath(
                                         RequestHandlerPath, 
                                         RequestHandlerIdentity
                                     );

    // delete the Accounting container and its content in ias.mdb
    LONG        DestAccountingIdentity;
    m_GlobalData.m_pObjects->WalkPath(
                                         AccountingPath,
                                         DestAccountingIdentity
                                     );

    _com_util::CheckError(m_GlobalData.m_pObjects->DeleteObject(
                                             DestAccountingIdentity));

    // for each accounting in src, copy it in dest with its properties.
    _com_util::CheckError(CopyTree(
                                    AccountingIdentity, 
                                    RequestHandlerIdentity
                                  )); 
}


//////////////////////////////////////////////////////////////////////////////
// MigrateEventLog
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::MigrateEventLog()
{
    const WCHAR EventLogPath[] = L"Root\0"
                                 L"Microsoft Internet Authentication Service\0"
                                 L"Auditors\0"
                                 L"Microsoft NT Event Log Auditor\0";

    LONG        EventLogIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(EventLogPath, EventLogIdentity);

    const WCHAR AuditorsPath[] = L"Root\0"
                                 L"Microsoft Internet Authentication Service\0"
                                 L"Auditors\0";

    LONG        AuditorsIdentity;
    m_GlobalData.m_pObjects->WalkPath(AuditorsPath, AuditorsIdentity);

    // delete the Auditors container and its content in ias.mdb
    LONG        DestEventLogIdentity;
    m_GlobalData.m_pObjects->WalkPath(EventLogPath, DestEventLogIdentity);

    _com_util::CheckError(m_GlobalData.m_pObjects->DeleteObject(
                                               DestEventLogIdentity));

    // for each EventLog in src, copy it in dest with its properties.
    _com_util::CheckError(CopyTree(EventLogIdentity, AuditorsIdentity)); 
}


//////////////////////////////////////////////////////////////////////////////
// MigrateService
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::MigrateService()
{
    const LONG  PORT_SIZE_MAX = 34;
    const WCHAR ServicePath[] = L"Root\0"
                                L"Microsoft Internet Authentication Service\0"
                                L"Protocols\0"
                                L"Microsoft Radius Protocol\0";

    LONG        RefServiceIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(ServicePath, RefServiceIdentity);

    LONG        DestServiceIdentity;
    m_GlobalData.m_pObjects->WalkPath(ServicePath, DestServiceIdentity);


    _bstr_t     PropertyName = L"Authentication Port";
    _bstr_t     RadiusPort;
    LONG        Type = 0;
    m_GlobalData.m_pRefProperties->GetPropertyByName(
                                                       RefServiceIdentity,
                                                       PropertyName,
                                                       Type,
                                                       RadiusPort
                                                    );
    if ( Type != VT_BSTR )
    {
        _com_issue_error(E_UNEXPECTED);
    }
    
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 DestServiceIdentity,
                                                 PropertyName,
                                                 VT_BSTR,
                                                 RadiusPort
                                              );

    _bstr_t     AcctPort;
    PropertyName = L"Accounting Port";
    Type = 0;
    m_GlobalData.m_pRefProperties->GetPropertyByName(
                                                       RefServiceIdentity,
                                                       PropertyName,
                                                       Type,
                                                       AcctPort
                                                    );
    
    if ( Type != VT_BSTR )
    {
        _com_issue_error(E_UNEXPECTED);
    }

    m_GlobalData.m_pProperties->UpdateProperty(
                                                 DestServiceIdentity,
                                                 PropertyName,
                                                 VT_BSTR,
                                                 AcctPort
                                              );
    // Now update the service description (name)
    const WCHAR IASPath[] = 
                        L"Root\0"
                        L"Microsoft Internet Authentication Service\0";

    LONG        RefIASIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(IASPath, RefIASIdentity);

    LONG        DestIASIdentity;
    m_GlobalData.m_pObjects->WalkPath(IASPath, DestIASIdentity);


    PropertyName = L"Description";
    _bstr_t     Description;
    Type = 0;
    m_GlobalData.m_pRefProperties->GetPropertyByName(
                                                       RefIASIdentity,
                                                       PropertyName,
                                                       Type,
                                                       Description
                                                    );
    if ( Type != VT_BSTR )
    {
        _com_issue_error(E_UNEXPECTED);
    }
    
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 DestIASIdentity,
                                                 PropertyName,
                                                 VT_BSTR,
                                                 Description
                                              );
}


//////////////////////////////////////////////////////////////////////////////
// MigrateWin2kRealms
//
// Not used: msUserIdentityAlgorithm
// msManipulationRule
// msManipulationTarget (enum: 1, 30 or 31)
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::MigrateWin2kRealms()
{
    const WCHAR     DEFAULT_REALM_TARGET[] = L"1";
    const int       MAX_LONG_SIZE          = 32;

    /////////////////////////////////////////////////
    // Get the Microsoft Realms Evaluator's Identity
    /////////////////////////////////////////////////
    LPCWSTR     RealmPath = L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"RequestHandlers\0"
                            L"Microsoft Realms Evaluator\0";

    LONG        RealmIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(RealmPath, RealmIdentity);
    
    ///////////////////////////////////////////////
    // Get the Proxy Profiles container's Identity
    ///////////////////////////////////////////////
    LPCWSTR     ProxyProfilePath = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"Proxy Profiles\0";

    LONG        ProxyContainerIdentity;
    m_GlobalData.m_pObjects->WalkPath(
                                        ProxyProfilePath, 
                                        ProxyContainerIdentity
                                     );

    //////////////////////////////////////////////////////////////////////
    // Now get the first Object with the above container as parent.
    // this is the default proxy profile (it's localized: I can't search
    // for the name directly).
    //////////////////////////////////////////////////////////////////////
    _bstr_t     ObjectName; 
    LONG        ProxyProfileIdentity;
    HRESULT     hr = m_GlobalData.m_pObjects->GetObject(
                                                        ObjectName,
                                                        ProxyProfileIdentity,
                                                        ProxyContainerIdentity
                                                       );

    _com_util::CheckError(hr); 
    _bstr_t     PropertyName;
    LONG        Type;
    _bstr_t     StrVal;

    //////////////////////////
    // get all the properties
    //////////////////////////
    _com_util::CheckError(m_GlobalData.m_pRefProperties->GetProperty(
                                                    RealmIdentity,
                                                    PropertyName,
                                                    Type,
                                                    StrVal
                                                ));
    LONG        IndexProperty        = 1;
    LONG        NbPropertiesInserted = 0;
    _bstr_t     NewName              = L"msManipulationRule";
    
    while ( hr == S_OK )    
    {
        /////////////////////////////////////////
        // for each, if Name == L"Realms"
        // then add to the default proxy profile
        /////////////////////////////////////////
        if ( !lstrcmpiW(PropertyName, L"Realms") )
        {
            m_GlobalData.m_pProperties->InsertProperty(
                                                       ProxyProfileIdentity,
                                                       NewName,
                                                       Type,
                                                       StrVal
                                                            );
            ++NbPropertiesInserted;
        }

        hr = m_GlobalData.m_pRefProperties->GetNextProperty(
                                                         RealmIdentity,
                                                         PropertyName,
                                                         Type,
                                                         StrVal,
                                                         IndexProperty
                                                       );
        ++IndexProperty;
    };

    hr = S_OK;

    ////////////////////////////////////////////////////////////////
    // Check that an even number of msManipulationRule was inserted
    ////////////////////////////////////////////////////////////////
    if ( (NbPropertiesInserted % 2) )
    {
        /////////////////////////
        // Inconsistent database
        /////////////////////////
        _com_issue_error(E_FAIL);
    }

    //////////////////////////////////////////
    // No realm migrated: nothing else to set.
    //////////////////////////////////////////
    if ( !NbPropertiesInserted )
    {
        return;
    }

    /////////////////////////////////////
    // Now process the reg keys settings
    /////////////////////////////////////
    BOOL    OverRide     = m_Utils.OverrideUserNameSet();
    DWORD   IdentityAtt  = m_Utils.GetUserIdentityAttribute();
    BOOL    UserIdentSet = m_Utils.UserIdentityAttributeSet();

    if ( (IdentityAtt != 1) && (!OverRide) )
    {
        // log a warning / error for the user?
        // the new behavior will not be exactly the same as before
    }

    //////////////////////////////////////////////////
    // insert the UserIdentityAttribute if it was set.
    //////////////////////////////////////////////////
    _bstr_t TargetName = L"msManipulationTarget";
    _bstr_t TargetStrVal;
    if ( UserIdentSet )
    {
        WCHAR   TempString[MAX_LONG_SIZE];
        _ltow(IdentityAtt, TempString, 10); // base 10 will never change 
        // Add the msManipulationTarget Property based on the reg key
        // "SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy";
        // "User Identity Attribute"; // Attribute used to identify the user. 
        // If not set then default to RADIUS_ATTRIBUTE_USER_NAME 
        // (1: "User-Name")
        TargetStrVal = TempString;
    }
    else
    {
        // Not set in the registry: write the default
        TargetStrVal = DEFAULT_REALM_TARGET;
    }
    m_GlobalData.m_pProperties->InsertProperty(
                                                  ProxyProfileIdentity,
                                                  TargetName,
                                                  VT_I4,
                                                  TargetStrVal
                                              );
}


//////////////////////////////////////////////////////////////////////////////
// MigrateServerGroups
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::MigrateServerGroups()
{
    const WCHAR SvrGroupPath[] = 
                                L"Root\0"
                                L"Microsoft Internet Authentication Service\0"
                                L"RADIUS Server Groups\0";

    LONG        SvrGroupIdentity;
    m_GlobalData.m_pRefObjects->WalkPath(SvrGroupPath, SvrGroupIdentity);

    const WCHAR IASPath[] = L"Root\0"
                            L"Microsoft Internet Authentication Service\0";

    LONG        IASIdentity;
    m_GlobalData.m_pObjects->WalkPath(IASPath, IASIdentity);

    // delete the SvrGroups container and its content
    LONG        DestSvrGroupIdentity;
    m_GlobalData.m_pObjects->WalkPath(SvrGroupPath, DestSvrGroupIdentity);

    _com_util::CheckError(m_GlobalData.m_pObjects->DeleteObject(
                                                DestSvrGroupIdentity));

    // for each SvrGroup in src, copy it in dest with its properties.
    _com_util::CheckError(CopyTree(SvrGroupIdentity, IASIdentity)); 
}


//////////////////////////////////////////////////////////////////////////////
// Migrate
// migrate the content of a Win2k or Whistler DB before the proxy feature
// into a whistler DB.
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::Migrate()
{
    MigrateClients();
    MigrateProfilesPolicies(); 
    MigrateAccounting(); 
    MigrateEventLog();
    MigrateService();
    MigrateWin2kRealms();

    //////////////////////////////////////////////////////
    // Update the MSChap Authentication types (password)
    //////////////////////////////////////////////////////
    CUpdateMSCHAP    UpdateMSCHAP(m_GlobalData);
    UpdateMSCHAP.Execute();
}


//////////////////////////////////////////////////////////////////////////////
// UpdateWhistler
// migrate the content from a Whistler DB to a whistler DB.
// This is used by the netshell aaaa context
//////////////////////////////////////////////////////////////////////////////
void CMigrateContent::UpdateWhistler(const bool UpdateChapPasswords)
{
    MigrateClients();
    MigrateProfilesPolicies(); 
    MigrateAccounting(); 
    MigrateEventLog();
    MigrateService();
    MigrateProxyProfilesPolicies(); 
    MigrateServerGroups(); 

    if (UpdateChapPasswords)
    {
       //////////////////////////////////////////////////////
       // Update the MSChap Authentication types (password)
       //////////////////////////////////////////////////////
       CUpdateMSCHAP    UpdateMSCHAP(m_GlobalData);
       UpdateMSCHAP.Execute();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\globaltransaction.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      GlobalTransaction.h 
//
// Project:     Windows 2000 IAS
//
// Description: CGlobalTransaction
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _GLOBALTRANSACTION_H_3F0038C3_D139_4C04_BAF9_86F1E14A256C
#define _GLOBALTRANSACTION_H_3F0038C3_D139_4C04_BAF9_86F1E14A256C

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "nocopy.h"

class CGlobalTransaction  : private NonCopyable
{
protected:
    CGlobalTransaction()
                :m_StdInitialized(FALSE),
                 m_RefInitialized(FALSE),
                 m_DnaryInitialized(FALSE),
                 m_NT4Initialized(FALSE)
    {
    };

    ~CGlobalTransaction();

public:
    static CGlobalTransaction& Instance();
    void OpenStdDataSource(LPCWSTR   DataSourceName); 
    void OpenRefDataSource(LPCWSTR   DataSourceName);
    void OpenDnaryDataSource(LPCWSTR   DataSourceName); 
    void OpenNT4DataSource(LPCWSTR   DataSourceName); 
    void Commit();
    void Abort() throw();
    void MyCloseDataSources();

    CSession& GetStdSession() throw()
    {
        return m_StdSession; // private member returned
    }

    CSession& GetRefSession() throw()
    {
        return m_RefSession; // private member returned
    }

    CSession& GetNT4Session() throw()
    {
        return m_NT4Session; // private member returned
    }

    CSession& GetDnarySession() throw()
    {
        return m_DnarySession; // private member returned
    }

private:
    BOOL            m_StdInitialized;
    BOOL            m_RefInitialized;
    BOOL            m_DnaryInitialized;
    BOOL            m_NT4Initialized;

    CSession        m_StdSession;
    CSession        m_RefSession;
    CSession        m_DnarySession;
    CSession        m_NT4Session;

    CDataSource     m_StdDataSource;
    CDataSource     m_RefDataSource;
    CDataSource     m_DnaryDataSource;
    CDataSource     m_NT4DataSource;

    static CGlobalTransaction _instance;
};
#endif // _GLOBALTRANSACTION_H_3F0038C3_D139_4C04_BAF9_86F1E14A256C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\globaldata.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      GlobalData.h
//
// Project:     Windows 2000 IAS
//
// Description: CGlobalData class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _GLOBALDATA_H_F4CBA054_88A0_458D_8041_F59414862D5B
#define _GLOBALDATA_H_F4CBA054_88A0_458D_8041_F59414862D5B

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CAttributes;
class CClients;
class CDefaultProvider;
class CObjects;
class CProfileAttributeList;
class CProfiles;
class CProperties;
class CProviders;
class CRADIUSAttributeValues;
class CRealms;
class CRemoteRadiusServers;
class CServiceConfiguration;
class CVersion;


// Everything is public (struct) 
struct CGlobalData  
{
    CGlobalData() throw()
                :m_pAttributes(NULL),
                 m_pClients(NULL),
                 m_pDefaultProvider(NULL),
                 m_pObjects(NULL),
                 m_pProfileAttributeList(NULL),
                 m_pProfiles(NULL),
                 m_pProperties(NULL),
                 m_pProviders(NULL),
                 m_pRADIUSAttributeValues(NULL),
                 m_pRealms(NULL),
                 m_pRefObjects(NULL),
                 m_pRefProperties(NULL),
                 m_pRefVersion(NULL),
                 m_pRadiusServers(NULL),
                 m_pServiceConfiguration(NULL)
    {};

    ~CGlobalData()
    {
        Clean();
    };

    void    InitStandard(CSession& Session);
    void    InitRef(CSession& Session);

    void    InitNT4(CSession& Session); 
    void    InitDnary(CSession& Session);
    void    Clean() throw();

    CAttributes*            m_pAttributes;
    CClients*               m_pClients;
    CDefaultProvider*       m_pDefaultProvider;
    CObjects*               m_pObjects;
    CProfileAttributeList*  m_pProfileAttributeList;
    CProfiles*              m_pProfiles;
    CProperties*            m_pProperties;
    CProviders*             m_pProviders;
    CRADIUSAttributeValues* m_pRADIUSAttributeValues;
    CRealms*                m_pRealms;
    CObjects*               m_pRefObjects;
    CProperties*            m_pRefProperties;
    CVersion*               m_pRefVersion;
    CRemoteRadiusServers*   m_pRadiusServers;
    CServiceConfiguration*  m_pServiceConfiguration;
};

#endif // _GLOBALDATA_H_F4CBA054_88A0_458D_8041_F59414862D5B
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\globaltransaction.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      GlobalTransaction.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of CGlobalTransaction
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "GlobalTransaction.h"


CGlobalTransaction CGlobalTransaction::_instance;

CGlobalTransaction& CGlobalTransaction::Instance()
{
    return _instance;
}


CGlobalTransaction::~CGlobalTransaction()
{
    // an error-free upgrade will have commit called, then MyCloseDataSources
    // before the objects are destroyed.
    // that'll insure that the mdb files can be manipulated (no lock on them)

    // if it was not comited before, then abort.
    Abort();

    // close the datasources if needed
    MyCloseDataSources();
};

/////////////////////////////////////////////////////////////////////////////
// MyCloseDataSources
/////////////////////////////////////////////////////////////////////////////
void CGlobalTransaction::MyCloseDataSources()
{
    // then close the data sources
    if ( m_StdInitialized )
    {
        m_StdSession.Close();
        m_StdDataSource.Close();
        m_StdInitialized = FALSE;
    }

    if ( m_RefInitialized )
    {
        m_RefSession.Close();
        m_RefDataSource.Close();
        m_RefInitialized = FALSE;
    }

    if ( m_DnaryInitialized )
    {
        m_DnarySession.Close();
        m_DnaryDataSource.Close();
        m_DnaryInitialized = FALSE;
    }

    if ( m_NT4Initialized )
    {
        m_NT4Session.Close();
        m_NT4DataSource.Close();
        m_NT4Initialized = FALSE;
    }
}


/////////////////////////////////////////////////////////////////////////////
// Commit
/////////////////////////////////////////////////////////////////////////////
void CGlobalTransaction::Commit() 
{
    if ( m_StdInitialized )
    {
        _com_util::CheckError(m_StdSession.Commit(FALSE, XACTTC_SYNC, 0));
    }
}


/////////////////////////////////////////////////////////////////////////////
// Abort
/////////////////////////////////////////////////////////////////////////////
void CGlobalTransaction::Abort() 
{
    if ( m_StdInitialized )
    {
        m_StdSession.Abort(NULL, FALSE, FALSE ); // no check
    }
}


//////////////////////////////////////////////////////////////////////////
// OpenStdDataSource
//////////////////////////////////////////////////////////////////////////
void CGlobalTransaction::OpenStdDataSource(LPCWSTR   DataSourceName)
{
    CDBPropSet  dbinit(DBPROPSET_DBINIT);

    dbinit.AddProperty(DBPROP_INIT_DATASOURCE, DataSourceName);
    dbinit.AddProperty(DBPROP_INIT_MODE, static_cast<long>
                                                (DB_MODE_READWRITE)); 
    dbinit.AddProperty(DBPROP_INIT_PROMPT, static_cast<short>
                                                (DBPROMPT_NOPROMPT)); 
    _com_util::CheckError(m_StdDataSource.Open(
                                L"Microsoft.Jet.OLEDB.4.0", &dbinit
                                              ));

    _com_util::CheckError(m_StdSession.Open(m_StdDataSource));
    
    ULONG   TransactionLevel;
    _com_util::CheckError(m_StdSession.StartTransaction(
                                        ISOLATIONLEVEL_READCOMMITTED, 
                                        0,
                                        NULL, 
                                        &TransactionLevel
                                     ));
    m_StdInitialized = TRUE;            
}

//////////////////////////////////////////////////////////////////////////
// OpenRefDataSource
// No transaction (read only)
//////////////////////////////////////////////////////////////////////////
void CGlobalTransaction::OpenRefDataSource(LPCWSTR   DataSourceName)
{
    CDBPropSet  dbinit(DBPROPSET_DBINIT);

    dbinit.AddProperty(DBPROP_INIT_DATASOURCE, DataSourceName);
    dbinit.AddProperty(DBPROP_INIT_MODE, static_cast<long>(DB_MODE_READ)); 
    dbinit.AddProperty(DBPROP_INIT_PROMPT, static_cast<short>(DBPROMPT_NOPROMPT)); 
    
    _com_util::CheckError(m_RefDataSource.Open(
                                L"Microsoft.Jet.OLEDB.4.0", &dbinit
                                              ));
    
    _com_util::CheckError(m_RefSession.Open(m_RefDataSource));
    m_RefInitialized = TRUE;            
}


//////////////////////////////////////////////////////////////////////////
// OpenDnaryDataSource
// No transaction (read only)
//////////////////////////////////////////////////////////////////////////
void CGlobalTransaction::OpenDnaryDataSource(LPCWSTR   DataSourceName)
{
    CDBPropSet  dbinit(DBPROPSET_DBINIT);

    dbinit.AddProperty(DBPROP_INIT_DATASOURCE, DataSourceName);
    dbinit.AddProperty(DBPROP_INIT_MODE, static_cast<long>(DB_MODE_READ)); 
    dbinit.AddProperty(DBPROP_INIT_PROMPT, static_cast<short>(DBPROMPT_NOPROMPT)); 
    
    _com_util::CheckError(m_DnaryDataSource.Open(
                                L"Microsoft.Jet.OLEDB.4.0", &dbinit
                                                ));
    
    _com_util::CheckError(m_DnarySession.Open(m_DnaryDataSource));
    m_DnaryInitialized = TRUE;            
}


//////////////////////////////////////////////////////////////////////////
// OpenNT4DataSource
// No transaction (read only)
//////////////////////////////////////////////////////////////////////////
void CGlobalTransaction::OpenNT4DataSource(LPCWSTR   DataSourceName)
{
    CDBPropSet  dbinit(DBPROPSET_DBINIT);

    dbinit.AddProperty(DBPROP_INIT_DATASOURCE, DataSourceName);
    dbinit.AddProperty(DBPROP_INIT_MODE, static_cast<long>(DB_MODE_READ)); 
    dbinit.AddProperty(DBPROP_INIT_PROMPT, static_cast<short>(DBPROMPT_NOPROMPT)); 

    _com_util::CheckError(m_NT4DataSource.Open(
                                L"Microsoft.Jet.OLEDB.4.0", &dbinit
                                              ));
    
    _com_util::CheckError(m_NT4Session.Open(m_NT4DataSource));
    m_NT4Initialized = TRUE;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\migrateregistry.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999-2000 Microsoft Corporation all rights reserved.
//
// Module:      migrateregistry.cpp
//
// Project:     Windows 2000 IAS
//
// Description: IAS NT 4 Registry to IAS W2K MDB Migration Logic
//
// Author:      TLP 1/13/1999
//
//
// Revision     02/24/2000 Moved to a separate dll
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "migrateregistry.h"


//////////////////////////////////////////////////////////////////////////////
// DeleteAuthSrvService
//////////////////////////////////////////////////////////////////////////////
LONG CMigrateRegistry::DeleteAuthSrvService()
{
    LONG        Result = ERROR_CAN_NOT_COMPLETE;
    SC_HANDLE   hServiceManager;
    SC_HANDLE   hService;

    if ( NULL != (hServiceManager = OpenSCManager(
                                                    NULL, 
                                                    NULL, 
                                                    SC_MANAGER_ALL_ACCESS
                                                  )) )
    {
        if ( NULL != (hService = OpenService(
                                               hServiceManager,
                                               L"AuthSrv", 
                                               SERVICE_ALL_ACCESS
                                            )) )
        {
            DeleteService(hService);
            CloseServiceHandle(hService);
        }

        Result = ERROR_SUCCESS;
        CloseServiceHandle(hServiceManager);
    }
    return Result;
}


//////////////////////////////////////////////////////////////////////////////
// MigrateProviders
//////////////////////////////////////////////////////////////////////////////
void CMigrateRegistry::MigrateProviders()
{
    const   int     MAX_EXTENSION_DLLS_STRING_SIZE = 4096;
    const   WCHAR   AUTHSRV_KEY[] = L"SYSTEM\\CurrentControlSet"
                                    L"\\Services\\AuthSrv";

    const   WCHAR   AUTHSRV_PROVIDERS_EXTENSION_DLL_VALUE[] = L"ExtensionDLLs";

    HKEY    hKeyAuthSrvParameter;
    LONG    Result = RegOpenKeyEx(
                                      HKEY_LOCAL_MACHINE,
                                      CUtils::AUTHSRV_PARAMETERS_KEY,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hKeyAuthSrvParameter
                                  );

    if ( Result != ERROR_SUCCESS )
    {
        _com_issue_error(HRESULT_FROM_WIN32(Result));
    }

    BYTE    szProvidersExtensionDLLs[MAX_EXTENSION_DLLS_STRING_SIZE] = "";
    DWORD   lSizeBuffer = MAX_EXTENSION_DLLS_STRING_SIZE;

    LONG ExtensionDLLResult =  RegQueryValueEx(
                                 hKeyAuthSrvParameter,
                                 AUTHSRV_PROVIDERS_EXTENSION_DLL_VALUE,
                                 NULL,
                                 NULL,
                                 szProvidersExtensionDLLs,
                                 &lSizeBuffer
                             );

    RegCloseKey(hKeyAuthSrvParameter);

    DeleteAuthSrvService(); //ignore the result

    CRegKey  RegKey;
    Result = RegKey.Open(HKEY_LOCAL_MACHINE, CUtils::SERVICES_KEY);
    if ( Result == ERROR_SUCCESS )
    {
        RegKey.RecurseDeleteKey(L"AuthSrv"); //result not checked
    }

    if ( ExtensionDLLResult == ERROR_SUCCESS ) //ExtensionsDLLs to restore
    {
        HKEY    hKeyAuthSrv;
        DWORD   dwDisposition;
        WCHAR   EmptyString[] = L"";
        // re-create the AuthSrv key
        Result = RegCreateKeyEx(
                                   HKEY_LOCAL_MACHINE,
                                   AUTHSRV_KEY,
                                   0,
                                   EmptyString,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hKeyAuthSrv,
                                   &dwDisposition
                               );
        if ( Result != ERROR_SUCCESS )
        {
            _com_issue_error(HRESULT_FROM_WIN32(Result));
        }

        HKEY    hKeyParameters;
        Result = RegCreateKeyEx(
                                   hKeyAuthSrv,
                                   L"Parameters",
                                   0,
                                   EmptyString,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hKeyParameters,
                                   &dwDisposition
                               );


        if ( Result != ERROR_SUCCESS )
        {
            _com_issue_error(HRESULT_FROM_WIN32(Result));
        }

        Result = RegSetValueEx(
                                  hKeyParameters,
                                  AUTHSRV_PROVIDERS_EXTENSION_DLL_VALUE,
                                  0,
                                  REG_MULTI_SZ,
                                  szProvidersExtensionDLLs,
                                  lSizeBuffer
                              );

        RegCloseKey(hKeyParameters);
        RegCloseKey(hKeyAuthSrv);
    }
    // Else no ExtensionDLL value to restore
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\migratemdb.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999-2000 Microsoft Corporation all rights reserved.
//
// Module:      migratemdb.h
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of CMigrateMdb
//              Used only by the NT4 migration code
//
// Author:      tperraut
//
// Revision     02/25/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _MIGRATEMDB_H_852AA70D_D88D_4925_8D12_BE4A607723F5
#define _MIGRATEMDB_H_852AA70D_D88D_4925_8D12_BE4A607723F5

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"

class CMigrateMdb : private NonCopyable
{
public:
    explicit CMigrateMdb(
                            CUtils&         pUtils,
                            CGlobalData&    pGlobalData
                        )
                            : m_Utils(pUtils),
                              m_GlobalData(pGlobalData)
    {
    }

    void        NewMigrate();


private:
    void        ConvertVSA(
                             /*[in]*/ LPCWSTR     pAttributeValueName, 
                             /*[in]*/ LPCWSTR     pAttrValue,
                                      _bstr_t&    NewString
                          );

    void        NewMigrateClients();
    void        NewMigrateProfiles();
    void        NewMigrateAccounting(); 
    void        NewMigrateEventLog();
    void        NewMigrateService();
    void        MigrateProxyServers();
    void        MigrateCorpProfile(
                                     const _bstr_t& ProfileName,
                                     const _bstr_t& Description
                                  );
    void MigrateAttribute(
                             const _bstr_t&    Attribute,
                                   LONG        AttributeNumber,
                             const _bstr_t&    AttributeValueName,
                             const _bstr_t&    StringValue,
                                   LONG        RASProfileIdentity
                         );

    void ConvertAttribute(
                             const _bstr_t&  Value,
                                   LONG      Syntax,
                                   LONG&     Type,
                                   bstr_t&   StrVal
                         );

    void MigrateOtherProfile(
                                const _bstr_t&  ProfileName,
                                      LONG      ProfileIdentity
                            );

    CUtils&                  m_Utils;
    CGlobalData&             m_GlobalData;
};


#endif // _MIGRATEMDB_H_852AA70D_D88D_4925_8D12_BE4A607723F5_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\migratemdb.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999-2000 Microsoft Corporation all rights reserved.
//
// Module:      migratemdb.cpp
//
// Project:     Windows 2000 IAS
//
// Description: IAS NT 4 MDB to IAS W2K MDB Migration Logic
//
// Author:      TLP 1/13/1999
//
//
// Revision     02/24/2000 Moved to a separate dll
//              03/15/2000 Almost completely rewritten
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "Attributes.h"
#include "Clients.h"
#include "DefaultProvider.h"
#include "GlobalData.h"
#include "migratemdb.h"
#include "migrateregistry.h"
#include "Objects.h"
#include "Policy.h"
#include "Properties.h"
#include "Profiles.h"
#include "profileattributelist.h"
#include "Providers.h"
#include "proxyservergroupcollection.h"
#include "RadiusAttributeValues.h"
#include "Realms.h"
#include "RemoteRadiusServers.h"
#include "ServiceConfiguration.h"
#include "Version.h"
#include "updatemschap.h"

// To remember:
// IAS_MAX_VSA_LENGTH = (253 * 2);
// 1.0 Format Offsets
//VSA_OFFSET                   =  0;
//VSA_OFFSET_ID                =  0;
//VSA_OFFSET_TYPE              =  8;
//VSA_OFFSET_LENGTH            = 10;
//VSA_OFFSET_VALUE_RFC         = 12;
//VSA_OFFSET_VALUE_NONRFC      =  8;

// 2.0 Format Offsets
//VSA_OFFSET_NEW               =  2;
//VSA_OFFSET_ID_NEW            =  2;
//VSA_OFFSET_TYPE_NEW          = 10;
//VSA_OFFSET_LENGTH_NEW        = 12;
//VSA_OFFSET_VALUE_NONRFC_NEW  = 10;


//////////////////////////////////////////////////////////////////////////////
// Helper Functions
//////////////////////////////////////////////////////////////////////////////
/////// From inet.c in ias util directory /////////////
//////////
// Macro to test if a character is a digit.
//////////
#define IASIsDigit(p) ((_TUCHAR)(p - _T('0')) <= 9)

//////////
// Macro to strip one byte of an IP address from a character string.
//    'p'   pointer to the string to be parsed
//    'ul'  unsigned long that will receive the result.
//////////
#define STRIP_BYTE(p,ul) {                \
   if (!IASIsDigit(*p)) goto error;          \
   ul = *p++ - _T('0');                   \
   if (IASIsDigit(*p)) {                     \
      ul *= 10; ul += *p++ - _T('0');     \
      if (IASIsDigit(*p)) {                  \
         ul *= 10; ul += *p++ - _T('0');  \
      }                                   \
   }                                      \
   if (ul > 0xff) goto error;             \
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    ias_inet_addr
//
// DESCRIPTION
//
//    This function is similar to the WinSock inet_addr function (q.v.) except
//    it returns the address in host order and it can operate on both ANSI
//    and UNICODE strings.
//
///////////////////////////////////////////////////////////////////////////////
unsigned long __stdcall ias_inet_addr(const WCHAR* cp)
{
   unsigned long token;
   unsigned long addr;

   STRIP_BYTE(cp,addr);
   if (*cp++ != _T('.')) goto error;

   STRIP_BYTE(cp,token);
   if (*cp++ != _T('.')) goto error;
   addr <<= 8;
   addr  |= token;

   STRIP_BYTE(cp,token);
   if (*cp++ != _T('.')) goto error;
   addr <<= 8;
   addr  |= token;

   STRIP_BYTE(cp,token);
   addr <<= 8;
   return addr | token;

error:
   return 0xffffffff;
}


//////////////////////////////////////////////////////////////////////////////
// ConvertVSA
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::ConvertVSA(
                               /*[in]*/ LPCWSTR     pAttributeValueName, 
                               /*[in]*/ LPCWSTR     pAttrValue,
                                        _bstr_t&    NewString
                            )
{
    const long  IAS_MAX_VSA_LENGTH          = (253 * 2);
    const byte  VSA_OFFSET                  =  0;
    const byte  VSA_OFFSET_NEW              =  2;
    const byte  VSA_OFFSET_VALUE_RFC_NEW    = 14;

    wchar_t     szNewValue[IAS_MAX_VSA_LENGTH + 1];

    szNewValue[0] = '\0';

    // RFC compliant integer
    if ( ! lstrcmp(pAttributeValueName, L"URDecimal or Hexadecimal (0x.. "
                                        L"format) Integer") )
    {
        // Add the "02" as the type to the head of the string
        lstrcat(szNewValue,L"02"); 
        // Copy the old value to the new
        lstrcpy(szNewValue + VSA_OFFSET_NEW, pAttrValue + VSA_OFFSET);
        // Strip of the "0x" if necessary and convert to decimal
        if ( ! wcsncmp(&szNewValue[VSA_OFFSET_VALUE_RFC_NEW], L"0x", 2) )
        {
            lstrcpy(&szNewValue[VSA_OFFSET_VALUE_RFC_NEW],
                    &szNewValue[VSA_OFFSET_VALUE_RFC_NEW + 2] );
        }
    }
    // RFC compliant string
    else if ( ! lstrcmp(pAttributeValueName, L"URString") )
    {
        // Set the new string type to "01"
        lstrcat(szNewValue,L"01");
        // Copy the old string to the new
        lstrcpy(szNewValue + VSA_OFFSET_NEW, pAttrValue + VSA_OFFSET);
        // Convert the old hex formatted string to a BSTR (in place)
        wchar_t  wcSaved;
        wchar_t* pXlatPos = &szNewValue[VSA_OFFSET_VALUE_RFC_NEW];
        wchar_t* pNewCharPos = pXlatPos;
        wchar_t* pEnd;
        while ( *pXlatPos != '\0' )
        {
            wcSaved = *(pXlatPos + 2);
            *(pXlatPos + 2) = '\0';
            *pNewCharPos = (wchar_t) wcstol(pXlatPos, &pEnd, 16);
            *(pXlatPos + 2) = wcSaved;
            pXlatPos += 2;
            ++pNewCharPos;
        }
        *pNewCharPos = '\0';
    }
    // RFC compliant hex
    else if ( ! lstrcmp(pAttributeValueName, L"URHexadecimal") )
    {
        // Set the new type and copy the old string to the new
        lstrcat(szNewValue,L"03");
        lstrcpy(szNewValue + VSA_OFFSET_NEW, pAttrValue + VSA_OFFSET);
    }
    // Non RFC compliant (always hex)
    else if ( ! lstrcmp(pAttributeValueName, L"UHHexadecimal") )
    {
        // Set the new type and copy the old string to the new
        lstrcat(szNewValue,L"00");
        lstrcpy(szNewValue + VSA_OFFSET_NEW, pAttrValue + VSA_OFFSET);
    }
    // Error
    else
    {
        _ASSERT(FALSE);
    }

    // Return the new string
    NewString = szNewValue;
}


//////////////////////////////////////////////////////////////////////////////
// MigrateProxyServers 
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::MigrateProxyServers()
{
    const long DEFAULT_PRIORITY = 1;
    const long DEFAULT_WEIGHT   = 50;

    // If there isn't any servers.
    if ( m_GlobalData.m_pRadiusServers->IsEmpty() )
    {
        return;
    }

    CProxyServerGroupCollection& ServerCollection 
                        = CProxyServerGroupCollection::Instance();

    // Do a loop on the RadiusServers sorted by server group
    _bstr_t     CurrentGroupName;

    CProxyServersGroupHelper* pCurrentServerGroup = NULL; //avoid warning
    
    // CurrentGroupName will never match a name received therefore
    // pCurrentServerGroup will always be initialized before being used
    HRESULT hr;
    do 
    {
        _bstr_t GroupName = m_GlobalData.m_pRadiusServers->GetGroupName();
    
        if ( CurrentGroupName != GroupName )
        {
            CProxyServersGroupHelper ServerGroup(m_GlobalData);
            CurrentGroupName = GroupName;

            ServerGroup.SetName(GroupName);

            // Add a server to the collection
            pCurrentServerGroup = ServerCollection.Add(ServerGroup);
        }

        if ( !pCurrentServerGroup )
        {
            _com_issue_error(E_FAIL);
        }

        CProxyServerHelper  Server(m_GlobalData);

        _bstr_t ServerName = m_GlobalData.m_pRadiusServers->
                                                        GetProxyServerName();
        Server.SetAddress(ServerName);
        Server.SetAuthenticationPort(
            m_GlobalData.m_pRadiusServers->GetAuthenticationPortNumber()
                                    );
        Server.SetAccountingPort(
                m_GlobalData.m_pRadiusServers->GetAccountingPortNumber()
                                );
        _bstr_t Secret = m_GlobalData.m_pRadiusServers->GetSharedSecret();
        Server.SetAuthenticationSecret(Secret);
        Server.SetPriority(DEFAULT_PRIORITY);
        Server.SetWeight(DEFAULT_WEIGHT);

        pCurrentServerGroup->Add(Server); // cannot be NULL pointer

        hr = m_GlobalData.m_pRadiusServers->GetNext();
    } 
    while (hr == S_OK);
    // persist everything in the database
    ServerCollection.Persist();

    _com_util::CheckError(hr);
}   


//////////////////////////////////////////////////////////////////////////////
// NewMigrateClients 
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::NewMigrateClients()
{
    // If there isn't any client, return
    if ( m_GlobalData.m_pClients->IsEmpty() )
    {
        return;
    }

    // for each client in the client table, add it (blindly) to the dest table
    // i.e. walkpath to find the clients container
    // create the properties for that containes (clients).
    const WCHAR ClientContainerPath[] = 
                                L"Root\0"
                                L"Microsoft Internet Authentication Service\0"
                                L"Protocols\0"
                                L"Microsoft Radius Protocol\0"
                                L"Clients\0";

    LONG        ClientContainerIdentity;
    m_GlobalData.m_pObjects->WalkPath(
                                         ClientContainerPath, 
                                         ClientContainerIdentity
                                     );

    HRESULT     hr;
    do 
    {
        _bstr_t     ClientName   = m_GlobalData.m_pClients->GetHostName();
        _bstr_t     ClientSecret = m_GlobalData.m_pClients->GetSecret();
    
        LONG    ClientIdentity;
        m_GlobalData.m_pObjects->InsertObject(
                                                ClientName, 
                                                ClientContainerIdentity,
                                                ClientIdentity
                                               );

        // Now insert the properties:
        // IP Address
        _bstr_t PropertyName = L"IP Address";
        m_GlobalData.m_pProperties->InsertProperty(
                                                     ClientIdentity,
                                                     PropertyName,
                                                     VT_BSTR,
                                                     ClientName
                                                  );
        // NAS Manufacturer
        PropertyName = L"NAS Manufacturer";
        _bstr_t     StrValZero = L"0"; // RADIUS Standard  
        m_GlobalData.m_pProperties->InsertProperty(
                                                     ClientIdentity,
                                                     PropertyName,
                                                     VT_I4,
                                                     StrValZero
                                                  );
        // Require Signature
        PropertyName = L"Require Signature";
        m_GlobalData.m_pProperties->InsertProperty(
                                                     ClientIdentity,
                                                     PropertyName,
                                                     VT_BOOL,
                                                     StrValZero
                                                  );
        // Shared Secret
        PropertyName = L"Shared Secret";
        m_GlobalData.m_pProperties->InsertProperty(
                                                     ClientIdentity,
                                                     PropertyName,
                                                     VT_BSTR,
                                                     ClientSecret
                                                  );
        hr = m_GlobalData.m_pClients->GetNext();
    }
    while ( hr == S_OK );

    _com_util::CheckError(hr);
}


//////////////////////////////////////////////////////////////////////////////
// ConvertAttribute
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::ConvertAttribute(
                                      const _bstr_t&    Value,
                                            LONG        Syntax,
                                            LONG&       Type,
                                            bstr_t&     StrVal
                                  )
{
    const size_t    SIZE_LONG_MAX = 14;
    switch (Syntax)
    {
      case IAS_SYNTAX_OCTETSTRING:
        {
            // abinary => OctetString
            Type = VT_BSTR;
            StrVal = Value;
            break;
        }

    case IAS_SYNTAX_STRING:
    case IAS_SYNTAX_UTCTIME:
    case IAS_SYNTAX_PROVIDERSPECIFIC:
        {
            Type = VT_BSTR;
            StrVal = Value;
            break;
        }
    case IAS_SYNTAX_INETADDR:
        {
            unsigned long ulValue = ias_inet_addr(Value);
            _ASSERT( ulValue != 0xffffffff );
            Type = VT_I4;
            WCHAR   TempString[SIZE_LONG_MAX];
            StrVal = _ultow(ulValue, TempString, 10);
            break;
        }
    case IAS_SYNTAX_BOOLEAN:            
        {
            LONG lValue = _wtol(Value);
            Type = VT_BOOL;
            StrVal = lValue? L"-1":L"0";
            break;
        }
    case IAS_SYNTAX_INTEGER:
    case IAS_SYNTAX_UNSIGNEDINTEGER:    
    case IAS_SYNTAX_ENUMERATOR:         
        {
            Type = VT_I4;
            StrVal = Value;
            break;
        }
    default:
        {
            _com_issue_error(E_INVALIDARG);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
// MigrateAttribute
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::MigrateAttribute(
                                      const _bstr_t&    Attribute,
                                            LONG        AttributeNumber,
                                      const _bstr_t&    AttributeValueName,
                                      const _bstr_t&    StringValue,
                                            LONG        RASProfileIdentity
                                  ) 
{
    // Note: Order might not be needed if the previous DB is always sorted
    const size_t    SIZE_LONG_MAX = 14;
    _bstr_t         LDAPName, StrVal;
    LONG            Syntax, Type; // Type: VT_BSTR, VT_I4, VT_BOOL 
    BOOL            IsMultiValued;
    HRESULT hr = m_GlobalData.m_pAttributes->GetAttribute(
                                                            AttributeNumber,
                                                            LDAPName,
                                                            Syntax,
                                                            IsMultiValued
                                                         );
    if ( FAILED(hr) )
    {
        // Attribute unknown in the new dictionary
        // that should never happen 
        return;
    }

    const LONG VSA = 26; //Vendor-Specific-Attribute
    if ( StringValue.length() && ( AttributeNumber != VSA) )
    {
        // ordinary attribute, not an enumerator
        ConvertAttribute(
                            StringValue,
                            Syntax,
                            Type,
                            StrVal
                        );
        if ( IsMultiValued )
        {
            // If the attribute is multivalued then we need to add the value 
            // Otherwise we just update the attribute value
            m_GlobalData.m_pProperties->InsertProperty(
                                                          RASProfileIdentity,
                                                          LDAPName,
                                                          Type,
                                                          StrVal
                                                      );
        }
        else
        {
            m_GlobalData.m_pProperties->UpdateProperty(
                                                          RASProfileIdentity,
                                                          LDAPName,
                                                          Type,
                                                          StrVal
                                                      );
        }
    }
    else if ( StringValue.length() && ( AttributeNumber == VSA) )
    {
        // VSA Attribute (convert...)
        if ( !AttributeValueName )
        {
            _com_issue_error(E_INVALIDARG);
        }
        ConvertVSA(AttributeValueName, StringValue, StrVal);
        Type = VT_BSTR;
        m_GlobalData.m_pProperties->InsertProperty(
                                                      RASProfileIdentity,
                                                      LDAPName,
                                                      Type,
                                                      StrVal
                                                  );
    }
    else if ( !StringValue.length() )
    {
        // Multivalued attribute.
        Type = VT_I4;
        // Get the number associated with it from the RadiusAttributeValues
        // table
        LONG Number = m_GlobalData.m_pRADIUSAttributeValues->GetAttributeNumber
                                                        (
                                                            Attribute,
                                                            AttributeValueName
                                                        );

        WCHAR   TempString[SIZE_LONG_MAX ];
        StrVal = _ltow(Number, TempString, 10);
        
        // The attribute should be multivalued 
        _ASSERTE(IsMultiValued);
        m_GlobalData.m_pProperties->InsertProperty(
                                                      RASProfileIdentity,
                                                      LDAPName,
                                                      Type,
                                                      StrVal
                                                  );

    }
    else
    {
        // other (unknown)
        _com_issue_error(E_FAIL);
    }
}


//////////////////////////////////////////////////////////////////////////////
// MigrateOtherProfile
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::MigrateOtherProfile(
                                        const _bstr_t&    ProfileName,
                                              LONG        ProfileIdentity
                                     )
{
    _bstr_t    Attribute, AttributeValueName, StringValue;
    LONG       Order, AttributeNumber;

    // Now add the attributes from the NT4 file
    HRESULT hr = m_GlobalData.m_pProfileAttributeList->GetAttribute(
                                                         ProfileName,
                                                         Attribute,
                                                         AttributeNumber,
                                                         AttributeValueName,
                                                         StringValue,
                                                         Order
                                                                   );
    LONG    IndexAttribute = 1;
    // For each attribute in the Profile Attribute List
    // with szProfile = ProfileName
    while ( SUCCEEDED(hr) )
    {
        // migrate it to the default RAS profile in IAS.mdb
        MigrateAttribute(
                            Attribute,
                            AttributeNumber,
                            AttributeValueName,
                            StringValue,
                            ProfileIdentity
                        );        

        hr = m_GlobalData.m_pProfileAttributeList->GetAttribute(
                                                        ProfileName,
                                                        Attribute,
                                                        AttributeNumber,
                                                        AttributeValueName,
                                                        StringValue,
                                                        Order,
                                                        IndexAttribute
                                                               );
        ++IndexAttribute;
    }
}


//////////////////////////////////////////////////////////////////////////////
// MigrateCorpProfile
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::MigrateCorpProfile(
                                        const _bstr_t& ProfileName,
                                        const _bstr_t& Description
                                    )
{
    _bstr_t    Attribute, AttributeValueName, StringValue;
    LONG       Order, AttributeNumber;

    // empty the default profiles attributes
    const WCHAR RASProfilePath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"RadiusProfiles\0";

    LONG        RASProfileIdentity;
    m_GlobalData.m_pObjects->WalkPath(RASProfilePath, RASProfileIdentity);
    
    // Now get the first profile: that's the default (localized) RAS profile
    _bstr_t     DefaultProfileName;
    LONG        DefaultProfileIdentity;
    m_GlobalData.m_pObjects->GetObject(
                                          DefaultProfileName, 
                                          DefaultProfileIdentity,
                                          RASProfileIdentity
                                      );

    // Clean the default attributes
    m_GlobalData.m_pProperties->DeleteProperty(
                                                 DefaultProfileIdentity, 
                                                 L"msRADIUSServiceType"
                                              );
    m_GlobalData.m_pProperties->DeleteProperty(
                                                 DefaultProfileIdentity, 
                                                 L"msRADIUSFramedProtocol"
                                              );

    // Now add the attributes from the NT4 file
    HRESULT hr = m_GlobalData.m_pProfileAttributeList->GetAttribute(
                                                         ProfileName,
                                                         Attribute,
                                                         AttributeNumber,
                                                         AttributeValueName,
                                                         StringValue,
                                                         Order
                                                                   );
    LONG    IndexAttribute = 1;
    // For each attribute in the Profile Attribute List
    // with szProfile = ProfileName
    while ( SUCCEEDED(hr) )
    {
        // migrate it to the default RAS profile in IAS.mdb
        MigrateAttribute(
                            Attribute,
                            AttributeNumber,
                            AttributeValueName,
                            StringValue,
                            DefaultProfileIdentity
                        );        

        hr = m_GlobalData.m_pProfileAttributeList->GetAttribute(
                                                        ProfileName,
                                                        Attribute,
                                                        AttributeNumber,
                                                        AttributeValueName,
                                                        StringValue,
                                                        Order,
                                                        IndexAttribute
                                                               );
        ++IndexAttribute;
    }

    // now not matter what, if Description == ODBC, 
    // Then the policy should have a condition to never match. 
    // (update msNPConstraint
    const _bstr_t   BadProvider = L"ODBC";
    if ( Description == BadProvider ) //safe compare
    {
        // Get the Policy container
        const WCHAR RASPolicyPath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"NetworkPolicy\0";
        // Get its (unique) child
        LONG        RASPolicyIdentity;
        m_GlobalData.m_pObjects->WalkPath(RASPolicyPath, RASPolicyIdentity);
    
        // Now get the first policy: that's the default (localized) RAS policy
        _bstr_t     DefaultPolicyName;
        LONG        DefaultPolicyIdentity;
        m_GlobalData.m_pObjects->GetObject(
                                              DefaultPolicyName, 
                                              DefaultPolicyIdentity,
                                              RASPolicyIdentity
                                          );
        // delete the msNPConstraint (s)
        const _bstr_t Constraint = L"msNPConstraint";
        m_GlobalData.m_pProperties->DeleteProperty(
                                                        DefaultPolicyIdentity, 
                                                        Constraint
                                                    );
        // add a TIMEOFDAY that never matches
        const _bstr_t DumbTime = L"TIMEOFDAY(\"\")";
        m_GlobalData.m_pProperties->InsertProperty( 
                                                     RASPolicyIdentity,
                                                     Constraint,
                                                     VT_BSTR,
                                                     DumbTime
                                                  );
    }
}


//////////////////////////////////////////////////////////////////////////////
// NewMigrateProfiles
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::NewMigrateProfiles()
{
    const LONG      AUTH_PROVIDER_WINDOWS       = 1;
    const LONG      AUTH_PROVIDER_RADIUS_PROXY  = 2;
    const LONG      ACCT_PROVIDER_RADIUS_PROXY  = 2;
    const _bstr_t   RemoteRADIUSServers         = L"Remote RADIUS Servers";
    const _bstr_t   MCIS                        = L"MCIS";
    const _bstr_t   MCISv2                      = L"MCIS version 2.0";
    const _bstr_t   ODBC                        = L"ODBC";
    const _bstr_t   WindowsNT                   = L"Windows NT";
    const _bstr_t   MatchAll = L"TIMEOFDAY(\"0 00:00-24:00; 1 00:00"
            L"-24:00; 2 00:00-24:00; 3 00:00-24:00; 4 00:00-24:00; 5 00:"
            L"00-24:00; 6 00:00-24:00\")";
    
    // Get the Default Provider's data
    _bstr_t        DPUserDefinedName, DPProfile;
    VARIANT_BOOL   DPForwardAccounting, DPSupressAccounting
                 , DPLogoutAccounting;

    m_GlobalData.m_pDefaultProvider->GetDefaultProvider(
                                          DPUserDefinedName,
                                          DPProfile,
                                          DPForwardAccounting,
                                          DPSupressAccounting,
                                          DPLogoutAccounting
                                      );
    _bstr_t ProfileName = m_GlobalData.m_pProfiles->GetProfileName();

    // Do the NT4 CORP migration first if needed
    if ( m_Utils.IsNT4Corp() )
    {
        // This is NT4 CORP. migrate the default profile into 
        // the default policy/profile (not the proxy default)
        _bstr_t     Description = m_GlobalData.m_pProviders->
                            GetProviderDescription(DPUserDefinedName);

        MigrateCorpProfile(ProfileName, Description);
        
        // stop here
        return;
    }
    // Now that is not a NT4 CORP migration

    // Delete the default Proxy Policy / profile
    const WCHAR ProxyPoliciesPath[] = 
                        L"Root\0"
                        L"Microsoft Internet Authentication Service\0"
                        L"Proxy Policies\0";

    LONG        ProxyPolicyIdentity;
    m_GlobalData.m_pObjects->WalkPath(ProxyPoliciesPath, ProxyPolicyIdentity);

    // Now get the first profile: that's the default (localized) RAS policy
    _bstr_t     DefaultPolicyName;
    LONG        DefaultPolicyIdentity;
    m_GlobalData.m_pObjects->GetObject(
                                          DefaultPolicyName, 
                                          DefaultPolicyIdentity,
                                          ProxyPolicyIdentity
                                      );
    m_GlobalData.m_pObjects->DeleteObject(DefaultPolicyIdentity);
    // From now on the default proxy policy / profile is deleted

    // Now empty the default RAS profiles attributes
    const WCHAR RASProfilePath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"RadiusProfiles\0";

    LONG        RASProfileIdentity;
    m_GlobalData.m_pObjects->WalkPath(RASProfilePath, RASProfileIdentity);
    
    // Now get the first profile: that's the default (localized) RAS profile
    _bstr_t     DefaultProfileName;
    LONG        DefaultProfileIdentity;
    m_GlobalData.m_pObjects->GetObject(
                                          DefaultProfileName, 
                                          DefaultProfileIdentity,
                                          RASProfileIdentity
                                      );

    // Clean the default attributes
    m_GlobalData.m_pProperties->DeleteProperty(
                                                 DefaultProfileIdentity, 
                                                 L"msRADIUSServiceType"
                                              );
    m_GlobalData.m_pProperties->DeleteProperty(
                                                 DefaultProfileIdentity, 
                                                 L"msRADIUSFramedProtocol"
                                              );

    // from now on the default RAS profile has its default attributes (the one 
    // in the Advanced tab in the UI) deleted.

    HRESULT     hr;
    LONG        Sequence = 1;
    // Get the list of the profiles
    do
    {
        LONG    RealmIndex = 0;
        ProfileName = m_GlobalData.m_pProfiles->GetProfileName();
        
        // Note: hr should be set only by GetRealmIndex
        do
        {
            // Get the realms associated with that profile
            CPolicy             TempPolicy;
            hr = m_GlobalData.m_pRealms->GetRealmIndex(ProfileName,RealmIndex);
            if ( hr != S_OK )
            {
                // exit that internal do / while  to get the next profile
                break;
            }
            _bstr_t     RealmName = m_GlobalData.m_pRealms->GetRealmName();
            TempPolicy.SetmsNPAction(RealmName);

            ++RealmIndex;
            
            // That will set the realm part of the profile based on the 
            // values in NT4 as well as the reg keys values
            m_GlobalData.m_pRealms->SetRealmDetails(
                                                      TempPolicy, 
                                                      m_Utils
                                                   );

        
            _bstr_t     UserDefinedName = m_GlobalData.m_pRealms
                                               ->GetUserDefinedName();
            // Look up the provider in the providers table. Note: Assume 
            // the proxy servers (and groups) are already migrated.
            _bstr_t ProviderDescription = m_GlobalData.m_pProviders
                                    ->GetProviderDescription(UserDefinedName);

            // Set the sequence order
            TempPolicy.SetmsNPSequence(Sequence);

            // Now set the authentication provider
            if ( ProviderDescription == RemoteRADIUSServers )
            {
                TempPolicy.SetmsAuthProviderType(
                                                  AUTH_PROVIDER_RADIUS_PROXY,
                                                  UserDefinedName
                                                );
            }
            else if ( ( ProviderDescription == MCIS )     || 
                      ( ProviderDescription == MCISv2 )   ||
                      ( ProviderDescription == WindowsNT ) )
            {
                TempPolicy.SetmsAuthProviderType(AUTH_PROVIDER_WINDOWS);
            }
            else if ( ProviderDescription == ODBC )
            {
                // If ODBC is the authentication provider, 
                // then convert that realm into a policy that would never match. 
                // Authentication provider should be NT Domain.
                TempPolicy.SetmsAuthProviderType(AUTH_PROVIDER_WINDOWS);
                const _bstr_t MatchNothing = L"TIMEOFDAY(\"\")";
                TempPolicy.SetmsNPConstraint(MatchNothing);
            }
            else
            {
                _com_issue_error(E_INVALIDARG);
            }

            // persist the policy
            LONG    ProfileIdentity = TempPolicy.Persist(m_GlobalData);
            
            // migrate the profile associated with that policy
            MigrateOtherProfile(ProfileName, ProfileIdentity);
        
            ++Sequence;
        } while (hr == S_OK);
        
        hr = m_GlobalData.m_pProfiles->GetNext();
    } while ( hr == S_OK );
    
    if ( DPUserDefinedName.length() )
    {
        // there is a default provider: a default policy needs to be created
        // same logic as above (mostly)
        CPolicy     DefaultPolicy;
        DefaultPolicy.SetmsNPAction(DPProfile);

        _bstr_t ProviderDescription = m_GlobalData.m_pProviders
                                ->GetProviderDescription(DPUserDefinedName);

        if ( ProviderDescription == RemoteRADIUSServers )
        {
            DefaultPolicy.SetmsAuthProviderType(
                                                  AUTH_PROVIDER_RADIUS_PROXY,
                                                  DPUserDefinedName
                                               );
            DefaultPolicy.SetmsNPConstraint(MatchAll);
        }
        else if ( ( ProviderDescription == MCIS )     || 
                  ( ProviderDescription == MCISv2 )   ||
                  ( ProviderDescription == WindowsNT ) )
        {
            DefaultPolicy.SetmsNPConstraint(MatchAll);
            DefaultPolicy.SetmsAuthProviderType(AUTH_PROVIDER_WINDOWS);
        }
        else if ( ProviderDescription == ODBC )
        {
            // If ODBC is the authentication provider, 
            // then convert that realm into a policy that would never match. 
            // Authentication provider should be NT Domain.
            DefaultPolicy.SetmsAuthProviderType(AUTH_PROVIDER_WINDOWS);
            const _bstr_t MatchNothing = L"TIMEOFDAY(\"\")";
            DefaultPolicy.SetmsNPConstraint(MatchNothing);
        }
        else
        {
            _com_issue_error(E_INVALIDARG);
        }
      
        DefaultPolicy.SetmsNPSequence(Sequence);
        if ( DPForwardAccounting )
        {
            DefaultPolicy.SetmsAcctProviderType(ACCT_PROVIDER_RADIUS_PROXY);
        }
    
        LONG    ProfileIdentity = DefaultPolicy.Persist(m_GlobalData);

        MigrateOtherProfile(DPProfile, ProfileIdentity);
    }
    // else no default provider: no default policy
}


//////////////////////////////////////////////////////////////////////////////
// NewMigrateAccounting
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::NewMigrateAccounting()
{
    const WCHAR AccountingPath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"RequestHandlers\0"
                            L"Microsoft Accounting\0";

    LONG        AccountingIdentity;
    m_GlobalData.m_pObjects->WalkPath(AccountingPath, AccountingIdentity);

    _bstr_t MaxLogSize = m_GlobalData.m_pServiceConfiguration->GetMaxLogSize();

    _bstr_t LogFrequency = m_GlobalData.m_pServiceConfiguration->
                                                    GetLogFrequency();


    _bstr_t PropertyName = L"New Log Frequency";
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 AccountingIdentity,
                                                 PropertyName,
                                                 VT_I4,
                                                 LogFrequency
                                              );
 
    PropertyName = L"New Log Size";
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 AccountingIdentity,
                                                 PropertyName,
                                                 VT_I4,
                                                 MaxLogSize
                                              );
    DWORD   Value;
    m_Utils.NewGetAuthSrvParameter(L"LogAuthentications", Value);

    _bstr_t     LogAuth;
    Value ? LogAuth = L"-1": LogAuth = L"0";

    PropertyName = L"Log Authentication Packets";
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 AccountingIdentity,
                                                 PropertyName,
                                                 VT_BOOL,
                                                 LogAuth
                                              );

    m_Utils.NewGetAuthSrvParameter(L"LogAccounting", Value);

    _bstr_t     LogAcct;
    Value ? LogAcct = L"-1": LogAcct = L"0";

    PropertyName = L"Log Accounting Packets";
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 AccountingIdentity,
                                                 PropertyName,
                                                 VT_BOOL,
                                                 LogAcct
                                              );

    _bstr_t     FormatIAS1 = L"0";
    PropertyName = L"Log Format";
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 AccountingIdentity,
                                                 PropertyName,
                                                 VT_I4,
                                                 FormatIAS1
                                              );
}


//////////////////////////////////////////////////////////////////////////////
// NewMigrateEventLog
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::NewMigrateEventLog()
{
    const WCHAR EventLogPath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"Auditors\0"
                            L"Microsoft NT Event Log Auditor\0";

    LONG        EventLogIdentity;
    m_GlobalData.m_pObjects->WalkPath(EventLogPath, EventLogIdentity);

    DWORD   Value;
    m_Utils.NewGetAuthSrvParameter(L"LogData", Value);

    _bstr_t     LogData;
    Value ? LogData = L"-1": LogData = L"0";

    _bstr_t PropertyName = L"Log Verbose";
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 EventLogIdentity,
                                                 PropertyName,
                                                 VT_BOOL,
                                                 LogData
                                              );

    m_Utils.NewGetAuthSrvParameter(L"LogBogus", Value);

    _bstr_t     LogBogus;
    Value ? LogBogus = L"-1": LogBogus = L"0";

    PropertyName = L"Log Malformed Packets";
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 EventLogIdentity,
                                                 PropertyName,
                                                 VT_BOOL,
                                                 LogBogus
                                              );
}


//////////////////////////////////////////////////////////////////////////////
// NewMigrateService
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::NewMigrateService()
{
    const LONG  PORT_SIZE_MAX = 34;
    const WCHAR ServicePath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"Protocols\0"
                            L"Microsoft Radius Protocol\0";

    LONG        ServiceIdentity;

    m_GlobalData.m_pObjects->WalkPath(ServicePath, ServiceIdentity);


    DWORD       Value;
    m_Utils.NewGetAuthSrvParameter(L"RadiusPort", Value);

    WCHAR       TempString[PORT_SIZE_MAX];
    _bstr_t     RadiusPort = _ultow(Value, TempString, 10);


    _bstr_t     PropertyName = L"Authentication Port";
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 ServiceIdentity,
                                                 PropertyName,
                                                 VT_BSTR,
                                                 RadiusPort
                                              );

    m_Utils.NewGetAuthSrvParameter(L"AcctPort", Value);

    _bstr_t     AcctPort = _ltow(Value, TempString, 10);


    PropertyName = L"Accounting Port";
    m_GlobalData.m_pProperties->UpdateProperty(
                                                 ServiceIdentity,
                                                 PropertyName,
                                                 VT_BSTR,
                                                 AcctPort
                                              );
}


//////////////////////////////////////////////////////////////////////////////
// NewMigrate
//////////////////////////////////////////////////////////////////////////////
void CMigrateMdb::NewMigrate()
{
    NewMigrateClients();

    if ( !m_Utils.IsNT4Corp() ) // it's either Win2k or NT4 ISP
    {
        // the proxy servers must be migrated before the policies and
        // profiles 
        MigrateProxyServers();
    }
    
    NewMigrateProfiles();
    NewMigrateAccounting(); 
    NewMigrateEventLog();
    NewMigrateService();

    /////////////////////////////
    // Migrate the Registry Keys
    /////////////////////////////
    CMigrateRegistry    MigrateRegistry(m_Utils);
    MigrateRegistry.MigrateProviders();

    //////////////////////////////////////////////////////
    // Update the MSChap Authentication types (password)
    //////////////////////////////////////////////////////
    CUpdateMSCHAP    UpdateMSCHAP(m_GlobalData);
    UpdateMSCHAP.Execute();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\objects.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Objects.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of the CObjects class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "objects.h"

CObjects::CObjects(CSession& CurrentSession)
                   :m_ObjectsCommandPath(CurrentSession),
                    m_ObjectsCommandIdentity(CurrentSession),
                    m_ObjectsCommandDelete(CurrentSession),
                    m_ObjectsCommandNameParent(CurrentSession),
                    m_ObjectsCommandGet(CurrentSession),
                    m_ObjectsCommandInsert(CurrentSession)
{
};


//////////////////////////////////////////////////////////////////////////
// Destructor
//////////////////////////////////////////////////////////////////////////
CObjects::~CObjects()
{

};


//////////////////////////////////////////////////////////////////////////
// GetObject 
//////////////////////////////////////////////////////////////////////////
HRESULT CObjects::GetObject(
                               _bstr_t&     Name, 
                               LONG&        Identity, 
                               LONG         Parent
                           )
{
    return m_ObjectsCommandGet.GetObject(Name, Identity, Parent);
}


//////////////////////////////////////////////////////////////////////////
// GetNextObject 
//////////////////////////////////////////////////////////////////////////
HRESULT CObjects::GetNextObject(  
                                   _bstr_t& Name, 
                                   LONG&    Identity, 
                                   LONG     Parent, 
                                   LONG     Index
                               )
{ 
    return m_ObjectsCommandGet.GetObject(
                                            Name, 
                                            Identity, 
                                            Parent, 
                                            Index
                                        );
}


//////////////////////////////////////////////////////////////////////////
// WalkPath
//////////////////////////////////////////////////////////////////////////
void CObjects::WalkPath(
                            LPCWSTR     Path, 
                            LONG&       Identity, 
                            LONG        Parent // = 1 defined in header
                       ) 
{
    m_ObjectsCommandPath.WalkPath(Path, Identity, Parent);
}


//////////////////////////////////////////////////////////////////////////
// GetObjectIdentity
//////////////////////////////////////////////////////////////////////////
HRESULT CObjects::GetObjectIdentity(
                                       _bstr_t& Name, 
                                       LONG&    Parent, 
                                       LONG     Identity
                                   ) 
{
    return  m_ObjectsCommandIdentity.GetObjectIdentity(
                                                        Name, 
                                                        Parent, 
                                                        Identity
                                                      );
}


//////////////////////////////////////////////////////////////////////////
// GetObjectNameParent
//////////////////////////////////////////////////////////////////////////
HRESULT CObjects::GetObjectNameParent(
                                         const _bstr_t&    Name, 
                                               LONG        Parent, 
                                               LONG&       Identity
                                     ) 
{
    return  m_ObjectsCommandNameParent.GetObjectNameParent(
                                                              Name, 
                                                              Parent, 
                                                              Identity
                                                          );
}


//////////////////////////////////////////////////////////////////////////
// DeleteObject
//////////////////////////////////////////////////////////////////////////
HRESULT CObjects::DeleteObject(LONG Identity) 
{
    return  m_ObjectsCommandDelete.DeleteObject(Identity);
}


//////////////////////////////////////////////////////////////////////////
// InsertObject
//////////////////////////////////////////////////////////////////////////
BOOL CObjects::InsertObject(
                               const _bstr_t&   Name,
                                     LONG       Parent,
                                     LONG&      Identity
                           ) 
{
    return m_ObjectsCommandInsert.InsertObject(
                                                  Name, 
                                                  Parent, 
                                                  Identity
                                              );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\objectscommand.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ObjectsCommand.H 
//
// Project:     Windows 2000 IAS
//
// Description: Declaration of the the Object Commands classes
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Objects.h"

//////////////////////////////////////////////////////////////////////////////
// class CObjectsCommandGet 
//////////////////////////////////////////////////////////////////////////////

CObjects::CObjectsCommandGet::CObjectsCommandGet(CSession& CurrentSession)
{
    Init(CurrentSession);
}


/////////////
// GetObject 
/////////////
HRESULT CObjects::CObjectsCommandGet::GetObject(
                                                  _bstr_t&    Name, 
                                                  LONG&       Identity, 
                                                  LONG        Parent
                                               ) 
{
    m_ParentParam = Parent;
    HRESULT hr = BaseExecute();
    if ( SUCCEEDED(hr) )
    {
        Identity = m_Identity;
        Name     = m_Name;
    }
    return hr;
}


/////////////////////////
// GetObject overloaded
/////////////////////////
HRESULT CObjects::CObjectsCommandGet::GetObject(
                                        _bstr_t&    Name, 
                                        LONG&       Identity, 
                                        LONG        Parent, 
                                        LONG        Index
                                     ) 
{
    m_ParentParam = Parent;

    HRESULT hr = BaseExecute(Index);
    if ( SUCCEEDED(hr) )
    {
        Identity = m_Identity;
        Name     = m_Name;
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// class CObjectsCommandPath 
//////////////////////////////////////////////////////////////////////////////

CObjects::CObjectsCommandPath::CObjectsCommandPath(CSession& CurrentSession)
{
    Init(CurrentSession);
}


////////////
// WalkPath
////////////
void CObjects::CObjectsCommandPath::WalkPath(
                                        LPCWSTR     Path, 
                                        LONG&       Identity, 
                                        LONG        Parent // = 1 in header
                                            ) 
{
    _ASSERTE(Path);
    if ( !Path )
    {
        _com_issue_error(E_INVALIDARG);
    }

    LONG    CurrentParent = Parent;

    const WCHAR *p = Path;
    while ( *p ) // ok to dereference
    {
        m_ParentParam = CurrentParent;
        lstrcpynW(m_NameParam, p, NAME_SIZE);

        _com_util::CheckError(BaseExecute());
        CurrentParent = m_Identity;
        p += lstrlenW(p);
        // go past the \0
        ++p;
    }
    Identity = CurrentParent;
}

//////////////////////////////////////////////////////////////////////////////
// class CObjectsCommandIdentity
//////////////////////////////////////////////////////////////////////////////
CObjects::CObjectsCommandIdentity::CObjectsCommandIdentity(
                                                    CSession& CurrentSession
                                                          )
{
    Init(CurrentSession);
}

/////////////////////
// GetObjectIdentity
/////////////////////
HRESULT CObjects::CObjectsCommandIdentity::GetObjectIdentity(
                                                          _bstr_t&  Name, 
                                                          LONG&     Parent, 
                                                          LONG      Identity
                                                            ) 
{
    m_IdentityParam = Identity;

    HRESULT hr = BaseExecute();
    if ( SUCCEEDED(hr) )
    {
        Name    = m_Name;
        Parent  = m_Parent;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// class CObjectsCommandNameParent
//////////////////////////////////////////////////////////////////////////////
CObjects::CObjectsCommandNameParent::CObjectsCommandNameParent(
                                                    CSession& CurrentSession
                                                               )
{
    Init(CurrentSession);
}

////////////////////////////////////////
// GetObjectNameParent
//
// works on CObjectsAccSelectNameParent
////////////////////////////////////////
HRESULT CObjects::CObjectsCommandNameParent::GetObjectNameParent(
                                                    const _bstr_t&    Name, 
                                                          LONG        Parent, 
                                                          LONG&       Identity
                                                                ) 
{
    lstrcpynW(m_NameParam, Name, NAME_SIZE);
    m_ParentParam = Parent;
    
    HRESULT hr = BaseExecute();
    if ( SUCCEEDED(hr) )
    {
        Identity = m_Identity;
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// class CObjectsCommandDelete
//////////////////////////////////////////////////////////////////////////////
CObjects::CObjectsCommandDelete::CObjectsCommandDelete(
                                                   CSession& CurrentSession
                                                      )
{
    Init(CurrentSession);
}

//////////////////////////////
// DeleteObject
//
// works on CObjectsAccDelete
//////////////////////////////
HRESULT CObjects::CObjectsCommandDelete::DeleteObject(LONG Identity)
{
	// Set properties for open
	CDBPropSet	propset(DBPROPSET_ROWSET);
	propset.AddProperty(DBPROP_IRowsetChange, true);
	propset.AddProperty(DBPROP_UPDATABILITY, DBPROPVAL_UP_CHANGE | 
                        DBPROPVAL_UP_DELETE);

    m_IdentityParam = Identity;
    HRESULT hr = Open(&propset);
    Close();
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// class CObjectsCommandInsert
//////////////////////////////////////////////////////////////////////////////
CObjects::CObjectsCommandInsert::CObjectsCommandInsert(
                                                   CSession& CurrentSession
                                                      )
                                            :m_Session(CurrentSession)
{
    Init(CurrentSession);
}

//////////////////////////////
// InsertObject
//
// works on CObjectsAccInsert
//////////////////////////////
BOOL CObjects::CObjectsCommandInsert::InsertObject(
                                                    const _bstr_t&   Name,
                                                          LONG       Parent,
                                                          LONG&      Identity
                                                  )
{
    ClearRecord();

    CDBPropSet  propset(DBPROPSET_ROWSET);
    propset.AddProperty(DBPROP_IRowsetChange, true);
    propset.AddProperty(DBPROP_UPDATABILITY, DBPROPVAL_UP_CHANGE | 
                                             DBPROPVAL_UP_INSERT );
    
    lstrcpynW(m_NameParam, Name, NAME_SIZE);
    m_ParentParam = Parent;
    
    HRESULT hr = Open(&propset);
    if ( hr == S_OK )
    {
        CObjectsCommandNameParent   NameParent(m_Session);
        _com_util::CheckError(NameParent.GetObjectNameParent(
                                                                Name, 
                                                                Parent, 
                                                                Identity
                                                            ));
        Close();
        return TRUE;
    }
    else
    {
        // ignore the real error. 
        // the assumption here is that if I can't insert, that's because
        // the object already exists
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\policy.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Policy.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of the CPolicy class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Policy.h"

//////////////////////////////////////////////////////////////////////////////
// AddmsManipulationRules
//////////////////////////////////////////////////////////////////////////////
void CPolicy::SetmsManipulationRules(
                                        const _bstr_t&  Search, 
                                        const _bstr_t&  Replace
                                    )
{
    m_Search  = Search; 
    m_Replace = Replace;
}


//////////////////////////////////////////////////////////////////////////////
// Persist
// return the Identity of the new profile
//////////////////////////////////////////////////////////////////////////////
LONG CPolicy::Persist(CGlobalData& GlobalData)
{
    const LONG MAX_LONG = 14;

    // Get the proxy policy and proxyprofiles containers
    const WCHAR ProxyPoliciesPath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"Proxy Policies\0";

    LONG        ProxyPolicyIdentity;
    GlobalData.m_pObjects->WalkPath(ProxyPoliciesPath, ProxyPolicyIdentity);

    const WCHAR ProxyProfilesPath[] = 
                            L"Root\0"
                            L"Microsoft Internet Authentication Service\0"
                            L"Proxy Profiles\0";

    
    LONG        ProxyProfileIdentity;
    GlobalData.m_pObjects->WalkPath(ProxyProfilesPath, ProxyProfileIdentity);
    
    // Create a new policy
    GlobalData.m_pObjects->InsertObject(
                                           m_PolicyName, 
                                           ProxyPolicyIdentity,
                                           m_NewPolicyIdentity
                                       );

    // create a new profile
    GlobalData.m_pObjects->InsertObject(
                                           m_PolicyName, 
                                           ProxyProfileIdentity,
                                           m_NewProfileIdentity
                                       );
    m_Persisted          = TRUE;

    // Now insert the attributes in the policy and in the profile
    const _bstr_t   msNPAction = L"msNPAction";
    GlobalData.m_pProperties->InsertProperty(
                                                m_NewPolicyIdentity, 
                                                msNPAction, 
                                                VT_BSTR, 
                                                m_PolicyName
                                            );
    
    const _bstr_t   msNPConstraint = L"msNPConstraint";
    GlobalData.m_pProperties->InsertProperty(
                                                m_NewPolicyIdentity, 
                                                msNPConstraint, 
                                                VT_BSTR, 
                                                m_Constraint
                                            );
    const _bstr_t   msNPSequence = L"msNPSequence";
    WCHAR  TempString[MAX_LONG]; 
    _bstr_t Seq = _ltow(m_Sequence, TempString, 10);

    GlobalData.m_pProperties->InsertProperty(
                                                m_NewPolicyIdentity, 
                                                msNPSequence, 
                                                VT_I4, 
                                                Seq
                                            );
    
    const _bstr_t msAuthProviderType = L"msAuthProviderType";
    _bstr_t Provider = _ltow(m_AuthType, TempString, 10);
    GlobalData.m_pProperties->InsertProperty(
                                                m_NewProfileIdentity, 
                                                msAuthProviderType, 
                                                VT_I4, 
                                                Provider
                                            );
    if ( m_ServerGroup.length() )
    {
        const _bstr_t msAuthProviderName = L"msAuthProviderName";
        GlobalData.m_pProperties->InsertProperty(
                                                    m_NewProfileIdentity, 
                                                    msAuthProviderName, 
                                                    VT_BSTR, 
                                                    m_ServerGroup
                                                );
    }

    // If there's an Accounting provider, then its name should
    // be persisted too
    if ( m_AcctType )
    {
        const _bstr_t msAcctProviderType = L"msAcctProviderType";
        Provider = _ltow(m_AuthType, TempString, 10);
        GlobalData.m_pProperties->InsertProperty(
                                                    m_NewProfileIdentity, 
                                                    msAcctProviderType, 
                                                    VT_I4, 
                                                    Provider
                                                );

        const _bstr_t msAcctProviderName = L"msAcctProviderName";
        GlobalData.m_pProperties->InsertProperty(
                                                    m_NewProfileIdentity, 
                                                    msAcctProviderName, 
                                                    VT_BSTR, 
                                                    m_ServerGroup
                                                );
    }
    
    // persist the seearch / replace rules only if there's a search rule
    if ( m_Search.length() )
    {
        const _bstr_t msManipulationRule = L"msManipulationRule";
        GlobalData.m_pProperties->InsertProperty(
                                                    m_NewProfileIdentity, 
                                                    msManipulationRule, 
                                                    VT_BSTR, 
                                                    m_Search                                            
                                                );

        // make sure that InsertProperty has some valid parameters
        if ( ! m_Replace.length() )
        {
            m_Replace = L"";
        }
        GlobalData.m_pProperties->InsertProperty(
                                                    m_NewProfileIdentity, 
                                                    msManipulationRule, 
                                                    VT_BSTR, 
                                                    m_Replace
                                                );
    }
    
    // Sets the validation target
    if ( m_ManipulationTarget )
    {
        const _bstr_t msManipulationTarget = L"msManipulationTarget";
        _bstr_t Target = _ltow(m_ManipulationTarget, TempString, 10);
        GlobalData.m_pProperties->InsertProperty(
                                                    m_NewProfileIdentity, 
                                                    msManipulationTarget, 
                                                    VT_I4, 
                                                    Target
                                                );
    }    
    return  m_NewProfileIdentity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\migrateregistry.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999-2000 Microsoft Corporation all rights reserved.
//
// Module:      migrateregistry.h
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of CMigrateRegistry
//              Used only by the NT4 migration code
//
// Author:      tperraut
//
// Revision     02/25/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _MIGRATEREGISTRY_H_E9ADA837_270D_48ae_82C9_CA0EC3C1B6E1
#define _MIGRATEREGISTRY_H_E9ADA837_270D_48ae_82C9_CA0EC3C1B6E1

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"

class CMigrateRegistry: private NonCopyable
{
public:
    explicit CMigrateRegistry(CUtils& pUtils) 
                        : m_pUtils(pUtils)
    {
    }

    void     MigrateProviders();

private:
    LONG     DeleteAuthSrvService();

    CUtils&   m_pUtils;
};

#endif // _MIGRATEREGISTRY_H_E9ADA837_270D_48ae_82C9_CA0EC3C1B6E1_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\profileattributelist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ProfileAttributeList.cpp
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Implementation of the CProfileAttributeList class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ProfileAttributeList.h"  
#include "RADIUSAttributes.h"  

CProfileAttributeList::CProfileAttributeList(CSession& Session)
        :m_Session(Session)
{
    Init(Session);
}


//////////////////////////////////////////////////////////////////////////
// GetAttribute 
//////////////////////////////////////////////////////////////////////////
HRESULT CProfileAttributeList::GetAttribute(
                                           const _bstr_t&  ProfileName,
                                                 _bstr_t&  Attribute,
                                                 LONG&     AttributeNumber,
                                                 _bstr_t&  AttributeValueName,
                                                 _bstr_t&  StringValue,
                                                 LONG&     Order
                                           ) 
{
    lstrcpynW(m_ProfileParam, ProfileName, COLUMN_SIZE);
    
    HRESULT hr = BaseExecute();
    if ( SUCCEEDED(hr) )
    {
        // set the out params
        Order               = m_Order;
        AttributeValueName  = m_AttributeValueName;
        Attribute           = m_Attribute;
        CRADIUSAttributes   RadiusAttributes(m_Session);
        AttributeNumber     = RadiusAttributes.GetAttributeNumber(Attribute);

        // special case because the integers in NT4 are stored (sometimes) 
        // with a blanc space before the value.
        if ( !wcsncmp(m_StringValue , L" ", 1) ) 
        {
            WCHAR*  TempString = m_StringValue + 1;
            StringValue = TempString;
        }
        else
        {
            StringValue = m_StringValue;
        }
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////
// GetAttribute overloaded
//////////////////////////////////////////////////////////////////////////
HRESULT CProfileAttributeList::GetAttribute(
                                        const _bstr_t   ProfileName,
                                              _bstr_t&  Attribute,
                                              LONG&     AttributeNumber,
                                              _bstr_t&  AttributeValueName,
                                              _bstr_t&  StringValue,
                                              LONG&     Order,
                                              LONG      Index
                                            ) throw()
{
    lstrcpynW(m_ProfileParam, ProfileName, COLUMN_SIZE);

    HRESULT hr = BaseExecute(Index);
    if ( SUCCEEDED(hr) )
    {
        // set the out params
        Order               = m_Order;
        AttributeValueName  = m_AttributeValueName;
        Attribute           = m_Attribute;
        CRADIUSAttributes   RadiusAttributes(m_Session);
        AttributeNumber     = RadiusAttributes.GetAttributeNumber(Attribute);

        // special case because the integers in NT4 are stored (sometimes) 
        // with a blanc space before the value.
        if ( !wcsncmp(m_StringValue , L" ", 1) ) 
        {
            WCHAR*  TempString = m_StringValue + 1;
            StringValue = TempString;
        }
        else
        {
            StringValue = m_StringValue;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\policy.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Policy.h
//
// Project:     Windows 2000 IAS
//
// Description:Definition of the CPolicy class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _POLICY_H_182D3E52_6866_460d_817C_627B77E66D45
#define _POLICY_H_182D3E52_6866_460d_817C_627B77E66D45

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "globaldata.h"

//////////////////////////////////////////////////////////////////////////////
// CLASS CPolicy
class CPolicy 
{
public:
    CPolicy()
        :m_Sequence(0),
         m_AuthType(0),
         m_AcctType(0),
         m_ManipulationTarget(0),
         m_NewProfileIdentity(0),
         m_NewPolicyIdentity(0),
         m_Persisted(FALSE),
         m_ServerGroup(L"")
    {};

    //////////////////////////////////////////////////////////////////////////
    // SetmsNPAction
    //////////////////////////////////////////////////////////////////////////
    void SetmsNPAction(const _bstr_t& PolicyName)
    {
        m_PolicyName = PolicyName;
    }


    //////////////////////////////////////////////////////////////////////////
    // SetmsNPConstraint
    //////////////////////////////////////////////////////////////////////////
    void SetmsNPConstraint(const _bstr_t& Constraint)
    {
        m_Constraint = Constraint;
    }


    //////////////////////////////////////////////////////////////////////////
    // SetmsNPSequence
    //////////////////////////////////////////////////////////////////////////
    void SetmsNPSequence(LONG    Sequence)
    {
        m_Sequence  = Sequence;
    }


    //////////////////////////////////////////////////////////////////////////
    // SetmsAuthProviderType
    //////////////////////////////////////////////////////////////////////////
    void SetmsAuthProviderType(LONG Type, LPCWSTR    ServerGroup = NULL)
    {
        m_AuthType    = Type;
        if ( ServerGroup )
        {
            m_ServerGroup = ServerGroup;
        }
    }


    //////////////////////////////////////////////////////////////////////////
    // SetmsAcctProviderType
    //////////////////////////////////////////////////////////////////////////
    void SetmsAcctProviderType(LONG Type)
    {
        m_AcctType = Type;
    }

    //////////////////////////////////////////////////////////////////////////
    // AddmsManipulationRules
    //////////////////////////////////////////////////////////////////////////
    void SetmsManipulationRules(
                                   const _bstr_t&  Search, 
                                   const _bstr_t&  Replace
                               );


    //////////////////////////////////////////////////////////////////////////
    // SetmsManipulationTarget
    //////////////////////////////////////////////////////////////////////////
    void SetmsManipulationTarget(LONG    Target)
    {
            m_ManipulationTarget = Target;
    }


    //////////////////////////////////////////////////////////////////////////
    // Persist
    //////////////////////////////////////////////////////////////////////////
    LONG Persist(CGlobalData& GlobalData);

private:

    _bstr_t         m_PolicyName;
    _bstr_t         m_Constraint;
    LONG            m_Sequence;
    LONG            m_AuthType, m_AcctType;
    _bstr_t         m_ServerGroup;
    LONG            m_ManipulationTarget;
    LONG            m_NewProfileIdentity;
    LONG            m_NewPolicyIdentity;
    BOOL            m_Persisted;
    _bstr_t         m_Search; 
    _bstr_t         m_Replace;
};
#endif //_POLICY_H_182D3E52_6866_460d_817C_627B77E66D45
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\providers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Providers.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of the CProviders class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Providers.h"

//////////////////////////////////////////////////////////////////////////
// GetProvider
//////////////////////////////////////////////////////////////////////////
void CProviders::GetProvider(
                                const _bstr_t&      UserDefinedName,
                                      _bstr_t&      Description,
                                      _bstr_t&      Type,
                                      _bstr_t&      DLLName,
                                      VARIANT_BOOL& IsConfigured,
                                      VARIANT_BOOL& CanConfigure
                            )
{
    lstrcpynW(m_UserDefinedNameParam, UserDefinedName, COLUMN_SIZE);

    _com_util::CheckError(BaseExecute());
    Description  = m_Description;
    Type         = m_Type;
    DLLName      = m_DLLName;
    IsConfigured = m_IsConfigured;
    CanConfigure = m_CanConfigure;
}

//////////////////////////////////////////////////////////////////////////////
// GetProviderDescription
//////////////////////////////////////////////////////////////////////////////
LPCOLESTR   CProviders::GetProviderDescription(const _bstr_t&  UserDefinedName)
{
    lstrcpynW(m_UserDefinedNameParam, UserDefinedName, COLUMN_SIZE);
    _com_util::CheckError(BaseExecute());
    return m_Description;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\properties.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Properties.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of the CProperties class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Properties.h"

//////////////////////////////////////////////////////////////////////////
// class CProperties
//////////////////////////////////////////////////////////////////////////
//Constructor
//////////////
CProperties::CProperties(CSession& SessionParam)
                        :m_PropertiesCommandGet(SessionParam),
                         m_PropertiesCommandGetByName(SessionParam),
                         m_PropertiesCommandInsert(SessionParam),
                         m_PropertiesCommandDelete(SessionParam),
                         m_PropertiesCommandDeleteMultiple(SessionParam)
{
};


//////////////
// Destructor
//////////////
CProperties::~CProperties()
{
};


///////////////
// GetProperty
///////////////
HRESULT CProperties::GetProperty(
                                   LONG      Bag,
                                   _bstr_t&  Name,
                                   LONG&     Type,
                                   _bstr_t&  StrVal
                                )
{
    return  m_PropertiesCommandGet.GetProperty(
                                                    Bag,
                                                    Name,
                                                    Type,
                                                    StrVal
                                                );
}


///////////////////
// GetNextProperty
///////////////////
HRESULT CProperties::GetNextProperty(
                                        LONG      Bag,
                                        _bstr_t&  Name,
                                        LONG&     Type,
                                        _bstr_t&  StrVal,
                                        LONG      Index
                                    ) 
{
    return  m_PropertiesCommandGet.GetProperty(
                                                        Bag,
                                                        Name,
                                                        Type,
                                                        StrVal,
                                                        Index
                                                    );
}


/////////////////////
// GetPropertyByName
/////////////////////
HRESULT CProperties::GetPropertyByName(
                                              LONG      Bag,
                                        const _bstr_t&  Name,
                                              LONG&     Type,
                                              _bstr_t&  StrVal
                                      )
{
    return  m_PropertiesCommandGetByName.GetPropertyByName(
                                                        Bag,
                                                        Name,
                                                        Type,
                                                        StrVal
                                                    );
}


//////////////////////////////////
// InsertProperty
// throw an exception if it fails
//////////////////////////////////
void CProperties::InsertProperty(
                                          LONG        Bag,
                                    const _bstr_t&    Name,
                                          LONG        Type,
                                    const _bstr_t&    StrVal
                                ) 
{
    m_PropertiesCommandInsert.InsertProperty(
                                                Bag,
                                                Name,
                                                Type,
                                                StrVal
                                            );
}


//////////////////////////////////
// DeleteProperty
// throw an exception if it fails
//////////////////////////////////
void CProperties::DeleteProperty(
                                          LONG      Bag,
                                    const _bstr_t&  Name
                                )
{
    m_PropertiesCommandDelete.DeleteProperty(
                                                Bag,
                                                Name
                                            );
}

//////////////////////////
// DeletePropertiesExcept
//////////////////////////
void CProperties::DeletePropertiesExcept(
                                                    LONG        Bag,
                                            const   _bstr_t&    Exception
                                        )
{
    m_PropertiesCommandDeleteMultiple.DeletePropertiesExcept(Bag, Exception);
}


///////////////////////////////////////////////////
// UpdateProperty
// throw an exception if it fails
// Improvement possible: create a SQL statement 
// to update instead of doing a delete then insert
///////////////////////////////////////////////////
void CProperties::UpdateProperty(
                                          LONG      Bag,
                                    const _bstr_t&  Name,
                                          LONG      Type,
                                    const _bstr_t&  StrVal
                                )
{
    try
    {
        m_PropertiesCommandDelete.DeleteProperty(
                                                    Bag,
                                                    Name
                                                );
    }
    catch(...)
    {
        // ignore the failure. If delete fails but insert works, that's ok
    }
    m_PropertiesCommandInsert.InsertProperty(
                                                Bag,
                                                Name,
                                                Type,
                                                StrVal
                                            );
}


//////////////////////////////////////////////////////////////////////////////
// class CPropertiesCommandGet
//////////////////////////////////////////////////////////////////////////////
CProperties::CPropertiesCommandGet::CPropertiesCommandGet(
                                                    CSession& CurrentSession
                                                         )
{
    Init(CurrentSession);
};


///////////////
// GetProperty
///////////////
HRESULT CProperties::CPropertiesCommandGet::GetProperty(
                                                          LONG        Bag,
                                                          _bstr_t&    Name,
                                                          LONG&       Type,
                                                          _bstr_t&    StrVal
                                                       ) 
{
    m_BagParam = Bag;

    HRESULT hr = BaseExecute();
    if ( SUCCEEDED(hr) )
    {
        Name    = m_Name;
        Type    = m_Type;
        StrVal  = m_StrVal;
    }
    return hr;
}


//////////////////////////
// GetProperty overloaded
//////////////////////////
HRESULT CProperties::CPropertiesCommandGet::GetProperty(
                                                        LONG        Bag,
                                                        _bstr_t&    Name,
                                                        LONG&       Type,
                                                        _bstr_t&    StrVal,
                                                        LONG        Index
                                                    )
{
    m_BagParam = Bag;

    HRESULT hr = BaseExecute(Index);
    if ( SUCCEEDED(hr) )
    {
        Name    = m_Name;
        Type    = m_Type;
        StrVal  = m_StrVal;
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// class CPropertiesCommandGetByName
//////////////////////////////////////////////////////////////////////////////
CProperties::CPropertiesCommandGetByName::CPropertiesCommandGetByName(
                                                    CSession& CurrentSession
                                                         )
{
    Init(CurrentSession);
};


//////////////////////
// GetPropertyByName
//////////////////////
HRESULT CProperties::CPropertiesCommandGetByName::GetPropertyByName(
                                                             LONG      Bag,
                                                       const _bstr_t&  Name,
                                                             LONG&     Type,
                                                             _bstr_t&  StrVal
                                                     )
{
    m_BagParam = Bag;
    if ( Name.length() )
    {
        lstrcpynW(m_NameParam, Name, NAME_SIZE);
    }

    HRESULT hr = BaseExecute();
    if ( SUCCEEDED(hr) )
    {
        Type    = m_Type;
        StrVal  = m_StrVal;
    }
    return hr;
};



//////////////////////////////////////////////////////////////////////////////
// class CPropertiesCommandInsert
//////////////////////////////////////////////////////////////////////////////
CProperties::CPropertiesCommandInsert::CPropertiesCommandInsert(
                                                    CSession& CurrentSession
                                                               )
{
    Init(CurrentSession);
}


//////////////////
// InsertProperty
//////////////////
void CProperties::CPropertiesCommandInsert::InsertProperty(
                                                      LONG            Bag,
                                                      const _bstr_t&  Name,
                                                      LONG            Type,
                                                      const _bstr_t&  StrVal
                                                  ) 
{
    ClearRecord();
    m_BagParam = Bag;
    if ( Name.length() )
    {
        lstrcpynW(m_NameParam, Name, NAME_SIZE);
    }
    m_TypeParam = Type;
    if ( StrVal.length() )
    {
        lstrcpynW(m_StrValParam, StrVal, STRVAL_SIZE);
    }

    CDBPropSet  propset(DBPROPSET_ROWSET);
    propset.AddProperty(DBPROP_IRowsetChange, true);
    propset.AddProperty(DBPROP_UPDATABILITY, DBPROPVAL_UP_CHANGE  
                                           | DBPROPVAL_UP_INSERT );

    _com_util::CheckError(Open(&propset));
    Close();
}


//////////////////////////////////////////////////////////////////////////////
// class CPropertiesCommandDelete
//////////////////////////////////////////////////////////////////////////////
CProperties::CPropertiesCommandDelete::CPropertiesCommandDelete(
                                                  CSession& CurrentSession
                                                               )
{
    Init(CurrentSession);
}


//////////////////
// DeleteProperty
//////////////////
void CProperties::CPropertiesCommandDelete::DeleteProperty(
                                                             LONG       Bag,
                                                       const _bstr_t&   Name
                                                          )
{
    m_BagParam = Bag;
    lstrcpynW(m_NameParam, Name, NAME_SIZE);

    CDBPropSet  propset(DBPROPSET_ROWSET);
    propset.AddProperty(DBPROP_IRowsetChange, true);
    propset.AddProperty(DBPROP_UPDATABILITY, DBPROPVAL_UP_CHANGE  
                                           | DBPROPVAL_UP_DELETE );

    _com_util::CheckError(Open(&propset));
    Close();
}


//////////////////////////////////////////////////////////////////////////////
// class CPropertiesCommandDeleteMultiple
//////////////////////////////////////////////////////////////////////////////
CProperties::CPropertiesCommandDeleteMultiple::
                 CPropertiesCommandDeleteMultiple(CSession& CurrentSession)
{
    Init(CurrentSession);
}


//////////////////
// DeleteProperty
//////////////////
void CProperties::CPropertiesCommandDeleteMultiple::DeletePropertiesExcept(
                                                            LONG      Bag,
                                                      const _bstr_t&  Exception
                                                                          )
{
    m_BagParam = Bag;
    lstrcpynW(m_ExceptionParam, Exception, SIZE_EXCEPTION_MAX);

    CDBPropSet  propset(DBPROPSET_ROWSET);
    propset.AddProperty(DBPROP_IRowsetChange, true);
    propset.AddProperty(DBPROP_UPDATABILITY, DBPROPVAL_UP_CHANGE  
                                           | DBPROPVAL_UP_DELETE );

    Open(&propset); // ignore the result
    Close();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\proxyservergroupcollection.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ProxyServerGroupCollection.h 
//
// Project:     Windows 2000 IAS
//
// Description: Declaration of the CProxyServerGroupCollection class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _PROXYSERVERGROUPCOLLECTION_H_195CF33C_8382_4462_A4EF_CCEAFCC4E4D8
#define _PROXYSERVERGROUPCOLLECTION_H_195CF33C_8382_4462_A4EF_CCEAFCC4E4D8

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "proxyserversgrouphelper.h"

#include <map>
#include "nocopy.h"
using namespace std;

typedef map<_bstr_t, CProxyServersGroupHelper> ServerGroupMap; 


class CProxyServerGroupCollection : private NonCopyable  
{
protected:
    CProxyServerGroupCollection(){};

public:
    static CProxyServerGroupCollection& Instance();
    void                                Persist();
	CProxyServersGroupHelper*           Add(
                                    CProxyServersGroupHelper&  ServerGroup
                                           );

private:
    static CProxyServerGroupCollection  _instance;
    ServerGroupMap                      m_ServerGroupMap;
};

#endif // _PROXYSERVERGROUPCOLLECTION_H_195CF33C_8382_4462_A4EF_CCEAFCC4E4D8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\proxyserverhelper.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ProxyServerHelper.h 
//
// Project:     Windows 2000 IAS
//
// Description: CProxyServerHelper class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _PROXYSERVERPHELPER_H_6ABCB440_15A3_45d6_92FB_627EBF5C4C6F
#define _PROXYSERVERPHELPER_H_6ABCB440_15A3_45d6_92FB_627EBF5C4C6F

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <vector>
#include "globaldata.h"

class CStringUuid
{
public:
   CStringUuid();
   ~CStringUuid() throw();

   const wchar_t* GetUuid() throw();

private:
   wchar_t* stringUuid;
   CStringUuid& operator=(const CStringUuid& P);
   CStringUuid(const CStringUuid& P);

};


class CProxyServerHelper
{
public:
    explicit CProxyServerHelper(
                                  CGlobalData& GlobalData
                               );

    void    CreateUniqueName();
    void    SetName(const _bstr_t& Name);
    void    SetAccountingPort(LONG Port);
    void    SetAccountingSecret(const _bstr_t& Secret);
    void    SetAuthenticationPort(LONG Port);
    void    SetAuthenticationSecret(const _bstr_t& Secret);
    void    SetAddress(const _bstr_t& Address);
    void    SetForwardAccounting(BOOL bOn);
    void    SetWeight(LONG Weight);
    void    SetPriority(LONG Priority);
    void    SetBlackoutInterval(LONG Interval);
    void    SetMaximumLostPackets(LONG MaxLost);
    void    SetTimeout(LONG Timeout);
    void    Persist(LONG Parent);

    CProxyServerHelper& operator=(const CProxyServerHelper& P);
    CProxyServerHelper(const CProxyServerHelper& P);
    
private:

    struct Properties
    {
        const WCHAR*    Name;
        LONG            Type;
    };

    static const Properties   c_DefaultProxyServerProperties[];
    static const unsigned int c_NbDefaultProxyServerProperties;

    static const long MAX_LONG_SIZE = 14;
    
    enum _ArrayPosition
    {
        ACCT_PORT_POS, 
        ACCT_SECRET_POS,
        AUTH_PORT_POS,
        AUTH_SECRET_POS,
        ADDRESS_POS,
        FORWARD_ACCT_POS,
        PRIORITY_POS,
        WEIGHT_POS,
        TIMEOUT_POS,
        MAX_LOST_PACKETS_POS,
        BLACKOUT_POS
    };

    struct _PropertiesArray
    {
        _bstr_t     Name;
        LONG        Type;
        _bstr_t     StrVal;
    };

    typedef std::vector<_PropertiesArray> PropertiesArray; 

    CGlobalData&        m_GlobalData;
    _bstr_t             m_Name;
    PropertiesArray     m_PropArray;
};

#endif // _PROXYSERVERPHELPER_H_6ABCB440_15A3_45d6_92FB_627EBF5C4C6F
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\proxyservergroupcollection.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ProxyServerGroupCollection.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of CProxyServerGroupCollection
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ProxyServerGroupCollection.h"

CProxyServerGroupCollection CProxyServerGroupCollection::_instance;

CProxyServerGroupCollection& CProxyServerGroupCollection::Instance()
{
    return _instance;
}

//////////////////////////////////////////////////////////////////////////////
// Add
//////////////////////////////////////////////////////////////////////////////
CProxyServersGroupHelper* CProxyServerGroupCollection::Add(
                                  CProxyServersGroupHelper& ServerGroup
                                        )
{
    _bstr_t GroupName = ServerGroup.GetName();

    // try to find if the group already exists
    ServerGroupMap::iterator MapIterator = m_ServerGroupMap.find(GroupName);
    if ( MapIterator != m_ServerGroupMap.end() )
    {
        // found in the map. Return it
        return &(MapIterator->second);
    }
    else
    {
        // insert and return it
        m_ServerGroupMap.insert(ServerGroupMap::value_type(
                                                               GroupName, 
                                                               ServerGroup
                                                            ));
        // get the newly inserted servergroup (i.e. it was copied)
        MapIterator = m_ServerGroupMap.find(GroupName);
        return &(MapIterator->second);
    }
}


//////////////////////////////////////////////////////////////////////////////
// Persist
//////////////////////////////////////////////////////////////////////////////
void CProxyServerGroupCollection::Persist()
{
    // for each serversgroup
    ServerGroupMap::iterator MapIterator = m_ServerGroupMap.begin();
    while (MapIterator != m_ServerGroupMap.end())
    {
        MapIterator->second.Persist();
        ++MapIterator;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\proxyserversgrouphelper.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ProxyServersGroupHelper.cpp
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of CProxyServersGroupHelper 
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "GlobalTransaction.h"
#include "GlobalData.h"
#include "ProxyServersGroupHelper.h"
#include "Objects.h"
#include "Properties.h"


LONG CProxyServersGroupHelper::m_GroupParent = 0;

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////////////
CProxyServersGroupHelper::CProxyServersGroupHelper(
                                                    CGlobalData& pGlobalData
                                                  )
                                            :m_pGlobalData(pGlobalData),
                                             m_NewGroupIdSet(FALSE),
                                             m_Name(L""),
                                             m_GroupIdentity(0)
                                             
{
    if ( !m_GroupParent )
    {
        LPCWSTR Path = L"Root\0"
                       L"Microsoft Internet Authentication Service\0"
                       L"RADIUS Server Groups\0";

        m_pGlobalData.m_pObjects->WalkPath(
                                               Path,
                                               m_GroupParent
                                          );
    }
}


//////////////////////////////////////////////////////////////////////////////
// SetName
//////////////////////////////////////////////////////////////////////////////
void CProxyServersGroupHelper::SetName(const _bstr_t &pName)
{
    m_Name = pName;
}


//////////////////////////////////////////////////////////////////////////////
// GetServersGroupIdentity
//////////////////////////////////////////////////////////////////////////////
LONG CProxyServersGroupHelper::GetIdentity() const
{
    if ( m_NewGroupIdSet ) // initialized implied
    {
        return m_GroupIdentity;
    }
    else
    {
        _com_issue_error(E_INVALIDARG);
        // never hit but needed to compile
        return 0;
    }
}


//////////////////////////////////////////////////////////////////////////////
// Add
//////////////////////////////////////////////////////////////////////////////
void CProxyServersGroupHelper::Add(CProxyServerHelper &Server)
{
    Server.CreateUniqueName();
    m_ServerArray.push_back(Server);
}


//////////////////////////////////////////////////////////////////////////////
// GetName
//////////////////////////////////////////////////////////////////////////////
LPCOLESTR CProxyServersGroupHelper::GetName() const
{
    return m_Name;
}


//////////////////////////////////////////////////////////////////////////////
// Persist
//////////////////////////////////////////////////////////////////////////////
void CProxyServersGroupHelper::Persist()
{
    // Persist the ServerGroup Itself so that m_GroupIdentity is set
    if ( m_Name.length() )
    {
        // object does not exist (New Database assumed)
        m_pGlobalData.m_pObjects->InsertObject(
                                                  m_Name,
                                                  m_GroupParent,
                                                  m_GroupIdentity
                                              );
        m_NewGroupIdSet = TRUE;
    }
    else
    {
        _com_issue_error(E_INVALIDARG);
    }

    // now for each server in the vector
    ServerArray::iterator ArrayIterator = m_ServerArray.begin();
    while (ArrayIterator != m_ServerArray.end())
    {
        // then persist
        ArrayIterator->Persist(m_GroupIdentity);
        ++ArrayIterator;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\proxyserverhelper.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ProxyServerHelper.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of CProxyServerHelper
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "GlobalTransaction.h"
#include "GlobalData.h"
#include "ProxyServerHelper.h"
#include "Objects.h"
#include "Properties.h"


CStringUuid::CStringUuid()
{
   UUID        uuid;
   RPC_STATUS  Result = UuidCreate(&uuid);
   if ( (Result == RPC_S_OK) || (Result == RPC_S_UUID_LOCAL_ONLY) )
   {
      Result = UuidToStringW(
                  &uuid,
                  &stringUuid
                  );
      if ( Result != RPC_S_OK )
      {
         _com_issue_error(HRESULT_FROM_WIN32(Result)); // long
      }
   }
   else
   {
      _com_issue_error(E_FAIL); 
   }
}


CStringUuid::~CStringUuid()
{
   RpcStringFreeW(&stringUuid);
}


const wchar_t* CStringUuid::GetUuid()
{
   return stringUuid;
}


const CProxyServerHelper::Properties 
                CProxyServerHelper::c_DefaultProxyServerProperties[] =
{
    {
        L"Server Accounting Port",
        VT_I4,
    },
    {
        L"Accounting Secret",
        VT_BSTR,
    },
    {
        L"Server Authentication Port",
        VT_I4,
    },
    {
        L"Authentication Secret",
        VT_BSTR,
    },
    {
        L"Address",
        VT_BSTR,
    },
    {
        L"Forward Accounting On/Off",
        VT_BOOL,
    },
    {
        L"Priority",
        VT_I4,
    },
    {
        L"Weight",
        VT_I4,
    },
    {
        L"Timeout",
        VT_I4,
    },
    {
        L"Maximum Lost Packets",
        VT_I4,
    },
    {
        L"Blackout Interval",
        VT_I4,
    },
    // add next properties below and in the enum
};

const unsigned int CProxyServerHelper::c_NbDefaultProxyServerProperties
                          = sizeof(c_DefaultProxyServerProperties) /
                            sizeof(c_DefaultProxyServerProperties[0]);


//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////////////
CProxyServerHelper::CProxyServerHelper(
                                         CGlobalData& GlobalData
                                      ):m_GlobalData(GlobalData) 

{
    for (unsigned int i = 0; i < c_NbDefaultProxyServerProperties; ++i)
    {
        _PropertiesArray TempProperty;
        TempProperty.Name = c_DefaultProxyServerProperties[i].Name;
        TempProperty.Type = c_DefaultProxyServerProperties[i].Type;
        m_PropArray.push_back(TempProperty);
    }
}


//////////////////////////////////////////////////////////////////////////////
// SetName
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetName(const _bstr_t& Name)
{
    m_Name = Name;
}


//////////////////////////////////////////////////////////////////////////////
// CreateUniqueName
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::CreateUniqueName()
{
    CStringUuid   uuidString;
    m_Name = uuidString.GetUuid();
}


//////////////////////////////////////////////////////////////////////////////
// SetAccountingPort
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetAccountingPort(LONG Port)
{
    // base 10 Will never change
    WCHAR   TempString[MAX_LONG_SIZE];
    m_PropArray.at(ACCT_PORT_POS).StrVal = _ltow(Port, TempString, 10); 
}


//////////////////////////////////////////////////////////////////////////////
// SetAccountingSecret
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetAccountingSecret(const _bstr_t &Secret)
{
    m_PropArray.at(ACCT_SECRET_POS).StrVal = Secret;
}


//////////////////////////////////////////////////////////////////////////////
// SetAuthenticationPort
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetAuthenticationPort(LONG Port)
{
    // base 10 Will never change
    WCHAR   TempString[MAX_LONG_SIZE];
    m_PropArray.at(AUTH_PORT_POS).StrVal = _ltow(Port, TempString, 10); 
}


//////////////////////////////////////////////////////////////////////////////
// SetAuthenticationSecret
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetAuthenticationSecret(const _bstr_t &Secret)
{
    m_PropArray.at(AUTH_SECRET_POS).StrVal = Secret;
}


//////////////////////////////////////////////////////////////////////////////
// SetAddress
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetAddress(const _bstr_t& Address)
{
    m_PropArray.at(ADDRESS_POS).StrVal = Address;
}


//////////////////////////////////////////////////////////////////////////////
// SetForwardAccounting
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetForwardAccounting(BOOL bOn)
{
    m_PropArray.at(FORWARD_ACCT_POS).StrVal = bOn? L"-1": L"0";
}


//////////////////////////////////////////////////////////////////////////////
// SetPriority
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetPriority(LONG Priority)
{
    WCHAR   TempString[MAX_LONG_SIZE];
    m_PropArray.at(PRIORITY_POS).StrVal = _ltow(Priority, TempString, 10); 
}


//////////////////////////////////////////////////////////////////////////////
// SetWeight
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetWeight(LONG Weight)
{
    WCHAR   TempString[MAX_LONG_SIZE];
    m_PropArray.at(WEIGHT_POS).StrVal = _ltow(Weight, TempString, 10);
}


//////////////////////////////////////////////////////////////////////////////
// SetTimeout
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetTimeout(LONG Timeout)
{
    WCHAR   TempString[MAX_LONG_SIZE];
    m_PropArray.at(TIMEOUT_POS).StrVal = _ltow(Timeout, TempString, 10);
}


//////////////////////////////////////////////////////////////////////////////
// SetMaximumLostPackets
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetMaximumLostPackets(LONG MaxLost)
{
    WCHAR   TempString[MAX_LONG_SIZE];
    m_PropArray.at(MAX_LOST_PACKETS_POS).StrVal = _ltow(MaxLost,TempString,10);
}


//////////////////////////////////////////////////////////////////////////////
// SetBlackoutInterval
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::SetBlackoutInterval(LONG Interval)
{
    WCHAR   TempString[MAX_LONG_SIZE];
    m_PropArray.at(BLACKOUT_POS).StrVal = _ltow(Interval, TempString, 10);
}


//////////////////////////////////////////////////////////////////////////////
// Persist
//////////////////////////////////////////////////////////////////////////////
void CProxyServerHelper::Persist(LONG Parent)
{
    if ( !Parent )
    {
        _com_issue_error(E_INVALIDARG);
    }

    // Create a server in the servergroup (m_Objects)
    LONG        BagNumber;
    m_GlobalData.m_pObjects->InsertObject(
                                             m_Name,
                                             Parent,
                                             BagNumber
                                          );

    // then set all the properties (m_Properties)
    for (unsigned int i = 0; i < c_NbDefaultProxyServerProperties; ++i)
    {
        if ( !m_PropArray.at(i).StrVal )
        {
            // property not set 
            continue;
        }

        m_GlobalData.m_pProperties->InsertProperty(
                                                      BagNumber,
                                                      m_PropArray.at(i).Name,
                                                      m_PropArray.at(i).Type,
                                                      m_PropArray.at(i).StrVal
                                                  );
    }
}


//////////////////////////////////////////////////////////////////////////////
// operator = (cleanup and copy)
//////////////////////////////////////////////////////////////////////////////
CProxyServerHelper& CProxyServerHelper::operator=(const CProxyServerHelper& P)
{
    if ( this != &P )
    {
        m_GlobalData   = P.m_GlobalData;
        m_Name         = P.m_Name;
        
        PropertiesArray     TempArray;

        for (unsigned int i = 0; i < c_NbDefaultProxyServerProperties; ++i)
        {
            _PropertiesArray     TempProperty;
            TempProperty.Type   = P.m_PropArray.at(i).Type;
            TempProperty.Name   = P.m_PropArray.at(i).Name; 
            TempProperty.StrVal = P.m_PropArray.at(i).StrVal; 

            TempArray.push_back(TempProperty);
        }
        m_PropArray.swap(TempArray);
    }
    return *this;
}


//////////////////////////////////////////////////////////////////////////////
// copy constructor
//////////////////////////////////////////////////////////////////////////////
CProxyServerHelper::CProxyServerHelper(const CProxyServerHelper& P)
                                :m_GlobalData(P.m_GlobalData)
{
    m_Name         = P.m_Name;

    PropertiesArray     TempArray;

    m_PropArray.reserve(c_NbDefaultProxyServerProperties);
    for (unsigned int i = 0; i < c_NbDefaultProxyServerProperties; ++i)
    {
        _PropertiesArray     TempProperty;
        TempProperty.Type   = P.m_PropArray.at(i).Type;
        TempProperty.Name   = P.m_PropArray.at(i).Name; 
        TempProperty.StrVal = P.m_PropArray.at(i).StrVal; 

        TempArray.push_back(TempProperty);
    }
    m_PropArray.swap(TempArray);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\proxyserversgrouphelper.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ProxyServersGroupHelper.h 
//
// Project:     Windows 2000 IAS
//
// Description: CProxyServersGroupHelper class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _PROXYSERVERSGROUPHELPER_H_D9B838F7_0269_47C8_BAB3_10927AB9FCAD
#define _PROXYSERVERSGROUPHELPER_H_D9B838F7_0269_47C8_BAB3_10927AB9FCAD

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ProxyServerHelper.h"
#include <vector>

using namespace std;

typedef vector<CProxyServerHelper> ServerArray; 

class CProxyServersGroupHelper 
{
public:
    explicit CProxyServersGroupHelper(CGlobalData& pGlobalData);

    LPCOLESTR   GetName() const;
    LONG        GetIdentity() const;
	void        Add(CProxyServerHelper& Server);
    void        SetName(const _bstr_t& pName);
	void        Persist();

private:
    CGlobalData&        m_pGlobalData;
    BOOL                m_NewGroupIdSet;
    _bstr_t             m_Name;
    LONG                m_GroupIdentity;
    ServerArray         m_ServerArray;

    static LONG         m_GroupParent;

    CProxyServersGroupHelper& operator=(const CProxyServersGroupHelper&);
};

#endif // _PROXYSERVERSGROUPHELPER_H_D9B838F7_0269_47C8_BAB3_10927AB9FCAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\radiusattributevalues.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      RADIUSAttributeValues.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Implementation of the CRADIUSAttributeValues class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
#include "stdafx.h"
#include "RADIUSAttributeValues.h"

//////////////////////////////////////////////////////////////////////////
// GetAttributeNumber
//////////////////////////////////////////////////////////////////////////
LONG    CRADIUSAttributeValues::GetAttributeNumber(
                                  const _bstr_t& AttributeName,
                                  const _bstr_t& AttributeValueName
                              )
{
    lstrcpynW(m_AttributeParam, AttributeName, COLUMN_SIZE);
    lstrcpynW(m_AttributeValueNameParam, AttributeValueName, COLUMN_SIZE);
 
    _com_util::CheckError(BaseExecute());
    return m_AttributeValueNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\radiusattributes.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      RADIUSAttributes.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Implementation of the CRADIUSAttributes class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "RADIUSAttributes.h"


CRADIUSAttributes::CRADIUSAttributes(CSession& Session)
{
    Init(Session);
}


//////////////////////////////////////////////////////////////////////////
// GetAttributeNumber
//////////////////////////////////////////////////////////////////////////
LONG CRADIUSAttributes::GetAttributeNumber(const _bstr_t& AttributeName)
{
    lstrcpynW(m_AttributesParam, AttributeName, COLUMN_SIZE);

    HRESULT hr  = BaseExecute();
    if ( hr == S_OK )
    {
        return m_AttributeNumber;
    }
    else
    {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\serviceconfiguration.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ServiceConfiguration.cpp
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of the CServiceConfiguration class
//
// Author:      tperraut
//
// Revision     03/21/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "serviceconfiguration.h"

CServiceConfiguration::CServiceConfiguration(CSession& Session)
{
    Init(Session, L"Service Configuration");
}

//////////////////////////////////////////////////////////////////////////
// GetMaxLogSize
//////////////////////////////////////////////////////////////////////////
_bstr_t CServiceConfiguration::GetMaxLogSize() const
{
    WCHAR       TempString[SIZE_LONG_MAX];
    _ltow(m_MaxLogSize, TempString, 10);
    _bstr_t     StringMaxLogSize = TempString;
    return StringMaxLogSize;
}

    
//////////////////////////////////////////////////////////////////////////
// GetLogFrequency
//////////////////////////////////////////////////////////////////////////
_bstr_t CServiceConfiguration::GetLogFrequency() const
{
    LONG    Frequency;
    if ( m_NewLogDaily )
    {
        Frequency = IAS_LOGGING_DAILY;
    }
    else if ( m_NewLogWeekly )
    {
        Frequency = IAS_LOGGING_WEEKLY;
    }
    else if ( m_NewLogMonthly )
    {
        Frequency = IAS_LOGGING_MONTHLY;
    }
    else if ( m_NewLogBySize )
    {
        Frequency = IAS_LOGGING_WHEN_FILE_SIZE_REACHES;
    }           
    else
    {
        Frequency = IAS_LOGGING_UNLIMITED_SIZE;
    }

    WCHAR       TempString[SIZE_LONG_MAX];
    _ltow(Frequency, TempString, 10);
    _bstr_t     StringFrequency = TempString;
    return StringFrequency;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\stdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      stdafx.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: 
//  stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\setup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      setup.cpp 
//
// Project:     Windows 2000 IAS
//
// Description: IAS Upgrade class implementation
//
// Author:      tperraut 06/13/2000 
//
// Revision     
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "doupgrade.h"
#include "iasdb.h"
#include "setup.h" // to get the CIASUpgrade class

////////////////////////////
// CIASUpgrade Constructor
////////////////////////////
CIASUpgrade::CIASUpgrade()
{
   ///////////////////////////////////////////////////////////////
   // Expand the three string even if two only might be needed in 
   // the netshell scenario
   // The mdb files can be:
   //    \ias\iasnew.mdb";
   //    \ias\ias.mdb";
   //    \ias\iasold.mdb";
   ///////////////////////////////////////////////////////////////

    wchar_t sysWow64Path[MAX_PATH+1] = L"";

   //
   //  << GetSystemWow64Directory>>  returns the number of chars copied to the buffer.
   //  If we get zero back, then we need to check the last error code to see what the
   //  reason for failure was.  If it was call not implemented then we know we are
   //  running on native x86.
   //
   UINT uReturn = GetSystemWow64DirectoryW(sysWow64Path, MAX_PATH);
   if ( uReturn != 0 )
   {
      // proper path found
      m_pIASNewMdb = sysWow64Path;
      m_pIASNewMdb += L"\\ias\\iasnew.mdb";

      m_pIASMdb = sysWow64Path;
      m_pIASMdb += L"\\ias\\ias.mdb";

      m_pIASOldMdb = sysWow64Path;
      m_pIASOldMdb += L"\\ias\\iasold.mdb";
   }
   else
   {
      // check the error message
      DWORD error = GetLastError();

      if (ERROR_CALL_NOT_IMPLEMENTED == error)
      {
         // Pure 32 bits environment
         uReturn = GetWindowsDirectoryW(sysWow64Path, MAX_PATH);
         if ( uReturn != 0 )
         {
            // proper path found
            m_pIASNewMdb = sysWow64Path;
            m_pIASNewMdb += L"\\System32\\ias\\iasnew.mdb";

            m_pIASMdb = sysWow64Path;
            m_pIASMdb += L"\\System32\\ias\\ias.mdb";

            m_pIASOldMdb = sysWow64Path;
            m_pIASOldMdb += L"\\System32\\ias\\iasold.mdb";
         }
         else
         {
            _com_issue_error(HRESULT_FROM_WIN32(error));
         }
      }
      else
      {
         _com_issue_error(HRESULT_FROM_WIN32(error));
      }
   }

   ///////////////////////////////////////////////
   // Check that all the strings are properly set
   ///////////////////////////////////////////////
   if ( !m_pIASNewMdb || !m_pIASMdb || !m_pIASOldMdb )
   {
      _com_issue_error(E_OUTOFMEMORY);
   }
}


/////////////////////////////////
// CIASUpgrade::GetVersionNumber
/////////////////////////////////
LONG CIASUpgrade::GetVersionNumber(LPCWSTR DatabaseName)
{
    if ( !DatabaseName )
    {
        _com_issue_error(E_INVALIDARG);
    }

    /////////////////////////////////////////////////
    // Check %TMP% and create a directory if needed
    // That's to fix a bug with JET
    /////////////////////////////////////////////////
    IASCreateTmpDirectory();

    CComPtr<IUnknown>   Session = NULL;
    HRESULT hr = IASOpenJetDatabase(DatabaseName, TRUE, &Session);
    if ( FAILED(hr) )
    {
        _com_issue_error(hr);
    }

    CComBSTR     SelectVersion(L"SELECT * FROM Version");
    if ( !SelectVersion ) 
    { 
        _com_issue_error(E_OUTOFMEMORY); 
    } 

    LONG    Version = 0;
    hr = IASExecuteSQLFunction(Session, SelectVersion, &Version);
    if ( FAILED(hr) ) // no Version table for instance
    {
        // Version  0. That's not an error 
    }
    Session.Release();
    return Version;
}


///////////////////////////////////////////////////////////////
// CIASUpgrade::DoWin2kUpgradeFromNetshell
//
// The call to the upgrade is the result of a Netshell script
// ias.mdb is assumed present and good (Whistler).
// iasold is assumed present and will be migrated into ias.mdb
///////////////////////////////////////////////////////////////
void CIASUpgrade::DoWin2kUpgradeFromNetshell()
{
    ///////////////////////////////////////////////////////
    // Now Upgrade the Win2k, Whistler 1.0 or Whistler 2.0
    // DB into the current Whistler 2.0 DB
    // The upgrade will throw if it fails
    ///////////////////////////////////////////////////////
   {
       CUpgradeWin2k       Upgrade2k;
       Upgrade2k.Execute(); 
   }

    ////////////////////////////////////
    // Delete iasold.mdb no matter what
    // here the upgrade was successful
    ////////////////////////////////////
    DeleteFile(m_pIASOldMdb);
}


//////////////////////////////////////////////////
// DoNT4UpgradeOrCleanInstall
//
// The file ias.mdb did not exist before
// That's either a NT4 upgrade or a clean install
// iasnew.mdb was successfuly copied into ias.mdb
//////////////////////////////////////////////////
void CIASUpgrade::DoNT4UpgradeOrCleanInstall()
{
    ////////////////////////////////////
    // Delete iasnew.mdb no matter what
    ////////////////////////////////////
    DeleteFile(m_pIASNewMdb); 

    //////////////////////////////////////////////////////
    // Call DoUpgrade: that will check if a NT4 migration 
    // should be done or not and do it if necessary
    //////////////////////////////////////////////////////
    CDoNT4OrCleanUpgrade    Upgrade;
    Upgrade.Execute(); 
}


/////////////////////////////////////////////////////////////////////////////
// CIASUpgrade::DoWin2kUpgrade
/////////////////////////////////////////////////////////////////////////////
void CIASUpgrade::DoWin2kUpgrade()
{
    LONG Result = ERROR_SUCCESS;
    //////////////////////////////////////////
    // now force copy ias.mdb into iasold.mdb 
    //////////////////////////////////////////
    BOOL Succeeded = CopyFile(m_pIASMdb, m_pIASOldMdb, FALSE);
    if ( !Succeeded )
    {
        ////////////////////////////////////////////////
        // iasnew.mdb will still be copied into ias.mdb 
        // later but not upgraded after that 
        ////////////////////////////////////////////////
        Result = GetLastError();
    }
    //////////////////////////////////////
    // force copy iasnew.mdb into ias.mdb
    //////////////////////////////////////
    Succeeded = CopyFile(m_pIASNewMdb, m_pIASMdb, FALSE);
    if ( !Succeeded )
    {
        /////////////////////////////
        // do not upgrade after that 
        /////////////////////////////
        Result = GetLastError();
    }
    
    ////////////////////////////////////////////////////
    // Delete iasnew.mdb no matter what: if the upgrade 
    // throws an exception then iasnew.mdb will not be 
    // left on the drive
    ////////////////////////////////////////////////////
    DeleteFile(m_pIASNewMdb);

    /////////////////////////////////////////////
    // Now Upgrade the Win2k or Whistler 1.0 DB 
    // into the Whistler DB if the previous copy
    // operations were successful
    /////////////////////////////////////////////
    if ( Result == ERROR_SUCCESS )
    {
        ///////////////////////////////////
        // will throw if the upgrade fails
        ///////////////////////////////////
        CUpgradeWin2k       Upgrade2k;
        Upgrade2k.Execute();
    }
    else
    {
        _com_issue_error(HRESULT_FROM_WIN32(Result));
    }
    ////////////////////////////////////
    // Delete iasold.mdb no matter what
    // here the upgrade was successful
    ////////////////////////////////////
    DeleteFile(m_pIASOldMdb);
}


////////////////////////////////////////
// CIASUpgrade::DoWhistlerUpgrade
//
// nothing to do: already a Whistler DB
////////////////////////////////////////
void CIASUpgrade::DoWhistlerUpgrade()
{
    ////////////////////////////////////
    // Delete iasnew.mdb no matter what
    ////////////////////////////////////
    DeleteFile(m_pIASNewMdb); 
}


/////////////////////////////////////////////////////////////////////////////
// CIASUpgrade::IASUpgrade 
/////////////////////////////////////////////////////////////////////////////
HRESULT CIASUpgrade::IASUpgrade(BOOL     FromNetshell)
{
    HRESULT hr = S_OK;

    ////////////////////////////
    // Now get the upgrade type
    ////////////////////////////
    do
    {
        if ( FromNetshell )
        {
            UpgradeType = Win2kUpgradeFromNetshell;
            break;
        }
        ///////////////////////////////////////
        // try to copy iasnew.mdb into ias.mdb 
        // fails if the file is already there
        ///////////////////////////////////////
        BOOL IsNT4OrCleanInstall = CopyFile(m_pIASNewMdb, m_pIASMdb, TRUE);
        if ( IsNT4OrCleanInstall )
        {
            // select NT4 or Clean install
            UpgradeType = NT4UpgradeOrCleanInstall;
            break;
        }
        else // Win2k or Whistler upgrade
        {
            ///////////////////////////////////////////
            // cannot copy: the file is already there.
            // Check the version number (of ias.mdb)
            ///////////////////////////////////////////
            LONG  CurrentVersion = GetVersionNumber(m_pIASMdb);
            const LONG  IAS_5_1_VERSION = 3;

            if ( CurrentVersion < IAS_5_1_VERSION )
            {
                UpgradeType = Win2kUpgrade;
                break;
            }
            else
            {
                UpgradeType = WhistlerUpgrade;
                break;
            }
        }
    }
    while (FALSE);

    try 
    {
        switch ( UpgradeType )
        {
        case Win2kUpgradeFromNetshell:
            {
                DoWin2kUpgradeFromNetshell();
                break;
            }

        case NT4UpgradeOrCleanInstall:
            {
                DoNT4UpgradeOrCleanInstall();
                break;
            }
        
        case Win2kUpgrade:
            {
                DoWin2kUpgrade();
                break;
            }
        
        case WhistlerUpgrade:
            {
                DoWhistlerUpgrade();
                break;
            }
        
        default:
            {
                _com_issue_error(E_FAIL);
            }
        }
    }
    catch(const _com_error& e)
    {
        hr = e.Error();
    }
    catch(...)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }



    if ( FromNetshell )
    {
        /////////////////////////////////////
        // Return the error code to netshell
        /////////////////////////////////////
        return hr;
    }
    else
    {
        ///////////////////////////////////////
        // Result ignored: no errors returned.
        ///////////////////////////////////////
        return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\realms.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Realms.cpp
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of the CProperties class
//      works only with m_StdSession (database being upgraded)
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Realms.h"
#include "utils.h"

//////////////////////////////////////////////////////////////////////////////
// Contructor
//////////////////////////////////////////////////////////////////////////////
CRealms::CRealms(CSession&   Session)
{
    Init(Session);
};


//////////////////////////////////////////////////////////////////////////////
// GetRealm
//////////////////////////////////////////////////////////////////////////////
void CRealms::GetRealm(const _bstr_t& Profile)
{
    lstrcpynW(m_ProfileParam, Profile, REALM_COLUMN_SIZE);
    _com_util::CheckError(BaseExecute());
}

//////////////////////////////////////////////////////////////////////////////
// GetRealmIndex
//////////////////////////////////////////////////////////////////////////////
HRESULT  CRealms::GetRealmIndex(const _bstr_t& Profile, LONG Index)
{
    lstrcpynW(m_ProfileParam, Profile, REALM_COLUMN_SIZE);
    return BaseExecute(Index);
}


//////////////////////////////////////////////////////////////////////////////
// SetRealmDetails
//////////////////////////////////////////////////////////////////////////////
void CRealms::SetRealmDetails(CPolicy& TempPolicy, CUtils& m_Utils)
{
    const LONG ACCT_PROVIDER_RADIUS_PROXY = 2;
    // From the Realm. Reg key should be used 
    _bstr_t     Constraint = L"MATCH(\"";
    DWORD       Identity   = 1;
    if ( m_Utils.UserIdentityAttributeSet() )
    {
        Identity = m_Utils.GetUserIdentityAttribute();
        switch (Identity)
        {
        case 30: //hardcoded value
            {
                Constraint += L"Called-Station-Id=";
                break;
            }
        case 31: //hardcoded value
            {
                Constraint += L"Calling-Station-Id=";
                break;
            }
        case 1: //hardcoded value
        default:
            {
                Constraint += L"User-Name=";
                break;
            }
        }
    }
    else
    {
        Constraint += L"User-Name=";
    }

    // beginning of line
    if ( m_Prefix )
    {
        Constraint += L"^";
    }
    _bstr_t     SuffixPrefix = m_SuffixPrefix;
    Constraint += SuffixPrefix;

    // end of line
    if ( !m_Prefix )
    {
        Constraint += L"$";
    }
    
    Constraint += L"\")";
    TempPolicy.SetmsNPConstraint(Constraint);

    TempPolicy.SetmsManipulationTarget(Identity);

    _bstr_t     Search;
    _bstr_t     Replace = L"";

    // If Strip is set, then replace (by nothing) the Suffix or Prefix
    if ( m_StripSuffixPrefix )
    {
        if ( m_Prefix )
        {
            Search += L"^";
        }

        Search += m_SuffixPrefix;

        if ( !m_Prefix )
        {
            Search += L"$";
        }
        TempPolicy.SetmsManipulationRules(Search, Replace);
    }

    // Forward Accounting bit
    if ( m_ForwardAccounting )
    {
        TempPolicy.SetmsAcctProviderType(ACCT_PROVIDER_RADIUS_PROXY);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\updatemschap.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      updatemschap.h
//
// Project:     Windows 2000 IAS
//
// Description: add the authentication types RAS_AT_MSCHAPPASS and 
//              RAS_AT_MSCHAP2PASS when RAS_AT_MSCHAP and RAS_AT_MSCHAP2
//              are in the profiles.
//
// Author:      tperraut 11/30/2000
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _UPDATEMSCHAP_H_
#define _UPDATEMSCHAP_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"

class CUpdateMSCHAP : private NonCopyable
{
public:
    explicit CUpdateMSCHAP(CGlobalData&    pGlobalData)
                : m_GlobalData(pGlobalData)
    {
    }

    void        Execute();

private:
   void UpdateProperties(LONG CurrentProfileIdentity);

    CGlobalData&             m_GlobalData;
};

#endif // _UPDATEMSCHAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      stdafx.h
//
// Project:     Windows 2000 IAS
//
// Description: 
//      include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _STDAFX_H_64176C8B_CC9E_4A96_8997_47FA8A21C843
#define _STDAFX_H_64176C8B_CC9E_4A96_8997_47FA8A21C843

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#define _ATL_APARTMENT_THREADED

#ifndef _UNICODE
#define _UNICODE
#endif
#ifndef UNICODE
#define UNICODE
#endif

#pragma warning( push )
#pragma warning( disable : 4700 )   // variable not initialized

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>
#include "atldb.h"

#pragma warning( pop )

#include <comutil.h>
#include <comdef.h>

#include <crtdbg.h>

#include <wchar.h>
#include <new>
#include <memory>

// next line for the constants like IAS_SYNTAX_OCTETSTRING, IAS_LOGGING_DAILY
#include "sdoias.h" 

#include "nocopy.h"
#include "utils.h"

// to improve building times:
#include <map>
#include <vector>

#include "Attributes.h"
#include "basetable.h"
#include "basecommand.h"
#include "Clients.h"
#include "DefaultProvider.h"
#include "doupgrade.h"
#include "GlobalData.h"
#include "Objects.h"
#include "migratemdb.h"
#include "migrateregistry.h"
#include "nocopy.h"
#include "Properties.h"
#include "profileattributelist.h"
#include "Profiles.h"
#include "Providers.h"
#include "proxyservergroupcollection.h"
#include "proxyserversgrouphelper.h"
#include "ProxyServerHelper.h"
#include "RadiusAttributeValues.h"
#include "Realms.h"
#include "RemoteRadiusServers.h"
#include "ServiceConfiguration.h"
#include "Version.h"

#endif // _STDAFX_H_64176C8B_CC9E_4A96_8997_47FA8A21C843
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\updatemschap.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      updatemschap.cpp
//
// Project:     Windows 2000 IAS
//
// Description: add the authentication types RAS_AT_MSCHAPPASS and 
//              RAS_AT_MSCHAP2PASS when RAS_AT_MSCHAP and RAS_AT_MSCHAP2
//              are in the profiles.
//
// Author:      tperraut 11/30/2000
//
// Revision     
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "GlobalData.h"
#include "updatemschap.h"
#include "Objects.h"
#include "Properties.h"
#include "sdoias.h"


void CUpdateMSCHAP::UpdateProperties(const LONG CurrentProfileIdentity)
{
   _bstr_t AuthenticationName = L"msNPAuthenticationType2";

   // Now get the properties for the current profile
   _bstr_t PropertyName;
   _bstr_t PropertyValue;

   LONG Type = 0;
   bool ChapSet      = false;
   bool Chap2Set     = false;
   bool ChapPassSet  = false;
   bool Chap2PassSet = false;

   LONG IndexProperty = 0;
   HRESULT hr = m_GlobalData.m_pProperties->GetProperty(
                                       CurrentProfileIdentity,
                                       PropertyName,
                                       Type,
                                       PropertyValue
                                       );

   while ( SUCCEEDED(hr) )
   {

      // msNPAuthenticationType2 property found
      if ( PropertyName == AuthenticationName )
      {
         if ( Type != VT_I4 )
         {
            _com_issue_error(E_UNEXPECTED);
         }

                    
         LONG AuthenticationType = _wtol(static_cast<wchar_t*>(PropertyValue));
         switch (AuthenticationType)
         {
         case IAS_AUTH_MSCHAP:
            {
               ChapSet = true;
               break;
            }
         case IAS_AUTH_MSCHAP2:
            {
               Chap2Set = true;
               break;
            }
         case IAS_AUTH_MSCHAP_CPW:
            {
               ChapPassSet = true;
               break;
            }
         case IAS_AUTH_MSCHAP2_CPW:
            {
               Chap2PassSet = true;
               break;
            }
         default:
            {
               break;
            }
         }
      }

      ++IndexProperty;

      hr = m_GlobalData.m_pProperties->GetNextProperty(
                                          CurrentProfileIdentity,
                                          PropertyName,
                                          Type,
                                          PropertyValue,
                                          IndexProperty
                                          );
   }

   // No property or no more properties for this profile
   
   // Insert the newproperties if necessary
   if ( ChapSet && !ChapPassSet )
   {
      // RAS_AT_MSCHAPPASS = 9
      wchar_t buffer[34]; // can convert 33 char max
      _ltow(IAS_AUTH_MSCHAP_CPW, buffer, 10); // radix 10

      _bstr_t  ChapPasswordValue(buffer);
      // now insert the new properties if needed
      m_GlobalData.m_pProperties->InsertProperty(
                                     CurrentProfileIdentity,
                                     AuthenticationName,
                                     VT_I4,
                                     ChapPasswordValue
                                     );
   }

   if ( Chap2Set && !Chap2PassSet )
   {
      // RAS_AT_MSCHAP2PASS = 10
      wchar_t buffer[34]; // can convert 33 char max
      _ltow(IAS_AUTH_MSCHAP2_CPW, buffer, 10); // radix 10

      _bstr_t  Chap2PasswordValue(buffer);
      // now insert the new properties if needed
      m_GlobalData.m_pProperties->InsertProperty(
                                     CurrentProfileIdentity,
                                     AuthenticationName,
                                     VT_I4,
                                     Chap2PasswordValue
                                     );
   }
}


//////////////////////////////////////////////////////////////////////////////
// Execute
//
// For each profile, if msNPAuthenticationType2 is RAS_AT_MSCHAP then add the 
//    msNPAuthenticationType2 RAS_AT_MSCHAPPASS
// if msNPAuthenticationType2 is RAS_AT_MSCHAP2 then add the 
//    msNPAuthenticationType2 RAS_AT_MSCHAP2PASS 
//
//////////////////////////////////////////////////////////////////////////////
void CUpdateMSCHAP::Execute()
{
   // Get the Profiles container identity 
   const WCHAR ProfilesPath[] = 
                                L"Root\0"
                                L"Microsoft Internet Authentication Service\0"
                                L"RadiusProfiles\0";

   LONG ProfilesIdentity;
   m_GlobalData.m_pObjects->WalkPath(ProfilesPath, ProfilesIdentity);


   // Get the first Profile (if any)
   _bstr_t CurrentProfileName;
   LONG    CurrentProfileIdentity;

   HRESULT hr = m_GlobalData.m_pObjects->GetObject(
                                            CurrentProfileName,
                                            CurrentProfileIdentity,
                                            ProfilesIdentity
                                            );
   // for each profiles in ias.mdb, execute the changes.
   LONG IndexObject = 0;

   // if hr is not S_OK, there's no profile, nothing to do
   while ( SUCCEEDED(hr) )
   {
      UpdateProperties(CurrentProfileIdentity);

      // now get the next profile
      ++IndexObject;
      hr = m_GlobalData.m_pObjects->GetNextObject(
                                       CurrentProfileName,
                                       CurrentProfileIdentity,
                                       ProfilesIdentity,
                                       IndexObject
                                       );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\version.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Version.cpp
//
// Project:     Windows 2000 IAS
//
// Description: Implementation of the CProperties class
//      works only with m_StdSession (database being upgraded)
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "version.h"


//////////////////////////////////////////////////////////////////////////////
// CVersionGet::GetVersion
//////////////////////////////////////////////////////////////////////////////
LONG CVersionGet::GetVersion()
{
    HRESULT hr = BaseExecute();
    if ( FAILED(hr) )
    {
        /////////////////////////////////////
        // The Version table does not exist.
        // return zero as the version # 
        /////////////////////////////////////
        
        ///////////////////////////
        // Set Zero as the version
        ///////////////////////////
        m_Version = 0;
    }
    Close();
    return m_Version;
}


//////////////////////////////////////////////////////////////////////////////
// CVersion::GetVersion
//////////////////////////////////////////////////////////////////////////////
LONG CVersion::GetVersion()
{
    CVersionGet  GetVer(m_Session);
    return GetVer.GetVersion();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\attributes.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Attributes.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the CAttributes class (for ias.mdb)
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _ATTRIBUTES_H_359EA54D_FA43_49C6_90CB_16EF58079642
#define _ATTRIBUTES_H_359EA54D_FA43_49C6_90CB_16EF58079642

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basecommand.h"

//////////////////////////////////////////////////////////////////////////////
// class CAttributesAcc
//////////////////////////////////////////////////////////////////////////////
class CAttributesAcc
{
protected:
    static const size_t DESCRIPTION_SIZE      = 245;
    static const size_t LDAP_NAME_SIZE        = 55;
    static const size_t NAME_SIZE             = 69;

    WCHAR           m_Description[DESCRIPTION_SIZE];
	VARIANT_BOOL    m_ExcludefromNT4IASLog;
	LONG            m_ID;
	VARIANT_BOOL    m_IsAllowedInCondition;
	VARIANT_BOOL    m_IsAllowedInProfile;
	VARIANT_BOOL    m_IsAllowedInProxyCondition;
	VARIANT_BOOL    m_IsAllowedInProxyProfile;
	WCHAR           m_LDAPName[LDAP_NAME_SIZE];
	VARIANT_BOOL    m_MultiValued;
	WCHAR           m_Name[NAME_SIZE];
	LONG            m_ODBCLogOrdinal;
	LONG            m_Syntax;
	LONG            m_VendorID;
	LONG            m_VendorLengthWidth;
	LONG            m_VendorTypeID;
	LONG            m_VendorTypeWidth;

BEGIN_COLUMN_MAP(CAttributesAcc)
	COLUMN_ENTRY(1, m_ID)
	COLUMN_ENTRY(2, m_Name)
	COLUMN_ENTRY(3, m_Syntax)
	COLUMN_ENTRY_TYPE(4, DBTYPE_BOOL, m_MultiValued)
	COLUMN_ENTRY(5, m_VendorID)
	COLUMN_ENTRY(6, m_VendorTypeID)
	COLUMN_ENTRY(7, m_VendorTypeWidth)
	COLUMN_ENTRY(8, m_VendorLengthWidth)
	COLUMN_ENTRY_TYPE(9, DBTYPE_BOOL, m_ExcludefromNT4IASLog)
	COLUMN_ENTRY(10, m_ODBCLogOrdinal)
	COLUMN_ENTRY_TYPE(11, DBTYPE_BOOL, m_IsAllowedInProfile)
	COLUMN_ENTRY_TYPE(12, DBTYPE_BOOL, m_IsAllowedInCondition)
	COLUMN_ENTRY_TYPE(13, DBTYPE_BOOL, m_IsAllowedInProxyProfile)
	COLUMN_ENTRY_TYPE(14, DBTYPE_BOOL, m_IsAllowedInProxyCondition)
	COLUMN_ENTRY(15, m_Description)
	COLUMN_ENTRY(16, m_LDAPName)
END_COLUMN_MAP()

    LONG    m_IDParam;

BEGIN_PARAM_MAP(CAttributesAcc)
	COLUMN_ENTRY(1, m_IDParam)
END_PARAM_MAP()


DEFINE_COMMAND(CAttributesAcc, L" \
	SELECT \
		ID, \
		Name, \
		Syntax, \
		MultiValued, \
		VendorID, \
		VendorTypeID, \
		VendorTypeWidth, \
		VendorLengthWidth, \
		`Exclude from NT4 IAS Log`, \
		`ODBC Log Ordinal`, \
		IsAllowedInProfile, \
		IsAllowedInCondition, \
		IsAllowedInProxyProfile, \
		IsAllowedInProxyCondition, \
		Description, \
		LDAPName  \
		FROM Attributes \
        WHERE ID = ?")
};


//////////////////////////////////////////////////////////////////////////////
// class CAttributes
//////////////////////////////////////////////////////////////////////////////
class CAttributes : public CBaseCommand<CAccessor<CAttributesAcc> >,
                    private NonCopyable
{
public:
    CAttributes(CSession& Session);

    //////////////////////////////////////////////////////////////////////////
    // GetAttribute
    //////////////////////////////////////////////////////////////////////////
    HRESULT GetAttribute(
                            LONG            ID,
                            _bstr_t&        LDAPName,
                            LONG&           Syntax,
                            BOOL&           IsMultiValued
                        );
};

#endif // _ATTRIBUTES_H_359EA54D_FA43_49C6_90CB_16EF58079642
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\utils.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999-2000 Microsoft Corporation all rights reserved.
//
// Module:      utils.cpp
//
// Project:     Windows 2000 IAS
//
// Description: IAS 4 to Windows 2000 Migration Utility Functions
//
//              Used mostly by the NT4 migration code
//
// Author:      TLP 1/13/1999
//
//
// Revision     02/24/2000 Moved to a separate dll
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _UTILS_H_643D9D3E_AD27_4c9e_8ECC_CCB7B8A1AC19
#define _UTILS_H_643D9D3E_AD27_4c9e_8ECC_CCB7B8A1AC19

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"

class CUtils : private NonCopyable
{
protected:
    CUtils();

public:
    static  CUtils& Instance();

    LONG    GetAuthSrvDirectory(/*[in]*/ _bstr_t& pszDir) const;
    LONG    GetIAS2Directory(   /*[in]*/ _bstr_t& pszDir) const;

    void    DeleteOldIASFiles();
    
    BOOL    IsWhistler() const throw();
    BOOL    IsNT4Isp()   const throw();
    BOOL    IsNT4Corp()  const throw();
    BOOL    OverrideUserNameSet()      const throw();
    BOOL    UserIdentityAttributeSet() const throw();
    
    void    NewGetAuthSrvParameter(
                                    /*[in]*/  LPCWSTR   szParameterName,
                                    /*[out]*/ DWORD&    DwordValue
                                  ) const;

    
    DWORD   GetUserIdentityAttribute() const throw();

    static const WCHAR AUTHSRV_PARAMETERS_KEY[];
    static const WCHAR SERVICES_KEY[];

private:
    static CUtils _instance;

    void    GetVersion();
    void    GetRealmParameters() throw();
    
    static const WCHAR           IAS_KEY[];
    static const WCHAR*          m_FilesToDelete[];
    static const int             m_NbFilesToDelete;
    
    BOOL                         m_IsNT4ISP;
    BOOL                         m_IsNT4CORP;
    BOOL                         m_OverrideUserNameSet;
    BOOL                         m_UserIdentityAttributeSet;
    DWORD                        m_UserIdentityAttribute;
};

#endif // _UTILS_H_643D9D3E_AD27_4c9e_8ECC_CCB7B8A1AC19
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\basecommand.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      BaseCommand.H 
//
// Project:     Windows 2000 IAS
//
// Description: Declaration of the CBaseCommand class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _BASE_COMMAND_H_CC774BB1_DFE3_4730_96B7_7F7764CC54DC
#define _BASE_COMMAND_H_CC774BB1_DFE3_4730_96B7_7F7764CC54DC

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

///////////////////////////////////////////////////////////////////////////
// CBaseCommand
template <class TAccessor>
class CBaseCommand : public CCommand<TAccessor>
{
public:
    CBaseCommand()
                 :pPropSet(NULL),
                  pRowsAffected(NULL),
                  bBind(TRUE)
    {
    };

    void        Init(CSession& Session);
    virtual     ~CBaseCommand() throw(); 

    HRESULT     BaseExecute();
    HRESULT     BaseExecute(LONG    Index);

protected:
    DBPARAMS    params;
	DBPARAMS*   pParams;
    DBPROPSET*  pPropSet;
    LONG_PTR*   pRowsAffected;
    BOOL        bBind;
};


//////////////////////////////////////////////////////////////////////////////
// Init
//////////////////////////////////////////////////////////////////////////////
template <class TAccessor> void CBaseCommand<TAccessor>::Init(
                                                              CSession& Session
                                                             )
{
    LPCWSTR     szCommand = NULL;
    _com_util::CheckError(GetDefaultCommand(&szCommand));
    _com_util::CheckError(Create(Session, szCommand));
    
	// Bind the parameters if we have some
	if (_ParamClass::HasParameters())
	{
		// Bind the parameters in the accessor if they haven't already been bound
        _com_util::CheckError(BindParameters(
                                                &m_hParameterAccessor, 
                                                m_spCommand, 
                                                &params.pData
                                             ));

		// Setup the DBPARAMS structure
		params.cParamSets = 1;
		params.hAccessor  = m_hParameterAccessor;
		pParams           = &params;
	}
	else
    {
		pParams = NULL;
    }

}


//////////////////////////////////////////////////////////////////////////////
// Destructor
//////////////////////////////////////////////////////////////////////////////
template <class TAccessor> CBaseCommand<TAccessor>::~CBaseCommand()
{
    Close();
    ReleaseCommand();
}

//////////////////////////////////////////////////////////////////////////////
// BaseExecute
//////////////////////////////////////////////////////////////////////////////
template <class TAccessor> HRESULT CBaseCommand<TAccessor>::BaseExecute()
{
	HRESULT hr = Execute(GetInterfacePtr(), pParams, pPropSet, pRowsAffected);
    if ( SUCCEEDED(hr) )
    {
	    // Only bind if we have been asked to and we have output columns
	    if (bBind && _OutputColumnsClass::HasOutputColumns())
        {
            _com_util::CheckError(Bind());
        }

        hr = MoveNext();
        Close();
        if ( hr == S_OK )
        {
            return hr;
        }
        else if ( SUCCEEDED(hr) )
        {
            hr = E_FAIL;
        }
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// BaseExecute overloaded
//////////////////////////////////////////////////////////////////////////////
template <class TAccessor> HRESULT CBaseCommand<TAccessor>::BaseExecute(
                                                                LONG  Index        
                                                                       )
{
	HRESULT hr = Execute(GetInterfacePtr(), pParams, pPropSet, pRowsAffected);
    if ( SUCCEEDED(hr) )
    {
	    // Only bind if we have been asked to and we have output columns
	    if (bBind && _OutputColumnsClass::HasOutputColumns())
        {
            _com_util::CheckError(Bind());
        }

        hr = MoveNext(Index, true);
        Close();
        if ( hr == S_OK )
        {
            return hr;
        }
        else if ( SUCCEEDED(hr) )
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

#endif // _BASE_COMMAND_H_CC774BB1_DFE3_4730_96B7_7F7764CC54DC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\utils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999-2000 Microsoft Corporation all rights reserved.
//
// Module:      utils.cpp
//
// Project:     Windows 2000 IAS
//
// Description: IAS NT 4 to IAS W2K Migration Utility Functions
//
// Author:      TLP 1/13/1999
//
//
// Revision     02/24/2000 Moved to a separate dll
//
// TODO: IsWhistler() put the correct minorversion for Whistler RTM.
//       i.e. if that's Win2k 5.1 ?
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "lm.h"

#ifndef celems
    #define celems(_x)          (sizeof(_x) / sizeof(_x[0]))
#endif

const WCHAR *CUtils::m_FilesToDelete[] =
{
   L"_adminui.mdb",
   L"_adminui.ldb",
   L"actlapi.dll",
   L"actlapi2.dll",
   L"adminui.chm",
   L"adminui.cnt",
   L"adminui.exe",
   L"adminui.gid",
   L"adminui.hlp",
   L"authdll.dll",
   L"authdll2.dll",
   L"authodbc.dll",
   L"authperf.dll",
   L"authperf.h",
   L"authperf.ini",
   L"authsam.dll",
   L"authsrv.exe",
   L"client",
   L"clients",
   L"dbcon.dll",
   L"dictionary",
   L"hhctrl.ocx",
   L"hhwrap.dll",
   L"iasconf.dll",
   L"radcfg.dll",
   L"radlog.dll",
   L"radstp.dll",
   L"user",
   L"users",
};

const int CUtils::m_NbFilesToDelete = celems(m_FilesToDelete);

const WCHAR CUtils::IAS_KEY[] = L"SYSTEM\\CurrentControlSet\\Services\\"
                                L"RemoteAccess\\Policy";

const WCHAR CUtils::AUTHSRV_PARAMETERS_KEY[] = L"SYSTEM\\CurrentControlSet\\"
                                           L"Services\\AuthSrv\\Parameters";

const WCHAR CUtils::SERVICES_KEY[] = L"SYSTEM\\CurrentControlSet\\"
                                    L"Services";

CUtils CUtils::_instance;

CUtils& CUtils::Instance()
{
    return _instance;
}

//////////////////////////////////////////////////////////////////////////////
// Constructor
// Init the BOOL static variables
//////////////////////////////////////////////////////////////////////////////
CUtils::CUtils()
                :m_IsNT4ISP(FALSE),
                 m_IsNT4CORP(FALSE),
                 m_OverrideUserNameSet(FALSE),
                 m_UserIdentityAttributeSet(FALSE),
                 m_UserIdentityAttribute(RADIUS_ATTRIBUTE_USER_NAME)
{
    GetVersion();
    GetRealmParameters();
};


//////////////////////////////////////////////////////////////////////////////
// GetAuthSrvDirectory
//////////////////////////////////////////////////////////////////////////////
LONG CUtils::GetAuthSrvDirectory(/*[out]*/ _bstr_t& pszDir) const
{
    static _bstr_t  AuthSrvDirString;
    static BOOL     AuthSrvDirValid = FALSE;

    LONG lResult = ERROR_SUCCESS;

    if ( !AuthSrvDirValid )
    {
        CRegKey Key;
        lResult = Key.Open( 
                              HKEY_LOCAL_MACHINE, 
                              AUTHSRV_PARAMETERS_KEY, 
                              KEY_READ 
                          );
        if ( lResult == ERROR_SUCCESS )
        {
            DWORD dwAuthSrvDirLength = MAX_PATH;
            WCHAR TempString[MAX_PATH];
            lResult = Key.QueryValue(
                                        TempString,
                                        L"DefaultDirectory", 
                                        &dwAuthSrvDirLength
                                    );
            if ( lResult == ERROR_SUCCESS )
            {
                AuthSrvDirString = TempString;
                AuthSrvDirValid  = TRUE;
            }
            Key.Close();
        }
    }
    if ( lResult == ERROR_SUCCESS )
    {
        pszDir = AuthSrvDirString;
    }       
    return lResult;
}


//////////////////////////////////////////////////////////////////////////////
// GetIASDirectory
//////////////////////////////////////////////////////////////////////////////
LONG CUtils::GetIAS2Directory(/*[in]*/ _bstr_t& pszDir) const
{
    static  _bstr_t  IASDirString;
    static  BOOL     IASDirValid = FALSE;

    LONG    lResult = ERROR_SUCCESS;

    if ( ! IASDirValid )
    {
        CRegKey Key;
        lResult = Key.Open( 
                             HKEY_LOCAL_MACHINE, 
                             IAS_KEY, 
                             KEY_READ 
                          );
        if ( lResult == ERROR_SUCCESS )
        {
            DWORD IASDirLength = MAX_PATH;
            WCHAR TempString[MAX_PATH];
            lResult = Key.QueryValue(
                                        TempString, 
                                        L"ProductDir", 
                                        &IASDirLength
                                     );
            
            if ( lResult == ERROR_SUCCESS )
            {
                IASDirString = TempString;
                IASDirValid = TRUE;
            }
            Key.Close();
        }
    }
    if ( lResult == ERROR_SUCCESS )
    {
        pszDir = IASDirString;
    }       
    return lResult;
}


//////////////////////////////////////////////////////////////////////////////
// DeleteOldIASFiles
//////////////////////////////////////////////////////////////////////////////
void CUtils::DeleteOldIASFiles()
{
    do
    {
        _bstr_t     szAdminuiDirectory;
        LONG        lResult = GetAuthSrvDirectory(szAdminuiDirectory);
        
        if ( lResult != ERROR_SUCCESS )
        {
            break;
        }

        _bstr_t szAdminuiMDB = szAdminuiDirectory;
        szAdminuiMDB += L"\\";
        _bstr_t szTempString;

        for (int i=0; i < m_NbFilesToDelete; ++i)
        {
            szTempString = szAdminuiMDB;
            szTempString += m_FilesToDelete[i];
            DeleteFile(szTempString); // result ignored
        }

        RemoveDirectoryW(szAdminuiDirectory); // result ignored

        // Delete the share
        // Return value ignored (nothing to do if that doesn't work)
        // const string used when LPWSTR expected
        NetShareDel(NULL, L"IAS1$", 0); 
    }
    while (FALSE);  
}


//////////////////////////////////////////////////////////////////////////////
// GetVersion
//
// No Key = Win2k or whistler
// Version = CORP: IAS 1.0 without Proxy
// Version = ISP: IAS 1.0 MCIS (Proxy) 
//////////////////////////////////////////////////////////////////////////////
void CUtils::GetVersion()
{
    CRegKey     Key;
    LONG        lResult = Key.Open( 
                                      HKEY_LOCAL_MACHINE, 
                                      AUTHSRV_PARAMETERS_KEY, 
                                      KEY_READ 
                                  );

    if ( lResult != ERROR_SUCCESS )
    {
        // IsWhistler will really check what version of IAS is installed
        // the only sure thing here is that it isn't NT4
        return;
    }

    DWORD   dwAuthSrvDirLength = MAX_PATH;
    WCHAR   TempString[MAX_PATH];
    lResult = Key.QueryValue(
                                TempString,
                                L"Version", 
                                &dwAuthSrvDirLength
                             );
    if ( lResult == ERROR_SUCCESS )
    {
        _bstr_t Value = TempString;
        _bstr_t Isp   = L"ISP";
        _bstr_t Corp  = L"CORP";
        if ( Value == Isp )
        {
            m_IsNT4ISP = TRUE;
        }
        else if ( Value == Corp )
        {
            m_IsNT4CORP = TRUE;
        }
        // else it isn't NT4
    }
    Key.Close();
}


//////////////////////////////////////////////////////////////////////////////
// IsNT4Corp
//////////////////////////////////////////////////////////////////////////////
BOOL CUtils::IsNT4Corp() const
{
    return m_IsNT4CORP;
}


//////////////////////////////////////////////////////////////////////////////
// IsNT4Isp
//////////////////////////////////////////////////////////////////////////////
BOOL CUtils::IsNT4Isp() const
{
    return m_IsNT4ISP;
}


//////////////////////////////////////////////////////////////////////////////
// IsWhistler
//
// cheapper to check the OS version than check the Database Version number.
// TODO: put the correct minorversion for Whistler RTM.
// i.e. if that's Win2k 5.1 ?
//////////////////////////////////////////////////////////////////////////////
BOOL CUtils::IsWhistler() const
{
    OSVERSIONINFOEX  osvi;
    DWORDLONG        dwlConditionMask = 0;

    // Initialize the OSVERSIONINFOEX structure.
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.dwMajorVersion = 5;
    osvi.dwMinorVersion = 0;
    osvi.dwBuildNumber  = 2195;

    // Initialize the condition mask.
    // at least Win2k RTM
    VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL);

    // but with a greater build number than RTM
    // that will have to be set properly for Whistler RTM
    VER_SET_CONDITION(dwlConditionMask, VER_BUILDNUMBER,  VER_GREATER);

    // Perform the test.
    return VerifyVersionInfo(
                  &osvi, 
                  VER_MAJORVERSION | VER_MINORVERSION | VER_BUILDNUMBER,
                  dwlConditionMask);
}


//////////////////////////////////////////////////////////////////////////////
// OverrideUserNameSet
//////////////////////////////////////////////////////////////////////////////
BOOL CUtils::OverrideUserNameSet() const
{
    return m_OverrideUserNameSet;
}


//////////////////////////////////////////////////////////////////////////////
// GetUserIdentityAttribute
//////////////////////////////////////////////////////////////////////////////
DWORD CUtils::GetUserIdentityAttribute() const
{
    return m_UserIdentityAttribute;
}


//////////////////////////////////////////////////////////////////////////////
// GetRealmParameters
//////////////////////////////////////////////////////////////////////////////
void CUtils::GetRealmParameters() 
{
    const WCHAR USER_IDENTITY_ATTRIBUTE[] = L"User Identity Attribute";
    const WCHAR OVERRIDE_USER_NAME[]      = L"Override User-Name";
    CRegKey Key;
    LONG    lResult = Key.Open( 
                                 HKEY_LOCAL_MACHINE, 
                                 IAS_KEY, 
                                 KEY_READ 
                              );

    if ( lResult == ERROR_SUCCESS )
    {
        lResult = Key.QueryValue(
                                    m_UserIdentityAttribute,
                                    USER_IDENTITY_ATTRIBUTE
                                 );
        if ( lResult == ERROR_SUCCESS )
        {
            m_UserIdentityAttributeSet = TRUE;
        }

        DWORD   Override;
        lResult = Key.QueryValue(
                                    Override,
                                    OVERRIDE_USER_NAME
                                 );
        if ( lResult == ERROR_SUCCESS )
        {
            Override ? m_OverrideUserNameSet = TRUE
                     : m_OverrideUserNameSet = FALSE;
        }
        Key.Close();
    }
}


//////////////////////////////////////////////////////////////////////////////
// NewGetAuthSrvParameter 
//////////////////////////////////////////////////////////////////////////////
void CUtils::NewGetAuthSrvParameter(
                                      /*[in]*/  LPCWSTR   szParameterName,
                                      /*[out]*/ DWORD&    DwordValue
                                   ) const
{
    CRegKey     Key;
    LONG        Result = Key.Open(
                                    HKEY_LOCAL_MACHINE,
                                    AUTHSRV_PARAMETERS_KEY,
                                    KEY_READ
                                 );
    if ( Result != ERROR_SUCCESS )
    {
        _com_issue_error(E_ABORT);
    }

    Result = Key.QueryValue(DwordValue, szParameterName);
    if ( Result != ERROR_SUCCESS )
    {
        _com_issue_error(E_ABORT);
    }
}


//////////////////////////////////////////////////////////////////////////////
// UserIdentityAttributeSet
//////////////////////////////////////////////////////////////////////////////
BOOL CUtils::UserIdentityAttributeSet() const
{
    return m_UserIdentityAttributeSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\basetable.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      BaseTable.H 
//
// Project:     Windows 2000 IAS
//
// Description: Declaration of the CBaseTable class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _BASE_TABLE_H_2836DAC4_B4E1_4658_9EB5_EB9301AA3951
#define _BASE_TABLE_H_2836DAC4_B4E1_4658_9EB5_EB9301AA3951

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

///////////////////////////////////////////////////////////////////////////
// CBaseTable
template <class TAccessor>
class CBaseTable : public CTable<TAccessor>
{
public:
    void Init(CSession& Session, LPCWSTR TableName);
    virtual ~CBaseTable() throw(); 

    void        Reset();
    HRESULT     GetNext();

};


//////////////////////////////////////////////////////////////////////////////
// Init
//////////////////////////////////////////////////////////////////////////////
template <class TAccessor> void CBaseTable<TAccessor>::Init(
                                                        CSession& Session,
                                                        LPCWSTR   TableName
                                                      )
{
    _com_util::CheckError(Open(Session, TableName));
    _com_util::CheckError(MoveFirst());
}


//////////////////////////////////////////////////////////////////////////////
// Destructor
//////////////////////////////////////////////////////////////////////////////
template <class TAccessor> CBaseTable<TAccessor>::~CBaseTable()
{
    Close();
}


//////////////////////////////////////////////////////////////////////////
// Reset
//////////////////////////////////////////////////////////////////////////
template <class TAccessor> void CBaseTable<TAccessor>::Reset() 
{
    _com_util::CheckError(MoveFirst());
}


//////////////////////////////////////////////////////////////////////////
// GetNext
//////////////////////////////////////////////////////////////////////////
template <class TAccessor> HRESULT CBaseTable<TAccessor>::GetNext() 
{
    return MoveNext();
}
#endif // _BASE_TABLE_H_2836DAC4_B4E1_4658_9EB5_EB9301AA3951
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\defaultprovider.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      DefaultProvider.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the CDefaultProvider class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _DEFAULTPROVIDER_H_1B622442_4568_4fb9_831D_2ECA39B6E7B5
#define _DEFAULTPROVIDER_H_1B622442_4568_4fb9_831D_2ECA39B6E7B5

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basecommand.h"

//////////////////////////////////////////////////////////////////////////////
// class CDefaultProviderAcc
//////////////////////////////////////////////////////////////////////////////
class CDefaultProviderAcc
{
protected:
    static const size_t COLUMN_SIZE = 65;

    VARIANT_BOOL    m_ForwardAccounting;
    VARIANT_BOOL    m_LogoutAccounting;
    VARIANT_BOOL    m_SupressAccounting;
    WCHAR           m_Profile[COLUMN_SIZE];
    WCHAR           m_UserDefinedName[COLUMN_SIZE];

BEGIN_COLUMN_MAP(CDefaultProviderAcc)
    COLUMN_ENTRY(1, m_UserDefinedName)
    COLUMN_ENTRY(2, m_Profile)
    COLUMN_ENTRY_TYPE(3, DBTYPE_BOOL, m_ForwardAccounting)
    COLUMN_ENTRY_TYPE(4, DBTYPE_BOOL, m_SupressAccounting)
    COLUMN_ENTRY_TYPE(5, DBTYPE_BOOL, m_LogoutAccounting)
END_COLUMN_MAP()

DEFINE_COMMAND(CDefaultProviderAcc, L" \
    SELECT \
        `User Defined Name`, \
        szProfile, \
        bForwardAccounting, \
        bSupressAccounting, \
        bLogoutAccounting \
        FROM `Default Provider`")

};

//////////////////////////////////////////////////////////////////////////////
// class CDefaultProvider 
//////////////////////////////////////////////////////////////////////////////
class CDefaultProvider : public CBaseCommand<CAccessor<CDefaultProviderAcc> >,
                         private NonCopyable
{
public:
    explicit CDefaultProvider(CSession&     Session) 
    {
        Init(Session);
    }

    //////////////////////////////////////////////////////////////////////////
    // GetDefaultProvider
    //////////////////////////////////////////////////////////////////////////
    HRESULT GetDefaultProvider(
                                  _bstr_t&        UserDefinedName,
                                  _bstr_t&        Profile,
                                  VARIANT_BOOL&   ForwardAccounting,
                                  VARIANT_BOOL&   SupressAccounting,
                                  VARIANT_BOOL&   LogoutAccounting
                              );
};

#endif // _DEFAULTPROVIDER_H_1B622442_4568_4fb9_831D_2ECA39B6E7B5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\clients.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Clients.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the CClients class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _CLIENTS_H_3C35A02E_B41D_478e_9EB2_57424DA21F96
#define _CLIENTS_H_3C35A02E_B41D_478e_9EB2_57424DA21F96

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "nocopy.h"
#include "basetable.h"

//////////////////////////////////////////////////////////////////////////////
// class CClientsAcc
//////////////////////////////////////////////////////////////////////////////
class CClientsAcc 
{
protected:
    static const size_t NAME_SIZE = 256;

	LONG    m_HostNameType;
	WCHAR   m_HostName[NAME_SIZE];
	WCHAR   m_PrevSecret[NAME_SIZE];
	WCHAR   m_Secret[NAME_SIZE];

BEGIN_COLUMN_MAP(CClientsAcc)
	COLUMN_ENTRY(1, m_HostName)
	COLUMN_ENTRY(2, m_HostNameType)
	COLUMN_ENTRY(3, m_Secret)
	COLUMN_ENTRY(4, m_PrevSecret)
END_COLUMN_MAP()
};


//////////////////////////////////////////////////////////////////////////////
// class CClients 
//////////////////////////////////////////////////////////////////////////////
class CClients : public CBaseTable<CAccessor<CClientsAcc> >,
                 private NonCopyable
{ 
public:
    CClients(CSession& Session)
    {
        // To check if the table is empty
        m_HostNameType = -1;
        Init(Session, L"Clients");
    }

    //////////////////////////////////////////////////////////////////////////
    // IsEmpty
    //////////////////////////////////////////////////////////////////////////
    BOOL IsEmpty() const throw() 
    {
        if ( m_HostNameType == -1 )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }


    //////////////////////////////////////////////////////////////////////////
    // GetHostName
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR GetHostName() const throw() 
    {
        return m_HostName;
    }


    //////////////////////////////////////////////////////////////////////////
    // GetSecret
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR GetSecret() const throw()
    {
	    return m_Secret;
    }

};

#endif // _CLIENTS_H_3C35A02E_B41D_478e_9EB2_57424DA21F96
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\objects.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Objects.H 
//
// Project:     Windows 2000 IAS
//
// Description: Declaration of the CObjects class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _OBJECT_H_3A179338_CF1E_4932_8663_9F6AE0F03AA5
#define _OBJECT_H_3A179338_CF1E_4932_8663_9F6AE0F03AA5

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basecommand.h"

class CObjects : private NonCopyable
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructor
    //////////////////////////////////////////////////////////////////////////
    explicit CObjects(CSession& CurrentSession);

    //////////////////////////////////////////////////////////////////////////
    // Destructor
    //////////////////////////////////////////////////////////////////////////
    virtual ~CObjects() throw();

    //////////////////////////////////////////////////////////////////////////
    // GetObject 
    //////////////////////////////////////////////////////////////////////////
    HRESULT GetObject(_bstr_t& Name, LONG& Identity, LONG Parent);

    //////////////////////////////////////////////////////////////////////////
    // GetNextObject 
    //////////////////////////////////////////////////////////////////////////
    HRESULT GetNextObject(  
                            _bstr_t&    Name, 
                            LONG&       Identity, 
                            LONG        Parent, 
                            LONG        Index
                         ) throw();

    //////////////////////////////////////////////////////////////////////////
    // WalkPath
    //////////////////////////////////////////////////////////////////////////
    void WalkPath(LPCWSTR Path, LONG& Identity, LONG Parent = 1);

    //////////////////////////////////////////////////////////////////////////
    // GetObjectIdentity
    //////////////////////////////////////////////////////////////////////////
    HRESULT GetObjectIdentity(
                                _bstr_t&    Name, 
                                LONG&       Parent, 
                                LONG        Identity
                             ) throw();
    //////////////////////////////////////////////////////////////////////////
    // GetObjectNameParent
    //////////////////////////////////////////////////////////////////////////
    HRESULT GetObjectNameParent(
                                   const _bstr_t&   Name, 
                                         LONG       Parent, 
                                         LONG&      Identity
                               ) throw();
    //////////////////////////////////////////////////////////////////////////
    // DeleteObject
    //////////////////////////////////////////////////////////////////////////
    HRESULT DeleteObject(LONG Identity);
    //////////////////////////////////////////////////////////////////////////
    // InsertObject
    //////////////////////////////////////////////////////////////////////////
    BOOL InsertObject(
                         const _bstr_t&     Name,
                               LONG         Parent,
                               LONG&        Identity
                     );


private:
    //////////////////////////////////////////////////////////////////////////
    // OBJECTS COMMAND CLASSES START
    //////////////////////////////////////////////////////////////////////////
    struct CBaseObjectConst
    {
        static const int NAME_SIZE = 256;
    };

    //////////////////////////////////////////////////////////////////////////
    // class CObjectsAccSelectParent
    //////////////////////////////////////////////////////////////////////////
    class CObjectsAccSelectParent : public CBaseObjectConst
    {
    protected:
        LONG    m_Identity;
	    WCHAR   m_Name[NAME_SIZE];
	    LONG    m_Parent;

    BEGIN_COLUMN_MAP(CObjectsAccSelectParent)
	    COLUMN_ENTRY(1, m_Identity)
	    COLUMN_ENTRY(2, m_Name)
	    COLUMN_ENTRY(3, m_Parent)
    END_COLUMN_MAP()

        WCHAR m_NameParam[NAME_SIZE];
        LONG  m_ParentParam;

    BEGIN_PARAM_MAP(CObjectsAccSelectParent)
	    COLUMN_ENTRY(1, m_ParentParam)
    END_PARAM_MAP()

    DEFINE_COMMAND(CObjectsAccSelectParent, L" \
                   SELECT * \
                   FROM Objects \
                   WHERE Parent = ?");
    };

    //////////////////////////////////////////////////////////////////////////
    // class CObjectsCommandGet 
    //////////////////////////////////////////////////////////////////////////
    class CObjectsCommandGet : 
            public CBaseCommand<CAccessor<CObjectsAccSelectParent> >
    {
    public:
        explicit CObjectsCommandGet(CSession& CurrentSession);

        //////////////////////////////////////////////////////////////////////
        // GetObject 
        //////////////////////////////////////////////////////////////////////
        HRESULT GetObject(_bstr_t& Name, LONG& Identity, LONG Parent);

        //////////////////////////////////////////////////////////////////////
        // GetObject overloaded
        //////////////////////////////////////////////////////////////////////
        HRESULT GetObject(
                            _bstr_t&    Name, 
                            LONG&       Identity, 
                            LONG        Parent, 
                            LONG        Index);
    };


    //////////////////////////////////////////////////////////////////////////
    // class CObjectsAccSelectIdentity
    //////////////////////////////////////////////////////////////////////////
    class CObjectsAccSelectIdentity : public CBaseObjectConst
    {
    protected:
	    LONG    m_Identity;
	    WCHAR   m_Name[NAME_SIZE];
	    LONG    m_Parent;

    BEGIN_COLUMN_MAP(CObjectsAccSelectIdentity)
	    COLUMN_ENTRY(1, m_Identity)
	    COLUMN_ENTRY(2, m_Name)
	    COLUMN_ENTRY(3, m_Parent)
    END_COLUMN_MAP()

        LONG  m_IdentityParam;

    BEGIN_PARAM_MAP(CObjectsAccSelectIdentity)
	    COLUMN_ENTRY(1, m_IdentityParam)
    END_PARAM_MAP()

    DEFINE_COMMAND(CObjectsAccSelectIdentity, L" \
                   SELECT *  \
                   FROM Objects \
                   WHERE Identity = ?");

    };


    //////////////////////////////////////////////////////////////////////////
    // class CObjectsCommandIdentity
    //////////////////////////////////////////////////////////////////////////
    class CObjectsCommandIdentity : 
            public CBaseCommand<CAccessor<CObjectsAccSelectIdentity> >
    {
    public:
        explicit CObjectsCommandIdentity(CSession& CurrentSession);

        //////////////////////////////////////////////////////////////////////
        // GetObjectIdentity
        //////////////////////////////////////////////////////////////////////
        HRESULT GetObjectIdentity(
                                      _bstr_t&  Name, 
                                      LONG&     Parent, 
                                      LONG      Identity
                                 );
    };


    //////////////////////////////////////////////////////////////////////////
    // class CObjectsAccSelectNameParent
    //////////////////////////////////////////////////////////////////////////
    class CObjectsAccSelectNameParent : public CBaseObjectConst
    {
    protected:
        LONG m_Identity;
	    WCHAR m_Name[NAME_SIZE];
	    LONG m_Parent;

    BEGIN_COLUMN_MAP(CObjectsAccSelectNameParent)
	    COLUMN_ENTRY(1, m_Identity)
	    COLUMN_ENTRY(2, m_Name)
	    COLUMN_ENTRY(3, m_Parent)
    END_COLUMN_MAP()

        WCHAR m_NameParam[NAME_SIZE];
        LONG  m_ParentParam;

    BEGIN_PARAM_MAP(CObjectsAccSelectNameParent)
	    COLUMN_ENTRY(1, m_NameParam)
	    COLUMN_ENTRY(2, m_ParentParam)
    END_PARAM_MAP()

    DEFINE_COMMAND(CObjectsAccSelectNameParent, L" \
                   SELECT * \
                   FROM Objects \
                   WHERE Name = ? AND Parent = ?");
    };


    //////////////////////////////////////////////////////////////////////////
    // class CObjectsCommandNameParent
    //////////////////////////////////////////////////////////////////////////
    class CObjectsCommandNameParent : 
            public CBaseCommand<CAccessor<CObjectsAccSelectNameParent> >
    {
    public:
        explicit CObjectsCommandNameParent(CSession& CurrentSession);

        //////////////////////////////////////////////////////////////////////
        // GetObjectNameParent
        //
        // works on CObjectsAccSelectNameParent
        //////////////////////////////////////////////////////////////////////
        HRESULT GetObjectNameParent(
                                      const _bstr_t&    Name, 
                                            LONG        Parent, 
                                            LONG&       Identity
                                   );
    };


    //////////////////////////////////////////////////////////////////////////
    // class CObjectsCommandPath 
    //////////////////////////////////////////////////////////////////////////
    class CObjectsCommandPath : 
            public CBaseCommand<CAccessor<CObjectsAccSelectNameParent> >
    {
    public:
        explicit CObjectsCommandPath(CSession& CurrentSession);

        //////////////////////////////////////////////////////////////////////
        // WalkPath
        //////////////////////////////////////////////////////////////////////
        void WalkPath(LPCWSTR Path, LONG& Identity, LONG Parent = 1);
    };

            
    //////////////////////////////////////////////////////////////////////////
    // class CObjectsAccDelete
    //////////////////////////////////////////////////////////////////////////
    class CObjectsAccDelete : public CBaseObjectConst
    {
    protected: 
        LONG m_IdentityParam;

    BEGIN_PARAM_MAP(CObjectsAccDelete)
	    COLUMN_ENTRY(1, m_IdentityParam)
    END_PARAM_MAP()

    DEFINE_COMMAND(CObjectsAccDelete, L" \
                   DELETE \
                   FROM Objects \
                   WHERE Identity = ?");
    };


    //////////////////////////////////////////////////////////////////////////
    // class CObjectsCommandDelete
    //////////////////////////////////////////////////////////////////////////
    class CObjectsCommandDelete : 
            public CBaseCommand<CAccessor<CObjectsAccDelete> >
    {
    public:
        explicit CObjectsCommandDelete(CSession& CurrentSession);

        //////////////////////////////////////////////////////////////////////
        // DeleteObject
        //
        // works on CObjectsAccDelete
        //////////////////////////////////////////////////////////////////////
        HRESULT DeleteObject(LONG Identity);
    };


    //////////////////////////////////////////////////////////////////////////
    // class CObjectsAccInsert
    //////////////////////////////////////////////////////////////////////////
    class CObjectsAccInsert : public CBaseObjectConst
    {
    protected:

	    // You may wish to call this function if you are inserting a record
        // and wish to
	    // initialize all the fields, if you are not going to explicitly 
        // set all of them.
	    void ClearRecord()
	    {
		    memset(this, 0, sizeof(*this));
	    }

        WCHAR m_NameParam[NAME_SIZE];
        LONG  m_ParentParam;

    BEGIN_PARAM_MAP(CObjectsAccInsert)
	    COLUMN_ENTRY(1, m_NameParam)
	    COLUMN_ENTRY(2, m_ParentParam)
    END_PARAM_MAP()

    DEFINE_COMMAND(CObjectsAccInsert, L" \
                   INSERT INTO Objects \
                   (Name, Parent) \
                   VALUES (?, ?)");
    };


    //////////////////////////////////////////////////////////////////////////
    // class CObjectsCommandInsert
    //////////////////////////////////////////////////////////////////////////
    class CObjectsCommandInsert : 
            public CBaseCommand<CAccessor<CObjectsAccInsert> >
    {
    public:
        explicit CObjectsCommandInsert(CSession& CurrentSession);

        //////////////////////////////////////////////////////////////////////
        // InsertObject
        //
        // works on CObjectsAccInsert
        //////////////////////////////////////////////////////////////////////
        BOOL InsertObject(
                            const _bstr_t&  Name,
                                  LONG      Parent,
                                  LONG&     Identity
                         );
    private:
        CSession&   m_Session;
    };

    CObjectsCommandPath        m_ObjectsCommandPath;
    CObjectsCommandIdentity    m_ObjectsCommandIdentity;
    CObjectsCommandDelete      m_ObjectsCommandDelete;
    CObjectsCommandNameParent  m_ObjectsCommandNameParent;
    CObjectsCommandGet         m_ObjectsCommandGet;
    CObjectsCommandInsert      m_ObjectsCommandInsert;
};

#endif // _OBJECT_H_3A179338_CF1E_4932_8663_9F6AE0F03AA5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\providers.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Providers.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the CProviders class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _PROVIDERS_H_32E6104C_7547_4b28_A150_5E1E3D080F92
#define _PROVIDERS_H_32E6104C_7547_4b28_A150_5E1E3D080F92

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basecommand.h"

//////////////////////////////////////////////////////////////////////////////
// class CProvidersAcc
//////////////////////////////////////////////////////////////////////////////
class CProvidersAcc
{
protected:
    static const size_t COLUMN_SIZE = 65;
    static const size_t NAME_SIZE   = 256;

    VARIANT_BOOL    m_CanConfigure;
    VARIANT_BOOL    m_IsConfigured;
    WCHAR           m_Description[NAME_SIZE];
    WCHAR           m_DLLName[NAME_SIZE];
    WCHAR           m_Type[COLUMN_SIZE];
    WCHAR           m_UserDefinedName[COLUMN_SIZE];

BEGIN_COLUMN_MAP(CProvidersAcc)
    COLUMN_ENTRY(1, m_UserDefinedName)
    COLUMN_ENTRY(2, m_Description)
    COLUMN_ENTRY(3, m_Type)
    COLUMN_ENTRY(4, m_DLLName)
    COLUMN_ENTRY_TYPE(5, DBTYPE_BOOL, m_IsConfigured)
    COLUMN_ENTRY_TYPE(6, DBTYPE_BOOL, m_CanConfigure)
END_COLUMN_MAP()

    WCHAR           m_UserDefinedNameParam[COLUMN_SIZE];

BEGIN_PARAM_MAP(CProvidersAcc)
    COLUMN_ENTRY(1, m_UserDefinedNameParam)
END_PARAM_MAP()

DEFINE_COMMAND(CProvidersAcc, L" \
    SELECT \
        `User Defined Name`, \
        Description, \
        Type, \
        DLLName, \
        bIsConfigured, \
        bCanConfigure  \
        FROM Providers \
        WHERE `User Defined Name` = ?")
};


//////////////////////////////////////////////////////////////////////////////
// class CProviders 
//////////////////////////////////////////////////////////////////////////////
class CProviders : public CBaseCommand<CAccessor<CProvidersAcc> >,
                   private NonCopyable
{
public:
    explicit CProviders(CSession&   Session)
    {
        Init(Session);
    }

    //////////////////////////////////////////////////////////////////////////
    // GetProvider
    //////////////////////////////////////////////////////////////////////////
    void GetProvider(
                          const _bstr_t&  UserDefinedName,
                          _bstr_t&        Description,
                          _bstr_t&        Type,
                          _bstr_t&        DLLName,
                          VARIANT_BOOL&   IsConfigured,
                          VARIANT_BOOL&   CanConfigure
                    );

    LPCOLESTR   GetProviderDescription(const _bstr_t&  DPUserDefinedName);
};

#endif // _PROVIDERS_H_32E6104C_7547_4b28_A150_5E1E3D080F92
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\radiusattributes.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      RADIUSAttributes.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the CRADIUSAttributes class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _RADIUSATTRIBUTES_H_7F7029A3_4862_478f_A02D_D70A92C08065
#define _RADIUSATTRIBUTES_H_7F7029A3_4862_478f_A02D_D70A92C08065

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basetable.h"

//////////////////////////////////////////////////////////////////////////////
// class CRADIUSAttributesAcc
//////////////////////////////////////////////////////////////////////////////
class CRADIUSAttributesAcc
{
protected:
    static const size_t COLUMN_SIZE = 65;
    VARIANT_BOOL    m_Selectable;
    LONG            m_AttributeNumber;
    WCHAR           m_Attribute[COLUMN_SIZE];
    WCHAR           m_AttributeType[COLUMN_SIZE];

BEGIN_COLUMN_MAP(CRADIUSAttributesAcc)
    COLUMN_ENTRY(1, m_Attribute)
    COLUMN_ENTRY(2, m_AttributeNumber)
END_COLUMN_MAP()

    WCHAR    m_AttributesParam[COLUMN_SIZE];

BEGIN_PARAM_MAP(CRADIUSAttributesAcc)
	COLUMN_ENTRY(1, m_AttributesParam)
END_PARAM_MAP()


DEFINE_COMMAND(CRADIUSAttributesAcc, L" \
	SELECT \
      szAttribute, \
      `lAttribute Number` \
		FROM `RADIUS Attributes` \
        WHERE szAttribute = ?")
};


//////////////////////////////////////////////////////////////////////////////
// class CRADIUSAttributes 
//////////////////////////////////////////////////////////////////////////////
class CRADIUSAttributes : public CBaseCommand<CAccessor<CRADIUSAttributesAcc> >,
                          private NonCopyable
{
public:
    CRADIUSAttributes(CSession& Session);

    //////////////////////////////////////////////////////////////////////////
    // GetAttributeNumber
    //////////////////////////////////////////////////////////////////////////
    LONG GetAttributeNumber(const _bstr_t& AttributeName);
};

#endif // _RADIUSATTRIBUTES_H_7F7029A3_4862_478f_A02D_D70A92C08065
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\profiles.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Profiles.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the CProfiles class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _PROFILES_H_B2C5BF20_07C5_4f30_B81D_A0BB2BC2F9E2
#define _PROFILES_H_B2C5BF20_07C5_4f30_B81D_A0BB2BC2F9E2

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basetable.h"

//////////////////////////////////////////////////////////////////////////////
// class CProfilesAcc
//////////////////////////////////////////////////////////////////////////////
class CProfilesAcc
{
protected:
    static const int COLUMN_SIZE = 65;

    WCHAR m_Profile[COLUMN_SIZE];

BEGIN_COLUMN_MAP(CProfilesAcc)
    COLUMN_ENTRY(1, m_Profile)
END_COLUMN_MAP()
};

//////////////////////////////////////////////////////////////////////////////
// class CProfiles
//////////////////////////////////////////////////////////////////////////////
class CProfiles : public CBaseTable<CAccessor<CProfilesAcc> >,
                  private NonCopyable
{
public:
    CProfiles(CSession& Session)
    {
        memset(m_Profile, 0, sizeof(WCHAR) * COLUMN_SIZE);
        Init(Session, L"Profiles");
    }

    //////////////////////////////////////////////////////////////////////////
    // GetProfileName
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR   GetProfileName() const throw()
    {
        return m_Profile;
    }
};

#endif // _PROFILES_H_B2C5BF20_07C5_4f30_B81D_A0BB2BC2F9E2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\profileattributelist.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ProfileAttributeList.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the CProfileAttributeList class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _PROFILEATTRIBUTELIST_H_C86D2421_6523_4000_A523_5D3CC7585A18
#define _PROFILEATTRIBUTELIST_H_C86D2421_6523_4000_A523_5D3CC7585A18

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basecommand.h"
class CRADIUSAttributes;

//////////////////////////////////////////////////////////////////////////////
// class CProfileAttributeListSelectAcc
//////////////////////////////////////////////////////////////////////////////
class CProfileAttributeListSelectAcc
{
protected:
    static const size_t COLUMN_SIZE = 65;
    static const size_t STRING_SIZE = 256;

    LONG    m_Order;
    WCHAR   m_Attribute[COLUMN_SIZE];
    WCHAR   m_AttributeValueName[COLUMN_SIZE];
    WCHAR   m_Profile[COLUMN_SIZE];
    WCHAR   m_StringValue[STRING_SIZE];

BEGIN_COLUMN_MAP(CProfileAttributeListSelectAcc)
    COLUMN_ENTRY(1, m_Profile)
    COLUMN_ENTRY(2, m_Attribute)
    COLUMN_ENTRY(3, m_AttributeValueName)
    COLUMN_ENTRY(4, m_StringValue)
    COLUMN_ENTRY(5, m_Order)
END_COLUMN_MAP()

    WCHAR   m_ProfileParam[COLUMN_SIZE];

BEGIN_PARAM_MAP(CProfileAttributeListSelectAcc)
    COLUMN_ENTRY(1, m_ProfileParam)
END_PARAM_MAP()

DEFINE_COMMAND(CProfileAttributeListSelectAcc, L" \
        SELECT \
        szProfile, \
        szAttribute, \
        `szAttribute Value Name`, \
        `szString Value`, \
        dwOrder  \
        FROM `Profile Attribute List` \
        WHERE szProfile = ? \
        ORDER BY dwOrder")
};


//////////////////////////////////////////////////////////////////////////////
// class CProfileAttributeList
//////////////////////////////////////////////////////////////////////////////
class CProfileAttributeList 
                : public CBaseCommand<CAccessor<CProfileAttributeListSelectAcc> >,
                  private NonCopyable
{
public:
    explicit CProfileAttributeList(CSession& Session);

    //////////////////////////////////////////////////////////////////////////
    // GetAttribute 
    //////////////////////////////////////////////////////////////////////////
    HRESULT GetAttribute(
                            const _bstr_t&  ProfileName,
                                  _bstr_t&  Attribute,
                                  LONG&     AttributeNumber,
                                  _bstr_t&  AttributeValueName,
                                  _bstr_t&  StringValue,
                                  LONG&     Order
                        );

    //////////////////////////////////////////////////////////////////////////
    // GetAttribute overloaded
    //////////////////////////////////////////////////////////////////////////
    HRESULT GetAttribute(
                            const _bstr_t   ProfileName,
                                  _bstr_t&  Attribute,
                                  LONG&     AttributeNumber,
                                  _bstr_t&  AttributeValueName,
                                  _bstr_t&  StringValue,
                                  LONG&     Order,
                                  LONG      Index
                        );

private:
    CSession    m_Session;
};

#endif // _PROFILEATTRIBUTELIST_H_C86D2421_6523_4000_A523_5D3CC7585A18
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\properties.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Properties.H 
//
// Project:     Windows 2000 IAS
//
// Description: Declaration of the CProperties class
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _PROPERTIES_H_8FACED96_87C8_4f68_BFFB_92669BA5E835
#define _PROPERTIES_H_8FACED96_87C8_4f68_BFFB_92669BA5E835

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basecommand.h"

class CProperties : private NonCopyable
{
public:
    //////////////
    //Constructor
    //////////////
    explicit CProperties(CSession& SessionParam);

    //////////////
    // Destructor
    //////////////
    virtual ~CProperties() throw();

   
    ///////////////
    // GetProperty
    ///////////////
    HRESULT GetProperty(
                           LONG      Bag,
                           _bstr_t&  Name,
                           LONG&     Type,
                           _bstr_t&  StrVal
                       );

    ///////////////////
    // GetNextProperty
    ///////////////////
    HRESULT GetNextProperty(
                               LONG      Bag,
                               _bstr_t&  Name,
                               LONG&     Type,
                               _bstr_t&  StrVal,
                               LONG      Index
                           );

    /////////////////////
    // GetPropertyByName
    /////////////////////
    HRESULT GetPropertyByName(
                                     LONG      Bag,
                               const _bstr_t&  Name,
                                     LONG&     Type,
                                     _bstr_t&  StrVal
                             );

    //////////////////
    // InsertProperty
    //////////////////
    void InsertProperty(
                                 LONG       Bag,
                           const _bstr_t&   Name,
                                 LONG       Type,
                           const _bstr_t&   StrVal
                       );

    //////////////////
    // DeleteProperty
    //////////////////
    void DeleteProperty(
                                    LONG        Bag,
                              const _bstr_t&    Name
                       );

    ////////////////////
    // DeleteProperties
    ////////////////////
    void DeletePropertiesExcept(
                                         LONG       Bag,
                                   const _bstr_t&   Exception
                               );

    //////////////////
    // UpdateProperty
    //////////////////
    void UpdateProperty(
                                 LONG      Bag,
                           const _bstr_t&  Name,
                                 LONG      Type,
                           const _bstr_t&  StrVal
                       );


private:
/////////////////////////////////////////////////////////////////////////////
// START of the Properties Commands classes
/////////////////////////////////////////////////////////////////////////////
    struct CBasePropertiesConst
    {
        static const int NAME_SIZE          = 256;
        // 64 KB = the size of a memo field ? 
        // Here even 1024 would be enough
        static const int STRVAL_SIZE        = 65536;
        static const int SIZE_EXCEPTION_MAX = 256;
    };

    //////////////////////////////////////////////////////////////////////////
    // class CSelectPropertiesAcc
    //////////////////////////////////////////////////////////////////////////
    class CSelectPropertiesAcc : public CBasePropertiesConst
    {
    protected:
        LONG    m_Bag;
        WCHAR   m_Name[NAME_SIZE];
        WCHAR   m_StrVal[STRVAL_SIZE];
        LONG    m_Type;

    BEGIN_COLUMN_MAP(CSelectPropertiesAcc)
        COLUMN_ENTRY(1, m_Bag)
        COLUMN_ENTRY(2, m_Name)
        COLUMN_ENTRY(3, m_Type)
        COLUMN_ENTRY(4, m_StrVal)
    END_COLUMN_MAP()

    LONG    m_BagParam;

    BEGIN_PARAM_MAP(CSelectPropertiesAcc)
	    COLUMN_ENTRY(1, m_BagParam)
    END_PARAM_MAP()

    DEFINE_COMMAND(CSelectPropertiesAcc, L" \
                   SELECT \
                   Bag, \
                   Name, \
                   Type, \
                   StrVal  \
                   FROM Properties \
                   WHERE Bag = ?");
    };


    //////////////////////////////////////////////////////////////////////////
    // class CPropertiesCommandGet
    //////////////////////////////////////////////////////////////////////////
    class CPropertiesCommandGet: 
                         public CBaseCommand<CAccessor<CSelectPropertiesAcc> >
    {
    public:
        explicit CPropertiesCommandGet(CSession& CurrentSession);
    
        ///////////////
        // GetProperty
        ///////////////
        HRESULT GetProperty(
                                LONG        Bag,
                                _bstr_t&    Name,
                                LONG&       Type,
                                _bstr_t&    StrVal
                            );

        //////////////////////////
        // GetProperty overloaded
        //////////////////////////
        HRESULT GetProperty(
                                LONG        Bag,
                                _bstr_t&    Name,
                                LONG&       Type,
                                _bstr_t&    StrVal,
                                LONG        Index
                            );
    };

    //////////////////////////////////////////////////////////////////////////
    // class CSelectPropertiesAcc
    //////////////////////////////////////////////////////////////////////////
    class CSelectPropertiesByNameAcc : public CBasePropertiesConst
    {
    protected:
        LONG    m_Bag;
        WCHAR   m_Name[NAME_SIZE];
        WCHAR   m_StrVal[STRVAL_SIZE];
        LONG    m_Type;

    BEGIN_COLUMN_MAP(CSelectPropertiesByNameAcc)
        COLUMN_ENTRY(1, m_Bag)
        COLUMN_ENTRY(2, m_Name)
        COLUMN_ENTRY(3, m_Type)
        COLUMN_ENTRY(4, m_StrVal)
    END_COLUMN_MAP()

    LONG    m_BagParam;
    WCHAR   m_NameParam[NAME_SIZE];

    BEGIN_PARAM_MAP(CSelectPropertiesByNameAcc)
	    COLUMN_ENTRY(1, m_BagParam)
	    COLUMN_ENTRY(2, m_NameParam)
    END_PARAM_MAP()

    DEFINE_COMMAND(CSelectPropertiesByNameAcc, L" \
                   SELECT \
                   Bag, \
                   Name, \
                   Type, \
                   StrVal  \
                   FROM Properties \
                   WHERE ((Bag = ?) AND (Name = ?))");
    };


    //////////////////////////////////////////////////////////////////////////
    // class CPropertiesCommandGetByName
    //////////////////////////////////////////////////////////////////////////
    class CPropertiesCommandGetByName: 
                   public CBaseCommand<CAccessor<CSelectPropertiesByNameAcc> >
    {
    public:
        explicit CPropertiesCommandGetByName(CSession& CurrentSession);
    
        ///////////////
        // GetPropertyByName
        ///////////////
        HRESULT GetPropertyByName(
                                         LONG      Bag,
                                   const _bstr_t&  Name,
                                         LONG&     Type,
                                         _bstr_t&  StrVal
                                 );

    };


    //////////////////////////////////////////////////////////////////////////
    // class CInsertPropertyAcc
    //////////////////////////////////////////////////////////////////////////
    class CInsertPropertyAcc : public CBasePropertiesConst
    {
    protected:
        WCHAR   m_NameParam[NAME_SIZE];
        LONG    m_TypeParam;
        WCHAR   m_StrValParam[STRVAL_SIZE];
        LONG    m_BagParam;

    BEGIN_PARAM_MAP(CInsertPropertyAcc)
        COLUMN_ENTRY(1, m_BagParam)
        COLUMN_ENTRY(2, m_NameParam)
        COLUMN_ENTRY(3, m_TypeParam)
        COLUMN_ENTRY(4, m_StrValParam)
    END_PARAM_MAP()

    DEFINE_COMMAND(CInsertPropertyAcc, L" \
            INSERT INTO Properties \
            (Bag, Name, Type, StrVal)  \
            VALUES (?, ?, ?, ?)")

        // You may wish to call this function if you are inserting a record 
        // and wish to initialize all the fields, if you are not going to 
        // explicitly set all of them.
        void ClearRecord()
        {
            memset(this, 0, sizeof(*this));
        }
    };


    //////////////////////////////////
    // class CPropertiesCommandInsert
    //////////////////////////////////
    class CPropertiesCommandInsert: 
                         public CBaseCommand<CAccessor<CInsertPropertyAcc> >
    {
    public:
        explicit CPropertiesCommandInsert(CSession& CurrentSession);

        void InsertProperty(
                                     LONG       Bag,
                               const _bstr_t&   Name,
                                     LONG       Type,
                               const _bstr_t&   StrVal
                           );
    };

 
    //////////////////////////////////////////////////////////////////////////
    // class CDeletePropertyAcc
    //////////////////////////////////////////////////////////////////////////
    class CDeletePropertyAcc : public CBasePropertiesConst
    {
    protected:
        WCHAR   m_NameParam[NAME_SIZE];
        LONG    m_BagParam;

    BEGIN_PARAM_MAP(CDeletePropertyAcc)
        COLUMN_ENTRY(1, m_BagParam)
        COLUMN_ENTRY(2, m_NameParam)
    END_PARAM_MAP()

    DEFINE_COMMAND(CDeletePropertyAcc, L" \
            DELETE * \
            FROM Properties \
            WHERE ((Bag = ?) AND (Name = ?))")
    };

    
    //////////////////////////////////
    // class CPropertiesCommandDelete
    //////////////////////////////////
    class CPropertiesCommandDelete: 
                         public CBaseCommand<CAccessor<CDeletePropertyAcc> >
    {
    public:
        explicit CPropertiesCommandDelete(CSession& CurrentSession);

        void DeleteProperty(
                                     LONG       Bag,
                               const _bstr_t&   Name
                           );
    };

    //////////////////////////////////////////////////////////////////////////
    // class CDeletePropertiesAcc
    //////////////////////////////////////////////////////////////////////////
    class CDeletePropertiesAcc : public CBasePropertiesConst
    {
    protected:
        LONG    m_BagParam;
        WCHAR   m_ExceptionParam[SIZE_EXCEPTION_MAX];

    BEGIN_PARAM_MAP(CDeletePropertiesAcc)
        COLUMN_ENTRY(1, m_BagParam)
        COLUMN_ENTRY(2, m_ExceptionParam)
     END_PARAM_MAP()

    DEFINE_COMMAND(CDeletePropertiesAcc, L" \
            DELETE * \
            FROM Properties \
            WHERE ( (Bag = ?) AND (Name <> ?))")
    };

    
    //////////////////////////////////
    // class CPropertiesCommandDelete
    //////////////////////////////////
    class CPropertiesCommandDeleteMultiple: 
                     public CBaseCommand<CAccessor<CDeletePropertiesAcc> >
    {
    public:
        explicit CPropertiesCommandDeleteMultiple(CSession& CurrentSession);

        void DeletePropertiesExcept(LONG  Bag, const _bstr_t& Exception);
    };


    CPropertiesCommandGet            m_PropertiesCommandGet;
    CPropertiesCommandGetByName      m_PropertiesCommandGetByName;
    CPropertiesCommandInsert         m_PropertiesCommandInsert;
    CPropertiesCommandDelete         m_PropertiesCommandDelete;
    CPropertiesCommandDeleteMultiple m_PropertiesCommandDeleteMultiple;
};

#endif // _PROPERTIES_H_8FACED96_87C8_4f68_BFFB_92669BA5E835
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\realms.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Realms.H 
//
// Project:     Windows 2000 IAS
//
// Description: Declaration of the CRealms class
//
// Author:      tperraut
//
// Revision     03/09/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _REALMS_H_54D54DB1_874E_48ab_84A5_9E6EE190C738
#define _REALMS_H_54D54DB1_874E_48ab_84A5_9E6EE190C738

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "policy.h"

//////////////////////////////////////////////////////////////////////////////
// class CRealmsAccProfile
//////////////////////////////////////////////////////////////////////////////
class CRealmsAccProfile
{
protected:
    static const size_t REALM_COLUMN_SIZE = 65;
    static const size_t REALM_NAME_SIZE   = 256;

    WCHAR           m_RealmName[REALM_NAME_SIZE];
    WCHAR           m_UserDefinedName[REALM_COLUMN_SIZE];
    VARIANT_BOOL    m_Prefix;
    VARIANT_BOOL    m_StripSuffixPrefix;
    WCHAR           m_SuffixPrefix[REALM_COLUMN_SIZE];
    VARIANT_BOOL    m_ForwardAccounting;
    VARIANT_BOOL    m_AccountingasLogout;
    VARIANT_BOOL    m_SuppressAccounting;
    WCHAR           m_Profile[REALM_COLUMN_SIZE];
    LONG            m_Order;

BEGIN_COLUMN_MAP(CRealmsAccProfile)
    COLUMN_ENTRY(1,                   m_RealmName)
    COLUMN_ENTRY(2,                   m_UserDefinedName)
    COLUMN_ENTRY_TYPE(3, DBTYPE_BOOL, m_Prefix)
    COLUMN_ENTRY_TYPE(4, DBTYPE_BOOL, m_StripSuffixPrefix)
    COLUMN_ENTRY(5,                   m_SuffixPrefix)
    COLUMN_ENTRY_TYPE(6, DBTYPE_BOOL, m_ForwardAccounting)
    COLUMN_ENTRY_TYPE(7, DBTYPE_BOOL, m_AccountingasLogout)
    COLUMN_ENTRY_TYPE(8, DBTYPE_BOOL, m_SuppressAccounting)
    COLUMN_ENTRY(9,                   m_Profile)
    COLUMN_ENTRY(10,                  m_Order)
END_COLUMN_MAP()

    WCHAR       m_ProfileParam[REALM_COLUMN_SIZE];

BEGIN_PARAM_MAP(CRealmsAccProfile)
    COLUMN_ENTRY(1, m_ProfileParam)
END_PARAM_MAP()

DEFINE_COMMAND(CRealmsAccProfile, L" \
        SELECT * \
        FROM Realms \
        WHERE szProfile = ?")
};


//////////////////////////////////////////////////////////////////////////////
// CRealms 
//////////////////////////////////////////////////////////////////////////////
class CRealms : public CBaseCommand<CAccessor<CRealmsAccProfile> >,
                private NonCopyable
{
public:
    explicit    CRealms(CSession&   Session);
    void        GetRealm(const _bstr_t& Profile);
    HRESULT     GetRealmIndex(const _bstr_t& Profile, LONG Index);
    void        SetRealmDetails(CPolicy& TempPolicy, CUtils& m_Utils);
    
    VARIANT_BOOL AccountingasLogout() const throw()
    {
        return m_AccountingasLogout;
    }

    //////////////////////////////////////////////////////////////////////////
    // ForwardAccounting
    //////////////////////////////////////////////////////////////////////////
    VARIANT_BOOL ForwardAccounting() const throw()
    {
        return m_ForwardAccounting;
    }

    //////////////////////////////////////////////////////////////////////////
    // Prefix
    //////////////////////////////////////////////////////////////////////////
    VARIANT_BOOL Prefix() const throw()
    {
        return m_Prefix;
    }

    //////////////////////////////////////////////////////////////////////////
    // StripSuffixPrefix
    //////////////////////////////////////////////////////////////////////////
    VARIANT_BOOL StripSuffixPrefix() const throw()
    {
        return m_StripSuffixPrefix;
    }

    //////////////////////////////////////////////////////////////////////////
    // SuppressAccounting
    //////////////////////////////////////////////////////////////////////////
    VARIANT_BOOL SuppressAccounting() const throw()
    {
        return m_SuppressAccounting;
    }

    //////////////////////////////////////////////////////////////////////////
    // Order
    //////////////////////////////////////////////////////////////////////////
    LONG  Order() const throw()
    {
        return m_Order;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetProfile
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR GetProfile() const throw()
    {
         return m_Profile;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetRealmName
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR GetRealmName() const throw()
    {
         return m_RealmName;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetSuffixPrefix
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR GetSuffixPrefix() const throw()
    {
         return m_SuffixPrefix;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetUserDefinedName
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR GetUserDefinedName() const throw()
    {
         return m_UserDefinedName;
    }
};
#endif // _REALMS_H_54D54DB1_874E_48ab_84A5_9E6EE190C738
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\radiusattributevalues.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      RADIUSAttributeValues.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the RADIUSAttributeValues class
//
// Author:      tperraut
//
// Revision     03/15/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _RADIUSATTRIBUTEVALUES_H_2D58B146_3341_453e_A1F2_A4E6443EA64A
#define _RADIUSATTRIBUTEVALUES_H_2D58B146_3341_453e_A1F2_A4E6443EA64A

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basetable.h"

//////////////////////////////////////////////////////////////////////////////
// class CRADIUSAttributeValuesAcc
//////////////////////////////////////////////////////////////////////////////
class CRADIUSAttributeValuesAcc 
{
protected:
    static const size_t COLUMN_SIZE = 65;

    LONG  m_AttributeValueNumber;
    WCHAR m_Attribute[COLUMN_SIZE];
    WCHAR m_AttributeValueName[COLUMN_SIZE];

BEGIN_COLUMN_MAP(CRADIUSAttributeValuesAcc)
    COLUMN_ENTRY(1, m_Attribute)
    COLUMN_ENTRY(2, m_AttributeValueName)
    COLUMN_ENTRY(3, m_AttributeValueNumber)
END_COLUMN_MAP()

    WCHAR       m_AttributeParam[COLUMN_SIZE];
    WCHAR       m_AttributeValueNameParam[COLUMN_SIZE];

BEGIN_PARAM_MAP(CRADIUSAttributeValuesAcc )
    COLUMN_ENTRY(1, m_AttributeParam)
    COLUMN_ENTRY(2, m_AttributeValueNameParam)
END_PARAM_MAP()

DEFINE_COMMAND(CRADIUSAttributeValuesAcc , L" \
    SELECT \
        szAttribute, \
        `szAttribute Value Name`, \
        `lAttribute Value Number` \
        FROM `RADIUS Attribute Values` \
        WHERE ( (`szAttribute` = ?) AND \
        (`szAttribute Value Name` = ?) )")
};


//////////////////////////////////////////////////////////////////////////////
// class CRADIUSAttributeValues 
//////////////////////////////////////////////////////////////////////////////
class CRADIUSAttributeValues 
                  : public CBaseCommand<CAccessor<CRADIUSAttributeValuesAcc> >,
                    private NonCopyable
{
public:
    explicit CRADIUSAttributeValues(CSession&   Session)
    {
        Init(Session);
    }

    //////////////////////////////////////////////////////////////////////////
    // GetAttributeNumber
    //////////////////////////////////////////////////////////////////////////
    LONG    GetAttributeNumber(
                                  const _bstr_t& AttributeName,
                                  const _bstr_t& AttributeValueName
                              );
};

#endif // _RADIUSATTRIBUTEVALUES_H_2D58B146_3341_453e_A1F2_A4E6443EA64A
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\version.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      Version.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the CVersion class
//      works only with m_StdSession (database being upgraded)
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef VERSION_H_80F1E134_D2A0_4f40_86CB_3D2AC31B1967
#define VERSION_H_80F1E134_D2A0_4f40_86CB_3D2AC31B1967

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basecommand.h"

//////////////////////////////////////////////////////////////////////////////
// class CVersionGetAcc
//////////////////////////////////////////////////////////////////////////////
class CVersionGetAcc
{
protected:
    LONG    m_Version;

BEGIN_COLUMN_MAP(CVersionGetAcc)
	COLUMN_ENTRY(1, m_Version);
END_COLUMN_MAP()

DEFINE_COMMAND(CVersionGetAcc, L" \
               SELECT Version.Version \
               FROM Version;");
};


//////////////////////////////////////////////////////////////////////////////
// class CVersionGet
//////////////////////////////////////////////////////////////////////////////
class CVersionGet: public CBaseCommand<CAccessor<CVersionGetAcc> >,
                      private NonCopyable
{
public:
    explicit CVersionGet(CSession& Session)
            :m_Session(Session)
    {
        Init(Session);
    }

    LONG GetVersion();
private:
    CSession    m_Session;
};


//////////////////////////////////////////////////////////////////////////////
// class CVersionAcc
//////////////////////////////////////////////////////////////////////////////
class CVersionAcc
{
protected:
    LONG    m_NewVersionParam;
    LONG    m_OldVersionParam;

BEGIN_PARAM_MAP(CVersionAcc)
	COLUMN_ENTRY(1, m_NewVersionParam)
	COLUMN_ENTRY(2, m_OldVersionParam)
END_PARAM_MAP()

DEFINE_COMMAND(CVersionAcc, L" \
               UPDATE Version \
               SET Version.Version = ? \
               WHERE Version.Version = ?;");
};


//////////////////////////////////////////////////////////////////////////////
// class CVersion
//////////////////////////////////////////////////////////////////////////////
class CVersion : public CBaseCommand<CAccessor<CVersionAcc> >,
                 private NonCopyable
{
public:
    explicit CVersion(CSession& Session) 
        :m_Session(Session)
    {
        Init(Session);
    }

    LONG    GetVersion();

private:
    CSession    m_Session;
};

#endif // VERSION_H_80F1E134_D2A0_4f40_86CB_3D2AC31B1967
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\remoteradiusservers.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      RemoteRadiusServers.H 
//
// Project:     Windows 2000 IAS
//
// Description: 
//      Declaration of the CRemoteRadiusServersclass
//
// Author:      tperraut
//
// Revision     02/24/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _REMOTERADIUSSERVERS_H_313B77A9_9C6E_4b6b_954F_6DBAC96A0AF6
#define _REMOTERADIUSSERVERS_H_313B77A9_9C6E_4b6b_954F_6DBAC96A0AF6

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basetable.h"

//////////////////////////////////////////////////////////////////////////////
// class CRemoteRadiusServersAcc
//////////////////////////////////////////////////////////////////////////////
class CRemoteRadiusServersAcc 
{
protected:
    static const size_t COLUMN_SIZE = 65;

    LONG    m_Order;
    LONG    m_AccountingPortNumber;
    LONG    m_AddressType;
    LONG    m_AuthenticationPortNumber;
    WCHAR   m_PrevSharedSecret[COLUMN_SIZE];
    WCHAR   m_ProxyServer[COLUMN_SIZE];
    WCHAR   m_SharedSecret[COLUMN_SIZE];
    WCHAR   m_UserDefinedName[COLUMN_SIZE];

BEGIN_COLUMN_MAP(CRemoteRadiusServersAcc)
    COLUMN_ENTRY(1, m_UserDefinedName)
    COLUMN_ENTRY(2, m_ProxyServer)
    COLUMN_ENTRY(3, m_AddressType)
    COLUMN_ENTRY(4, m_AccountingPortNumber)
    COLUMN_ENTRY(5, m_AuthenticationPortNumber)
    COLUMN_ENTRY(6, m_SharedSecret)
    COLUMN_ENTRY(7, m_PrevSharedSecret)
    COLUMN_ENTRY(8, m_Order)
END_COLUMN_MAP()
};


//////////////////////////////////////////////////////////////////////////////
// class CRemoteRadiusServers
//////////////////////////////////////////////////////////////////////////////
class CRemoteRadiusServers: 
                    public CBaseTable<CAccessor<CRemoteRadiusServersAcc> >,
                    private NonCopyable
{
public:
    CRemoteRadiusServers(CSession& Session)
    {
        // If there is no rows in the rowset.
        m_Order = -1;
        Init(Session, L"Remote Radius Servers");
    };

    //////////////////////////////////////////////////////////////////////////
    // IsEmpty
    //////////////////////////////////////////////////////////////////////////
    BOOL IsEmpty() const throw()
    {
        if ( m_Order == -1 )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    
    //////////////////////////////////////////////////////////////////////////
    // GetOrder
    //////////////////////////////////////////////////////////////////////////
    LONG GetOrder() const throw()
    {
        return m_Order;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetAccountingPortNumber
    //////////////////////////////////////////////////////////////////////////
    LONG GetAccountingPortNumber() const throw()
    {
        return m_AccountingPortNumber;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetAuthenticationPortNumber
    //////////////////////////////////////////////////////////////////////////
    LONG GetAuthenticationPortNumber() const throw()
    {
        return m_AuthenticationPortNumber;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetAddressType
    //////////////////////////////////////////////////////////////////////////
    LONG GetAddressType() const throw()
    {
        return m_AddressType;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetProxyServerName
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR GetProxyServerName() const throw()
    {
        return m_ProxyServer;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetSharedSecret
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR GetSharedSecret() const throw()
    {
        return m_SharedSecret;
    }

    //////////////////////////////////////////////////////////////////////////
    // GetGroupName
    //////////////////////////////////////////////////////////////////////////
    LPCOLESTR GetGroupName() const throw()
    {
        return m_UserDefinedName;
    }
};

#endif // _REMOTERADIUSSERVERS_H_313B77A9_9C6E_4b6b_954F_6DBAC96A0AF6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\ias.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ias.h
//
// SYNOPSIS
//
//    Common header file for all IAS modules.
//
// MODIFICATION HISTORY
//
//    07/09/1997    Original version.
//    11/20/1997    Added the ATL headers.
//    06/16/1998    iasapi.h must be included before the VC COM support.
//    08/18/1998    Added iastrace.h
//    04/23/1999    Remove iasevent.h
//    05/21/1999    Remove iasdebug.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IAS_H_
#define _IAS_H_
#if _MSC_VER >= 1000
#pragma once
#endif

//////////
// Everything should be hard-coded for UNICODE, but just in case ...
//////////
#ifndef UNICODE
   #define UNICODE
#endif

#ifndef _UNICODE
   #define _UNICODE
#endif

#include <iaspragma.h>
#include <windows.h>
#include <iasdefs.h>
#include <iasapi.h>
#include <iastrace.h>
#include <iasuuid.h>

//////////
// Don't pull in C++/ATL support if IAS_LEAN_AND_MEAN is defined.
//////////
#ifndef IAS_LEAN_AND_MEAN

#include <iasapix.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#endif  // !IAS_LEAN_AND_MEAN
#endif  // _IAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iasapi.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasapi.h
//
// SYNOPSIS
//
//    This file describes all "C"-style API functions in the Everest core.
//
// MODIFICATION HISTORY
//
//    08/29/1997    Original version.
//    11/12/1997    Added IASUpdateRegistry.
//    11/26/1997    Revised timer API.
//    01/08/1998    Made changes so that header could stand alone.
//    01/30/1998    Added IASAdler32.
//    04/17/1998    Added IASLookupAttributeIDs.
//    06/16/1998    Added IASVariantChangeType.
//    08/13/1998    Removed obsolete API's.
//    04/19/1999    Added IASRadiusCrypt.
//    01/25/2000    Added IASGetHostByName.
//    04/14/2000    Added dictionary API.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASAPI_H_
#define _IASAPI_H_

#ifndef IASCOREAPI
#define IASCOREAPI DECLSPEC_IMPORT
#endif

#include <wtypes.h>
#include <oaidl.h>

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Functions to initialize and shutdown the core services.
//
///////////////////////////////////////////////////////////////////////////////
IASCOREAPI
BOOL
WINAPI
IASInitialize ( VOID );

IASCOREAPI
VOID
WINAPI
IASUninitialize ( VOID );


///////////////////////////////////////////////////////////////////////////////
//
// Function for computing the Adler-32 checksum of a buffer.
//
///////////////////////////////////////////////////////////////////////////////

IASCOREAPI
DWORD
WINAPI
IASAdler32(
    CONST BYTE *pBuffer,
    DWORD nBufferLength
    );

// The Adler-32 checksum is also a decent hash algorithm.
#define IASHashBytes IASAdler32


///////////////////////////////////////////////////////////////////////////////
//
// Allocate a 32-bit integer that's guaranteed to be unique process wide.
//
///////////////////////////////////////////////////////////////////////////////

IASCOREAPI
DWORD
WINAPI
IASAllocateUniqueID( VOID );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for updating the registry.
//
///////////////////////////////////////////////////////////////////////////////

#define IAS_REGISTRY_INPROC       0x00000000
#define IAS_REGISTRY_LOCAL        0x00000001
#define IAS_REGISTRY_FREE         0x00000000
#define IAS_REGISTRY_APT          0x00000002
#define IAS_REGISTRY_BOTH         0x00000004
#define IAS_REGISTRY_AUTO         0x00000008

IASCOREAPI
HRESULT
WINAPI
IASRegisterComponent(
    HINSTANCE hInstance,
    REFCLSID clsid,
    LPCWSTR szProgramName,
    LPCWSTR szComponentName,
    DWORD dwRegFlags,
    REFGUID tlid,
    WORD wVerMajor,
    WORD wVerMinor,
    BOOL bRegister
    );


///////////////////////////////////////////////////////////////////////////////
//
// IASReportEvent is used to report events within the Everest server.
//
///////////////////////////////////////////////////////////////////////////////

IASCOREAPI
HRESULT
WINAPI
IASReportEvent(
    DWORD dwEventID,
    DWORD dwNumStrings,
    DWORD dwDataSize,
    LPCWSTR *lpStrings,
    LPVOID lpRawData
    );


///////////////////////////////////////////////////////////////////////////////
//
// Generic callback struct.
//
///////////////////////////////////////////////////////////////////////////////
typedef struct IAS_CALLBACK IAS_CALLBACK, *PIAS_CALLBACK;

typedef VOID (WINAPI *IAS_CALLBACK_ROUTINE)(
    PIAS_CALLBACK This
    );

struct IAS_CALLBACK {
    IAS_CALLBACK_ROUTINE CallbackRoutine;
};


///////////////////////////////////////////////////////////////////////////////
//
// This is the native "C"-style interface into the threading engine.
//
///////////////////////////////////////////////////////////////////////////////

IASCOREAPI
BOOL
WINAPI
IASRequestThread(
    PIAS_CALLBACK pOnStart
    );

IASCOREAPI
DWORD
WINAPI
IASSetMaxNumberOfThreads(
    DWORD dwMaxNumberOfThreads
    );

IASCOREAPI
DWORD
WINAPI
IASSetMaxThreadIdle(
    DWORD dwMilliseconds
    );

///////////////////////////////////////////////////////////////////////////////
//
// Replacement for VariantChangeType to prevent hidden window.
//
///////////////////////////////////////////////////////////////////////////////

IASCOREAPI
HRESULT
WINAPI
IASVariantChangeType(
    VARIANT * pvargDest,
    VARIANT * pvarSrc,
    USHORT wFlags,
    VARTYPE vt
    );

// Map any oleaut32 calls to our implementation.
#define VariantChangeType IASVariantChangeType

///////////////////////////////////////////////////////////////////////////////
//
// RADIUS Encryption/Decryption.
//
///////////////////////////////////////////////////////////////////////////////

IASCOREAPI
VOID
WINAPI
IASRadiusCrypt(
    BOOL encrypt,
    BOOL salted,
    const BYTE* secret,
    ULONG secretLen,
    const BYTE* reqAuth,
    PBYTE buf,
    ULONG buflen
    );

///////////////////////////////////////////////////////////////////////////////
//
// Unicode version of gethostbyname.
// The caller must free the returned hostent struct by calling LocalFree.
//
// Note: Since this is a Unicode API, the returned hostent struct will always
//       have h_name and h_aliases set to NULL.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct hostent *PHOSTENT;

IASCOREAPI
PHOSTENT
WINAPI
IASGetHostByName(
    IN PCWSTR name
    );

///////////////////////////////////////////////////////////////////////////////
//
// Methods for accessing the attribute dictionary.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct _IASTable {
    ULONG numColumns;
    ULONG numRows;
    BSTR* columnNames;
    VARTYPE* columnTypes;
    VARIANT* table;
} IASTable;

HRESULT
WINAPI
IASGetDictionary(
    IN PCWSTR path,
    OUT IASTable* dnary,
    OUT VARIANT* storage
    );

const IASTable*
WINAPI
IASGetLocalDictionary( VOID );

#ifdef __cplusplus
}
#endif
#endif  // _IASAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\iasjet\setup\dbhelper\serviceconfiguration.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 2000 Microsoft Corporation all rights reserved.
//
// Module:      ServiceConfiguration.H 
//
// Project:     Windows 2000 IAS
//
// Description: Declaration of the CServiceConfiguration class
//
// Author:      tperraut
//
// Revision     03/21/2000 created
//
/////////////////////////////////////////////////////////////////////////////
#ifndef SERVICE_CONFIGURATION_H_3124D940_2304_4d32_B742_C9829FFB754D
#define SERVICE_CONFIGURATION_H_3124D940_2304_4d32_B742_C9829FFB754D

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "nocopy.h"
#include "basetable.h"

//////////////////////////////////////////////////////////////////////////////
// class CServiceConfigurationAcc
//////////////////////////////////////////////////////////////////////////////
class CServiceConfigurationAcc
{
protected:
    static const size_t   FIFTY_ONE_LENGTH  = 51;
    static const size_t   SIXTY_FIVE_LENGTH = 65;
    static const size_t   NAME_LENGTH       = 256;
    static const size_t   VERSION_LENGTH    = 16;

    VARIANT_BOOL    m_AutomaticallyOpenNewLog;
    VARIANT_BOOL    m_DefaultUserValidation;
    VARIANT_BOOL    m_LoggingOn;
    VARIANT_BOOL    m_NewLogBySize;
    VARIANT_BOOL    m_NewLogDaily;
    VARIANT_BOOL    m_NewLogMonthly;
    VARIANT_BOOL    m_NewLogWeekly;
    VARIANT_BOOL    m_NoDefaultUserValidation;
    VARIANT_BOOL    m_TraceAccounting;
    VARIANT_BOOL    m_TraceAuthentication;
    VARIANT_BOOL    m_TraceInvalid;
    LONG            m_AccountingPort;
    LONG            m_AuthenticationPort;
    LONG            m_MaxLogSize;
    LONG            m_ServerThreads;
    WCHAR           m_LogFileDirectory[FIFTY_ONE_LENGTH];
    WCHAR           m_LogFilename[NAME_LENGTH];
    WCHAR           m_LogFormat[SIXTY_FIVE_LENGTH];
    // Realm: No referential integrity enforced. Used when users are validated
    // locally.
    WCHAR           m_Realm[FIFTY_ONE_LENGTH];  
    WCHAR           m_SystemName[SIXTY_FIVE_LENGTH]; 
    WCHAR           m_Version[VERSION_LENGTH];    

BEGIN_COLUMN_MAP(CServiceConfigurationAcc)
    COLUMN_ENTRY(1,                     m_SystemName)
    COLUMN_ENTRY(2,                     m_AuthenticationPort)
    COLUMN_ENTRY(3,                     m_AccountingPort)
    COLUMN_ENTRY(4,                     m_ServerThreads)
    COLUMN_ENTRY_TYPE(5, DBTYPE_BOOL,   m_TraceInvalid)
    COLUMN_ENTRY_TYPE(6, DBTYPE_BOOL,   m_TraceAuthentication)
    COLUMN_ENTRY_TYPE(7, DBTYPE_BOOL,   m_TraceAccounting)
    COLUMN_ENTRY_TYPE(8, DBTYPE_BOOL,   m_NoDefaultUserValidation)
    COLUMN_ENTRY_TYPE(9, DBTYPE_BOOL,   m_DefaultUserValidation)
    COLUMN_ENTRY(10,                    m_Realm)
    COLUMN_ENTRY_TYPE(11, DBTYPE_BOOL,  m_LoggingOn)
    COLUMN_ENTRY(12,                    m_LogFormat)
    COLUMN_ENTRY_TYPE(13, DBTYPE_BOOL,  m_AutomaticallyOpenNewLog)
    COLUMN_ENTRY_TYPE(14, DBTYPE_BOOL,  m_NewLogDaily)
    COLUMN_ENTRY_TYPE(15, DBTYPE_BOOL,  m_NewLogWeekly)
    COLUMN_ENTRY_TYPE(16, DBTYPE_BOOL,  m_NewLogMonthly)
    COLUMN_ENTRY_TYPE(17, DBTYPE_BOOL,  m_NewLogBySize)
    COLUMN_ENTRY(18,                    m_MaxLogSize)
    COLUMN_ENTRY(19,                    m_LogFilename)
    COLUMN_ENTRY(20,                    m_LogFileDirectory)
    COLUMN_ENTRY(21,                    m_Version)
END_COLUMN_MAP()
};


//////////////////////////////////////////////////////////////////////////////
// class CServiceConfiguration
//////////////////////////////////////////////////////////////////////////////
class CServiceConfiguration :
                     public CBaseTable<CAccessor<CServiceConfigurationAcc> >,
                     private NonCopyable
{
public:
    CServiceConfiguration(CSession& Session);

    //////////////////////////////////////////////////////////////////////////
    // GetMaxLogSize
    //////////////////////////////////////////////////////////////////////////
    _bstr_t     GetMaxLogSize() const;

    
    //////////////////////////////////////////////////////////////////////////
    // GetLogFrequency
    //////////////////////////////////////////////////////////////////////////
    _bstr_t     GetLogFrequency() const;
    
private:
    static const size_t SIZE_LONG_MAX = 14;
};
#endif // SERVICE_CONFIGURATION_H_3124D940_2304_4d32_B742_C9829FFB754D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\dbgtrace.h ===
/*----------------------------------------------------------------------
    dbgtrace.h
        Definitions for async tracing routines

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#if !defined(_DBGTRACE_H_)
#define _DBGTRACE_H_


#ifdef __cplusplus
extern "C" {
#endif


//
// setup DLL Export macros
//
#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif
#if !defined(DllImport)
    #define DllImport __declspec( dllimport )
#endif
#if !defined(_DBGTRACE_DLL_DEFINED)
    #define _DBGTRACE_DLL_DEFINED
    #if defined(WIN32)
        #if defined(_DBGTRACE_DLL_IMPLEMENTATION)
            #define DbgTraceDLL DllExport
        #else
            #define DbgTraceDLL DllImport
        #endif
    #else
        #define DbgTraceDLL
    #endif
#endif

#ifndef THIS_FILE
#define THIS_FILE   __FILE__
#endif

#if defined( NOTRACE )

#define FLUSHASYNCTRACE                         // for _ASSERT below

#define FatalTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTrace  1 ? (void)0 : PreAsyncTrace
#define DebugTrace  1 ? (void)0 : PreAsyncTrace
#define StateTrace  1 ? (void)0 : PreAsyncTrace
#define FunctTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTraceX 1 ? (void)0 : PreAsyncTrace
#define DebugTraceX 1 ? (void)0 : PreAsyncTrace

#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )

#define TraceFunctEnter( sz )
#define TraceFunctEnterEx( lparam, sz )
#define TraceFunctLeave()

//
// import functions from DBGTRACE.DLL
//
#define	InitAsyncTrace()
#define	TermAsyncTrace()
#define	FlushAsyncTrace()

__inline int PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
        return( 1);
}


#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )



#else // NOTRACE

#define FLUSHASYNCTRACE     FlushAsyncTrace(),  // for _ASSERT below

#define FatalTrace  !(__dwEnabledTraces & FATAL_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, FATAL_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define ErrorTrace  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTrace  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define StateTrace  !(__dwEnabledTraces & STATE_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, STATE_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define FunctTrace  !(__dwEnabledTraces & FUNCT_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, FUNCT_TRACE_MASK ) &&     \
                    PreAsyncTrace

//
// Support for unspecified function names
//

#define ErrorTraceX  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, "Fn", ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTraceX  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, "Fn", DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace


//
// use to explicitly remove function tracing even for debug builds
//
#define TraceQuietEnter( sz )                   \
        char    *___pszFunctionName = sz

//
// disable function tracing for retail builds
// reduces code size increase and only should
// only be used sparingly
//
#ifdef  DEBUG

#define TraceFunctEnter( sz )                   \
        TraceQuietEnter( sz );                  \
        FunctTrace( 0, "Entering %s", sz )

#define TraceFunctLeave()                       \
        FunctTrace( 0, "Leaving %s", ___pszFunctionName )

#define TraceFunctEnterEx( lParam, sz )         \
        TraceQuietEnter( sz );                  \
        FunctTrace( lParam, "Entering %s", sz )

#define TraceFunctLeaveEx( lParam )             \
        FunctTrace( lParam, "Leaving %s", ___pszFunctionName )

#else

#define TraceFunctEnter( sz )           TraceQuietEnter( sz )
#define TraceFunctEnterEx( lParam, sz ) TraceQuietEnter( sz )

#define TraceFunctLeave()
#define TraceFunctLeaveEx( lParam )

#endif

//
// import functions from DBGTRACE.DLL
//
extern DbgTraceDLL BOOL WINAPI InitAsyncTrace( void );
extern DbgTraceDLL BOOL WINAPI TermAsyncTrace( void );
extern DbgTraceDLL BOOL WINAPI FlushAsyncTrace( void );




//
// fixed number of parameters for Binary trace macros
//
#define MessageTrace( lParam, pbData, cbData )                  \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_MESSAGE, pbData, cbData )

#define BinaryTrace( lParam, pbData, cbData )                   \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_BINARY, pbData, cbData )

#define UserTrace( lParam, dwUserType, pbData, cbData )         \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, dwUserType, pbData, cbData )

//
// imported trace flag used by trace macros to determine if the trace
// statement should be executed
//
extern DWORD DbgTraceDLL    __dwEnabledTraces;



extern DbgTraceDLL int WINAPI AsyncStringTrace( LPARAM  lParam,
                                                LPCSTR  szFormat,
                                                va_list marker );

extern DbgTraceDLL int WINAPI AsyncBinaryTrace( LPARAM  lParam,
                                                DWORD   dwBinaryType,
                                                LPBYTE  pbData,
                                                DWORD   cbData );

extern DbgTraceDLL int WINAPI SetAsyncTraceParams(  LPSTR   pszFile,
                                                    int     iLine,
                                                    LPSTR   szFunction,
                                                    DWORD   dwTraceMask );

//
// Trace flag constants
//
#define FATAL_TRACE_MASK    0x00000001
#define ERROR_TRACE_MASK    0x00000002
#define DEBUG_TRACE_MASK    0x00000004
#define STATE_TRACE_MASK    0x00000008
#define FUNCT_TRACE_MASK    0x00000010
#define MESSAGE_TRACE_MASK  0x00000020
#define ALL_TRACE_MASK      0xFFFFFFFF

#define NUM_TRACE_TYPES     6

//
// Output trace types. used by tools to modify the
// registry to change the output target
//
enum tagTraceOutputTypes {
    TRACE_OUTPUT_DISABLED = 0,
    TRACE_OUTPUT_FILE = 1,
    TRACE_OUTPUT_DEBUG = 2,
    TRACE_OUTPUT_DISCARD = 4        // used to find race windows
};

#define TRACE_OUTPUT_INVALID    \
        ~(TRACE_OUTPUT_FILE|TRACE_OUTPUT_DEBUG|TRACE_OUTPUT_DISCARD)


#define IsTraceFile(x)      ((x) & TRACE_OUTPUT_FILE)
#define IsTraceDebug(x)     ((x) & TRACE_OUTPUT_DEBUG)
#define IsTraceDiscard(x)   ((x) & TRACE_OUTPUT_DISCARD)


//
// predefined types of binary trace types.  User defined
// types must be greater than 0x8000
//
enum tagBinaryTypes {
    TRACE_STRING = 0,
    TRACE_BINARY,
    TRACE_MESSAGE,
    TRACE_USER = 0x8000
};

#include <stdarg.h>

//
// use __inline to ensure grab __LINE__ and __FILE__
//
__inline int WINAPIV PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
    va_list marker;
    int     iLength;

    va_start( marker, szFormat );
    iLength = AsyncStringTrace( lParam, szFormat, marker );
    va_end( marker );

    return  iLength;
}

// !defined(NOTRACE) from way at the top of this include file
#endif // !defined(NOTRACE)

// Asserts are independent of tracing
// (with the exception of flushing the trace buffer).

//
// For now enable ASSERT defines only if debugging is enabled
//
#ifdef  DEBUG
#define _ENABLE_ASSERTS

#ifndef NOTRACE
#define _ENABLE_VERBOSE_ASSERTS
#endif	// NO_TRACE

#endif	// DEBUG

//
// Macros added for doing asserts and verifies.  basic clones
// of the MFC macros with a prepended _ symbol
//
#ifdef  _ENABLE_ASSERTS

extern DllExport void WINAPI DebugAssert(	DWORD dwLine,
											LPSTR lpszFunction,
											LPSTR lpszExpression );

#ifndef _ASSERT
#ifdef  _ENABLE_VERBOSE_ASSERTS
#define _ASSERT(f)	!(f) ? DebugAssert( __LINE__,  THIS_FILE, #f ) : ((void)0)
#else
#define _ASSERT(f)	!(f) ? DebugBreak() : ((void)0)
#endif	//_ENABLE_VERBOSE_ASSERTS
#endif

#define _VERIFY(f)	_ASSERT(f)

#else

#define _ASSERT(f)	((void)0)
#define _VERIFY(f)	((void)(f))

#endif	// _ENABLE_ASSERTS


#ifdef __cplusplus
} // extern "C"

#ifdef NOTRACE

#define TraceFunctEntry(sz)

#else

class CTraceEntry
{
public:
    CTraceEntry(char * psz)
    {
        this->___pszFunctionName = psz;
        FunctTrace( 0, "Entering %s", psz);
    }
    ~CTraceEntry()
    {
        FunctTrace( 0, "Leaving %s", this->___pszFunctionName);
    }
    char * ___pszFunctionName;
};

#define TraceFunctEntry(sz) CTraceEntry __cte(sz)

#endif // NOTRACE


#endif


#endif // !defined(_DBGTRACE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iasapix.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasapix.h
//
// SYNOPSIS
//
//    This file describes the IAS C++ API.
//
// MODIFICATION HISTORY
//
//    11/10/1997    Original version.
//    01/08/1998    Renamed to iasapix.h (was iascback.h).
//    08/10/1998    Remove obsolete IASRegMap.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASAPIX_H_
#define _IASAPIX_H_

#ifndef _IASAPI_H_
#error iasapi.h must be included first.
#endif

#ifdef __cplusplus

///////////////////////////////////////////////////////////////////////////////
//
// MACRO
//
//    IAS_DECLARE_REGISTRY
//
// DESCRIPTION
//
//    Macro that allows ATL COM components to use the IASRegisterComponent
//    API.
//
///////////////////////////////////////////////////////////////////////////////
#define IAS_DECLARE_REGISTRY(coclass, ver, flags, tlb) \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
{ \
   return IASRegisterComponent(_Module.GetModuleInstance(), \
                               __uuidof(coclass), \
                               IASProgramName, \
                               L ## #coclass, \
                               flags, \
                               __uuidof(tlb), \
                               ver, \
                               0, \
                               bRegister); \
}


///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    Callback
//
// DESCRIPTION
//
//    This servers as the base class for all callback objects. The
//    CallbackRoutine member serves as a mini-vtable to provide polymorphism.
//    I chose not to use a virtual function for two reasons: C compatibility
//    and to make the IAS_CALLBACK struct as lightweight as possible. The
//    Callback objects make use of the small block allocator, so all
//    derived classes must be smaller than IAS_SMALLBLOCK_SIZE.
//
///////////////////////////////////////////////////////////////////////////////
struct Callback : IAS_CALLBACK
{
   Callback(VOID (WINAPI *pFn)(Callback*))
   { CallbackRoutine = (IAS_CALLBACK_ROUTINE)pFn; }

   void operator()(){ CallbackRoutine(this); }
};


///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    cback_fun_t, cback_fun1_t, cback_mem_t, cback_mem1_t
//
// DESCRIPTION
//
//    Various templated classes that extend Callback to implement the most
//    common scenarios.
//
//    These classes should not be instantiated directly.  Use the MakeCallback
//    and MakeBoundCallback functions instead (see below).
//
///////////////////////////////////////////////////////////////////////////////
template <class Fn>
struct cback_fun_t : Callback
{
   typedef cback_fun_t<Fn> _Myt;

   cback_fun_t(Fn pFn)
      : Callback(CallbackRoutine), m_pFn(pFn) { }

   void operator()() { m_pFn(); }

protected:
   Fn m_pFn;

   static VOID WINAPI CallbackRoutine(Callback* This)
   { (*((_Myt*)This))(); delete This; }
};


template <class Fn, class A>
struct cback_fun1_t : Callback
{
   typedef cback_fun1_t<Fn, A> _Myt;

   cback_fun1_t(Fn pFn, A vArg)
      : Callback(CallbackRoutine), m_pFn(pFn), m_vArg(vArg) { }

   void operator()() { m_pFn(m_vArg); }

protected:
   Fn m_pFn;
   A m_vArg;

   static VOID WINAPI CallbackRoutine(Callback* This)
   { (*((_Myt*)This))(); delete This; }
};


template <class Ty, class Fn>
struct cback_mem_t : Callback
{
   typedef cback_mem_t<Ty, Fn> _Myt;

   cback_mem_t(Ty* pObj, Fn pFn)
      : Callback(CallbackRoutine), m_pObj(pObj), m_pFn(pFn) { }

   void operator()() { (m_pObj->*m_pFn)(); }

protected:
   Ty* m_pObj;
   Fn m_pFn;

   static VOID WINAPI CallbackRoutine(Callback* This)
   { (*((_Myt*)This))(); delete This; }
};


template <class Ty, class Fn, class A>
struct cback_mem1_t : Callback
{
   typedef cback_mem1_t<Ty, Fn, A> _Myt;

   cback_mem1_t(Ty* pObj, Fn pFn, A vArg)
      : Callback(CallbackRoutine), m_pObj(pObj), m_pFn(pFn), m_vArg(vArg) { }

   void operator()() { (m_pObj->*m_pFn)(m_vArg); }

protected:
   Ty* m_pObj;
   A m_vArg;    // Put m_vArg second since it might require 8 byte alignment.
   Fn m_pFn;

   static VOID WINAPI CallbackRoutine(Callback* This)
   { (*((_Myt*)This))(); delete This; }
};


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    MakeCallback
//
// DESCRIPTION
//
//    This overloaded function provides an interface for constructing a
//    Callback object that invokes a non-member function. The function can
//    use any calling convention, have any return type, and take zero or one
//    arguments. The argument must have a copy constructor and be eight bytes
//    or less.
//
//    The callback will be deleted automatically when it is invoked.
//    Otherwise, the caller is responsible for deleting the object.
//
// EXAMPLE
//
//    class Foo
//    {
//    public:
//        static void Bar(DWORD dwSomeArg);
//    };
//
//    DWORD dwArg = 12;
//    Callback* cback = MakeCallback(&Foo::Bar, dwArg);
//
///////////////////////////////////////////////////////////////////////////////
template <class Fn>
inline Callback* MakeCallback(Fn pFn)
{
   return new cback_fun_t<Fn>(pFn);
}


template <class Fn, class A>
inline Callback* MakeCallback(Fn pFn, A vArg)
{
   return new cback_fun1_t<Fn, A>(pFn, vArg);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    MakeBoundCallback
//
// DESCRIPTION
//
//    This overloaded function provides an interface for constructing a
//    Callback object that invokes a bound (member) function. The function
//    can use any calling convention, have any return type, and take zero or
//    one arguments. The argument must have a copy constructor and be eight
//    bytes or less.
//
//    The callback will be deleted automatically when it is invoked.
//    Otherwise, the caller is responsible for deleting the object.
//
// EXAMPLE
//
//    class Foo
//    {
//    public:
//        void Bar(DWORD dwSomeArg);
//    } foo;
//
//    DWORD dwArg = 12;
//    Callback* cback = MakeCallback(&foo, &Foo::Bar, dwArg);
//
///////////////////////////////////////////////////////////////////////////////
template <class Ty, class Fn>
inline Callback* MakeBoundCallback(Ty* pObj, Fn pFn)
{
   return new cback_mem_t<Ty, Fn>(pObj, pFn);
}


template <class Ty, class Fn, class A>
inline Callback* MakeBoundCallback(Ty* pObj, Fn pFn, A vArg)
{
   return new cback_mem1_t<Ty, Fn, A>(pObj, pFn, vArg);
}

#endif  // __cplusplus
#endif  // _IASAPIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iasattr.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:        iasattr.h
//
// Project:        Everest
//
// Description:    IAS Attribute Function Prototypes
//
// Author:        Todd L. Paul 11/11/97
//
///////////////////////////////////////////////////////////////////////////

#ifndef __IAS_ATTRIBUTE_API_H_
#define __IAS_ATTRIBUTE_API_H_

#include "iaspolcy.h"

#ifndef IASPOLCYAPI
#define IASPOLCYAPI DECLSPEC_IMPORT
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// IAS raw attributes API
//
IASPOLCYAPI
DWORD
WINAPI
IASAttributeAlloc(
    DWORD dwCount,
    IASATTRIBUTE **pAttribute
    );

IASPOLCYAPI
DWORD
WINAPI
IASAttributeUnicodeAlloc(
    PIASATTRIBUTE Attribute
    );

IASPOLCYAPI
DWORD
WINAPI
IASAttributeAnsiAlloc(
    PIASATTRIBUTE Attribute
    );

IASPOLCYAPI
DWORD
WINAPI
IASAttributeAddRef(
    PIASATTRIBUTE pAttribute
    );

IASPOLCYAPI
DWORD
WINAPI
IASAttributeRelease(
    PIASATTRIBUTE pAttribute
    );

#ifdef __cplusplus
}
#endif
#endif    // __IAS_ATTRIBUTE_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iascompool.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:		iascompool.h
//
// Project:		Everest
//
// Description:	Object pool that uses CoTaskMemAlloc() / CoTaskMemFree()
//
// Author:		TLP 11/11/97
//
///////////////////////////////////////////////////////////////////////////

#ifndef __IAS_COM_MEMPOOL_H_
#define __IAS_COM_MEMPOOL_H_

// Assume another include has #included ias.h
#include <vector>
#include <list>
using namespace std;

#define		COM_MEMPOOL_INITIALIZED			1
#define		COM_MEMPOOL_UNINITIALIZED		0

//
// NOTE: m_lState must be aligned on 32 bit value or calls to
//       InterlockedExchange will fail on multi-processor x86 systems.

template < class T, DWORD dwPerAllocT, bool bFixedSize > 
class CComMemPool
{
	// State flag - 1 = mem pool initialized, 0 = mem pool uninitialized
	LONG							m_lState;
	// Total number of items allocated
	DWORD							m_dwCountTotal; 
	// Number of items on the free list
	DWORD							m_dwCountFree;
	// Highest number of outstanding allocations
	DWORD							m_dwHighWater;
	// Number of objects per system memory allocation
	DWORD							m_dwPerAllocT;
	// Fixed size pool flag
	bool							m_bFixedSize;
	// Critical Section - serializes free item list access
	CRITICAL_SECTION				m_CritSec;		
	// Memory block list
	typedef list<PVOID>				MemBlockList;
	typedef MemBlockList::iterator	MemBlockListIterator;
	MemBlockList					m_listMemBlocks;
	// Free item list
	typedef list<T*>				FreeList;
	typedef FreeList::iterator		FreeListIterator;
	FreeList						m_listFreeT;	

	// Disallow copy and assignment
	CComMemPool(const CComMemPool& theClass);
	CComMemPool& operator=(const CComMemPool& theClass);

public:

	//
	// Constructor
	//
	CComMemPool()
		:  m_listMemBlocks(0), 
		   m_listFreeT(0) // pre-alloc space for list nodes 
	{
		m_lState = COM_MEMPOOL_UNINITIALIZED;
		m_dwPerAllocT = dwPerAllocT;
		m_bFixedSize = bFixedSize;
		m_dwCountTotal = 0;
		m_dwCountFree = 0;
		m_dwHighWater = 0;
		InitializeCriticalSection(&m_CritSec);
	}

	//
	// Destructor
	//
	~CComMemPool()
	{
		_ASSERT( COM_MEMPOOL_UNINITIALIZED == m_lState );
		DeleteCriticalSection(&m_CritSec);
	}


	//////////////////////////////////////////////////////////////////////////
	// Init() - Initialize the memory pool
	//////////////////////////////////////////////////////////////////////////
	bool Init(void)
	{
		bool	bReturn = false;

		if ( COM_MEMPOOL_UNINITIALIZED == InterlockedExchange(&m_lState, COM_MEMPOOL_INITIALIZED) ) 
		{
			if ( AllocateMemBlock() )
			{
				bReturn = true;
			}
			else
			{
				InterlockedExchange(&m_lState, COM_MEMPOOL_UNINITIALIZED);
			}
		}
		else 
		{
			_ASSERTE(FALSE);		
		}
		return bReturn;
	}


	//////////////////////////////////////////////////////////////////////////
	// Shutdown() - Shutdown the memory pool freeing any system resources used
	//////////////////////////////////////////////////////////////////////////
	void	Shutdown(void)
	{
		MemBlockListIterator p;
		MemBlockListIterator q;

		if ( COM_MEMPOOL_INITIALIZED == InterlockedExchange(&m_lState, COM_MEMPOOL_UNINITIALIZED) )
		{
			if ( m_dwCountTotal != m_dwCountFree )
			{
				// Still have blocks outstanding...
				//
				_ASSERTE( FALSE );
			}
			if ( ! m_listMemBlocks.empty() )
			{
				p = m_listMemBlocks.begin();
				q = m_listMemBlocks.end();
				while ( p != q )
				{
					CoTaskMemFree(*p);
					p++;
				}
				m_listMemBlocks.clear();
			}
			m_dwCountTotal = 0;
			m_dwCountFree = 0;
		}
		else 
		{
			// COM pool is not inititalized
			//
			_ASSERTE( FALSE );
		}
	}

	
	//////////////////////////////////////////////////////////////////////////
	// Alloc() - Allocate an unitialized object from the pool
	//////////////////////////////////////////////////////////////////////////
	T*	Alloc(void)
	{
		T*	pMemBlk = NULL;

		TraceFunctEnter("CComMemPool::Alloc()");

		if ( COM_MEMPOOL_INITIALIZED == m_lState )
		{
			EnterCriticalSection(&m_CritSec);
			if ( m_listFreeT.empty() )
			{
				if ( ! m_bFixedSize )
				{
					if ( AllocateMemBlock() )
					{
						pMemBlk = m_listFreeT.front();
						m_listFreeT.pop_front();
						m_dwCountFree--;
						if ( m_dwHighWater < (m_dwCountTotal - m_dwCountFree) )
						{
							m_dwHighWater++;
						}
					}
					else
					{
						ErrorTrace(0,"Could not allocate memory!");
					}
				}
				else
				{
					ErrorTrace(0,"Fixed size pool is exhausted!");
				}
			}
			else 
			{
				pMemBlk = m_listFreeT.front();
				m_listFreeT.pop_front();
				m_dwCountFree--;
				if ( m_dwHighWater < (m_dwCountTotal - m_dwCountFree) )
				{
					m_dwHighWater++;
				}
			}
			LeaveCriticalSection(&m_CritSec);
		}
		else
		{
			ErrorTrace(0,"The memory pool is not initialized!");
			_ASSERTE( FALSE );
		}
		if ( pMemBlk )
		{
			memset(pMemBlk, 0, sizeof(T));
			new (pMemBlk) T();	// Placement new for class T - requires default contructor
		}
		TraceFunctLeave();
		return pMemBlk;
	}

	
	//////////////////////////////////////////////////////////////////////////
	// Free() - Return an object to the memory pool
	//////////////////////////////////////////////////////////////////////////
	void	Free(T *pMemBlk)
	{
		TraceFunctEnter("CComMemPool::Free()");
		if ( COM_MEMPOOL_INITIALIZED == m_lState )
		{
			pMemBlk->~T(); // Explicit call to destructor due to placement new
			EnterCriticalSection(&m_CritSec);
			m_listFreeT.insert(m_listFreeT.begin(),pMemBlk);
			m_dwCountFree++;
			LeaveCriticalSection(&m_CritSec);
		}
		else
		{
			ErrorTrace(0,"The memory pool is not initialized!");
			_ASSERTE( FALSE );
		}
		TraceFunctLeave();
	}


	//////////////////////////////////////////////////////////////////////////
	// Dump() - Dump the contents of the memory pool - Debug Service 
	//////////////////////////////////////////////////////////////////////////
	void	Dump(void)
	{

#ifdef DEBUG

		UINT i;
		MemBlockListIterator p;
		FreeListIterator r;
		FreeListIterator s;

		TraceFunctEnter("CComMemPool::Dump()");
		if ( COM_MEMPOOL_INITIALIZED == m_lState )
		{
			// Dump the counts
			EnterCriticalSection(&m_CritSec);
			DebugTrace(0,"m_dwCountTotal = %d", m_dwCountTotal);
			DebugTrace(0,"m_dwCountFree = %d", m_dwCountFree);
			DebugTrace(0,"m_dwHighWater = %d", m_dwHighWater);
			// Dump the pointers to memory blocks
			DebugTrace(0,"m_listMemBlocks.size() = %d", m_listMemBlocks.size());
			p = m_listMemBlocks.begin();
			i = 0;
			while ( p != m_listMemBlocks.end() )
			{
				DebugTrace(0,"m_listMemBlocks block %d = $%p", i, *p);
				i++;
				p++;
			}
			// Dump the pointers to items
			DebugTrace(0,"CComMemPool::Dump() - m_listFreeT.size() = %d", m_listFreeT.size());
			r = m_listFreeT.begin();
			i = 0;
			while ( r != m_listFreeT.end() )
			{
				DebugTrace(0,"CComMemPool::Dump() - m_listFreeT item %d = $%p", i, *r);
				i++;
				r++;
			}
			LeaveCriticalSection(&m_CritSec);
		}
		else
		{
			ErrorTrace(0,"The memory pool is not initialized!");
			_ASSERTE( FALSE );
		}
		TraceFunctLeave();
#endif	// DEBUG

	}


private:

	//////////////////////////////////////////////////////////////////////////
	// AllocateMemBlock() - Allocate some system memory and chop it into 
	//						T sized blocks
	//////////////////////////////////////////////////////////////////////////
	bool	AllocateMemBlock()
	{

	bool	bReturn = false;
	UINT	i;
	UINT	uBlkSize;
	T*		lpMemBlock;

		TraceFunctEnter("CComMemPool::AllocateMemBlock()");
		uBlkSize = m_dwPerAllocT * sizeof(T);
		lpMemBlock = (T*) CoTaskMemAlloc(uBlkSize);
		if ( lpMemBlock )
		{
			memset(lpMemBlock, 0, uBlkSize);
			m_listMemBlocks.insert(m_listMemBlocks.begin(), (PVOID)lpMemBlock);
			// Chop up the newly allocated memory block into sizeof(T) sized elements and place
			// the elements on the list of pointers to Ts.
			for ( i = 0; i < m_dwPerAllocT; i++ )
			{
				m_listFreeT.insert(m_listFreeT.end(),lpMemBlock);
				lpMemBlock++;
			}
			// Update the pool memory use variables
			m_dwCountTotal += m_dwPerAllocT;
			m_dwCountFree += m_dwPerAllocT;
			bReturn = true;
		}
		TraceFunctLeave();
		return bReturn;
	}

};	// End of CComMemPool


#endif	// __IAS_COM_MEMPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iasdefs.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasdefs.h
//
// SYNOPSIS
//
//    Declares various constants used by IAS.
//
// MODIFICATION HISTORY
//
//    08/07/1997    Original version.
//    12/19/1997    Added database string constants.
//    05/20/1998    Removed attribute name constants.
//    08/13/1998    Removed various string constants that weren't being used.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASDEFS_H_
#define _IASDEFS_H_

//////////
// The name of the IAS Service.
//////////
#define IASServiceName L"IAS"

//////////
// The name of the IAS Program
// Used for forming ProgID's of the format Program.Component.Version.
//////////
#define IASProgramName IASServiceName

//////////
// Macro to munge a component string literal into a full ProgID.
//////////
#define IAS_PROGID(component) IASProgramName L"." L#component

//////////
// Microsoft's Vendor ID
//////////
#define IAS_VENDOR_MICROSOFT 311

#endif  // _IASDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iasdebug.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasdebug.h
//
// SYNOPSIS
//
//    This file defines various debug macros.
//
// MODIFICATION HISTORY
//
//    10/22/1997    Original version.
//    05/21/1999    Stub out old style trace.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IASDEBUG_H
#define IASDEBUG_H

__inline int PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{ return 1; }

#define ErrorTrace  1 ? (void)0 : PreAsyncTrace
#define DebugTrace  1 ? (void)0 : PreAsyncTrace

#define DECLARE_TRACELIFE(Name)
#define DEFINE_TRACELIFE(Name)
#define TRACE_FUNCTION(Name)

#endif  // IASDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iasinfo.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasinfo.h
//
// SYNOPSIS
//
//    This file describes the structs that are placed in shared memory
//    to expose server information to the outside world.
//
// MODIFICATION HISTORY
//
//    09/09/1997    Original version.
//    09/08/1998    Conform to latest rev. of ietf draft.
//    02/16/2000    Added proxy counters.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASINFO_H_
#define _IASINFO_H_

//////////
// Counters that are global to the RADIUS server.
//////////
typedef enum _RadiusServerCounter
{
   radiusAuthServTotalInvalidRequests,
   radiusAccServTotalInvalidRequests,
   NUM_RADIUS_SERVER_COUNTERS
} RadiusServerCounter;


//////////
// Counters that are maintained per RADIUS client.
//////////
typedef enum _RadiusClientCounter
{
   radiusAuthServMalformedAccessRequests,
   radiusAuthServBadAuthenticators,
   radiusAuthServPacketsDropped,
   radiusAuthServUnknownType,
   radiusAuthServAccessRequests,
   radiusAuthServDupAccessRequests,
   radiusAuthServAccessAccepts,
   radiusAuthServAccessRejects,
   radiusAuthServAccessChallenges,
   radiusAccServMalformedRequests,
   radiusAccServBadAuthenticators,
   radiusAccServPacketsDropped,
   radiusAccServUnknownType,
   radiusAccServRequests,
   radiusAccServDupRequests,
   radiusAccServNoRecord,
   radiusAccServResponses,
   NUM_RADIUS_CLIENT_COUNTERS
} RadiusClientCounter;


//////////
// Struct used to represents a single entry in the client table.
//////////
typedef struct _RadiusClientEntry
{
   DWORD dwAddress;  // Client IP address in network order.
   DWORD dwCounters[NUM_RADIUS_CLIENT_COUNTERS];
} RadiusClientEntry;


//////////
// Struct used to represent the server.
//////////
typedef struct _RadiusServerEntry
{
   LARGE_INTEGER     liStartTime;
   LARGE_INTEGER     liResetTime;
   DWORD             dwCounters[NUM_RADIUS_SERVER_COUNTERS];
} RadiusServerEntry;


//////////
// Struct used to represent all shared statistics.
//////////
typedef struct _RadiusStatistics
{
   RadiusServerEntry seServer;
   DWORD             dwNumClients;
   RadiusClientEntry ceClients[1];
} RadiusStatistics;


//////////
// Counters that are global to the RADIUS proxy.
//////////
typedef enum _RadiusProxyCounter
{
   radiusAuthClientInvalidAddresses,
   radiusAccClientInvalidAddresses,
   NUM_RADIUS_PROXY_COUNTERS
} RadiusProxyCounter;


//////////
// Counters that are maintained per remote RADIUS server.
//////////
typedef enum _RadiusRemoteServerCounter
{
   radiusAuthClientServerPortNumber,
   radiusAuthClientRoundTripTime,
   radiusAuthClientAccessRequests,
   radiusAuthClientAccessRetransmissions,
   radiusAuthClientAccessAccepts,
   radiusAuthClientAccessRejects,
   radiusAuthClientAccessChallenges,
   radiusAuthClientUnknownTypes,
   radiusAuthClientMalformedAccessResponses,
   radiusAuthClientBadAuthenticators,
   radiusAuthClientPacketsDropped,
   radiusAuthClientTimeouts,
   radiusAccClientServerPortNumber,
   radiusAccClientRoundTripTime,
   radiusAccClientRequests,
   radiusAccClientRetransmissions,
   radiusAccClientResponses,
   radiusAccClientUnknownTypes,
   radiusAccClientMalformedResponses,
   radiusAccClientBadAuthenticators,
   radiusAccClientPacketsDropped,
   radiusAccClientTimeouts,

   NUM_RADIUS_REMOTE_SERVER_COUNTERS
} RadiusRemoteServerCounter;


//////////
// Struct used to represents a single entry in the remote servers table.
//////////
typedef struct _RadiusRemoteServerEntry
{
   DWORD dwAddress;  // Server IP address in network order.
   DWORD dwCounters[NUM_RADIUS_REMOTE_SERVER_COUNTERS];
} RadiusRemoteServerEntry;


//////////
// Struct used to represent the proxy.
//////////
typedef struct _RadiusProxyEntry
{
   DWORD dwCounters[NUM_RADIUS_PROXY_COUNTERS];
} RadiusProxyEntry;


//////////
// Struct used to represent all shared proxy statistics.
//////////
typedef struct _RadiusProxyStatistics
{
   RadiusProxyEntry        peProxy;
   DWORD                   dwNumRemoteServers;
   RadiusRemoteServerEntry rseRemoteServers[1];
} RadiusProxyStatistics;

//////////
// Name of the shared memory mappings.
//////////
#define RadiusStatisticsName       L"{A5B99A4C-2959-11D1-BAC8-00C04FC2E20D}"
#define RadiusProxyStatisticsName  L"{A5B99A4E-2959-11D1-BAC8-00C04FC2E20D}"

//////////
// Name of the mutex controlling access.
//////////
#define RadiusStatisticsMutex      L"{A5B99A4D-2959-11D1-BAC8-00C04FC2E20D}"

#endif  // _IASINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iasplcy.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      iasplcy.h
//
// Project:     Everest
//
// Description: IAS Policy Initialization / Shutdown Function Prototypes
//
// Author:      Todd L. Paul 11/11/97
//
///////////////////////////////////////////////////////////////////////////

#ifndef __IAS_POLICY_API_H_
#define __IAS_POLICY_API_H_

#include <ias.h>

STDAPI_(DWORD) IASPolicyInitialize(void);
STDAPI_(DWORD) IASPolicyShutdown(void);

STDAPI_(DWORD) IASPipelineInitialize(void);
STDAPI_(DWORD) IASPipelineShutdown(void);

#endif  // __IAS_POLICY_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iasexceptns.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:		iasexceptns.h
//
// Project:		Everest
//
// Description:	IAS Exceptions
//
// Author:		TLP 1/20/98
//
///////////////////////////////////////////////////////////////////////////

#ifndef _IAS_EXCEPTIONS_H
#define _IAS_EXCEPTIONS_H

// Assume another include has #included ias.h

// Exception Class for Win32 Errors

class CWin32Error {

	LPTSTR		m_lpMsgBuf;
	DWORD		m_dwLastError;

public:
    
	//////////////////////////////////////////////////////////////////////
	CWin32Error() throw() 
		: m_lpMsgBuf(NULL)
	{ 
		m_dwLastError = GetLastError(); 
	}

    //////////////////////////////////////////////////////////////////////
	~CWin32Error() throw() 
	{ 
		if ( m_lpMsgBuf )
		{
			LocalFree( m_lpMsgBuf );
		}
	}

	//////////////////////////////////////////////////////////////////////
	DWORD Error()
	{
		return m_dwLastError;
	}

    //////////////////////////////////////////////////////////////////////
	LPCTSTR Reason() const throw()
	{ 
		DWORD	dwCount;

		_ASSERTE ( NULL == m_lpMsgBuf );

		dwCount = FormatMessage(
								FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
								NULL,
								m_dwLastError,
								MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
								(LPTSTR) &m_lpMsgBuf,
								0,
								NULL
							   );
		if ( dwCount > 0 )
		{
			return m_lpMsgBuf;
		}
		else
		{
			return NULL;
		}
	}
};

#endif // __IAS_EXCEPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iaspragma.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iaspragma.h
//
// SYNOPSIS
//
//    Compiler pragma's used by IAS.
//
// MODIFICATION HISTORY
//
//    07/09/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASPRAGMA_H_
#define _IASPRAGMA_H_

// C++ Exception Specification ignored
#pragma warning(disable:4290)

#endif  // _IASPRAGMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iastransport.h ===
//#--------------------------------------------------------------
//
//  File:       iohandler.h
//
//  Synopsis:   This file holds the API declaration for the
//              RADIUS Transport DLLs
//
//  History:     11/21/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _IASTRANSPORT_H_
#define _IASTRANSPORT_H_


#ifdef __cplusplus
extern "C" {
#endif

//
// initialize the Transport DLL
//
BOOL    WINAPI
IASTransportInit (
    VOID
    );

//
// Open a Port to carry out data transfer
//
BOOL    WINAPI
IASOpenPort (
    DWORD   dwPortNumber,
    DWORD   dwOpAttribs,
    PDWORD_PTR pdwHandle
    );


//
// Close the Port
//
BOOL    WINAPI
IASClosePort (
    DWORD_PTR dwHandle
    );

//
// send data out through a previously opened port
//
BOOL    WINAPI
IASSendData (
    DWORD_PTR dwHandle,
    PBYTE   pBuffer,
    DWORD   dwSize,
    DWORD   dwPeerAddress,
    WORD    wPeerAddress
    );

//
// Recv Data from a previously opened port
//
BOOL WINAPI
IASRecvData    (
    DWORD_PTR dwHandle,
    PBYTE   pBuffer,
    PDWORD  pdwSize,
    PDWORD  pdwPeerAddress,
    PWORD   pwPeerPort
    );

#ifdef __cplusplus
}
#endif

#endif  //  #ifndef _IASTRANSPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iasuuid.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasuuid.h
//
// SYNOPSIS
//
//    This file contains a list of all the UUID's used by IAS.
//
///////////////////////////////////////////////////////////////////////////////

//////////
// Don't pull in the VC++ COM support if IAS_LEAN_AND_MEAN is defined.
//////////

#ifndef GUID_DEFS_ONLY
#ifndef IAS_LEAN_AND_MEAN
   #include <comdef.h>
#else
   #include <ole2.h>
#endif
#endif

//////////
// If the macro INITGUID is defined, we'll actually define the guid's.
// Generally, this is unnecessary since you should link against iasuuid.lib
// instead.
//////////
#ifndef INITGUID
   #define IAS_DEFINE_GUID(prefix, type) \
   EXTERN_C const IID prefix##type
#else
   #define IAS_DEFINE_GUID(prefix, type) \
   EXTERN_C const IID prefix##type = __uuidof(type)
#endif

//////////
// Interfaces.
//////////
#ifndef IAS_LEAN_AND_MEAN
   #define IAS_IID(iid, intfc) \
   struct __declspec(uuid(#iid)) intfc; \
   IAS_DEFINE_GUID(IID_, intfc);\
   _COM_SMARTPTR_TYPEDEF(intfc, __uuidof(intfc));
#else
   #define IAS_IID(iid, intfc) \
   struct __declspec(uuid(#iid)) intfc; \
   IAS_DEFINE_GUID(IID_, intfc);
#endif

//////////
// CoClasses.
//////////
#define IAS_CLS(clsid, coclass) \
class __declspec(uuid(#clsid)) coclass; \
IAS_DEFINE_GUID(CLSID_, coclass);

//////////
// Type libraries.
//////////
#define IAS_LIB(libid, typelib) \
struct __declspec(uuid(#libid)) typelib; \
IAS_DEFINE_GUID(LIBID_, typelib);


//////////
// Core uuid's
//////////

IAS_LIB(6BC09690-0CE6-11D1-BAAE-00C04FC2E20D, IASCoreLib)

//      6BC09691-0CE6-11D1-BAAE-00C04FC2E20D
IAS_CLS(6BC09692-0CE6-11D1-BAAE-00C04FC2E20D, AttributeDictionary)
IAS_CLS(6BC09693-0CE6-11D1-BAAE-00C04FC2E20D, CIASNetshJetHelper)
//      6BC09694-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC09695-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC09696-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC09697-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC09698-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC09699-0CE6-11D1-BAAE-00C04FC2E20D

IAS_IID(6BC0969A-0CE6-11D1-BAAE-00C04FC2E20D, IAuditSink)
IAS_IID(6BC0969B-0CE6-11D1-BAAE-00C04FC2E20D, IAuditSource)
//      6BC0969C-0CE6-11D1-BAAE-00C04FC2E20D
IAS_CLS(6BC0969D-0CE6-11D1-BAAE-00C04FC2E20D, AuditChannel)
//      6BC0969E-0CE6-11D1-BAAE-00C04FC2E20D
IAS_CLS(6BC0969F-0CE6-11D1-BAAE-00C04FC2E20D, NTEventLog)
IAS_CLS(6BC096A0-0CE6-11D1-BAAE-00C04FC2E20D, InfoBase)
//      6BC096A1-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC096A2-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC096A3-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC096A4-0CE6-11D1-BAAE-00C04FC2E20D


//////////
// Request Handler uuid's
//////////

//////////
// NT-SAM Components.
//////////
//      6BC09895-0CE6-11D1-BAAE-00C04FC2E20D
IAS_CLS(6BC09896-0CE6-11D1-BAAE-00C04FC2E20D, NTSamAuthentication)
IAS_CLS(6BC09897-0CE6-11D1-BAAE-00C04FC2E20D, MSChapErrorReporter)
IAS_CLS(6BC09898-0CE6-11D1-BAAE-00C04FC2E20D, BaseCampHost)
IAS_CLS(6BC09899-0CE6-11D1-BAAE-00C04FC2E20D, AuthorizationHost)
IAS_CLS(6BC0989B-0CE6-11D1-BAAE-00C04FC2E20D, ChangePassword)
IAS_CLS(6BC0989C-0CE6-11D1-BAAE-00C04FC2E20D, NTSamPerUser)
IAS_CLS(6BC0989D-0CE6-11D1-BAAE-00C04FC2E20D, NTSamNames)
IAS_CLS(6BC0989E-0CE6-11D1-BAAE-00C04FC2E20D, AccountValidation)
//      6BC0989F-0CE6-11D1-BAAE-00C04FC2E20D

//////////
// EAP Components.
//////////
IAS_CLS(6BC0989A-0CE6-11D1-BAAE-00C04FC2E20D, EAP)

//
// Accounting
//
IAS_CLS(6BC096B8-0CE6-11D1-BAAE-00C04FC2E20D, Accounting)


//////////
// Network Access Policy Provider.
//////////
IAS_LIB(6BC098A0-0CE6-11D1-BAAE-00C04FC2E20D, NetworkPolicy)
IAS_IID(6BC098A1-0CE6-11D1-BAAE-00C04FC2E20D, ICondition)
IAS_IID(6BC098A2-0CE6-11D1-BAAE-00C04FC2E20D, IConditionText)
IAS_IID(6BC098A3-0CE6-11D1-BAAE-00C04FC2E20D, IPolicyAction)
IAS_CLS(6BC098A4-0CE6-11D1-BAAE-00C04FC2E20D, AttributeMatch)
IAS_CLS(6BC098A5-0CE6-11D1-BAAE-00C04FC2E20D, NTGroups)
IAS_CLS(6BC098A6-0CE6-11D1-BAAE-00C04FC2E20D, TimeOfDay)
IAS_CLS(6BC098A7-0CE6-11D1-BAAE-00C04FC2E20D, PolicyEnforcer)
//      6BC098A8-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC098A9-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC098AA-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC098AB-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC098AC-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC098AD-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC098AE-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC098AF-0CE6-11D1-BAAE-00C04FC2E20D

//////////
// Data Store
//////////
IAS_IID(6BC096C0-0CE6-11D1-BAAE-00C04FC2E20D, IDataStoreObject)
IAS_IID(6BC096C1-0CE6-11D1-BAAE-00C04FC2E20D, IDataStoreContainer)
IAS_IID(6BC096C2-0CE6-11D1-BAAE-00C04FC2E20D, IDataStore2)
//      6BC096C3-0CE6-11D1-BAAE-00C04FC2E20D
IAS_CLS(6BC096C4-0CE6-11D1-BAAE-00C04FC2E20D, OleDBDataStore)
IAS_LIB(6BC096C5-0CE6-11D1-BAAE-00C04FC2E20D, DataStore2Lib)
IAS_CLS(6BC096C6-0CE6-11D1-BAAE-00C04FC2E20D, ADsDataStore)
//      6BC096C7-0CE6-11D1-BAAE-00C04FC2E20D
IAS_CLS(6BC096C8-0CE6-11D1-BAAE-00C04FC2E20D, NetDataStore)
IAS_IID(6BC096C9-0CE6-11D1-BAAE-00C04FC2E20D, IDataStoreProperty)
//      6BC096CA-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC096CB-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC096CC-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC096CD-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC096CE-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC096CF-0CE6-11D1-BAAE-00C04FC2E20D


///////////
// Policy Component uuids
///////////

//
// Policy uuids (Any type of Policy supports these interfaces)
//
IAS_LIB(6BC096A5-0CE6-11D1-BAAE-00C04FC2E20D, IASPolicyLib)
IAS_IID(6BC096A6-0CE6-11D1-BAAE-00C04FC2E20D, IAttribute)
IAS_IID(6BC096A7-0CE6-11D1-BAAE-00C04FC2E20D, IRequest)
IAS_IID(6BC096A8-0CE6-11D1-BAAE-00C04FC2E20D, IAttributesRaw)
IAS_IID(6BC096BA-0CE6-11D1-BAAE-00C04FC2E20D, IRequestState)
IAS_IID(6BC096AA-0CE6-11D1-BAAE-00C04FC2E20D, IRequestHandler)
IAS_IID(6BC096A9-0CE6-11D1-BAAE-00C04FC2E20D, IRequestSource)
IAS_IID(6BC096AB-0CE6-11D1-BAAE-00C04FC2E20D, IQualityControl)
IAS_CLS(6BC096B0-0CE6-11D1-BAAE-00C04FC2E20D, Attribute)
IAS_CLS(6BC096B1-0CE6-11D1-BAAE-00C04FC2E20D, Request)

//
// Pipeline uuids (Policy implementation)
//
IAS_LIB(6BC096B9-0CE6-11D1-BAAE-00C04FC2E20D, IASPipelineLib)
IAS_IID(6BC096AC-0CE6-11D1-BAAE-00C04FC2E20D, IStage)
IAS_IID(6BC096AD-0CE6-11D1-BAAE-00C04FC2E20D, IPipeline)
IAS_IID(6BC096BE-0CE6-11D1-BAAE-00C04FC2E20D, IPipelineManager)
IAS_IID(6BC096AE-0CE6-11D1-BAAE-00C04FC2E20D, IConnector)
IAS_IID(6BC096AF-0CE6-11D1-BAAE-00C04FC2E20D, IConnectorInput)
IAS_CLS(6BC096B2-0CE6-11D1-BAAE-00C04FC2E20D, Stage)
IAS_CLS(6BC096B3-0CE6-11D1-BAAE-00C04FC2E20D, Pipeline)
IAS_CLS(6BC096BF-0CE6-11D1-BAAE-00C04FC2E20D, PipelineManager)

// 6BC096D0-0CE6-11D1-BAAE-00C04FC2E20D
// 6BC096D1-0CE6-11D1-BAAE-00C04FC2E20D
// 6BC096D2-0CE6-11D1-BAAE-00C04FC2E20D
// 6BC096D3-0CE6-11D1-BAAE-00C04FC2E20D

///////////
// Protocol Component uuids
///////////

//
// RADIUS protocol uuids
//
IAS_LIB (6BC09890-0CE6-11D1-BAAE-00C04FC2E20D, IASRadiusLib)
IAS_IID (6BC09891-0CE6-11D1-BAAE-00C04FC2E20D, IEasObject)
IAS_IID (6BC09892-0CE6-11D1-BAAE-00C04FC2E20D, IProtocol)
IAS_IID (6BC09893-0CE6-11D1-BAAE-00C04FC2E20D, IComponentNotify)
IAS_CLS (6BC09894-0CE6-11D1-BAAE-00C04FC2E20D, RadiusProtocol)
IAS_IID (6BC096D9-0CE6-11D1-BAAE-00C04FC2E20D, IIasClient)
IAS_CLS (6BC096DA-0CE6-11D1-BAAE-00C04FC2E20D, CClient)

//
// IAS Helper UUIDs
//
IAS_LIB (6BC096BB-0CE6-11D1-BAAE-00C04FC2E20D, IasHelperLib)
IAS_CLS (6BC096BC-0CE6-11D1-BAAE-00C04FC2E20D, IasHelper)
IAS_IID (6BC096BD-0CE6-11D1-BAAE-00C04FC2E20D, IRecvRequest)

///////////
// Init / Shutdown uuids
//////////
IAS_IID(6BC096B4-0CE6-11D1-BAAE-00C04FC2E20D, IIasComponent)
IAS_CLS(6BC096B5-0CE6-11D1-BAAE-00C04FC2E20D, IASApplication)
//      6BC096B6-0CE6-11D1-BAAE-00C04FC2E20D
//      6BC096B7-0CE6-11D1-BAAE-00C04FC2E20D

//
// User Restrictions Handler
//
IAS_LIB (6BC096D4-0CE6-11D1-BAAE-00C04FC2E20D, URHandlerLib)
IAS_CLS (6BC096D5-0CE6-11D1-BAAE-00C04FC2E20D, URHandler)

//
// SDO private part
//
IAS_CLS (BC94D813-4D7F-11d2-A8C9-00AA00A71DCA, SdoService)
IAS_IID (7A968236-9D6D-11d1-BF5D-000000000000, ISdoService)
IAS_IID (EFF64A83-46C1-11d2-A8C2-00AA00A71DCA, ISdoClassInfo)
IAS_IID (EFF64A84-46C1-11d2-A8C2-00AA00A71DCA, ISdoPropertyInfo)
IAS_IID (7ECBFDCF-4759-11d2-8EC9-00C04FC2F519, ISdoSchema)
IAS_LIB (56BC53D1-96DB-11D1-BF3F-000000000000, SDOIASLibPrivate)

/* ----------------------------------------------------------------------

 Unused core uuid's.

6BC096DB-0CE6-11D1-BAAE-00C04FC2E20D
6BC096DC-0CE6-11D1-BAAE-00C04FC2E20D
6BC096DD-0CE6-11D1-BAAE-00C04FC2E20D
6BC096DE-0CE6-11D1-BAAE-00C04FC2E20D
6BC096DF-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E0-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E1-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E2-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E3-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E4-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E5-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E6-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E7-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E8-0CE6-11D1-BAAE-00C04FC2E20D
6BC096E9-0CE6-11D1-BAAE-00C04FC2E20D
6BC096EA-0CE6-11D1-BAAE-00C04FC2E20D
6BC096EB-0CE6-11D1-BAAE-00C04FC2E20D
6BC096EC-0CE6-11D1-BAAE-00C04FC2E20D
6BC096ED-0CE6-11D1-BAAE-00C04FC2E20D
6BC096EE-0CE6-11D1-BAAE-00C04FC2E20D
6BC096EF-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F0-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F1-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F2-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F3-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F4-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F5-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F6-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F7-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F8-0CE6-11D1-BAAE-00C04FC2E20D
6BC096F9-0CE6-11D1-BAAE-00C04FC2E20D
6BC096FA-0CE6-11D1-BAAE-00C04FC2E20D
6BC096FB-0CE6-11D1-BAAE-00C04FC2E20D
6BC096FC-0CE6-11D1-BAAE-00C04FC2E20D
6BC096FD-0CE6-11D1-BAAE-00C04FC2E20D
6BC096FE-0CE6-11D1-BAAE-00C04FC2E20D
6BC096FF-0CE6-11D1-BAAE-00C04FC2E20D
6BC09700-0CE6-11D1-BAAE-00C04FC2E20D
6BC09701-0CE6-11D1-BAAE-00C04FC2E20D
6BC09702-0CE6-11D1-BAAE-00C04FC2E20D
6BC09703-0CE6-11D1-BAAE-00C04FC2E20D
6BC09704-0CE6-11D1-BAAE-00C04FC2E20D
6BC09705-0CE6-11D1-BAAE-00C04FC2E20D
6BC09706-0CE6-11D1-BAAE-00C04FC2E20D
6BC09707-0CE6-11D1-BAAE-00C04FC2E20D
6BC09708-0CE6-11D1-BAAE-00C04FC2E20D
6BC09709-0CE6-11D1-BAAE-00C04FC2E20D
6BC0970A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0970B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0970C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0970D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0970E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0970F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09710-0CE6-11D1-BAAE-00C04FC2E20D
6BC09711-0CE6-11D1-BAAE-00C04FC2E20D
6BC09712-0CE6-11D1-BAAE-00C04FC2E20D
6BC09713-0CE6-11D1-BAAE-00C04FC2E20D
6BC09714-0CE6-11D1-BAAE-00C04FC2E20D
6BC09715-0CE6-11D1-BAAE-00C04FC2E20D
6BC09716-0CE6-11D1-BAAE-00C04FC2E20D
6BC09717-0CE6-11D1-BAAE-00C04FC2E20D
6BC09718-0CE6-11D1-BAAE-00C04FC2E20D
6BC09719-0CE6-11D1-BAAE-00C04FC2E20D
6BC0971A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0971B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0971C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0971D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0971E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0971F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09720-0CE6-11D1-BAAE-00C04FC2E20D
6BC09721-0CE6-11D1-BAAE-00C04FC2E20D
6BC09722-0CE6-11D1-BAAE-00C04FC2E20D
6BC09723-0CE6-11D1-BAAE-00C04FC2E20D
6BC09724-0CE6-11D1-BAAE-00C04FC2E20D
6BC09725-0CE6-11D1-BAAE-00C04FC2E20D
6BC09726-0CE6-11D1-BAAE-00C04FC2E20D
6BC09727-0CE6-11D1-BAAE-00C04FC2E20D
6BC09728-0CE6-11D1-BAAE-00C04FC2E20D
6BC09729-0CE6-11D1-BAAE-00C04FC2E20D
6BC0972A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0972B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0972C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0972D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0972E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0972F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09730-0CE6-11D1-BAAE-00C04FC2E20D
6BC09731-0CE6-11D1-BAAE-00C04FC2E20D
6BC09732-0CE6-11D1-BAAE-00C04FC2E20D
6BC09733-0CE6-11D1-BAAE-00C04FC2E20D
6BC09734-0CE6-11D1-BAAE-00C04FC2E20D
6BC09735-0CE6-11D1-BAAE-00C04FC2E20D
6BC09736-0CE6-11D1-BAAE-00C04FC2E20D
6BC09737-0CE6-11D1-BAAE-00C04FC2E20D
6BC09738-0CE6-11D1-BAAE-00C04FC2E20D
6BC09739-0CE6-11D1-BAAE-00C04FC2E20D
6BC0973A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0973B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0973C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0973D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0973E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0973F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09740-0CE6-11D1-BAAE-00C04FC2E20D
6BC09741-0CE6-11D1-BAAE-00C04FC2E20D
6BC09742-0CE6-11D1-BAAE-00C04FC2E20D
6BC09743-0CE6-11D1-BAAE-00C04FC2E20D
6BC09744-0CE6-11D1-BAAE-00C04FC2E20D
6BC09745-0CE6-11D1-BAAE-00C04FC2E20D
6BC09746-0CE6-11D1-BAAE-00C04FC2E20D
6BC09747-0CE6-11D1-BAAE-00C04FC2E20D
6BC09748-0CE6-11D1-BAAE-00C04FC2E20D
6BC09749-0CE6-11D1-BAAE-00C04FC2E20D
6BC0974A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0974B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0974C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0974D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0974E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0974F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09750-0CE6-11D1-BAAE-00C04FC2E20D
6BC09751-0CE6-11D1-BAAE-00C04FC2E20D
6BC09752-0CE6-11D1-BAAE-00C04FC2E20D
6BC09753-0CE6-11D1-BAAE-00C04FC2E20D
6BC09754-0CE6-11D1-BAAE-00C04FC2E20D
6BC09755-0CE6-11D1-BAAE-00C04FC2E20D
6BC09756-0CE6-11D1-BAAE-00C04FC2E20D
6BC09757-0CE6-11D1-BAAE-00C04FC2E20D
6BC09758-0CE6-11D1-BAAE-00C04FC2E20D
6BC09759-0CE6-11D1-BAAE-00C04FC2E20D
6BC0975A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0975B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0975C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0975D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0975E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0975F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09760-0CE6-11D1-BAAE-00C04FC2E20D
6BC09761-0CE6-11D1-BAAE-00C04FC2E20D
6BC09762-0CE6-11D1-BAAE-00C04FC2E20D
6BC09763-0CE6-11D1-BAAE-00C04FC2E20D
6BC09764-0CE6-11D1-BAAE-00C04FC2E20D
6BC09765-0CE6-11D1-BAAE-00C04FC2E20D
6BC09766-0CE6-11D1-BAAE-00C04FC2E20D
6BC09767-0CE6-11D1-BAAE-00C04FC2E20D
6BC09768-0CE6-11D1-BAAE-00C04FC2E20D
6BC09769-0CE6-11D1-BAAE-00C04FC2E20D
6BC0976A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0976B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0976C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0976D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0976E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0976F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09770-0CE6-11D1-BAAE-00C04FC2E20D
6BC09771-0CE6-11D1-BAAE-00C04FC2E20D
6BC09772-0CE6-11D1-BAAE-00C04FC2E20D
6BC09773-0CE6-11D1-BAAE-00C04FC2E20D
6BC09774-0CE6-11D1-BAAE-00C04FC2E20D
6BC09775-0CE6-11D1-BAAE-00C04FC2E20D
6BC09776-0CE6-11D1-BAAE-00C04FC2E20D
6BC09777-0CE6-11D1-BAAE-00C04FC2E20D
6BC09778-0CE6-11D1-BAAE-00C04FC2E20D
6BC09779-0CE6-11D1-BAAE-00C04FC2E20D
6BC0977A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0977B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0977C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0977D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0977E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0977F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09780-0CE6-11D1-BAAE-00C04FC2E20D
6BC09781-0CE6-11D1-BAAE-00C04FC2E20D
6BC09782-0CE6-11D1-BAAE-00C04FC2E20D
6BC09783-0CE6-11D1-BAAE-00C04FC2E20D
6BC09784-0CE6-11D1-BAAE-00C04FC2E20D
6BC09785-0CE6-11D1-BAAE-00C04FC2E20D
6BC09786-0CE6-11D1-BAAE-00C04FC2E20D
6BC09787-0CE6-11D1-BAAE-00C04FC2E20D
6BC09788-0CE6-11D1-BAAE-00C04FC2E20D
6BC09789-0CE6-11D1-BAAE-00C04FC2E20D
6BC0978A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0978B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0978C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0978D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0978E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0978F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09790-0CE6-11D1-BAAE-00C04FC2E20D
6BC09791-0CE6-11D1-BAAE-00C04FC2E20D
6BC09792-0CE6-11D1-BAAE-00C04FC2E20D
6BC09793-0CE6-11D1-BAAE-00C04FC2E20D
6BC09794-0CE6-11D1-BAAE-00C04FC2E20D
6BC09795-0CE6-11D1-BAAE-00C04FC2E20D
6BC09796-0CE6-11D1-BAAE-00C04FC2E20D
6BC09797-0CE6-11D1-BAAE-00C04FC2E20D
6BC09798-0CE6-11D1-BAAE-00C04FC2E20D
6BC09799-0CE6-11D1-BAAE-00C04FC2E20D
6BC0979A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0979B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0979C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0979D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0979E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0979F-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A0-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A1-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A2-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A3-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A4-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A5-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A6-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A7-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A8-0CE6-11D1-BAAE-00C04FC2E20D
6BC097A9-0CE6-11D1-BAAE-00C04FC2E20D
6BC097AA-0CE6-11D1-BAAE-00C04FC2E20D
6BC097AB-0CE6-11D1-BAAE-00C04FC2E20D
6BC097AC-0CE6-11D1-BAAE-00C04FC2E20D
6BC097AD-0CE6-11D1-BAAE-00C04FC2E20D
6BC097AE-0CE6-11D1-BAAE-00C04FC2E20D
6BC097AF-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B0-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B1-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B2-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B3-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B4-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B5-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B6-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B7-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B8-0CE6-11D1-BAAE-00C04FC2E20D
6BC097B9-0CE6-11D1-BAAE-00C04FC2E20D
6BC097BA-0CE6-11D1-BAAE-00C04FC2E20D
6BC097BB-0CE6-11D1-BAAE-00C04FC2E20D
6BC097BC-0CE6-11D1-BAAE-00C04FC2E20D
6BC097BD-0CE6-11D1-BAAE-00C04FC2E20D
6BC097BE-0CE6-11D1-BAAE-00C04FC2E20D
6BC097BF-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C0-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C1-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C2-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C3-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C4-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C5-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C6-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C7-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C8-0CE6-11D1-BAAE-00C04FC2E20D
6BC097C9-0CE6-11D1-BAAE-00C04FC2E20D
6BC097CA-0CE6-11D1-BAAE-00C04FC2E20D
6BC097CB-0CE6-11D1-BAAE-00C04FC2E20D
6BC097CC-0CE6-11D1-BAAE-00C04FC2E20D
6BC097CD-0CE6-11D1-BAAE-00C04FC2E20D
6BC097CE-0CE6-11D1-BAAE-00C04FC2E20D
6BC097CF-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D0-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D1-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D2-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D3-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D4-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D5-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D6-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D7-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D8-0CE6-11D1-BAAE-00C04FC2E20D
6BC097D9-0CE6-11D1-BAAE-00C04FC2E20D
6BC097DA-0CE6-11D1-BAAE-00C04FC2E20D
6BC097DB-0CE6-11D1-BAAE-00C04FC2E20D
6BC097DC-0CE6-11D1-BAAE-00C04FC2E20D
6BC097DD-0CE6-11D1-BAAE-00C04FC2E20D
6BC097DE-0CE6-11D1-BAAE-00C04FC2E20D
6BC097DF-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E0-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E1-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E2-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E3-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E4-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E5-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E6-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E7-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E8-0CE6-11D1-BAAE-00C04FC2E20D
6BC097E9-0CE6-11D1-BAAE-00C04FC2E20D
6BC097EA-0CE6-11D1-BAAE-00C04FC2E20D
6BC097EB-0CE6-11D1-BAAE-00C04FC2E20D
6BC097EC-0CE6-11D1-BAAE-00C04FC2E20D
6BC097ED-0CE6-11D1-BAAE-00C04FC2E20D
6BC097EE-0CE6-11D1-BAAE-00C04FC2E20D
6BC097EF-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F0-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F1-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F2-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F3-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F4-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F5-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F6-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F7-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F8-0CE6-11D1-BAAE-00C04FC2E20D
6BC097F9-0CE6-11D1-BAAE-00C04FC2E20D
6BC097FA-0CE6-11D1-BAAE-00C04FC2E20D
6BC097FB-0CE6-11D1-BAAE-00C04FC2E20D
6BC097FC-0CE6-11D1-BAAE-00C04FC2E20D
6BC097FD-0CE6-11D1-BAAE-00C04FC2E20D
6BC097FE-0CE6-11D1-BAAE-00C04FC2E20D
6BC097FF-0CE6-11D1-BAAE-00C04FC2E20D
6BC09800-0CE6-11D1-BAAE-00C04FC2E20D
6BC09801-0CE6-11D1-BAAE-00C04FC2E20D
6BC09802-0CE6-11D1-BAAE-00C04FC2E20D
6BC09803-0CE6-11D1-BAAE-00C04FC2E20D
6BC09804-0CE6-11D1-BAAE-00C04FC2E20D
6BC09805-0CE6-11D1-BAAE-00C04FC2E20D
6BC09806-0CE6-11D1-BAAE-00C04FC2E20D
6BC09807-0CE6-11D1-BAAE-00C04FC2E20D
6BC09808-0CE6-11D1-BAAE-00C04FC2E20D
6BC09809-0CE6-11D1-BAAE-00C04FC2E20D
6BC0980A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0980B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0980C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0980D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0980E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0980F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09810-0CE6-11D1-BAAE-00C04FC2E20D
6BC09811-0CE6-11D1-BAAE-00C04FC2E20D
6BC09812-0CE6-11D1-BAAE-00C04FC2E20D
6BC09813-0CE6-11D1-BAAE-00C04FC2E20D
6BC09814-0CE6-11D1-BAAE-00C04FC2E20D
6BC09815-0CE6-11D1-BAAE-00C04FC2E20D
6BC09816-0CE6-11D1-BAAE-00C04FC2E20D
6BC09817-0CE6-11D1-BAAE-00C04FC2E20D
6BC09818-0CE6-11D1-BAAE-00C04FC2E20D
6BC09819-0CE6-11D1-BAAE-00C04FC2E20D
6BC0981A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0981B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0981C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0981D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0981E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0981F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09820-0CE6-11D1-BAAE-00C04FC2E20D
6BC09821-0CE6-11D1-BAAE-00C04FC2E20D
6BC09822-0CE6-11D1-BAAE-00C04FC2E20D
6BC09823-0CE6-11D1-BAAE-00C04FC2E20D
6BC09824-0CE6-11D1-BAAE-00C04FC2E20D
6BC09825-0CE6-11D1-BAAE-00C04FC2E20D
6BC09826-0CE6-11D1-BAAE-00C04FC2E20D
6BC09827-0CE6-11D1-BAAE-00C04FC2E20D
6BC09828-0CE6-11D1-BAAE-00C04FC2E20D
6BC09829-0CE6-11D1-BAAE-00C04FC2E20D
6BC0982A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0982B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0982C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0982D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0982E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0982F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09830-0CE6-11D1-BAAE-00C04FC2E20D
6BC09831-0CE6-11D1-BAAE-00C04FC2E20D
6BC09832-0CE6-11D1-BAAE-00C04FC2E20D
6BC09833-0CE6-11D1-BAAE-00C04FC2E20D
6BC09834-0CE6-11D1-BAAE-00C04FC2E20D
6BC09835-0CE6-11D1-BAAE-00C04FC2E20D
6BC09836-0CE6-11D1-BAAE-00C04FC2E20D
6BC09837-0CE6-11D1-BAAE-00C04FC2E20D
6BC09838-0CE6-11D1-BAAE-00C04FC2E20D
6BC09839-0CE6-11D1-BAAE-00C04FC2E20D
6BC0983A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0983B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0983C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0983D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0983E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0983F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09840-0CE6-11D1-BAAE-00C04FC2E20D
6BC09841-0CE6-11D1-BAAE-00C04FC2E20D
6BC09842-0CE6-11D1-BAAE-00C04FC2E20D
6BC09843-0CE6-11D1-BAAE-00C04FC2E20D
6BC09844-0CE6-11D1-BAAE-00C04FC2E20D
6BC09845-0CE6-11D1-BAAE-00C04FC2E20D
6BC09846-0CE6-11D1-BAAE-00C04FC2E20D
6BC09847-0CE6-11D1-BAAE-00C04FC2E20D
6BC09848-0CE6-11D1-BAAE-00C04FC2E20D
6BC09849-0CE6-11D1-BAAE-00C04FC2E20D
6BC0984A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0984B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0984C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0984D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0984E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0984F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09850-0CE6-11D1-BAAE-00C04FC2E20D
6BC09851-0CE6-11D1-BAAE-00C04FC2E20D
6BC09852-0CE6-11D1-BAAE-00C04FC2E20D
6BC09853-0CE6-11D1-BAAE-00C04FC2E20D
6BC09854-0CE6-11D1-BAAE-00C04FC2E20D
6BC09855-0CE6-11D1-BAAE-00C04FC2E20D
6BC09856-0CE6-11D1-BAAE-00C04FC2E20D
6BC09857-0CE6-11D1-BAAE-00C04FC2E20D
6BC09858-0CE6-11D1-BAAE-00C04FC2E20D
6BC09859-0CE6-11D1-BAAE-00C04FC2E20D
6BC0985A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0985B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0985C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0985D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0985E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0985F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09860-0CE6-11D1-BAAE-00C04FC2E20D
6BC09861-0CE6-11D1-BAAE-00C04FC2E20D
6BC09862-0CE6-11D1-BAAE-00C04FC2E20D
6BC09863-0CE6-11D1-BAAE-00C04FC2E20D
6BC09864-0CE6-11D1-BAAE-00C04FC2E20D
6BC09865-0CE6-11D1-BAAE-00C04FC2E20D
6BC09866-0CE6-11D1-BAAE-00C04FC2E20D
6BC09867-0CE6-11D1-BAAE-00C04FC2E20D
6BC09868-0CE6-11D1-BAAE-00C04FC2E20D
6BC09869-0CE6-11D1-BAAE-00C04FC2E20D
6BC0986A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0986B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0986C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0986D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0986E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0986F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09870-0CE6-11D1-BAAE-00C04FC2E20D
6BC09871-0CE6-11D1-BAAE-00C04FC2E20D
6BC09872-0CE6-11D1-BAAE-00C04FC2E20D
6BC09873-0CE6-11D1-BAAE-00C04FC2E20D
6BC09874-0CE6-11D1-BAAE-00C04FC2E20D
6BC09875-0CE6-11D1-BAAE-00C04FC2E20D
6BC09876-0CE6-11D1-BAAE-00C04FC2E20D
6BC09877-0CE6-11D1-BAAE-00C04FC2E20D
6BC09878-0CE6-11D1-BAAE-00C04FC2E20D
6BC09879-0CE6-11D1-BAAE-00C04FC2E20D
6BC0987A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0987B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0987C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0987D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0987E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0987F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09880-0CE6-11D1-BAAE-00C04FC2E20D
6BC09881-0CE6-11D1-BAAE-00C04FC2E20D
6BC09882-0CE6-11D1-BAAE-00C04FC2E20D
6BC09883-0CE6-11D1-BAAE-00C04FC2E20D
6BC09884-0CE6-11D1-BAAE-00C04FC2E20D
6BC09885-0CE6-11D1-BAAE-00C04FC2E20D
6BC09886-0CE6-11D1-BAAE-00C04FC2E20D
6BC09887-0CE6-11D1-BAAE-00C04FC2E20D
6BC09888-0CE6-11D1-BAAE-00C04FC2E20D
6BC09889-0CE6-11D1-BAAE-00C04FC2E20D
6BC0988A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0988B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0988C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0988D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0988E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0988F-0CE6-11D1-BAAE-00C04FC2E20D
--------------------------------------------------------------------------- */


/* ---------------------------------------------------------------------------

 Unused extension uuid's.

6BC098B0-0CE6-11D1-BAAE-00C04FC2E20D
6BC098B1-0CE6-11D1-BAAE-00C04FC2E20D
6BC098B2-0CE6-11D1-BAAE-00C04FC2E20D
6BC098B3-0CE6-11D1-BAAE-00C04FC2E20D
6BC098B4-0CE6-11D1-BAAE-00C04FC2E20D
6BC098B5-0CE6-11D1-BAAE-00C04FC2E20D
6BC098B6-0CE6-11D1-BAAE-00C04FC2E20D
6BC098B7-0CE6-11D1-BAAE-00C04FC2E20D
6BC098B8-0CE6-11D1-BAAE-00C04FC2E20D
6BC098B9-0CE6-11D1-BAAE-00C04FC2E20D
6BC098BA-0CE6-11D1-BAAE-00C04FC2E20D
6BC098BB-0CE6-11D1-BAAE-00C04FC2E20D
6BC098BC-0CE6-11D1-BAAE-00C04FC2E20D
6BC098BD-0CE6-11D1-BAAE-00C04FC2E20D
6BC098BE-0CE6-11D1-BAAE-00C04FC2E20D
6BC098BF-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C0-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C1-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C2-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C3-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C4-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C5-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C6-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C7-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C8-0CE6-11D1-BAAE-00C04FC2E20D
6BC098C9-0CE6-11D1-BAAE-00C04FC2E20D
6BC098CA-0CE6-11D1-BAAE-00C04FC2E20D
6BC098CB-0CE6-11D1-BAAE-00C04FC2E20D
6BC098CC-0CE6-11D1-BAAE-00C04FC2E20D
6BC098CD-0CE6-11D1-BAAE-00C04FC2E20D
6BC098CE-0CE6-11D1-BAAE-00C04FC2E20D
6BC098CF-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D0-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D1-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D2-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D3-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D4-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D5-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D6-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D7-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D8-0CE6-11D1-BAAE-00C04FC2E20D
6BC098D9-0CE6-11D1-BAAE-00C04FC2E20D
6BC098DA-0CE6-11D1-BAAE-00C04FC2E20D
6BC098DB-0CE6-11D1-BAAE-00C04FC2E20D
6BC098DC-0CE6-11D1-BAAE-00C04FC2E20D
6BC098DD-0CE6-11D1-BAAE-00C04FC2E20D
6BC098DE-0CE6-11D1-BAAE-00C04FC2E20D
6BC098DF-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E0-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E1-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E2-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E3-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E4-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E5-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E6-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E7-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E8-0CE6-11D1-BAAE-00C04FC2E20D
6BC098E9-0CE6-11D1-BAAE-00C04FC2E20D
6BC098EA-0CE6-11D1-BAAE-00C04FC2E20D
6BC098EB-0CE6-11D1-BAAE-00C04FC2E20D
6BC098EC-0CE6-11D1-BAAE-00C04FC2E20D
6BC098ED-0CE6-11D1-BAAE-00C04FC2E20D
6BC098EE-0CE6-11D1-BAAE-00C04FC2E20D
6BC098EF-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F0-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F1-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F2-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F3-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F4-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F5-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F6-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F7-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F8-0CE6-11D1-BAAE-00C04FC2E20D
6BC098F9-0CE6-11D1-BAAE-00C04FC2E20D
6BC098FA-0CE6-11D1-BAAE-00C04FC2E20D
6BC098FB-0CE6-11D1-BAAE-00C04FC2E20D
6BC098FC-0CE6-11D1-BAAE-00C04FC2E20D
6BC098FD-0CE6-11D1-BAAE-00C04FC2E20D
6BC098FE-0CE6-11D1-BAAE-00C04FC2E20D
6BC098FF-0CE6-11D1-BAAE-00C04FC2E20D
6BC09900-0CE6-11D1-BAAE-00C04FC2E20D
6BC09901-0CE6-11D1-BAAE-00C04FC2E20D
6BC09902-0CE6-11D1-BAAE-00C04FC2E20D
6BC09903-0CE6-11D1-BAAE-00C04FC2E20D
6BC09904-0CE6-11D1-BAAE-00C04FC2E20D
6BC09905-0CE6-11D1-BAAE-00C04FC2E20D
6BC09906-0CE6-11D1-BAAE-00C04FC2E20D
6BC09907-0CE6-11D1-BAAE-00C04FC2E20D
6BC09908-0CE6-11D1-BAAE-00C04FC2E20D
6BC09909-0CE6-11D1-BAAE-00C04FC2E20D
6BC0990A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0990B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0990C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0990D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0990E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0990F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09910-0CE6-11D1-BAAE-00C04FC2E20D
6BC09911-0CE6-11D1-BAAE-00C04FC2E20D
6BC09912-0CE6-11D1-BAAE-00C04FC2E20D
6BC09913-0CE6-11D1-BAAE-00C04FC2E20D
6BC09914-0CE6-11D1-BAAE-00C04FC2E20D
6BC09915-0CE6-11D1-BAAE-00C04FC2E20D
6BC09916-0CE6-11D1-BAAE-00C04FC2E20D
6BC09917-0CE6-11D1-BAAE-00C04FC2E20D
6BC09918-0CE6-11D1-BAAE-00C04FC2E20D
6BC09919-0CE6-11D1-BAAE-00C04FC2E20D
6BC0991A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0991B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0991C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0991D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0991E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0991F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09920-0CE6-11D1-BAAE-00C04FC2E20D
6BC09921-0CE6-11D1-BAAE-00C04FC2E20D
6BC09922-0CE6-11D1-BAAE-00C04FC2E20D
6BC09923-0CE6-11D1-BAAE-00C04FC2E20D
6BC09924-0CE6-11D1-BAAE-00C04FC2E20D
6BC09925-0CE6-11D1-BAAE-00C04FC2E20D
6BC09926-0CE6-11D1-BAAE-00C04FC2E20D
6BC09927-0CE6-11D1-BAAE-00C04FC2E20D
6BC09928-0CE6-11D1-BAAE-00C04FC2E20D
6BC09929-0CE6-11D1-BAAE-00C04FC2E20D
6BC0992A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0992B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0992C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0992D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0992E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0992F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09930-0CE6-11D1-BAAE-00C04FC2E20D
6BC09931-0CE6-11D1-BAAE-00C04FC2E20D
6BC09932-0CE6-11D1-BAAE-00C04FC2E20D
6BC09933-0CE6-11D1-BAAE-00C04FC2E20D
6BC09934-0CE6-11D1-BAAE-00C04FC2E20D
6BC09935-0CE6-11D1-BAAE-00C04FC2E20D
6BC09936-0CE6-11D1-BAAE-00C04FC2E20D
6BC09937-0CE6-11D1-BAAE-00C04FC2E20D
6BC09938-0CE6-11D1-BAAE-00C04FC2E20D
6BC09939-0CE6-11D1-BAAE-00C04FC2E20D
6BC0993A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0993B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0993C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0993D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0993E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0993F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09940-0CE6-11D1-BAAE-00C04FC2E20D
6BC09941-0CE6-11D1-BAAE-00C04FC2E20D
6BC09942-0CE6-11D1-BAAE-00C04FC2E20D
6BC09943-0CE6-11D1-BAAE-00C04FC2E20D
6BC09944-0CE6-11D1-BAAE-00C04FC2E20D
6BC09945-0CE6-11D1-BAAE-00C04FC2E20D
6BC09946-0CE6-11D1-BAAE-00C04FC2E20D
6BC09947-0CE6-11D1-BAAE-00C04FC2E20D
6BC09948-0CE6-11D1-BAAE-00C04FC2E20D
6BC09949-0CE6-11D1-BAAE-00C04FC2E20D
6BC0994A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0994B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0994C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0994D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0994E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0994F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09950-0CE6-11D1-BAAE-00C04FC2E20D
6BC09951-0CE6-11D1-BAAE-00C04FC2E20D
6BC09952-0CE6-11D1-BAAE-00C04FC2E20D
6BC09953-0CE6-11D1-BAAE-00C04FC2E20D
6BC09954-0CE6-11D1-BAAE-00C04FC2E20D
6BC09955-0CE6-11D1-BAAE-00C04FC2E20D
6BC09956-0CE6-11D1-BAAE-00C04FC2E20D
6BC09957-0CE6-11D1-BAAE-00C04FC2E20D
6BC09958-0CE6-11D1-BAAE-00C04FC2E20D
6BC09959-0CE6-11D1-BAAE-00C04FC2E20D
6BC0995A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0995B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0995C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0995D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0995E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0995F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09960-0CE6-11D1-BAAE-00C04FC2E20D
6BC09961-0CE6-11D1-BAAE-00C04FC2E20D
6BC09962-0CE6-11D1-BAAE-00C04FC2E20D
6BC09963-0CE6-11D1-BAAE-00C04FC2E20D
6BC09964-0CE6-11D1-BAAE-00C04FC2E20D
6BC09965-0CE6-11D1-BAAE-00C04FC2E20D
6BC09966-0CE6-11D1-BAAE-00C04FC2E20D
6BC09967-0CE6-11D1-BAAE-00C04FC2E20D
6BC09968-0CE6-11D1-BAAE-00C04FC2E20D
6BC09969-0CE6-11D1-BAAE-00C04FC2E20D
6BC0996A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0996B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0996C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0996D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0996E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0996F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09970-0CE6-11D1-BAAE-00C04FC2E20D
6BC09971-0CE6-11D1-BAAE-00C04FC2E20D
6BC09972-0CE6-11D1-BAAE-00C04FC2E20D
6BC09973-0CE6-11D1-BAAE-00C04FC2E20D
6BC09974-0CE6-11D1-BAAE-00C04FC2E20D
6BC09975-0CE6-11D1-BAAE-00C04FC2E20D
6BC09976-0CE6-11D1-BAAE-00C04FC2E20D
6BC09977-0CE6-11D1-BAAE-00C04FC2E20D
6BC09978-0CE6-11D1-BAAE-00C04FC2E20D
6BC09979-0CE6-11D1-BAAE-00C04FC2E20D
6BC0997A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0997B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0997C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0997D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0997E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0997F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09980-0CE6-11D1-BAAE-00C04FC2E20D
6BC09981-0CE6-11D1-BAAE-00C04FC2E20D
6BC09982-0CE6-11D1-BAAE-00C04FC2E20D
6BC09983-0CE6-11D1-BAAE-00C04FC2E20D
6BC09984-0CE6-11D1-BAAE-00C04FC2E20D
6BC09985-0CE6-11D1-BAAE-00C04FC2E20D
6BC09986-0CE6-11D1-BAAE-00C04FC2E20D
6BC09987-0CE6-11D1-BAAE-00C04FC2E20D
6BC09988-0CE6-11D1-BAAE-00C04FC2E20D
6BC09989-0CE6-11D1-BAAE-00C04FC2E20D
6BC0998A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0998B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0998C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0998D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0998E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0998F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09990-0CE6-11D1-BAAE-00C04FC2E20D
6BC09991-0CE6-11D1-BAAE-00C04FC2E20D
6BC09992-0CE6-11D1-BAAE-00C04FC2E20D
6BC09993-0CE6-11D1-BAAE-00C04FC2E20D
6BC09994-0CE6-11D1-BAAE-00C04FC2E20D
6BC09995-0CE6-11D1-BAAE-00C04FC2E20D
6BC09996-0CE6-11D1-BAAE-00C04FC2E20D
6BC09997-0CE6-11D1-BAAE-00C04FC2E20D
6BC09998-0CE6-11D1-BAAE-00C04FC2E20D
6BC09999-0CE6-11D1-BAAE-00C04FC2E20D
6BC0999A-0CE6-11D1-BAAE-00C04FC2E20D
6BC0999B-0CE6-11D1-BAAE-00C04FC2E20D
6BC0999C-0CE6-11D1-BAAE-00C04FC2E20D
6BC0999D-0CE6-11D1-BAAE-00C04FC2E20D
6BC0999E-0CE6-11D1-BAAE-00C04FC2E20D
6BC0999F-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A0-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A1-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A2-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A3-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A4-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A5-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A6-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A7-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A8-0CE6-11D1-BAAE-00C04FC2E20D
6BC099A9-0CE6-11D1-BAAE-00C04FC2E20D
6BC099AA-0CE6-11D1-BAAE-00C04FC2E20D
6BC099AB-0CE6-11D1-BAAE-00C04FC2E20D
6BC099AC-0CE6-11D1-BAAE-00C04FC2E20D
6BC099AD-0CE6-11D1-BAAE-00C04FC2E20D
6BC099AE-0CE6-11D1-BAAE-00C04FC2E20D
6BC099AF-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B0-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B1-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B2-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B3-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B4-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B5-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B6-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B7-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B8-0CE6-11D1-BAAE-00C04FC2E20D
6BC099B9-0CE6-11D1-BAAE-00C04FC2E20D
6BC099BA-0CE6-11D1-BAAE-00C04FC2E20D
6BC099BB-0CE6-11D1-BAAE-00C04FC2E20D
6BC099BC-0CE6-11D1-BAAE-00C04FC2E20D
6BC099BD-0CE6-11D1-BAAE-00C04FC2E20D
6BC099BE-0CE6-11D1-BAAE-00C04FC2E20D
6BC099BF-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C0-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C1-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C2-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C3-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C4-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C5-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C6-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C7-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C8-0CE6-11D1-BAAE-00C04FC2E20D
6BC099C9-0CE6-11D1-BAAE-00C04FC2E20D
6BC099CA-0CE6-11D1-BAAE-00C04FC2E20D
6BC099CB-0CE6-11D1-BAAE-00C04FC2E20D
6BC099CC-0CE6-11D1-BAAE-00C04FC2E20D
6BC099CD-0CE6-11D1-BAAE-00C04FC2E20D
6BC099CE-0CE6-11D1-BAAE-00C04FC2E20D
6BC099CF-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D0-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D1-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D2-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D3-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D4-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D5-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D6-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D7-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D8-0CE6-11D1-BAAE-00C04FC2E20D
6BC099D9-0CE6-11D1-BAAE-00C04FC2E20D
6BC099DA-0CE6-11D1-BAAE-00C04FC2E20D
6BC099DB-0CE6-11D1-BAAE-00C04FC2E20D
6BC099DC-0CE6-11D1-BAAE-00C04FC2E20D
6BC099DD-0CE6-11D1-BAAE-00C04FC2E20D
6BC099DE-0CE6-11D1-BAAE-00C04FC2E20D
6BC099DF-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E0-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E1-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E2-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E3-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E4-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E5-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E6-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E7-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E8-0CE6-11D1-BAAE-00C04FC2E20D
6BC099E9-0CE6-11D1-BAAE-00C04FC2E20D
6BC099EA-0CE6-11D1-BAAE-00C04FC2E20D
6BC099EB-0CE6-11D1-BAAE-00C04FC2E20D
6BC099EC-0CE6-11D1-BAAE-00C04FC2E20D
6BC099ED-0CE6-11D1-BAAE-00C04FC2E20D
6BC099EE-0CE6-11D1-BAAE-00C04FC2E20D
6BC099EF-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F0-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F1-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F2-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F3-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F4-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F5-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F6-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F7-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F8-0CE6-11D1-BAAE-00C04FC2E20D
6BC099F9-0CE6-11D1-BAAE-00C04FC2E20D
6BC099FA-0CE6-11D1-BAAE-00C04FC2E20D
6BC099FB-0CE6-11D1-BAAE-00C04FC2E20D
6BC099FC-0CE6-11D1-BAAE-00C04FC2E20D
6BC099FD-0CE6-11D1-BAAE-00C04FC2E20D
6BC099FE-0CE6-11D1-BAAE-00C04FC2E20D
6BC099FF-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A00-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A01-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A02-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A03-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A04-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A05-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A06-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A07-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A08-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A09-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A0A-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A0B-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A0C-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A0D-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A0E-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A0F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A10-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A11-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A12-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A13-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A14-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A15-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A16-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A17-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A18-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A19-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A1A-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A1B-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A1C-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A1D-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A1E-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A1F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A20-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A21-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A22-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A23-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A24-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A25-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A26-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A27-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A28-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A29-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A2A-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A2B-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A2C-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A2D-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A2E-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A2F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A30-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A31-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A32-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A33-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A34-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A35-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A36-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A37-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A38-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A39-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A3A-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A3B-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A3C-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A3D-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A3E-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A3F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A40-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A41-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A42-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A43-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A44-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A45-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A46-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A47-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A48-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A49-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A4A-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A4B-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A4C-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A4D-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A4E-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A4F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A50-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A51-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A52-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A53-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A54-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A55-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A56-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A57-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A58-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A59-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A5A-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A5B-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A5C-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A5D-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A5E-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A5F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A60-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A61-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A62-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A63-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A64-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A65-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A66-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A67-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A68-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A69-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A6A-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A6B-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A6C-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A6D-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A6E-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A6F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A70-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A71-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A72-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A73-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A74-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A75-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A76-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A77-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A78-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A79-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A7A-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A7B-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A7C-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A7D-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A7E-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A7F-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A80-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A81-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A82-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A83-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A84-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A85-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A86-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A87-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A88-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A89-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A8A-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A8B-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A8C-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A8D-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A8E-0CE6-11D1-BAAE-00C04FC2E20D
6BC09A8F-0CE6-11D1-BAAE-00C04FC2E20D

---------------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\iastrace.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iastrace.h
//
// SYNOPSIS
//
//    Declares the API into the IAS trace facility.
//
// MODIFICATION HISTORY
//
//    08/18/1998    Original version.
//    10/06/1998    Trace is always on.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASTRACE_H_
#define _IASTRACE_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

DWORD
WINAPI
IASFormatSysErr(
    IN DWORD dwError,
    IN PSTR lpBuffer,
    IN DWORD nSize
    );

VOID
WINAPIV
IASTracePrintf(
    IN PCSTR szFormat,
    ...
    );

VOID
WINAPI
IASTraceString(
    IN PCSTR szString
    );

VOID
WINAPI
IASTraceBinary(
    IN CONST BYTE* lpbBytes,
    IN DWORD dwByteCount
    );

VOID
WINAPI
IASTraceFailure(
    IN PCSTR szFunction,
    IN DWORD dwError
    );

//////////
// This can only be called from inside a C++ catch block. If you call it
// anywhere else you will probably crash the process.
//////////
VOID
WINAPI
IASTraceExcept( VOID );

#ifdef __cplusplus
}
#endif
#endif  // _IASTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\newop.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    newop.cpp
//
// SYNOPSIS
//
//    Implmentation of the global new and delete operators.
//
// MODIFICATION HISTORY
//
//    08/19/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NEWOP_CPP_
#define _NEWOP_CPP_

#include <cstdlib>
#include <new>

//////////
// CRT function that calls the new handler directly.
//////////
extern "C" int __cdecl _callnewh(size_t);


//////////
// Standard new operator.
//////////
void* __cdecl operator new(size_t size) throw (std::bad_alloc)
{
   void* p;

   // Loop until either we get the memory or the new handler fails.
   while ((p = malloc(size)) == 0)
   {
      if (!_callnewh(size))
      {
         throw std::bad_alloc();
      }
   }

   return p;
}

   
//////////
// "No throw" version of the new operator.
//////////
void* __cdecl operator new(size_t size, const std::nothrow_t&) throw ()
{
   void* p;

   // Loop until either we get the memory or the new handler fails.
   while ((p = malloc(size)) == 0)
   {
      if (!_callnewh(size))
      {
         return 0;
      }
   }

   return p;
}


//////////
// Delete operator.
//////////
void __cdecl operator delete(void *p) throw()
{
#ifdef DEBUG
   // Clobber the memory.
   if (p) memset(p, 0xA3, _msize(p));
#endif

   // The MSVC free() handles null pointers, so we don't have to check.
   free(p);
}


#endif  // _NEWOP_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\sources.inc ===
TARGETNAME=ias
TARGETPATH=
TARGETTYPE=NOTARGET

SOURCES=

NTTARGETFILES=\
!if "$(ALT_PROJECT_TARGET)"=="" 
    $(O)\dnary.mdb \
!endif
    $(O)\ias.mdb

MISCFILES=\
!if "$(ALT_PROJECT_TARGET)"=="" 
    $(O)\dnary.mdb \
!endif
    $(O)\ias.mdb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\inc\vendors.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Vendors.cpp

Abstract:

	Implementation file for NAS Vendor ID info.

	This will be moved into the SDO's at some point so that the server core 
	can access this information as well.


Author:

    Michael A. Maguire 02/19/98

Revision History:
	mmaguire 02/19/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined( _IAS_VENDORS_H_ )
#define _IAS_VENDORS_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

// The structure which has the vendors.
typedef
struct tag_Vendor
{
	DWORD dwID;
	TCHAR * szName;
} Vendor;


// The array of Vendor structures.
extern Vendor g_aVendors[];
extern int	  g_iVendorNum;

// invalid vendorid
#define INVALID_VENDORID	-1


// Searches for a given vendor ID and returns its position in the array of vendors.
int VendorIDToOrdinal( DWORD dwID );



#endif // _IAS_VENDORS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\ara\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\makefile.inc ===
#
# makefile for the IAS dictionary file dnary.mdb and also ias.mdb
# that file is generated from empty databases
# templias.mdb, templdnary.mdb and localized inf files
# iasdump.inf, dnarydump.inf
# iasinfdb.exe (from mstools) populates the database
#


$(O)\ias.mdb: ..\templias.mdb .\iasdump.inf
    -mkdir .\$(O)
    -iasinfdb.exe $** $@

!if "$(ALT_PROJECT_TARGET)"=="" 
$(O)\dnary.mdb: ..\templdnary.mdb .\dnarydump.inf
    -mkdir .\$(O)
    -iasinfdb.exe $** $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\en\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\es\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\fi\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\cs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\chs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\cht\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\da\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\fr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\el\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\heb\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\ger\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\hu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\br\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\it\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\nl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\jpn\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\kor\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\no\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\psu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\ru\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\pl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\pt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\sv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\tr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\misc\usa\makefile.inc ===
#
# makefile for the IAS dictionary file dnary.mdb and also ias.mdb
# that file is generated from empty databases
# templias.mdb, templdnary.mdb and localized inf files
# iasdump.inf, dnarydump.inf
# iasinfdb.exe (from mstools) populates the database
#

!if !exist($(O))
!if [mkdir $(O)]
!endif
!endif

$(O)\ias.mdb: ..\templias.mdb .\iasdump.inf
    iasinfdb.exe $** $@

$(O)\dnary.mdb: ..\templdnary.mdb .\dnarydump.inf
    iasinfdb.exe $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\atl25\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation, 1996 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#include <mmc.h>
#include <commctrl.h>
#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")

// MAM things which haven't made it into real atlsnap.h yet.
#define TASKPAD_SUPPORT
#define FIX_PROBLEM_WITH_PROPERTY_CHANGE_NOTIFICATION_HANDLES
#define FIX_PROBLEM_WITH_DYNAMIC_CAST_ON_CSNAPINOBJECTROOT_NOT_WORKING
#define FIX_PROBLEM_WITH_GET_RESULT_VIEW_TYPE_NULL_COOKIE

template <class T, bool bAutoDelete = TRUE>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
   PROPSHEETPAGE m_psp;


#ifdef FIX_PROBLEM_WITH_PROPERTY_CHANGE_NOTIFICATION_HANDLES
   LONG_PTR m_hNotificationHandle;
   BOOL        m_bOwnsNotificationHandle;
#endif FIX_PROBLEM_WITH_PROPERTY_CHANGE_NOTIFICATION_HANDLES


   operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
#ifdef FIX_PROBLEM_WITH_PROPERTY_CHANGE_NOTIFICATION_HANDLES
   CSnapInPropertyPageImpl(LONG_PTR hNotificationHandle, LPCTSTR lpszTitle = NULL, BOOL bOwnsNotificationHandle = FALSE)
#else
   CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
#endif // FIX_PROBLEM_WITH_PROPERTY_CHANGE_NOTIFICATION_HANDLES
   {
      // initialize PROPSHEETPAGE struct
      memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
      m_psp.dwSize = sizeof(PROPSHEETPAGE);
      m_psp.dwFlags = PSP_USECALLBACK;
      m_psp.hInstance = _Module.GetResourceInstance();
      m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
      m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
      m_psp.pfnCallback = T::PropPageCallback;
      m_psp.lParam = (LPARAM)this;

      if(lpszTitle != NULL)
      {
         m_psp.pszTitle = lpszTitle;
         m_psp.dwFlags |= PSP_USETITLE;
      }

#ifdef FIX_PROBLEM_WITH_PROPERTY_CHANGE_NOTIFICATION_HANDLES
      m_hNotificationHandle = hNotificationHandle;
      m_bOwnsNotificationHandle = bOwnsNotificationHandle;
#endif //FIX_PROBLEM_WITH_PROPERTY_CHANGE_NOTIFICATION_HANDLES


   }


   void  SetTitles(LPCWSTR szTitle, LPCWSTR szSubtitle)
   {
      m_psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

      m_psp.pszHeaderTitle = szTitle;
      m_psp.pszHeaderSubTitle = szSubtitle;
   };


#ifdef FIX_PROBLEM_WITH_PROPERTY_CHANGE_NOTIFICATION_HANDLES
   ~CSnapInPropertyPageImpl()
   {
      if( m_bOwnsNotificationHandle )
      {
         // The MMC docs specify that this handle should only be freed once.
         // For this reason, we have the bOwnsNotificationHandle flag which
         // should only be set for one property page.
         // We only free the handle in the destructor of the page
         // that has been designated as the "owner".
         MMCFreeNotifyHandle( m_hNotificationHandle );
      }

   }



   HRESULT PropertyChangeNotify( LPARAM param )
   {
      return MMCPropertyChangeNotify( m_hNotificationHandle, param );
   }
   

#endif //FIX_PROBLEM_WITH_PROPERTY_CHANGE_NOTIFICATION_HANDLES


   static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
   {
      ATLASSERT(hWnd == NULL);
      if(uMsg == PSPCB_CREATE)
      {
         CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
         _Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
      }
      if (bAutoDelete && uMsg == PSPCB_RELEASE)
      {
         T* pPage = (T*)ppsp->lParam;
         delete pPage;
      }

      return 1;
   }

   HPROPSHEETPAGE Create()
   {
      return ::CreatePropertySheetPage(&m_psp);
   }

   BOOL EndDialog(int)
   {
      // do nothing here, calling ::EndDialog will close the whole sheet
      ATLASSERT(FALSE);
      return FALSE;
   }

// Operations
   void CancelToClose()
   {
      ATLASSERT(::IsWindow(m_hWnd));
      ATLASSERT(GetParent() != NULL);

      ::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
   }
   void SetModified(BOOL bChanged = TRUE)
   {
      ATLASSERT(::IsWindow(m_hWnd));
      ATLASSERT(GetParent() != NULL);

      if(bChanged)
         ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
      else
         ::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
   }
   LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
   {
      ATLASSERT(::IsWindow(m_hWnd));
      ATLASSERT(GetParent() != NULL);

      return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
   }

   BEGIN_MSG_MAP(CSnapInPropertyPageImpl< T >)
      MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
   END_MSG_MAP()

// Message handler
   LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
   {
      ATLASSERT(::IsWindow(m_hWnd));
      NMHDR* pNMHDR = (NMHDR*)lParam;

      // don't handle messages not from the page/sheet itself
      if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
      {
         bHandled = FALSE;
         return 1;
      }

      T* pT = (T*)this;
      LRESULT lResult = 0;
      // handle default
      switch(pNMHDR->code)
      {
      case PSN_SETACTIVE:
         lResult = pT->OnSetActive() ? 0 : -1;
         break;
      case PSN_KILLACTIVE:
         lResult = !pT->OnKillActive();
         break;
      case PSN_APPLY:
         lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
         break;
      case PSN_RESET:
         pT->OnReset();
         break;
      case PSN_QUERYCANCEL:
         lResult = !pT->OnQueryCancel();
         break;
      case PSN_WIZNEXT:
         // changed, since the orginal one doesn't work when jump to a different page
         {
            LRESULT  l = pT->OnWizardNext(); 

            switch(l)
            {
            case  TRUE:
               lResult = 0;
               break;
            case  FALSE:
               lResult = -1;
               break;
            default:
               lResult = l;
               break;
            }
         }
         break;
      case PSN_WIZBACK:
         // changed, since the orginal one doesn't work when jump to a different page
         {
            LRESULT  l = pT->OnWizardBack(); 

            switch(l)
            {
            case  TRUE:
               lResult = 0;
               break;
            case  FALSE:
               lResult = -1;
               break;
            default:
               lResult = l;
               break;
            }
         }
         break;
      case PSN_WIZFINISH:
         lResult = !pT->OnWizardFinish();
         break;
      case PSN_HELP:
         lResult = pT->OnHelp();
         break;
      default:
         bHandled = FALSE; // not handled
      }

      return lResult;
   }

// Overridables
   BOOL OnSetActive()
   {
      return TRUE;
   }
   BOOL OnKillActive()
   {
      return TRUE;
   }
   BOOL OnApply()
   {
      return TRUE;
   }
   void OnReset()
   {
   }
   BOOL OnQueryCancel()
   {
      return TRUE;    // ok to cancel
   }
   BOOL OnWizardBack()
   {
      return TRUE;
   }
   BOOL OnWizardNext()
   {
      return TRUE;
   }
   BOOL OnWizardFinish()
   {
      return TRUE;
   }
   BOOL OnHelp()
   {
      return TRUE;
   }
};

#if _ATL_VER < 0x0300
// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
   TKey* m_aKey;
   TVal* m_aVal;
   int m_nSize;

// Construction/destruction
   CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
   { }

   ~CSimpleMap()
   {
      RemoveAll();
   }

// Operations
   int GetSize() const
   {
      return m_nSize;
   }
   BOOL Add(TKey key, TVal val)
   {
      TKey* pKey;
      pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
      if(pKey == NULL)
         return FALSE;
      m_aKey = pKey;
      TVal* pVal;
      pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
      if(pVal == NULL)
         return FALSE;
      m_aVal = pVal;
      m_nSize++;
      SetAtIndex(m_nSize - 1, key, val);
      return TRUE;
   }
   BOOL Remove(TKey key)
   {
      int nIndex = FindKey(key);
      if(nIndex == -1)
         return FALSE;
      if(nIndex != (m_nSize - 1))
      {
         memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
         memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
      }
      TKey* pKey;
      pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
      if(pKey != NULL || m_nSize == 1)
         m_aKey = pKey;
      TVal* pVal;
      pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
      if(pVal != NULL || m_nSize == 1)
         m_aVal = pVal;
      m_nSize--;
      return TRUE;
   }
   void RemoveAll()
   {
      if(m_nSize > 0)
      {
         free(m_aKey);
         free(m_aVal);
         m_aKey = NULL;
         m_aVal = NULL;
         m_nSize = 0;
      }
   }
   BOOL SetAt(TKey key, TVal val)
   {
      int nIndex = FindKey(key);
      if(nIndex == -1)
         return FALSE;
      SetAtIndex(nIndex, key, val);
      return TRUE;
   }
   TVal Lookup(TKey key) const
   {
      int nIndex = FindKey(key);
      if(nIndex == -1)
         return NULL;   // must be able to convert
      return GetValueAt(nIndex);
   }
   TKey ReverseLookup(TVal val) const
   {
      int nIndex = FindVal(val);
      if(nIndex == -1)
         return NULL;   // must be able to convert
      return GetKeyAt(nIndex);
   }
   TKey& GetKeyAt(int nIndex) const
   {
      ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
      return m_aKey[nIndex];
   }
   TVal& GetValueAt(int nIndex) const
   {
      ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
      return m_aVal[nIndex];
   }

// Implementation
   void SetAtIndex(int nIndex, TKey& key, TVal& val)
   {
      ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
      m_aKey[nIndex] = key;
      m_aVal[nIndex] = val;
   }
   int FindKey(TKey& key) const
   {
      for(int i = 0; i < m_nSize; i++)
      {
         if(m_aKey[i] == key)
            return i;
      }
      return -1;  // not found
   }
   int FindVal(TVal& val) const
   {
      for(int i = 0; i < m_nSize; i++)
      {
         if(m_aVal[i] == val)
            return i;
      }
      return -1;  // not found
   }
};
#endif


class CSnapInItem;
class CSnapInObjectRootBase;

class CObjectData
{
public:
   CSnapInItem* m_pItem;
   DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem 
{
public:
   CSnapInItem(unsigned int helpIndex = 0)
      :m_helpIndex(helpIndex)
   {
   }

   virtual ~CSnapInItem()
   {
   }
   STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
      LPARAM arg,
      LPARAM param,
      IComponentData* pComponentData,
      IComponent* pComponent,
      DATA_OBJECT_TYPES type) = 0;
    
   STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;

   STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
      long  *pViewOptions) = 0;
    
   STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
   STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
      long  *pInsertionAllowed,
      DATA_OBJECT_TYPES type) = 0;
    
   STDMETHOD(Command)(long lCommandID,    
      CSnapInObjectRootBase* pObj,     
      DATA_OBJECT_TYPES type) = 0;
    
   STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
      LONG_PTR handle,
      IUnknown* pUnk,
      DATA_OBJECT_TYPES type) = 0;
    
   STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;
    
   STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
      IExtendControlbar  *pExtendControlbar,
      CSimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;
    
   STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
      IExtendControlbar  *pExtendControlbar,
      CSimpleMap<UINT, IUnknown*>* pToolbarMap,
      MMC_NOTIFY_TYPE event,
      LPARAM arg,
      LPARAM param,
      CSnapInObjectRootBase* pObj,
      DATA_OBJECT_TYPES type) = 0;
    
   STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
   STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

   STDMETHOD(FillData)(CLIPFORMAT cf, 
      LPSTREAM pStream) = 0;

   virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
   {
      _ASSERTE(0 && "Override this function in derived class");
   }

   static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
   {
      if (ppItem == NULL)
         return E_POINTER;
      if (pType == NULL)
         return E_POINTER;

      *ppItem = NULL;
      *pType = CCT_UNINITIALIZED;

      STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
      FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA, 
         NULL, 
         DVASPECT_CONTENT, 
         -1, 
         TYMED_HGLOBAL 
      };

      stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
      if (stgmedium.hGlobal == NULL)
         return E_OUTOFMEMORY;

      HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
      if (SUCCEEDED(hr))
      {
         CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
          *ppItem = pData->m_pItem;
          *pType = pData->m_type;
      }
      
      GlobalFree(stgmedium.hGlobal);
      
      return hr;
   }

#ifdef TASKPAD_SUPPORT
   STDMETHOD(TaskNotify)(
              IDataObject * pDataObject
            , VARIANT * pvarg
            , VARIANT * pvparam
            ) = 0;

   STDMETHOD(EnumTasks)(
              IDataObject * pDataObject
            , BSTR szTaskGroup
            , IEnumTASK** ppEnumTASK
            ) = 0;
#endif // TASKPAD_SUPPORT

   virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

   static void Init()
   {
      m_CCF_NODETYPE       = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
      m_CCF_SZNODETYPE     = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));  
      m_CCF_DISPLAY_NAME      = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME")); 
      m_CCF_SNAPIN_CLASSID = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
      m_CCF_SNAPIN_GETOBJECTDATA = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
      m_CCF_MMC_MULTISELECT_DATAOBJECT = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_MULTISELECT_DATAOBJECT"));
   }

public:
   static CLIPFORMAT m_CCF_NODETYPE;
   static CLIPFORMAT m_CCF_SZNODETYPE;
   static CLIPFORMAT m_CCF_DISPLAY_NAME;
   static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
   static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
   static CLIPFORMAT m_CCF_MMC_MULTISELECT_DATAOBJECT;

   // IAS: Added to store some information about which help file to use
   unsigned int m_helpIndex;
};

class CSnapInObjectRootBase
{
public:
   CComPtr <IControlbar> m_spControlbar;
   CSimpleMap <UINT, IUnknown*> m_toolbarMap;
   const int m_ntype;

   CSnapInObjectRootBase(int n = 0) : m_ntype(n)
   {
   }
   HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
   {
      return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
   }

#ifdef FIX_PROBLEM_WITH_DYNAMIC_CAST_ON_CSNAPINOBJECTROOT_NOT_WORKING
   // Need at least one virtual method, or compiler does not generate a vtable
   virtual ~CSnapInObjectRootBase()
   {
   }
#endif FIX_PROBLEM_WITH_DYNAMIC_CAST_ON_CSNAPINOBJECTROOT_NOT_WORKING


};

template <int n, class ComponentData>
class CSnapInObjectRoot : public CSnapInObjectRootBase
{
public :
   CSnapInObjectRoot() : CSnapInObjectRootBase(n)
   {
      m_pComponentData = NULL;
   }
   ComponentData* m_pComponentData;
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
   HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
   { \
      if (ppItem == NULL) \
         return E_POINTER; \
      if (pType == NULL) \
         return E_POINTER; \
\
      *ppItem = NULL; \
\
      *pType = CCT_UNINITIALIZED; \
\
      STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
      FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, \
         NULL, \
         DVASPECT_CONTENT, \
         -1, \
         TYMED_HGLOBAL \
      }; \
\
      stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
      if (stgmedium.hGlobal == NULL) \
         return E_OUTOFMEMORY; \
\
      HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
      if (FAILED(hr)) \
      { \
         GlobalFree(stgmedium.hGlobal); \
         return hr; \
      } \
\
      GUID guid; \
      memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
      GlobalFree(stgmedium.hGlobal); \
      hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
      if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
      { \
         *ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
         _ASSERTE(*ppItem != NULL); \
         (*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
         return hr; \
      }

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
         return CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
   };

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
   public CComObjectRoot
{
public:
   BEGIN_COM_MAP(CSnapInDataObjectImpl)
      COM_INTERFACE_ENTRY(IDataObject)
   END_COM_MAP()
   STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
   }

   STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
   {
      ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
      if (pmedium == NULL)
         return E_POINTER;

      HRESULT hr = DV_E_TYMED;
      // Make sure the type medium is HGLOBAL
      if (pmedium->tymed == TYMED_HGLOBAL)
      {
         // Create the stream on the hGlobal passed in
         CComPtr<IStream> spStream;
         hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
         if (SUCCEEDED(hr))
            if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
            {
               hr = DV_E_CLIPFORMAT;
               ULONG uWritten;
               hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
            }
            else
               hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
      }
      return hr;
   }

   STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
   }
   STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
   }
   STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
   }
   STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
   }
   STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
      DWORD *pdwConnection)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
   }
   STDMETHOD(DUnadvise)(DWORD dwConnection)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
   }
   STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
   }

   CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
   IComponentDataImpl()
   {
      m_pNode = NULL;
   }

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
   {
      ATLTRACE(_T("IComponentDataImpl::Initialize\n"));

      HRESULT hr = E_POINTER;

      ATLASSERT(pUnknown != NULL);
      if (pUnknown == NULL)
         ATLTRACE(_T("IComponentData::Initialize called with pUnknown == NULL\n"));
      else
      {
         hr = pUnknown->QueryInterface(IID_IConsole, (void**)&m_spConsole);
         if (FAILED(hr))
            ATLTRACE(_T("QI for IConsole failed\n"));
      }

      return hr;
   }

   STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
   {
      ATLTRACE(_T("IComponentDataImpl::CreateComponent\n"));

      HRESULT hr = E_POINTER;

      ATLASSERT(ppComponent != NULL);
      if (ppComponent == NULL)
         ATLTRACE(_T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
      else
      {
         *ppComponent = NULL;
         
         CComObject< Component >* pComponent;
         hr = CComObject< Component >::CreateInstance(&pComponent);
         ATLASSERT(SUCCEEDED(hr));
         if (FAILED(hr))
            ATLTRACE(_T("IComponentData::CreateComponent : Could not create IComponent object\n"));
         else
         {
            pComponent->m_pComponentData = static_cast<T*>(this);
            hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
         }
      }
      return hr;
   }

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
   {
      ATLTRACE(_T("IComponentDataImpl::Notify\n"));

      HRESULT hr = E_POINTER;

      ATLASSERT(lpDataObject != NULL);
      if (lpDataObject == NULL)
         ATLTRACE(_T("IComponentData::Notify called with lpDataObject == NULL\n"));
      else
      {
         T* pT = static_cast<T*>(this);
         CSnapInItem* pItem;
         DATA_OBJECT_TYPES type;
         hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
         ATLASSERT(SUCCEEDED(hr));
         if (SUCCEEDED(hr))
            hr = pItem->Notify(event, arg, param, pT, NULL, type);
      }
      return hr;
   }

    STDMETHOD(Destroy)(void)
   {
      ATLTRACE(_T("IComponentDataImpl::Destroy\n"));

      T* pT = static_cast<T*>(this);
      if (pT->m_spControlbar != NULL)
      {
         int n = pT->m_toolbarMap.GetSize();
         for (int i = 0; i < n; i++)
         {
            IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
             if (pToolbar != NULL)
             {
               pT->m_spControlbar->Detach(pToolbar);
               pToolbar->Release();
             }
         }
      }
      pT->m_toolbarMap.RemoveAll();

      m_spConsole.Release();
      return S_OK;
   }

    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
   {
      ATLTRACE(_T("IComponentDataImpl::QueryDataObject\n"));
      HRESULT hr = E_POINTER;
      
      ATLASSERT(ppDataObject != NULL);
      if (ppDataObject == NULL)
         ATLTRACE(_T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
      else
      {
         *ppDataObject = NULL;
         
         CSnapInItem* pItem = (CSnapInItem*) cookie;
         if (cookie == NULL)
            pItem = m_pNode;

         hr = pItem->GetDataObject(ppDataObject, type);
      }
      return hr;
   }
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
   {
      ATLTRACE(_T("IComponentDataImpl::GetDisplayInfo\n"));


      HRESULT hr = E_POINTER;
      
      ATLASSERT(pScopeDataItem != NULL);
      if (pScopeDataItem == NULL)
         ATLTRACE(_T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
      else
      {
         CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
         if (pItem == NULL)
            pItem = m_pNode;

         hr = E_UNEXPECTED;
         if (pItem != NULL)
            hr = pItem->GetScopePaneInfo(pScopeDataItem);
      }
      return hr;
   }
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
   {
      ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

   CComPtr<IConsole> m_spConsole;
   CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
   {
      ATLTRACE(_T("IComponentImpl::Initialize\n"));

      HRESULT hr = E_POINTER;

      ATLASSERT(lpConsole != NULL);
      if (lpConsole == NULL)
         ATLTRACE(_T("lpConsole is NULL\n"));
      else
      {
         m_spConsole = lpConsole;
   
         CComPtr<IHeaderCtrl> spHeaderCtrl;
         hr = m_spConsole->QueryInterface(IID_IHeaderCtrl, (void**)&spHeaderCtrl);
         if (FAILED(hr))
            ATLTRACE(_T("QI for IHeaderCtrl failed\n"));
         else
         {
            hr = m_spConsole->SetHeader(spHeaderCtrl);
            if (FAILED(hr))
               ATLTRACE(_T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
         }
      }
      return hr;
   }
    
   STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);
    
    STDMETHOD(Destroy)(MMC_COOKIE cookie)
   {
      ATLTRACE(_T("IComponentImpl::Destroy\n"));

      T* pT = static_cast<T*>(this);

      if (pT->m_spControlbar != NULL)
      {
         int n = pT->m_toolbarMap.GetSize();
         for (int i = 0; i < n; i++)
         {
            IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
             if (pToolbar != NULL)
             {
               pT->m_spControlbar->Detach(pToolbar);
               pToolbar->Release();
             }
         }
      }
      pT->m_toolbarMap.RemoveAll();

      m_spConsole->SetHeader(NULL);
      m_spConsole.Release();
      return S_OK;
   }
    
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
   {
      ATLTRACE(_T("IComponentImpl::QueryDataObject\n"));

      ATLASSERT(ppDataObject != NULL);
      if (ppDataObject == NULL)
      {
         ATLTRACE(_T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
         return E_POINTER;
      }
      
      if (cookie == NULL)
      {
         ATLTRACE(_T("IComponent::QueryDataObject called with cookie==NULL \n"));
         return E_UNEXPECTED;
      }

      *ppDataObject = NULL;
      if (cookie == MMC_MULTI_SELECT_COOKIE)
      {
         ATLTRACE(_T("Override QueryDataObject to handle multiselect\n"));
         return E_UNEXPECTED;
      }

      CSnapInItem* pItem = (CSnapInItem*) cookie;
      return pItem->GetDataObject(ppDataObject, type);
   }
    
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions)
   {
      ATLTRACE(_T("IComponentImpl::GetResultViewType\n"));

      if (cookie == NULL)
      {

#ifdef FIX_PROBLEM_WITH_GET_RESULT_VIEW_TYPE_NULL_COOKIE
         T* pT = static_cast<T*>(this);

         // We are being asked about our root node.
         _ASSERTE( pT->m_pComponentData!= NULL );
         _ASSERTE( pT->m_pComponentData->m_pNode != NULL );
         return pT->m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
   
#else // FIX_PROBLEM_WITH_GET_RESULT_VIEW_TYPE_NULL_COOKIE
         
         
         *ppViewType = NULL;
         *pViewOptions = MMC_VIEW_OPTIONS_NONE;
         return S_FALSE;
#endif //FIX_PROBLEM_WITH_GET_RESULT_VIEW_TYPE_NULL_COOKIE

      
      }
      

      CSnapInItem* pItem = (CSnapInItem*)cookie;
      return pItem->GetResultViewType(ppViewType, pViewOptions);
   }
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
   {
      ATLTRACE(_T("IComponentImpl::GetDisplayInfo\n"));

      ATLASSERT(pResultDataItem != NULL);
      if (pResultDataItem == NULL)
      {
         ATLTRACE(_T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
         return E_POINTER;
      }

      CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

      if (pItem == NULL)
      {
         ATLTRACE(_T("Invalid Item\n"));
         return E_UNEXPECTED;
      }
      return pItem->GetResultPaneInfo(pResultDataItem);
   }
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
   {
      ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
   }

   CComPtr<IConsole> m_spConsole;
};

template <class T>
HRESULT IComponentImpl<T>::Notify(LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param)
{
   ATLTRACE(_T("IComponentImpl::Notify\n"));
   HRESULT hr = E_POINTER;
   
   ATLASSERT(lpDataObject != NULL);
   if (lpDataObject == NULL)
      ATLTRACE(_T("IComponent::Notify called with lpDataObject==NULL \n"));
   else
   {
      T* pT = static_cast<T*>(this);
      CSnapInItem* pItem;
      DATA_OBJECT_TYPES type;
      // Make sure that the object is derived from CSnapInObjectRoot
      hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
      if (SUCCEEDED(hr))
         hr = pItem->Notify(event, arg, param, NULL, pT, type);
   }
   return hr;
}

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(LPARAM lUserParam,
        MMC_COOKIE cookieA,
        MMC_COOKIE cookieB,
        int *pnResult)
   {
      ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
   }
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed);
   
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject);
};

template <class T>
inline HRESULT IExtendContextMenuImpl<T>::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK piCallback,
    long *pInsertionAllowed)
{
   ATLTRACE(_T("IExtendContextMenuImpl::AddMenuItems\n"));

   HRESULT hr = E_POINTER;

   ATLASSERT(pDataObject != NULL);
   if (pDataObject == NULL)
      ATLTRACE(_T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
   else
   {
      T* pT = static_cast<T*>(this);
      CSnapInItem* pItem;
      DATA_OBJECT_TYPES type;
      hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

      if (SUCCEEDED(hr))
         hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
   }
   return hr;
}

template <class T>
inline HRESULT IExtendContextMenuImpl<T>::Command(long lCommandID,
    LPDATAOBJECT pDataObject)
{
   ATLTRACE(_T("IExtendContextMenuImpl::Command\n"));

   HRESULT hr = E_POINTER;

   ATLASSERT(pDataObject != NULL);
   if (pDataObject == NULL)
      ATLTRACE(_T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
   else
   {
      T* pT = static_cast<T*>(this);
      CSnapInItem* pItem;
      DATA_OBJECT_TYPES type;
      hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
      
      if (SUCCEEDED(hr))
         hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)pT, type);
   }
   return hr;
}

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet2
{
public:
   STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject);
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);
    STDMETHOD(GetWatermarks)( 
            LPDATAOBJECT lpIDataObject,
             HBITMAP *lphWatermark,
             HBITMAP *lphHeader,
             HPALETTE *lphPalette,
             BOOL *bStretch);

};

template<class T>
inline HRESULT IExtendPropertySheetImpl<T>::GetWatermarks(
         LPDATAOBJECT lpIDataObject,
            HBITMAP *lphWatermark,
            HBITMAP *lphHeader,
            HPALETTE *lphPalette,
            BOOL *bStretch)
{
   ATLTRACE(_T("IExtendPropertySheetImpl::GetWatermarks\n"));
   return E_NOTIMPL;
}
    
template<class T>
inline HRESULT IExtendPropertySheetImpl<T>::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT pDataObject)
{
   ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

   HRESULT hr = E_POINTER;

   ATLASSERT(pDataObject != NULL);
   if (pDataObject == NULL)
      ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
   else
   {
      T* pT = static_cast<T*>(this);
      CSnapInItem* pItem;
      DATA_OBJECT_TYPES type;
      hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

      if (SUCCEEDED(hr))
         hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
   }

   return hr;
}

template <class T>
inline HRESULT IExtendPropertySheetImpl<T>::QueryPagesFor(LPDATAOBJECT pDataObject)
{
   ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor\n"));
   

   HRESULT hr = E_POINTER;
   
   ATLASSERT(pDataObject != NULL);
   if (pDataObject == NULL)
      ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
   else
   {
      T* pT = static_cast<T*>(this);
      CSnapInItem* pItem;
      DATA_OBJECT_TYPES type;
      hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

      if (SUCCEEDED(hr))
         hr = pItem->QueryPagesFor(type);
   }
   return hr;
}

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
   STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
   {
      ATLTRACE(_T("IExtendControlbarImpl::SetControlbar\n"));
      T* pT = static_cast<T*>(this);

      if (pT->m_spControlbar != NULL)
      {
         int n = pT->m_toolbarMap.GetSize();
         for (int i = 0; i < n; i++)
         {
            IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
             if (pToolbar != NULL)
             {
               pT->m_spControlbar->Detach(pToolbar);
               pToolbar->Release();
             }
         }
      }
      pT->m_toolbarMap.RemoveAll();

      pT->m_spControlbar = pControlbar;
      return S_OK;
   }
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);
};

template <class T>
inline HRESULT IExtendControlbarImpl<T>::ControlbarNotify(MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param)
{
   ATLTRACE(_T("IExtendControlbarImpl::ControlbarNotify\n"));

   CSnapInItem* pItem = NULL;
   DATA_OBJECT_TYPES type;
   HRESULT hr = S_OK;
   T* pT = static_cast<T*>(this);

   if (event == MMCN_BTN_CLICK)
      hr = pT->m_pComponentData->GetDataClass((IDataObject*) arg, &pItem, &type);
   else if (event == MMCN_SELECT)
   {
      hr = pT->m_pComponentData->GetDataClass((IDataObject*) param, &pItem, &type);
      BOOL bSelect = (BOOL) HIWORD (arg);
      BOOL bScope = (BOOL) LOWORD(arg); 
      if (bSelect)
      {
         int n = pT->m_toolbarMap.GetSize();
         for (int i = 0; i < n; i++)
         {
            IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
             if (pToolbar != NULL)
               pT->m_spControlbar->Detach(pToolbar);
         }
      }
   }

   if (SUCCEEDED(hr))
      hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, (CSnapInObjectRootBase*) pT, type);

   return hr;
}



#ifdef TASKPAD_SUPPORT
template <class T>
class ATL_NO_VTABLE IExtendTaskPadImpl : public IExtendTaskPad
{
public:

   STDMETHOD(TaskNotify)( 
      /* [in] */ IDataObject __RPC_FAR *lpDataObject,
      /* [in] */ VARIANT __RPC_FAR *pvarg,
      /* [in] */ VARIANT __RPC_FAR *pvparam)
   {
      ATLTRACE(_T("IExtendTaskPadImpl::TaskNotify\n"));

      HRESULT hr = E_POINTER;
      
      ATLASSERT(lpDataObject != NULL);
      if (lpDataObject == NULL)
         ATLTRACE(_T("IExtendTaskPadImpl::TaskNotify called with lpDataObject==NULL \n"));
      else
      {
         T* pT = static_cast<T*>(this);
         CSnapInItem* pItem;
         DATA_OBJECT_TYPES type;
         ATLASSERT(pT->m_pComponentData != NULL);
         hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
         if (SUCCEEDED(hr))
            hr = pItem->TaskNotify(
                       lpDataObject
                     , pvarg
                     , pvparam
                     );
      }
      return hr;

   }

   STDMETHOD(EnumTasks)( 
      /* [in] */ IDataObject __RPC_FAR *lpDataObject,
      /* [in] */ LPOLESTR szTaskGroup,
      /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK)
   {
      ATLTRACE(_T("IExtendTaskPadImpl::EnumTasks\n"));

      HRESULT hr = E_POINTER;
      
      ATLASSERT(lpDataObject != NULL);
      if (lpDataObject == NULL)
         ATLTRACE(_T("IExtendTaskPadImpl::EnumTasks called with lpDataObject==NULL \n"));
      else
      {
         T* pT = static_cast<T*>(this);
         CSnapInItem* pItem;
         DATA_OBJECT_TYPES type;
         ATLASSERT(pT->m_pComponentData != NULL);
         hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
         if (SUCCEEDED(hr))
            hr = pItem->EnumTasks(
                       lpDataObject
                     , szTaskGroup
                     , ppEnumTASK
                     );
      }
      return hr;
   }

   STDMETHOD(GetTitle)( 
      /* [in,string] */ LPOLESTR szGroup,
      /* [out,string] */ LPOLESTR *pszTitle)
   {
      ATLTRACENOTIMPL(_T("IExtendTaskPadImpl::GetTitle\n"));
   }

   STDMETHOD(GetDescriptiveText)( 
      /* [in,string] */ LPOLESTR pszGroup,
      /* [out,string] */ LPOLESTR *pszDescriptiveText)
   {
      ATLTRACENOTIMPL(_T("IExtendTaskPadImpl::GetDescriptiveText\n"));
   }

   STDMETHOD(GetBackground)( 
      /* [in,string] */ LPOLESTR pszGroup,
      /* [out] */ MMC_TASK_DISPLAY_OBJECT *pTDO )
   {
      ATLTRACENOTIMPL(_T("IExtendTaskPadImpl::GetBackground\n"));
   }

   STDMETHOD(GetListPadInfo)( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo)
   {
      ATLTRACENOTIMPL(_T("IExtendTaskPadImpl::GetListPadInfo\n"));
   }


};
#endif // TASKPAD_SUPPORT







#define SNAPINMENUID(id) \
public: \
   static const UINT GetMenuID() \
   { \
      static const UINT IDMENU = id; \
      return id; \
   }

#define EXT_SNAPINMENUID(id) \
public: \
   static const UINT GetMenuID() \
   { \
      static const UINT IDMENU = id; \
      return id; \
   }

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
   HRESULT ProcessCommand(UINT nID, \
      bool& bHandled, \
      CSnapInObjectRootBase* pObj, \
      DATA_OBJECT_TYPES type) \
   { \
         bHandled = true; \
         HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
      if (id == nID) \
      { \
         hr = func(bHandled, pObj); \
         if (bHandled) \
            return hr; \
      }

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
      if (id1 >= nID && nID <= id2) \
      { \
         hr = func(nID, bHandled, pObj); \
         if (bHandled) \
            return hr; \
      }

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
   { \
      hr = theChainClass::ProcessCommand(nID, bHandled, pObj, type); \
      if (bHandled) \
         return hr; \
   }

#define END_SNAPINCOMMAND_MAP() \
         return hr; \
   }

struct CSnapInToolBarData
{
   WORD wVersion;
   WORD wWidth;
   WORD wHeight;
   WORD wItemCount;
   //WORD aItems[wItemCount]

   WORD* items()
      { return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
   
class CSnapInToolbarInfo
{
public:
   ~CSnapInToolbarInfo()
   {
      CleanUp();
   }

   HRESULT CleanUp()
   {
      if (m_pStrToolTip)
      {
         for (UINT i = 0; i < m_nButtonCount; i++)
         {
            delete m_pStrToolTip[i];
            m_pStrToolTip[i] = NULL;
         }
         delete [] m_pStrToolTip;
         m_pStrToolTip = NULL;
      }

      if (m_pStrButtonText)
      {
         for (UINT i = 0; i < m_nButtonCount; i++)
         {
            delete m_pStrButtonText[i];
            m_pStrButtonText[i] = NULL;
         }

         delete [] m_pStrButtonText;
         m_pStrButtonText = NULL;
      }
      if (m_pnButtonID)
      {
         delete m_pnButtonID;
         m_pnButtonID = NULL;
      }

      m_nButtonCount = 0;
      return S_OK;
   }

   OLECHAR** m_pStrToolTip;
   OLECHAR** m_pStrButtonText;
   UINT* m_pnButtonID;
   UINT m_idToolbar;
   UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
   static CSnapInToolbarInfo* GetToolbarInfo() \
   { \
      static CSnapInToolbarInfo m_toolbarInfo[] = \
      {

#define SNAPINTOOLBARID_ENTRY(id) \
         { NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
         { NULL, NULL, NULL, 0, 0} \
      }; \
      return m_toolbarInfo; \
   }  

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
   CSnapInItemImpl(unsigned int helpIndex = 0)
      :CSnapInItem(helpIndex)
   {
   }

   virtual ~CSnapInItemImpl()
   {
   }    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
      IComponentData* pComponentData,
      IComponent* pComponent,
      DATA_OBJECT_TYPES type)
   {
      ATLASSERT("Override Function in Derived Class");
      ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
   }
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
   {
      ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
   }
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
   {
      ATLTRACE(_T("CSnapInItemImpl::GetResultViewType\n"));
      *ppViewType = NULL;
      *pViewOptions = MMC_VIEW_OPTIONS_NONE;
      return S_FALSE;
   }
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
   {
      ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
   }
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
      DATA_OBJECT_TYPES type)
   {
      ATLTRACE(_T("CSnapInItemImpl::AddMenuItems\n"));
      T* pT = static_cast<T*>(this);

      if (!bIsExtension)
         pT->SetMenuInsertionFlags(true, pInsertionAllowed);

      UINT menuID = pT->GetMenuID();
      if (menuID == 0)
         return S_OK;

      HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
      long insertionID;
      if (hMenu)
      {
         for (int i = 0; 1; i++)
         {
            HMENU hSubMenu = GetSubMenu(hMenu, i);
            if (hSubMenu == NULL)
               break;
            
            MENUITEMINFO menuItemInfo;
            memset(&menuItemInfo, 0, sizeof(menuItemInfo));
            menuItemInfo.cbSize = sizeof(menuItemInfo);

            switch (i)
            {
            case 0:
               if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
                  continue;
               insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
               break;

            case 1:
               if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
                  continue;
               if (bIsExtension)
                  insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
               else
                  insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
               break;

            case 2:;
               if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
                  continue;
               if (bIsExtension)
                  insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
               else
                  insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
               break;
            case 3:;
               if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
                  continue;
               insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
               break;
            default:
               {
                  insertionID = 0;
                  continue;
               }
               break;
            }

            menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
            menuItemInfo.fType = MFT_STRING;
            TCHAR szMenuText[128];

            for (int j = 0; 1; j++)
            {
               menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
               menuItemInfo.fType = MFT_STRING;
               menuItemInfo.cch = 128;
               menuItemInfo.dwTypeData = szMenuText;
               TCHAR szStatusBar[256];

               if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
                  break;
               if (menuItemInfo.fType != MFT_STRING)
                  continue;

               pT->UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
               LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, szStatusBar, 256);

               OLECHAR wszStatusBar[256];
               OLECHAR wszMenuText[128];
               USES_CONVERSION;
               ocscpy(wszMenuText, T2OLE(szMenuText));
               ocscpy(wszStatusBar, T2OLE(szStatusBar));

               CONTEXTMENUITEM contextMenuItem;
               contextMenuItem.strName = wszMenuText;
               contextMenuItem.strStatusBarText = wszStatusBar;
               contextMenuItem.lCommandID = menuItemInfo.wID;
               contextMenuItem.lInsertionPointID = insertionID;
               contextMenuItem.fFlags = menuItemInfo.fState;
               contextMenuItem.fSpecialFlags = 0;
               
               HRESULT hr = piCallback->AddItem(&contextMenuItem);
               ATLASSERT(SUCCEEDED(hr));
            }
         }
         DestroyMenu(hMenu);
      }

      if (!bIsExtension)
         pT->SetMenuInsertionFlags(true, pInsertionAllowed);

      return S_OK;
   }
    
    STDMETHOD(Command)(long lCommandID,      
      CSnapInObjectRootBase* pObj,
      DATA_OBJECT_TYPES type)
   {
      ATLTRACE(_T("CSnapInItemImpl::Command\n"));
      bool bHandled;
      T* pT = static_cast<T*>(this);
      return pT->ProcessCommand(lCommandID, bHandled, pObj, type);
   }
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
      IUnknown* pUnk,
      DATA_OBJECT_TYPES type)
   {
      ATLASSERT("Override Function in Derived Class");
      ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
   }
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
   {
      ATLASSERT("Override Function in Derived Class");
      ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
   }

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, 
      IExtendControlbar* pExtendControlBar,
      CSimpleMap<UINT, IUnknown*>* pToolbarMap)
   {
      ATLTRACE(_T("CSnapInItemImpl::SetControlbar\n"));
      T* pT = static_cast<T*>(this);

      CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
      if (pInfo == NULL)
         return S_OK;

      for( ; pInfo->m_idToolbar; pInfo++)
      {
         IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
         if (p != NULL)
            continue;

         HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
         if (hBitmap == NULL)
            return S_OK;

         HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
         if (hRsrc == NULL)
            return S_OK;

         HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc);
         if (hGlobal == NULL)
            return S_OK;

         CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
         if (pData == NULL)
            return S_OK;
         ATLASSERT(pData->wVersion == 1);
         ATLASSERT(pData->wWidth == 16);
         ATLASSERT(pData->wHeight == 16);

         pInfo->m_nButtonCount = pData->wItemCount;
         if (pInfo->m_pnButtonID == NULL)
            pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];

         if (pInfo->m_pnButtonID == NULL)
            continue;

         MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
         if (pButtons == NULL)
         {
            delete []pInfo->m_pnButtonID;
            continue;
         }
         
         if (pInfo->m_pStrToolTip == NULL)
         {
            pInfo->m_pStrToolTip = new OLECHAR* [pData->wItemCount];
            if (pInfo->m_pStrToolTip)
               memset(pInfo->m_pStrToolTip, 0, sizeof(OLECHAR*) * pData->wItemCount);
         }

         if (pInfo->m_pStrToolTip == NULL)
         {
            delete []pInfo->m_pnButtonID;
            delete []pButtons;
            continue;
         }


         for (int i = 0, j = 0; i < pData->wItemCount; i++)
         {
            pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
            if (pButtons[i].idCommand)
            {
               pButtons[i].nBitmap = j++;
               // get the statusbar string and allow modification of the button state
               TCHAR szStatusBar[512];
               LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, szStatusBar, 512);

               if (pInfo->m_pStrToolTip[i] == NULL)
                  pInfo->m_pStrToolTip[i] = new OLECHAR[lstrlen(szStatusBar) + 1];
               if (pInfo->m_pStrToolTip[i] == NULL)
                  continue;
               USES_CONVERSION;
               ocscpy(pInfo->m_pStrToolTip[i], T2OLE(szStatusBar));
               pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
               pButtons[i].lpButtonText = OLESTR("");
               pButtons[i].fsState = TBSTATE_ENABLED;
               pButtons[i].fsType = TBSTYLE_BUTTON;
               pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
            }
            else
            {
               pButtons[i].lpTooltipText = OLESTR("");
               pButtons[i].lpButtonText = OLESTR("");
               pButtons[i].fsType = TBSTYLE_SEP;
               pButtons[i].fsState = 0;
            }
         }

         IToolbar* pToolbar;
           HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
         if (SUCCEEDED(hr))
         {

            hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(255, 0, 255));
            if (SUCCEEDED(hr))
            {
               hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
               if (SUCCEEDED(hr))
               {
                  pToolbar->AddRef();
                  pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
               }
            }
         }
         pToolbar->Release();
         delete [] pButtons;
      }
      return S_OK;
   }
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
      CSimpleMap<UINT, IUnknown*>* pToolbarMap,
      MMC_NOTIFY_TYPE event,
        LPARAM arg, 
      LPARAM param,
      CSnapInObjectRootBase* pObj,
      DATA_OBJECT_TYPES type)
   {
      ATLTRACE(_T("CSnapInItemImpl::ControlbarNotify\n"));
      T* pT = static_cast<T*>(this);

      SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

      if(event == MMCN_SELECT)
      {
         if (pControlbar == NULL)
            return S_OK;

         BOOL bSelect = (BOOL) HIWORD (arg);
         BOOL bScope = (BOOL) LOWORD(arg); 

         CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
         if (pInfo == NULL)
            return S_OK;

         for(; pInfo->m_idToolbar; pInfo++)
         {
            IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
            if (pToolbar == NULL)
               continue;

            if (!bSelect && bScope)
               pControlbar->Detach(pToolbar);
            else
            {
               pControlbar->Attach(TOOLBAR, pToolbar);
               for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
               {
                  if (pInfo->m_pnButtonID[i])
                  {
                     pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                        ENABLED,
                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                           ENABLED));
                     pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                        CHECKED,
                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                           CHECKED));
                     pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                        HIDDEN,
                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                           HIDDEN));
                     pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                        INDETERMINATE,
                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                           INDETERMINATE));
                     pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                        BUTTONPRESSED,
                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
                           BUTTONPRESSED));
                  }
               }
            }
         }
         return S_OK;
      }
      else if (event == MMCN_BTN_CLICK)
      {
         bool bHandled;
         return pT->ProcessCommand((UINT) param, bHandled, pObj, type);
      }

      return E_UNEXPECTED;
   }

   STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
   {
      if (pScopeDataItem == NULL)
         return E_FAIL;

      *pScopeDataItem = &m_scopeDataItem;
      return S_OK;
   }
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
   {
      if (pResultDataItem == NULL)
         return E_FAIL;

      *pResultDataItem = &m_resultDataItem;
      return S_OK;
   }

   STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
   {
      CComObject<CSnapInDataObjectImpl>* pData;
      HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
      if (FAILED(hr))
         return hr;

      T* pT = static_cast<T*> (this);
      pData->m_objectData.m_pItem = pT;
      pData->m_objectData.m_type = type;

      hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
      return hr;
   }

   void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
   {
      return;
   }

   void SetToolbarButtonInfo(UINT id, BYTE *pfsState, BYTE *pfsType)
   {
      *pfsState = TBSTATE_ENABLED;
      *pfsType = TBSTYLE_BUTTON;
   }

   BOOL UpdateToolbarButton(UINT id, BYTE fsState)
   {
      if (fsState == ENABLED)
         return TRUE;
      return FALSE;
   }

   HRESULT ProcessCommand(UINT nID, 
      bool& bHandled,
      CSnapInObjectRootBase* pObj,
      DATA_OBJECT_TYPES type)
   {
      ATLTRACE(_T("No handler for item with ID %d\n"), nID);
      return S_OK;
   }

   STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
   {
      HRESULT hr = DV_E_CLIPFORMAT;
      ULONG uWritten;

      T* pT = static_cast<T*> (this);

      if (cf == m_CCF_NODETYPE)
      {
         hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
         return hr;
      }

      if (cf == m_CCF_SZNODETYPE)
      {
         hr = pStream->Write(pT->GetSZNodeType(), (ocslen((OLECHAR*)pT->GetSZNodeType()) + 1 )* sizeof(OLECHAR), &uWritten);
         return hr;
      }

      if (cf == m_CCF_DISPLAY_NAME)
      {
         hr = pStream->Write(pT->GetDisplayName(), (ocslen((OLECHAR*)pT->GetDisplayName()) + 1) * sizeof(OLECHAR), &uWritten);
         return hr;
      }

      if (cf == m_CCF_SNAPIN_CLASSID)
      {
         hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
         return hr;
      }

      return hr;
   }

   static CSnapInToolbarInfo* GetToolbarInfo()
   {
      return NULL;
   }

   static const UINT GetMenuID() 
   {
      return 0;
   }

   void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed)
   {
   }

   void* GetNodeType()
   {
      return (void*)T::m_NODETYPE;
   }
   void* GetSZNodeType()
   {
      return (void*)T::m_SZNODETYPE;
   }

   void* GetDisplayName()
   {
      return (void*)T::m_SZDISPLAY_NAME;
   }

   void* GetSnapInCLSID()
   {
      return (void*)T::m_SNAPIN_CLASSID;
   }

   CComBSTR m_bstrDisplayName;
   SCOPEDATAITEM m_scopeDataItem;
   RESULTDATAITEM m_resultDataItem;


#ifdef TASKPAD_SUPPORT
   STDMETHOD(TaskNotify)(
              IDataObject * pDataObject
            , VARIANT * pvarg
            , VARIANT * pvparam
            )
   {
      ATLTRACENOTIMPL(_T("CSnapInItemImpl::TaskNotify"));

   }

   STDMETHOD(EnumTasks)(
              IDataObject * pDataObject
            , BSTR szTaskGroup
            , IEnumTASK** ppEnumTASK
            )
   {
      ATLTRACENOTIMPL(_T("CSnapInItemImpl::EnumTasks"));
   }
#endif // TASKPAD_SUPPORT

};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\dialog.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

   Dialog.h

Abstract:

   Header file for the CIASDialog template class.

Author:

    Michael A. Maguire 02/03/98

Revision History:
   mmaguire 02/03/98 - abstracted from CAddClientDialog class


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_DIALOG_H_)
#define _IAS_DIALOG_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include <atlwin.h>
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

//=============================================================================
// Global Help Table for many Dialog IDs
//
#include "hlptable.h"

// works with ATL dialog implementation

template < class T, bool bAutoDelete = TRUE>
class CIASDialog : public CDialogImpl<T>
{
protected:
   const DWORD*   m_pHelpTable;

public:

   BEGIN_MSG_MAP( (CIASDialog<T,nIDD,bAutoDelete>) )
      MESSAGE_HANDLER( WM_CONTEXTMENU, OnContextHelp )
      MESSAGE_HANDLER( WM_HELP, OnF1Help )
      COMMAND_ID_HANDLER( IDC_BUTTON_HELP, OnHelp )
      MESSAGE_HANDLER( WM_NCDESTROY, OnFinalMessage )
   END_MSG_MAP()

   CIASDialog()
   {
      SET_HELP_TABLE(T::IDD);
   }
   //////////////////////////////////////////////////////////////////////////////
   /*++

   CAddClientDialog::OnF1Help

   You shouldn't need to override this method in your derived class.
   Just initialize your static m_dwHelpMap member variable appropriately.

   This is called in response to the WM_HELP Notify message.

   This message is sent when the user presses F1 or <Shift>-F1
   over an item or when the user clicks on the ? icon and then
   presses the mouse over an item.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   LRESULT OnF1Help(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      )
   {
      ATLTRACE(_T("# CIASDialog::OnF1Help\n"));
            
      // Check for preconditions:
      // None.

      HELPINFO* helpinfo = (HELPINFO*) lParam;

      if (helpinfo->iContextType == HELPINFO_WINDOW)
      {
         ::WinHelp(
           (HWND) helpinfo->hItemHandle,
           HELPFILE_NAME,
           HELP_WM_HELP,
           (DWORD_PTR)(void*) m_pHelpTable );
      }

      return TRUE;
   }


   //////////////////////////////////////////////////////////////////////////////
   /*++

   CAddClientDialog::OnContextHelp

   You shouldn't need to override this method in your derived class.
   Just initialize your static m_dwHelpMap member variable appropriately.

   This is called in response to the WM_CONTEXTMENU Notify message.

   This message is sent when the user right clicks over an item
   and then clicks "What's this?"

   --*/
   //////////////////////////////////////////////////////////////////////////////
   LRESULT OnContextHelp(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      )
   {
      ATLTRACE(_T("# CIASDialog::OnContextHelp\n"));
            
      // Check for preconditions:
      // None.

      WinHelp(
              HELPFILE_NAME
            , HELP_CONTEXTMENU
            , (DWORD_PTR)(void*) m_pHelpTable
            );

      return TRUE;
   }


   /////////////////////////////////////////////////////////////////////////////
   /*++

   CIASDialog::OnHelp

   Remarks:

      Don't override this method in your derived class.
      Instead, override the GetHelpPath method.
      
      This implementation calls the HtmlHelp API call with the HH_DISPLAY_TOPIC
      parameter, supplying the correct path to the compressed HTML help
      file for our application.  It calls our GetHelpPath
      method to get the string to pass in as the fourth parameter
      to the HtmlHelp call.

      This method is called when the user presses on the Help button of a
      property sheet.

      It is an override of atlsnap.h CSnapInPropertyPageImpl::OnHelp.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   virtual LRESULT OnHelp(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
      )
   {
      ATLTRACE(_T("# CIASDialog::OnHelp -- Don't override\n"));

      // Check for preconditions:

      HRESULT hr;
      WCHAR szHelpFilePath[IAS_MAX_STRING*2];


      // Use system API to get windows directory.
      UINT uiResult = GetWindowsDirectory( szHelpFilePath, IAS_MAX_STRING );
      if( uiResult <=0 || uiResult > IAS_MAX_STRING )
      {
         return E_FAIL;
      }

      WCHAR *szTempAfterWindowsDirectory = szHelpFilePath + lstrlen(szHelpFilePath);

      // Load the help file name.  Note: IDS_HTMLHELP_FILE = "iasmmc.chm"
      int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_HTMLHELP_PATH, szTempAfterWindowsDirectory, IAS_MAX_STRING );
      if( nLoadStringResult <= 0 )
      {
         return TRUE;
      }

      lstrcat( szTempAfterWindowsDirectory, L"::/" );

      WCHAR * szHelpFilePathAfterFileName = szHelpFilePath + lstrlen(szHelpFilePath);

      hr = GetHelpPath( szHelpFilePathAfterFileName );
      if( FAILED( hr ) )
      {
         return TRUE;
      }

      MMCPropertyHelp( szHelpFilePath );
      return 0;
   }

   
   /////////////////////////////////////////////////////////////////////////////
   /*++

   CIASDialog::GetHelpPath

   Remarks:

      Override this method in your derived class.
      
      You should return the string with the relevant path within the
      compressed HTML file to get help for your property page.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   virtual HRESULT GetHelpPath( LPTSTR szHelpPath )
   {
      ATLTRACE(_T("# CIASDialog::GetHelpPath -- override in your derived class\n"));
            
      // Check for preconditions:

#ifdef UNICODE_HHCTRL
      // ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
      // installed on this machine -- it appears to be non-unicode.
      lstrcpy( szHelpPath, _T("") );
#else
      strcpy( (CHAR *) szHelpPath, "" );
#endif

      return S_OK;
   }


   /////////////////////////////////////////////////////////////////////////////
   /*++

   CAddClientDialog::OnFinalMessage

   This will get called when the page is sent the WM_NCDESTROY message,
   which is an appropriate time to delete the class implementing this dialog.


   --*/
   //////////////////////////////////////////////////////////////////////////////
   LRESULT OnFinalMessage(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      )
   {
      ATLTRACE(_T("# CIASDialog::OnFinalMessage\n"));

      // Check for preconditions:
      // None.

      if( bAutoDelete )
      {
         // Be very careful here -- if you just do "delete this"
         // then destruction for the object which derives from this template
         // class won't occur -- this was causing some smart pointers
         // in a derived class not to release.
         T * pT = static_cast<T*> ( this );
         delete pT;
      }

      return 0;
   }
};

#endif // _IAS_DIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\commres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       commres.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by common.rc
//
#define IDC_EDIT_USERNAME               534
#define IDC_TEXT_USER                   535
#define IDC_EDIT_USER_PASSWORD          536
#define IDC_TEXT_PASSWORD               537
#define IDC_TEXT_INACCESSIBLE_RESOURCE  538
#define IDC_EDIT_MACHINENAME            539
#define IDD_CONNECT_AS                  605

#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\cnctdlg.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    CnctDlg.cpp
//
// History:
//  05/24/96    Michael Clark      Created.
//
// Implements the Router Connection dialog
//============================================================================
//

#include "precompiled.h"
#include "afx.h"
#include "CnctDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TCHAR c_szIPCShare[]              = TEXT("IPC$");

/////////////////////////////////////////////////////////////////////////////
//
// CConnectAsDlg dialog
//
/////////////////////////////////////////////////////////////////////////////


CConnectAsDlg::CConnectAsDlg(CWnd* pParent /*=NULL*/)
	: CHelpDialog(CConnectAsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConnectAsDlg)
	m_sUserName = _T("");
	m_sPassword = _T("");
	m_stTempPassword = m_sPassword;
    m_sRouterName= _T("");
	//}}AFX_DATA_INIT

//	SetHelpMap(m_dwHelpMap);
}


void CConnectAsDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConnectAsDlg)
	DDX_Text(pDX, IDC_EDIT_USERNAME, m_sUserName);
	DDX_Text(pDX, IDC_EDIT_USER_PASSWORD, m_stTempPassword);
	DDX_Text(pDX, IDC_EDIT_MACHINENAME, m_sRouterName);
	DDV_MaxChars( pDX, m_sRouterName, MAX_PATH );
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		// Copy the data into the new buffer
		// ------------------------------------------------------------
		m_sPassword = m_stTempPassword;

		// Clear out the temp password, by copying 0's
		// into its buffer
		// ------------------------------------------------------------
		int		cPassword = m_stTempPassword.GetLength();
		::ZeroMemory(m_stTempPassword.GetBuffer(0),
					 cPassword * sizeof(TCHAR));
		m_stTempPassword.ReleaseBuffer();
		
		// Encode the password into the real password buffer
		// ------------------------------------------------------------
		m_ucSeed = CONNECTAS_ENCRYPT_SEED;
		RtlEncodeW(&m_ucSeed, m_sPassword.GetBuffer(0));
		m_sPassword.ReleaseBuffer();
	}
}

IMPLEMENT_DYNCREATE(CConnectAsDlg, CHelpDialog)

BEGIN_MESSAGE_MAP(CConnectAsDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CConnectAsDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CConnectAsDlg::OnInitDialog()
{
    BOOL    fReturn;
    
    fReturn = CHelpDialog::OnInitDialog();

    // Bring this window to the top
    BringWindowToTop();
    
    return fReturn;
}


/*!--------------------------------------------------------------------------
	ConnectAsAdmin
		Connect to the remote machine as administrator with user-supplied
		credentials.

		Returns
			S_OK	- if a connection was established
			S_FALSE - if user cancelled out
			other	- error condition
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConnectAsAdmin( IN LPCTSTR szRouterName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())


    //
    // allow user to specify credentials
    //

    DWORD           dwRes           = (DWORD) -1;
	HRESULT			hr = S_OK;
    
    CConnectAsDlg   caDlg;
    ::CString         stIPCShare;
	::CString			stRouterName;
	::CString			stPassword;

	stRouterName = szRouterName;
    
    //
    // set message text in connect as dialog.
    //
    
    caDlg.m_sRouterName = szRouterName;


    //
    // loop till connect succeeds or user cancels
    //
    
    while ( TRUE )
    {

        // We need to ensure that this dialog is brought to
        // the top (if it gets lost behind the main window, we
        // are really in trouble).
        dwRes = caDlg.DoModal();

        if ( dwRes == IDCANCEL )
        {
			hr = S_FALSE;
            break;
        }


        //
        // Create remote resource name
        //

        stIPCShare.Empty();
        
        if ( stRouterName.Left(2) != TEXT( "\\\\" ) )
        {
            stIPCShare = TEXT( "\\\\" );
        }
		        
        stIPCShare += stRouterName;
        stIPCShare += TEXT( "\\" );
        stIPCShare += c_szIPCShare;


        NETRESOURCE nr;

        nr.dwType       = RESOURCETYPE_ANY;
        nr.lpLocalName  = NULL;
        nr.lpRemoteName = (LPTSTR) (LPCTSTR) stIPCShare;
        nr.lpProvider   = NULL;
            

        //
        // connect to \\router\ipc$ to try and establish credentials.
        // May not be the best way to establish credentials but is 
        // the most expendient for now.
        //

		// Need to unencode the password in the ConnectAsDlg
		stPassword = caDlg.m_sPassword;

		RtlDecodeW(caDlg.m_ucSeed, stPassword.GetBuffer(0));
		stPassword.ReleaseBuffer();
        
        dwRes = WNetAddConnection2(
                    &nr,
                    (LPCTSTR) stPassword,
                    (LPCTSTR) caDlg.m_sUserName,
                    0
                );
		ZeroMemory(stPassword.GetBuffer(0),
				   stPassword.GetLength() * sizeof(TCHAR));
		stPassword.ReleaseBuffer();

        if ( dwRes != NO_ERROR )
        {
            PBYTE           pbMsgBuf        = NULL;
            
            ::FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwRes,
                MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
                (LPTSTR) &pbMsgBuf,
                0,
                NULL 
            );

            AfxMessageBox( (LPCTSTR) pbMsgBuf );

            LocalFree( pbMsgBuf );
        }

        else
        {
            //
            // connection succeeded
            //

			hr = S_OK;
            break;
        }
    }

    return hr;
}

    
// Some helper functions

DWORD RtlEncodeW(PUCHAR pucSeed, LPWSTR pswzString)
{
	UNICODE_STRING	ustring;

	ustring.Length = lstrlenW(pswzString) * sizeof(WCHAR);
	ustring.MaximumLength = ustring.Length;
	ustring.Buffer = pswzString;

	RtlRunEncodeUnicodeString(pucSeed, &ustring);
	return 0;
}

DWORD RtlDecodeW(UCHAR ucSeed, LPWSTR pswzString)
{
	UNICODE_STRING	ustring;

	ustring.Length = lstrlenW(pswzString) * sizeof(WCHAR);
	ustring.MaximumLength = ustring.Length;
	ustring.Buffer = pswzString;

	RtlRunDecodeUnicodeString(ucSeed, &ustring);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\changenotification.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	ChangeNotification.h

Abstract:

	Declaration of the CChangeNotification class.

	Several of the MMC notification mechanisms accept on one or two parameters for 
	sending information.

	For example, MMCPropertyChangeNotify accepts only one long param handle which 
	can be used to send information back to the main snapin from the separate
	thread in which a property page runs.

	Sometimes, this isn't enough information, so this structure allows us
	to encapsulate more information to pass around.


	This is all inline -- there is no implementation file.

Revision History:
	mmaguire 07/17/98	- based on Baogang Yao's original implementation


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_CHANGE_NOTIFICATION_H_)
#define _CHANGE_NOTIFICATION_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



// Notification flags:

// No special handling required.
const DWORD CHANGE_UPDATE_RESULT_NODE = 0x00;

// The policy name for this node has been changed. This is used for renaming of policy.
const DWORD CHANGE_PARENT_MUST_BE_UPDATED_TOO = 0x01;

// The policy name for this node has been changed. This is used for renaming of policy.
const DWORD CHANGE_NAME = 0x02;

// Some information has changed -- e.g. Connect action finished.  Make sure the result view
// of the currently selected scope node is updated.
const DWORD CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE = 0x04;

// Make sure the result view of the currently selected scope node is updated.
const DWORD CHANGE_UPDATE_CHILDREN_OF_THIS_NODE = 0x08;

// Will require a parent redraw and some selection changes.
const DWORD CHANGE_RESORT_PARENT = 0x10;



class CChangeNotification
{

public:

	
	// What kind of notitification.
	DWORD	m_dwFlags;

	// Which node was affected.
	CSnapInItem * m_pNode;	

	// The parent node of the node which changed.
	CSnapInItem * m_pParentNode;

	// Extra data.
	DWORD		m_dwParam;				

	// A string -- can be used however needed.
	CComBSTR	m_bstrStringInfo;


	// Constructor -- set ref count to 1.
	CChangeNotification( void )
	{
		m_lRefs = 1;
	}


	// COM-style lifetime management.
	LONG AddRef( void )
	{
		return InterlockedIncrement( &m_lRefs );
	}


	// COM-style lifetime management.
	LONG Release( void )
	{
		LONG lRefCount = InterlockedDecrement( &m_lRefs );
		if( 0 == lRefCount )
		{
			delete this;
		}
		return lRefCount;
	}



private:
	LONG	m_lRefs;
	

};


#endif // _CHANGE_NOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\cnctdlg.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    CnctDlg.h
//
// History:
//  05/24/96    Michael Clark      Created.
//
// Implements the Router Connection dialog
// Implements the Router Connect As dialog
//============================================================================
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "commres.h"
#include "dlgcshlp.h"


/////////////////////////////////////////////////////////////////////////////
// CConnectAs dialog

class CConnectAsDlg : public CHelpDialog
{
	DECLARE_DYNCREATE(CConnectAsDlg)

// Construction
public:
	CConnectAsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConnectAsDlg)
	enum { IDD = IDD_CONNECT_AS };
	CString	m_sUserName;
	CString m_sPassword;
	CString	m_stTempPassword;
	CString m_sRouterName;
	//}}AFX_DATA

	UCHAR	m_ucSeed;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConnectAsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConnectAsDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    BOOL    OnInitDialog();
};

// This is used as the seed value for the RtlRunEncodeUnicodeString
// and RtlRunDecodeUnicodeString functions.
#define CONNECTAS_ENCRYPT_SEED		(0xB7)

DWORD RtlEncodeW(PUCHAR pucSeed, LPWSTR pswzString);
DWORD RtlDecodeW(UCHAR ucSeed, LPWSTR pswzString);

HRESULT ConnectAsAdmin( IN LPCTSTR szRouterName);

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////////
//
// defines
#ifndef NT_INCLUDED
    typedef LONG NTSTATUS;
    typedef NTSTATUS *PNTSTATUS;

    typedef struct _UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;
#endif

NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    PUCHAR          Seed        OPTIONAL,
    PUNICODE_STRING String
    );


NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    UCHAR           Seed,
    PUNICODE_STRING String
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\cutandpastedataobject.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    CutAndPasteDataObject.h

Abstract:

	Header file for the CCutAndPasteDataObject template class.

	This is an inline template class.

Usage Notes:

	This template class can be used to enable cutting and pasting
	for a node.

	Override ATLsnap's 	CSnapInItem::GetDataObject and instead of 
	passing back an IDataObject pointer on ATLsnap's CSnapInDataObjectImpl, 
	pass back an IDataObject interface pointer on CCutAndPasteDataObject<CYourNode>.


	In order to use this template class, your node class must have the following:

  		HRESULT FillText(LPSTGMEDIUM pSTM);			// So our data can be pasted into any apps.
		HRESULT FillClipboardData(LPSTGMEDIUM pSTM);
		static CLIPFORMAT m_CCF_CUT_AND_PASTE_FORMAT;
	
	  
	You should make sure that your static m_CCF_CUT_AND_PASTE_FORMAT is 
	registered as a clipformat in some static function you call at snapin startup, e.g.

		static void InitClipboardFormat();

	Note that once you have these implemented, you will also need
	to set the MMC_VERB_COPY on your node.
	
	You must them set the MMC_VERB_PASTE node on the folder node into which
	you would like to paste the node you've copied.  That folder node must
	also repond appropriately to the MMCN_QUERY_PASTE notification.  
	To handle this notification properly, you may find it helpful to add
	a method to the copied node which will tell whether the IDataObject
	has a valid clipboard format, e.g.:

		static HRESULT IsClientClipboardData( IDataObject* pDataObj );

	Once you've told MMC your folder node can handle a paste, you will
	have to respond correctly to the MMCN_PASTE notification, and you
	may again find it helpful to implement a method on the copied node
	which can fill that node with data from the IDataObject, e.g.:
		
		  HRESULT SetClientWithDataFromClipboard( IDataObject* pDataObject );

Author:

    Michael A. Maguire 02/12/98

Revision History:
	mmaguire 02/12/98 - abstracted from CClientDataObject


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_CUT_AND_PASTE_DATA_OBJECT_H_)
#define _IAS_CUT_AND_PASTE_DATA_OBJECT_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//#include <atlctl.h>  We've decided not to derive from ATL's IDataObjectImpl.
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


// Helper class used by class below.
template <class NodeToBeCutAndPasted>
class CCutAndPasteObjectData
{
public:
	NodeToBeCutAndPasted * m_pItem;
	DATA_OBJECT_TYPES m_type;
};



template <class NodeToBeCutAndPasted>
class ATL_NO_VTABLE CCutAndPasteDataObject : 
						  public IDataObject
						, public CComObjectRoot
{

public:

	BEGIN_COM_MAP(CCutAndPasteDataObject<NodeToBeCutAndPasted>)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()



	//////////////////////////////////////////////////////////////////////////////
	/*++

	  CCutAndPasteDataObject::GetData

		This method is needed for spiffy clipboard functions.


	  Purpose:
		Retrieves data described by a specific FormatEtc into a StgMedium
		allocated by this function.  Used like GetClipboardData.

	  Parameters:
		pFE             LPFORMATETC describing the desired data.
		pSTM            LPSTGMEDIUM in which to return the data.

	  Return Value:
		HRESULT         NOERROR or a general error value.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	STDMETHOD(GetData)(FORMATETC *pFormatEtc, STGMEDIUM *pStorageMedium )
	{
		ATLTRACE(_T("CCutAndPasteDataObject::GetData\n"));

		HRESULT hr;
		UINT            cf=pFormatEtc->cfFormat;

		// Check the aspects we support.
//		if (!(DVASPECT_CONTENT & pFE->dwAspect))
//			return ResultFromScode(DATA_E_FORMATETC);

		if( TYMED_HGLOBAL & pFormatEtc->tymed )
		{
			if( cf == CF_TEXT )
			{
				return hr = m_objectData.m_pItem->FillText( pStorageMedium );
			}

			if( cf == NodeToBeCutAndPasted::m_CCF_CUT_AND_PASTE_FORMAT )
			{
				return hr = m_objectData.m_pItem->FillClipboardData( pStorageMedium );
			}
		
		}

		return E_NOTIMPL;

	}



	//////////////////////////////////////////////////////////////////////////////
	/*++

	  CCutAndPasteDataObject::GetDataHere


	  This method is needed by MMC to do its usual work -- we are pretty much 
	  copying the ATLsnap.h implementation here.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE(_T("CCutAndPasteDataObject::GetDataHere\n"));

		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}



	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("CCutAndPasteDataObject::QueryGetData\n"));
	}



	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("CCutAndPasteDataObject::GetCanonicalFormatEtc\n"));
	}



	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("CCutAndPasteDataObject::SetData\n"));
	}



	//////////////////////////////////////////////////////////////////////////////
	/*++

	  CCutAndPasteDataObject::GetDataHere

		For cut and paste, the OLE clipboard will ask us for an IEnumFORMATETC
		structure that lists the formats we support.

		We construct a enumerator which will say that we support the format
		indicated by the m_CCF_CUT_AND_PASTE_FORMAT class variable from 
		the node as template parameter.

		You can use this template class for many nodes, each of which will 
		have the m_CCF_CUT_AND_PASTE_FORMAT class variable, but just make sure
		that you use a different string for each of them in the RegisterClipboardFormat
		call.

		  	CClientNode::m_CCF_CUT_AND_PASTE_FORMAT	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_IAS_CLIENT_NODE"));
		  	CPolicyNode::m_CCF_CUT_AND_PASTE_FORMAT	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NAP_POLICY_NODE"));

		Also, so that we can paste our data into any app, we support CF_TEXT.
		If you don't want this functionality, respond minimally in your node's
		FillText method.
	  
	--*/
	//////////////////////////////////////////////////////////////////////////////
	STDMETHOD(EnumFormatEtc)(DWORD dwDirection, IEnumFORMATETC** ppenumFormatEtc )
	{
		ATLTRACE(_T("CCutAndPasteDataObject::EnumFormatEtc\n"));

		static FORMATETC fetcFormat[2];

		fetcFormat[0].cfFormat=CF_TEXT;
		fetcFormat[0].dwAspect=DVASPECT_CONTENT;
		fetcFormat[0].ptd=NULL;
		fetcFormat[0].tymed=TYMED_HGLOBAL;
		fetcFormat[0].lindex=-1;

		fetcFormat[1].cfFormat= NodeToBeCutAndPasted::m_CCF_CUT_AND_PASTE_FORMAT;
		fetcFormat[1].dwAspect=DVASPECT_CONTENT;
		fetcFormat[1].ptd=NULL;
		fetcFormat[1].tymed=TYMED_HGLOBAL;
		fetcFormat[1].lindex=-1;

		switch (dwDirection)
			{
			case DATADIR_GET:
				*ppenumFormatEtc=new CEnumFormatEtc(2, fetcFormat);
				break;

			case DATADIR_SET:
				*ppenumFormatEtc=NULL;
				break;

			default:
				*ppenumFormatEtc=NULL;
				break;
			}

		if( NULL == *ppenumFormatEtc )
		{
			return E_FAIL;
		}
		else
		{
			(*ppenumFormatEtc)->AddRef();
		}

		return NOERROR;
	}



	STDMETHOD(DAdvise)(
					  FORMATETC *pformatetc
					, DWORD advf
					, IAdviseSink *pAdvSink
					, DWORD *pdwConnection
					)
	{
		ATLTRACENOTIMPL(_T("CCutAndPasteDataObject::DAdvise\n"));
	}



	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACENOTIMPL(_T("CCutAndPasteDataObject::DUnadvise\n"));
	}
	


	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACENOTIMPL(_T("CCutAndPasteDataObject::EnumDAdvise\n"));
	}


	
	CCutAndPasteObjectData<NodeToBeCutAndPasted> m_objectData;

};


#endif // _IAS_CUT_AND_PASTE_DATA_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\dlgcshlp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       dlgcshlp.cpp
//
//--------------------------------------------------------------------------

#include "dlgcshlp.h"
#include "propertypage.h"

IMPLEMENT_DYNCREATE(CHelpDialog, CDialog)

BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
	//{{AFX_MSG_MAP(CHelpDialog)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CHelpDialog::OnContextMenu(CWnd* pWnd, ::CPoint point) 
{
    if (m_pHelpTable)
		::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)m_pHelpTable);
}

BOOL CHelpDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW && m_pHelpTable)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_WM_HELP,
		           (DWORD_PTR)(LPVOID)m_pHelpTable);
	}
    return TRUE;	
}



/////////////////////////////////////////////////////////////////////////////
// CHelpPage property page
BEGIN_MESSAGE_MAP(CHelpPage, CPropertyPage)
	//{{AFX_MSG_MAP(CHelpPage)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CHelpPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (m_pHelpTable)
		::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)m_pHelpTable);
}

BOOL CHelpPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW && m_pHelpTable)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_WM_HELP,
		           (DWORD_PTR)(LPVOID)m_pHelpTable);
	}
    return TRUE;	
}


/////////////////////////////////////////////////////////////////////////////
// CHelpPageEx property page
BEGIN_MESSAGE_MAP(CHelpPageEx, CPropertyPageEx)
	//{{AFX_MSG_MAP(CHelpPageEx)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CHelpPageEx::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   if (m_bHelpEnabled)
   {
      if (m_pHelpTable)
      {
         ::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
            HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)m_pHelpTable);
      }
   }
}

BOOL CHelpPageEx::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   if (m_bHelpEnabled)
   {
      if (pHelpInfo->iContextType == HELPINFO_WINDOW && m_pHelpTable)
	   {
           ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		              AfxGetApp()->m_pszHelpFilePath,
		              HELP_WM_HELP,
		              (DWORD_PTR)(LPVOID)m_pHelpTable);
	   }
   }
   return TRUE;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\dialogwithworkerthread.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    DialogWithWorkerThread.h

Abstract:

	Header file for a template class which manages a dialog that will run in the main
	context of the MMC thread.  This dialog will spawn off a worker thread 
	that will communicate with the main mmc thread via MMC's window
	message pump associated with the dialog.
	
	This is an inline template class and there is no .cpp file.

Author:

    Michael A. Maguire 02/28/98

Revision History:
	mmaguire 02/28/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_DIALOG_WITH_WORKER_THREAD_H_)
#define _IAS_DIALOG_WITH_WORKER_THREAD_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "Dialog.h"
//
//
// where we can find what this class has or uses:
//
#include <process.h>
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


typedef
enum _TAG_WORKER_THREAD_STATUS
{
	WORKER_THREAD_NEVER_STARTED = 0,
	WORKER_THREAD_STARTING,
	WORKER_THREAD_STARTED,
	WORKER_THREAD_START_FAILED,
	WORKER_THREAD_ACTION_INTERRUPTED,
	WORKER_THREAD_FINISHED
} WORKER_THREAD_STATUS;


// This should be a safe private window message to pass.
#define WORKER_THREAD_MESSAGE  ((WM_USER) + 100)


template <class T>
class CDialogWithWorkerThread : public CDialogImpl<T>
{

public:

	// In your derived class, declare the ID of the dialog resource 
	// you want for this class in the following manner.
	// An enum must be used here because the correct value of 
	// IDD must be initialized before the base class's constructor is called.
	
	//	enum { IDD = IDD_CONNECT_TO_MACHINE };


	BEGIN_MSG_MAP(CDialogWithWorkerThread<T>)
		MESSAGE_HANDLER(WORKER_THREAD_MESSAGE, OnReceiveThreadMessage)
	END_MSG_MAP()



	/////////////////////////////////////////////////////////////////////////////
	/*++

	CDialogWithWorkerThread()

	Constructor

	--*/
	//////////////////////////////////////////////////////////////////////////////
	CDialogWithWorkerThread()
	{
		ATLTRACE(_T("# CDialogWithWorkerThread::CDialogWithWorkerThread\n"));


		m_wtsWorkerThreadStatus = WORKER_THREAD_NEVER_STARTED ;
		m_ulWorkerThread = NULL; 
		m_lRefCount = 0;

	}


	
	/////////////////////////////////////////////////////////////////////////////
	/*++

	~CDialogWithWorkerThread( void )

	Destructor

	--*/
	//////////////////////////////////////////////////////////////////////////////
	~CDialogWithWorkerThread( void )
	{
		ATLTRACE(_T("# CDialogWithWorkerThread::~CDialogWithWorkerThread\n"));


	}


	
	//////////////////////////////////////////////////////////////////////////////
	/*++

	AddRef

	COM-style lifetime management.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	LONG AddRef( void )
	{
		ATLTRACE(_T("# CDialogWithWorkerThread::AddRef\n"));

		return InterlockedIncrement( &m_lRefCount );
	}


	
	//////////////////////////////////////////////////////////////////////////////
	/*++

	Release

	COM-style lifetime management.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	LONG Release( BOOL bOwner = TRUE )
	{
		ATLTRACE(_T("# CDialogWithWorkerThread::Release\n"));

		LONG lRefCount;


		if( bOwner && m_hWnd != NULL )
		{
			//
			// Only the thread which created the window managed by this class 
			// should call DestroyWindow.
			// Release() with bOwner == TRUE means the owning thread is 
			// calling release.
			//
			DestroyWindow();
		}
		
		
		lRefCount = InterlockedDecrement( &m_lRefCount );


		if( lRefCount == 0)
		{
			T * pT = static_cast<T*>(this);

			delete pT;
			return 0;
		}

		return lRefCount;

	}



	/////////////////////////////////////////////////////////////////////////////
	/*++

	CDialogWithWorkerThread::StartWorkerThread

	Instructs this class to create and start the worker thread.  
	
	You should not need to override this in your derived class.

	If the worker thread has already been previously started, this function 
	will do nothing, and return S_FALSE.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	HRESULT StartWorkerThread( void )
	{
		ATLTRACE(_T("# CDialogWithWorkerThread::StartWorkerThread\n"));


		// Check for preconditions:
		// None.


		// Make sure the worker thread isn't already trying to do its job.

		if(		WORKER_THREAD_NEVER_STARTED == m_wtsWorkerThreadStatus 
			||	WORKER_THREAD_START_FAILED == m_wtsWorkerThreadStatus 
			||	WORKER_THREAD_ACTION_INTERRUPTED == m_wtsWorkerThreadStatus 
			||	WORKER_THREAD_FINISHED == m_wtsWorkerThreadStatus 
			)
		{

			// We create a new thread.
			m_wtsWorkerThreadStatus = WORKER_THREAD_STARTING;

// Don't use CreateThread if you are using the C Run-Time -- use _beginthread instead.
//			m_hWorkerThread = CreateThread(  
//						  NULL					// pointer to thread security attributes
//						, 0						// initial thread stack size, in bytes
//						, WorkerThreadFunc		// pointer to thread function
//						, (LPVOID) this			// argument for new thread
//						, 0						// creation flags
//						, &dwThreadId			// pointer to returned thread identifier
//						);
		

			m_ulWorkerThread = _beginthread(  
						  WorkerThreadFunc		// pointer to thread function
						, 0						// stack size
						, (void *) this			// argument for new thread
						);
		

			if( -1 == m_ulWorkerThread )
			{
				m_wtsWorkerThreadStatus = WORKER_THREAD_START_FAILED;
				return E_FAIL;	// ISSUE: better return code?
			}


			return S_OK;
		
		}
		else
		{
			// Worker thread already in progress.
			return S_FALSE;
		}

	}



	//////////////////////////////////////////////////////////////////////////////
	/*++

	GetWorkerThreadStatus

	--*/
	//////////////////////////////////////////////////////////////////////////////
	WORKER_THREAD_STATUS GetWorkerThreadStatus( void )
	{
		ATLTRACE(_T("# CDialogWithWorkerThread::GetWorkerThreadStatus\n"));

		return m_wtsWorkerThreadStatus;
	}



protected:


	
	//////////////////////////////////////////////////////////////////////////////
	/*++

	DoWorkerThreadAction

	This is called by the worker thread.  Override in your derived class and
	perform the actions you want your worker thread to do.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual DWORD DoWorkerThreadAction()
	{
		ATLTRACE(_T("# CDialogWithWorkerThread::StartWorkerThread -- override in your derived class\n"));

		return 0;
	}

	
	//////////////////////////////////////////////////////////////////////////////
	/*++

	PostMessageToMainThread

	Use this from your worker thread (i.e. within your DoWorkerThreadAction method)
	to pass a message back to the main MMC thread.  What you send in wParam and lParam
	will be passed to your OnReceiveThreadMessage method. 

	You should have no need to override this.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	BOOL PostMessageToMainThread( WPARAM wParam, LPARAM lParam )
	{
		ATLTRACE(_T("# CDialogWithWorkerThread::PostMessageToMainThread\n"));

		// Check to make sure that this window still exists.
		if( !::IsWindow(m_hWnd) )
		{
			return FALSE;
		}
		else
		{
			return( PostMessage( WORKER_THREAD_MESSAGE, wParam, lParam) );
		}

	}

	
	/////////////////////////////////////////////////////////////////////////////
	/*++

	CDialogWithWorkerThread::OnReceiveThreadMessage

	This is the sink for messages sent to the main thread from the worker thread.
	
	Since messages are received here through the Windows message pump, your 
	worker thread can pass messages that will be received and processed within
	the main MMC context.  So do anything you need to do with MMC interface pointers
	here.

	Override in your derived class and process any messages your worker thread might send.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual LRESULT OnReceiveThreadMessage(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		)
	{
		ATLTRACE(_T("# CDialogWithWorkerThread::OnReceiveThreadMessage\n"));

		return 0;
	}



	WORKER_THREAD_STATUS m_wtsWorkerThreadStatus;


private:



	//////////////////////////////////////////////////////////////////////////////
	/*++

	WorkerThreadFunc

	You should not need to override this function.  It is passed to the 
	thread creation API call as the thread start procedure in StartWorkerThread.
	
	It is passed a pointer to 'this' of this class, which it casts and calls
	DoWorkerThreadAction on.  Override DoWorkerThreadAction in your derived class.

	--*/
	//////////////////////////////////////////////////////////////////////////////
// Use of _beginthread instead of CreateThread requires different declaration.
//	static DWORD WINAPI WorkerThreadFunc( LPVOID lpvThreadParm )
	static void _cdecl WorkerThreadFunc( LPVOID lpvThreadParm )
	{
		ATLTRACE(_T("# WorkerThreadFunc -- no need to override.\n"));
		
		// Check for preconditions:
		_ASSERTE( lpvThreadParm != NULL );


		DWORD dwReturnValue;

		// The lpvThreadParm we were passed will be a pointer to 'this' for T.
		T * pT = static_cast<T*>(lpvThreadParm);
		
		pT->AddRef();
		dwReturnValue = pT->DoWorkerThreadAction();

		// Call Release with bOwner = FALSE -- we are not the owning thread.
		pT->Release(FALSE);

// This is bad -- we don't want to clobber whatever value the DoWorkerThreadAction
// assigned to m_wtsWorkerThreadStatus -- it is reponsible for saying whether the
// task was finished properly.
//		pT->m_wtsWorkerThreadStatus = WORKER_THREAD_FINISHED;

// Use of _beginthread instead of CreateThread requires different declaration.
//		return dwReturnValue;
	}


	unsigned long m_ulWorkerThread; 

	LONG m_lRefCount;


};


#endif // _IAS_DIALOG_WITH_WORKER_THREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\dlgcshlp.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

   Dialog.h

Abstract:

   Header file for the CIASDialog template class.

Author:

    Michael A. Maguire 02/03/98

Revision History:
   mmaguire 02/03/98 - abstracted from CAddClientDialog class
   tperraut 08/2000  - added CHelpPageEx 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_DLG_CS_HELP_H_)
#define _DLG_CS_HELP_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

//=============================================================================
// Global Help Table for many Dialog IDs
//

#include <afxdlgs.h>
#include "hlptable.h"

//=============================================================================
// Dialog that handles Context Help -- uses MFC
//
class CHelpDialog : public CDialog  // talk back to property sheet
{
   DECLARE_DYNCREATE(CHelpDialog)
// Implementation
protected:
   // Generated message map functions
   //{{AFX_MSG(CHelpDialog)
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
   
public:  
   CHelpDialog(UINT nIDTemplate = 0, CWnd* pParent = NULL) : CDialog(nIDTemplate, pParent)
   {
      SET_HELP_TABLE(nIDTemplate);     
   };
protected:

#ifdef   _DEBUG
   virtual void Dump( CDumpContext& dc ) const
   {
      dc << _T("CHelpDialog");
   };
#endif   

protected:
   const DWORD*            m_pHelpTable;
};


//=============================================================================
// Page that handles Context Help, -- USING MFC
//
class CHelpPage : public CPropertyPage // talk back to property sheet
{
// Implementation
protected:
   // Generated message map functions
   //{{AFX_MSG(CHelpPage)
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
   
public:  
   CHelpPage(UINT nIDTemplate = 0) : CPropertyPage(nIDTemplate)
   {
      SET_HELP_TABLE(nIDTemplate);     
   };


#ifdef   _DEBUG
   virtual void Dump( CDumpContext& dc ) const
   {
      dc << _T("CHelpPage");
   };

#endif

protected:
   const DWORD*            m_pHelpTable;

};

//=============================================================================
// Page that handles Context Help, -- USING MFC
//
class CHelpPageEx : public CPropertyPageEx   // talk back to property sheet
{
// Implementation
protected:
   // Generated message map functions
   //{{AFX_MSG(CHelpPageEx)
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
   
public:  
   CHelpPageEx(UINT nIDTemplate = 0, bool helpEnabled = true) 
      : CPropertyPageEx(nIDTemplate),
        m_bHelpEnabled(helpEnabled)
   {
      if (m_bHelpEnabled)
      {
         SET_HELP_TABLE(nIDTemplate);     
      }
   };

   CHelpPageEx(
      UINT nIDTemplate, 
      UINT nIDCaption = 0, 
      UINT nIDHeaderTitle = 0, 
      UINT nIDHeaderSubTitle = 0,
      bool helpEnabled = true) 
      : CPropertyPageEx(nIDTemplate, nIDCaption, nIDHeaderTitle, nIDHeaderSubTitle),
        m_bHelpEnabled(helpEnabled)

   {
      if (m_bHelpEnabled)
      {
         SET_HELP_TABLE(nIDTemplate);     
      }
   };

#ifdef   _DEBUG
   virtual void Dump( CDumpContext& dc ) const
   {
      dc << _T("CHelpPageEx");
   };

#endif

protected:
   const DWORD*   m_pHelpTable;
   bool  m_bHelpEnabled;

};

#endif // _DLG_CS_HELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\enumformatetc.cpp ===
/*
 * EnumFormatEtc.cpp
 * Data Object Chapter 10
 *
 * Standard implementation of a FORMATETC enumerator with the
 * IEnumFORMATETC interface that will generally not need
 * modification.
 *
 * Copyright (C)1993-1995 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Microsoft
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */

#include "Precompiled.h"

#include "EnumFormatEtc.h"

/*
 * CEnumFormatEtc::CEnumFormatEtc
 * CEnumFormatEtc::~CEnumFormatEtc
 *
 * Parameters (Constructor):
 *  cFE             ULONG number of FORMATETCs in pFE
 *  prgFE           LPFORMATETC to the array to enumerate.
 */

CEnumFormatEtc::CEnumFormatEtc(ULONG cFE, LPFORMATETC prgFE)
    {
    UINT        i;

    m_cRef=0;
    m_iCur=0;
    m_cfe=cFE;
    m_prgfe=new FORMATETC[(UINT)cFE];

    if (NULL!=m_prgfe)
        {
        for (i=0; i < cFE; i++)
            m_prgfe[i]=prgFE[i];
        }

    return;
    }


CEnumFormatEtc::~CEnumFormatEtc(void)
    {
    if (NULL!=m_prgfe)
        delete [] m_prgfe;

    return;
    }






/*
 * CEnumFormatEtc::QueryInterface
 * CEnumFormatEtc::AddRef
 * CEnumFormatEtc::Release
 *
 * Purpose:
 *  IUnknown members for CEnumFormatEtc object.  For QueryInterface
 *  we only return out own interfaces and not those of the data
 *  object.  However, since enumerating formats only makes sense
 *  when the data object is around, we insure that it stays as
 *  long as we stay by calling an outer IUnknown for AddRef
 *  and Release.  But since we are not controlled by the lifetime
 *  of the outer object, we still keep our own reference count in
 *  order to free ourselves.
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface(REFIID riid, VOID ** ppv)
    {
    *ppv=NULL;

    /*
     * Enumerators are separate objects, not the data object, so
     * we only need to support out IUnknown and IEnumFORMATETC
     * interfaces here with no concern for aggregation.
     */
    if (IID_IUnknown==riid || IID_IEnumFORMATETC==riid)
        *ppv=this;

    //AddRef any interface we'll return.
    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef(void)
    {
    ++m_cRef;
    return m_cRef;
    }

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release(void)
    {
    if (0!=--m_cRef)
        return m_cRef;

    delete this;
    return 0;
    }







/*
 * CEnumFormatEtc::Next
 *
 * Purpose:
 *  Returns the next element in the enumeration.
 *
 * Parameters:
 *  cFE             ULONG number of FORMATETCs to return.
 *  pFE             LPFORMATETC in which to store the returned
 *                  structures.
 *  pulFE           ULONG * in which to return how many we
 *                  enumerated.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE otherwise,
 */

STDMETHODIMP CEnumFormatEtc::Next(ULONG cFE, LPFORMATETC pFE
    , ULONG *pulFE)
    {
    ULONG               cReturn=0L;

    if (NULL==m_prgfe)
        return ResultFromScode(S_FALSE);

    if (NULL==pulFE)
        {
        if (1L!=cFE)
            return ResultFromScode(E_POINTER);
        }
    else
        *pulFE=0L;

    if (NULL==pFE || m_iCur >= m_cfe)
        return ResultFromScode(S_FALSE);

    while (m_iCur < m_cfe && cFE > 0)
        {
        *pFE++=m_prgfe[m_iCur++];
        cReturn++;
        cFE--;
        }

    if (NULL!=pulFE)
        *pulFE=cReturn;

    return NOERROR;
    }







/*
 * CEnumFormatEtc::Skip
 *
 * Purpose:
 *  Skips the next n elements in the enumeration.
 *
 * Parameters:
 *  cSkip           ULONG number of elements to skip.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE if we could not
 *                  skip the requested number.
 */

STDMETHODIMP CEnumFormatEtc::Skip(ULONG cSkip)
    {
    if (((m_iCur+cSkip) >= m_cfe) || NULL==m_prgfe)
        return ResultFromScode(S_FALSE);

    m_iCur+=cSkip;
    return NOERROR;
    }






/*
 * CEnumFormatEtc::Reset
 *
 * Purpose:
 *  Resets the current element index in the enumeration to zero.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR
 */

STDMETHODIMP CEnumFormatEtc::Reset(void)
    {
    m_iCur=0;
    return NOERROR;
    }






/*
 * CEnumFormatEtc::Clone
 *
 * Purpose:
 *  Returns another IEnumFORMATETC with the same state as ourselves.
 *
 * Parameters:
 *  ppEnum          LPENUMFORMATETC * in which to return the
 *                  new object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CEnumFormatEtc::Clone(LPENUMFORMATETC *ppEnum)
    {
    PCEnumFormatEtc     pNew;

    *ppEnum=NULL;

    //Create the clone
    pNew=new CEnumFormatEtc(m_cfe, m_prgfe);

    if (NULL==pNew)
        return ResultFromScode(E_OUTOFMEMORY);

    pNew->AddRef();
    pNew->m_iCur=m_iCur;

    *ppEnum=pNew;
    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\enumformatetc.h ===
/*
 * EnumFormatEtc.h
 * Data Object Chapter 10
 *
 * Standard implementation of a FORMATETC enumerator with the
 * IEnumFORMATETC interface that will generally not need
 * modification.
 *
 * Copyright (C)1993-1995 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Microsoft
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */

#if !defined(_IAS_ENUM_FORMAT_ETC_H_)
#define _IAS_ENUM_FORMAT_ETC_H_



/*
 * IEnumFORMATETC object that is created from
 * IDataObject::EnumFormatEtc.  This object lives on its own.
 */

class CEnumFormatEtc : public IEnumFORMATETC
    {
    private:
        ULONG           m_cRef;         //Object reference count
        ULONG           m_iCur;         //Current element.
        ULONG           m_cfe;          //Number of FORMATETCs in us
        LPFORMATETC     m_prgfe;        //Source of FORMATETCs

    public:
        CEnumFormatEtc(ULONG, LPFORMATETC);
        ~CEnumFormatEtc(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, VOID **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IEnumFORMATETC members
        STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG *);
        STDMETHODIMP Skip(ULONG);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IEnumFORMATETC **);
    };


typedef CEnumFormatEtc *PCEnumFormatEtc;


#endif // _IAS_ENUM_FORMAT_ETC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\enumtask.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    EnumTask.h

Abstract:

	This header file implements the IEnumTASKImpl template class.
	This base class implements an enumerator for tasks to populate a taskpad.

	This is an inline template class, there is no cpp class for implementation.

Author:

    Michael A. Maguire 02/05/98

Revision History:
	mmaguire 02/05/98 -  created from MMC taskpad sample code


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_ENUM_TASKS_H_)
#define _IAS_ENUM_TASKS_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


template < class T >
class IEnumTASKImpl : public IEnumTASK
{

public:
	IEnumTASKImpl()
	{
		ATLTRACE(_T("# IEnumTASKImpl::IEnumTASKImpl\n"));

		m_refs = 0;
		m_index = 0;
		m_type = 0;    // default group/category

	}
	
	~IEnumTASKImpl()
	{
		ATLTRACE(_T("# IEnumTASKImpl::~IEnumTASKImpl\n"));

	}

	// IUnknown implementation
public:
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj)
	{
		ATLTRACE(_T("# IEnumTASKImpl::QueryInterface\n"));

		if ( (riid == IID_IUnknown)  ||	(riid == IID_IEnumTASK) )
		{
			*ppvObj = this;
			((LPUNKNOWN)(*ppvObj))->AddRef();
			return NOERROR;
		}
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	STDMETHOD_(ULONG, AddRef)()
	{
		ATLTRACE(_T("# IEnumTASKImpl::AddRef\n"));

		return ++m_refs;
	}

	STDMETHOD_(ULONG, Release) ()
	{
		ATLTRACE(_T("# IEnumTASKImpl::Release\n"));

		T * pT = static_cast<T*>(this);
		if (--m_refs == 0)
		{
			delete pT;
			return 0;
		}
		return m_refs;
	}

private:
	ULONG m_refs;


	// IEnumTASKS implementation
public:
	STDMETHOD(Next) (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched)
	{
		ATLTRACE(_T("# IEnumTASKImpl::Next -- Override in your derived class\n"));

		if ( NULL != pceltFetched)
		{
			*pceltFetched = 0;
		}

		return S_FALSE;   // Failed to enumerate any more tasks.
	}

	STDMETHOD(Skip) (ULONG celt)
	{
		ATLTRACE(_T("# IEnumTASKImpl::Skip\n"));

		m_index += celt;
		return S_OK;
	}

	STDMETHOD(Reset)()
	{
		ATLTRACE(_T("# IEnumTASKImpl::Reset\n"));

		m_index = 0;
		return S_OK;
	}

	STDMETHOD(Clone)(IEnumTASK **ppEnumTASK)
	{
		ATLTRACE(_T("# IEnumTASKImpl::Clone\n"));

		// Clone maintaining state info 
		T * pEnumTasks = new T();
		if( pEnumTasks ) 
		{
			pEnumTasks->CopyState( (T *) this );
			return pEnumTasks->QueryInterface (IID_IEnumTASK, (void **)ppEnumTASK);   // can't fail
		}
		return E_OUTOFMEMORY;
	}


	STDMETHOD(CopyState)( T * pSourceT)
	{
		ATLTRACE(_T("# IEnumTASKImpl::CopyState\n"));

		m_index = pSourceT->m_index;
		m_type = pSourceT->m_type;

		return S_OK;
	}



protected:
	ULONG m_index;


public:
	STDMETHOD(Init)(IDataObject * pdo, LPOLESTR szTaskGroup)
	{
		ATLTRACE(_T("# IEnumTASKImpl::Init -- Override in your derived class\n"));

		return S_OK;
	}

protected:
	int m_type; // Task grouping mechanism.

};


#endif // _IAS_ENUM_TASKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\hlptable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       hlptable.h
//
//--------------------------------------------------------------------------

#ifndef		__GLOBAL_HELP_TABLE__
#define		__GLOBAL_HELP_TABLE__
//=============================================================================
// Global Help Table for many Dialog IDs
//

#define SET_HELP_TABLE(nIDD)	m_pHelpTable = ::FindHelpTable(__pGlobalCSHelpTable, nIDD)
#define	DLG_HELP_ENTRY(nIDD)	{nIDD, g_aHelpIDs_##nIDD}

struct CGlobalHelpTable{
	UINT	nIDD;
	const DWORD	*pdwTable;
};

inline const DWORD* FindHelpTable(const CGlobalHelpTable *pGTable, UINT nIDD)
{
		const DWORD*	pdwTable = NULL;
		if(pGTable)
		{
			while(pGTable->nIDD && pGTable->nIDD != nIDD)
				pGTable++;
			if(pGTable->nIDD)
				pdwTable = pGTable->pdwTable;
		}

		return pdwTable;
};

extern const CGlobalHelpTable __pGlobalCSHelpTable[];


#endif		//__GLOBAL_HELP_TABLE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\mmcutility.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    MMCUtility.cpp

Abstract:

	Implementation file for functions doing various handy things
	that were getting written over and over again.


Author:

    Michael A. Maguire 02/05/98

Revision History:
	mmaguire 02/05/98 - created
	mmaguire 11/03/98 - moved GetSdo/PutSdo wrappers to sdohelperfuncs.cpp

--*/
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "MMCUtility.h"
#include "cnctdlg.h"
//
//
// where we can find declarations needed in this file:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

HRESULT BringUpPropertySheetForNode(
				  CSnapInItem *pSnapInItem
				, IComponentData *pComponentData
				, IComponent *pComponent
				, IConsole *pConsole
				, BOOL bCreateSheetIfOneIsntAlreadyUp = FALSE
				, LPCTSTR lpszSheetTitle = NULL
				, BOOL bPropertyPage = TRUE // TRUE creates property page, FALSE wizard page.
				);


Tries to bring up a property sheet on a given node.  If the sheet for the
node is already up, it will bring that sheet to the foreground.


Parameters:

pSnapInItem

	You must supply a pointer to the node you want the sheet for.


pComponentData, pComponent

	Either you call with pComponentData != NULL and pComponent == NULL
	or pComponentData == NULL and pComponent != NULL.

pConsole

	You must supply a pointer to an IConsole interface.

bCreateSheetIfOneIsntAlreadyUp

	TRUE - if a sheet isn't already up, will try to create a property sheet
	for you -- in this case you _must_ specify a title for the
	sheet in lpszSheetTitle.

	FALSE - will try to bring already existing sheet to foreground, but
	will return immediately	if there isn't one.

bPropertyPage

	TRUE for property pages. (Note: MMC creates property sheet in new thread.)
	FALSE for wizard pages.  (Note: Wizard pages run in same thread.)


Return:

	S_OK if found property sheet already up.
	S_FALSE if didn't find sheet already up but successfully made new one appear.
	E_... if some error error occurred.


Remarks:
	
	For this function's to work, you must have correctly implemented
	IComponentData::CompareObjects and IComponentData::CompareObjects.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT BringUpPropertySheetForNode(
				  CSnapInItem *pSnapInItem
				, IComponentData *pComponentData
				, IComponent *pComponent
				, IConsole *pConsole
				, BOOL bCreateSheetIfOneIsntAlreadyUp
				, LPCTSTR lpszSheetTitle
				, BOOL bPropertyPage
				, DWORD dwPropertySheetOptions
				)
{
	ATLTRACE(_T("# BringUpPropertySheetForNode\n"));

	
	// Check for preconditions:
	_ASSERTE( pSnapInItem != NULL );

	// We need one or the other to be non-NULL
	_ASSERTE( pComponentData != NULL || pComponent != NULL );
	_ASSERTE( pConsole != NULL );


	HRESULT hr;
	
	// Query IConsole for the needed interface.
	CComQIPtr<IPropertySheetProvider, &IID_IPropertySheetProvider> spPropertySheetProvider( pConsole );
	_ASSERTE( spPropertySheetProvider != NULL );


	CComPtr<IDataObject> spDataObject;

	hr = pSnapInItem->GetDataObject( &spDataObject, CCT_RESULT );
	if( FAILED( hr ) )
	{
		return hr;
	}

	// This returns S_OK if a property sheet for this object already exists
	// and brings that property sheet to the foreground.
	// It returns S_FALSE if the property sheet wasn't found.
	// If this is coming in through my IComponent object, I pass the pComponent pointer.
	// If this is coming in through my IComponentData object,
	// then pComponent is NULL, which is the appropriate value to pass in for
	// the call to FindPropertySheet when coming in through IComponentData.
	hr = spPropertySheetProvider->FindPropertySheet(
									  (MMC_COOKIE) pSnapInItem   // cookie
									, pComponent
									, spDataObject
									);

	if( FAILED( hr ) )
	{
		return hr;
	}


	if( S_OK == hr || FALSE == bCreateSheetIfOneIsntAlreadyUp )
	{
		// We found a property sheet already up for this node,
		// or we didn't find one but we weren't asked to create one.
		return hr;
	}


	// We didn't find a property sheet already up for this node.
	_ASSERTE( S_FALSE == hr );


	hr = spPropertySheetProvider->CreatePropertySheet(
										  lpszSheetTitle
										, (BOOLEAN)bPropertyPage /* TRUE == prop page, FALSE == wizard */
										, (MMC_COOKIE) pSnapInItem   // cookie
										, spDataObject
										, dwPropertySheetOptions
										);
	if( FAILED( hr ) )
	{
		return hr;
	}

	HWND hWndNotification;
	HWND hWndMain;

	hr = pConsole->GetMainWindow( & hWndMain );

	if( FAILED( hr ) )
	{
		return hr;
	}

	// Try to get the correct window that notifications should be sent to.
	hWndNotification = FindWindowEx( hWndMain, NULL, L"MDIClient", NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, L"MMCChildFrm", NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, L"MMCView", NULL );
	
	if( NULL == hWndNotification  )
	{
		// It was a nice try, but it failed, so we should be able to get by by using the main HWND.
		hWndNotification = hWndMain;
	}



    hr = spPropertySheetProvider->AddPrimaryPages(
													  (pComponent != NULL ? (LPUNKNOWN) pComponent : (LPUNKNOWN) pComponentData )
													, TRUE
													, hWndNotification
													, (pComponent != NULL ? FALSE : TRUE )
													);
	if( FAILED( hr ) )
	{
		// Release data allocated in CreatePropertySheet
		spPropertySheetProvider->Show( -1, 0);
		return hr;
	}

    hr = spPropertySheetProvider->AddExtensionPages();
	if( FAILED( hr ) )
	{
		// ISSUE: Should I care if this fails?

		// Release data allocated in CreatePropertySheet
		spPropertySheetProvider->Show( -1, 0);
		return hr;
	}

    hr = spPropertySheetProvider->Show( (LONG_PTR) hWndMain, 0);
	if( FAILED( hr ) )
	{
		return hr;
	}

	return hr;

}



int ShowErrorDialog(
					  HWND hWnd
					, UINT uErrorID
					, BSTR bstrSupplementalErrorString
					, HRESULT hr
					, UINT uTitleID
					, IConsole *pConsole
					, UINT uType
					)
//////////////////////////////////////////////////////////////////////////////
/*++

Puts up an error dialog with varying degrees of detail

Parameters:

	All parameters are optional -- in the worst case, you can simply call
		
		  ShowErrorDialog();

	to put up a very generic error message.


uErrorID

	The resource ID of the string to be used for the error message.
	Passing in USE_DEFAULT gives causes the default error message to be displayed.
	Passing in USE_SUPPLEMENTAL_ERROR_STRING_ONLY causes no resource string text to be displayed.

bstrSupplementalErrorString

	Pass in a string to print as the error message.  Useful if you are
	receiving an error string from some other component you communicate with.

hr

	If there is an HRESULT involved in the error, pass it in here so that
	a suitable error message based on the HRESULT can be put up.
	Pass in S_OK if the HRESULT doesn't matter to the error.


uTitleID

	The resource ID of the string to be used for the error dialog title.
	Passing in USE_DEFAULT gives causes the default error dialog title to be displayed.

pConsole

	If you are running within the main MMC context, pass in a valid IConsole pointer
	and ShowErrorDialog will use MMC's IConsole::MessageBox rather than the
	standard system MessageBox.

hWnd
	
	Whatever you pass in here will be passed in as the HWND parameter
	to the MessageBox call.
	This is not used if you pass in an IConsole pointer.

uType

	Whatever you pass in here will be passed in as the HWND parameter
	to the MessageBox call.


Return:

	The standard int returned from MessageBox.

	

--*/
//////////////////////////////////////////////////////////////////////////////
{
	ATLTRACE(_T("# ShowErrorDialog\n"));

	
	// Check for preconditions:
	// None.

	int iReturnValue;
	TCHAR szError[IAS_MAX_STRING*2];
	TCHAR szTitle[IAS_MAX_STRING*2];
	int iLoadStringResult;

	szError[0] = NULL;
	szTitle[0] = NULL;


	HINSTANCE hInstance = _Module.GetResourceInstance();


	if( USE_DEFAULT == uTitleID )
	{
		uTitleID = IDS_ERROR__GENERIC_TITLE;
	
	}

	iLoadStringResult = LoadString(  hInstance, uTitleID, szTitle, IAS_MAX_STRING );
	_ASSERT( iLoadStringResult > 0 );



	if( USE_SUPPLEMENTAL_ERROR_STRING_ONLY == uErrorID )
	{
		// Special case.  We have no text to load from the resources.
	}
	else
	{

		if( USE_DEFAULT == uErrorID )
		{
			uErrorID = IDS_ERROR__GENERIC;
		}

		iLoadStringResult = LoadString(  hInstance, uErrorID, szError, IAS_MAX_STRING*2 );
		_ASSERT( iLoadStringResult > 0 );

		if( NULL != bstrSupplementalErrorString )
		{
			// Add some spacing.
			_tcscat( szError, _T(" ") );
		}

	}
		


	if( NULL != bstrSupplementalErrorString )
	{

		// We were passed a string with supplemental error info.
		_tcscat( szError, bstrSupplementalErrorString );

	}


	if( FAILED( hr ) )
	{
#if 0	// change to display system wide error info
		// The HRESULT contains some information about the kind of failure.

		// We may want to change this later to provide more information
		// information based on the error that was returned.

		// We could have a map which defines relationships between error
		// ID's and the HRESULTS.  That way we could provide the appropriate
		// error message for each HRESULT based on the context of which ID
		// was passed in.

		// For now, just print the error ID.

		TCHAR szErrorNumber[IAS_MAX_STRING];

		_stprintf( szErrorNumber, _T(" 0x%x"), hr );

		// Some spacing.
		_tcscat( szError, _T(" ") );

		_tcscat( szError, szErrorNumber );
#endif
		PTSTR	ptzSysMsg;
		int		cch;

		cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
						NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						(PTSTR)&ptzSysMsg, 0, NULL);

		if (!cch) { //try ads errors
			HMODULE		adsMod;
			adsMod = GetModuleHandle (L"odbc32.dll");
			cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, 
						adsMod, hr,	MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						(PTSTR)&ptzSysMsg, 0, NULL);
		}

		if(cch)	// found
		{
			_tcscat( szError, _T(" ") );

			_tcscat( szError, ptzSysMsg );

			LocalFree( ptzSysMsg );
		}
		else
		{
			TCHAR szErrorNumber[IAS_MAX_STRING];

			if(hr == DB_E_NOTABLE)	// assume, the RPC connection has problem
				iLoadStringResult = LoadString(  hInstance, IDS_ERROR__RESTART_SNAPIN, szErrorNumber, IAS_MAX_STRING );
			else
			{
				_stprintf( szErrorNumber, _T(" 0x%x"), hr );

				// Some spacing.
				_tcscat( szError, _T(" ") );

				_tcscat( szError, szErrorNumber );
			}
		}
	}




	// Put the error message up in the appropriate manner depending on our context.
	if( pConsole != NULL )
	{
		pConsole->MessageBox( szError, szTitle, uType, &iReturnValue );
	}
	else
	{
		// ISSUE: Do we want to do anything special if hWnd == NULL?
		// Or just pass the NULL right on to MessageBox?
		iReturnValue = ::MessageBox( hWnd, szError, szTitle, uType );
	}

	return iReturnValue;
}



BOOL   GetUserAndDomainName(	LPTSTR UserName
				, LPDWORD cchUserName
				, LPTSTR DomainName
				, LPDWORD cchDomainName
				)
//////////////////////////////////////////////////////////////////////////////
/*++

Retrieves current user's username and domain.

Stolen from Knowledge Base HOWTO article:

HOWTO: Look Up Current User Name and Domain Name
Rollup: WINPROG
Database: win32sdk
Article ID: Q155698
Last modified: June 16, 1997
Security: PUBLIC


--*/
//////////////////////////////////////////////////////////////////////////////
{
	HANDLE hToken;
	#define MY_BUFSIZE 512  // highly unlikely to exceed 512 bytes
	UCHAR InfoBuffer[ MY_BUFSIZE ];
	DWORD cbInfoBuffer = MY_BUFSIZE;
	SID_NAME_USE snu;
	BOOL bSuccess;

	if( !OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) )
	{
		if(GetLastError() == ERROR_NO_TOKEN)
		{
			//
			// attempt to open the process token, since no thread token
			// exists
			//
			if(!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
				return FALSE;
		}
		else
		{
			//
			// error trying to get thread token
			//
			return FALSE;
		}
	}

	bSuccess = GetTokenInformation( hToken, TokenUser, InfoBuffer, cbInfoBuffer, &cbInfoBuffer );
	if(!bSuccess)
	{
		if( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
		{
			//
			// alloc buffer and try GetTokenInformation() again
			//
               		CloseHandle(hToken);
			return FALSE;
		}
		else
		{
			//
			// error getting token info
			//
			CloseHandle(hToken);
			return FALSE;
		}
	}

	CloseHandle(hToken);

	return LookupAccountSid( NULL
				, ((PTOKEN_USER)InfoBuffer)->User.Sid
				, UserName
				, cchUserName
				, DomainName
				, cchDomainName
				, &snu
				);
}


//////////////////////////////////////////////////////////////////////////////
/*++

	Decide if the service is installed

*/


HRESULT   IfServiceInstalled(LPCTSTR lpszMachine, LPCTSTR lpszService, BOOL* pBool)
{
	if(!lpszService || !pBool)	return E_INVALIDARG;
	
	SC_HANDLE	schMgr = NULL;
	SC_HANDLE	schSvc = NULL;
	HRESULT		hr = S_OK;

	// OPen service manager
	schMgr = OpenSCManager(lpszMachine, SERVICES_ACTIVE_DATABASE, GENERIC_READ);

	while(schMgr == NULL)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		if(hr == E_ACCESSDENIED)
		{
			hr = ConnectAsAdmin(lpszMachine);
			if(hr == S_FALSE)	// user chose cancel on the passwd dialog
				hr = E_ACCESSDENIED;
		}
		if(hr != S_OK)
		{
			goto Error;
		}
		else
			schMgr = OpenSCManager(lpszMachine, SERVICES_ACTIVE_DATABASE, GENERIC_READ);
	}

	// try to open the service
	schSvc = OpenService(schMgr, lpszService, READ_CONTROL);
	if(schSvc == NULL)
	{
		DWORD	dwErr = GetLastError();

		if(dwErr == ERROR_SERVICE_DOES_NOT_EXIST)
		{
			*pBool = FALSE;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(dwErr);
		}
	}
	else
	{
		*pBool = TRUE;
	}
	
Error:
	if(schMgr)	CloseServiceHandle(schMgr);
	if(schSvc)	CloseServiceHandle(schSvc);
	return hr;
}


/*!--------------------------------------------------------------------------
	GetModuleFileNameOnly
		-
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
DWORD GetModuleFileNameOnly(HINSTANCE hInst, LPTSTR lpFileName, DWORD nSize )
{
	CString	name;
	TCHAR	FullName[MAX_PATH * 2];
	DWORD	dwErr = ::GetModuleFileName(hInst, FullName, MAX_PATH * 2);

	if (dwErr != 0)
	{
		name = FullName;
		DWORD	FirstChar = name.ReverseFind(_T('\\')) + 1;

		name = name.Mid(FirstChar);
		DWORD len = name.GetLength();

		if( len < nSize )
		{
			_tcscpy(lpFileName, name);
		}
		else
			len = 0;

		return len;
	}
	else
		return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\nodewithresultchildrenlist.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    NodeWithResultChildrenList.h

Abstract:

   This is the header file for CNodeWithResultChildrenList, a class which
   implements a node that has a list of scope pane children.

   This is an inline template class.
   Include NodeWithScopeChildrenList.cpp in the .cpp files
   of the classes in which you use this template.

Author:

    Michael A. Maguire 12/03/97

Revision History:
   mmaguire 12/03/97 - created based on old ClientsNode.h


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_RESULT_CHILDREN_LIST_H_)
#define _NODE_WITH_RESULT_CHILDREN_LIST_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "SnapinNode.h"
//
//
// where we can find what this class has or uses:
//
#include <atlapp.h>        // for CSimpleArray
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


template < class T, class CChildNode, class TArray, class TComponentData, class TComponent>
class CNodeWithResultChildrenList : public CSnapinNode< T, TComponentData, TComponent >
{

   // Constructor/Destructor

public:
   CNodeWithResultChildrenList(
                                 CSnapInItem* pParentNode, 
                                 unsigned int helpIndex = 0
                              );
   ~CNodeWithResultChildrenList();


   // Child list management.

public:
   virtual HRESULT AddSingleChildToListAndCauseViewUpdate( CChildNode * pChildNode );
   virtual HRESULT RemoveChild( CChildNode * pChildNode );
   virtual void RemoveChildrenNoRefresh();
   virtual HRESULT UpdateResultPane(IResultData * pResultData);
   
   // Flag indicating whether list has been initially populated
   BOOL m_bResultChildrenListPopulated;
protected:
   // Override these in your derived classes
   virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
   virtual HRESULT PopulateResultChildrenList( void );
   virtual HRESULT RepopulateResultChildrenList( void );
   // Stuff which must be accessible to subclasses.  These methods shouldn't need to be overidden.
   virtual HRESULT AddChildToList( CChildNode * pChildNode );
   virtual HRESULT EnumerateResultChildren( IResultData * pResultData );
   // Array of pointers to children nodes.
   // This is protected so that it can be visible in the derived classes.
   TArray m_ResultChildrenList;



   // Overrides for standard MMC functionality. 
public:
   virtual HRESULT OnShow( 
                 LPARAM arg
               , LPARAM param
               , IComponentData * pComponentData
               , IComponent * pComponent
               , DATA_OBJECT_TYPES type
               );
   virtual HRESULT OnRefresh( 
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );



};


#endif // _NODE_WITH_RESULT_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\nodewithscopechildrenlist.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    NodeWithScopeChildrenList.cpp

Abstract:

	Implementation file for the CNodeWithScopeChildrenList subclass.

	This is the implementation portion of an inline template class.
	Include it in the .cpp file of the class in which you want to
	use the template.

Author:

    Michael A. Maguire 12/01/97

Revision History:
	mmaguire 12/01/97 - abstracted from CRootNode, which will be changed to subclass this class

--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//

//
// where we can find declaration for main class in this file:
//
#include "NodeWithScopeChildrenList.h"
//
//
// where we can find declarations needed in this file:
//
#include "SnapinNode.cpp"	// Template class implementation
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////
	


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::AddChild

Adds a child to the list of children.

This has to be public as it must be accessible even from a separate dialog
(e.g. a Connect to Server dialog) that may want to add a child.

Here we add the child item to the list of children and call InsertItem
to add the child to the scope pane.

This is one difference between adding nodes into the scope
pane and the result pane.  When we were inserting a child into
the result pane, we didn't call InsertItem in the AddChild methods(s)
because we needed to worry about sending an UpdataAllViews
notification and repopulating the result pane in each view.

Because MMC takes care of replicating scope pane changes to all views,
we don't need to worry about this.  Instead, we just do InsertItem once here.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode >
HRESULT CNodeWithScopeChildrenList<T,CChildNode>::AddChild( CChildNode * pChildNode )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::AddChild\n"));
	

	// Check for preconditions:
	// None.


	HRESULT hr = S_OK;
	
	if( m_ScopeChildrenList.Add( pChildNode ) )
	{

		// Insert the item into the result pane now
		// so that the new item will show up immediately

		CComponentData *pComponentData = GetComponentData();
		_ASSERTE(pComponentData != NULL );

		// Need IConsoleNameSpace
		CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace( pComponentData->m_spConsole );
		_ASSERT( spConsoleNameSpace != NULL );

		// We hand our HSCOPEITEM as the parent ID for this child.
		pChildNode->m_scopeDataItem.relativeID = (HSCOPEITEM) m_scopeDataItem.ID;

		hr = spConsoleNameSpace->InsertItem( &(pChildNode->m_scopeDataItem) );
		if (FAILED(hr))
		{
			return hr;
		}

		// Check: On return, the ID member of 'm_scopeDataItem'
		// contains the handle to the newly inserted item.
		_ASSERT( NULL != pChildNode->m_scopeDataItem.ID );

	}
	else
	{
		// Failed to add => out of memory
		hr = E_OUTOFMEMORY;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::RemoveChild

Removes a child from the list of children.

This has to be public so that child nodes can ask their parent to be deleted
from the list of children when they receive the MMCN_DELETE notification.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode >
HRESULT CNodeWithScopeChildrenList<T,CChildNode>::RemoveChild( CChildNode * pChildNode )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::RemoveChild\n"));
	

	// Check for preconditions:
	// None.


	HRESULT hr = S_OK;


	if( m_ScopeChildrenList.Remove( pChildNode ) )
	{

		// Need IConsoleNameSpace
		CComponentData *pComponentData = GetComponentData();
		_ASSERTE(pComponentData != NULL );

		CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace( pComponentData->m_spConsole );
		_ASSERT( spConsoleNameSpace != NULL );

		hr = spConsoleNameSpace->DeleteItem( pChildNode->m_scopeDataItem.ID, TRUE );
		if (FAILED(hr))
		{
			return hr;
		}

	}
	else
	{
		// If we failed to remove, probably the child was never in the list
		// ISSUE: determine what do here -- this should never happen
		_ASSERTE( FALSE );

		hr = S_FALSE;
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

Constructor

This is an base class which we don't want instantiated on its own,
so the contructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode >
CNodeWithScopeChildrenList<T,CChildNode>::CNodeWithScopeChildrenList( CSnapInItem * pParentNode ): CSnapinNode< T >( pParentNode )
{
	ATLTRACE(_T("# +++ CNodeWithScopeChildrenList::CNodeWithScopeChildrenList\n"));
	

	// Check for preconditions:
	// None.


	// We have not yet loaded the child nodes' data
	m_bScopeChildrenListPopulated = FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode >
CNodeWithScopeChildrenList<T,CChildNode>::~CNodeWithScopeChildrenList()
{
	ATLTRACE(_T("# --- CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList\n"));
	

	// Check for preconditions:
	// None.



	// Delete each node in the list of children
	CChildNode* pChildNode;
	for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
	{
		pChildNode = m_ScopeChildrenList[i];
		delete pChildNode;
	}

	// Empty the list
	m_ScopeChildrenList.RemoveAll();

}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::PopulateScopeChildrenList

Override this in your derived class to populate the list of children nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode >
HRESULT CNodeWithScopeChildrenList<T,CChildNode>::PopulateScopeChildrenList( void )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::PopulateScopeChildren -- override in your derived class\n"));
		

	// Check for preconditions:
	// None.


	// override in your derived class and do something like:
/*
	CSomeChildNode *myChild1 = new CSomeChildNode();
	m_CChildrenList.Add(myChild1);

	CSomeChildNode *myChild2 = new CSomeChildNode();
	m_CChildrenList.Add(myChild2);

	CSomeChildNode *myChild3 = new CSomeChildNode();
	m_CChildrenList.Add(myChild3);
*/
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods
which it calls: InsertColumns

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode >
HRESULT CNodeWithScopeChildrenList<T,CChildNode>::OnShow(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type
				)
{
	ATLTRACE(_T("# CNodeScopeChildrenList::OnShow\n"));
	

	// Check for preconditions:
	_ASSERTE( pComponentData != NULL || pComponent != NULL );


	HRESULT hr = S_FALSE;

	//ISSUE: only do this if selected (arg = TRUE) -- what should we do if not selected?
	// See sburns' localsec example

	if( arg )
	{

		// arg <> 0 => we are being selected.

		// Need IHeaderCtrl.

		// But to get that, first we need IConsole
		CComPtr<IConsole> spConsole;
		if( pComponentData != NULL )
		{
			 spConsole = ((CComponentData*)pComponentData)->m_spConsole;
		}
		else
		{
			// We should have a non-null pComponent
			 spConsole = ((CComponent*)pComponent)->m_spConsole;
		}
		_ASSERTE( spConsole != NULL );

		CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
		_ASSERT( spHeaderCtrl != NULL );

		hr = InsertColumns( spHeaderCtrl );
		_ASSERT( S_OK == hr );

	}

	return hr;


}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode >
HRESULT CNodeWithScopeChildrenList<T,CChildNode>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::InsertColumns -- override in your derived class\n"));
	

	// Check for preconditions:
	_ASSERTE( pHeaderCtrl != NULL );


	HRESULT hr;

	// override in your derived class and do something like:
	hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
	_ASSERT( S_OK == hr );

	hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
	_ASSERT( S_OK == hr );

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildren::OnExpand

Don't override this in your derived class.  Instead, override methods
which it calls: PopulateScopeChildrenList

This method is an override of CSnapinNode::OnExpand.  When MMC passes the
MMCN_EXPAND method for this node, we are to add children into the
scope pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnExpand.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode >
HRESULT CNodeWithScopeChildrenList<T,CChildNode>::OnExpand(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CNodeWithScopeChildren::OnExpand\n"));
	

	// Check for preconditions:
	_ASSERTE( pComponentData != NULL || pComponent != NULL );



	HRESULT hr = S_FALSE;

	if( TRUE == arg )
	{

		// Need IConsoleNameSpace

		// But to get that, first we need IConsole
		CComPtr<IConsole> spConsole;
		if( pComponentData != NULL )
		{
			 spConsole = ((CComponentData*)pComponentData)->m_spConsole;
		}
		else
		{
			// We should have a non-null pComponent
			 spConsole = ((CComponent*)pComponent)->m_spConsole;
		}
		_ASSERTE( spConsole != NULL );


		CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
		_ASSERT( spConsoleNameSpace != NULL );

		hr = EnumerateScopeChildren( spConsoleNameSpace );

	}
	else	// arg != TRUE so not expanding
	{

		// do nothing for now -- I don't think arg = FALSE is even implemented
		// for MMC v. 1.0 or 1.1

	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithScopeChildrenList::EnumerateScopeChildren

Don't override this in your derived class. Instead, override the method
it calls, PopulateScopeChildrenList.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode >
HRESULT CNodeWithScopeChildrenList<T,CChildNode>::EnumerateScopeChildren( IConsoleNameSpace* pConsoleNameSpace )
{
	ATLTRACE(_T("# CNodeWithScopeChildrenList::EnumerateScopeChildren\n"));
	

	// Check for preconditions:
	// None.


	HRESULT hr;

	if ( FALSE == m_bScopeChildrenListPopulated )
	{
		// We have not yet loaded all of our children into our list.
		hr = PopulateScopeChildrenList();
		if( FAILED(hr) )
		{
			return( hr );
		}

		// We've already loaded our children objects with
		// data necessary to populate the result pane.
		m_bScopeChildrenListPopulated = TRUE;	// We only want to do this once.
	}


	// We don't need any code here to InsertItem the children into the
	// scope pane as we did in the EnumerateScopeChildren method
	// for CNodeWithResultChildrenList.
	// This is one difference between adding nodes into the scope
	// pane and the result pane.  Because MMC takes care of replicating
	// scope pane changes to all views, we don't need to worry about
	// sending an UpdateAllViews notification and handling insertion
	// there for each result pane.  Instead, we just do InsertItem once.
	// So for CNodeWithScopePaneChildren, we call InsertItem
	// in the AddChild method which is called by PopulateScopeChildrenList
	// above.

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\mmcutility.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    MMCUtility.cpp

Abstract:

	Implementation file for functions doing various handy things 
	that were getting written over and over again.


Author:

    Michael A. Maguire 02/05/98

Revision History:
	mmaguire 02/05/98 - created
	mmaguire 11/03/98 - moved GetSdo/PutSdo wrappers to sdohelperfuncs.h

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_MMC_UTILITY_H_)
#define _IAS_MMC_UTILITY_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

BringUpPropertySheetForNode


Tries to bring up a property sheet on a given node.  If the sheet for the
node is already up, it will bring that sheet to the foreground.


Parameters:

pSnapInItem

	You must supply a pointer to the node you want the sheet for.


pComponentData, pComponent

	Either you call with pComponentData != NULL and pComponent == NULL
	or pComponentData == NULL and pComponent != NULL.

pConsole

	You must supply a pointer to an IConsole interface.

bCreateSheetIfOneIsntAlreadyUp

	TRUE - if a sheet isn't already up, will try to create a property sheet 
	for you -- in this case you should specify a title for the 
	sheet in lpszSheetTitle.

	FALSE - will try to bring already existing sheet to foreground, but
	will return immediately	if there isn't one.

bPropertyPage

	TRUE for property pages. (Note: MMC creates property sheet in new thread.)
	FALSE for wizard pages.  (Note: Wizard pages run in same thread.)


Return:

	S_OK if found property sheet already up.
	S_FALSE if didn't find sheet already up but successfully made new one appear.
	E_... if some error error occurred.


Remarks:
	
	For this function's to work, you must have correctly implemented 
	IComponentData::CompareObjects and IComponentData::CompareObjects.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT BringUpPropertySheetForNode( 
				  CSnapInItem *pSnapInItem
				, IComponentData *pComponentData
				, IComponent *pComponent
				, IConsole *pConsole
				, BOOL bCreateSheetIfOneIsntAlreadyUp = FALSE
				, LPCTSTR lpszSheetTitle = NULL
				, BOOL bPropertyPage = TRUE // TRUE creates property page, FALSE wizard page.
				, DWORD dwPropertySheetOptions = 0 // e.g. pass MMC_PSO_NEWWIZARDTYPE for Wizard97 style
				);



#define USE_DEFAULT				0
#define USE_SUPPLEMENTAL_ERROR_STRING_ONLY	1


//////////////////////////////////////////////////////////////////////////////
/*++

ShowErrorDialog

Puts up an error dialog with varying degrees of detail

Parameters:

	All parameters are optional -- in the worst case, you can simply call 
		
		  ShowErrorDialog();

	to put up a very generic error message.


uErrorID

	The resource ID of the string to be used for the error message.
	Passing in USE_DEFAULT gives causes the default error message to be displayed. 
	Passing in USE_SUPPLEMENTAL_ERROR_STRING_ONLY causes no resource string text to be displayed. 

bstrSupplementalErrorString

	Pass in a string to print as the error message.  Useful if you are
	receiving an error string from some other component you communicate with.

hr

	If there is an HRESULT involved in the error, pass it in here so that 
	a suitable error message based on the HRESULT can be put up.
	Pass in S_OK if the HRESULT doesn't matter to the error.


uTitleID

	The resource ID of the string to be used for the error dialog title.
	Passing in USE_DEFAULT gives causes the default error dialog title to be displayed. 

pConsole

	If you are running within the main MMC context, pass in a valid IConsole pointer
	and ShowErrorDialog will use MMC's IConsole::MessageBox rather than the
	standard system MessageBox.

hWnd
	
	Whatever you pass in here will be passed in as the HWND parameter 
	to the MessageBox call.
	This is not used if you pass in an IConsole pointer.

uType

	Whatever you pass in here will be passed in as the HWND parameter 
	to the MessageBox call.


Return:

	The standard int returned from MessageBox.

	

--*/
//////////////////////////////////////////////////////////////////////////////
int ShowErrorDialog( 
					  HWND hWnd = NULL
					, UINT uErrorID = USE_DEFAULT
					, BSTR bstrSupplementalErrorString = NULL
					, HRESULT hr = S_OK
					, UINT uTitleID = USE_DEFAULT
					, IConsole *pConsole = NULL
					, UINT uType = MB_OK | MB_ICONEXCLAMATION 
				);



////////////////////////////////////////////////////////////////////////////
/*++

GetUserAndDomainName

Retrieves current user's username and domain.

Stolen from Knowledge Base HOWTO article:

HOWTO: Look Up Current User Name and Domain Name 
Rollup: WINPROG
Database: win32sdk
Article ID: Q155698
Last modified: June 16, 1997
Security: PUBLIC
 

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL   GetUserAndDomainName(	LPTSTR UserName
				, LPDWORD cchUserName
				, LPTSTR DomainName
				, LPDWORD cchDomainName
				);


DWORD GetModuleFileNameOnly(HINSTANCE hInst, LPTSTR lpFileName, DWORD nSize );


////////////////////////////////////////////////////////////////////////////
/*++
*/
HRESULT   IfServiceInstalled(LPCTSTR lpszMachine, LPCTSTR lpszService, BOOL* pBool);



#endif // _IAS_MMC_UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\propertypage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    PropertyPage.h

   This template class is currently implemented inline.
   There is node PropertyPage.cpp for implementation.

Abstract:

   Header file for the CIASPropertyPage class.

   This is our virtual base class for an MMC property page.

Author:

    Michael A. Maguire 11/24/97

Revision History:
   mmaguire 11/24/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_PROPERTY_PAGE_H_)
#define _PROPERTY_PAGE_H_

//=============================================================================
// Global Help Table for many Dialog IDs
//
#include "hlptable.h"


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
// Moved to Precompiled.h: #include <atlsnap.h>
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


// This object is shared among all property pages
// up for a given node and keeps a ref count
// of how many pages have not yet made sure all their data is clean.
// As long as this is non-zero, we don't commit our data.
// Create it when you first make the property pages,
// AddRef for each page you add it to, and delete
// it when you check and find that the refcount is 0.
class CSynchronizer
{

public:

   CSynchronizer::CSynchronizer()
   {
      m_lRefCount = 0;  
      m_lCount = 0;     
      m_lHighestCount = 0;
   }

   // Usual AddRef as for COM objects -- governs lifetime of this synchronizer object.
   LONG AddRef( void )
   {
      return m_lRefCount++;
   }

   // Usual Release as for COM objects -- governs lifetime of this synchronizer object.
   LONG Release( void )
   {
      LONG lRefCount = --m_lRefCount;
      if( 0 == m_lRefCount )
      {
         delete this;
      }
      return lRefCount;
   }

   // Raises count of interacting objects depending on this synchronizer.
   // Use this if an object has seen some data and will now need a
   // change to validate its data before allowing the data to be saved.
   LONG RaiseCount( void )
   {
      m_lCount++;

      if( m_lCount > m_lHighestCount )
      {
         m_lHighestCount = m_lCount;
      }

      return m_lCount;
   }

   // Lowers count of interacting objects depending on this synchronizer.
   // Use this if an object makes it through the validation of its data and is good to go.
   LONG LowerCount( void )
   {
      return --m_lCount;
   }

   // Resets count to highest it ever was during lifetime of this synchrnizer.
   // Use this if your objects all need to go through the data validation process again.
   LONG ResetCountToHighest( void )
   {
      return( m_lCount = m_lHighestCount );
   }

protected:

   // This is just to govern the lifetime of this object.
   LONG m_lRefCount;

   // This is used to keep track of dependencies of several other objects.
   LONG m_lCount;
   
   // This is used to keep several other objects synchronized.
   LONG m_lHighestCount;

};


template <class T>
class CIASPropertyPageNoHelp : public CSnapInPropertyPageImpl<T>
{
public :

   BEGIN_MSG_MAP(CIASPropertyPageNoHelp<T>)
      CHAIN_MSG_MAP(CSnapInPropertyPageImpl<T>)
   END_MSG_MAP()

protected:

   /////////////////////////////////////////////////////////////////////////////
   /*++

   CIASPropertyPageNoHelp::CIASPropertyPageNoHelp

   Constructor

   We never want someone to instantiate an object of CIASPage -- it should
   be an abstract base class from which we derive.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   CIASPropertyPageNoHelp(
      LONG_PTR hNotificationHandle, 
      TCHAR* pTitle = NULL, 
      BOOL bOwnsNotificationHandle = FALSE
      ) 
      : CSnapInPropertyPageImpl<T> (hNotificationHandle, pTitle, bOwnsNotificationHandle)
   {
      ATLTRACE(_T("# +++ CIASPropertyPageNoHelp::CIASPropertyPageNoHelp\n"));
            
      // Check for preconditions:
      // None.
      
      // Initialize the Synchronizer handle.
      m_pSynchronizer = NULL;
   }

public:
   
   /////////////////////////////////////////////////////////////////////////////
   /*++

   CIASPropertyPageNoHelp::~CIASPropertyPageNoHelp

   Destructor

   This needs to be public as it has to be accessed from from a static callback
   function (PropPageCallback) which responds to the PSPCB_RELEASE notification
   by deleting the property page.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   virtual ~CIASPropertyPageNoHelp()
   {
      ATLTRACE(_T("# --- CIASPropertyPageNoHelp::~CIASPropertyPageNoHelp\n"));
                  
      // Check for preconditions:

      if( m_pSynchronizer != NULL )
      {
         m_pSynchronizer->Release();
      }
   }

   // This points to an object shared among all property pages
   // for a given node that keeps a ref count
   // of how many pages have not yet made sure all their data is clean.
   // As long as this is non-zero, we don't commit our data.
   CSynchronizer * m_pSynchronizer;
};


template <class T>
class CIASPropertyPage : public CSnapInPropertyPageImpl<T>
{

protected:
   const DWORD *m_pHelpTable; // Help id pairs

public :

   BEGIN_MSG_MAP(CIASPropertyPage<T>)
      MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp )
      MESSAGE_HANDLER(WM_HELP, OnF1Help )
      CHAIN_MSG_MAP(CSnapInPropertyPageImpl<T>)
   END_MSG_MAP()

   //////////////////////////////////////////////////////////////////////////////
   /*++

   CIASPropertyPage::OnF1Help

   You shouldn't need to override this method in your derived class.
   Just initialize your static m_dwHelpMap member variable appropriately.

   This is called in response to the WM_HELP Notify message.

   This message is sent when the user presses F1 or <Shift>-F1
   over an item or when the user clicks on the ? icon and then
   presses the mouse over an item.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
   {
      ATLTRACE(_T("# CIASPropertyPage::OnF1Help\n"));
            
      // Check for preconditions:

      // ISSUE: Should we make F1 bring up the same help as pressing the Help
      // button as I think the UI guidelines suggest?  How do we do that?

      HELPINFO* helpinfo = (HELPINFO*) lParam;

      if (helpinfo->iContextType == HELPINFO_WINDOW)
      {
         ::WinHelp(
           (HWND) helpinfo->hItemHandle,
           HELPFILE_NAME,
           HELP_WM_HELP,
           (DWORD_PTR)(void*) m_pHelpTable );
      }

      return TRUE;
   }


   //////////////////////////////////////////////////////////////////////////////
   /*++

   CIASPropertyPage::OnContextHelp

   You shouldn't need to override this method in your derived class.
   Just initialize your static m_dwHelpMap member variable appropriately.

   This is called in response to the WM_CONTEXTMENU Notify message.

   This message is sent when the user right clicks over an item
   and then clicks "What's this?"

   --*/
   //////////////////////////////////////////////////////////////////////////////
   LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
   {
      ATLTRACE(_T("# CIASPropertyPage::OnContextHelp\n"));

      // Check for preconditions:
      // None.

      //ISSUE: See sburns's code in localsec snapin on problem with Windows
      // algorithm for default context help for items with ID == -1.
      // It doesn't look like we will need to worry about this.

      WinHelp(
              HELPFILE_NAME
            , HELP_CONTEXTMENU
            , (DWORD_PTR)(void*) m_pHelpTable
            );

      return TRUE;
   }


   /////////////////////////////////////////////////////////////////////////////
   /*++

   CIASPropertyPage::OnHelp

   Remarks:

      Don't override this method in your derived class.
      Instead, override the GetHelpPath method.
      
      This implementation calls the HtmlHelp API call with the HH_DISPLAY_TOPIC
      parameter, supplying the correct path to the compressed HTML help
      file for our application.  It calls our GetHelpPath
      method to get the string to pass in as the fourth parameter
      to the HtmlHelp call.

      This method is called when the user presses on the Help button of a
      property sheet.

      It is an override of atlsnap.h CSnapInPropertyPageImpl::OnHelp.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   virtual BOOL OnHelp()
   {
      ATLTRACE(_T("# CIASPropertyPage::OnHelp -- Don't override\n"));

      // Check for preconditions:

      HRESULT hr;
      WCHAR szHelpFilePath[IAS_MAX_STRING*2];

      // Use system API to get windows directory.
      UINT uiResult = GetWindowsDirectory( szHelpFilePath, IAS_MAX_STRING );
      if( uiResult <=0 || uiResult > IAS_MAX_STRING )
      {
         return E_FAIL;
      }

      WCHAR *szTempAfterWindowsDirectory = szHelpFilePath + lstrlen(szHelpFilePath);

      // Load the help file name.  Note: IDS_HTMLHELP_FILE = "iasmmc.chm"
      int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_HTMLHELP_PATH, szTempAfterWindowsDirectory, IAS_MAX_STRING );
      if( nLoadStringResult <= 0 )
      {
         return TRUE;
      }

      lstrcat( szTempAfterWindowsDirectory, L"::/" );

      WCHAR * szHelpFilePathAfterFileName = szHelpFilePath + lstrlen(szHelpFilePath);

      hr = GetHelpPath( szHelpFilePathAfterFileName );
      if( FAILED( hr ) )
      {
         return TRUE;
      }

      MMCPropertyHelp( szHelpFilePath );

      return TRUE;
   }

   
   /////////////////////////////////////////////////////////////////////////////
   /*++

   CIASPropertyPage::GetHelpPath

   Remarks:

      Override this method in your derived class.
      
      You should return the string with the relevant path within the
      compressed HTML file to get help for your property page.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   virtual HRESULT GetHelpPath( LPTSTR szHelpPath )
   {
      ATLTRACE(_T("# CIASPropertyPage::GetHelpPath -- override in your derived class\n"));

      // Check for preconditions:

#ifdef UNICODE_HHCTRL
      // ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
      // installed on this machine -- it appears to be non-unicode.
      lstrcpy( szHelpPath, _T("") );
#else
      strcpy( (CHAR *) szHelpPath, "" );
#endif

      return S_OK;
   }

protected:
   
   /////////////////////////////////////////////////////////////////////////////
   /*++

   CIASPropertyPage::CIASPropertyPage

   Constructor

   We never want someone to instantiate an object of CIASPage -- it should
   be an abstract base class from which we derive.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   CIASPropertyPage( LONG_PTR hNotificationHandle, TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE) : CSnapInPropertyPageImpl<T> (hNotificationHandle, pTitle, bOwnsNotificationHandle)
   {
      ATLTRACE(_T("# +++ CIASPropertyPage::CIASPropertyPage\n"));
            
      // Check for preconditions:
      // None.
      SET_HELP_TABLE(T::IDD);
   
      // Initialize the Synchronizer handle.
      m_pSynchronizer = NULL;
   }

public:
   
   /////////////////////////////////////////////////////////////////////////////
   /*++

   CIASPropertyPage::~CIASPropertyPage

   Destructor

   This needs to be public as it has to be accessed from from a static callback
   function (PropPageCallback) which responds to the PSPCB_RELEASE notification
   by deleting the property page.

   --*/
   //////////////////////////////////////////////////////////////////////////////
   virtual ~CIASPropertyPage()
   {
      ATLTRACE(_T("# --- CIASPropertyPage::~CIASPropertyPage\n"));
                  
      // Check for preconditions:

      if( m_pSynchronizer != NULL )
      {
         m_pSynchronizer->Release();
      }
   }

public:

   // This points to an object shared among all property pages
   // for a given node that keeps a ref count
   // of how many pages have not yet made sure all their data is clean.
   // As long as this is non-zero, we don't commit our data.
   CSynchronizer * m_pSynchronizer;

};


template <class T, int titileId, int subtitleId>
class CIASWizard97Page : public CIASPropertyPageNoHelp<T>
{
protected:
   ::CString   m_strWizard97Title;
   ::CString   m_strWizard97SubTitle;
   CIASWizard97Page( LONG_PTR hNotificationHandle, TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE) 
   : CIASPropertyPageNoHelp<T>( hNotificationHandle, pTitle, bOwnsNotificationHandle)

   {
      SetTitleIds(titileId, subtitleId);
   };

public :
   void  SetTitleIds(int titleId, int subtitleId)
   {
      AFX_MANAGE_STATE(AfxGetStaticModuleState());

      // load titles, and set title with the property page
      if(titileId != 0 && subtitleId != 0)
      {
         m_strWizard97Title.LoadString(titileId);
         m_strWizard97SubTitle.LoadString(subtitleId);
         
         SetTitles((LPCTSTR)m_strWizard97Title, (LPCTSTR)m_strWizard97SubTitle);
      }
      else
      {
          m_psp.dwFlags |= PSP_HIDEHEADER;
      }
   };
};

#endif // _PROPERTY_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\nodewithresultchildrenlist.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    NodeWithResultChildrenList.cpp

Abstract:

   Implementation file for the CNodeWithResultChildrenList subnode.

   This is the implementation portion of an inline template class.
   Include it in the .cpp file of the class in which you want to
   use the template.

Author:

    Michael A. Maguire 01/19/98

Revision History:
   mmaguire 01/19/98 - created based on old ClientsNode.h


--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//

//
// where we can find declaration for main class in this file:
//
#include "NodeWithResultChildrenList.h"
//
//
// where we can find declarations needed in this file:
//
#include "SnapinNode.cpp"  // Template class implementation
#include "ChangeNotification.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::AddSingleChildToListAndCauseViewUpdate

Adds a child to the list of children and calls UpdateAllViews

Use this when the user wants to add a new child node to the list and you
need to add that node to the list and cause a view update to be done across
all views.

This has to be public so that it can be accessed from the Add Client dialog.

Note: In any Add Client method which uses this method, make sure that you
have initially called your PopulateResultChildrenList method before you call this method.
Otherwise, when EnumerateResultChildrenList gets called, it will check the
m_bResultChildrenListPopulated variable, find that it's false, and think that
no items have yet been added to the list.  So it will call your PopulateResultChildrenList
method to populate the list from your underlying data source, potentially causing
the newly added item to show up in the list twice.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class CChildNode, class TArray, class TComponentData, class TComponent>
HRESULT CNodeWithResultChildrenList<T, CChildNode, TArray, TComponentData, TComponent>::AddSingleChildToListAndCauseViewUpdate( CChildNode * pChildNode )
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::AddSingleChildToListAndCauseViewUpdate\n"));

   // Check for preconditions:
   // None.

   HRESULT hr = S_OK;
   
   if( m_ResultChildrenList.Add( pChildNode ) )
   {
      // We don't add the item directly into the result pane now
      // using IResultData->InsertItem, as we have no way of
      // adding it into all the possible views.
      // Instead, we call IConsole->UpdateAllViews which will
      // cause MMC to call Notify on each of our IComponent objects
      // with the MMCN_VIEW_CHANGE notification, and we will
      // repopulate the result view when we handle that notification.

      // We weren't passed an IConsole pointer here, so
      // we use the one we saved in out CComponentData object.
      TComponentData * pComponentData = GetComponentData();
      _ASSERTE( pComponentData != NULL );
      _ASSERTE( pComponentData->m_spConsole != NULL );

      // We pass in a pointer to 'this' because we want each
      // of our CComponent objects to update its result pane
      // view if 'this' node is the same as the saved currently
      // selected node.

      // We want to make sure all views get updated.
      CChangeNotification *pChangeNotification = new CChangeNotification();
      pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_THIS_NODE;
      pChangeNotification->m_pNode = this;
      hr = pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
      pChangeNotification->Release();
   }
   else
   {
      // Failed to add => out of memory
      hr = E_OUTOFMEMORY;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RemoveChild

Removes a child from the list of children.

This is declared public because it must be accessed from a child node when that
node receives the MMCN_DELETE message and tries to delete itself.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent>
HRESULT CNodeWithResultChildrenList<T,CChildNode, TArray, TComponentData, TComponent>::RemoveChild( CChildNode * pChildNode )
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::RemoveChild\n"));

   // Check for preconditions:
   // None.

   HRESULT hr = S_OK;
   
   if( m_ResultChildrenList.Remove( pChildNode ) )
   {

      // We don't remove the item directly from the result pane now
      // using IResultData->RemoveItem, as we have no way of
      // removing it from all the possible views.
      // Instead, we call IConsole->UpdateAllViews which will
      // cause MMC to call Notify on each of our IComponent objects
      // with the MMCN_VIEW_CHANGE notification, and we will
      // repopulate the result view when we handle that notification.

      // We weren't passed an IConsole pointer here, so
      // we use the one we saved in out CComponentData object.
      TComponentData * pComponentData = GetComponentData();
      _ASSERTE( pComponentData != NULL );
      _ASSERTE( pComponentData->m_spConsole != NULL );

      // We pass in a pointer to 'this' because we want each
      // of our CComponent objects to update its result pane
      // view if 'this' node is the same as the saved currently
      // selected node.
      // We want to make sure all views get updated.
      CChangeNotification *pChangeNotification = new CChangeNotification();
      pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_THIS_NODE;
      pChangeNotification->m_pNode = this;
      hr = pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
      pChangeNotification->Release();
   }
   else
   {
      // If we failed to remove, probably the child was never in the list
      // ISSUE: determine what do here -- this should never happen
      _ASSERTE( FALSE );
      hr = S_FALSE;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CNodeWithResultChildrenList::RemoveChildrenNoRefresh
//
// Removes a child from the list of children.
// Does not refresh the view.
//
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent>
void CNodeWithResultChildrenList<T,CChildNode, TArray, TComponentData, TComponent>::RemoveChildrenNoRefresh()
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::RemoveChildrenNoRefresh\n"));

   // Check for preconditions:
   // None.

   for (unsigned int i = 0; i < m_ResultChildrenList.GetSize(); ++i)
   {
      delete m_ResultChildrenList[i];
   }

   m_ResultChildrenList.RemoveAll();
}  


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::InsertColumns

Override this in your derived class.

This method is called by OnShow when it needs you to set the appropriate
column headers to be displayed in the result pane for this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent>
HRESULT CNodeWithResultChildrenList<T, CChildNode, TArray, TComponentData, TComponent>::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::InsertColumns -- override in your derived class\n"));

   // Check for preconditions:
   _ASSERTE( pHeaderCtrl );

   HRESULT hr;

   // override in your derived class and do something like:
   hr = pHeaderCtrl->InsertColumn( 0, L"@Column 1 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 120 );
   _ASSERT( S_OK == hr );

   hr = pHeaderCtrl->InsertColumn( 1, L"@Column 2 -- override CNodeWithResultChildrenList::OnShowInsertColumns", 0, 300 );
   _ASSERT( S_OK == hr );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::PopulateResultChildrenList

Override this in your derived class.

This is called by EnumerateResultChildren which is called by OnShow when
you need to populate the list of children of this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent>
HRESULT CNodeWithResultChildrenList<T,CChildNode, TArray, TComponentData, TComponent>::PopulateResultChildrenList( void )
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::PopulateResultChildrenList -- override in your derived class\n"));

   // Check for preconditions:
   // None.

   // override in your derived class and do something like:
/*
   CSomeChildNode *myChild1 = new CSomeChildNode();
   AddChildToList(myChild1);

   CSomeChildNode *myChild2 = new CSomeChildNode();
   AddChildToList(myChild2);

   CSomeChildNode *myChild3 = new CSomeChildNode();
   AddChildToList(myChild3);
*/
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::RepopulateResultChildrenList

DON'T Override this in your derived class.

Call this to empty the list of children and repopulate it.
This method will call PopulateResultChildrenList, which you should override.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent >
HRESULT CNodeWithResultChildrenList<T, CChildNode, TArray, TComponentData, TComponent>::RepopulateResultChildrenList()
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::RepopulateResultChildrenList -- DON'T override in your derived class\n"));
      
   // Check for preconditions:
   // None.

   HRESULT hr;

   // Get rid of what we had.

   // Delete each node in the list of children
   CChildNode* pChildNode;
   int iSize = m_ResultChildrenList.GetSize();
   for (int i = 0; i < iSize; i++)
   {
      pChildNode = m_ResultChildrenList[i];
      delete pChildNode;
   }

   // Empty the list
   m_ResultChildrenList.RemoveAll();

   // We no longer have a populated list.
   m_bResultChildrenListPopulated = FALSE;

   // Repopulate the list.
   hr = PopulateResultChildrenList();
   if( FAILED(hr) )
   {
      return( hr );
   }

   // We've already loaded our children ClientNode objects with
   // data necessary to populate the result pane.
   m_bResultChildrenListPopulated = TRUE; // We only want to do this once.

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::CNodeWithResultChildrenList

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent>
CNodeWithResultChildrenList<T,CChildNode, TArray, TComponentData, TComponent>::CNodeWithResultChildrenList(
                                                     CSnapInItem* pParentNode, 
                                                     unsigned int helpIndex
                                                     ) 
      :CSnapinNode<T, TComponentData, TComponent>(pParentNode, helpIndex)
{
   ATLTRACE(_T("# +++ CNodeWithResultChildrenList::CNodeWithResultChildrenList\n"));

   // Check for preconditions:
   // None.

   // We have not yet loaded the child nodes' data
   m_bResultChildrenListPopulated = FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::~CNodeWithResultChildrenList

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent >
CNodeWithResultChildrenList<T, CChildNode, TArray, TComponentData, TComponent>::~CNodeWithResultChildrenList()
{
   ATLTRACE(_T("# --- CNodeWithResultChildrenList::~CNodeWithResultChildrenList\n"));
   
   // Check for preconditions:
   // None.

   // Delete each node in the list of children
   CChildNode* pChildNode;
   int iSize = m_ResultChildrenList.GetSize();
   for (int i = 0; i < iSize; i++)
   {
      pChildNode = m_ResultChildrenList[i];
      delete pChildNode;
   }

   // Empty the list
   m_ResultChildrenList.RemoveAll();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::AddChildToList

Adds a child to the list of children.  Does not cause a view update.

Use this in your PopulateResultChildrenList method.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent >
HRESULT CNodeWithResultChildrenList<T,CChildNode, TArray, TComponentData, TComponent>::AddChildToList( CChildNode * pChildNode )
{
   // Check for preconditions:
   // None.

   HRESULT hr = S_OK;
   
   if( m_ResultChildrenList.Add( pChildNode ) )
   {
      hr = S_OK;
   }
   else
   {
      // Failed to add => out of memory
      hr = E_OUTOFMEMORY;
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnShow

Don't override this in your derived class.  Instead, override methods
which it calls: InsertColumns and (indirectly) PopulateResultChildrenList

This method is an override of CSnapinNode::OnShow.  When MMC passes the
MMCN_SHOW method for this node, we are to add children into the
result pane.  In this class we add them from a list we maintain.

For more information, see CSnapinNode::OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent >
HRESULT CNodeWithResultChildrenList<T, CChildNode, TArray, TComponentData, TComponent>::OnShow( 
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::OnShow\n"));
   
   // Check for preconditions:
   _ASSERTE( pComponentData != NULL || pComponent != NULL );

   HRESULT hr = S_FALSE;

   T * pT = static_cast<T*>( this );

   //ISSUE: only do this if selected (arg = TRUE) -- what should we do if not selected?
   // See sburns' localsec example

   if( arg )
   {

      // arg <> 0 => we are being selected.

      // Note: This method will only get called with
      // arg <> 0 (i.e. selected) if you responded appropriately to
      // the MMCN_ADD_IMAGES method

      // We have been asked to display result pane nodes belonging under this node.

      // It appears we must do IResultData->InsertItems each time we receive
      // the MMCN_SHOW message -- MMC doesn't remember what nodes
      // we have previously inserted.

      
      // Set the column headers in the results pane
      // Note: if you don't set these, MMC will never
      // bother to put up your result-pane only items

      // When this Notify method is called from IComponentDataImpl, we
      // get pHeader (and pToolbar) passed in as NULL, so we aren't
      // going to bother using it and will instead always
      // QI pConsole for this pointer

      // Need IHeaderCtrl.

      // But to get that, first we need IConsole
      CComPtr<IConsole> spConsole;
      if( pComponentData != NULL )
      {
          spConsole = ((TComponentData*)pComponentData)->m_spConsole;
      }
      else
      {
         // We should have a non-null pComponent
          spConsole = ((TComponent*)pComponent)->m_spConsole;
      }
      _ASSERTE( spConsole != NULL );

      CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl(spConsole);
      _ASSERT( spHeaderCtrl != NULL );

      hr = pT->InsertColumns( spHeaderCtrl );
      _ASSERT( S_OK == hr );


      // Display our list of children in the result pane

      // Need IResultData
      CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
      _ASSERT( spResultData != NULL );

      hr = pT->EnumerateResultChildren( spResultData );
   }
   return hr;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::OnRefresh


You shouldn't need to override this in your derived method.  Simply
enable the MMC_VERB_REFRESH for your node.

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.

For more information, see CSnapinNode::OnRefresh.


--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent >
HRESULT CNodeWithResultChildrenList<T, CChildNode, TArray, TComponentData, TComponent>::OnRefresh( 
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::OnRefresh\n"));

   HRESULT hr;

   // Rebuild our list of nodes from the uderlying data source.
   T * pT = static_cast<T*> (this);
   hr = pT->RepopulateResultChildrenList();

   // Update the views.

   // We weren't passed an IConsole pointer here, so
   // we use the one we saved in out CComponentData object.
   TComponentData * pMyComponentData = GetComponentData();
   _ASSERTE( pMyComponentData != NULL );
   _ASSERTE( pMyComponentData->m_spConsole != NULL );

   // We pass in a pointer to 'this' because we want each
   // of our CComponent objects to update its result pane
   // view if 'this' node is the same as the saved currently
   // selected node.

   // We want to make sure all views get updated.
   CChangeNotification *pChangeNotification = new CChangeNotification();
   pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_THIS_NODE;
   pChangeNotification->m_pNode = this;
   hr = pMyComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
   pChangeNotification->Release();

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNodeWithResultChildrenList::EnumerateResultChildren

Don't override this in your derived class. Instead, override the method
it calls, PopulateResultChildrenList.

This is called by the OnShow method.

--*/
//////////////////////////////////////////////////////////////////////////////
template < class T, class CChildNode, class TArray, class TComponentData, class TComponent >
HRESULT CNodeWithResultChildrenList<T, CChildNode, TArray, TComponentData, TComponent>::EnumerateResultChildren( IResultData * pResultData )
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::EnumerateResultChildren\n"));
   
   // Check for preconditions:
   _ASSERTE( pResultData != NULL );

   HRESULT hr = S_OK;

   T * pT = static_cast<T*> (this);

   if ( FALSE == m_bResultChildrenListPopulated )
   {
      // We have not yet loaded all of our children into our list.
      // This call will add items to the list from whatever data source.
      hr = pT->PopulateResultChildrenList();
      if( FAILED(hr) )
      {
         return( hr );
      }

      // We've already loaded our children ClientNode objects with
      // data necessary to populate the result pane.
      m_bResultChildrenListPopulated = TRUE; // We only want to do this once.

   }

   // From MeanGene's Step4 -- need to first remove all items from result pane
   hr = pResultData->DeleteAllRsltItems();
   if( FAILED(hr) )
   {
      return hr;
   }

   // The ResultChildrenList is already populated, so we
   // just need to show the CChildNode objects to the world
   // by populating the result pane.

   CChildNode* pChildNode;
   for (int i = 0; i < m_ResultChildrenList.GetSize(); i++)
   {
      pChildNode = m_ResultChildrenList[i];
      if ( NULL == pChildNode )
      {
         continue;
      }

      // Insert the item into the result pane.
      hr = pResultData->InsertItem( &(pChildNode->m_resultDataItem) );
      if (FAILED(hr))
      {
         return hr;
      }

        // for some reason the item isn't showing up correctly in the result pane...
        // call this to force and upate of this item
      hr = pResultData->UpdateItem( pChildNode->m_resultDataItem.itemID );

 //      hr = pResultData->Sort(0,0,-1);

      // Check: On return, the itemID member of 'm_resultDataItem'
      // contains the handle to the newly inserted item.
      _ASSERT( NULL != pChildNode->m_resultDataItem.itemID );
   
   }

   return hr;
}


template < class T, class CChildNode, class TArray, class TComponentData, class TComponent >
HRESULT CNodeWithResultChildrenList<T, CChildNode, TArray, TComponentData, TComponent>::UpdateResultPane( IResultData * pResultData )
{
   return EnumerateResultChildren(pResultData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\sdohelperfuncs.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) Microsoft Corporation, 1997 - 1999 all rights reserved.
//
// Module:      sdohelperfuncs.cpp
//
// Project:     Everest
//
// Description: Helper Functions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
// 7/03/98      MAM    Adapted from \ias\sdo\sdoias to use in UI
// 11/03/98		MAM		Moved GetSdo/PutSdo routines here from mmcutility.cpp
//
/////////////////////////////////////////////////////////////////////////////

#include "sdohelperfuncs.h"
#include "comdef.h"



//////////////////////////////////////////////////////////////////////////////
//					CORE HELPER FUNCTIONS
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
HRESULT SDOGetCollectionEnumerator(
									ISdo*		   pSdo, 
									LONG		   lPropertyId, 
								    IEnumVARIANT** ppEnum
								  )
{
	HRESULT					hr;
	CComPtr<IUnknown>		pUnknown;
	CComPtr<ISdoCollection>	pSdoCollection;
	_variant_t				vtDispatch;

	_ASSERT( NULL != pSdo && NULL == *ppEnum );
	hr = pSdo->GetProperty(lPropertyId, &vtDispatch);
	_ASSERT( VT_DISPATCH == V_VT(&vtDispatch) );
	if ( SUCCEEDED(hr) )
	{
		hr = vtDispatch.pdispVal->QueryInterface(IID_ISdoCollection, (void**)&pSdoCollection);
		if ( SUCCEEDED(hr) )
		{
			hr = pSdoCollection->get__NewEnum(&pUnknown);
			if ( SUCCEEDED(hr) )
		    {
				hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)ppEnum);
			}
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////
HRESULT SDONextObjectFromCollection(
								     IEnumVARIANT*  pEnum, 
								     ISdo**			ppSdo
								   )
{
	HRESULT			hr;
    DWORD			dwRetrieved = 1;
	_variant_t		vtDispatch;

	_ASSERT( NULL != pEnum && NULL == *ppSdo );
    hr = pEnum->Next(1, &vtDispatch, &dwRetrieved);
    _ASSERT( S_OK == hr || S_FALSE == hr );
	if ( S_OK == hr )
	{
        hr = vtDispatch.pdispVal->QueryInterface(IID_ISdo, (void**)ppSdo);
	}

	return hr;
}



///////////////////////////////////////////////////////////////////
HRESULT SDOGetComponentIdFromObject(
									ISdo*	pSdo, 
									LONG	lPropertyId, 
									PLONG	pComponentId
								   )
{
	HRESULT		hr;
	_variant_t	vtProperty;

	_ASSERT( NULL != pSdo && NULL != pComponentId );

	hr = pSdo->GetProperty(lPropertyId, &vtProperty);
	if ( SUCCEEDED(hr) )
	{
		_ASSERT( VT_I4 == V_VT(&vtProperty) );
		*pComponentId = V_I4(&vtProperty);
	}

	return hr;
}


///////////////////////////////////////////////////////////////////
HRESULT SDOGetSdoFromCollection(
							    ISdo*  pSdoServer, 
							    LONG   lCollectionPropertyId, 
								LONG   lComponentPropertyId, 
								LONG   lComponentId, 
								ISdo** ppSdo
							   )
{
	HRESULT					hr;
	CComPtr<IEnumVARIANT>	pEnum;
	CComPtr<ISdo>			pSdo;
	LONG					ComponentId;

	do 
	{
		hr = SDOGetCollectionEnumerator(
										 pSdoServer,
										 lCollectionPropertyId,
										 &pEnum
									   );
		if ( FAILED(hr) )
			break;

		hr = SDONextObjectFromCollection(pEnum,&pSdo);
		while( S_OK == hr )
		{
			hr = SDOGetComponentIdFromObject(
											 pSdo,
											 lComponentPropertyId,
											 &ComponentId
											);
			if ( FAILED(hr) )
				break;

			if ( ComponentId == lComponentId )
			{
				pSdo->AddRef();
				*ppSdo = pSdo;
				break;
			}

			pSdo.Release();
			hr = SDONextObjectFromCollection(pEnum,&pSdo);
		}
		
		if ( S_OK != hr )
			hr = E_FAIL;

	} while ( FALSE );

	return hr;
}





//////////////////////////////////////////////////////////////////////////////
/*++

GetSdoVariant

Gets a Variant from the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetSdoVariant(
					  ISdo *pSdo
					, LONG lPropertyID
					, VARIANT * pVariant
					, UINT uiErrorID
					, HWND hWnd
					, IConsole *pConsole
				)
{
	ATLTRACE(_T("# GetSdoVariant\n"));

	
	// Check for preconditions:
	_ASSERTE( pSdo != NULL );
	_ASSERTE( pVariant != NULL );


	HRESULT hr;

	hr = pSdo->GetProperty( lPropertyID, pVariant );
	if( FAILED( hr ) )
	{
		CComPtr<IUnknown> spUnknown(pSdo);
		if( spUnknown == NULL )
		{
			// Just put up an error dialog with the error string ID passed to us.
			ShowErrorDialog( hWnd, uiErrorID );
		}
		else
		{
			CComBSTR bstrError;
						
			HRESULT hrTemp = GetLastOLEErrorDescription( spUnknown, IID_ISdo, (BSTR *) &bstrError );
			if( SUCCEEDED( hr ) )
			{
				ShowErrorDialog( hWnd, 1, bstrError );
			}
			else
			{
				// Just put up an error dialog with the error string ID passed to us.
				ShowErrorDialog( hWnd, uiErrorID );
			}
		}
	}
	else
	{
		if( pVariant->vt == VT_EMPTY )
		{
			// This is not a real error -- we just need to 
			// know that this item has not yet been initialized.
			return OLE_E_BLANK;
		}
	}


	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

GetSdoBSTR

Gets a BSTR from the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetSdoBSTR(
					  ISdo *pSdo
					, LONG lPropertyID
					, BSTR * pBSTR
					, UINT uiErrorID
					, HWND hWnd
					, IConsole *pConsole
				)
{
	ATLTRACE(_T("# GetSdoBSTR\n"));

	
	// Check for preconditions:
	_ASSERTE( pSdo != NULL );
	_ASSERTE( pBSTR != NULL );

	HRESULT			hr;
	CComVariant		spVariant;


	hr = GetSdoVariant( pSdo, lPropertyID, &spVariant, uiErrorID, hWnd, pConsole );
	if( SUCCEEDED( hr ) )
	{
		_ASSERTE( spVariant.vt == VT_BSTR );

		// Copy the string from the variant to the BSTR pointer passed in. 
		if( SysReAllocString( pBSTR, spVariant.bstrVal ) == FALSE )
		{
			ShowErrorDialog( hWnd, uiErrorID );
		}
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

GetSdoBOOL

Gets a BOOL from the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetSdoBOOL(
					  ISdo *pSdo
					, LONG lPropertyID
					, BOOL * pBOOL
					, UINT uiErrorID 
					, HWND hWnd
					, IConsole *pConsole
				)
{
	ATLTRACE(_T("# GetSdoBOOL\n"));

	
	// Check for preconditions:
	_ASSERTE( pSdo != NULL );
	_ASSERTE( pBOOL != NULL );

	HRESULT			hr;
	CComVariant		spVariant;


	hr = GetSdoVariant( pSdo, lPropertyID, &spVariant, uiErrorID, hWnd, pConsole );
	if( SUCCEEDED( hr ) )
	{
		_ASSERTE( spVariant.vt == VT_BOOL );

		// Copy the value from the variant to the BOOL pointer passed in. 
		// We must do a quick and dirty conversion here because of the way OLE
		// does BOOL values.
		*pBOOL = ( spVariant.boolVal == VARIANT_TRUE ? TRUE : FALSE );
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

GetSdoI4

Gets an I4 (LONG) from the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetSdoI4(
					  ISdo *pSdo
					, LONG lPropertyID
					, LONG * pI4
					, UINT uiErrorID
					, HWND hWnd
					, IConsole *pConsole
				)
{
	ATLTRACE(_T("# GetSdoI4\n"));

	
	// Check for preconditions:
	_ASSERTE( pSdo != NULL );
	_ASSERTE( pI4 != NULL );

	HRESULT			hr;
	CComVariant		spVariant;


	hr = GetSdoVariant( pSdo, lPropertyID, &spVariant, uiErrorID, hWnd, pConsole );
	if( SUCCEEDED( hr ) )
	{
		_ASSERTE( spVariant.vt == VT_I4 );

		// Copy the value from the variant to the BOOL pointer passed in. 
		*pI4 = spVariant.lVal;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

PutSdoVariant

Writes a Variant to the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT PutSdoVariant(
					  ISdo *pSdo
					, LONG lPropertyID
					, VARIANT * pVariant
					, UINT uiErrorID
					, HWND hWnd
					, IConsole *pConsole
				)
{
	ATLTRACE(_T("# PutSdoVariant\n"));

	
	// Check for preconditions:
	_ASSERTE( pSdo != NULL );
	_ASSERTE( pVariant != NULL );


	HRESULT hr;

	hr = pSdo->PutProperty( lPropertyID, pVariant );
	if( FAILED( hr ) )
	{
		CComPtr<IUnknown> spUnknown(pSdo);
		if( spUnknown == NULL )
		{
			// Just put up an error dialog with the error string ID passed to us.
			ShowErrorDialog( hWnd, uiErrorID );
		}
		else
		{
			CComBSTR bstrError;
						
			HRESULT hrTemp = GetLastOLEErrorDescription( spUnknown, IID_ISdo, (BSTR *) &bstrError );
			if( SUCCEEDED( hr ) )
			{
				ShowErrorDialog( hWnd, 1, bstrError );
			}
			else
			{
				// Just put up an error dialog with the error string ID passed to us.
				ShowErrorDialog( hWnd, uiErrorID );
			}
		}
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

PutSdoBSTR

Writes a BSTR to the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT PutSdoBSTR(
					  ISdo *pSdo
					, LONG lPropertyID
					, BSTR *pBSTR
					, UINT uiErrorID
					, HWND hWnd
					, IConsole *pConsole
				)
{
	ATLTRACE(_T("# PutSdoBSTR\n"));

	
	// Check for preconditions:
	_ASSERTE( pSdo != NULL );
	_ASSERTE( pBSTR != NULL );

	HRESULT			hr;
	CComVariant		spVariant;
	
	// Load the Variant with the required info.
	spVariant.vt = VT_BSTR;
	spVariant.bstrVal = SysAllocString( *pBSTR );

	if( spVariant.bstrVal == NULL )
	{
		ShowErrorDialog( hWnd, uiErrorID );
	}

	hr = PutSdoVariant( pSdo, lPropertyID, &spVariant, uiErrorID, hWnd, pConsole );

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

PutSdoBOOL

Writes a BOOL to the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT PutSdoBOOL(
					  ISdo *pSdo
					, LONG lPropertyID
					, BOOL bValue
					, UINT uiErrorID 
					, HWND hWnd
					, IConsole *pConsole
				)
{
	ATLTRACE(_T("# PutSdoBOOL\n"));

	
	// Check for preconditions:
	_ASSERTE( pSdo != NULL );

	HRESULT			hr;
	CComVariant		spVariant;

	// Load the Variant with the required info.
	// We have to do a little mapping here because of the way Automation does BOOL's.
	spVariant.vt = VT_BOOL;
	spVariant.boolVal = ( bValue ? VARIANT_TRUE : VARIANT_FALSE );

	hr = PutSdoVariant( pSdo, lPropertyID, &spVariant, uiErrorID, hWnd, pConsole );

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

PutSdoI4

Writes an I4 (LONG) to the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT PutSdoI4(
					  ISdo *pSdo
					, LONG lPropertyID
					, LONG lValue
					, UINT uiErrorID
					, HWND hWnd
					, IConsole *pConsole
				)
{
	ATLTRACE(_T("# PutSdoI4\n"));

	
	// Check for preconditions:
	_ASSERTE( pSdo != NULL );

	HRESULT			hr;
	CComVariant		spVariant;

	// Load the Variant with the required info.
	spVariant.vt = VT_I4;
	spVariant.lVal = lValue;

	hr = PutSdoVariant( pSdo, lPropertyID, &spVariant, uiErrorID, hWnd, pConsole );

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

GetLastOLEErrorDescription

Gets an error string from an interface.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetLastOLEErrorDescription(
					  IUnknown *pUnknown
					, REFIID riid
					, BSTR *pbstrError
				)
{
	ATLTRACE(_T("# GetLastOLEErrorDescription\n"));

	
	// Check for preconditions:
	_ASSERTE( pUnknown != NULL );

	HRESULT hr;


	CComQIPtr<ISupportErrorInfo, &IID_ISupportErrorInfo> spSupportErrorInfo(pUnknown);
	if( spSupportErrorInfo == NULL )
	{
		return E_NOINTERFACE;
	}

	hr = spSupportErrorInfo->InterfaceSupportsErrorInfo(riid);
	if( S_OK != hr )
	{
		return E_FAIL;
	}


	CComPtr<IErrorInfo> spErrorInfo;

	hr = GetErrorInfo( /* reserved */ 0, (IErrorInfo  **) &spErrorInfo );  
	if( hr != S_OK || spErrorInfo == NULL )
	{
		return E_FAIL;
	}

	hr = spErrorInfo->GetDescription( pbstrError );
	
	return hr;
}




//////////////////////////////////////////////////////////////////////////////
/*++

VendorsVector::VendorsVector

Constructor for STL vector wrapper for the SDO's vendor list.

Can throw E_FAIL or exceptions from std::vector::push_back.

--*/
//////////////////////////////////////////////////////////////////////////////
VendorsVector::VendorsVector( ISdoCollection * pSdoVendors )
{

	HRESULT					hr = S_OK;
	CComPtr<IUnknown>		spUnknown;
	CComPtr<IEnumVARIANT>	spEnumVariant;
	CComVariant				spVariant;
	long					ulCount;
	ULONG					ulCountReceived; 

	if( ! pSdoVendors )
	{
		throw E_FAIL;	// Is there a better error to return here?
	}

	// We check the count of items in our collection and don't bother getting the 
	// enumerator if the count is zero.  
	// This saves time and also helps us to avoid a bug in the the enumerator which
	// causes it to fail if we call next when it is empty.
	pSdoVendors->get_Count( & ulCount );

	if( ulCount > 0 )
	{

		// Get the enumerator for the Clients collection.
		hr = pSdoVendors->get__NewEnum( (IUnknown **) & spUnknown );
		if( FAILED( hr ) || ! spUnknown )
		{
			throw E_FAIL;
		}

		hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
		spUnknown.Release();
		if( FAILED( hr ) || ! spEnumVariant )
		{
			throw E_FAIL;
		}

		// Get the first item.
		hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );

		while( SUCCEEDED( hr ) && ulCountReceived == 1 )
		{
		
			// Get an sdo pointer from the variant we received.
			if( spVariant.vt != VT_DISPATCH || ! spVariant.pdispVal )
			{
				_ASSERTE( FALSE );
				continue;
			}

			CComPtr<ISdo> spSdo;
			hr = spVariant.pdispVal->QueryInterface( IID_ISdo, (void **) &spSdo );
			spVariant.Clear();
			if( FAILED( hr ) )
			{
				_ASSERTE( FALSE );
				continue;
			}


			// Get Vendor Name.
			hr = spSdo->GetProperty( PROPERTY_SDO_NAME, &spVariant );
			if( FAILED( hr ) )
			{
				_ASSERTE( FALSE );
				continue;
			}

			_ASSERTE( spVariant.vt == VT_BSTR );
			CComBSTR bstrVendorName = spVariant.bstrVal;
			spVariant.Clear();


			// Get Vendor ID.
			hr = spSdo->GetProperty( PROPERTY_NAS_VENDOR_ID, &spVariant );
			if( FAILED( hr ) )
			{
				_ASSERTE( FALSE );
				continue;
			}

			_ASSERTE( spVariant.vt == VT_I4 );
			LONG lVendorID = spVariant.lVal;
			spVariant.Clear();


			// Add the vendor infor to the list of vendors.
			push_back( std::make_pair(bstrVendorName, lVendorID) );


			// Get the next item.
			hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );

		} 

	}
	else
	{
		// There are no items in the enumeration
		// Do nothing.
	}

}



//////////////////////////////////////////////////////////////////////////////
/*++

VendorsVector::VendorIDToOrdinal

Given a RADIUS vendor ID, tells you the position of that vendor in the vector.

--*/
//////////////////////////////////////////////////////////////////////////////
int VendorsVector::VendorIDToOrdinal( LONG lVendorID )
{

	for (int i = 0; i < size() ; ++i)
	{
		if( lVendorID == operator[](i).second )
		{
			return i;
		}
	}

	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\nodewithscopechildrenlist.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    NodeWithScopeChildrenList.h

Abstract:

	This is the header file for CNodeWithScopeChildrenList, a class which
	implements a node that has a list of scope pane children.

	This is an inline template class.
	Include NodeWithScopeChildrenList.cpp in the .cpp files
	of the classes in which you use this template.

Author:

    Michael A. Maguire 12/01/97

Revision History:
	mmaguire 12/01/97 - abstracted from CRootNode, which will be changed to subclass this class

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NODE_WITH_SCOPE_CHILDREN_LIST_H_)
#define _NODE_WITH_SCOPE_CHILDREN_LIST_H_


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "SnapinNode.h"
//
//
// where we can find what this class has or uses:
//
#include <atlapp.h>			// for CSimpleArray
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



template <class T, class CChildNode >
class CNodeWithScopeChildrenList : public CSnapinNode< T >
{

public:

	
	
	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::AddChild

	Adds a child to the list of children.

	This has to be public as it must be accessible even from a separate dialog
	(e.g. a Connect to Server dialog) that may want to add a child.

	Here we add the child item to the list of children and call InsertItem
	to add the child to the scope pane.

	This is one difference between adding nodes into the scope
	pane and the result pane.  When we were inserting a child into
	the result pane, we didn't call InsertItem in the AddChild methods(s)
	because we needed to worry about sending an UpdataAllViews
	notification and repopulating the result pane in each view.
	
	Because MMC takes care of replicating scope pane changes to all views,
	we don't need to worry about this.  Instead, we just do InsertItem once here.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT AddChild( CChildNode * pChildNode );



	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::RemoveChild

	Removes a child from the list of children.

	This has to be public so that child nodes can ask their parent to be deleted
	from the list of children when they receive the MMCN_DELETE notification.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT RemoveChild( CChildNode * pChildNode );



	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::OnShow

	Don't override this in your derived class.  Instead, override methods
	which it calls: InsertColumns

	This method is an override of CSnapinNode::OnShow.  When MMC passes the
	MMCN_SHOW method for this node.
	
	For more information, see CSnapinNode::OnShow.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnShow(	
					  LPARAM arg
					, LPARAM param
					, IComponentData * pComponentData
					, IComponent * pComponent
					, DATA_OBJECT_TYPES type
					);



protected:


	// Array of pointers to children nodes
	CSimpleArray<CChildNode*> m_ScopeChildrenList;

	// Flag indicating whether list has been initially populated
	BOOL m_bScopeChildrenListPopulated;


	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::CNodeWithScopeChildrenList

	Constructor

	This is an base class which we don't want instantiated on its own,
	so the contructor is protected

	--*/
	//////////////////////////////////////////////////////////////////////////////
	CNodeWithScopeChildrenList( CSnapInItem * pParentNode );



	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::~CNodeWithScopeChildrenList

	Destructor

	--*/
	//////////////////////////////////////////////////////////////////////////////
	~CNodeWithScopeChildrenList();



	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::PopulateScopeChildrenList

	Override this in your derived class to populate the list of children nodes.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT PopulateScopeChildrenList( void );

	// override in your derived class and do something like:

/*
	virtual HRESULT PopulateScopeChildrenList( void )
	{
		CSomeChildNode *myChild1 = new CSomeChildNode();
		AddChild(myChild1);
	
		CSomeChildNode *myChild2 = new CSomeChildNode();
		AddChild(myChild2);
	
		CSomeChildNode *myChild3 = new CSomeChildNode();
		AddChild(myChild3);

		return S_OK;
	}
*/


	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::InsertColumns

	Override this in your derived class.

	This method is called by OnShow when it needs you to set the appropriate
	column headers to be displayed in the result pane for this node.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );



	//////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildren::OnExpand

	Don't override this in your derived class.  Instead, override methods
	which it calls: PopulateScopeChildrenList

	This method is an override of CSnapinNode::OnExpand.  When MMC passes the
	MMCN_EXPAND method for this node, we are to add children into the
	scope pane.  In this class we add them from a list we maintain.
	
	For more information, see CSnapinNode::OnExpand.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT OnExpand(	
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type
				);
	


	/////////////////////////////////////////////////////////////////////////////
	/*++

	CNodeWithScopeChildrenList::EnumerateScopeChildren

	Don't override this in your derived class. Instead, override the method
	it calls, PopulateScopeChildrenList.

	--*/
	//////////////////////////////////////////////////////////////////////////////
	virtual HRESULT EnumerateScopeChildren( IConsoleNameSpace* pConsoleNameSpace );


};


#endif // _NODE_WITH_SCOPE_CHILDREN_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\sdohelperfuncs.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) Microsoft Corporation, 1997 - 1999 all rights reserved.
//
// Module:      sdohelperfuncs.h
//
// Project:     Everest
//
// Description: Helper Functions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
// 7/03/98      MAM    Adapted from \ias\sdo\sdoias to use in UI
// 11/03/98		MAM		Moved GetSdo/PutSdo routines here from mmcutility.h
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __INC_IAS_SDO_HELPER_FUNCS_H
#define __INC_IAS_SDO_HELPER_FUNCS_H

#include <vector>
#include <utility>	// For "pair"


//////////////////////////////////////////////////////////////////////////////
//					CORE HELPER FUNCTIONS
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
HRESULT SDOGetCollectionEnumerator(
									ISdo*		   pSdo, 
									LONG		   lPropertyId, 
								    IEnumVARIANT** ppEnum
								  );

///////////////////////////////////////////////////////////////////
HRESULT SDONextObjectFromCollection(
								     IEnumVARIANT*  pEnum, 
								     ISdo**			ppSdo
								   );


///////////////////////////////////////////////////////////////////
HRESULT SDOGetComponentIdFromObject(
									ISdo*	pSdo, 
									LONG	lPropertyId, 
									PLONG	pComponentId
								   );


///////////////////////////////////////////////////////////////////
HRESULT SDOGetSdoFromCollection(
							    ISdo*  pSdoServer, 
							    LONG   lCollectionPropertyId, 
								LONG   lComponentPropertyId, 
								LONG   lComponentId, 
								ISdo** ppSdo
							   );



//////////////////////////////////////////////////////////////////////////////
/*++

GetSdoVariant

Gets a Variant from the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetSdoVariant(
					  ISdo *pSdo
					, LONG lPropertyID
					, VARIANT * pVariant
					, UINT uiErrorID = USE_DEFAULT
					, HWND hWnd = NULL
					, IConsole *pConsole = NULL
				);



//////////////////////////////////////////////////////////////////////////////
/*++

GetSdoBSTR

Gets a BSTR from the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetSdoBSTR(
					  ISdo *pSdo
					, LONG lPropertyID
					, BSTR * pBSTR
					, UINT uiErrorID = USE_DEFAULT
					, HWND hWnd = NULL
					, IConsole *pConsole = NULL
				);



//////////////////////////////////////////////////////////////////////////////
/*++

GetSdoBOOL

Gets a BOOL from the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetSdoBOOL(
					  ISdo *pSdo
					, LONG lPropertyID
					, BOOL * pBOOL
					, UINT uiErrorID = USE_DEFAULT
					, HWND hWnd = NULL
					, IConsole *pConsole = NULL
				);



//////////////////////////////////////////////////////////////////////////////
/*++

GetSdoI4

Gets an I4 (LONG) from the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetSdoI4(
					  ISdo *pSdo
					, LONG lPropertyID
					, LONG * pI4
					, UINT uiErrorID = USE_DEFAULT
					, HWND hWnd = NULL
					, IConsole *pConsole = NULL
				);



//////////////////////////////////////////////////////////////////////////////
/*++

PutSdoVariant

Writes a Variant to the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT PutSdoVariant(
					  ISdo *pSdo
					, LONG lPropertyID
					, VARIANT * pVariant
					, UINT uiErrorID = USE_DEFAULT
					, HWND hWnd = NULL
					, IConsole *pConsole = NULL
				);



//////////////////////////////////////////////////////////////////////////////
/*++

PutSdoBSTR

Writes a BSTR to the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT PutSdoBSTR(
					  ISdo *pSdo
					, LONG lPropertyID
					, BSTR *pBSTR
					, UINT uiErrorID = USE_DEFAULT
					, HWND hWnd = NULL
					, IConsole *pConsole = NULL
				);



//////////////////////////////////////////////////////////////////////////////
/*++

PutSdoBOOL

Writes a BOOL to the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT PutSdoBOOL(
					  ISdo *pSdo
					, LONG lPropertyID
					, BOOL bValue
					, UINT uiErrorID = USE_DEFAULT
					, HWND hWnd = NULL
					, IConsole *pConsole = NULL
				);



//////////////////////////////////////////////////////////////////////////////
/*++

PutSdoI4

Writes an I4 (LONG) to the SDO's and handles any error checking.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT PutSdoI4(
					  ISdo *pSdo
					, LONG lPropertyID
					, LONG lValue
					, UINT uiErrorID = USE_DEFAULT
					, HWND hWnd = NULL
					, IConsole *pConsole = NULL
				);



//////////////////////////////////////////////////////////////////////////////
/*++

GetLastOLEErrorDescription

Gets an error string from an interface.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GetLastOLEErrorDescription(
					  IUnknown *pUnknown
					, REFIID riid
					, BSTR *pbstrError
				);



//////////////////////////////////////////////////////////////////////////////
/*++

VendorsVector

STL vector wrapper for the SDO's vendor list.

--*/
//////////////////////////////////////////////////////////////////////////////

typedef std::pair< CComBSTR, LONG > VendorPair;

class VendorsVector: public std::vector< VendorPair >
{
public:
	VendorsVector( ISdoCollection * pSdoVendors );

	int VendorIDToOrdinal( LONG lVendorID );

};



#endif // __INC_IAS_SDO_HELPER_FUNCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\smdebug.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1991 - 1999 .
//
//  File:       debug.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//				following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//				 7-Oct-94   BruceFo		Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//  "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\SmDebug"
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif


#if DBG == 1

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
#define EXTRNC "C"
#else
#define EXTRNC
#endif

// smprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   smprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   EXPORTDEF void          APINOT
   SmAssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   EXPORTDEF unsigned long APINOT
   SetSmInfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetSmInfoMask(
       unsigned long ulNewMask);

   EXPORTDEF unsigned long APINOT
   SetSmAssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF void APINOT
   InitializeDebugging(
	   void);

   EXPORTDEF void APINOT
   CheckInit(char * pInfoLevelString, unsigned long * InfoLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

#define Win4Assert(x)  \
        (void)((x) || (SmAssertEx(__FILE__, __LINE__, #x),0))

#define Win4Verify(x) Win4Assert(x)


//
// Debug print macros
//

#define DEB_ERROR               0x00000001      // exported error paths
#define DEB_WARN                0x00000002      // exported warnings
#define DEB_TRACE               0x00000004      // exported trace messages

#define DEB_DBGOUT              0x00000010      // Output to debugger
#define DEB_STDOUT              0x00000020      // Output to stdout

#define DEB_IERROR              0x00000100      // internal error paths
#define DEB_IWARN               0x00000200      // internal warnings
#define DEB_ITRACE              0x00000400      // internal trace messages

#define DEB_USER1               0x00010000      // User defined
#define DEB_USER2               0x00020000      // User defined
#define DEB_USER3               0x00040000      // User defined
#define DEB_USER4               0x00080000      // User defined
#define DEB_USER5               0x00100000      // User defined
#define DEB_USER6               0x00200000      // User defined
#define DEB_USER7               0x00400000      // User defined
#define DEB_USER8               0x00800000      // User defined
#define DEB_USER9               0x01000000      // User defined
#define DEB_USER10              0x02000000      // User defined
#define DEB_USER11              0x04000000      // User defined
#define DEB_USER12              0x08000000      // User defined
#define DEB_USER13              0x10000000      // User defined
#define DEB_USER14              0x20000000      // User defined
#define DEB_USER15              0x40000000      // User defined

#define DEB_NOCOMPNAME          0x80000000      // suppress component name

#define DEB_FORCE               0x7fffffff      // force message

#define ASSRT_MESSAGE           0x00000001      // Output a message
#define ASSRT_BREAK             0x00000002      // Int 3 on assertion
#define ASSRT_POPUP             0x00000004      // And popup message


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

#ifndef DEF_INFOLEVEL
 #define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif


#define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char* comp##InfoLevelString = #comp;


#ifdef __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel); \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

#else  // ! __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel);
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

#endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

#define Win4Assert(x)  NULL
#define Win4Verify(x)  (x)

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\snapinnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    SnapinNode.h

Abstract:

   Header for the CSnapinNode class.

   This is our virtual base class for an MMC Snap-in node.

   As this is a template class and is all implemented inline,
   there is no SnapinNode.cpp for implementation.


Author:

    Michael A. Maguire 11/6/97

Revision History:
   mmaguire 11/6/97 - created using MMC snap-in wizard
   mmaguire 12/15/97 - made into template class


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_SNAPIN_NODE_H_)
#define _SNAPIN_NODE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
// Moved to Precompiled files: #include <atlsnap.h>
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

//class CComponentData;

template <class T, class TComponentData, class TComponent>
class CSnapinNode : public CSnapInItemImpl< T >
{

protected:
   // Constructor/Destructor  
   CSnapinNode(CSnapInItem * pParentNode, unsigned int helpIndex = 0);
   ~CSnapinNode();

public:
   // For IDataObject handling.
   IDataObject* m_pDataObject;
   void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault);

   // Clipboard formats which IDataObjects on all MMC nodes must support.
   static const GUID* m_NODETYPE;
   static const TCHAR* m_SZNODETYPE;
   static const TCHAR* m_SZDISPLAY_NAME;
   static const CLSID* m_SNAPIN_CLASSID;

   // Pointer to parent node.  This is passed in the call to our
   // constructor.  Needed so that a node can access its parent.
   // For example, when we receive the MMCN_DELETE notification, we might tell
   // our parent node to remove us from its list of children.
   CSnapInItem * m_pParentNode;

protected:
   // Allows us access to snapin-global data.
   virtual TComponentData * GetComponentData( void ) = 0;

public:
   // Standard MMC functionality -- override if you need to.
   STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider
      , LONG_PTR handle
      , IUnknown* pUnk
      , DATA_OBJECT_TYPES type
      );
   STDMETHOD(QueryPagesFor)( DATA_OBJECT_TYPES type );
   void* GetDisplayName();
   STDMETHOD(GetScopePaneInfo)( SCOPEDATAITEM *pScopeDataItem );
   STDMETHOD(GetResultPaneInfo)( RESULTDATAITEM *pResultDataItem );
   virtual LPOLESTR GetResultPaneColInfo(int nCol);
   virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );

   // Notify method will call notification handlers below -- shouldn't need to override.
   STDMETHOD( Notify ) (
           MMC_NOTIFY_TYPE event
         , LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         );

   // Notification handlers -- override when you want to intercept.
   virtual HRESULT OnActivate(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnAddImages(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnButtonClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnContextHelp(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnContextMenu(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnDoubleClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnDelete(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            , BOOL fSilent = FALSE
            );
   virtual HRESULT OnExpand(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnHelp(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnMenuButtonClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnMinimized(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnPaste(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnQueryPaste(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnRefresh(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnRemoveChildren(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnRename(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnSelect(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnShow(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT OnViewChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );

   // Special notification handler -- saves off the currently selected node.
   HRESULT PreOnShow(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );

   // Taskpad functionality.
   STDMETHOD(TaskNotify)(
              IDataObject * pDataObject
            , VARIANT * pvarg
            , VARIANT * pvparam
            );

   STDMETHOD(EnumTasks)(
              IDataObject * pDataObject
            , BSTR szTaskGroup
            , IEnumTASK** ppEnumTASK
            );
};

#endif // _SNAPIN_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\about.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    About.h

Abstract:

	Header file for the CSnapinAbout class.

	The CSnapinAbout class implements the ISnapinAbout interface which enables the MMC 
	console to get copyright and version information from the snap-in.
	The console also uses this interface to obtain images for the static folder
	from the snap-in.

	See About.cpp for implementation.

Author:

    Michael A. Maguire 11/6/97

Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_ABOUT_H_)
#define _IAS_ABOUT_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
// Moved to Precompiled.h: #include <atlsnap.h>
//
//
// where we can find what this class has or uses:
//
#include "resource.h"
#include "IASMMC.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class ATL_NO_VTABLE CSnapinAbout : 
	  public ISnapinAbout
	, public CComObjectRoot
	, public CComCoClass< CSnapinAbout, &CLSID_IASSnapinAbout>
{

public:
	
	DECLARE_REGISTRY(CSnapinAbout, _T("IASSnapinAbout.1"), _T("IASSnapinAbout.1"), IDS_IASSNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CSnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)( LPOLESTR *lpDescription );

    STDMETHOD(GetProvider)( LPOLESTR *lpName );

    STDMETHOD(GetSnapinVersion)( LPOLESTR *lpVersion );

    STDMETHOD(GetSnapinImage)( HICON *hAppIcon );

    STDMETHOD(GetStaticFolderImage)(
		  HBITMAP *hSmallImage
		, HBITMAP *hSmallImageOpen
		, HBITMAP *hLargeImage
		, COLORREF *cMask
		);

};

#endif // _IAS_ABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\common\snapinnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    SnapinNode.h

Abstract:

	Implementation file for the CSnapinNode class.
	
	This is our virtual base class for an MMC Snap-in node.

	This is the implementation portion of an inline template class.
	Include it in the .cpp file of the class in which you want to
	use the template.

Author:

    Michael A. Maguire 11/6/97

Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//

//
// where we can find declaration for main class in this file:
//
#include "SnapinNode.h"
//
//
// where we can find declarations needed in this file:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CreatePropertyPages

Adds pages to a property sheet.


HRESULT CreatePropertyPages(
  LPPROPERTYSHEETCALLBACK lpProvider,
							  // Pointer to the callback interface
  LONG_PTR handle,            // Handle for routing notification
  LPDATAOBJECT lpIDataObject  // Pointer to the data object
);


Remarks:

	DON'T Override in your derived class.  Instead, override the AddPropertyPages
	method which this class uses in your derived class.

	This is because we have some standard processing to do for all nodes
	on CreatePropertyPages, namely to check to see whether the property
	sheet for the node is already up.  If it is, we bring that page to the
	front and exit without needlessly recreating property pages.

Parameters

	lpProvider
	[in] Pointer to the IPropertySheetCallback interface.

	handle
	[in] Specifies the handle used to route the MMCN_PROPERTY_CHANGE notification message to the appropriate IComponent or IComponentData.

	lpIDataObject
	[in] Pointer to the IDataObject interface on the object that contains context information about the node.


Return Value

	S_OK
	The property sheet pages were successfully added.

	S_FALSE
	There were no pages added.

	E_UNEXPECTED
	An unexpected error occurred.

	E_INVALIDARG
	One or more parameters are invalid.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
STDMETHODIMP CSnapinNode<T, TComponentData, TComponent>::CreatePropertyPages(
	  LPPROPERTYSHEETCALLBACK lpProvider
	, LONG_PTR handle
	, IUnknown* pUnk
	, DATA_OBJECT_TYPES type
	)
{
	ATLTRACE(_T("# CSnapinNode::CreatePropertyPages -- override in your derived class\n"));

	return E_NOTIMPL;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:QueryPagesFor

Determines whether the object requires pages.


HRESULT QueryPagesFor(  DATA_OBJECT_TYPES type  );


Parameters

	void


Return Value

	S_OK
	Properties exist for this cookie.

	E_UNEXPECTED
	An unexpected error occurred.

	E_INVALID
	The parameter is invalid.

	ISSUE: So what do we return if an item doesn't have property pages?
		S_FALSE is used in sburns' localsec code

Remarks

	The console calls this method to determine whether the Properties menu
	item should be added to the context menu.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
STDMETHODIMP CSnapinNode<T, TComponentData, TComponent>::QueryPagesFor( DATA_OBJECT_TYPES type )
{
	ATLTRACE(_T("# CSnapinNode::QueryPagesFor -- override in your derived class if you have property pages\n"));

	// this method should be overriden and should return S_OK if you
	// have property pages for this node otherwise it should return S_FALSE.

	return S_FALSE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:InitDataClass

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
void CSnapinNode<T, TComponentData, TComponent>::InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
{
	// The default code stores off the pointer to the Dataobject the class is wrapping
	// at the time.
	// Alternatively you could convert the dataobject to the internal format
	// it represents and store that information

	m_pDataObject = pDataObject;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneInfo

ISSUE: what are the parameters to this function?  Why not void?

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
void* CSnapinNode<T, TComponentData, TComponent>::GetDisplayName()
{
	ATLTRACE(_T("# CSnapinNode::GetDisplayName\n"));

//		ISSUE: It looks as thought the m_SZDISPLAY_NAME is a totally
//		bogus variable -- we should think about eliminating it
//		Problematic -- const m_SZDISPLAY_NAME can't be localized
//		return (void*)m_SZDISPLAY_NAME;

	return (void*)m_bstrDisplayName;
}

//	void* GetSnapInCLSID()
//	{
//		ATLTRACE(_T("# CSnapinNode::GetSnapInCLSID\n"));
//
//		return (void*)m_SNAPIN_CLASSID;
//	}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetScopePaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
STDMETHODIMP CSnapinNode<T, TComponentData, TComponent>::GetScopePaneInfo( SCOPEDATAITEM *pScopeDataItem )
{
	ATLTRACE(_T("# CSnapinNode::GetScopePaneInfo\n"));

	if (pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if (pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if (pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if (pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if (pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	// TODO : Add code for SDI_CHILDREN
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
STDMETHODIMP CSnapinNode<T, TComponentData, TComponent>::GetResultPaneInfo( RESULTDATAITEM *pResultDataItem )
{
	ATLTRACE(_T("# CSnapinNode::GetResultPaneInfo\n"));

	if (pResultDataItem->bScopeItem)
	{
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if (pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if (pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if (pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if (pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::Notify


This method is this node's response to the MMC calling Notify on
IComponent or IComponentData.


STDMETHOD( Notify ) (
		  MMC_NOTIFY_TYPE event
		, LPARAM arg
		, LPARAM param
		, IComponentData * pComponentData
		, IComponent * pComponent
		, DATA_OBJECT_TYPES type
		
		
		)


Parameters

	event
	[in] Identifies an action taken by a user. IComponent::Notify and
	IComponentData::Notify can receive the following notifications for a
	specific node:

		MMCN_ACTIVATE
		MMCN_ADD_IMAGES
		MMCN_BTN_CLICK
		MMCN_CLICK
		MMCN_CONTEXTMENU
		MMCN_DBLCLICK
		MMCN_DELETE
		MMCN_EXPAND
		MMCN_HELP
		MMCN_MENU_BTNCLICK
		MMCN_MINIMIZED
		MMCN_PROPERTY_CHANGE
		MMCN_REFRESH
		MMCN_REMOVE_CHILDREN
		MMCN_RENAME
		MMCN_SELECT
		MMCN_SHOW
		MMCN_VIEW_CHANGE
		MMCN_CONTEXTHELP

	See CSnapinNode::OnActivate, OnAddImages, OnButtonClick, etc. for
	a detailed explanation of each of these notify events

	arg
	Depends on the notification type.

	param
	Depends on the notification type.


Return Values

	S_OK
	Depends on the notification type.

	E_UNEXPECTED
	An unexpected error occurred.


Remarks

	Our IComponentData and IComponent implementations were passed a LPDATAOBJECT
	which corresponds to a node.  This was converted to a pointer to
	a node object.  Below is the Notify method on this node object, were
	the node object can deal with the Notify event itself.

	Our implementation of Notify is a large switch statement which delegates the
	task of dealing with virtual OnXxxxxx methods which can overridden in
	derived classes.  As all events are dealt with this way here, you shouldn't
	need to implement a Notify method for any of your derived nodes.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
STDMETHODIMP CSnapinNode<T, TComponentData, TComponent>:: Notify (
		  MMC_NOTIFY_TYPE event
		, LPARAM arg
		, LPARAM param
		, IComponentData * pComponentData
		, IComponent * pComponent
		, DATA_OBJECT_TYPES type
		)
{
	ATLTRACE(_T("# CSnapinNode::Notify\n"));

	HRESULT hr = S_FALSE;

	// this makes for faster code.
	T* pT = static_cast<T*> (this);



	switch( event )
	{

	case MMCN_ACTIVATE:
		hr = pT->OnActivate( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_ADD_IMAGES:
		hr = pT->OnAddImages( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_BTN_CLICK:
		hr = pT->OnButtonClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CLICK:
		hr = pT->OnClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CONTEXTHELP:
		hr = pT->OnContextHelp( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CONTEXTMENU:
		hr = pT->OnContextMenu( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_CUTORMOVE:
		hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, TRUE );
		break;

	case MMCN_DBLCLICK:
		hr = pT->OnDoubleClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_DELETE:
		hr = pT->OnDelete( arg, param, pComponentData, pComponent, type, FALSE );
		break;

	case MMCN_EXPAND:
		hr = pT->OnExpand( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_HELP:
		hr = pT->OnHelp( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_MENU_BTNCLICK:
		hr = pT->OnMenuButtonClick( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_MINIMIZED:
		hr = pT->OnMinimized( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_PASTE:
		hr = pT->OnPaste( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_PROPERTY_CHANGE:
		hr = pT->OnPropertyChange( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_QUERY_PASTE:
		hr = pT->OnQueryPaste( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_REFRESH:
		hr = pT->OnRefresh( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_REMOVE_CHILDREN:
		hr = pT->OnRemoveChildren( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_RENAME:
		hr = pT->OnRename( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_SELECT:
		// For nodes with result-pane children
		hr = pT->OnSelect( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_SHOW:
		// For nodes with result-pane children
		// We call PreOnShow which will then call OnShow.
		// PreOnShow will save away the selected node in a member variable
		// of out CComponent class.
		hr = pT->PreOnShow( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_VIEW_CHANGE:
		hr = pT->OnViewChange( arg, param, pComponentData, pComponent, type );
		break;

	case MMCN_COLUMNS_CHANGED:
		hr = S_FALSE;
		break;
		
	default:
		// Unhandled notify event.
		//  MMC wants E_NOTIMPL if you can't do something or it will crash
		hr = E_NOTIMPL;
		break;

	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:CSnapinNode

Constructor

This class is to be the virtual base class for all our nodes
We never want people instantiating it so the constructor is protected

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
CSnapinNode<T, TComponentData, TComponent>::CSnapinNode( 
                                               CSnapInItem * pParentNode, 
                                               unsigned int helpIndex
                                               )
   :CSnapInItemImpl<T>(helpIndex)
{
	ATLTRACE(_T("# +++ CSnapinNode::CSnapinNode\n"));

	// Set the parent node below which this node is displayed.
	m_pParentNode = pParentNode;

	// We set cookie for both scope and result pane data items,
	// as this class can be subclassed for either a scope-pane
	// or a result-pane-only node.

	// Sridhar moved this initialization code out of SnapInItemImpl
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nImage = 0;			// May need modification
	m_scopeDataItem.nOpenImage = 0;		// May need modification
	// If this node is inserted in to the scope pane using
	// IConsoleNamespace->InsertItem, the value stored in lParam
	// will be what MMC later passes back as the cookie for this node.
	m_scopeDataItem.lParam = (LPARAM) this;

	// Sridhar moved this initialization code out of SnapInItemImpl
	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = MMC_CALLBACK;
	m_resultDataItem.nImage = 0;		// May need modification
	// If this node is inserted in to the result pane using
	// IResultData->InsertItem, the value stored in lParam will
	// be what MMC later passes back as the cookie for this node.
	m_resultDataItem.lParam = (LPARAM) this;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:~CSnapinNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
CSnapinNode<T, TComponentData, TComponent>::~CSnapinNode()
{
	ATLTRACE(_T("# --- CSnapinNode::~CSnapinNode\n"));
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode:GetResultPaneColInfo


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
LPOLESTR CSnapinNode<T, TComponentData, TComponent>::GetResultPaneColInfo(int nCol)
{
	ATLTRACE(_T("# CSnapinNode::GetResultPaneColInf\n"));

	if (nCol == 0)
	{
		return m_bstrDisplayName;
	}

	// TODO : Return the text for other columns
	return OLESTR("CSnapinNode::GetResultPaneColInfo -- Override in your derived class");
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnActivate

virtual HRESULT OnActivate(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_ACTIVATE
Notify message is sent for this node.

MMC sends this message to the snap-in's IComponent::Notify method when a window is
being activated or deactivated.


Parameters

	arg
	TRUE if the window is activated; otherwise, it is FALSE.

	param
	Not used.


Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnActivate(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnActivate  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnAddImages

virtual HRESULT OnAddImages(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

We have chosen to handle this on a per-IComponent object basis, since it has
very little to do (for us at least) with the particular IDataObject.

See CComponent::OnAddImages for where we add images.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnAddImages(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnAddImages  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnButtonClick

virtual HRESULT OnButtonClick(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_BTN_CLICK Notify message is
sent for this node.

MMC sends this message to the snap-in's IComponent, IComponentData,
or IExtendControlbar implementation when a user clicks on one of the
toolbar buttons.


Parameters

For IComponent::Notify or IComponentData::Notify:

	arg
	Must be zero.

	param
	CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration.

For IExtendControlBar::ControlbarNotify:

	arg
	Data object of the currently selected scope or result pane item.

	param
	[in] CmdID of the button equal to a value of the MMC_CONSOLE_VERB enumeration.


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnButtonClick(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnButtonClick  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnClick

virtual HRESULT OnClick(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_CLICK Notify message is
sent for this node.

MMC sends this message to IComponent when a user clicks a mouse button
on a list view item.


Parameters

 	arg
	Not used.

	param
	Not used.


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnClick(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnClick  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextHelp

virtual HRESULT OnContextHelp(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_CONTEXTHELP Notify message is
sent for this node.

MMC sends this message when the user requests help about a selected item


Parameters

	arg
	0.

	param
	0.


Return Values

  Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnContextHelp(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnContextHelp  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnContextMenu

virtual HRESULT OnContextMenu(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_CONTEXTMENU Notify
message is sent for this node.

In the Fall 97 Platform SDK documentation, this event is listed as not used.


Parameters

	arg
	TBD

	param
	TBD

Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnContextMenu(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnContextMenu  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDoubleClick

virtual HRESULT OnDoubleClick(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_DBLCLICK Notify message is
sent for this node.

MMC sends this message to IComponent when a user double clicks a mouse
button on a list view item.


Parameters

	arg
	Not used.

	param
	Not used.


Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnDoubleClick(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnDoubleClick  -- Override in your derived class if you don't want default verb action\n"));

	// Through speaking with Eugene Baucom, I discovered that if you return S_FALSE
	// here, the default verb action will occur when the user double clicks on a node.
	// For the most part we have Properties as default verb, so a double click
	// will cause property sheet on a node to pop up.
//		return E_NOTIMPL;
	return S_FALSE;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnDelete

virtual HRESULT OnDelete(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_DELETE Notify
message is sent for this node.

MMC sends this message to the snap-in's IComponent and IComponentData implementation to inform the snap-in that the object should be deleted.


Parameters

	arg
	Not used.

	param
	Not used.

Return Values

	Not used.


Remarks

	This message is generated when the user presses the delete key or uses
	the mouse to click on the toolbar's delete button.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnDelete(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			, BOOL fSilent
			)
{
	ATLTRACE(_T("# CSnapinNode::OnDelete  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnExpand

virtual HRESULT OnExpand(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

If your node will have scope-pane children,
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_EXPAND Notify message is
sent for this node.

MMC sends this message to the snap-in's IComponentData
implementation when a folder node needs to be expanded or contracted.


Parameters

	arg
	[in] If TRUE, the folder needs to be expanded. If FALSE, the folder needs to be contracted.

	Param
	[in] The HSCOPEITEM of the item that needs to be expanded.


Return Values

	HRESULT


Remarks

	On receipt of this notification the snap-in should enumerate the
	children (sub-containers only) of the specified scope item, if any,
	using IConsoleNameSpace methods. Subsequently, if a new item is added to
	or deleted from this scope object through some external means, then
	that item should also be added to or deleted from the console's
	namespace using IConsoleNameSpace methods.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnExpand(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnExpand  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnHelp

virtual HRESULT OnHelp(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_HELP Notify
message is sent for this node.

In the Fall 97 Platform SDK documentation, this event is listed as not used.

MMC sends this message when the user presses the F1 help key.


Parameters

	arg
	TBD

	param
	Pointer to a GUID. If NULL, the NodeType is used instead.


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnHelp(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnHelp  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMenuButtonClick

virtual HRESULT OnMenuButtonClick(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)


In our implementation, this method gets called when the MMCN_MENU_BTNCLICK Notify
message is sent for this node.

MMC sends this ify message is sent Sent to the snap-in's IExtendControlbar
interface when a user clicks on a menu button.


Parameters

	arg
	Data object of currently selected scope or result pane item.

	param
	[in] Pointer to a MENUBUTTONDATA structure.


Return Values
	
	  Not Used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnMenuButtonClick(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnMenuButtonClick  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnMinimized

virtual HRESULT OnMinimized(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)


In our implementation, this method gets called when the MMCN_MINIMIZED Notify message is
sent for this node.

MMC sends this message to the snap-in's IComponent implementation when
a window is being minimized or maximized.


Parameters

	arg
	TRUE if the window has been minimized; otherwise, it is FALSE.

	Param
	Not used.


Return Values

  Not Used


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnMinimized(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnMinimized  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPaste

virtual HRESULT OnPaste(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_PASTE
Notify message is sent for this node.

Called to ask the snap-ins folder to paste the selected items.


Parameters

	pDataobject
	The data object in which to paste the selected items provided by the snap-in.
	arg
	The data object of the selected item(s) provided by the source snap-in that need to be pasted.
	param
	NULL for move (as opposed to cut).
	For a single-item paste:

	BOOL* pPasted = (BOOL*)param; Set this to TRUE here if the item was successfully pasted.

	For a multiitem paste:

	LPDATAOBJECT* ppDataObj = (LPDATAOBJECT*)param;

	Use this to return a pointer to a data object consisting of the items successfully pasted. See MMCN_CUTORMOVE.


Return Values
	
	Not used.


See Also
	
	MMCN_CUTORMOVE


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnPaste(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnPaste  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnPropertyChange

virtual HRESULT OnPropertyChange(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_PROPERTY_CHANGE
Notify message is sent for this node.

When the snap-in uses the MMCPropertyChangeNotify function to notify it's
views about changes, MMC_PROPERTY_CHANGE is sent to the snap-in's
IComponentData and IComponent implementations.


Parameters

	arg
	[in] TRUE if the property change is for a scope pane item.

	lParam
	This is the param passed into MMCPropertyChangeNotify.


Return Values
	
	  Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnPropertyChange(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnPropertyChange  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnQueryPaste

virtual HRESULT OnQueryPaste(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_QUERY_PASTE
Notify message is sent for this node.

Sent to the snap-in before pasting into the snap-in's folder to determine if the
snap-in can accept the data.


Parameters

	pdataobject
	The dataobject of the selected item provided by the snap-in.
	arg
	The dataobject of the item(s) provided by the source snap-in that need to be pasted.
	param
	Not used.


Return Values

	Not used.


See Also

	MMCN_PASTE


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnQueryPaste(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnQueryPaste  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRefresh

virtual HRESULT OnRefresh(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_REFRESH
Notify message is sent for this node.

In the Fall 97 Platform SDK documentation, this event is listed as TBD.


Parameters


Return Values

	Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnRefresh(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnRefresh  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRemoveChildren

virtual HRESULT OnRemoveChildren(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_REMOVE_CHILDREN
Notify message is sent for this node.

MMC sends this message to the snap-in's IComponentData implementation to inform
the snap-in that it must delete all the cookies (the entire subtree) it has
added below the specified node.


Parameters

	arg
	Specifies the HSCOPEITEM of the node whose children need to be deleted.

	param
	Not used.


Return Values
	
	  Not used.


Remarks

  	Use IConsoleNameSpace methods GetChildItem and GetNextItem to traverse
	the tree and determine the cookies to be deleted.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnRemoveChildren(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnRemoveChildren  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnRename

virtual HRESULT OnRename(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_RENAME Notify
message is sent for this node.
	
ISSUE: I do not seem to be seeing the two-call behaviour documented below

MMC sends this message the first time to query for a rename and the
second time to do the rename.


Parameters

	arg
	Not used.

	param
	LPOLESTR for containing the new name.

Return Values

	S_OK
	Allows the rename.

	S_FALSE
	Disallows the rename.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnRename(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnRename  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnSelect

virtual HRESULT OnSelect(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

You shouldn't need to override this method.  The OnSelect method has common
behaviour for all nodes, only the verbs to be set are different.  Rather
than overriding OnSelect in each node, simply override SetVerbs, which this
implementation of OnSelect calls.

In our implementation, this method gets called when the MMCN_SELECT Notify message is
sent through IComponent::Notify for this node.

Note: MMC also sends the MMCN_SELECT message through IExtendControlbar::ControlbarNotify
but we don't respond to that here -- See CSnapInItem::ControlbarNotify for that.


Parameters

For IComponent::Notify:

	arg
	BOOL bScope = (BOOL) LOWORD(arg);
	BOOL bSelec = (BOOL) HIWORD(arg);

	bScope
	TRUE if an item in the scope pane is selected.
	FALSE if an item in the result view pane is selected.

	bSelect
	TRUE if the item is selected.
	FALSE if the item is deselected.

	param
	This parameter is ignored.

Return Values

	Not used.


Remarks

	When an IComponent::Notify method receives the MMCN_SELECT notification
	it should update the standard verbs.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnSelect(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnSelect\n"));

	
	
	_ASSERTE( pComponentData != NULL || pComponent != NULL );


	HRESULT hr = S_FALSE;
	CComPtr<IConsoleVerb> spConsoleVerb;

	BOOL bSelected = (BOOL) HIWORD( arg );

	if( bSelected )
	{

		// Need IConsoleVerb

		// But to get that, first we need IConsole
		CComPtr<IConsole> spConsole;
		if( pComponentData != NULL )
		{
			 spConsole = ((TComponentData*)pComponentData)->m_spConsole;
		}
		else
		{
			// We should have a non-null pComponent
			 spConsole = ((TComponent*)pComponent)->m_spConsole;
		}
		_ASSERTE( spConsole != NULL );

		hr = spConsole->QueryConsoleVerb( &spConsoleVerb );
		_ASSERT( SUCCEEDED( hr ) );

		hr = SetVerbs( spConsoleVerb );

	}
	else
	{

		// Anything to do here? Don't think so -- see sburns localsec example.

		hr = S_OK;

	}


	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::SetVerbs

virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb )

Override this method in your derived class.

This method is called by our default implementation of OnSelect
when the verbs for this node need to be set.

Parameters

	IConsoleVerb * pConsoleVerb


Return Values

	HRESULT


Remarks

	The OnSelect method has common behaviour for all nodes, only the verbs
	to be set are different.  Rather than duplicate code by implementing OnSelect
	in each node, simply override this SetVerbs method

	Every time an item is selected, the verb states for all the commands
	are returned to disabled and visible. It is up to the snap-in writer
	to use IConsoleVerb to update the verb state every time an item is selected.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::SetVerbs( IConsoleVerb * pConsoleVerb )
{
	ATLTRACE(_T("# CSnapinNode::SetVerbs -- Override in your derived class\n"));

	HRESULT hr = S_OK;

	// Override in your derived class and do something like:
/*		
	// We want the user to be able to choose properties on this node
	hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

	// We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

	// We want the user to be able to rename this node
	hr = pConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
*/	
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::PreOnShow

virtual HRESULT PreOnShow(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

We call this instead of OnShow, so that we can save away the selected node.

This method will then just call OnShow.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::PreOnShow(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::PreOnShow  -- Don't override in your derived class\n"));


	if( NULL != pComponent )
	{

		TComponent * pMyComponent = static_cast<TComponent *>( pComponent );

		if( arg )
		{
			// We are being selected.

			// Save our 'this' pointer as the currently selected node for this result view.
			pMyComponent->m_pSelectedNode = static_cast<CSnapInItem *>( this );

		}
		else
		{
			// We are being deselected.

			// Check to make sure that our result view doesn't think
			// this node is the currently selected one.
			if( pMyComponent->m_pSelectedNode == static_cast<CSnapInItem *>( this ) )
			{
				// We don't want to be the selected node anymore.
				pMyComponent->m_pSelectedNode = NULL;
			}

		}

	}

	return OnShow( arg, param, pComponentData, pComponent, type );
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnShow

virtual HRESULT OnShow(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

If your node will have result-pane children,
this method should be overidden in your derived class.

In our implementation, this method gets called when the MMCN_SHOW Notify message is
sent for this node.

MMC sends this message when a scope item is selected or deselected for the
first time.


Parameters

	arg
	TRUE (<>0 ) if selecting; True indicates that the snap-in should set
	up the result pane and add the enumerated items.
	FALSE (0) if deselecting. indicates that the snap-in is going out of
	focus and that it should clean up all cookies the right hand side
	(the result pane), because current result pane will be replaced by a new one.

	param
	The HSCOPEITEM of the selected or deselected item.


Return Values

	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnShow(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnShow  -- Override in your derived class\n"));

	// Returning E_NOTIMPL seems to be a bad thing here.
	// It caused all kinds of problems with toolbar buttons persisting to
	// the wrong node, as well as verbs not getting set correctly for nodes.
	// Basically, if you don't respond with S_OK to the MMCN_SHOW notification,
	// you won't get sent the appropriate MMCN_SELECT notification.
	// return E_NOTIMPL;
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::OnViewChange

virtual HRESULT OnViewChange(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)

In our implementation, this method gets called when the MMCN_VIEW_CHANGE Notify
message is sent for this node.

MMC sends this message to the snap-in's IComponent implementation so it
can update all views when a change occurs.  This node data object passed
to IConsole::UpdateAllViews.


Parameters

	arg
	[in] The data parameter passed to IConsole::UpdateAllViews.

	param
	[in] The hint parameter passed to IConsole::UpdateAllViews.


Return Values

	Not used.


Remarks

	This notification is generated when the snap-in (IComponent or
	IComponentData) calls IConsole::UpdateAllViews.


--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
HRESULT CSnapinNode<T, TComponentData, TComponent>::OnViewChange(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	ATLTRACE(_T("# CSnapinNode::OnViewChange  -- Override in your derived class\n"));

	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::TaskNotify

Called when MMC wants to notify us that the user clicked on a task
on a taskpad belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
STDMETHODIMP CSnapinNode<T, TComponentData, TComponent>::TaskNotify(
			  IDataObject * pDataObject
			, VARIANT * pvarg
			, VARIANT * pvparam
			)
{
	ATLTRACENOTIMPL(_T("# CSnapInItemImpl::TaskNotify\n"));

}



/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinNode::EnumTasks

Called when MMC wants us to enumerate the tasks	on a taskpad
belonging to this node.

--*/
//////////////////////////////////////////////////////////////////////////////
template <class T, class TComponentData, class TComponent>
STDMETHODIMP CSnapinNode<T, TComponentData, TComponent>::EnumTasks(
			  IDataObject * pDataObject
			, BSTR szTaskGroup
			, IEnumTASK** ppEnumTASK
			)
{
	ATLTRACENOTIMPL(_T("# CSnapInItemImpl::EnumTasks\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\about.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    About.cpp

Abstract:

	Implementation file for the CSnapinAbout class.

	The CSnapinAbout class implements the ISnapinAbout interface which enables the MMC 
	console to get copyright and version information from the snap-in.
	The console also uses this interface to obtain images for the static folder
	from the snap-in.

Author:

    Michael A. Maguire 11/6/97

Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "About.h"
//
//
// where we can find declarations needed in this file:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetSnapinDescription


Enables the console to obtain the text for the snap-in's description box.


HRESULT GetSnapinDescription(
  LPOLESTR * lpDescription  // Pointer to the description text.
);

  
Parameters

lpDescription 
[out] Pointer to the text for the description box on an About property page. 


Return Values

S_OK 
The text was successfully obtained. 


Remarks
Memory for out parameters must be allocated using CoTaskMemAlloc. This function is documented in the Platform SDK.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription (LPOLESTR *lpDescription)
{
	ATLTRACE(_T("# CSnapinAbout::GetSnapinDescription\n"));


	// Check for preconditions:



	USES_CONVERSION;

	TCHAR szBuf[256];
	if (::LoadString(_Module.GetResourceInstance(), IDS_IASSNAPIN_DESC, szBuf, 256) == 0)
		return E_FAIL;

	*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
	if (*lpDescription == NULL)
		return E_OUTOFMEMORY;

	ocscpy(*lpDescription, T2OLE(szBuf));

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetProvider


Enables the console to obtain the snap-in provider's name.


HRESULT GetProvider(
  LPOLESTR * lpName  // Pointer to the provider's name
);

  
Parameters

lpName 
[out] Pointer to the text making up the snap-in provider's name. 


Return Values

S_OK 
The name was successfully obtained. 


Remarks

Memory for out parameters must be allocated using CoTaskMemAlloc. This function is documented in the Platform SDK.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetProvider (LPOLESTR *lpName)
{
	ATLTRACE(_T("# CSnapinAbout::GetProvider\n"));


	// Check for preconditions:



	USES_CONVERSION;
	TCHAR szBuf[256];
	if (::LoadString(_Module.GetResourceInstance(), IDS_IASSNAPIN_PROVIDER, szBuf, 256) == 0)
		return E_FAIL;

	*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
	if (*lpName == NULL)
		return E_OUTOFMEMORY;

	ocscpy(*lpName, T2OLE(szBuf));

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetSnapinVersion


Enables the console to obtain the snap-in's version number.


HRESULT GetSnapinVersion(
  LPOLESTR* lpVersion  // Pointer to the version number.
);
 

Parameters

lpVersion 
[out] Pointer to the text making up the snap-in's version number. 


Return Values

S_OK 
The version number was successfully obtained. 


Remarks

Memory for out parameters must be allocated using CoTaskMemAlloc. This function is documented in the Platform SDK.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinVersion (LPOLESTR *lpVersion)
{
	ATLTRACE(_T("# CSnapinAbout::GetSnapinVersion\n"));


	// Check for preconditions:



	USES_CONVERSION;
	TCHAR szBuf[256];
	if (::LoadString(_Module.GetResourceInstance(), IDS_IASSNAPIN_VERSION, szBuf, 256) == 0)
		return E_FAIL;

	*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
	if (*lpVersion == NULL)
		return E_OUTOFMEMORY;

	ocscpy(*lpVersion, T2OLE(szBuf));

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetSnapinImage


Enables the console to obtain the snap-in's main icon to be used in the About box.


HRESULT GetSnapinImage(
  HICON * hAppIcon  // Pointer to the application's main icon
);
 

Parameters

hAppIcon 
[out] Pointer to the handle of the main icon of the snap-in that is to be used in the About property page. 


Return Values

S_OK 
The handle to the icon was successfully obtained. 

  ISSUE: What do I return if I can't get the icon?

Remarks

Memory for out parameters must be allocated using CoTaskMemAlloc. This function is documented in the Platform SDK.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinImage (HICON *hAppIcon)
{
	ATLTRACE(_T("# CSnapinAbout::GetSnapinImage\n"));


	// Check for preconditions:
	// None.


	if ( NULL == (*hAppIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_IAS_SNAPIN_IMAGE) ) ) )
		return E_FAIL;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetStaticFolderImage


Allows the console to obtain the static folder images for the scope and result panes.

As of version 1.1 of MMC, the icon returned here will be the icon used on
the root node of our snapin. 



HRESULT GetStaticFolderImage(
  HBITMAP * hSmallImage,  // Pointer to a handle to a small icon.
  HBITMAP * hSmallImageOpen,  // Pointer to a handle to open folder 
                              // icon.
  HBITMAP * hLargeImage,  // Pointer to a handle to a large icon.
  COLORREF * cMask        // Color used to generate a mask.
);
 

Parameter

hSmallImage 
[out] Pointer to the handle of a small icon (16x16n pixels) in either the scope or result view pane.

hSmallImageOpen 
[out] Pointer to the handle of a small open-folder icon (16x16n pixels).

hLargImage 
[out] Pointer to the handle of a large icon (32x32n pixels).

cMask 
[out] Pointer to a COLORREF structure that specifies the color used to generate a mask. This structure is documented in the Platform SDK. 


Return Values

S_OK 
The icon was successfully obtained. 

  ISSUE: What should we return if we fail?

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetStaticFolderImage (
	HBITMAP *hSmallImage,
    HBITMAP *hSmallImageOpen,
    HBITMAP *hLargeImage,
    COLORREF *cMask)
{

	ATLTRACE(_T("# CSnapinAbout::GetStaticFolderImage\n"));
	

	// Check for preconditions:


	
	
	if( NULL == (*hSmallImageOpen = (HBITMAP) LoadImage(
		_Module.GetResourceInstance(),   // handle of the instance that contains the image  
		MAKEINTRESOURCE(IDB_STATIC_FOLDER_OPEN_16),  // name or identifier of image
		IMAGE_BITMAP,        // type of image  
		0,     // desired width
		0,     // desired height  
		LR_DEFAULTCOLOR        // load flags
		) ) )
	{
		return E_FAIL;
	}


	if( NULL == (*hSmallImage = (HBITMAP) LoadImage(
		_Module.GetResourceInstance(),   // handle of the instance that contains the image  
		MAKEINTRESOURCE(IDB_STATIC_FOLDER_16),  // name or identifier of image
		IMAGE_BITMAP,        // type of image  
		0,     // desired width
		0,     // desired height  
		LR_DEFAULTCOLOR        // load flags
		) ) )
	{
		return E_FAIL;
	}

	if( NULL == (*hLargeImage = (HBITMAP) LoadImage(
		_Module.GetResourceInstance(),   // handle of the instance that contains the image  
		MAKEINTRESOURCE(IDB_STATIC_FOLDER_32),  // name or identifier of image
		IMAGE_BITMAP,        // type of image  
		0,     // desired width
		0,     // desired height  
		LR_DEFAULTCOLOR        // load flags
		) ) )
	{
		return E_FAIL;
	}


	// ISSUE: Need to worry about releasing these bitmaps.

	*cMask = RGB(255, 0, 255);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\addclientdialog.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	AddClientDialog.h

Abstract:

	Header file for the CAddClientDialog class.

	See CAddClientDialog.cpp for implementation.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_ADD_CLIENT_DIALOG_H_)
#define _IAS_ADD_CLIENT_DIALOG_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "Dialog.h"
//
//
// where we can find what this class has or uses:
//
#include "ComponentData.h"
#include "Component.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

// This is needed for the message map below because the second template parameter 
// causes preprocessor grief.

class CAddClientDialog;

typedef CIASDialog<CAddClientDialog,FALSE> CIASDialogCAddClientDialogFALSE;


class CClientsNode;
class CClientNode;

// We want to handle lifetime on this object ourselves, hence the FALSE for bAutoDelete
class CAddClientDialog : public CIASDialog<CAddClientDialog,FALSE>
{


public:

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of 
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_ADD_CLIENT };

	BEGIN_MSG_MAP(CAddClientDialog)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDOK, OnOK )
		COMMAND_ID_HANDLER( IDCANCEL, OnCancel )
		COMMAND_ID_HANDLER( IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT, OnConfigureClient )
//		CHAIN_MSG_MAP( CIASDialog<CAddClientDialog,FALSE> )	// Second template parameter causes preprocessor grief.
		CHAIN_MSG_MAP( CIASDialogCAddClientDialogFALSE )
	END_MSG_MAP()

	CAddClientDialog();

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnOK(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnConfigureClient(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	HRESULT GetHelpPath( LPTSTR szHelpPath );


	CComPtr<IConsole> m_spConsole;



	// SDO management.
	HRESULT LoadCachedInfoFromSdo( void );


	// These are pointers to IComponentData and/or IComponent which will be
	// passed in on creation of the dialog so that this dialog will
	// be able to access functions it may need.
	CComPtr<IComponentData> m_spComponentData;
	CComPtr<IComponent> m_spComponent;

	// This is a pointer to the sdo clients collection.
	CComPtr<ISdoCollection> m_spClientsSdoCollection;

	// This is a pointer to the node to which this dialog will add clients.
	// It gets set in the constructor of this class.
	CClientsNode * m_pClientsNode;

	// This is a pointer to the SDO object for the newly added client.
	CComPtr<ISdo> m_spClientSdo;

protected:



	// This is a pointer to the client node which this dialog will add.
	// It gets created in the OnConfigureClient of this class.
	CClientNode * m_pClientNode;

};

#endif // _IAS_ADD_CLIENT_DIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\addclientwizardpage1.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    AddClientWizardPage1.cpp

Abstract:

	Implementation file for the ClientsPage class.

	We implement the class needed to handle the property page for the Client node.

Author:

    Michael A. Maguire 03/26/98

Revision History:
	mmaguire 03/26/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "AddClientWizardPage1.h"
//
//
// where we can find declarations needed in this file:
//
#include "ClientNode.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage1::CAddClientWizardPage1

--*/
//////////////////////////////////////////////////////////////////////////////
CAddClientWizardPage1::CAddClientWizardPage1( LONG_PTR hNotificationHandle, CClientNode *pClientNode,  TCHAR* pTitle, BOOL bOwnsNotificationHandle )
						: CIASPropertyPageNoHelp<CAddClientWizardPage1> ( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
	ATLTRACE(_T("# +++ CAddClientWizardPage1::CAddClientWizardPage1\n"));


	// Check for preconditions:
	_ASSERTE( pClientNode != NULL );



	// Add the help button to the page
//	m_psp.dwFlags |= PSP_HASHELP;

	// We immediately save off a parent to the client node.
	// We don't want to keep and use a pointer to the client object
	// because the client node pointers may change out from under us
	// if the user does something like call refresh.  We will
	// use only the SDO, and notify the parent of the client object
	// we are modifying that it (and its children) may need to refresh
	// themselves with new data from the SDO's.
	m_pParentOfNodeBeingModified = pClientNode->m_pParentNode;


}



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage1::~CAddClientWizardPage1

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CAddClientWizardPage1::~CAddClientWizardPage1()
{
	ATLTRACE(_T("# --- CAddClientWizardPage1::CAddClientWizardPage1\n"));

}



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage1::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientWizardPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE(_T("# CAddClientWizardPage1::OnInitDialog\n"));

	
	// Check for preconditions:
	_ASSERTE( m_spSdoClient );

	HRESULT				hr;
	CComBSTR			bstrTemp;
	LRESULT lresResult;



	// Initialize the data on the property page.

	
	hr = GetSdoBSTR( m_spSdoClient, PROPERTY_SDO_NAME, &bstrTemp, IDS_ERROR__CLIENT_READING_NAME, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__NAME, bstrTemp );

		// Initialize the dirty bits;
		// We do this after we've set all the data above otherwise we get false
		// notifications that data has changed when we set the edit box text.
		m_fDirtyClientName			= FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			// This means that this property has not yet been initialized
			// with a valid value and the user must enter something.
			SetDlgItemText(IDC_EDIT_SERVER_PAGE1__NAME, _T("") );
			m_fDirtyClientName			= TRUE;
			SetModified( TRUE );
		}

	}
	bstrTemp.Empty();


	// Populate the list of protocol types.

	// For now, we simply hard-code in one protocol type -- RADIUS.
	// Later, we will read in the list of supported protocols
	// from a Server Data Object.

	// Initialize the list box.
	lresResult = ::SendMessage( GetDlgItem( IDC_COMBO_ADD_CLIENT__PROTOCOL ), CB_RESETCONTENT, 0, 0);

	TCHAR szRADIUS[IAS_MAX_STRING];

	int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_RADIUS_PROTOCOL, szRADIUS, IAS_MAX_STRING );
	_ASSERT( nLoadStringResult > 0 );

	// Add an item to it.
	lresResult = ::SendMessage( GetDlgItem( IDC_COMBO_ADD_CLIENT__PROTOCOL ), CB_ADDSTRING, 0, (LPARAM) szRADIUS );

	// Make sure to select the first object in the combo box.
	lresResult = ::SendMessage( GetDlgItem( IDC_COMBO_ADD_CLIENT__PROTOCOL ), CB_SETCURSEL, 0, 0 );



	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage1::OnChange

Called when the WM_COMMAND message is sent to our page with any of the
BN_CLICKED, EN_CHANGE or CBN_SELCHANGE notifications.

This is our chance to check to see what the user has touched, set the
dirty bits for these items so that only they will be saved,
and enable the Apply button.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientWizardPage1::OnChange(		
							  UINT uMsg
							, WPARAM wParam
							, HWND hwnd
							, BOOL& bHandled
							)
{
	ATLTRACE(_T("# CAddClientWizardPage1::OnChange\n"));

	
	// Check for preconditions:
	// None.
	
	// We don't want to prevent anyone else down the chain from receiving a message.
	bHandled = FALSE;

	// Figure out which item has changed and set the dirty bit for that item.
	int iItemID = (int) LOWORD(wParam);

	switch( iItemID )
	{
	case IDC_EDIT_CLIENT_PAGE1__NAME:
		m_fDirtyClientName = TRUE;
		break;
	default:
		return TRUE;
		break;
	}

	// We should only get here if the item that changed was
	// one of the ones we were checking for.
	// This enables the Apply button.
	SetModified( TRUE );
	
	return TRUE;	// ISSUE: what do we need to be returning here?
}



/////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage1::GetHelpPath

Remarks:

	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help
	button of a property sheet.

	It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
/*
HRESULT CAddClientWizardPage1::GetHelpPath( LPTSTR szHelpPath )
{
	ATLTRACE(_T("# CAddClientWizardPage1::GetHelpPath\n"));


	// Check for preconditions:



#ifdef UNICODE_HHCTRL
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("idh_add_client.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "idh_add_client.htm" );
#endif

	return S_OK;
}
*/


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage1::OnWizardNext

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnApply gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnApply method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CAddClientWizardPage1::OnWizardNext()
{
	ATLTRACE(_T("# CAddClientWizardPage1::OnWizardNext\n"));


	// Check for preconditions:


	if( m_spSdoClient == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO );
		return FALSE;
	}


	HRESULT			hr;
	BOOL			bResult;
	CComBSTR		bstrTemp;

	// Save data from property page to the Sdo.

	bResult = GetDlgItemText( IDC_EDIT_ADD_CLIENT__NAME, (BSTR &) bstrTemp );
	if( ! bResult )
	{
		// We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
		bstrTemp = SysAllocString( _T("") );
	}
	else
	{
		::CString str = bstrTemp;
		str.TrimLeft();
		str.TrimRight();
		bstrTemp = str;
		if (str.IsEmpty())
		{
			ShowErrorDialog( m_hWnd, IDS_ERROR__CLIENTNAME_EMPTY);
			return FALSE;
		}
	}

	hr = PutSdoBSTR( m_spSdoClient, PROPERTY_SDO_NAME, &bstrTemp, IDS_ERROR__CLIENT_WRITING_NAME, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		// Turn off the dirty bit.
		m_fDirtyClientName = FALSE;
	}
	else
	{
		return FALSE;
	}
	bstrTemp.Empty();


	return TRUE;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage1::OnQueryCancel

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnQueryCancel gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnQueryCancel method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CAddClientWizardPage1::OnQueryCancel()
{
	ATLTRACE(_T("# CAddClientWizardPage1::OnQueryCancel\n"));
	

	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage1::OnSetActive

Return values:

	TRUE if the page can be made active
	FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

	If you want to change which pages are visited based on a user's
	choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CAddClientWizardPage1::OnSetActive()
{
	ATLTRACE(_T("# CAddClientWizardPage1::OnSetActive\n"));
	
	// MSDN docs say you need to use PostMessage here rather than SendMessage.
	::PostMessage(GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);

	return TRUE;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage1::InitSdoPointers

Return values:

	HRESULT.

Remarks:

	There's no need to marshal interface pointers here as we did for
	the property page -- wizards run in the same, main, MMC thread.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CAddClientWizardPage1::InitSdoPointers(	  ISdo * pSdoClient )
{
	ATLTRACE(_T("# CAddClientWizardPage1::InitSdoPointers\n"));

	HRESULT hr = S_OK;

	m_spSdoClient = pSdoClient;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\addclientdialog.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	AddClientDialog.cpp

Abstract:

	Implementation file for the CAddClientDialog class.

Author:

    Michael A. Maguire 01/09/98

Revision History:
	mmaguire 01/09/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "AddClientDialog.h"
//
// where we can find declarations needed in this file:
//
#include "ClientsNode.h"
#include "ClientNode.h"
#include "ClientPage1.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



// Initialize the Help ID pairs.
const DWORD CAddClientDialog::m_dwHelpMap[] = 
{
	IDC_EDIT_ADD_CLIENT__NAME,							IDH_EDIT_ADD_CLIENT__NAME,
	IDC_COMBO_ADD_CLIENT__PROTOCOL,						IDH_COMBO_ADD_CLIENT__PROTOCOL,
	IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT,			IDH_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT,
	IDOK,												IDH_BUTTON_ADD_CLIENT__OK,
	IDCANCEL,											IDH_BUTTON_ADD_CLIENT__CANCEL,
	0, 0
};



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientDialog::CAddClientDialog

--*/
//////////////////////////////////////////////////////////////////////////////
CAddClientDialog::CAddClientDialog()
{
	ATLTRACE(_T("# +++ AddClientDialog::AddClientDialog\n"));


	// Check for preconditions:




	// We have no client configured yet
	m_pClientNode = NULL;

}




//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientDialog::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientDialog::OnInitDialog(
	  UINT uMsg
	, WPARAM wParam
	, LPARAM lParam
	, BOOL& bHandled
	)
{
	ATLTRACE(_T("# AddClientDialog::OnInitDialog\n"));


	// Check for preconditions:
	// None.


	LRESULT lresResult;
	long lButtonStyle;

	// Populate the list of protocol types.

	// For now, we simply hard-code in one protocol type -- RADIUS.
	// Later, we will read in the list of supported protocols
	// from a Server Data Object.

	// Initialize the list box.
	lresResult = ::SendMessage( GetDlgItem( IDC_COMBO_ADD_CLIENT__PROTOCOL ), CB_RESETCONTENT, 0, 0);

	TCHAR szRADIUS[IAS_MAX_STRING];

	int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_RADIUS_PROTOCOL, szRADIUS, IAS_MAX_STRING );
	_ASSERT( nLoadStringResult > 0 );

	// Add an item to it.
	lresResult = ::SendMessage( GetDlgItem( IDC_COMBO_ADD_CLIENT__PROTOCOL ), CB_ADDSTRING, 0, (LPARAM) szRADIUS );

	// Make sure to select the first object in the combo box.
	lresResult = ::SendMessage( GetDlgItem( IDC_COMBO_ADD_CLIENT__PROTOCOL ), CB_SETCURSEL, 0, 0 );



	// Disable the IDOK button.
	::EnableWindow( GetDlgItem( IDOK ), FALSE );
	lButtonStyle = ::GetWindowLong( GetDlgItem( IDOK ), GWL_STYLE );
	lButtonStyle = lButtonStyle & ~BS_DEFPUSHBUTTON;
	SendDlgItemMessage( IDOK, BM_SETSTYLE, LOWORD(lButtonStyle), MAKELPARAM(1,0) );

	// Make sure the "Configure" button is the default button.
	lButtonStyle = ::GetWindowLong( GetDlgItem( IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT ), GWL_STYLE );
	lButtonStyle = lButtonStyle | BS_DEFPUSHBUTTON;
	SendDlgItemMessage( IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT, BM_SETSTYLE, LOWORD(lButtonStyle), MAKELPARAM(1,0) );
//	::SetFocus( GetDlgItem( IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT ) );



	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientDialog::OnConfigureClient

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientDialog::OnConfigureClient(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# AddClientDialog::OnConfigureClient\n"));


	// Check for preconditions:



	// ISSUE: Need to figure out how to convert HRESULT to LRESULT here.
	LRESULT lr = TRUE;
	HRESULT hr = S_OK;
//	long lButtonStyle;
	


	// Make the Configure button no longer the default
//	lButtonStyle = ::GetWindowLong( GetDlgItem( IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT ), GWL_STYLE );
//	lButtonStyle = lButtonStyle & ~BS_DEFPUSHBUTTON;
//	SendDlgItemMessage( IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT, BM_SETSTYLE, LOWORD(lButtonStyle), MAKELPARAM(1,0) );



	// For now, we simply configure a RADIUS client.
	// In the future, we will choose which kind of client configuration page to pop up
	// depending on the type of protocol selected by the user in IDC_COMBO_ADD_CLIENT__PROTOCOL.


	// If we have not already created a new Client item, create it now.
	// Then pop up property pages on it to allow the user to configure it.

	// The client object may have already been created if this is the second time
	// the user clicked on the Configure button.
	
	if( NULL == m_pClientNode )
	{

		// We have not yet tried to create the client object.
		// Try to create it.

		// Check to make sure we have a valid SDO pointer.
		if( m_spClientsSdoCollection == NULL )
		{
			// No SDO pointer.
			ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO );
			return E_POINTER;
		}


		// Create the client UI object.
		m_pClientNode = new CClientNode( m_pClientsNode );
	
		if( NULL == m_pClientNode )
		{
			// We failed to create the client node.
			ShowErrorDialog( m_hWnd, IDS_ERROR__OUT_OF_MEMORY );

			// ISSUE: This functions requires an LRESULT return value,
			// not an HRESULT.  What is the relationship between L and H RESULT's?
			return E_OUTOFMEMORY;
		}
	
		
		// Set the name of the new client to be what the user just entered.
		GetDlgItemText( IDC_EDIT_ADD_CLIENT__NAME, (BSTR &) m_pClientNode->m_bstrDisplayName );

		if( m_pClientNode->m_bstrDisplayName == NULL )
		{
			// There is no name specified for the client.
			ShowErrorDialog( m_hWnd, IDS_ADD_CLIENT__REQUIRES_NAME );

			delete m_pClientNode;
			m_pClientNode = NULL;
			return FALSE;
		}

		// GetDlgItemText should return a NULL pointer if the string is blank.
		_ASSERTE( wcslen( m_pClientNode->m_bstrDisplayName) != 0 );


		// Try to Add a new client to the clients sdo collection.
		CComPtr<IDispatch> spDispatch;
		hr =  m_spClientsSdoCollection->Add( m_pClientNode->m_bstrDisplayName, (IDispatch **) &spDispatch );
		if( FAILED( hr ) )
		{

#ifdef SDO_COLLECTION_HAS_LAST_ERROR

			// Once Todd adds a LastError method to the ISdoCollection interface,
			// we will be able to query to find out exactly why we couldn't add a new client.

			CComBSTR		bstrError;

			// Figure out error and give back appropriate messsage.
			m_spClientsSdoCollection->LastError( &bstrError );
			ShowErrorDialog( m_hWnd, IDS_ERROR__ADDING_OBJECT_TO_COLLECTION, bstrError  );

#else	// SDO_COLLECTION_HAS_LAST_ERROR
			
			// For now, just give back an error saying that we couldn't add it.

			// We could not create the object.
			ShowErrorDialog( m_hWnd, IDS_ERROR__ADDING_OBJECT_TO_COLLECTION );

#endif	// SDO_COLLECTION_HAS_LAST_ERROR

			// Clean up.
			delete m_pClientNode;
			m_pClientNode = NULL;
			return( hr );
		}

		// Query the returned IDispatch interface for an ISdo interface.
		_ASSERTE( spDispatch != NULL );
		hr = spDispatch->QueryInterface( IID_ISdo, (void **) &m_spClientSdo );
		spDispatch.Release();

		if( m_spClientSdo == NULL || FAILED(hr) )
		{
			// For some reason, we couldn't get the client sdo.
			ShowErrorDialog( m_hWnd, IDS_ERROR__ADDING_OBJECT_TO_COLLECTION  );

			// Clean up after ourselves.
			delete m_pClientNode;
			m_pClientNode = NULL;
			return( hr );
		}


		// Give the client node its sdo pointer
		m_pClientNode->InitSdoPointers( m_spClientSdo );

	}


	// Bring up the property pages on the node so the user can configure it.
	// This returns S_OK if a property sheet for this object already exists
	// and brings that property sheet to the foreground, otherwise
	// it creates a new sheet
	hr = BringUpPropertySheetForNode( 
					  m_pClientNode 
					, m_spComponentData
					, m_spComponent
					, m_spConsole
					, TRUE
					, m_pClientNode->m_bstrDisplayName
					, TRUE
					);


	return lr;


}



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientDialog::OnOK

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientDialog::OnOK(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# AddClientDialog::OnOK\n"));


	// Check for preconditions:
	_ASSERTE( m_pClientsNode != NULL );
	


	HRESULT hr;

	if( m_pClientNode == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__CLIENT_NOT_YET_CONFIGURED );
		return 0;
	}

	// We should only be able to hit apply if a client was configured.
	_ASSERTE( m_pClientNode != NULL );


	if( m_pClientNode != NULL )
	{
		// There is already a client node created.

		// First try to see if a property sheet for this node is already up.
		// If so, bring it to the foreground.

		// This returns S_OK if a property sheet for this object already exists
		// and brings that property sheet to the foreground.
		// It returns S_FALSE if the property sheet wasn't found.
		hr = BringUpPropertySheetForNode( 
					  m_pClientNode
					, m_spComponentData
					, m_spComponent
					, m_spConsole
					);

		if( FAILED( hr ) )
		{
			return hr;
		}

		
		if( S_OK == hr )
		{
			// We found a property sheet already up for this node.
			ShowErrorDialog( m_hWnd, IDS_ERROR__CLOSE_PROPERTY_SHEET );
			return 0;
		
		}


		// If we made it to here, the client object has already been created
		// and there was no property sheet up for it anymore.

		// Make sure the node object knows about any changes we made to SDO while in proppage.
		m_pClientNode->LoadCachedInfoFromSdo();

		// Add the child to the UI's list of nodes and end this dialog.
		m_pClientsNode->AddSingleChildToListAndCauseViewUpdate( m_pClientNode );

		EndDialog(TRUE);

	}

	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientDialog::OnCancel

The user chose not to add the new client.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientDialog::OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# AddClientDialog::OnCancel\n"));


	// Check for preconditions:
	_ASSERTE( m_spConsole != NULL );



	HRESULT hr = S_OK;


	if( m_pClientNode != NULL )
	{
		// There is already a client node created.

		// First try to see if a property sheet for this node is already up.
		// If so, bring it to the foreground.

		// This returns S_OK if a property sheet for this object already exists
		// and brings that property sheet to the foreground.
		// It returns S_FALSE if the property sheet wasn't found.
		hr = BringUpPropertySheetForNode( 
					  m_pClientNode
					, m_spComponentData
					, m_spComponent
					, m_spConsole
					);

		if( FAILED( hr ) )
		{
			return hr;
		}
		
		if( S_OK == hr )
		{
			// We found a property sheet already up for this node.
			ShowErrorDialog( m_hWnd, IDS_ERROR__CLOSE_PROPERTY_SHEET );
			return 0;
		
		}

		// We didn't find a property sheet already up for this node.
		_ASSERTE( S_FALSE == hr );

		// Delete the node, since the user choose not to add it.
		delete m_pClientNode;

		if( m_spClientSdo != NULL )
		{
			// We had already added a client object to the SDO's.
			// We should remove it from the clients collection.

			// Check to make sure we have a valid SDO pointer for the clients collection.
			_ASSERTE( m_spClientsSdoCollection != NULL );

			// Delete the client sdo from the collection.
			hr = m_spClientsSdoCollection->Remove( m_spClientSdo );
			_ASSERTE( SUCCEEDED( hr ) );

		}


	}

	// If we made it to here, either we had a node configured but we deleted it,
	// or we never added a node at all.

	hr = S_OK;

	EndDialog(FALSE);

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CAddClientDialog::GetHelpPath

Remarks:

	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help 
	button of a property sheet.

	It is an override of CIASDialog::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CAddClientDialog::GetHelpPath( LPTSTR szHelpPath )
{
	ATLTRACE(_T("# CAddClientDialog::GetHelpPath\n"));


	// Check for preconditions:



#ifdef UNICODE_HHCTRL
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("idh_add_client.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "idh_add_client.htm" );
#endif

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CAddClientDialog::LoadCachedInfoFromSdo

Remarks:

	This method is called when the AddClientDialog needs to update any
	info it might be displaying from the SDO object.

	It might get called when the property sheet we pop up from this
	dialog sends back a property change notification.
	
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CAddClientDialog::LoadCachedInfoFromSdo( void )
{
	ATLTRACE(_T("# CAddClientDialog::GetHelpPath\n"));


	// Check for preconditions:


	HRESULT hr = S_OK;


	if( m_spClientSdo != NULL )
	{
		CComVariant spVariant;

		hr = m_spClientSdo->GetProperty( PROPERTY_SDO_NAME, &spVariant );
		if( SUCCEEDED( hr ) )
		{
			_ASSERTE( spVariant.vt == VT_BSTR );
			SetDlgItemText( IDC_EDIT_ADD_CLIENT__NAME, spVariant.bstrVal );
		}
		else
		{
			// Fail silently.
		}
		spVariant.Clear();


	}


	// Enable the IDOK button and make it the default
	long lButtonStyle;
	::EnableWindow( GetDlgItem( IDOK ), TRUE );
	lButtonStyle = ::GetWindowLong( GetDlgItem( IDOK ), GWL_STYLE );
	lButtonStyle = lButtonStyle | BS_DEFPUSHBUTTON;
	SendDlgItemMessage( IDOK, BM_SETSTYLE, LOWORD(lButtonStyle), MAKELPARAM(1,0) );
	::SetFocus( GetDlgItem(IDOK) );

	return hr;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\addclientwizardpage2.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    AddClientWizardPage2.cpp

Abstract:

   Implementation file for the ClientsPage class.

   We implement the class needed to handle the property page for the Client node.

Author:

    Michael A. Maguire 03/26/98

Revision History:
   mmaguire 03/26/98 - created
   sbens    01/25/00 - Remove PROPERTY_CLIENT_FILTER_VSAS


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "AddClientWizardPage2.h"
//
//
// where we can find declarations needed in this file:
//
#include "ClientNode.h"
#include "ClientsNode.h"
#include "ResolveDNSName.h"

void TrimCComBSTR(CComBSTR& bstr);
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::CAddClientWizardPage2

--*/
//////////////////////////////////////////////////////////////////////////////
CAddClientWizardPage2::CAddClientWizardPage2( LONG_PTR hNotificationHandle, CClientNode *pClientNode,  TCHAR* pTitle, BOOL bOwnsNotificationHandle )
                  : CIASPropertyPageNoHelp<CAddClientWizardPage2> ( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
   ATLTRACE(_T("# +++ CAddClientWizardPage2::CAddClientWizardPage2\n"));


   // Check for preconditions:
   _ASSERTE( pClientNode != NULL );


   // Add the help button to the page
// m_psp.dwFlags |= PSP_HASHELP;

   // Save the node being modified.
   m_pNodeBeingCreated = pClientNode;

}


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::~CAddClientWizardPage2

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CAddClientWizardPage2::~CAddClientWizardPage2()
{
   ATLTRACE(_T("# --- CAddClientWizardPage2::CAddClientWizardPage2\n"));
}


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientWizardPage2::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   ATLTRACE(_T("# CAddClientWizardPage2::OnInitDialog\n"));

   
   // Check for preconditions:
   _ASSERTE( m_spSdoClient );
   _ASSERTE( m_spSdoServiceControl );

   HRESULT        hr;
   CComBSTR       bstrTemp;
   BOOL           bTemp;
   LONG           lTemp;



   // Initialize the data on the property page.

   
   hr = GetSdoBSTR( m_spSdoClient, PROPERTY_CLIENT_ADDRESS, &bstrTemp, IDS_ERROR__CLIENT_READING_ADDRESS, m_hWnd, NULL );
   if( SUCCEEDED( hr ) )
   {
      SetDlgItemText( IDC_EDIT_CLIENT_PAGE1__ADDRESS, bstrTemp );
      m_fDirtyAddress            = FALSE;
   }
   else
   {
      if( OLE_E_BLANK == hr )
      {
         SetDlgItemText( IDC_EDIT_CLIENT_PAGE1__ADDRESS, _T("") );
         m_fDirtyAddress            = TRUE;
         SetModified( TRUE );
      }
   }
   bstrTemp.Empty();


   lTemp = 311;   // Microsoft RRAS
   
   // Populate the list box of NAS vendors.
   // Set focus in list box to currently chosen vendor type.
   hr = GetSdoI4( m_spSdoClient, PROPERTY_CLIENT_NAS_MANUFACTURER, &lTemp, IDS_ERROR__CLIENT_READING_MANUFACTURER, m_hWnd, NULL );
   if( SUCCEEDED( hr ) )
   {
      m_fDirtyManufacturer    = FALSE;
   }
   else
   {
      if( OLE_E_BLANK == hr )
      {
         m_fDirtyManufacturer    = TRUE;
         SetModified( TRUE );
      }
   }
   

   // Initialize the combo box.
   LRESULT lresResult = SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_RESETCONTENT, 0, 0);

   for (size_t iVendorCount = 0; iVendorCount < m_vendors.Size(); ++iVendorCount )
   {
      
      // Add the address string to the combo box.
      lresResult = SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_ADDSTRING, 0, (LPARAM)m_vendors.GetName(iVendorCount));
      if(lresResult != CB_ERR)
      {
         SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_SETITEMDATA, lresResult, (LPARAM)m_vendors.GetVendorId(iVendorCount));

         // if selected
         if( lTemp == (LONG)m_vendors.GetVendorId(iVendorCount))
            SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_SETCURSEL, lresResult, 0 );
      }
               
      
   }


   hr = GetSdoBOOL( m_spSdoClient, PROPERTY_CLIENT_REQUIRE_SIGNATURE, &bTemp, IDS_ERROR__CLIENT_READING_REQUIRE_SIGNATURE, m_hWnd, NULL );
   if( SUCCEEDED( hr ) )
   {
      SendDlgItemMessage(IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE, BM_SETCHECK, bTemp, 0);
      m_fDirtySendSignature      = FALSE;
   }
   else
   {
      if( OLE_E_BLANK == hr )
      {
         SendDlgItemMessage(IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE, BM_SETCHECK, FALSE, 0);
         m_fDirtySendSignature      = TRUE;
         SetModified( TRUE );
      }
   }
   
#ifdef      __NEED_GET_SHARED_SECRET_OUT__      // this should NOT be true
   // ISSUE: Do we even want the UI to retrieve and display this information?
   hr = GetSdoBSTR( m_spSdoClient, PROPERTY_CLIENT_SHARED_SECRET, &bstrTemp, IDS_ERROR__CLIENT_READING_SHARED_SECRET, m_hWnd, NULL );
   if( SUCCEEDED( hr ) )
   {
      SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET, bstrTemp );
      SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM, bstrTemp );
      m_fDirtySharedSecret = FALSE;
   }
   else
   {
      if( OLE_E_BLANK == hr )
      {
         SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET, _T("") );
         SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM, _T("") );
         m_fDirtySharedSecret = TRUE;
         SetModified( TRUE );
      }
   }
   bstrTemp.Empty();
#endif


   return TRUE;   // ISSUE: what do we need to be returning here?
}


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::OnChange

Called when the WM_COMMAND message is sent to our page with any of the
BN_CLICKED, EN_CHANGE or CBN_SELCHANGE notifications.

This is our chance to check to see what the user has touched, set the
dirty bits for these items so that only they will be saved,
and enable the Apply button.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientWizardPage2::OnChange(     
                       UINT uMsg
                     , WPARAM wParam
                     , HWND hwnd
                     , BOOL& bHandled
                     )
{
   ATLTRACE(_T("# CAddClientWizardPage2::OnChange\n"));

   
   // Check for preconditions:
   // None.
   
   // We don't want to prevent anyone else down the chain from receiving a message.
   bHandled = FALSE;

   // Figure out which item has changed and set the dirty bit for that item.
   int iItemID = (int) LOWORD(wParam);

   switch( iItemID )
   {
   case IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE:
      m_fDirtySendSignature = TRUE;
      break;
   case IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET:
   case IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM:
      m_fDirtySharedSecret = TRUE;
      break;
   default:
      return TRUE;
      break;
   }

   // We should only get here if the item that changed was
   // one of the ones we were checking for.
   // This enables the Apply button.
   SetModified( TRUE );
   
   return TRUE;   // ISSUE: what do we need to be returning here?
}


/////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::GetHelpPath

Remarks:

   This method is called to get the help file path within
   an compressed HTML document when the user presses on the Help
   button of a property sheet.

   It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
/*
HRESULT CAddClientWizardPage2::GetHelpPath( LPTSTR szHelpPath )
{
   ATLTRACE(_T("# CAddClientWizardPage2::GetHelpPath\n"));


   // Check for preconditions:



#ifdef UNICODE_HHCTRL
   // ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
   // installed on this machine -- it appears to be non-unicode.
   lstrcpy( szHelpPath, _T("idh_proppage_client1.htm") );
#else
   strcpy( (CHAR *) szHelpPath, "idh_proppage_client1.htm" );
#endif

   return S_OK;
}
*/

//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::OnWizardFinish

Return values:

   TRUE if the sheet can be destroyed,
   FALSE if the sheet should not be destroyed (i.e. there was invalid data).

Remarks:

   OnApply gets called for each page in on a property sheet if that
   page has been visited, regardless of whether any values were changed.

   If you never switch to a tab, then its OnApply method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CAddClientWizardPage2::OnWizardFinish()
{
   ATLTRACE(_T("# CAddClientWizardPage2::OnWizardFinish\n"));


   // Check for preconditions:
   CClientsNode * pClientsNode = (CClientsNode *) ( (CClientNode *) m_pNodeBeingCreated )->m_pParentNode;
   _ASSERTE( pClientsNode != NULL );


   if( m_spSdoClient == NULL )
   {
      ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO );
      return FALSE;
   }


   BOOL        bRet = TRUE;
   UINT        idOfFocus = 0;
   HRESULT     hr;
   BOOL        bResult;
   CComBSTR    bstrTemp;
   BOOL        bTemp;
   LONG        lTemp;

   // Save data from property page to the Sdo.

   do 
   {  // false loop just to break when error

      bResult = GetDlgItemText( IDC_EDIT_CLIENT_PAGE1__ADDRESS, (BSTR &) bstrTemp);
      if( ! bResult )
      {
         // We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
         bstrTemp = SysAllocString( _T("") );
      }
      else
      {
         // trim the address
         TrimCComBSTR(bstrTemp);
         SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__ADDRESS, 
                        static_cast<LPCWSTR>(bstrTemp));
      }

      hr = PutSdoBSTR( m_spSdoClient, PROPERTY_CLIENT_ADDRESS, &bstrTemp, IDS_ERROR__CLIENT_WRITING_ADDRESS, m_hWnd, NULL );
      if( SUCCEEDED( hr ) )
      {
         // Turn off the dirty bit.
         m_fDirtyAddress = FALSE;
      }
      else
      {
         idOfFocus = IDC_EDIT_CLIENT_PAGE1__ADDRESS;
         bRet = FALSE;
         break;
      }
      bstrTemp.Empty();

      LRESULT lresIndex =  SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_GETCURSEL, 0, 0);

      if( lresIndex != CB_ERR )
      {
         lTemp =  SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_GETITEMDATA, lresIndex, 0);
      }
      else
      {
         // Set the value to be "Others"
         lTemp = 0;
      }

      hr = PutSdoI4( m_spSdoClient, PROPERTY_CLIENT_NAS_MANUFACTURER, lTemp, IDS_ERROR__CLIENT_WRITING_MANUFACTURER, m_hWnd, NULL );
      if( SUCCEEDED( hr ) )
      {
         // Turn off the dirty bit.
         m_fDirtyManufacturer = FALSE;

      }
      else
      {
         idOfFocus = IDC_COMBO_CLIENT_PAGE1__MANUFACTURER;
         bRet = FALSE;
         break;
      }

      bTemp = SendDlgItemMessage(IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE, BM_GETCHECK, 0, 0);
      hr = PutSdoBOOL( m_spSdoClient, PROPERTY_CLIENT_REQUIRE_SIGNATURE, bTemp, IDS_ERROR__CLIENT_WRITING_REQUIRE_SIGNATURE, m_hWnd, NULL );
      if( SUCCEEDED( hr ) )
      {
         // Turn off the dirty bit.
         m_fDirtySendSignature = FALSE;
      }
      else
      {
         idOfFocus = IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE;
         bRet = FALSE;
         break;
      }

      CComBSTR bstrSharedSecret;
      bResult = GetDlgItemText( IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET, (BSTR &) bstrSharedSecret );
      if( ! bResult )
      {
         // We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
         bstrSharedSecret = _T("");
      }

      CComBSTR bstrConfirmSharedSecret;
      bResult = GetDlgItemText( IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM, (BSTR &) bstrConfirmSharedSecret );
      if( ! bResult )
      {
         // We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
         bstrConfirmSharedSecret = _T("");
      }
   
      if( lstrcmp( bstrSharedSecret, bstrConfirmSharedSecret ) )  
      {
         ShowErrorDialog( m_hWnd, IDS_ERROR__SHARED_SECRETS_DONT_MATCH );
         idOfFocus = IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET;
         bRet = FALSE;
         break;
      }
   
      hr = PutSdoBSTR( m_spSdoClient, PROPERTY_CLIENT_SHARED_SECRET, &bstrSharedSecret, IDS_ERROR__CLIENT_WRITING_SHARED_SECRET, m_hWnd, NULL );
      if( SUCCEEDED( hr ) )
      {
         // Turn off the dirty bit.
         m_fDirtySharedSecret = FALSE;
      }
      else
      {
         idOfFocus = IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET;
         bRet = FALSE;
         break;
      }

      bstrTemp.Empty();

      // If we made it to here, try to apply the changes.
      // Since there is only one page for a client node, we don't
      // have to worry about synchronizing two or more pages
      // so that we only apply if they both are ready.
      // This is why we don't use m_pSynchronizer.
      hr = m_spSdoClient->Apply();
      if( FAILED( hr ) )
      {
         if(hr == DB_E_NOTABLE)  // assume, the RPC connection has problem
            ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
         else     
         {
//    m_spSdoClient->LastError( &bstrError );
//    ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, bstrError );
            ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO );
         }
         bRet = FALSE;
         break;
      }
      else
      {
         // We succeeded.

         // Tell the service to reload data.
         HRESULT hrTemp = m_spSdoServiceControl->ResetService();
         if( FAILED( hrTemp ) )
         {
            // Fail silently.
         }

         // Make sure the node object knows about any changes we made to SDO while in proppage.
         ( (CClientNode *) m_pNodeBeingCreated )->LoadCachedInfoFromSdo();

         // Add the child to the UI's list of nodes and end this dialog.
         pClientsNode->AddSingleChildToListAndCauseViewUpdate( (CClientNode *) m_pNodeBeingCreated );


//    Not needed because we are modal.  The AddSingleChildToListAndCauseViewUpdate command above
//    will update the view.
//    HRESULT hr = PropertyChangeNotify( (LPARAM) ( (CSnapInItem *) pClientsNode) );
//    _ASSERTE( SUCCEEDED( hr ) );
      }

   } while (FALSE);  // false loop just to break when error


   if(bRet == FALSE) // error condition
   {
      if(idOfFocus == 0)
      {
         // then set to the first control
         idOfFocus = IDC_EDIT_CLIENT_PAGE1__ADDRESS;
      }

      SetActiveWindow();
      ShowWindow(SW_SHOW);
      EnableWindow(TRUE);

      DWORD dwErr = 0;
      HWND hWnd = GetFocus();
      ::EnableWindow(hWnd, TRUE);

      ::SetFocus(GetDlgItem(idOfFocus));

      if(idOfFocus == IDC_EDIT_CLIENT_PAGE1__ADDRESS)
      {
         ::SendMessage(GetDlgItem(idOfFocus), EM_SETSEL, 0, -1);
      }
   }

   return bRet;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::OnQueryCancel

Return values:

   TRUE if the page can be destroyed,
   FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

   OnQueryCancel gets called for each page in on a property sheet if that
   page has been visited, regardless of whether any values were changed.

   If you never switch to a tab, then its OnQueryCancel method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CAddClientWizardPage2::OnQueryCancel()
{
   ATLTRACE(_T("# CAddClientWizardPage2::OnQueryCancel\n"));
   
   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::OnSetActive

Return values:

   TRUE if the page can be made active
   FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

   If you want to change which pages are visited based on a user's
   choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CAddClientWizardPage2::OnSetActive()
{
   ATLTRACE(_T("# CAddClientWizardPage2::OnSetActive\n"));
   
   // MSDN docs say you need to use PostMessage here rather than SendMessage.
   ::PostMessage(GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_FINISH);

   return TRUE;

}


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::OnResolveClientAddress

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientWizardPage2::OnResolveClientAddress(UINT uMsg, WPARAM wParam, HWND hwnd, BOOL& bHandled)
{
   ATLTRACE(_T("# CAddClientWizardPage2::OnResolveClientAddress\n"));


   // Check for preconditions:

   CComBSTR bstrClientAddress;
   
   CResolveDNSNameDialog * pResolveDNSNameDialog = new CResolveDNSNameDialog();

   // Get the current value in the address field.
   GetDlgItemText(IDC_EDIT_CLIENT_PAGE1__ADDRESS, (BSTR &) bstrClientAddress);
   
   // We pass a pointer to our address BSTR, so that the dialog
   // can use the current value, and replace it with the resolved one
   // if the user so chooses.
   pResolveDNSNameDialog->SetAddress( (BSTR *) &bstrClientAddress );

   // Put up the dialog.
   int iResult = pResolveDNSNameDialog->DoModal( m_hWnd );

   if( iResult )
   {
      // The user chose OK -- change the address to reflect what the user resolved.
      SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__ADDRESS, (LPCTSTR) bstrClientAddress );
   }
   else
   {
      // The user chose cancel -- do nothing.
   }

   delete pResolveDNSNameDialog;

   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::OnLostFocusAddress

  Trim the address for spaces
--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CAddClientWizardPage2::OnLostFocusAddress(
                                  UINT uMsg,
                                  WPARAM wParam,
                                  HWND hwnd,
                                  BOOL& bHandled
                                  )
{
   ATLTRACE(_T("# CAddClientWizardPage2::OnLostFocusAddress\n"));
   
   if (uMsg == EN_KILLFOCUS)
   {
      CComBSTR bstrClientAddress;
      GetDlgItemText(IDC_EDIT_CLIENT_PAGE1__ADDRESS, 
                     reinterpret_cast<BSTR &>(bstrClientAddress));
      TrimCComBSTR(bstrClientAddress);
      SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__ADDRESS, 
                     static_cast<LPCWSTR>(bstrClientAddress));
      m_fDirtyAddress = TRUE;
   }
   
   // We don't want to prevent anyone else down the chain from receiving a message.
   bHandled = FALSE;

   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CAddClientWizardPage2::InitSdoPointers

Return values:

   HRESULT.

Remarks:

   There's no need to marshal interface pointers here as we did for
   the property page -- wizards run in the same, main, MMC thread.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CAddClientWizardPage2::InitSdoPointers(   ISdo * pSdoClient
                        , ISdoServiceControl * pSdoServiceControl
                        , const Vendors& vendors
                        )
{
   ATLTRACE(_T("# CAddClientWizardPage1::InitSdoPointers\n"));

   HRESULT hr = S_OK;

   m_spSdoClient = pSdoClient;

   m_spSdoServiceControl = pSdoServiceControl;

   m_vendors = vendors;

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\addclientwizardpage1.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	AddClientWizardPage1.h

Abstract:

	Header file for the CAddClientWizardPage1 class.

	This is our handler class for the CClientNode property page.

	See ClientPage.cpp for implementation.

Author:

    Michael A. Maguire 03/26/98

Revision History:
	mmaguire 03/26/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_ADD_CLIENT_WIZARD_PAGE_1_H_)
#define _IAS_ADD_CLIENT_WIZARD_PAGE_1_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CClientNode;

class CAddClientWizardPage1 : public CIASPropertyPageNoHelp<CAddClientWizardPage1>
{

public :
	
	CAddClientWizardPage1( LONG_PTR hNotificationHandle, CClientNode *pClientNode,  TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );

	~CAddClientWizardPage1();


	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_WIZPAGE_ADD_CLIENT1 };

	BEGIN_MSG_MAP(CAddClientWizardPage1)
		COMMAND_CODE_HANDLER(BN_CLICKED, OnChange)		
		COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
		COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CAddClientWizardPage1>)
	END_MSG_MAP()


	BOOL OnSetActive();

	BOOL OnWizardNext();

	BOOL OnQueryCancel();


//	HRESULT GetHelpPath( LPTSTR szFilePath );

	HRESULT InitSdoPointers( ISdo * pSdoClient );


protected:
	// Interface pointer for this page's client's sdo.
	CComPtr<ISdo>	m_spSdoClient;

	// When we are passed a pointer to the client node in our constructor,
	// we will save away a pointer to its parent, as this is the node
	// which will need to receive an update message once we have
	// applied any changes.
	CSnapInItem * m_pParentOfNodeBeingModified;

private:

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnChange(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);


protected:
	
	// Dirty bits -- for keeping track of data which has been touched
	// so that we only save data we have to.
	BOOL m_fDirtyClientName;

};

#endif // _IAS_ADD_CLIENT_WIZARD_PAGE_1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\addclientwizardpage2.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

	AddClientWizardPage2.h

Abstract:

	Header file for the CAddClientWizardPage2 class.

	This is our handler class for the CClientNode property page.

	See ClientPage.cpp for implementation.

Author:

    Michael A. Maguire 03/26/98

Revision History:
	mmaguire 03/26/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_ADD_CLIENT_WIZARD_PAGE_2_H_)
#define _IAS_ADD_CLIENT_WIZARD_PAGE_2_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//
#include "Vendors.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CClientNode;

class CAddClientWizardPage2 : public CIASPropertyPageNoHelp<CAddClientWizardPage2>
{

public :
	
	CAddClientWizardPage2( LONG_PTR hNotificationHandle, CClientNode *pClientNode,  TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );

	~CAddClientWizardPage2();


	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_WIZPAGE_ADD_CLIENT2 };

	BEGIN_MSG_MAP(CAddClientWizardPage2)
		COMMAND_CODE_HANDLER(BN_CLICKED, OnChange)		
		COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
		COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
		COMMAND_HANDLER(IDC_EDIT_CLIENT_PAGE1__ADDRESS,EN_KILLFOCUS, OnLostFocusAddress)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDC_BUTTON_CLIENT_PAGE1_FIND, OnResolveClientAddress)
		CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CAddClientWizardPage2>)
	END_MSG_MAP()

	BOOL OnSetActive();

	BOOL OnWizardFinish();

	BOOL OnQueryCancel();


//	HRESULT GetHelpPath( LPTSTR szFilePath );

	HRESULT InitSdoPointers(	  ISdo * pSdoClient
								, ISdoServiceControl * pSdoServiceControl
								, const Vendors& vendors
								);

protected:
	// Interface pointer for this page's client's sdo.
	CComPtr<ISdo>	m_spSdoClient;

	CComPtr<ISdoServiceControl>	m_spSdoServiceControl;

	Vendors m_vendors;


	// This is a pointer to the node to which this dialog will add clients.
	// It gets set in the constructor of this class.
	CSnapInItem * m_pNodeBeingCreated;


private:

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnChange(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnResolveClientAddress(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

   LRESULT OnLostFocusAddress(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);


protected:
	
	// Dirty bits -- for keeping track of data which has been touched
	// so that we only save data we have to.
	BOOL m_fDirtySendSignature;
	BOOL m_fDirtySharedSecret;
	BOOL m_fDirtyAddress;
	BOOL m_fDirtyManufacturer;

};

#endif // _IAS_ADD_CLIENT_WIZARD_PAGE_2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\clientnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ClientNode.h

Abstract:

   Header file for the CClientNode subnode

   See ClientNode.cpp for implementation.

Author:

    Michael A. Maguire 11/19/97

Revision History:
   mmaguire 11/19/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_CLIENT_NODE_H_)
#define _IAS_CLIENT_NODE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "SnapinNode.h"
//
//
// where we can find what this class has or uses:
//
#include "Vendors.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

#define  FAKE_PASSWORD_FOR_DLG_CTRL _T("\b\b\b\b\b\b\b\b")

class CClientsNode;
class CClientPage1;
class CServerNode;
class CComponentData;
class CComponent;

class CClientNode : public CSnapinNode< CClientNode, CComponentData, CComponent >
{
public:
   SNAPINMENUID(IDM_CLIENT_NODE)

   BEGIN_SNAPINTOOLBARID_MAP(CClientNode)
//    SNAPINTOOLBARID_ENTRY(IDR_CLIENT1_TOOLBAR)
//    SNAPINTOOLBARID_ENTRY(IDR_CLIENT2_TOOLBAR)
   END_SNAPINTOOLBARID_MAP()

   // Constructor/Destructor.
   CClientNode( CSnapInItem * pParentNode, BOOL bAddNewClient = FALSE );
   ~CClientNode();

   // This flag should be set in the constructor when a node is
   // being added via the Add New Client command.
   // Clients in this state are "in limbo" and must be treated differently
   // until the user has finished configuring them.
   BOOL m_bAddNewClient;

   // Used to get access to snapin-global data.
   CComponentData * GetComponentData( void );

   // Used to get access to server-global data.
   CServerNode * GetServerRoot( void );

   // SDO management.
   HRESULT InitSdoPointers(     ISdo *pSdo
                        , ISdoServiceControl *pSdoServiceControl
                        , const Vendors& vendors
                        );

   HRESULT LoadCachedInfoFromSdo( void );

   // Related to supporting cut and paste.
   HRESULT FillText(LPSTGMEDIUM pSTM);
   HRESULT FillClipboardData(LPSTGMEDIUM pSTM);
   static HRESULT IsClientClipboardData( IDataObject* pDataObj );
   static CLIPFORMAT m_CCF_CUT_AND_PASTE_FORMAT;
   static void InitClipboardFormat();
   STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type);
   HRESULT GetClientNameFromClipboard( IDataObject* pDataObject, CComBSTR &bstrName );
   HRESULT SetClientWithDataFromClipboard( IDataObject* pDataObject );



    // Overrides for standard MMC functionality.
   STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK pPropertySheetCallback
      , LONG_PTR handle
      , IUnknown* pUnk
      , DATA_OBJECT_TYPES type
      );
   STDMETHOD(QueryPagesFor)( DATA_OBJECT_TYPES type );
   OLECHAR* GetResultPaneColInfo(int nCol);
   virtual HRESULT OnRename(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         );
   virtual HRESULT OnDelete(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         , BOOL fSilent
         );
   virtual HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );

   // Pointer to our client SDO.
   CComPtr<ISdo>  m_spSdo;

   // Smart pointer to interface for telling service to reload data.
   CComPtr<ISdoServiceControl>   m_spSdoServiceControl;

   // Collection of vendors.
   Vendors m_vendors;

private:

   // These strings contains a cache of some info from the SDO
   // which will show up in the different columns for this node.
   // The m_bstrDisplayName string also contains such cached info
   // but it is declared in the base class.
   CComBSTR m_bstrAddress;
   CComBSTR m_bstrProtocol;

   // Ordinal of the NAS vendor in the Vendors collection.
   size_t m_nasTypeOrdinal;
};

_declspec( selectany ) CLIPFORMAT CClientNode::m_CCF_CUT_AND_PASTE_FORMAT = 0;

#endif // _IAS_CLIENT_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\clientpage1.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

   ClientPage1.h

Abstract:

   Header file for the CClientPage1 class.

   This is our handler class for the CClientNode property page.

   See ClientPage.cpp for implementation.

Author:

    Michael A. Maguire 11/19/97

Revision History:
   mmaguire 11/19/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_CLIENT_PAGE_1_H_)
#define _IAS_CLIENT_PAGE_1_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//
#include "Vendors.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CClientNode;

class CClientPage1 : public CIASPropertyPage<CClientPage1>
{

public :
   
   CClientPage1( LONG_PTR hNotificationHandle, CClientNode *pClientNode,  TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );

   ~CClientPage1();


   // This is the ID of the dialog resource we want for this class.
   // An enum is used here because the correct value of
   // IDD must be initialized before the base class's constructor is called
   enum { IDD = IDD_PROPPAGE_CLIENT1 };

   BEGIN_MSG_MAP(CClientPage1)
      COMMAND_CODE_HANDLER(BN_CLICKED, OnChange)      
      COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
      COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
#ifndef MAKE_FIND_FOCUS
      COMMAND_ID_HANDLER( IDC_EDIT_CLIENT_PAGE1__ADDRESS, OnAddressEdit )
#endif
      COMMAND_ID_HANDLER( IDC_BUTTON_CLIENT_PAGE1_FIND, OnResolveClientAddress )
      CHAIN_MSG_MAP(CIASPropertyPage<CClientPage1>)
   END_MSG_MAP()

   BOOL OnApply();

   BOOL OnQueryCancel();


   HRESULT GetHelpPath( LPTSTR szFilePath );


   // Call this from another thread when you want this page to be able to
   // access these pointers when in its own thread.
   HRESULT InitSdoPointers(     ISdo * pSdoClient
                        , ISdoServiceControl * pSdoServiceControl
                        , const Vendors& vendors
                        );


protected:

   
   // Pointer to stream into which this page's Sdo interface
   // pointer will be marshalled.
   LPSTREAM m_pStreamSdoMarshal;

   // Pointer to stream into which this page's ISdoServiceControl interface
   // pointer will be marshalled.
   LPSTREAM m_pStreamSdoServiceControlMarshal;

   // Interface pointer for this page's client's sdo.
   CComPtr<ISdo>  m_spSdoClient;

   // Smart pointer to interface for telling service to reload data.
   CComPtr<ISdoServiceControl>   m_spSdoServiceControl;

   // Vendors collection.
   Vendors m_vendors;

   HRESULT UnMarshalInterfaces( void );


   // When we are passed a pointer to the client node in our constructor,
   // we will save away a pointer to its parent, as this is the node
   // which will need to receive an update message once we have
   // applied any changes.
   CSnapInItem * m_pParentOfNodeBeingModified;
   CSnapInItem * m_pNodeBeingModified;

private:

   LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      );

   LRESULT OnChange(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
      );

   LRESULT OnResolveClientAddress(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
      );


#ifndef MAKE_FIND_FOCUS
   LRESULT OnAddressEdit(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
      );
#endif

protected:
   
   // Dirty bits -- for keeping track of data which has been touched
   // so that we only save data we have to.
   BOOL m_fDirtyClientName;
   BOOL m_fDirtyAddress;
   BOOL m_fDirtyManufacturer;
   BOOL m_fDirtySendSignature;
   BOOL m_fDirtySharedSecret;
};

#endif // _IAS_CLIENT_PAGE_1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\clientnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    ClientNode.cpp

Abstract:

   Implementation file for the CClient class.


Author:

    Michael A. Maguire 11/19/97

Revision History:
   mmaguire 11/19/97 - created
   sbens    01/25/00 - Remove PROPERTY_CLIENT_FILTER_VSAS

--*/
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ClientNode.h"
#include "SnapinNode.cpp"  // Template class implementation
//
//
// where we can find declarations needed in this file:
//
#include "ComponentData.h"
#include "ClientPage1.h"
#include "AddClientWizardPage1.h"
#include "AddClientWizardPage2.h"
#include "ClientsNode.h"
#include "EnumFormatEtc.cpp" // Temporarily, so that this gets compiled, until we get
                        // build environment figured out so we can pull
                        // obj file from common directory.
#include "CutAndPasteDataObject.h"
#include "ServerNode.h"
#include "ChangeNotification.h"
#include "globals.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CClientClipboardData
{
public:
   TCHAR szName[IAS_MAX_STRING];
   TCHAR szAddress[IAS_MAX_STRING];
   LONG lManufacturerID;
   VARIANT_BOOL bAlwaysSendsSignature;
   TCHAR szPassword[IAS_MAX_STRING];
};


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::InitClipboardFormat

--*/
//////////////////////////////////////////////////////////////////////////////
void CClientNode::InitClipboardFormat()
{
   // Every node you want to use the CCutAndPasteDataObject template
   // class with should have a m_CCF_CUT_AND_PASTE_FORMAT static member variable.
   // However, make sure that the string you use (in this case "CCF_IAS_CLIENT_NODE"
   // is different for each node type you have.
   m_CCF_CUT_AND_PASTE_FORMAT = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_IAS_CLIENT_NODE"));
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::FillText

Parameters:
   pSTM            LPSTGMEDIUM in which to render.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::FillText(LPSTGMEDIUM pSTM)
{
   ATLTRACE(_T("# +++ CClientNode::RenderText\n"));

   HGLOBAL     hMem;

   CHAR szNarrowText[IAS_MAX_STRING];
   CHAR *psz;

   // It seems the CF_TEXT format is for ASCII only (non-UNICODE)
   int iResult = WideCharToMultiByte(
         CP_ACP,         // code page
         0,         // performance and mapping flags
         m_bstrDisplayName, // address of wide-character string
         -1,       // number of characters in string
         szNarrowText,  // address of buffer for new string
         IAS_MAX_STRING,      // size of buffer
         NULL,  // address of default for unmappable characters
         NULL   // address of flag set when default char. used
         );

   if( iResult == 0 )
   {
      // Some error attempting to convert.
      return E_FAIL;
   }

   hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, ( strlen(szNarrowText) + 1 )*sizeof(CHAR));

   if (NULL==hMem)
      return STG_E_MEDIUMFULL;

   psz=(LPSTR)GlobalLock(hMem);

   strcpy( psz, szNarrowText );

   GlobalUnlock(hMem);

   pSTM->hGlobal=hMem;
   pSTM->tymed=TYMED_HGLOBAL;
   pSTM->pUnkForRelease=NULL;
   return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::FillClipboardData

Parameters:
   pSTM            LPSTGMEDIUM in which to render.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::FillClipboardData(LPSTGMEDIUM pSTM)
{
   ATLTRACE(_T("# +++ CClientNode::FillClipboardData\n"));

   HGLOBAL     hMem;

   CClientClipboardData *pClientClipboardData;

   if( m_spSdo == NULL )
   {
      return E_FAIL; // ISSUE: Appropriate error?
   }

   hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(CClientClipboardData));

   if (NULL==hMem)
   {
        return STG_E_MEDIUMFULL;
   }

   pClientClipboardData = (CClientClipboardData *) GlobalLock(hMem);

   HRESULT hr;
   CComVariant spVariant;

   // Fill the data structure.
   wcscpy( pClientClipboardData->szName, m_bstrDisplayName );

   hr = m_spSdo->GetProperty( PROPERTY_CLIENT_REQUIRE_SIGNATURE, &spVariant );
   if( SUCCEEDED( hr ) )
   {
      _ASSERTE( spVariant.vt == VT_BOOL );
      pClientClipboardData->bAlwaysSendsSignature = spVariant.boolVal;
   }
   else
   {
      // Fail silently.
   }
   spVariant.Clear();

#ifdef      __NEED_GET_SHARED_SECRET_OUT__      // this should NOT be true
   hr = m_spSdo->GetProperty( PROPERTY_CLIENT_SHARED_SECRET, &spVariant );
   if( SUCCEEDED( hr ) )
   {
      _ASSERTE( spVariant.vt == VT_BSTR );
      wcscpy( pClientClipboardData->szPassword, spVariant.bstrVal );
   }
   else
   {
      // Fail silently.
   }
   spVariant.Clear();
#endif

   hr = m_spSdo->GetProperty( PROPERTY_CLIENT_NAS_MANUFACTURER, &spVariant );
   if( SUCCEEDED( hr ) )
   {
      _ASSERTE( spVariant.vt == VT_I4 );
      pClientClipboardData->lManufacturerID = spVariant.lVal;
   }
   else
   {
      // Fail silently.
   }
   spVariant.Clear();

   hr = m_spSdo->GetProperty( PROPERTY_CLIENT_ADDRESS, &spVariant );
   if( SUCCEEDED( hr ) )
   {
      _ASSERTE( spVariant.vt == VT_BSTR );
      wcscpy( pClientClipboardData->szAddress, spVariant.bstrVal );
   }
   else
   {
      // Fail silently.
   }
   spVariant.Clear();

   GlobalUnlock(hMem);

   pSTM->hGlobal=hMem;
   pSTM->tymed=TYMED_HGLOBAL;
   pSTM->pUnkForRelease=NULL;
   return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::IsClientClipboardData

Returns:
   S_OK if IDataObject supports CCF_IAS_CLIENT_NODE clipboard format.
   S_FALSE if it does not.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::IsClientClipboardData( IDataObject* pDataObject )
{
   ATLTRACE(_T("# +++ CClientNode::IsClientClipboardData\n"));

   // Check for preconditions:
   // None.

   if (pDataObject == NULL)
   {
      return E_POINTER;
   }

   // ISSUE: Instead of doing this, we should probably just use
   // IEnumFormatEtc to query the IDataObject to see if it supports
   // the CClientNode::m_CCF_IAS_CLIENT_NODE format.

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
   FORMATETC formatetc = {
                 m_CCF_CUT_AND_PASTE_FORMAT
               , NULL
               , DVASPECT_CONTENT
               , -1
               , TYMED_HGLOBAL
               };

   HRESULT hr = pDataObject->GetData(&formatetc, &stgmedium);
   if( SUCCEEDED( hr ) )
   {
      GlobalFree(stgmedium.hGlobal);
   }

   if( hr != S_OK )
   {
      // We want this method to give back only S_OK or S_FALSE.
      hr = S_FALSE;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::GetClientNameFromClipboard

Call this to get the name of a client from one passed in on the clipboard.

We had to add this method because ISdoCollection::Add was changed to require
a name for the client we want to add.

So we couldn't use the SetClientWithDataFromClipboard below because it requires
a valid SDO pointer to do its job -- a slight chicken and egg problem.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::GetClientNameFromClipboard( IDataObject* pDataObject, CComBSTR &bstrName )
{
   ATLTRACE(_T("# +++ CClientNode::GetClientNameFromClipboard\n"));

   // Check for preconditions:
   if (pDataObject == NULL)
   {
      return E_POINTER;
   }

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
   FORMATETC formatetc = {
                 m_CCF_CUT_AND_PASTE_FORMAT
               , NULL
               , DVASPECT_CONTENT
               , -1
               , TYMED_HGLOBAL
               };

   HRESULT hr = pDataObject->GetData(&formatetc, &stgmedium);
   if( SUCCEEDED( hr ) )
   {
      CComVariant spVariant;

      CClientClipboardData *pClientClipboardData = (CClientClipboardData *) GlobalLock(stgmedium.hGlobal);

      // Save Name data from clipboard to bstrName.

      // Should I release before I do this?
      bstrName = pClientClipboardData->szName;

      GlobalUnlock(stgmedium.hGlobal); // Needed if we are about to free?
      GlobalFree(stgmedium.hGlobal);
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::SetClientWithDataFromClipboard

Call this once you have created a new client and assigned it a new SDO client
object, to fill the SDO with data from an IDataObject retrieved from the clipboard.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::SetClientWithDataFromClipboard( IDataObject* pDataObject )
{
   ATLTRACE(_T("# +++ CClientNode::SetClientWithDataFromClipboard\n"));

   // Check for preconditions:
   _ASSERTE( m_spSdo != NULL );
   if (pDataObject == NULL)
   {
      return E_POINTER;
   }

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
   FORMATETC formatetc = {
                 m_CCF_CUT_AND_PASTE_FORMAT
               , NULL
               , DVASPECT_CONTENT
               , -1
               , TYMED_HGLOBAL
               };

   HRESULT hr = pDataObject->GetData(&formatetc, &stgmedium);
   if( SUCCEEDED( hr ) )
   {
      HRESULT hr;
      CComVariant spVariant;

      CClientClipboardData *pClientClipboardData = (CClientClipboardData *) GlobalLock(stgmedium.hGlobal);

      // Save data from clipboard to SDO

      spVariant.vt = VT_BOOL;
      // Note: be very careful here with VT_BOOL -- for variants, FALSE = 0, TRUE = -1.
      // Here we need not worry because bAlwaysSendsSignature was saved as VARIANT_BOOL.
      spVariant.boolVal = pClientClipboardData->bAlwaysSendsSignature;
      hr = m_spSdo->PutProperty( PROPERTY_CLIENT_REQUIRE_SIGNATURE, &spVariant );
      spVariant.Clear();
      if( FAILED( hr ) )
      {
         // Figure out error and give back appropriate messsage.

         // Fail silently.
      }

      spVariant.vt = VT_BSTR;
      spVariant.bstrVal = SysAllocString( pClientClipboardData->szPassword );
      hr = m_spSdo->PutProperty( PROPERTY_CLIENT_SHARED_SECRET, &spVariant );
      spVariant.Clear();
      if( FAILED( hr ) )
      {
         // Figure out error and give back appropriate messsage.

         // Fail silently.
      }

      spVariant.vt = VT_I4;
      spVariant.lVal = pClientClipboardData->lManufacturerID;
      hr = m_spSdo->PutProperty( PROPERTY_CLIENT_NAS_MANUFACTURER, &spVariant);
      spVariant.Clear();
      if( FAILED( hr ) )
      {
         // Figure out error and give back appropriate messsage.

         // Fail silently.
      }

      spVariant.vt = VT_BSTR;
      spVariant.bstrVal = SysAllocString( pClientClipboardData->szAddress );
      hr = m_spSdo->PutProperty( PROPERTY_CLIENT_ADDRESS, &spVariant );
      spVariant.Clear();
      if( FAILED( hr ) )
      {
         // Figure out error and give back appropriate messsage.

         // Fail silently.
      }

      // If we made it to here, try to apply the changes.
      // Since there is only one page for a client node, we don't
      // have to worry about synchronizing two or more pages
      // so that we only apply if they both are ready.
      // This is why we don't use m_pSynchronizer.
      hr = m_spSdo->Apply();
      if( FAILED( hr ) )
      {
         // Fail silently.
      }

      LoadCachedInfoFromSdo();
      GlobalUnlock(stgmedium.hGlobal); // Needed if we are about to free?
      GlobalFree(stgmedium.hGlobal);
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::CClientNode

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CClientNode::CClientNode(CSnapInItem * pParentNode, BOOL bAddNewClient)
   :CSnapinNode<CClientNode, CComponentData, CComponent>(pParentNode, CLIENT_HELP_INDEX)
{
   ATLTRACE(_T("# +++ CClientNode::CClientNode\n"));

   // Check for preconditions:
   // None.

   // Set whether this node is being added via the Add New Client command
   // and thus whether this node is "in limbo".
   m_bAddNewClient = bAddNewClient;

   // Set which bitmap image this node should use.
   m_resultDataItem.nImage =      IDBI_NODE_CLIENT;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::InitSdoPointers

Call as soon as you have constructed this class and pass in it's SDO pointer.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::InitSdoPointers(    ISdo *pSdo
                              , ISdoServiceControl *pSdoServiceControl
                              , const Vendors& vendors
                              )
{
   ATLTRACE(_T("# CClientNode::InitSdoPointers\n"));

   // Check for preconditions:
   _ASSERTE( pSdo != NULL );
   _ASSERTE( pSdoServiceControl != NULL );

   // Save our client sdo pointer.
   m_spSdo = pSdo;
   m_spSdoServiceControl = pSdoServiceControl;
   m_vendors = vendors;

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::LoadCachedInfoFromSdo

For quick screen updates, we cache some information like client name,
address, protocol and NAS type.  Call this to load this information
from the SDO's into the caches.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::LoadCachedInfoFromSdo( void )
{
   ATLTRACE(_T("# CClientNode::LoadCachedInfoFromSdo\n"));

   // Check for preconditions:
   if( m_spSdo == NULL )
   {
      return E_FAIL;
   }

   HRESULT hr;
   CComVariant spVariant;

   // Set the display name for this object.
   hr = m_spSdo->GetProperty( PROPERTY_SDO_NAME, & spVariant );
   if( spVariant.vt == VT_BSTR )
   {
      m_bstrDisplayName = spVariant.bstrVal;
   }
   else
   {
      m_bstrDisplayName = _T("@Not configured");
   }
   spVariant.Clear();

   // Set the address.
   hr = m_spSdo->GetProperty( PROPERTY_CLIENT_ADDRESS, & spVariant );
   if( spVariant.vt == VT_BSTR )
   {
      m_bstrAddress = spVariant.bstrVal;
   }
   else
   {
      m_bstrAddress = _T("@Not configured");
   }
   spVariant.Clear();

   // Set the protocol.
   TCHAR szProtocol[IAS_MAX_STRING];
   int iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_PROTOCOL_RADIUS, szProtocol, IAS_MAX_STRING );
   _ASSERT( iLoadStringResult > 0 );
   m_bstrProtocol = szProtocol;

   // Set the NAS Type.
   hr = m_spSdo->GetProperty( PROPERTY_CLIENT_NAS_MANUFACTURER, &spVariant );
   if( spVariant.vt == VT_I4 )
   {
      m_nasTypeOrdinal = m_vendors.VendorIdToOrdinal(V_I4(&spVariant));
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::GetDataObject

Because we want to be able to cut and paste Client objects, we will need to
implement a more featured DataObject implementation than we do for the other nodes.


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClientNode::GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
{
   ATLTRACE(_T("# CClientNode::GetDataObject\n"));

   // Check for preconditions:
   // None.

   CComObject< CCutAndPasteDataObject<CClientNode> > * pData;
   HRESULT hr = CComObject< CCutAndPasteDataObject<CClientNode> >::CreateInstance(&pData);
   if (FAILED(hr))
      return hr;

   pData->m_objectData.m_pItem = this;
   pData->m_objectData.m_type = type;

   hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::~CClientNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CClientNode::~CClientNode()
{
   ATLTRACE(_T("# --- CClientNode::~CClientNode\n"));
   // Check for preconditions:
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::CreatePropertyPages

See CSnapinNode::CreatePropertyPages (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CClientNode::CreatePropertyPages (
                 LPPROPERTYSHEETCALLBACK pPropertySheetCallback
               , LONG_PTR hNotificationHandle
               , IUnknown* pUnknown
               , DATA_OBJECT_TYPES type
               )
{
   ATLTRACE(_T("# CClientNode::CreatePropertyPages\n"));

   // Check for preconditions:
   _ASSERTE( pPropertySheetCallback != NULL );
   _ASSERTE( m_spSdo != NULL );

   HRESULT hr;

   if( m_bAddNewClient )
   {

      TCHAR lpszTab1Name[IAS_MAX_STRING];
      TCHAR lpszTab2Name[IAS_MAX_STRING];
      int nLoadStringResult;

      // Load property page tab name from resource.
      nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_ADD_CLIENT_WIZPAGE1__TAB_NAME, lpszTab1Name, IAS_MAX_STRING );
      _ASSERT( nLoadStringResult > 0 );

      // This page will take care of deleting itself when it
      // receives the PSPCB_RELEASE message.
      // We specify TRUE for the bOwnsNotificationHandle parameter so that this page's destructor will be
      // responsible for freeing the notification handle.  Only one page per sheet should do this.
      CAddClientWizardPage1 * pAddClientWizardPage1 = new CAddClientWizardPage1( hNotificationHandle, this, lpszTab1Name, TRUE );

      if( NULL == pAddClientWizardPage1 )
      {
         ATLTRACE(_T("# ***FAILED***: CClientNode::CreatePropertyPages -- Couldn't create property pages\n"));
         return E_OUTOFMEMORY;
      }

      // Load property page tab name from resource.
      nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_ADD_CLIENT_WIZPAGE2__TAB_NAME, lpszTab2Name, IAS_MAX_STRING );
      _ASSERT( nLoadStringResult > 0 );

      // This page will take care of deleting itself when it
      // receives the PSPCB_RELEASE message.
      CAddClientWizardPage2 * pAddClientWizardPage2 = new CAddClientWizardPage2( hNotificationHandle, this, lpszTab2Name );

      if( NULL == pAddClientWizardPage2 )
      {
         ATLTRACE(_T("# ***FAILED***: CClientNode::CreatePropertyPages -- Couldn't create property pages\n"));

         // Clean up the first page we created.
         delete pAddClientWizardPage1;

         return E_OUTOFMEMORY;
      }

      hr = pAddClientWizardPage1->InitSdoPointers( m_spSdo );
      if( FAILED( hr ) )
      {
         delete pAddClientWizardPage1;
         delete pAddClientWizardPage2;

         return E_FAIL;
      }

      hr = pAddClientWizardPage2->InitSdoPointers( m_spSdo, m_spSdoServiceControl, m_vendors );
      if( FAILED( hr ) )
      {
         delete pAddClientWizardPage1;
         delete pAddClientWizardPage2;

         return E_FAIL;
      }

      // Add the pages to the MMC property sheet.
      hr = pPropertySheetCallback->AddPage( pAddClientWizardPage1->Create() );
      _ASSERT( SUCCEEDED( hr ) );

      hr = pPropertySheetCallback->AddPage( pAddClientWizardPage2->Create() );
      _ASSERT( SUCCEEDED( hr ) );

      // Add a synchronization object which makes sure we only commit data
      // when all pages are OK with their data.
      CSynchronizer * pSynchronizer = new CSynchronizer();
      _ASSERTE( pSynchronizer != NULL );

      // Hand the sycnchronizer off to the pages.
      pAddClientWizardPage1->m_pSynchronizer = pSynchronizer;
      pSynchronizer->AddRef();

      pAddClientWizardPage2->m_pSynchronizer = pSynchronizer;
      pSynchronizer->AddRef();

      // We've now made the wizard pages that we should display for a client
      // freshly added using the Add New Client command.
      // At this point, regardless of whether the user finishes the wizard
      // or hits cancel, this node is no longer "in limbo".
      m_bAddNewClient = FALSE;
   }
   else
   {
      // Load name for client page 1 tab from resources
      TCHAR lpszTabName[IAS_MAX_STRING];
      int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_CLIENT_PAGE1__TAB_NAME, lpszTabName, IAS_MAX_STRING );
      _ASSERT( nLoadStringResult > 0 );

      // This page will take care of deleting itself when it
      // receives the PSPCB_RELEASE message.
      // We specify TRUE for the bOwnsNotificationHandle parameter so that this page's destructor will be
      // responsible for freeing the notification handle.  Only one page per sheet should do this.
      CClientPage1 * pClientPage1 = new CClientPage1( hNotificationHandle, this, lpszTabName, TRUE );
      if (NULL == pClientPage1)
      {
         ATLTRACE(_T("# ***FAILED***: CClientNode::CreatePropertyPages -- Couldn't create property pages\n"));
         return E_OUTOFMEMORY;
      }

      hr = pClientPage1->InitSdoPointers( m_spSdo, m_spSdoServiceControl, m_vendors );
      if( FAILED( hr ) )
      {
         delete pClientPage1;
         return E_FAIL;
      }

      hr = pPropertySheetCallback->AddPage( pClientPage1->Create() );
      _ASSERT( SUCCEEDED( hr ) );
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::QueryPagesFor

See CSnapinNode::QueryPagesFor (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CClientNode::QueryPagesFor ( DATA_OBJECT_TYPES type )
{
   ATLTRACE(_T("# CClientNode::QueryPagesFor\n"));

   // Check for preconditions:
   // S_OK means we have pages to display
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
OLECHAR* CClientNode::GetResultPaneColInfo(int nCol)
{
   ATLTRACE(_T("# CClientNode::GetResultPaneColInfo\n"));

   // Check for preconditions:
   // None.

   switch( nCol )
   {
   case 0:
      return m_bstrDisplayName;
      break;
   case 1:
      return m_bstrAddress;
      break;
   case 2:
      return m_bstrProtocol;
      break;
   case 3:
      return const_cast<OLECHAR*>(m_vendors.GetName(m_nasTypeOrdinal));
      break;
   default:
      // ISSUE: error -- should we assert here?
      return NULL;
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::OnRename

See CSnapinNode::OnRename (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::OnRename(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   ATLTRACE(_T("# CClientNode::OnRename\n"));

   // Check for preconditions:
   _ASSERTE( pComponentData != NULL || pComponent != NULL );

   CComPtr<IConsole> spConsole;
   HRESULT hr = S_FALSE;
   CComVariant spVariant;
   CComBSTR bstrError;

   // We need IConsole
   if( pComponentData != NULL )
   {
       spConsole = ((CComponentData*)pComponentData)->m_spConsole;
   }
   else
   {
       spConsole = ((CComponent*)pComponent)->m_spConsole;
   }
   _ASSERTE( spConsole != NULL );

   // This returns S_OK if a property sheet for this object already exists
   // and brings that property sheet to the foreground.
   // It returns S_FALSE if the property sheet wasn't found.
   hr = BringUpPropertySheetForNode(
              this
            , pComponentData
            , pComponent
            , spConsole
            );

   if( FAILED( hr ) )
   {
      return hr;
   }

   if( S_OK == hr )
   {
      // We found a property sheet already up for this node.
      ShowErrorDialog( NULL, IDS_ERROR__CLOSE_PROPERTY_SHEET, NULL, hr, 0, spConsole );
      return hr;
   }

   try
   {
      // We didn't find a property sheet already up for this node.
      _ASSERTE( S_FALSE == hr );

      ::CString str = (OLECHAR *) param;
      str.TrimLeft();
      str.TrimRight();
      if (str.IsEmpty())
      {
         ShowErrorDialog( NULL, IDS_ERROR__CLIENTNAME_EMPTY);
         hr = S_FALSE;
         return hr;
      }

      // Make a BSTR out of the new name.
      spVariant.vt = VT_BSTR;
      spVariant.bstrVal = SysAllocString( (OLECHAR *) param );
      _ASSERTE( spVariant.bstrVal != NULL );

      // Try to pass the new BSTR to the Sdo
      hr = m_spSdo->PutProperty( PROPERTY_SDO_NAME, &spVariant );
      if( FAILED( hr ) )
      {
         throw hr;
      }

      hr = m_spSdo->Apply();
      if( FAILED( hr ) )
      {
         throw hr;
      }

      m_bstrDisplayName = spVariant.bstrVal;

      // Tell the service to reload data.
      HRESULT hrTemp = m_spSdoServiceControl->ResetService();
      if( FAILED( hrTemp ) )
      {
         // Fail silently.
      }

      // Insure that MMC refreshes all views of this object
      // to reflect the renaming.

      CChangeNotification *pChangeNotification = new CChangeNotification();
      pChangeNotification->m_dwFlags = CHANGE_UPDATE_RESULT_NODE;
      pChangeNotification->m_pNode = this;
      hr = spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
      pChangeNotification->Release();
   }
   catch(...)
   {
      ShowErrorDialog( NULL, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, NULL, hr, 0, spConsole );
      hr = S_FALSE;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::OnDelete

See CSnapinNode::OnDelete (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::OnDelete(
        LPARAM arg
      , LPARAM param
      , IComponentData * pComponentData
      , IComponent * pComponent
      , DATA_OBJECT_TYPES type
      , BOOL fSilent
      )
{
   ATLTRACE(_T("# CClientNode::OnDelete\n"));

   // Check for preconditions:
   _ASSERTE( pComponentData != NULL || pComponent != NULL );
   _ASSERTE( m_pParentNode != NULL );

   HRESULT hr = S_FALSE;

   // First try to see if a property sheet for this node is already up.
   // If so, bring it to the foreground.

   // It seems to be acceptable to query IPropertySheetCallback for an IPropertySheetProvider.

   // But to get that, first we need IConsole
   CComPtr<IConsole> spConsole;
   if( pComponentData != NULL )
   {
       spConsole = ((CComponentData*)pComponentData)->m_spConsole;
   }
   else
   {
      // We should have a non-null pComponent
       spConsole = ((CComponent*)pComponent)->m_spConsole;
   }
   _ASSERTE( spConsole != NULL );

   // This returns S_OK if a property sheet for this object already exists
   // and brings that property sheet to the foreground.
   // It returns S_FALSE if the property sheet wasn't found.
   hr = BringUpPropertySheetForNode(
              this
            , pComponentData
            , pComponent
            , spConsole
            );

   if( FAILED( hr ) )
   {
      return hr;
   }

   if( S_OK == hr )
   {
      // We found a property sheet already up for this node.
      ShowErrorDialog( NULL, IDS_ERROR__CLOSE_PROPERTY_SHEET, NULL, hr, 0, spConsole  );
   }
   else
   {
      // We didn't find a property sheet already up for this node.
      _ASSERTE( S_FALSE == hr );

      if( FALSE == fSilent )
      {
         // Ask the user to confirm the client deletion.
         int iLoadStringResult;
         TCHAR szClientDeleteQuery[IAS_MAX_STRING*3];
         TCHAR szTemp[IAS_MAX_STRING];

         iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_CLIENT_NODE__DELETE_CLIENT__PROMPT1, szClientDeleteQuery, IAS_MAX_STRING );
         _ASSERT( iLoadStringResult > 0 );
         _tcscat( szClientDeleteQuery, m_bstrDisplayName );

         CServerNode *pServerNode = GetServerRoot();
         _ASSERTE( pServerNode != NULL );

         if( pServerNode->m_bConfigureLocal )
         {
            iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS__ON_LOCAL_MACHINE, szTemp, IAS_MAX_STRING );
            _ASSERT( iLoadStringResult > 0 );
            _tcscat( szClientDeleteQuery, szTemp);
         }
         else
         {
            iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS__ON_MACHINE, szTemp, IAS_MAX_STRING );
            _ASSERT( iLoadStringResult > 0 );
            _tcscat( szClientDeleteQuery, szTemp );

            _tcscat( szClientDeleteQuery, pServerNode->m_bstrServerAddress );
         }

         iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_CLIENT_NODE__DELETE_CLIENT__PROMPT3, szTemp, IAS_MAX_STRING );
         _ASSERT( iLoadStringResult > 0 );
         _tcscat( szClientDeleteQuery, szTemp );

         int iResult = ShowErrorDialog(
                          NULL
                        , 1
                        , szClientDeleteQuery
                        , S_OK
                        , IDS_CLIENT_NODE__DELETE_CLIENT__PROMPT_TITLE
                        , spConsole
                        , MB_YESNO | MB_ICONQUESTION
                        );

         if( IDYES != iResult )
         {
            // The user didn't confirm the delete operation.
            return S_FALSE;
         }
      }

      // Try to delete the underlying data.

      CClientsNode * pClientsNode = (CClientsNode *) m_pParentNode;

      // Remove this client from the Clients collection.
      // This will try to remove it from the Clients Sdo collection.
      hr = pClientsNode->RemoveChild( this );

      if( SUCCEEDED( hr ) )
      {
         // ISSUE: Need to call ISdoServer::Apply here as well?  Waiting for info from Todd on
         // SDO usage and apply semantics.

         delete this;
         return hr;
      }
      else
      {
         // Couldn't delete underlying data object for some reason.
         ShowErrorDialog( NULL, IDS_ERROR__DELETING_OBJECT, NULL, hr, 0, spConsole  );
      }
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
   ATLTRACE(_T("# CClientNode::SetVerbs\n"));

   // Check for preconditions:
   _ASSERTE( pConsoleVerb != NULL );

   HRESULT hr = S_OK;

   // We want the user to be able to choose Properties on this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

   // We want Properties to be the default
   hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );

   // We want the user to be able to delete this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );

   // We want the user to be able to rename this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );

#ifdef SUPPORT_COPY_AND_PASTE
   // We want the user to be able to paste this node

   // Paste doesn't work for leaf objects.
   // You need to enable paste for the container object,
   // that is, the node that has this node in its result-pane list.
   //hr = pConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );

   // We want the user to be able to copy/cut this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );

#endif // NO_PASTE

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData * CClientNode::GetComponentData( void )
{
   ATLTRACE(_T("# CClientNode::GetComponentData\n"));

   // Check for preconditions:
   _ASSERTE( m_pParentNode != NULL );

   return ((CClientsNode *) m_pParentNode)->GetComponentData();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::GetServerRoot

This method returns the Server node under which this node can be found.

It relies upon the fact that each node has a pointer to its parent,
all the way up to the server node.

This would be a useful function to use if, for example, you need a reference
to some data specific to a server.

--*/
//////////////////////////////////////////////////////////////////////////////
CServerNode * CClientNode::GetServerRoot( void )
{
   ATLTRACE(_T("# CClientNode::GetServerRoot\n"));

   // Check for preconditions:
   _ASSERTE( m_pParentNode != NULL );

   return ((CClientsNode *) m_pParentNode)->GetServerRoot();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientNode::OnPropertyChange

This is our own custom response to the MMCN_PROPERTY_CHANGE notification.

MMC never actually sends this notification to our snapin with a specific lpDataObject,
so it would never normally get routed to a particular node but we have arranged it
so that our property pages can pass the appropriate CSnapInItem pointer as the param
argument.  In our CComponent::Notify override, we map the notification message to
the appropriate node using the param argument.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientNode::OnPropertyChange(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   ATLTRACE(_T("# CClientNode::OnPropertyChange\n"));

   // Check for preconditions:
   // None.

   return LoadCachedInfoFromSdo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\clientsnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    ClientsNode.cpp

Abstract:

   Implementation file for the CClientsNode class.


Author:

    Michael A. Maguire 11/10/97

Revision History:
   mmaguire 11/10/97 - created

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ClientsNode.h"
#include "ComponentData.h" // this must be included before NodeWithResultChildrenList.cpp
#include "Component.h"     // this must be included before NodeWithResultChildrenList.cpp
#include "NodeWithResultChildrenList.cpp" // Implementation of template class.
//
//
// where we can find declarations needed in this file:
//
#include <time.h>
#include "ClientNode.h"
#include "AddClientDialog.h"
#include "ServerNode.h"
#include "globals.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

#define COLUMN_WIDTH__FRIENDLY_NAME    120
#define COLUMN_WIDTH__ADDRESS       140
#define COLUMN_WIDTH__PROTOCOL         100
#define COLUMN_WIDTH__NAS_TYPE         300

//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::UpdateMenuState

--*/
//////////////////////////////////////////////////////////////////////////////
void CClientsNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
   ATLTRACE(_T("# CClientsNode::UpdateMenuState\n"));

   // Check for preconditions:
   // None.

   // Set the state of the appropriate context menu items.
   if( id == ID_MENUITEM_CLIENTS_TOP__NEW_CLIENT || 
       id == ID_MENUITEM_CLIENTS_NEW__CLIENT )
   {
      if( m_spSdoCollection == NULL )
      {
         *flags = MFS_GRAYED;
      }
      else
      {
         *flags = MFS_ENABLED;
      }
   }
   return;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::CClientsNode

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CClientsNode::CClientsNode(CSnapInItem * pParentNode)
   :CNodeWithResultChildrenList<CClientsNode, CClientNode, CSimpleArray<CClientNode*>, CComponentData, CComponent>(pParentNode, CLIENT_HELP_INDEX)
{
   ATLTRACE(_T("# +++ CClientsNode::CClientsNode\n"));

   // Check for preconditions:
   // None.

   // Is this the appropriate place to add extra info to m_scopeDataItem and m_resultDataItem
   // which the default template doesn't add?  Think so.

   // Set the display name for this object
   TCHAR lpszName[IAS_MAX_STRING];
   int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_CLIENTS_NODE__NAME, lpszName, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   m_bstrDisplayName = lpszName;

   // In IComponentData::Initialize, we are asked to inform MMC of
   // the icons we would like to use for the scope pane.
   // Here we store an index to which of these images we
   // want to be used to display this node
   m_scopeDataItem.nImage =      IDBI_NODE_CLIENTS_CLOSED;
   m_scopeDataItem.nOpenImage =  IDBI_NODE_CLIENTS_OPEN;
   m_pAddClientDialog = NULL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::InitSdoPointers

Call as soon as you have constructed this class and pass in it's SDO pointer.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::InitSdoPointers( ISdo *pSdoServer )
{
   ATLTRACE(_T("# CClientsNode::InitSdoPointerso\n"));

   // Check for preconditions:
   _ASSERTE( pSdoServer );

   HRESULT hr = S_OK;
   hr = pSdoServer->QueryInterface( IID_ISdoServiceControl, (void **) &m_spSdoServiceControl );
   if( FAILED( hr ) )
   {
      ShowErrorDialog( NULL, IDS_ERROR__CANT_READ_DATA_FROM_SDO, NULL, hr, 0, GetComponentData()->m_spConsole );

      return 0;
   }

   // Get the SDO clients collection.
   CComPtr<ISdo> spSdoRadiusProtocol;

   hr = ::SDOGetSdoFromCollection(       pSdoServer
                              , PROPERTY_IAS_PROTOCOLS_COLLECTION
                              , PROPERTY_COMPONENT_ID
                              , IAS_PROTOCOL_MICROSOFT_RADIUS
                              , &spSdoRadiusProtocol
                              );

   if( spSdoRadiusProtocol == NULL )
   {
      ShowErrorDialog( NULL, IDS_ERROR__CANT_READ_DATA_FROM_SDO, NULL, hr, 0, GetComponentData()->m_spConsole );

      return 0;
   }

   CComVariant spVariant;

   hr = spSdoRadiusProtocol->GetProperty( PROPERTY_RADIUS_CLIENTS_COLLECTION, & spVariant );
   _ASSERTE( SUCCEEDED( hr ) );
   _ASSERTE( spVariant.vt == VT_DISPATCH );

   // Query the dispatch pointer we were given for an ISdoInterface.
   CComQIPtr<ISdoCollection, &IID_ISdoCollection> spSdoCollection( spVariant.pdispVal );
   _ASSERTE( spSdoCollection != NULL );
   spVariant.Clear();

   // Release the old pointer if we had one.
   if( m_spSdoCollection != NULL )
   {
      m_spSdoCollection.Release();
   }

   // Save our client sdo pointer.
   m_spSdoCollection = spSdoCollection;

   hr = spSdoRadiusProtocol->GetProperty( PROPERTY_RADIUS_VENDORS_COLLECTION, & spVariant );
   _ASSERTE( SUCCEEDED( hr ) );
   _ASSERTE( spVariant.vt == VT_DISPATCH );

   // Query the dispatch pointer we were given for an ISdoInterface.
   CComQIPtr<ISdoCollection, &IID_ISdoCollection> spSdoVendors( spVariant.pdispVal );
   _ASSERTE( spSdoCollection != NULL );

   m_bResultChildrenListPopulated = FALSE;

   return m_vendors.Reload(spSdoVendors);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::ResetSdoPointers

Call as soon as you have constructed this class and pass in it's SDO pointer.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::ResetSdoPointers( ISdo *pSdoServer )
{
   ATLTRACE(_T("# CClientsNode::InitSdoPointerso\n"));

   // Check for preconditions:
   _ASSERTE( pSdoServer );

   HRESULT hr = S_OK;

   // Get the SDO clients collection.
   CComPtr<ISdo> spSdoRadiusProtocol;

   hr = ::SDOGetSdoFromCollection(       pSdoServer
                              , PROPERTY_IAS_PROTOCOLS_COLLECTION
                              , PROPERTY_COMPONENT_ID
                              , IAS_PROTOCOL_MICROSOFT_RADIUS
                              , &spSdoRadiusProtocol
                              );

   if( spSdoRadiusProtocol == NULL )
   {
      ShowErrorDialog( NULL, IDS_ERROR__CANT_READ_DATA_FROM_SDO, NULL, hr, 0, GetComponentData()->m_spConsole );

      return 0;
   }
   CComVariant spVariant;

   hr = spSdoRadiusProtocol->GetProperty( PROPERTY_RADIUS_CLIENTS_COLLECTION, & spVariant );
   _ASSERTE( SUCCEEDED( hr ) );
   _ASSERTE( spVariant.vt == VT_DISPATCH );

   // Query the dispatch pointer we were given for an ISdoInterface.
   CComQIPtr<ISdoCollection, &IID_ISdoCollection> spSdoCollection( spVariant.pdispVal );
   _ASSERTE( spSdoCollection != NULL );
   spVariant.Clear();

   // Release the old pointer if we had one.
   if( m_spSdoCollection != NULL )
   {
      m_spSdoCollection.Release();
   }

   // Save our client sdo pointer.
   m_spSdoCollection = spSdoCollection;

   hr = spSdoRadiusProtocol->GetProperty( PROPERTY_RADIUS_VENDORS_COLLECTION, & spVariant );
   _ASSERTE( SUCCEEDED( hr ) );
   _ASSERTE( spVariant.vt == VT_DISPATCH );

   // Query the dispatch pointer we were given for an ISdoInterface.
   CComQIPtr<ISdoCollection, &IID_ISdoCollection> spSdoVendors( spVariant.pdispVal );
   _ASSERTE( spSdoCollection != NULL );

   return m_vendors.Reload(spSdoVendors);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::~CClientsNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CClientsNode::~CClientsNode()
{
   ATLTRACE(_T("# --- CClientsNode::~CClientsNode\n"));
   // Check for preconditions:
   // None.
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::DoRefresh


--*/
//////////////////////////////////////////////////////////////////////////////


HRESULT  CClientsNode::DataRefresh(ISdo* pNewSdo)
{
   HRESULT   hr = S_OK;
   // since these are result panes ...
   //set new sdo pointer
   hr = ResetSdoPointers(pNewSdo);

   if FAILED(hr)
      return hr;

   // population new sub nodes
   hr = PopulateResultChildrenList();

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::OnRefresh

See CSnapinNode::OnRefresh (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::OnRefresh(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   HRESULT   hr = S_OK;

   CWaitCursor WC;

   CComPtr<IConsole> spConsole;

   // We need IConsole
   if( pComponentData != NULL )
   {
       spConsole = ((CComponentData*)pComponentData)->m_spConsole;
   }
   else
   {
       spConsole = ((CComponent*)pComponent)->m_spConsole;
   }
   _ASSERTE( spConsole != NULL );

   // if there is any property page open
   int c = m_ResultChildrenList.GetSize();

   while ( c-- > 0)
   {
      CClientNode* pSub = m_ResultChildrenList[c];
      // Call our base class's method to remove the child from its list.
      // The RemoveChild method takes care of removing this node from the
      // UI's list of nodes under the parent and performing a refresh of all relevant views.
      // This returns S_OK if a property sheet for this object already exists
      // and brings that property sheet to the foreground.
      // It returns S_FALSE if the property sheet wasn't found.
      hr = BringUpPropertySheetForNode(
              pSub
            , pComponentData
            , pComponent
            , spConsole
            );

      if( S_OK == hr )
      {
         // We found a property sheet already up for this node.
         ShowErrorDialog( NULL, IDS_ERROR__CLOSE_PROPERTY_SHEET, NULL, hr, 0, spConsole );
         return hr;
      }
   }

   // if no property page is open, delete all the result node
   RemoveChildrenNoRefresh();

   // reload SDO from
   CServerNode* pSN = GetServerRoot();

   if(pSN)
   {
      hr =  pSN->DataRefresh();
   }

   // refresh the node
   hr = CNodeWithResultChildrenList<CClientsNode, CClientNode, CSimpleArray<CClientNode*>, CComponentData, CComponent >::OnRefresh( 
           arg, param, pComponentData, pComponent, type);
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::OnQueryPaste

See CSnapinNode::OnQueryPaste (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::OnQueryPaste(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   ATLTRACE(_T("# CClientsNode::OnQueryPaste\n"));

   // Check for preconditions:
   if( arg == NULL )
   {
      return E_POINTER;
   }

   CComPtr<IDataObject> spDataObject;
   spDataObject = (IDataObject *) arg;
   
   return CClientNode::IsClientClipboardData( spDataObject );
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::OnPaste

See CSnapinNode::OnPaste (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::OnPaste(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   ATLTRACE(_T("# CClientNode::OnPaste\n"));

   // Check for preconditions:
   _ASSERTE( arg != NULL );

   HRESULT hr;
   CComPtr<IDataObject> spDataObject;
   spDataObject = (IDataObject *) arg;
   CComPtr<ISdo> spClientSdo;
   CClientNode * pClientNode;
   CComPtr<IDispatch> spClientDispatch;

   // We try to create a new client UI object, a new client SDO object,
   // and then let the client object populate its own data
   // based on the data in the SDO.

   // Check to make sure we have a valid SDO pointer.
   if( m_spSdoCollection == NULL )
   {
      // No SDO pointer.
      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, S_OK, 0, GetComponentData()->m_spConsole  );
      return E_POINTER;
   }

   // Create the client UI object.
   pClientNode = new CClientNode( this );

   if( NULL == pClientNode )
   {
      // We failed to create the client node.
      ShowErrorDialog( NULL, IDS_ERROR__OUT_OF_MEMORY, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      return E_OUTOFMEMORY;
   }

   // We need to make sure that the result child list as been populated
   // initially from the SDO's, before we add anything new to it,
   // otherwise we may get an item showing up in our list twice.
   // See note for CNodeWithResultChildrenList::AddSingleChildToListAndCauseViewUpdate.
   if ( FALSE == m_bResultChildrenListPopulated )
   {
      // We have not yet loaded all of our children into our list.
      // This call will add items to the list from whatever data source.
      hr = PopulateResultChildrenList();
      if( FAILED(hr) )
      {
         return( hr );
      }
      // We've already loaded our children ClientNode objects with
      // data necessary to populate the result pane.
      m_bResultChildrenListPopulated = TRUE;
   }

   // Get the name of the client from the clipboard.  We need this
   // to call ISdoCollection::Add
   CComBSTR bstrName;
   pClientNode->GetClientNameFromClipboard( spDataObject, bstrName );

   // Load the format string that says "Copy of %s" just in case we need it.
   TCHAR szCopyOf[IAS_MAX_STRING];
   int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_COPY_OF, szCopyOf, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   int iLengthOfCopyOfText = wcslen( szCopyOf );

   // Load the current name of the client into the temp string.
   pClientNode->m_bstrDisplayName =  bstrName;

   // Try to add the client with the current name.
   hr =  m_spSdoCollection->Add( pClientNode->m_bstrDisplayName, (IDispatch **) &spClientDispatch );

   // We will get E_INVALIDARG when the name already exists.
   // If we failed with E_INVALIDARG. we keep looping around,
   // adding the string "Copy of " to the name until the client
   // can be successfully added or the string gets too long.
   while ( hr == E_INVALIDARG && ( pClientNode->m_bstrDisplayName.Length() + iLengthOfCopyOfText < IAS_MAX_STRING ) )
   {
      TCHAR szTempName[IAS_MAX_STRING];
      wsprintf( szTempName, szCopyOf, pClientNode->m_bstrDisplayName);
      pClientNode->m_bstrDisplayName.Empty();
      pClientNode->m_bstrDisplayName = szTempName;
      hr =  m_spSdoCollection->Add( pClientNode->m_bstrDisplayName, (IDispatch **) &spClientDispatch );
   }     


   if( FAILED( hr ) )
   {
      // For now, just give back an error saying that we couldn't add it.
      // We could not create the object.
      ShowErrorDialog( NULL, IDS_ERROR__ADDING_OBJECT_TO_COLLECTION, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      // Clean up.
      delete pClientNode;
      return( hr );
   }

   // Query the returned IDispatch interface for an ISdo interface.
   _ASSERTE( spClientDispatch != NULL );
   hr = spClientDispatch->QueryInterface( IID_ISdo, (void **) &spClientSdo );

   if( FAILED(hr) || ! spClientSdo )
   {
      // For some reason, we couldn't get the client sdo.
      ShowErrorDialog( NULL, IDS_ERROR__ADDING_OBJECT_TO_COLLECTION, NULL, S_OK, 0, GetComponentData()->m_spConsole );

      // Clean up after ourselves.
      HRESULT hrLocal = m_spSdoCollection->Remove( spClientDispatch );
      _ASSERTE( SUCCEEDED( hrLocal ) );
      delete pClientNode;
      return( hr );
   }

   // Give the client node its sdo pointer.
   hr = pClientNode->InitSdoPointers( spClientSdo, m_spSdoServiceControl, m_vendors );
   _ASSERTE( SUCCEEDED( hr ) );

   // Tell the client to fill its SDO with what the IDataObject contains.
   hr = pClientNode->SetClientWithDataFromClipboard( spDataObject );
   if( SUCCEEDED( hr ) )
   {
      AddSingleChildToListAndCauseViewUpdate( pClientNode );

      if( param != NULL )
      {
         // We are being asked to do a cut operation.

         // ISSUE: this will have to be updated once the MMC
         // team figures out what it wants to do with cut and paste.

         // Let's try putting the source node (arg) into param.
         // What we put in the param parameter here seems to be passed
         // in as the param parameter with the MMCN_CUTORPASTE
         // notification.
         IDataObject **ppSourceDataObject = (IDataObject **) param;
         *ppSourceDataObject = (IDataObject *) arg;
      }
      else
      {
         // We are being asked to do a move operation.
         // Do nothing
      }
   }  
   else
   {
      // We couldn't get all the data we needed out of the IDataObject.
      // Clean up.
      delete pClientNode;

      // This is a local HRESULT -- we want the function we're in to return the bad one.
      HRESULT hrLocal = m_spSdoCollection->Remove( spClientDispatch );
      _ASSERTE( SUCCEEDED( hrLocal ) );
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::OnPropertyChange

This is our own custom response to the MMCN_PROPERTY_CHANGE notification.

MMC never actually sends this notification to our snapin with a specific lpDataObject,
so it would never normally get routed to a particular node but we have arranged it
so that our property pages can pass the appropriate CSnapInItem pointer as the param
argument.  In our CComponent::Notify override, we map the notification message to
the appropriate node using the param argument.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::OnPropertyChange(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   ATLTRACE(_T("# CClientsNode::OnPropertyChange\n"));

   // Check for preconditions:
   // None.

   return LoadCachedInfoFromSdo();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
OLECHAR* CClientsNode::GetResultPaneColInfo(int nCol)
{
   ATLTRACE(_T("# CClientsNode::GetResultPaneColInfo\n"));

   // Check for preconditions:
   // None.

   if (nCol == 0 && m_bstrDisplayName != NULL)
   {
      return m_bstrDisplayName;
   }
   
   return NULL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
   ATLTRACE(_T("# CClientsNode::SetVerbs\n"));

   // Check for preconditions:
   _ASSERTE( pConsoleVerb != NULL );

   HRESULT hr = S_OK;

   // CClientsNode has a refresh method.
   if( m_spSdoCollection != NULL )
   {
      hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
   }

#ifndef NO_PASTE
   if( m_spSdoCollection != NULL )
   {
      hr = pConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );
   }
#endif // NO_PASTE

   // We don't want the user deleting or renaming this node, so we
   // don't set the MMC_VERB_PROPERTIES, MMC_VERB_RENAME or MMC_VERB_DELETE verbs.
   // By default, when a node becomes selected, these are disabled.

   // We want double-clicking on a collection node to show its children.
   // hr = pConsoleVerb->SetVerbState( MMC_VERB_OPEN, ENABLED, TRUE );
   // hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::LoadCachedInfoFromSdo

Causes this node and its children to re-read all their cached info from
the SDO's.  Call if you change something and you want to make sure that
the display reflects this change.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::LoadCachedInfoFromSdo( void )
{
   ATLTRACE(_T("# CClientsNode::LoadCachedInfoFromSdo\n"));

   // Check for preconditions:

   HRESULT hr;

#ifndef ADD_CLIENT_WIZARD
   // Check to make sure that the AddClientDialog also updates any info it is showing.
   if( NULL != m_pAddClientDialog )
   {
      // If the AddClient dialog is up, we don't want to RepopulateResultChildrenList
      // as this will show the tentatively-added client that AddClient is editing.
      m_pAddClientDialog->LoadCachedInfoFromSdo();
   }
#endif // ADD_CLIENT_WIZARD

   // So just refresh each of its children.
   CClientNode* pChildNode;

   int iSize = m_ResultChildrenList.GetSize();

   for (int i = 0; i < iSize; i++)
   {
      pChildNode = m_ResultChildrenList[i];
      _ASSERTE( pChildNode != NULL );
      hr = pChildNode->LoadCachedInfoFromSdo();
      // Ignore failed HRESULT.
   }
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::InsertColumns

See CNodeWithResultChildrenList::InsertColumns (which this method overrides)
for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
   ATLTRACE(_T("# CClientsNode::InsertColumns\n"));

   // Check for preconditions:
   _ASSERTE( pHeaderCtrl != NULL );

   HRESULT hr;
   int nLoadStringResult;
   TCHAR szFriendlyName[IAS_MAX_STRING];
   TCHAR szAddress[IAS_MAX_STRING];
   TCHAR szProtocol[IAS_MAX_STRING];
   TCHAR szNASType[IAS_MAX_STRING];

   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_CLIENTS_NODE__FRIENDLY_NAME, szFriendlyName, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_CLIENTS_NODE__ADDRESS, szAddress, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_CLIENTS_NODE__PROTOCOL, szProtocol, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_CLIENTS_NODE__NAS_TYPE, szNASType, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   hr = pHeaderCtrl->InsertColumn( 0, szFriendlyName, LVCFMT_LEFT, COLUMN_WIDTH__FRIENDLY_NAME );
   _ASSERT( S_OK == hr );

   hr = pHeaderCtrl->InsertColumn( 1, szAddress, LVCFMT_LEFT, COLUMN_WIDTH__ADDRESS );
   _ASSERT( S_OK == hr );

   hr = pHeaderCtrl->InsertColumn( 2, szProtocol, LVCFMT_LEFT, COLUMN_WIDTH__PROTOCOL );
   _ASSERT( S_OK == hr );

   hr = pHeaderCtrl->InsertColumn( 3, szNASType, LVCFMT_LEFT, COLUMN_WIDTH__NAS_TYPE );
   _ASSERT( S_OK == hr );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::PopulateResultChildrenList

See CNodeWithResultChildrenList::PopulateResultChildrenList (which this method overrides)
for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::PopulateResultChildrenList( void )
{
   ATLTRACE(_T("# CClientsNode::PopulateResultChildrenList\n"));

   // Check for preconditions:
   // None.

   HRESULT              hr = S_OK;
   CComPtr<IUnknown>    spUnknown;
   CComPtr<IEnumVARIANT>   spEnumVariant;
   CComVariant          spVariant;
   long              ulCount;
   ULONG             ulCountReceived;

   HCURSOR  hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

   if( m_spSdoCollection == NULL )
   {
      return S_FALSE;   // Is there a better error to return here?
   }

   // We check the count of items in our collection and don't bother getting the
   // enumerator if the count is zero.
   // This saves time and also helps us to a void a bug in the the enumerator which
   // causes it to fail if we call next when it is empty.
   m_spSdoCollection->get_Count( & ulCount );

   if( ulCount > 0 )
   {
      // Get the enumerator for the Clients collection.
      hr = m_spSdoCollection->get__NewEnum( (IUnknown **) & spUnknown );
      if( FAILED( hr ) || spUnknown == NULL )
      {
         return S_FALSE;
      }

      hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
      spUnknown.Release();
      if( FAILED( hr ) || spEnumVariant == NULL )
      {
         return S_FALSE;
      }

      // Get the first item.
      hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );

      while( SUCCEEDED( hr ) && ulCountReceived == 1 )
      {
         // Create a new node UI object to represent the sdo object.
         CClientNode *pClientNode = new CClientNode( this );
         if( NULL == pClientNode )
         {
            return E_OUTOFMEMORY;
         }

         // Get an sdo pointer from the variant we received.
         _ASSERTE( spVariant.vt == VT_DISPATCH );
         _ASSERTE( spVariant.pdispVal != NULL );

         CComPtr<ISdo> spSdo;
         hr = spVariant.pdispVal->QueryInterface( IID_ISdo, (void **) &spSdo );
         _ASSERTE( SUCCEEDED( hr ) );

         // Pass the newly created node its SDO pointer.
         hr = pClientNode->InitSdoPointers( spSdo, m_spSdoServiceControl, m_vendors );
         _ASSERTE( SUCCEEDED( hr ) );
         spSdo.Release();

         hr = pClientNode->LoadCachedInfoFromSdo();

         // Add the newly created node to the list of clients.
         AddChildToList(pClientNode);

         // Clear the variant of whatever it had --
         // this will release any data associated with it.
         spVariant.Clear();

         // Get the next item.
         hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );
      }
   }
   else
   {
      // There are no items in the enumeration
      // Do nothing.
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::OnAddNewClient

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::OnAddNewClient( bool &bHandled, CSnapInObjectRootBase* pSnapInObjectRoot )
{
   ATLTRACE(_T("# CClientsNode::OnAddNewClient\n"));

   // Check for preconditions:
   _ASSERT( pSnapInObjectRoot != NULL );

   HRESULT hr = S_OK;

   if( m_spSdoCollection == NULL )
   {
      return hr;
   }

   // We need to make sure that the result child list as been populated
   // initially from the SDO's, before we add anything new to it,
   // otherwise we may get an item showing up in our list twice.
   // See note for CNodeWithResultChildrenList::AddSingleChildToListAndCauseViewUpdate.
   if ( FALSE == m_bResultChildrenListPopulated )
   {
      // We have not yet loaded all of our children into our list.
      // This call will add items to the list from whatever data source.
      hr = PopulateResultChildrenList();
      if( FAILED(hr) )
      {
         return( hr );
      }

      // We've already loaded our children ClientNode objects with
      // data necessary to populate the result pane.
      m_bResultChildrenListPopulated = TRUE;

   }

#ifndef ADD_CLIENT_WIZARD

   if( NULL == m_pAddClientDialog )
   {
      // Make the AddClientDialog.
      m_pAddClientDialog = new CAddClientDialog();
      if( NULL == m_pAddClientDialog )
      {
         return E_OUTOFMEMORY;
      }
   }

   m_pAddClientDialog->m_pClientsNode = this;

   // Attempt to recover either an IComponentData or a IComponent pointer from
   // the passed in CSnapInObjectRoot pointer.

   // This is a safe cast to make because we know that pObj is pointing
   // to either our CComponentData or our CComponent object,
   // both of which inherit from CSnapInObjectRoot.
   CComponentData *pCComponentData = NULL;
   CComponent *pCComponent = NULL;

   pCComponentData = dynamic_cast< CComponentData *>( pSnapInObjectRoot );
   if( NULL == pCComponentData )
   {
      // It must be a CComponent pointer.
      pCComponent = dynamic_cast< CComponent *>( pSnapInObjectRoot );
      _ASSERTE( pCComponent != NULL );
   }

   // Save IComponentData and IComponent pointers to the dialog -- it will need them.
   // One of them should be NULL and the other non-null.
   if( m_pAddClientDialog->m_spComponentData != NULL )
   {
      m_pAddClientDialog->m_spComponentData.Release();
   }
   m_pAddClientDialog->m_spComponentData = ( IComponentData *) pCComponentData;

   if( m_pAddClientDialog->m_spComponent != NULL )
   {
      m_pAddClientDialog->m_spComponent.Release();
   }
   m_pAddClientDialog->m_spComponent = ( IComponent *) pCComponent;

   // Attempt to get our local copy of IConsole from either our CComponentData or CComponent.
   CComPtr<IConsole> spConsole;
   if( pCComponentData != NULL )
   {
      spConsole = pCComponentData->m_spConsole;
   }
   else
   {
      // If we don't have pComponentData, we better have pComponent
      _ASSERTE( pCComponent != NULL );
      spConsole = pCComponent->m_spConsole;
   }

   if( m_pAddClientDialog->m_spConsole != NULL )
   {
      m_pAddClientDialog->m_spConsole.Release();
   }
   m_pAddClientDialog->m_spConsole = spConsole;

   if( m_pAddClientDialog->m_spClientsSdoCollection != NULL )
   {
      m_pAddClientDialog->m_spClientsSdoCollection.Release();
   }
   m_pAddClientDialog->m_spClientsSdoCollection = m_spSdoCollection;

   m_pAddClientDialog->DoModal();
   delete m_pAddClientDialog;
   m_pAddClientDialog = NULL;

#else // WIZARD_ADD_CLIENT

   // Attempt to recover either an IComponentData or a IComponent pointer from
   // the passed in CSnapInObjectRoot pointer.

   // This is a safe cast to make because we know that pObj is pointing
   // to either our CComponentData or our CComponent object,
   // both of which inherit from CSnapInObjectRoot.
   CComponentData *pCComponentData = NULL;
   CComponent *pCComponent = NULL;

   pCComponentData = dynamic_cast< CComponentData *>( pSnapInObjectRoot );
   if( NULL == pCComponentData )
   {
      // It must be a CComponent pointer.
      pCComponent = dynamic_cast< CComponent *>( pSnapInObjectRoot );
      _ASSERTE( pCComponent != NULL );
   }

   // Attempt to get our local copy of IConsole from either our CComponentData or CComponent.
   CComPtr<IConsole> spConsole;
   if( pCComponentData != NULL )
   {
      spConsole = pCComponentData->m_spConsole;
   }
   else
   {
      // If we don't have pComponentData, we better have pComponent
      _ASSERTE( pCComponent != NULL );
      spConsole = pCComponent->m_spConsole;
   }

   // Check to make sure we have a valid SDO pointer.
   if( ! m_spSdoCollection )
   {
      // No SDO pointer.
      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, S_OK, 0, spConsole  );
      return E_POINTER;
   }

   // Create the client UI object.
   CClientNode * pClientNode = new CClientNode( this, TRUE );

   if( ! pClientNode )
   {
      // We failed to create the client node.
      ShowErrorDialog( NULL, IDS_ERROR__OUT_OF_MEMORY, NULL, S_OK, 0, spConsole  );

      return E_OUTOFMEMORY;
   }

   CComPtr<IDispatch> spDispatch;
   // Find a special temporary name for the new client.
   // The user should never see this.
   TCHAR tzTempName[IAS_MAX_STRING];
   do
   {
      //
      // create a temporary name. we used the seconds elapsed as the temp name
      // so the chance of getting identical names is very small
      //
      time_t ltime;
      time(&ltime);
      wsprintf(tzTempName, _T("TempName%ld"), ltime);
      pClientNode->m_bstrDisplayName.Empty();
      pClientNode->m_bstrDisplayName =  tzTempName; // temporary client name
      hr =  m_spSdoCollection->Add( pClientNode->m_bstrDisplayName, (IDispatch **) &spDispatch );

      //
      // we keep looping around until the client can be successfully added.
      // We will get E_INVALIDARG when the name already exists
      //
   } while ( hr == E_INVALIDARG );

   if( FAILED( hr ) )
   {
      // For now, just give back an error saying that we couldn't add it.
      // We could not create the object.
      ShowErrorDialog( NULL, IDS_ERROR__ADDING_OBJECT_TO_COLLECTION, NULL, S_OK, 0, spConsole  );
      // Clean up.
      delete pClientNode;
      return( hr );
   }

   // Query the returned IDispatch interface for an ISdo interface.
   _ASSERTE( spDispatch != NULL );
   CComQIPtr<ISdo, &IID_ISdo> spClientSdo(spDispatch);
   spDispatch.Release();

   if( spClientSdo == NULL )
   {
      // For some reason, we couldn't get the client sdo.
      ShowErrorDialog( NULL, IDS_ERROR__ADDING_OBJECT_TO_COLLECTION, NULL, S_OK, 0, spConsole  );

      // Clean up after ourselves.
      delete pClientNode;
      pClientNode = NULL;
      return( hr );
   }

   // Give the client node its sdo pointer
   pClientNode->InitSdoPointers( spClientSdo, m_spSdoServiceControl, m_vendors );

   // Bring up the property pages on the node so the user can configure it.
   // This returns S_OK if a property sheet for this object already exists
   // and brings that property sheet to the foreground, otherwise
   // it creates a new sheet
   hr = BringUpPropertySheetForNode(
                 pClientNode
               , (IComponentData *) pCComponentData
               , (IComponent *) pCComponent
               , spConsole
               , TRUE   // Bring up page if not already up
               , pClientNode->m_bstrDisplayName
               , FALSE  // FALSE = modal wizard page
//             , MMC_PSO_NEWWIZARDTYPE // Use wizard97 style wizard
               );

   if( S_OK == hr )
   {
      // We finished the wizard.
   }
   else
   {
      // There was some error, or the user hit cancel -- we should remove the client
      // from the SDO's.
      CComPtr<IDispatch> spDispatch;
      hr = pClientNode->m_spSdo->QueryInterface( IID_IDispatch, (void **) & spDispatch );
      _ASSERTE( SUCCEEDED( hr ) );

      // Remove this client from the Clients collection.
      hr = m_spSdoCollection->Remove( spDispatch );

      // Delete the node object.
      delete pClientNode;
   }
#endif // WIZARD_ADD_CLIENT

   bHandled = TRUE;
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData * CClientsNode::GetComponentData( void )
{
   ATLTRACE(_T("# CClientsNode::GetComponentData\n"));

   // Check for preconditions:
   _ASSERTE( m_pParentNode != NULL );

   return ((CServerNode *) m_pParentNode)->GetComponentData();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::RemoveChild

We override our base class's RemoveChild method to insert code that
removes the child from the Sdo's as well.  We then call our base
class's RemoveChild method to remove the UI object from the list
of UI children.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientsNode::RemoveChild( CClientNode * pChildNode )
{
   ATLTRACE(_T("# CClientsNode::RemoveChild\n"));

   // Check for preconditions:
   _ASSERTE( m_spSdoCollection != NULL );
   _ASSERTE( pChildNode != NULL );
   _ASSERTE( pChildNode->m_spSdo != NULL );

   HRESULT hr = S_OK;

   // Try to remove the object from the Sdo's
   // Get the IDispatch interface of this client's Sdo.
   CComPtr<IDispatch> spDispatch;
   hr = pChildNode->m_spSdo->QueryInterface( IID_IDispatch, (void **) & spDispatch );
   _ASSERTE( SUCCEEDED( hr ) );

   // Remove this client from the Clients collection.
   hr = m_spSdoCollection->Remove( spDispatch );

   if( FAILED( hr ) )
   {
      return hr;
   }

   // Tell the service to reload data.
   HRESULT hrTemp = m_spSdoServiceControl->ResetService();
   if( FAILED( hrTemp ) )
   {
      // Fail silently.
   }

   // Call our base class's method to remove the child from its list.
   // The RemoveChild method takes care of removing this node from the
   // UI's list of nodes under the parent and performing a refresh of all relevant views.
   CNodeWithResultChildrenList<CClientsNode, CClientNode, CSimpleArray<CClientNode*>, CComponentData, CComponent >::RemoveChild( pChildNode );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::FillData

The server node need to override CSnapInItem's implementation of this so that we can
also support a clipformat for exchanging machine names with any snapins extending us.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClientsNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
   ATLTRACE(_T("# CClientsNode::FillData\n"));
   // Check for preconditions:
   // None.
   HRESULT hr = DV_E_CLIPFORMAT;
   ULONG uWritten = 0;

   if (cf == CF_MMC_NodeID)
   {
      ::CString   SZNodeID = (LPCTSTR)GetSZNodeType();
      SZNodeID += GetServerRoot()->m_bstrServerAddress;

      DWORD dwIdSize = 0;

      SNodeID2* NodeId = NULL;
      BYTE *id = NULL;
      DWORD textSize = (SZNodeID.GetLength()+ 1) * sizeof(TCHAR);
       
      dwIdSize = textSize + sizeof(SNodeID2);

      try{
         NodeId = (SNodeID2 *)_alloca(dwIdSize);
       }
      catch(...)
      {
         hr = E_OUTOFMEMORY;
         return hr;
      }

      NodeId->dwFlags = 0;
      NodeId->cBytes = textSize;
      memcpy(NodeId->id,(BYTE*)(LPCTSTR)SZNodeID, textSize);

      hr = pStream->Write(NodeId, dwIdSize, &uWritten);
      return hr;
   }

   // Call the method which we're overriding to let it handle the
   // rest of the possible cases as usual.
   return CNodeWithResultChildrenList<CClientsNode, CClientNode, CSimpleArray<CClientNode*>, CComponentData, CComponent >::FillData( cf, pStream );
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientsNode::GetServerRoot

This method returns the Server node under which this node can be found.

It relies upon the fact that each node has a pointer to its parent,
all the way up to the server node.

This would be a useful function to use if, for example, you need a reference
to some data specific to a server.

--*/
//////////////////////////////////////////////////////////////////////////////
CServerNode * CClientsNode::GetServerRoot( void )
{
   ATLTRACE(_T("# CClientsNode::GetServerRoot\n"));


   // Check for preconditions:
   _ASSERTE( m_pParentNode != NULL );

   return (CServerNode *) m_pParentNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\clientpage1.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    ClientPage1.cpp

Abstract:

   Implementation file for the ClientsPage class.

   We implement the class needed to handle the property page for the Client node.

Author:

    Michael A. Maguire 11/11/97

Revision History:
   mmaguire 11/11/97 - created
   sbens    01/25/00 - Remove PROPERTY_CLIENT_FILTER_VSAS


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ClientPage1.h"
//
//
// where we can find declarations needed in this file:
//
#include "ClientNode.h"
#include "ResolveDNSName.h"
#include "ChangeNotification.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// TrimCComBSTR
//
//////////////////////////////////////////////////////////////////////////////
void TrimCComBSTR(CComBSTR& bstr)
{
   // Characters to be trimmed.
   static const WCHAR delim[] = L" \t\n";

   if (bstr.m_str)
   {
      PCWSTR begin, end, first, last;

      // Find the beginning and end of the whole string.
      begin = bstr;
      end   = begin + wcslen(begin);

      // Find the first and last character of the trimmed string.
      first = begin + wcsspn(begin, delim);
      for (last = end; last > first && wcschr(delim, *(last - 1)); --last) { }

      // If they're not the same ...
      if (first != begin || last != end)
      {
         // ... then we have to allocate a new string ...
         BSTR newBstr = SysAllocStringLen(first, last - first);
         if (newBstr) 
         {
            // ... and replace the original.
            SysFreeString(bstr.m_str);
            bstr.m_str = newBstr;
         }
      }
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::CClientPage1

--*/
//////////////////////////////////////////////////////////////////////////////
CClientPage1::CClientPage1( LONG_PTR hNotificationHandle, CClientNode *pClientNode,  TCHAR* pTitle, BOOL bOwnsNotificationHandle )
                  : CIASPropertyPage<CClientPage1> ( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
   ATLTRACE(_T("# +++ CClientPage1::CClientPage1\n"));

   // Check for preconditions:
   _ASSERTE( pClientNode != NULL );

   // Add the help button to the page
// m_psp.dwFlags |= PSP_HASHELP;

   // We immediately save off a parent to the client node.
   // We don't want to keep and use a pointer to the client object
   // because the client node pointers may change out from under us
   // if the user does something like call refresh.  We will
   // use only the SDO, and notify the parent of the client object
   // we are modifying that it (and its children) may need to refresh
   // themselves with new data from the SDO's.
   m_pParentOfNodeBeingModified = pClientNode->m_pParentNode;
   m_pNodeBeingModified = pClientNode;

   // Initialize the pointer to the stream into which the Sdo pointer will be marshalled.
   m_pStreamSdoMarshal = NULL;
   m_pStreamSdoServiceControlMarshal = NULL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::~CClientPage1

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CClientPage1::~CClientPage1()
{
   ATLTRACE(_T("# --- CClientPage1::CClientPage1\n"));

   // Release this stream pointer if this hasn't already been done.
   if( m_pStreamSdoMarshal != NULL )
   {
      m_pStreamSdoMarshal->Release();
   };


   if( m_pStreamSdoServiceControlMarshal != NULL )
   {
      m_pStreamSdoServiceControlMarshal->Release();
   };
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CClientPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   ATLTRACE(_T("# CClientPage1::OnInitDialog\n"));

   // Check for preconditions:
   _ASSERTE( m_pStreamSdoMarshal != NULL );
   _ASSERTE( m_pStreamSdoServiceControlMarshal != NULL );


   HRESULT  hr;
   CComBSTR bstrTemp;
   BOOL     bTemp;
   LONG     lTemp;

   hr = UnMarshalInterfaces();
   if( FAILED( hr) )
   {
      ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr );
      return 0;
   }

   // Initialize the data on the property page.

   hr = GetSdoBSTR( m_spSdoClient, PROPERTY_SDO_NAME, &bstrTemp, IDS_ERROR__CLIENT_READING_NAME, m_hWnd, NULL );
   if( SUCCEEDED( hr ) )
   {
      SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__NAME, bstrTemp );

      // Initialize the dirty bits;
      // We do this after we've set all the data above otherwise we get false
      // notifications that data has changed when we set the edit box text.
      m_fDirtyClientName         = FALSE;
   }
   else
   {
      if( OLE_E_BLANK == hr )
      {
         // This means that this property has not yet been initialized
         // with a valid value and the user must enter something.
         SetDlgItemText(IDC_EDIT_SERVER_PAGE1__NAME, _T("") );
         m_fDirtyClientName         = TRUE;
         SetModified( TRUE );
      }

   }
   bstrTemp.Empty();

   hr = GetSdoBOOL( m_spSdoClient, PROPERTY_CLIENT_REQUIRE_SIGNATURE, &bTemp, IDS_ERROR__CLIENT_READING_REQUIRE_SIGNATURE, m_hWnd, NULL );
   if( SUCCEEDED( hr ) )
   {
      SendDlgItemMessage(IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE, BM_SETCHECK, bTemp, 0);
      m_fDirtySendSignature      = FALSE;
   }
   else
   {
      if( OLE_E_BLANK == hr )
      {
         SendDlgItemMessage(IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE, BM_SETCHECK, FALSE, 0);
         m_fDirtySendSignature      = TRUE;
         SetModified( TRUE );
      }
   }

#ifdef      __NEED_GET_SHARED_SECRET_OUT__      // this should NOT be true
   // ISSUE: Do we even want the UI to retrieve and display this information?
   hr = GetSdoBSTR( m_spSdoClient, PROPERTY_CLIENT_SHARED_SECRET, &bstrTemp, IDS_ERROR__CLIENT_READING_SHARED_SECRET, m_hWnd, NULL );
   if( SUCCEEDED( hr ) )
   {
      SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET, bstrTemp );
      SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM, bstrTemp );
      m_fDirtySharedSecret = FALSE;
   }
   else
   {
      if( OLE_E_BLANK == hr )
      {
         SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET, _T("") );
         SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM, _T("") );
         m_fDirtySharedSecret = TRUE;
         SetModified( TRUE );
      }
   }
   bstrTemp.Empty();
#else
   SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET, FAKE_PASSWORD_FOR_DLG_CTRL );
   SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM, FAKE_PASSWORD_FOR_DLG_CTRL );
   m_fDirtySharedSecret = FALSE;

#endif

   // Populate the list box of NAS vendors.

   // Initialize the combo box.
   LRESULT lresResult = SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_RESETCONTENT, 0, 0);

   hr = GetSdoI4( m_spSdoClient, PROPERTY_CLIENT_NAS_MANUFACTURER, &lTemp, IDS_ERROR__CLIENT_READING_MANUFACTURER, m_hWnd, NULL );
   if( SUCCEEDED( hr ) )
   {
      m_fDirtyManufacturer    = FALSE;
   }
   else
   {
      if( OLE_E_BLANK == hr )
      {
         m_fDirtyManufacturer    = TRUE;
         SetModified( TRUE );
      }
   }

   for (size_t iVendorCount = 0; iVendorCount < m_vendors.Size(); ++iVendorCount )
   {

      // Add the address string to the combo box.

      lresResult = SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_ADDSTRING, 0, (LPARAM)m_vendors.GetName(iVendorCount));
      if(lresResult != CB_ERR)
      {
         SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_SETITEMDATA, lresResult, (LPARAM)m_vendors.GetVendorId(iVendorCount));

         // if selected
         if( lTemp == (LONG)m_vendors.GetVendorId(iVendorCount))
            SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_SETCURSEL, lresResult, 0 );
      }

   }


   // coient bit
   hr = GetSdoBSTR( m_spSdoClient, PROPERTY_CLIENT_ADDRESS, &bstrTemp, IDS_ERROR__CLIENT_READING_ADDRESS, m_hWnd, NULL );
   if( SUCCEEDED( hr ) )
   {
      SetDlgItemText( IDC_EDIT_CLIENT_PAGE1__ADDRESS, bstrTemp );
      m_fDirtyAddress            = FALSE;
   }
   else
   {
      if( OLE_E_BLANK == hr )
      {
         SetDlgItemText( IDC_EDIT_CLIENT_PAGE1__ADDRESS, _T("") );
         m_fDirtyAddress            = TRUE;
         SetModified( TRUE );
      }
   }
   bstrTemp.Empty();

   return TRUE;   // ISSUE: what do we need to be returning here?
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::OnChange

Called when the WM_COMMAND message is sent to our page with any of the
BN_CLICKED, EN_CHANGE or CBN_SELCHANGE notifications.

  This is our chance to check to see what the user has touched, set the
dirty bits for these items so that only they will be saved,
and enable the Apply button.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CClientPage1::OnChange(
                       UINT uMsg
                     , WPARAM wParam
                     , HWND hwnd
                     , BOOL& bHandled
                     )
{
   ATLTRACE(_T("# CClientPage1::OnChange\n"));

   // Check for preconditions:
   // None.

   // We don't want to prevent anyone else down the chain from receiving a message.
   bHandled = FALSE;

   // Figure out which item has changed and set the dirty bit for that item.
   int iItemID = (int) LOWORD(wParam);

   switch( iItemID )
   {
   case IDC_EDIT_CLIENT_PAGE1__NAME:
      m_fDirtyClientName = TRUE;
      break;
   case IDC_EDIT_CLIENT_PAGE1__ADDRESS:
      m_fDirtyAddress = TRUE;
      break;
   case IDC_COMBO_CLIENT_PAGE1__MANUFACTURER:
      m_fDirtyManufacturer = TRUE;
      break;
   case IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE:
      m_fDirtySendSignature = TRUE;
      break;
   case IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET:
   case IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM:
      m_fDirtySharedSecret = TRUE;
      break;
   default:
      return TRUE;
      break;
   }

   // We should only get here if the item that changed was
   // one of the ones we were checking for.
   // This enables the Apply button.
   SetModified( TRUE );

   return TRUE;   // ISSUE: what do we need to be returning here?
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::OnResolveClientAddress

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CClientPage1::OnResolveClientAddress(UINT uMsg, WPARAM wParam, HWND hwnd, BOOL& bHandled)
{
   ATLTRACE(_T("# CClientPage1::OnResolveClientAddress\n"));

   // Check for preconditions:

   CComBSTR bstrClientAddress;

   CResolveDNSNameDialog * pResolveDNSNameDialog = new CResolveDNSNameDialog();

   // Get the current value in the address field.
   GetDlgItemText(IDC_EDIT_CLIENT_PAGE1__ADDRESS, (BSTR &) bstrClientAddress);

   // We pass a pointer to our address BSTR, so that the dialog
   // can use the current value, and replace it with the resolved one
   // if the user so chooses.
   pResolveDNSNameDialog->SetAddress( (BSTR *) &bstrClientAddress );

   // Put up the dialog.
   int iResult = pResolveDNSNameDialog->DoModal( m_hWnd );

   if( iResult )
   {
      // The user chose OK -- change the address to reflect what the user resolved.
      SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__ADDRESS, (LPCTSTR) bstrClientAddress );
   }
   else
   {
      // The user chose cancel -- do nothing.
   }

   delete pResolveDNSNameDialog;

   return TRUE;
}


#ifndef MAKE_FIND_FOCUS
//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::OnAddressEdit

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CClientPage1::OnAddressEdit(UINT uMsg, WPARAM wParam, HWND hwnd, BOOL& bHandled)
{
   ATLTRACE(_T("# CClientPage1::OnAddressEdit\n"));

   // Check for preconditions:

   // If the Address edit control lost the focus, trim the address
   if (uMsg == EN_KILLFOCUS)
   {
      CComBSTR bstrClientAddress;
      GetDlgItemText(IDC_EDIT_CLIENT_PAGE1__ADDRESS,
                     reinterpret_cast<BSTR &>(bstrClientAddress));
      TrimCComBSTR(bstrClientAddress);
      SetDlgItemText(IDC_EDIT_CLIENT_PAGE1__ADDRESS, 
                     static_cast<LPCTSTR>(bstrClientAddress));
      m_fDirtyAddress = TRUE;
   }

   // Don't know quite how to do this yet.
   // I need to de-activate the main sheet's OK button as the default.
   // Do I want to do this?

   // Make the Find button the default.
   LONG lStyle = ::GetWindowLong( ::GetDlgItem( GetParent(), IDOK),GWL_STYLE );
   lStyle = lStyle & ~BS_DEFPUSHBUTTON;
   SendDlgItemMessage(IDOK,BM_SETSTYLE,LOWORD(lStyle),MAKELPARAM(1,0));

   lStyle = ::GetWindowLong( GetDlgItem(IDC_BUTTON_CLIENT_PAGE1__FIND), GWL_STYLE);
   lStyle = lStyle | BS_DEFPUSHBUTTON;
   SendDlgItemMessage(IDC_BUTTON_CLIENT_PAGE1__FIND,BM_SETSTYLE,LOWORD(lStyle),MAKELPARAM(1,0));

   return TRUE;
}
#endif // MAKE_FIND_FOCUS


/////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::GetHelpPath

Remarks:

   This method is called to get the help file path within
   an compressed HTML document when the user presses on the Help
   button of a property sheet.

   It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientPage1::GetHelpPath( LPTSTR szHelpPath )
{
   ATLTRACE(_T("# CClientPage1::GetHelpPath\n"));
   // Check for preconditions:

#ifdef UNICODE_HHCTRL
   // ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
   // installed on this machine -- it appears to be non-unicode.
   lstrcpy( szHelpPath, _T("idh_proppage_client1.htm") );
#else
   strcpy( (CHAR *) szHelpPath, "idh_proppage_client1.htm" );
#endif

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::OnApply

Return values:

   TRUE if the page can be destroyed,
   FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

   OnApply gets called for each page in on a property sheet if that
   page has been visited, regardless of whether any values were changed.

   If you never switch to a tab, then its OnApply method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CClientPage1::OnApply()
{
   ATLTRACE(_T("# CClientPage1::OnApply\n"));

   // Check for preconditions:

   if( m_spSdoClient == NULL )
   {
      ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO );
      return FALSE;
   }

   HRESULT     hr;
   BOOL        bResult;
   CComBSTR    bstrTemp;
   BOOL        bTemp;
   LONG        lTemp;

   // Save data from property page to the Sdo.

   if( m_fDirtyClientName )
   {
      bResult = GetDlgItemText( IDC_EDIT_CLIENT_PAGE1__NAME, (BSTR &) bstrTemp );
      if( ! bResult )
      {
         // We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
         bstrTemp = SysAllocString( _T("") );
      }

      {  // name can not be empty
         ::CString   str = bstrTemp;
         str.TrimLeft();
         str.TrimRight();
         if(str.IsEmpty())
         {
            ShowErrorDialog( m_hWnd, IDS_ERROR__CLIENTNAME_EMPTY );

            return FALSE;
         }
      }

      hr = PutSdoBSTR( m_spSdoClient, PROPERTY_SDO_NAME, &bstrTemp, IDS_ERROR__CLIENT_WRITING_NAME, m_hWnd, NULL );
      if( SUCCEEDED( hr ) )
      {
         // Turn off the dirty bit.
         m_fDirtyClientName = FALSE;
      }
      else
      {
         return FALSE;
      }
      bstrTemp.Empty();
   }

   if( m_fDirtySendSignature )
   {
      bTemp = SendDlgItemMessage(IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE, BM_GETCHECK, 0, 0);
      hr = PutSdoBOOL( m_spSdoClient, PROPERTY_CLIENT_REQUIRE_SIGNATURE, bTemp, IDS_ERROR__CLIENT_WRITING_REQUIRE_SIGNATURE, m_hWnd, NULL );
      if( SUCCEEDED( hr ) )
      {
         // Turn off the dirty bit.
         m_fDirtySendSignature = FALSE;
      }
      else
      {
         return FALSE;
      }
   }

   if( m_fDirtySharedSecret )
   {

      CComBSTR bstrSharedSecret;
      bResult = GetDlgItemText( IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET, (BSTR &) bstrSharedSecret );
      if( ! bResult )
      {
         // We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
         bstrSharedSecret = _T("");
      }

      CComBSTR bstrConfirmSharedSecret;
      bResult = GetDlgItemText( IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM, (BSTR &) bstrConfirmSharedSecret );
      if( ! bResult )
      {
         // We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
         bstrConfirmSharedSecret = _T("");
      }

      if( lstrcmp( bstrSharedSecret, bstrConfirmSharedSecret ) )
      {
         ShowErrorDialog( m_hWnd, IDS_ERROR__SHARED_SECRETS_DONT_MATCH );
         return FALSE;
      }

      hr = PutSdoBSTR( m_spSdoClient, PROPERTY_CLIENT_SHARED_SECRET, &bstrSharedSecret, IDS_ERROR__CLIENT_WRITING_SHARED_SECRET, m_hWnd, NULL );
      if( SUCCEEDED( hr ) )
      {
         // Turn off the dirty bit.
         m_fDirtySharedSecret = FALSE;
      }
      else
      {
         return FALSE;
      }
      bstrTemp.Empty();
   }

   if( m_fDirtyManufacturer )
   {

      LRESULT lresIndex =  SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_GETCURSEL, 0, 0);

      if( lresIndex != CB_ERR )
      {
         lTemp =  SendDlgItemMessage( IDC_COMBO_CLIENT_PAGE1__MANUFACTURER, CB_GETITEMDATA, lresIndex, 0);
      }
      else
      {
         // Set the value to be "Others"
         lTemp = 0;
      }

      hr = PutSdoI4( m_spSdoClient, PROPERTY_CLIENT_NAS_MANUFACTURER, lTemp, IDS_ERROR__CLIENT_WRITING_MANUFACTURER, m_hWnd, NULL );
      if( SUCCEEDED( hr ) )
      {
         // Turn off the dirty bit.
         m_fDirtyManufacturer = FALSE;

      }
      else
      {
         return FALSE;
      }
   }

   if( m_fDirtyAddress )
   {
      bResult = GetDlgItemText( IDC_EDIT_CLIENT_PAGE1__ADDRESS, (BSTR &) bstrTemp );
      if( ! bResult )
      {
         // We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
         bstrTemp = SysAllocString( _T("") );
      }
      else
      {
         // Trim that address
         // Do not refresh the screen there because that would cause OK 
         // to not close the property page
         TrimCComBSTR(bstrTemp);
      }

      hr = PutSdoBSTR( m_spSdoClient, PROPERTY_CLIENT_ADDRESS, &bstrTemp, IDS_ERROR__CLIENT_WRITING_ADDRESS, m_hWnd, NULL );
      if( SUCCEEDED( hr ) )
      {
         // Turn off the dirty bit.
         m_fDirtyAddress = FALSE;
      }
      else
      {
         return FALSE;
      }
      bstrTemp.Empty();
   }

   // If we made it to here, try to apply the changes.
   // Since there is only one page for a client node, we don't
   // have to worry about synchronizing two or more pages
   // so that we only apply if they both are ready.
   // This is why we don't use m_pSynchronizer.
   hr = m_spSdoClient->Apply();
   if( FAILED( hr ) )
   {
      if(hr == DB_E_NOTABLE)  // assume, the RPC connection has problem
         ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
      else
      {
//    m_spSdoClient->LastError( &bstrError );
//    ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, bstrError );
         ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO );
      }
      return FALSE;
   }
   else
   {
      // We succeeded.

      // Tell the service to reload data.
      HRESULT hrTemp = m_spSdoServiceControl->ResetService();
      if( FAILED( hrTemp ) )
      {
         // Fail silently.
      }

      // The data was accepted, so notify the main context of our snapin
      // that it may need to update its views.
      CChangeNotification * pChangeNotification = new CChangeNotification();
      pChangeNotification->m_dwFlags = CHANGE_UPDATE_RESULT_NODE;
      pChangeNotification->m_pNode = m_pNodeBeingModified;
      pChangeNotification->m_pParentNode = m_pParentOfNodeBeingModified;

      HRESULT hr = PropertyChangeNotify( (LONG_PTR) pChangeNotification );
      _ASSERTE( SUCCEEDED( hr ) );
   }

   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::OnQueryCancel

Return values:

   TRUE if the page can be destroyed,
   FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

   OnQueryCancel gets called for each page in on a property sheet if that
   page has been visited, regardless of whether any values were changed.

   If you never switch to a tab, then its OnQueryCancel method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CClientPage1::OnQueryCancel()
{
   ATLTRACE(_T("# CClientPage1::OnQueryCancel\n"));

   HRESULT hr;

   if( m_spSdoClient != NULL )
   {
      // If the user wants to cancel, we should make sure that we rollback
      // any changes the user may have started.

      // If the user had not already tried to commit something,
      // a cancel on an SDO will hopefully be designed to be benign.

      hr = m_spSdoClient->Restore();
      // Don't care about the HRESULT.

   }

   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::InitSdoPointers

Return values:

   HRESULT returned from CoMarshalInterThreadInterfaceInStream.

Remarks:

   Call this from another thread when you want this page to be able to
   access these pointers when in its own thread.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientPage1::InitSdoPointers(   ISdo * pSdoClient
                        , ISdoServiceControl * pSdoServiceControl
                        , const Vendors& vendors
                        )
{
   ATLTRACE(_T("# CClientPage1::InitSdoPointers\n"));

   HRESULT hr = S_OK;

   // Marshall the ISdo pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdo                 //Reference to the identifier of the interface
               , pSdoClient                  //Pointer to the interface to be marshaled
               , & m_pStreamSdoMarshal //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );

   if( FAILED( hr ) )
   {
      return hr;
   }

   // Marshall the ISdoServiceControl pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdoServiceControl                  //Reference to the identifier of the interface
               , pSdoServiceControl                //Pointer to the interface to be marshaled
               , &m_pStreamSdoServiceControlMarshal  //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );
   if( FAILED( hr ) )
   {
      return hr;
   }

   m_vendors = vendors;

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CClientPage1::UnMarshalInterfaces

Return values:

   HRESULT returned from CoMarshalInterThreadInterfaceInStream.

Remarks:

   Call this one in the property pages thread to unmarshal the interface
   pointers marshalled in MarshalInterfaces.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CClientPage1::UnMarshalInterfaces( void )
{
   HRESULT hr = S_OK;

   // Unmarshall an ISdo interface pointer.
   hr =  CoGetInterfaceAndReleaseStream(
                    m_pStreamSdoMarshal        //Pointer to the stream from which the object is to be marshaled
                  , IID_ISdo           //Reference to the identifier of the interface
                  , (LPVOID *) &m_spSdoClient    //Address of output variable that receives the interface pointer requested in riid
                  );

   // CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
   // We set it to NULL so that our destructor doesn't try to release this again.
   m_pStreamSdoMarshal = NULL;

   if( FAILED( hr) || m_spSdoClient == NULL )
   {
      return E_FAIL;
   }

   hr =  CoGetInterfaceAndReleaseStream(
                    m_pStreamSdoServiceControlMarshal      //Pointer to the stream from which the object is to be marshaled
                  , IID_ISdoServiceControl            //Reference to the identifier of the interface
                  , (LPVOID *) &m_spSdoServiceControl    //Address of output variable that receives the interface pointer requested in riid
                  );
   m_pStreamSdoServiceControlMarshal = NULL;

   if( FAILED( hr) || m_spSdoServiceControl == NULL )
   {
      return E_FAIL;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\component.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    Component.h

Abstract:

	The CComponent class implements several interfaces which MMC uses:
	
	The IComponent interface is basically how MMC talks to the snap-in
	to get it to implement a right-hand-side "scope" pane.  There can be several
	objects implementing this interface instantiated at once.  These are best
	thought of as "views" on the single object implementing the IComponentData
	"document" (see ComponentData.cpp).

	The IExtendPropertySheet interface is how the snap-in adds property sheets
	for any of the items a user might click on.

	The IExtendContextMenu interface what we do to add custom entries
	to the menu which appears when a user right-clicks on a node.
	
	The IExtendControlBar interface allows us to support a custom
	iconic toolbar.

	See Component.cpp for implementation details.

Note:

	Much of the functionality of this class is implemented in atlsnap.h
	by IComponentImpl.  We are mostly overriding here.


Author:

    Michael A. Maguire 11/6/97

Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_COMPONENT_H_)
#define _IAS_COMPONENT_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
// Moved to Precompiled.h: #include <atlsnap.h>
//
//
// where we can find what this class has or uses:
//
#include "resource.h"
#include "IASMMC.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CComponentData;

class CComponent :
	  public CComObjectRootEx<CComSingleThreadModel>
	, public CSnapInObjectRoot<2, CComponentData>
	, public IComponentImpl<CComponent>
#ifndef NOWIZARD97
	, public IExtendPropertySheet2Impl<CComponent>
#else // NOWIZARD97
	, public IExtendPropertySheetImpl<CComponent>
#endif //NOWIZARD97
	, public IExtendContextMenuImpl<CComponent>
	, public IExtendControlbarImpl<CComponent>
	, public IExtendTaskPadImpl<CComponent>
{

public:

	BEGIN_COM_MAP(CComponent)
		COM_INTERFACE_ENTRY(IComponent)
#ifndef NOWIZARD97
		COM_INTERFACE_ENTRY(IExtendPropertySheet2)
#else // NOWIZARD97
		COM_INTERFACE_ENTRY(IExtendPropertySheet)
#endif // NOWIZARD97
		COM_INTERFACE_ENTRY(IExtendContextMenu)
		COM_INTERFACE_ENTRY(IExtendControlbar)
		COM_INTERFACE_ENTRY(IExtendTaskPad)
	END_COM_MAP()

	// Constructor/Destructor
	CComponent();
	~CComponent();

	// A pointer to the currently selected node used for refreshing views.
	// When we need to update the view, we tell MMC to reselect this node.
	CSnapInItem * m_pSelectedNode;

	// Handlers for notifications which we want to handle on a
	// per-IComponent basis.
public:
	// We are overiding ATLsnap.h's IComponentImpl implementation of this
	// in order to correctly handle messages which it is incorrectly
	// ignoring (e.g. MMCN_COLUMN_CLICK and MMCN_SNAPINHELP)
	STDMETHOD(Notify)(
          LPDATAOBJECT lpDataObject
        , MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
		);

	STDMETHOD(CompareObjects)(
			  LPDATAOBJECT lpDataObjectA
			, LPDATAOBJECT lpDataObjectB
			);
protected:
	virtual HRESULT OnColumnClick(
		  LPARAM arg
		, LPARAM param
		);
	virtual HRESULT OnCutOrMove(
		  LPARAM arg
		, LPARAM param
		);
	virtual HRESULT OnViewChange(	
		  LPARAM arg
		, LPARAM param
		);
	virtual HRESULT OnPropertyChange(	
		  LPARAM arg
		, LPARAM param
		);
	virtual HRESULT OnAddImages(	
			  LPARAM arg
			, LPARAM param
			);

	// html help
	HRESULT OnResultContextHelp(LPDATAOBJECT lpDataObject);

public:

	// Related to TaskPad implementation.

	STDMETHOD(GetTitle)(
					  LPOLESTR pszGroup
					, LPOLESTR *pszTitle
					);

	STDMETHOD(GetBanner)(
					  LPOLESTR pszGroup
					, LPOLESTR *pszBitmapResource
					);

	STDMETHOD(GetBackground)(
					  LPOLESTR pszGroup
					, LPOLESTR *pszBitmapResource
					);

};

#endif // _IAS_COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\component.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    Component.cpp

Abstract:

   Implementation file for the CComponent class.

   The CComponent class implements several interfaces which MMC uses:
   
   The IComponent interface is basically how MMC talks to the snap-in
   to get it to implement a right-hand-side "scope" pane.  There can be several
   objects implementing this interface instantiated at once.  These are best
   thought of as "views" on the single object implementing the IComponentData
   "document" (see ComponentData.cpp).

   The IExtendPropertySheet interface is how the snap-in adds property sheets
   for any of the items a user might click on.

   The IExtendContextMenu interface what we do to add custom entries
   to the menu which appears when a user right-clicks on a node.
   
   The IExtendControlBar interface allows us to support a custom
   iconic toolbar.

Note:

   Much of the functionality of this class is implemented in atlsnap.h
   by IComponentDataImpl.  We are mostly overriding here.


Author:

    Michael A. Maguire 11/6/97

Revision History:
   mmaguire 11/6/97  - created using MMC snap-in wizard
   mmaguire 11/24/97 - hurricaned for better project structure

--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "Component.h"
//
// where we can find declarations needed in this file:
//
#include "ServerNode.h"
#include "ClientsNode.h"
#include "ClientNode.h"
#include "ComponentData.h"
#include "MMCUtility.cpp" // This is temporary until we figure out how to get
         // a cpp file from another directory compiling in this project
#include "ChangeNotification.h"
#include "globals.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::CComponent

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CComponent::CComponent()
   :m_pSelectedNode(NULL)
{
   ATLTRACE(_T("# +++ CComponent::CComponent\n"));
   // Check for preconditions:
   // None.
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::~CComponent

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CComponent::~CComponent()
{
   ATLTRACE(_T("# --- CComponent::~CComponent\n"));
   
   // Check for preconditions:
   // None.
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::Notify

Notifies the snap-in of actions taken by the user.

HRESULT Notify(
  LPDATAOBJECT lpDataObject,  // Pointer to a data object
  MMC_NOTIFY_TYPE event,      // Action taken by a user
  LPARAM arg,                 // Depends on event
  LPARAM param                // Depends on event
);


Parameters

   lpDataObject
   [in] Pointer to the data object of the currently selected item.

   event
   [in] Identifies an action taken by a user. IComponent::Notify can receive the
   following notifications:

      MMCN_ACTIVATE
      MMCN_ADD_IMAGES
      MMCN_BTN_CLICK
      MMCN_CLICK
      MMCN_DBLCLICK
      MMCN_DELETE
      MMCN_EXPAND
      MMCN_MINIMIZED
      MMCN_PROPERTY_CHANGE
      MMCN_REMOVE_CHILDREN
      MMCN_RENAME
      MMCN_SELECT
      MMCN_SHOW
      MMCN_VIEW_CHANGE

   All of which are forwarded to each node's Notify method, as well as:

      MMCN_COLUMN_CLICK
      MMCN_SNAPINHELP

   Which are handled here.


   arg
   Depends on the notification type.

   param
   Depends on the notification type.


Return Values

   S_OK
   Depends on the notification type.

   E_UNEXPECTED
   An unexpected error occurred.


Remarks

   We are overiding the ATLsnap.h implementation of IComponentImpl because
   it always returns E_UNEXPECTED when lpDataObject == NULL.
   Unfortunately, some valid message (e.g. MMCN_SNAPINHELP and MMCN_COLUMN_CLICK)
   pass in lpDataObject = NULL   by design.

   Also, there seems to be some problem with Sridhar's latest
   IComponentImpl::Notify method, because it causes MMC to run-time error.


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponent::Notify (
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param
      )
{
   ATLTRACE(_T("# CComponent::Notify\n"));

   // Check for preconditions:
   // None.

   HRESULT hr;

   // deal with help
   if(event == MMCN_CONTEXTHELP)
   {
      return OnResultContextHelp(lpDataObject);
   }

   // lpDataObject should be a pointer to a node object.
   // If it is NULL, then we are being notified of an event
   // which doesn't pertain to any specific node.

   if ( NULL == lpDataObject )
   {
      // respond to events which have no associated lpDataObject

      switch( event )
      {
      case MMCN_COLUMN_CLICK:
         hr = OnColumnClick( arg, param );
         break;

      case MMCN_CUTORMOVE:
         hr = OnCutOrMove( arg, param );
         break;

      case MMCN_PROPERTY_CHANGE:
         hr = OnPropertyChange( arg, param );
         break;

      case MMCN_VIEW_CHANGE:
         hr = OnViewChange( arg, param );
         break;

      default:
         ATLTRACE(_T("# CComponent::Notify - called with lpDataObject == NULL and no event handler\n"));
         hr = E_NOTIMPL;
         break;
      }

      return hr;
   }

   // Respond to some notifications where the lpDataObject is not NULL
   // but we nevertheless have decided that we want to handle them on a
   // per-IComponent basis.

   switch( event )
   {

   case MMCN_ADD_IMAGES:
      hr = OnAddImages( arg, param );
      return hr;
      break;

   case MMCN_CUTORMOVE:
         hr = OnCutOrMove( arg, param );
         return hr;
         break;

   }

   // We were passed a LPDATAOBJECT which corresponds to a node.
   // We convert this to the ATL ISnapInDataInterface pointer.
   // This is done in GetDataClass (a static method of ISnapInDataInterface)
   // by asking the dataobject via a supported clipboard format (CCF_GETCOOKIE)
   // to write out a pointer to itself on a stream and then
   // casting this value to a pointer.
   // We then call the Notify method on that object, letting
   // the node object deal with the Notify event itself.

   CSnapInItem* pItem;
   DATA_OBJECT_TYPES type;
   hr = m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
   
   ATLASSERT(SUCCEEDED(hr));
   
   if (SUCCEEDED(hr))
   {
      hr = pItem->Notify( event, arg, param, NULL, this, type );
   }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CComponent::CompareObjects

Needed so that IPropertySheetProvider::FindPropertySheet will work.

FindPropertySheet is used to bring a pre-existing property sheet to the foreground
so that we don't open multiple copies of Properties on the same node.

It requires CompareObjects to be implemented on both IComponent and IComponentData.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponent::CompareObjects(
        LPDATAOBJECT lpDataObjectA
      , LPDATAOBJECT lpDataObjectB
      )
{
   ATLTRACE(_T("# CComponent::CompareObjects\n"));

   // Check for preconditions:

   HRESULT hr;

   CSnapInItem *pDataA, *pDataB;
   DATA_OBJECT_TYPES typeA, typeB;

   hr = GetDataClass(lpDataObjectA, &pDataA, &typeA);
   if ( FAILED( hr ) )
   {
      return hr;
   }
   
   hr = GetDataClass(lpDataObjectB, &pDataB, &typeB);
   if ( FAILED( hr ) )
   {
      return hr;
   }

   if( pDataA == pDataB )
   {
      // They are the same object.
      return S_OK;
   }
   else
   {
      // They are different.
      return S_FALSE;
   }
}


/////////////////////////////////////////////////////////////////////////////
/*++

CComponent::OnColumnClick

HRESULT OnColumnClick(  
           LPARAM arg
         , LPARAM param
         )

In our implementation, this method gets called when the MMCN_COLUMN_CLICK
Notify message is sent for our IComponent object.

MMC sends this message when the user clicks on a result-list view column header.


Parameters

   arg
   Column number.

   param
   Sort option flags. By default, the sort is in ascending order. To specify descending order, use the RSI_DESCENDING (0x0001) flag.


Return Values
   
   Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::OnColumnClick(
     LPARAM arg
   , LPARAM param
   )
{
   ATLTRACE(_T("# CComponent::OnColumnClick -- Not implemented\n"));

   // Check for preconditions:
   // None.

   return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CComponent::OnCutOrMove

HRESULT OnCutOrMove( 
           LPARAM arg
         , LPARAM param
         )

In our implementation, this method gets called when the MMCN_COLUMN_CLICK
Notify message is sent for our IComponent object.

MMC sends this message when the user clicks on a result-list view column header.


Parameters

   arg
   Column number.

   param
   Sort option flags. By default, the sort is in ascending order. To specify descending order, use the RSI_DESCENDING (0x0001) flag.


Return Values
   
   Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::OnCutOrMove(
     LPARAM arg
   , LPARAM param
   )
{
   ATLTRACE(_T("# CComponent::OnCutOrMove\n"));

   // Check for preconditions:
   // None.

   // ISSUE: This may need to be changed once the MMC team finalizes their
   // cut and paste protocol -- they seem to be in flux for 1.1 as of 02/16/98.
   // Currently, we will assume that the arg value passed to us is the source item
   // in the cut-and-paste or drag-n-drop operation.  That is, it is the object
   // to be deleted.
   // We supplied this pointer in our response to the MMCN_PASTE notification,
   // when we set param to point to the source IDataObject.

   HRESULT hr;

   if( arg != NULL )
   {
      CSnapInItem* pData;
      DATA_OBJECT_TYPES type;
      hr = CSnapInItem::GetDataClass( (IDataObject *) arg, &pData, &type);
      
      ATLASSERT(SUCCEEDED(hr));
      
      if (SUCCEEDED(hr))
      {
         // We need a richer Notify method which has information about the IComponent and IComponentData objects
         //hr = pData->Notify(event, arg, param, TRUE, m_spConsole, NULL, NULL);

         hr = pData->Notify( MMCN_CUTORMOVE, arg, param, NULL, this, type );
      }
   }
   return S_OK;
}


/*!--------------------------------------------------------------------------
   CComponent::OnResultContextHelp
      Implementation of OnResultContextHelp
   Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CComponent::OnResultContextHelp(LPDATAOBJECT lpDataObject)
{
   const WCHAR szDefaultHelpTopic[] = L"ias_ops.chm::/sag_IAStopnode.htm";
   const WCHAR szClientHelpTopic[] = L"ias_ops.chm::/sag_ias_clientproc.htm";
  
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   bool isClientNode = false;

   CSnapInItem* pItem;
   DATA_OBJECT_TYPES type;

   HRESULT hr = GetDataClass(lpDataObject, &pItem, &type);
   if ( SUCCEEDED(hr) ) 
   {
      isClientNode = (pItem->m_helpIndex == CLIENT_HELP_INDEX);
   } 

   CComPtr<IDisplayHelp>  spDisplayHelp;

   hr = m_spConsole->QueryInterface(
                        __uuidof(IDisplayHelp), 
                        (LPVOID*) &spDisplayHelp
                        );
   
   ASSERT (SUCCEEDED (hr));
   if ( SUCCEEDED (hr) )
   {
      if ( isClientNode )
      {
         hr = spDisplayHelp->ShowTopic(W2OLE ((LPWSTR)szClientHelpTopic));
      }
      else
      {
         hr = spDisplayHelp->ShowTopic(W2OLE ((LPWSTR)szDefaultHelpTopic));
      }

      ASSERT (SUCCEEDED (hr));
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::OnViewChange

HRESULT OnViewChange(   
           LPARAM arg
         , LPARAM param
         )

This is where we respond to an MMCN_VIEW_CHANGE notification.

In our implementation, this is a signal to check the currently selected node in
the result pane for this component, and refresh the view if the node happens to
be the same as the pointer to a CSnapInItem passed in through arg.

We do this because you only want to refresh the view of the currently selected
node, and you only want to do that if its children have changed.

If the arg passed in is NULL, we just reselect the currently selected node.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::OnViewChange(   
           LPARAM arg
         , LPARAM param
         )
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::OnViewChange\n"));

   // Check for preconditions:
   _ASSERTE( m_spConsole != NULL );

   HRESULT hr = S_FALSE;

   CChangeNotification *pChangeNotification = NULL;

   try
   {
      // If arg here is non-NULL, it should be a pointer to a CChangeNotification object.
      if( arg != NULL )
      {
         pChangeNotification = (CChangeNotification *) arg;

         // For now, just call update item on the node.
         
         // ISSUE: Later, we should have a switch on m_dwFlags to see what we should do.
         // e.g. in the case of a deletion, we should (maybe?) reselect parent node or something.

         switch( pChangeNotification->m_dwFlags )
         {
         case CHANGE_UPDATE_RESULT_NODE:
            {
               // We need to update a single node.
               
               CComQIPtr< IResultData, &IID_IResultData > spResultData( m_spConsole );
               if( ! spResultData )
               {
                  throw hr;
               }

               if( pChangeNotification->m_pNode )
               {
                  HRESULTITEM item;
                  hr = spResultData->FindItemByLParam( (LPARAM) pChangeNotification->m_pNode, &item );
                  // Note: You can't use the itemID stored in CSnapInItem's RESULTDATAITEM structure
                  // as this itemID is unique to each view -- so when you add the same item in each
                  // result pane view, you get a different itemID from each call to InsertItem.
                  // CSnapInItem's RESULTDATAITEM structure only stores the last one stored.
                  // This is a flaw in the atlsnap.h architecture, which is why we use
                  // MMC's FindItemByLParam instead to get the appropriate itemID.
                  hr = spResultData->UpdateItem( item );
               }
            }
            break;
         case CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE:
            {
               // We basically tell MMC to simulate reselecting the
               // currently selected scope-pane node, which causes it to redraw.
               // This will cause MMC to send the MMCN_SHOW notification
               // to the selected node.
               if( m_pSelectedNode )
               {
                  SCOPEDATAITEM *pScopeDataItem;
                  m_pSelectedNode->GetScopeData( &pScopeDataItem );
                  hr = m_spConsole->SelectScopeItem( pScopeDataItem->ID );
               }

            }
            break;
         case CHANGE_UPDATE_CHILDREN_OF_THIS_NODE:
            {
               // We basically tell MMC to simulate reselecting the
               // currently selected scope-pane node, which causes it to redraw.
               // This will cause MMC to send the MMCN_SHOW notification
               // to the selected node.
               if( pChangeNotification->m_pNode && m_pSelectedNode && pChangeNotification->m_pNode == m_pSelectedNode )
               {
                  SCOPEDATAITEM *pScopeDataItem;
                  m_pSelectedNode->GetScopeData( &pScopeDataItem );
                  hr = m_spConsole->SelectScopeItem( pScopeDataItem->ID );
               }

            }

         default:
            break;
         }
      }

   // // What localsec snapin checks for:
   // if( ( arg == NULL || (CSnapInItem *) arg == m_pSelectedNode ) && m_pSelectedNode != NULL )
   // {
   //
   //    // We basically tell MMC to simulate reselecting the
   //    // currently selected node, which causes it to redraw.
   //    // This will cause MMC to send the MMCN_SHOW notification
   //    // to the selected node.
   //    // This function requires an HSCOPEITEM.  This is the ID member
   //    // of the HSCOPEDATAITEM associated with this node.
   //    SCOPEDATAITEM *pScopeDataItem;
   //    m_pSelectedNode->GetScopeData( &pScopeDataItem );
   //    hr = m_spConsole->SelectScopeItem( pScopeDataItem->ID );
   //
   // }

   }
   catch(...)
   {
      // Do nothing -- just need to catch for proper clean-up below.
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::OnPropertyChange

HRESULT OnPropertyChange(  
           LPARAM arg
         , LPARAM param
         )

This is where we respond to an MMCN_PROPERTY_CHANGE notification.

This notification is sent when we call MMCPropertyChangeNotify.
We call this in our property pages when changes are made to the data
they contain and we may need to update of view of the data.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::OnPropertyChange(  
           LPARAM arg
         , LPARAM param
         )
{
   ATLTRACE(_T("# CComponent::OnPropertyChange\n"));

   // Check for preconditions:
   _ASSERTE( m_spConsole != NULL );

   HRESULT hr = S_FALSE;

// if( param == NULL )
// {
//
//    // We want to make sure all views get updated.
//    hr = m_spConsole->UpdateAllViews( NULL, (LPARAM) m_pSelectedNode, 0);
//
// }
// else

   if( param )
   {
      // We were passed a pointer to a CChangeNotification in the param argument.

      CChangeNotification * pChangeNotification = (CChangeNotification *) param;

      
      // We call notify on the node specified, passing it our own custom event type
      // so that it knows that it must refresh its data.

      // Call notify on this node with the MMCN_PROPERTY_CHANGE notification.
      // We had to use this trick because of the fact that we are using template
      // classes and so we have no common object among all our nodes
      // other than CSnapInItem.  But we can't change CSnapInItem
      // so instead we use the notify method it already has with a new
      // notification.
      
      // Note:  We are trying to deal gracefully here with the fact that the
      // MMCN_PROPERTY_CHANGE notification doesn't pass us an lpDataObject
      // so we have to have our own protocol for picking out which node
      // needs to update itself.
      
      hr = pChangeNotification->m_pNode->Notify( MMCN_PROPERTY_CHANGE
                     , NULL
                     , NULL
                     , NULL
                     , NULL
                     , (DATA_OBJECT_TYPES) 0
                     );

      // We want to make sure all views with this node select also get updated.
      // Pass it the CChangeNotification pointer we were passed in param.
      hr = m_spConsole->UpdateAllViews( NULL, param, 0);
   
      pChangeNotification->Release();
   
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::OnAddImages

HRESULT OnAddImages( 
           LPARAM arg
         , LPARAM param
         )

This is where we respond to an MMCN_ADD_IMAGES notification to
this IComponent object.

We add images to the image list used to display result pane
items corresponding to this IComponent's view.

MMC sends this message to the snap-in's IComponent implementation
to add images for the result pane.

Parameters

   arg
   Pointer to the result pane's image list (IImageList).

   param
   Specifies the HSCOPEITEM of the item that was selected or deselected.


Return Values

   Not used.


Remarks

   The primary snap-in should add images for both folders and leaf
   items. Extension snap-ins should add only folder images.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::OnAddImages( 
           LPARAM arg
         , LPARAM param
         )
{
   ATLTRACE(_T("# CComponent::OnAddImages\n"));

   // Check for preconditions:
   _ASSERTE( arg != NULL );

   HRESULT hr = S_FALSE;

   // ISSUE: sburns in localsec does a trick where he combines
   // scope and result pane ImageLists into one
   // is this necessary?
   
   CComPtr<IImageList> spImageList = reinterpret_cast<IImageList*>(arg);
   _ASSERTE( spImageList != NULL );


   HBITMAP hBitmap16 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_IASSNAPIN_16 ) );

   HBITMAP hBitmap32 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_IASSNAPIN_32 ) );

   if( hBitmap16 != NULL && hBitmap32 != NULL )
   {
      hr = spImageList->ImageListSetStrip( (LONG_PTR*) hBitmap16, (LONG_PTR*) hBitmap32, 0, RGB(255,0,255) );
      if( FAILED( hr ) )
      {
         ATLTRACE(_T("# *** CSnapinNode::OnAddImages  -- Failed to add images.\n"));
      }
   }

   if ( hBitmap16 != NULL )
   {
      DeleteObject(hBitmap16);
   }
   if ( hBitmap32 != NULL )
   {
      DeleteObject(hBitmap32);
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::GetResultViewType

Used to answer what the view type should be for the result view.

We need to implement this here so that we can override the ATLsnap.h
implementation, which doesn't properly allow for the fact that a NULL cookie
corresponds to the root node, and we may not necessarily want the default
view for the root node.

This problem with ATLsnap.h could not easily be changed as the CComponentImpl
class has no easy way to find the root node -- it doesn't have a member
variable corresponding to it.

--*/
//////////////////////////////////////////////////////////////////////////////
//STDMETHODIMP CComponent::GetResultViewType (
//   MMC_COOKIE cookie
// , LPOLESTR  *ppViewType
// , long  *pViewOptions
// )
//{
// ATLTRACE(_T("# CComponent::GetResultViewType\n"));
//
//
// // Check for preconditions:
//
//
//
// // Check to see which node we are being asked to give view type for.
// if (cookie == NULL)
// {
//    // We are being asked for the result view type of our
//    // root node -- let the root node give back its answer.
//
//    _ASSERTE( m_pComponentData != NULL );
//    _ASSERTE( m_pComponentData->m_pNode != NULL );
//    return m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
//
// }
// else
// {
//    // Cookie was not null, which means we are beng asked about
//    // the result view type for some node other than our root node.
//    // Let that node set whatever view type it wants to.
//    CSnapInItem* pItem = (CSnapInItem*)cookie;
//
//    return pItem->GetResultViewType(ppViewType, pViewOptions);
// }
//
//}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::GetTitle

IExtendTaskPad interface member.

This is the title that show up under the banner.

ISSUE: Why does this not appear to be working?

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::GetTitle (LPOLESTR pszGroup, LPOLESTR *pszTitle)
{
   ATLTRACE(_T("# CComponent::GetTitle\n"));

   // Check for preconditions:
   _ASSERTE( pszTitle != NULL );

   OLECHAR szTitle[IAS_MAX_STRING];
   szTitle[0] = 0;
   int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_TASKPAD_SERVER__TITLE, szTitle, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   *pszTitle= (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(szTitle)+1) );

   if( ! *pszTitle )
   {
      return E_OUTOFMEMORY;
   }

   lstrcpy( *pszTitle, szTitle );

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::GetBanner

IExtendTaskPad interface member.

We provide the color bar banner that appears at the top of the taskpad.
It is a resource in our snapin DLL.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::GetBanner (LPOLESTR pszGroup, LPOLESTR *pszBitmapResource)
{
   ATLTRACE(_T("# CComponent::GetBanner\n"));

   // Check for preconditions:

   // We are constructing a string pointing to the bitmap resource
   // of the form: "res://D:\MyPath\MySnapin.dll/img\ntbanner.gif"

   OLECHAR szBuffer[MAX_PATH*2]; // A little extra.

   // Get "res://"-type string for bitmap.
   lstrcpy (szBuffer, L"res://");
   OLECHAR * temp = szBuffer + lstrlen(szBuffer);

   // Get our executable's filename.
   HINSTANCE hInstance = _Module.GetResourceInstance();
   ::GetModuleFileName (hInstance, temp, MAX_PATH);
   
   // Add the name of the image within our resources.
   lstrcat (szBuffer, L"/img\\IASTaskpadBanner.gif");

   // Alloc and copy bitmap resource string.
   *pszBitmapResource = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(szBuffer)+1) );
   if (!*pszBitmapResource)
   {
      return E_OUTOFMEMORY;
   }

   lstrcpy( *pszBitmapResource, szBuffer );

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::GetBackground

IExtendTaskPad interface member.

Not used

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::GetBackground(LPOLESTR pszGroup, LPOLESTR *pszBitmapResource)
{
   ATLTRACE(_T("# CComponent::GetBackground\n"));

   // Check for preconditions:

   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\clientsnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ClientsNode.h

Abstract:

   Header file for the CClientsNode subnode.

   See ClientsNode.cpp for implementation.

Author:

    Michael A. Maguire 11/10/97

Revision History:
   mmaguire 11/10/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_CLIENTS_NODE_H_)
#define _IAS_CLIENTS_NODE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "NodeWithResultChildrenList.h"
//
//
// where we can find what this class has or uses:
//

#include "Vendors.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CClientNode;
class CServerNode;
class CAddClientDialog;
class CComponentData;
class CComponent;

class CClientsNode : public CNodeWithResultChildrenList< CClientsNode, CClientNode, CSimpleArray<CClientNode*>, CComponentData, CComponent >
{
public:
   SNAPINMENUID(IDM_CLIENTS_NODE)

   BEGIN_SNAPINTOOLBARID_MAP(CClientsNode)
//    SNAPINTOOLBARID_ENTRY(IDR_CLIENTS_TOOLBAR)
   END_SNAPINTOOLBARID_MAP()

   BEGIN_SNAPINCOMMAND_MAP(CClientsNode, FALSE)
      SNAPINCOMMAND_ENTRY(ID_MENUITEM_CLIENTS_TOP__NEW_CLIENT, OnAddNewClient)
      SNAPINCOMMAND_ENTRY(ID_MENUITEM_CLIENTS_NEW__CLIENT, OnAddNewClient)
      //CHAIN_SNAPINCOMMAND_MAP( CSnapinNode<CClientsNode, CComponentData, CComponent> )
      //CHAIN_SNAPINCOMMAND_MAP( CClientsNode )
   END_SNAPINCOMMAND_MAP() 

   // Constructor/Destructor.
   CClientsNode( CSnapInItem * pParentNode );
   ~CClientsNode();

   // Used to get access to snapin-global data.
   CComponentData * GetComponentData( void );

   // Used to get access to server-global data.
   CServerNode * GetServerRoot( void );

   // SDO management.
   HRESULT InitSdoPointers( ISdo *pSdoServer );

   HRESULT LoadCachedInfoFromSdo( void );

   // Reset Sdo pointers during refresh
   HRESULT ResetSdoPointers( ISdo *pSdoServer );

   // called by parent node to do refresh
   HRESULT  DataRefresh(ISdo* pNewSdo);


   // Some overrides for standard MMC functionality.
   OLECHAR* GetResultPaneColInfo( int nCol );
   
   HRESULT OnQueryPaste(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   
   HRESULT OnPaste(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
   
   HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
   
   HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );

   void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);

   virtual HRESULT OnRefresh(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         );

   // Our own handling of property page changes.
   HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );


   STDMETHOD(FillData)(CLIPFORMAT cf, LPSTREAM pStream);

   // Adding, removing, listing client children.
   HRESULT OnAddNewClient( bool &bHandled, CSnapInObjectRootBase* pObj );
   
   HRESULT RemoveChild( CClientNode * pChildNode );
   
   HRESULT PopulateResultChildrenList( void );

private:
   CAddClientDialog * m_pAddClientDialog;

   // Smart pointer to interface for telling service to reload data.
   CComPtr<ISdoServiceControl>   m_spSdoServiceControl;
   
   // pointer to our clients SDO collection;
   CComPtr<ISdoCollection> m_spSdoCollection;   

   // Clients collection.
   Vendors m_vendors;
};

#endif // _IAS_CLIENTS_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\componentdata.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ComponentData.cpp

Abstract:

	The CComponentData class implements several interfaces which MMC uses:
	
	The IComponentData interface is basically how MMC talks to the snap-in
	to get it to implement the left-hand-side "scope" pane.

	The IExtendPropertySheet interface is how the snap-in adds property sheets
	for any of the items a user might click on.

	The IExtendContextMenu interface what we do to add custom entries
	to the menu which appears when a user right-clicks on a node.
	
	The IExtendControlBar interface allows us to support a custom
	iconic toolbar.

	See ComponentData.cpp for implementation.

Note:

	Much of the functionality of this class is implemented in atlsnap.h
	by IComponentDataImpl.  We are mostly overriding here.

Author:

    Michael A. Maguire 11/6/97

Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_COMPONENT_DATA_H_)
#define _IAS_COMPONENT_DATA_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
// Moved to Precompiled.h: #include <atlsnap.h>
//
//
// where we can find what this class has or uses:
//
#include "resource.h"
#include "IASMMC.h"
#include "Component.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class CComponentData :
	  public CComObjectRootEx<CComSingleThreadModel>
	, public CSnapInObjectRoot<1, CComponentData>
	, public IComponentDataImpl<CComponentData, CComponent>
#ifndef NOWIZARD97
	, public IExtendPropertySheet2Impl<CComponentData>
#else // NOWIZARD97
	, public IExtendPropertySheetImpl<CComponentData>
#endif //NOWIZARD97
	, public IExtendContextMenuImpl<CComponentData>
	, public ISnapinHelp
	, public IPersistStream
	, public CComCoClass<CComponentData, &CLSID_IASSnapin>
{

public:

	BEGIN_COM_MAP(CComponentData)
		COM_INTERFACE_ENTRY(IComponentData)
#ifndef NOWIZARD97
		COM_INTERFACE_ENTRY(IExtendPropertySheet2)
#else // NOWIZARD97
		COM_INTERFACE_ENTRY(IExtendPropertySheet)
#endif // NOWIZARD97
		COM_INTERFACE_ENTRY(IExtendContextMenu)
		COM_INTERFACE_ENTRY(ISnapinHelp)
		COM_INTERFACE_ENTRY(IPersistStream)
	END_COM_MAP()

	DECLARE_REGISTRY_RESOURCEID(IDR_IASSNAPIN)

	DECLARE_NOT_AGGREGATABLE(CComponentData)

	// Constructor/Destructor
	CComponentData();
	~CComponentData();

	// called when extending other snapins -- to add the IAS node
   HRESULT AddRootNode(LPCWSTR machinename, HSCOPEITEM parent);

	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	// We are overiding ATLsnap.h's IComponentImpl implementation of this
	// in order to correctly handle messages which it is incorrectly
	// ignoring (e.g. MMCN_COLUMN_CLICK and MMCN_SNAPINHELP)
	STDMETHOD(Notify)(
          LPDATAOBJECT lpDataObject
        , MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
		);

   virtual HRESULT OnPropertyChange(	
		  LPARAM arg
		, LPARAM param
		);

	STDMETHOD(CompareObjects)(
		  LPDATAOBJECT lpDataObjectA
		, LPDATAOBJECT lpDataObjectB
		);

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent);

   // ISnapinHelp method(s)
   STDMETHOD(GetHelpTopic)( LPOLESTR * lpCompiledHelpFile );

	// IPersist overrides
	STDMETHOD(GetClassID)(CLSID* pClassID);

	// IPersistStream overrides
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)(IStream* stream);
	STDMETHOD(Save)(IStream* stream, BOOL /* clearDirty */);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* size);
};

#endif // _IAS_COMPONENT_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\connectiontoserver.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ConectionToServer.h

Abstract:

	Header file for class which manages connection to a remote server.

	The connect action takes place in a worker thread.

	See ConnectionToServer.cpp for implementation.

Author:

    Michael A. Maguire 02/09/98

Revision History:
	mmaguire 02/09/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_CONNECTION_TO_SERVER_H_)
#define _IAS_CONNECTION_TO_SERVER_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "DialogWithWorkerThread.h"
//
//
// where we can find what this class has or uses:
//
#include "sdoias.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


typedef
enum _TAG_CONNECTION_STATUS
{
	NO_CONNECTION_ATTEMPTED = 0,
	CONNECTING,
	CONNECTED,
	CONNECTION_ATTEMPT_FAILED,
	CONNECTION_INTERRUPTED,
	UNKNOWN
} CONNECTION_STATUS;



class CServerNode;

class CConnectionToServer : public CDialogWithWorkerThread<CConnectionToServer>
{

public:

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of 
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_CONNECT_TO_MACHINE };

	BEGIN_MSG_MAP(CConnectionToServer)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDCANCEL, OnCancel )
		CHAIN_MSG_MAP(CDialogWithWorkerThread<CConnectionToServer>)
	END_MSG_MAP()

	LRESULT OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnReceiveThreadMessage(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	CConnectionToServer( CServerNode *pServerNode, BOOL fLocalMachine, BSTR bstrServerAddress );

	~CConnectionToServer( void );

	CONNECTION_STATUS GetConnectionStatus( void );

	HRESULT GetSdoServer( ISdo **ppSdo );

	// happening in the main thread
	HRESULT ReloadSdo(ISdo **ppSdo);

	DWORD DoWorkerThreadAction();

private:

	BOOL m_fLocalMachine;

	CComBSTR m_bstrServerAddress;

	CONNECTION_STATUS m_ConnectionStatus;

	// Pointer to stream into which the worker thread
	// this class creates will marshal the Sdo interface pointer it gets.
	LPSTREAM m_pStreamSdoMarshal;

	// SDO pointers for use in the main thread's context.
	CComPtr<ISdoMachine> m_spSdoMachine;
	CComPtr<ISdo> m_spSdo;

	CServerNode *m_pServerNode;
};


#endif // _IAS_CONNECTION_TO_SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\connectiontoserver.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ConnectionToServer.cpp

Abstract:

	Implementation file for utility functions for connecting to a server.


Author:

    Michael A. Maguire 11/10/97

Revision History:
	mmaguire 11/10/97 - created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ConnectionToServer.h"
//
//
// where we can find declarations needed in this file:
//
#include "ServerNode.h"
#include "ComponentData.h"
#include "ChangeNotification.h"
#include "cnctdlg.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



// Initialize the Help ID pairs
//const DWORD CConnectionToServer::m_dwHelpMap[] =
//{
//	0, 0
//};



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::CConnectionToServer

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CConnectionToServer::CConnectionToServer( CServerNode *pServerNode, BOOL fLocalMachine, BSTR bstrServerAddress )
{
	ATLTRACE(_T("# +++ CConnectionToServer::CConnectionToServer\n"));


	// Check for preconditions:
	_ASSERTE( pServerNode != NULL );

	m_fLocalMachine = fLocalMachine;

	m_bstrServerAddress = bstrServerAddress;

	m_pStreamSdoMarshal = NULL;

	m_pServerNode = pServerNode;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::~CConnectionToServer

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CConnectionToServer::~CConnectionToServer()
{
	ATLTRACE(_T("# --- CConnectionToServer::~CConnectionToServer\n"));

	// Release this stream pointer if this hasn't already been done.
	if( m_pStreamSdoMarshal != NULL )
	{
		m_pStreamSdoMarshal->Release();
	};

}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CConnectionToServer::OnInitDialog(
	  UINT uMsg
	, WPARAM wParam
	, LPARAM lParam
	, BOOL& bHandled
	)
{
	ATLTRACE(_T("# CConnectionToServer::OnInitDialog\n"));


	// Check for preconditions:
	CComponentData *pComponentData  = m_pServerNode->GetComponentData();
	_ASSERTE( pComponentData != NULL );
	_ASSERTE( pComponentData->m_spConsole != NULL );


	// Change the icon for the scope node from being normal to a busy icon.
	CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > spConsoleNameSpace( pComponentData->m_spConsole );
	LPSCOPEDATAITEM psdiServerNode;
	m_pServerNode->GetScopeData( &psdiServerNode );
	_ASSERTE( psdiServerNode );
	SCOPEDATAITEM sdi;
	sdi.mask = SDI_IMAGE | SDI_OPENIMAGE;
	sdi.nImage = IDBI_NODE_SERVER_BUSY_CLOSED;
	sdi.nOpenImage = IDBI_NODE_SERVER_BUSY_OPEN;
	sdi.ID = psdiServerNode->ID;


	// Change the stored indices as well so that MMC will use them whenever it queries
	// the node for its images.
	LPRESULTDATAITEM prdiServerNode;
	m_pServerNode->GetResultData( &prdiServerNode );
	_ASSERTE( prdiServerNode );
	prdiServerNode->nImage = IDBI_NODE_SERVER_BUSY_CLOSED;
	psdiServerNode->nImage = IDBI_NODE_SERVER_BUSY_CLOSED;
	psdiServerNode->nOpenImage = IDBI_NODE_SERVER_BUSY_OPEN;

	spConsoleNameSpace->SetItem( &sdi );

	// Create the SdoMachine object. We do it here, so that it will live in
	// the main thread's apartment.
	CoCreateInstance(
	    __uuidof(SdoMachine),
	    NULL,
	    CLSCTX_INPROC_SERVER,
	    __uuidof(ISdoMachine),
	    (PVOID*)&m_spSdoMachine
	    );

	// Marshall the pointer for the worker thread. We don't care if this or
	// the previous call fails. If either does, then m_pStreamSdoMarshal will
	// be NULL, and the worker thread will take appropriate action.
   CoMarshalInterThreadInterfaceInStream(
	    __uuidof(ISdoMachine),
	    m_spSdoMachine,
	    &m_pStreamSdoMarshal
	    );

	StartWorkerThread();

	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::OnReceiveThreadMessage

Called when the worker thread wants to inform the main MMC thread of something.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CConnectionToServer::OnReceiveThreadMessage(
	  UINT uMsg
	, WPARAM wParam
	, LPARAM lParam
	, BOOL& bHandled
	)
{
	ATLTRACE(_T("# CConnectionToServer::OnReceiveThreadMessage\n"));


	// Check for preconditions:
	_ASSERTE( m_pServerNode != NULL );
	CComponentData *pComponentData  = m_pServerNode->GetComponentData();
	_ASSERTE( pComponentData != NULL );
	_ASSERTE( pComponentData->m_spConsole != NULL );


	// The worker thread has notified us that it has finished.


	// Change main IAS scope node to appropriate icon.
	CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > spConsoleNameSpace( pComponentData->m_spConsole );
	LPSCOPEDATAITEM psdiServerNode = NULL;
	m_pServerNode->GetScopeData( &psdiServerNode );
	_ASSERTE( psdiServerNode );
	SCOPEDATAITEM sdi;
	sdi.mask = SDI_IMAGE | SDI_OPENIMAGE;
	if( wParam == 0 )
	{
		// Things went OK -- change the icon for the main IAS scope node
		// from being a busy icon to the normal icon.


		sdi.nImage = IDBI_NODE_SERVER_OK_CLOSED;
		sdi.nOpenImage = IDBI_NODE_SERVER_OK_OPEN;

		// Change the stored indices as well so that MMC will use them whenever it queries
		// the node for its images.
		LPRESULTDATAITEM prdiServerNode;
		m_pServerNode->GetResultData( &prdiServerNode );
		_ASSERTE( prdiServerNode );
		prdiServerNode->nImage = IDBI_NODE_SERVER_OK_CLOSED;
		psdiServerNode->nImage = IDBI_NODE_SERVER_OK_CLOSED;
		psdiServerNode->nOpenImage = IDBI_NODE_SERVER_OK_OPEN;
	}
	else
	{
		// There was an error -- change the icon for the main IAS scope node
		// from being a busy icon to the normal icon.

		sdi.nImage = IDBI_NODE_SERVER_ERROR_CLOSED;
		sdi.nOpenImage = IDBI_NODE_SERVER_ERROR_OPEN;

		// Change the stored indices as well so that MMC will use them whenever it queries
		// the node for its images.
		LPRESULTDATAITEM prdiServerNode;
		m_pServerNode->GetResultData( &prdiServerNode );
		_ASSERTE( prdiServerNode );
		prdiServerNode->nImage = IDBI_NODE_SERVER_ERROR_CLOSED;
		psdiServerNode->nImage = IDBI_NODE_SERVER_ERROR_CLOSED;
		psdiServerNode->nOpenImage = IDBI_NODE_SERVER_ERROR_OPEN;
	}
	sdi.ID = psdiServerNode->ID;
	spConsoleNameSpace->SetItem( &sdi );


	// We don't want to destroy the dialog, we just want to hide it.
	//ShowWindow( SW_HIDE );

	if( wParam == 0 )
	{
		// Tell the server node to grab its Sdo pointers.
		m_pServerNode->InitSdoPointers();

		// Ask the server node to update all its info from the SDO's.
		m_pServerNode->LoadCachedInfoFromSdo();

		// Cause a view update.

		CChangeNotification *pChangeNotification = new CChangeNotification();
		pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE;
		pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0 );
		pChangeNotification->Release();

// MAM 10/08/98 U0902 155029 No longer needed
//		// Show the "restart server before changes take effect" message.
//		// It needs to be a modal dialog on top of the main MMC window.
//		CComponentData *pComponentData = m_pServerNode->GetComponentData();
//		_ASSERTE( pComponentData );
//		ShowErrorDialog( NULL, IDS_INFO__RESTART_SERVER, NULL, S_OK, IDS_INFO_TITLE__RESTART_SERVER, pComponentData->m_spConsole );


	}
	else
	{
		// There was an error connecting.

		BOOL			fNT4 = FALSE;
		BOOL			fShowErr = TRUE;
		HRESULT			hr = S_OK;
		UINT			nErrId = IDS_ERROR__NO_SDO;
	
		//$NT5: kennt, changes made to read NT5 specific information
		// ----------------------------------------------------------------
		hr = HRESULT_FROM_WIN32(IsNT4Machine(m_bstrServerAddress, &fNT4));

		if(fNT4)	// then search the directory to see if the NT4 
		{

			hr = m_pServerNode->StartNT4AdminExe();

			if (FAILED(hr))
				fShowErr = FALSE;
			nErrId = IDS_ERROR_START_NT4_ADMIN;
		}

		if(fShowErr)
		{
			// It needs to be a modal dialog on top of the main MMC window.
			CComponentData *pComponentData = m_pServerNode->GetComponentData();
			_ASSERTE( pComponentData );
			ShowErrorDialog( NULL, nErrId, NULL, hr, USE_DEFAULT, pComponentData->m_spConsole );
		}
	}

	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::GetConnectionStatus

Our connection status is basically a function of the status of the underlying
worker thread.  So here we give a connection status based on the worker thread's.

--*/
//////////////////////////////////////////////////////////////////////////////
CONNECTION_STATUS CConnectionToServer::GetConnectionStatus( void )
{
	ATLTRACE(_T("# CConnectionToServer::GetConnectionStatus\n"));


	// Check for preconditions:


	CONNECTION_STATUS csStatus;


	switch( GetWorkerThreadStatus() )
	{
	case WORKER_THREAD_NEVER_STARTED:
		csStatus = NO_CONNECTION_ATTEMPTED;
		break;

	case WORKER_THREAD_STARTING:
	case WORKER_THREAD_STARTED:
		csStatus = CONNECTING;
		break;

	case WORKER_THREAD_FINISHED:
		csStatus = CONNECTED;
		break;

	case WORKER_THREAD_START_FAILED:
	case WORKER_THREAD_ACTION_INTERRUPTED:
		csStatus = CONNECTION_ATTEMPT_FAILED;
		break;

	default:
		csStatus = UNKNOWN;
		break;
	}

	return csStatus;

}

// reload Sdo for refresh
// happening in the main thread
HRESULT CConnectionToServer::ReloadSdo(ISdo **ppSdo)
{
	HRESULT hr = S_OK;

	// this is reload ...
	ASSERT(m_spSdo);

	m_spSdo.Release();

	// Get the service SDO.
	CComPtr<IUnknown> spUnk;
	CComBSTR serviceName(L"IAS");
	hr = m_spSdoMachine->GetServiceSDO(
                             DATA_STORE_LOCAL,
                             serviceName,
                             &spUnk
                             );
	if (FAILED(hr))
		return hr;

	// Get the ISdo interface to the service.
	hr = spUnk->QueryInterface(
                     __uuidof(ISdo),
                     (PVOID*)&m_spSdo
                     );
	if (FAILED(hr))
		return hr;


	*ppSdo = m_spSdo;
	(*ppSdo)->AddRef();

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::GetSdoServer

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CConnectionToServer::GetSdoServer( ISdo **ppSdoServer )
{
	ATLTRACE(_T("# CConnectionToServer::GetSdoServer\n"));


	// Check for preconditions:
	_ASSERTE( ppSdoServer != NULL );


	if( CONNECTED != GetConnectionStatus() )
	{
		*ppSdoServer = NULL;
		return E_FAIL;
	}



	HRESULT hr = S_OK;

	// If we get here, our status is CONNECTED, in which case
	// our worker thread should have marshalled an ISdo interface
	// of the server into the m_pStreadSdoMarshal.

	if( m_pStreamSdoMarshal == NULL )
	{
		// We have already unmarshalled our ISdo interface to the server.
		_ASSERTE( m_spSdo != NULL );

	}
	else
	{
		// Unmarshall an ISdo interface pointer to the server.
		hr =  CoGetInterfaceAndReleaseStream(
							  m_pStreamSdoMarshal			//Pointer to the stream from which the object is to be marshaled.
							, IID_ISdo						//Reference to the identifier of the interface.
							, (LPVOID *) &m_spSdo		//Address of output variable that receives the interface pointer requested in riid.
							);

		// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
		// We set it to NULL so that our destructor doesn't try to release this again.
		m_pStreamSdoMarshal = NULL;

	}

	*ppSdoServer = m_spSdo;
	if(*ppSdoServer)
		(*ppSdoServer)->AddRef();


	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::OnCancel

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CConnectionToServer::OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# CConnectionToServer::OnCancel\n"));


	// Check for preconditions:


	// We don't want to destroy the dialog, we just want to hide it.
	//owWindow( SW_HIDE );


	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::DoWorkerThreadAction

Called by the worker thread to have this class perform its action
in the new thread.

--*/
//////////////////////////////////////////////////////////////////////////////
DWORD CConnectionToServer::DoWorkerThreadAction()
{
	ATLTRACE(_T("# CConnectionToServer::DoWorkerThreadAction\n"));


	HRESULT hr;
	DWORD dwReturnValue;

	// We must call CoInitialize because we are in a new thread.
	hr = CoInitialize( NULL );


	if( FAILED( hr ) )
	{
		ATLTRACE(_T("# CConnectionToServer::DoWorkerThreadAction -- CoInitialize failed\n"));
		return( -1 );
	}

	do	// Loop for error checking only.
	{
		// Unmarshall the SdoMachine object.
		CComPtr<ISdoMachine> spSdoMachine;
		hr =  CoGetInterfaceAndReleaseStream(
		          m_pStreamSdoMarshal,
		          __uuidof(ISdoMachine),
		          (PVOID*)&spSdoMachine
		          );

		// The stream has been released, so null out the pointer.
		m_pStreamSdoMarshal = NULL;

		if( FAILED (hr ) )
		{
			// Error -- couldn't unmarshal SDO.
			ATLTRACE(_T("# CConnectionToServer::DoWorkerThreadAction -- CoGetInterfaceAndReleaseStream failed, hr = %lx\n"), hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = -1;	// ISSUE: Need to figure out better return codes.
			break;
		}

      // Attach to the machinine.
		hr = spSdoMachine->Attach(m_fLocalMachine ? (BSTR)NULL : m_bstrServerAddress);
		while( FAILED( hr ) )
		{
			if(hr == E_ACCESSDENIED)
				hr = ConnectAsAdmin(m_bstrServerAddress);
			if(hr != S_OK)
			{
				// Error -- couldn't connect SDO up to this server.
				ATLTRACE(_T("# CConnectionToServer::DoWorkerThreadAction -- ISdoMachine::Attach failed\n"));
				m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
				dwReturnValue = -1;	// ISSUE: Need to figure out better return codes.
				goto Error;
			}
			else
				hr = spSdoMachine->Attach(m_fLocalMachine ? (BSTR)NULL : m_bstrServerAddress);
		};

      // Get the service SDO.
      CComPtr<IUnknown> pUnk;
      CComBSTR serviceName(L"IAS");
      hr = spSdoMachine->GetServiceSDO(
                             DATA_STORE_LOCAL,
                             serviceName,
                             &pUnk
                             );
      if (FAILED(hr))
      {
         m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
         dwReturnValue = -1;
         break;
      }

		// Get the ISdo interface to the service.
	   CComPtr<ISdo> spSdo;
      hr = pUnk->QueryInterface(
                     __uuidof(ISdo),
                     (PVOID*)&spSdo
                     );
      if (FAILED(hr))
      {
         m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
         dwReturnValue = -1;
         break;
      }

		// Marshall the ISdo pointer so that the main thread can unmarshall
		// it and use the connection we have established.
		hr = CoMarshalInterThreadInterfaceInStream(
						  IID_ISdo										//Reference to the identifier of the interface.
						, spSdo										//Pointer to the interface to be marshaled.
						, &( m_pStreamSdoMarshal )	//Address of output variable that receives the IStream interface pointer for the marshaled interface.
						);

		if( FAILED( hr ) )
		{
			ATLTRACE(_T("# CConnectionToServer::DoWorkerThreadAction -- CoMarshalInterThreadInterfaceInStream failed\n"));
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = -1;
			break;
		}


		// If we made it to here, we are OK.

		_ASSERTE( m_pStreamSdoMarshal != NULL );

		m_wtsWorkerThreadStatus = WORKER_THREAD_FINISHED;

		dwReturnValue = 0;

	} while (0);	// Loop for error checking only.

Error:
	// Tell the main MMC thread what's up.
	PostMessageToMainThread( dwReturnValue, NULL );

	CoUninitialize();

	ATLTRACE(_T("# CConnectionToServer::DoWorkerThreadAction -- exiting\n"));


	return dwReturnValue;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\connecttoserverwizardpage1.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ConnectToServerWizardPage1.cpp

Abstract:

	Implementation file for the CConnectToServerWizardPage1 class.

	This is the wizard page that gets put up when the user adds this
	snapin into the console using the snapin manager.

	IMPORTANT NOTE:  If the user loads this snapin via a saved console
	(.msc) file, this wizard will never get called -- so don't do
	anything important to the snapin here.

Author:

    Michael A. Maguire 11/24/97

Revision History:
	mmaguire 11/24/97


--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ConnectToServerWizardPage1.h"
//
// where we can find declarations needed in this file:
//
#include "ServerNode.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CConnectToServerWizardPage1::CConnectToServerWizardPage1

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CConnectToServerWizardPage1::CConnectToServerWizardPage1( LONG_PTR hNotificationHandle, TCHAR* pTitle, BOOL bOwnsNotificationHandle)
						: CIASPropertyPage<CConnectToServerWizardPage1> ( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
	// Add the help button to the page
//	m_psp.dwFlags |= PSP_HASHELP;


	m_pServerNode = NULL;


}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectToServerWizardPage1::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CConnectToServerWizardPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE(_T("# CConnectToServerWizardPage1::OnInitDialog\n"));
	

	// Check for preconditions:
	// None.


	::SendMessage(GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);


	// ISSUE: We may need to read in from an MSC file whether we were
	// to use a local or a remote machine and what the name of that
	// machine was.  Then we should set those values here accordingly.

	SendDlgItemMessage( IDC_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER, BM_SETCHECK, TRUE, 0);

	SetLocalOrRemoteDependencies();

	return TRUE;	// ISSUE: what do we need to be returning here?
}




//////////////////////////////////////////////////////////////////////////////
/*++

CConnectToServerWizardPage1::OnWizardFinish

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:


--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CConnectToServerWizardPage1::OnWizardFinish()
{
	ATLTRACE(_T("# CConnectToServerWizardPage1::OnWizardFinish\n"));
	
	// Check for preconditions:
	_ASSERTE( NULL != m_pServerNode );


	CComBSTR bstrServerAddress;

	m_pServerNode->m_bConfigureLocal = SendDlgItemMessage( IDC_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER, BM_GETCHECK, 0, 0);

	if( ! m_pServerNode->m_bConfigureLocal )
	{
		// The user has chosen to configure a remote machine.

		// There should be no worry about this value getting clobbered
		// as no-one should have attempted to put anything into yet.
		BOOL bResult = GetDlgItemText( IDC_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME, (BSTR &) bstrServerAddress );
		if( ! bResult )
		{
			ShowErrorDialog( m_hWnd, IDS_ERROR__SERVER_ADDRESS_EMPTY );
			return FALSE;
		}

	}

	m_pServerNode->SetServerAddress( bstrServerAddress );

	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectToServerWizardPage1::OnLocalOrRemote


Remarks:

	Called when the user clicks on the Local or Remote radio button.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CConnectToServerWizardPage1::OnLocalOrRemote(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# CConnectToServerWizardPage1::OnLocalOrRemote\n"));

	// The Enable Logging button has been checked -- check dependencies.
	SetLocalOrRemoteDependencies();

	// This return value is ignored.
	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectToServerWizardPage1::SetLocalOrRemoteDependencies

Remarks:

	Utility to set state of items which may depend on whether the
	Local Computer or Remote computer radio button is checked.

	Call whenever something changes the state of IDC_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER.

--*/
//////////////////////////////////////////////////////////////////////////////
void CConnectToServerWizardPage1::SetLocalOrRemoteDependencies( void )
{
	ATLTRACE(_T("# CConnectToServerWizardPage1::SetLocalOrRemoteDependencies\n"));


	// Ascertain what the state of the IDC_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER radio button is.
	int iChecked = ::SendMessage( GetDlgItem( IDC_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER ), BM_GETCHECK, 0, 0 );

	if( iChecked )
	{
		// Make sure the correct items are disabled.
	
		::EnableWindow( GetDlgItem( IDC_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME ), FALSE );
	
	}
	else
	{
		// Make sure the correct items are enabled.

		::EnableWindow( GetDlgItem( IDC_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME ), TRUE );

	}

}



/////////////////////////////////////////////////////////////////////////////
/*++

CConnectToServerWizardPage1::GetHelpPath

Remarks:

	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help
	button of a property sheet.

	It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CConnectToServerWizardPage1::GetHelpPath( LPTSTR szHelpPath )
{
	ATLTRACE(_T("# CConnectToServerWizardPage1::GetHelpPath\n"));


	// Check for preconditions:



#ifdef UNICODE_HHCTRL
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("IDH_WIZPAGE_STARTUP_CONECT_TO_MACHINE.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "IDH_WIZPAGE_STARTUP_CONECT_TO_MACHINE.htm" );
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\connecttoserverwizardpage1.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ConnectToServerWizardPage1.h

Abstract:

	Header file for implementing the root node property page subnode.

	This is the wizard page that gets put up when the user adds this
	snapin into the console using the snapin manager.

	IMPORTANT NOTE:  If the user loads this snapin via a saved console
	(.msc) file, this wizard will never get called -- so don't do
	anything important to the snapin here.



Author:

    Michael A. Maguire 11/24/97

Revision History:
	mmaguire 11/24/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_CONNECT_TO_SERVER_WIZARD_PAGE1_H_)
#define _IAS_CONNECT_TO_SERVER_WIZARD_PAGE1_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CServerNode;

class CConnectToServerWizardPage1 : public CIASPropertyPage< CConnectToServerWizardPage1 >
{

public :

	CConnectToServerWizardPage1( LONG_PTR hNotificationHandle, TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );


	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_WIZPAGE_STARTUP_CONECT_TO_MACHINE };

	BEGIN_MSG_MAP(CConnectToServerWizardPage1)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDC_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER, OnLocalOrRemote )
		COMMAND_ID_HANDLER( IDC_RADIO_STARTUP_WIZARD_CONNECT__ANOTHER_COMPUTER, OnLocalOrRemote )
		CHAIN_MSG_MAP(CIASPropertyPage<CConnectToServerWizardPage1>)
	END_MSG_MAP()


	HRESULT GetHelpPath( LPTSTR szFilePath );


	BOOL OnWizardFinish();



	CServerNode * m_pServerNode;

private:

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnLocalOrRemote(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

							
	void SetLocalOrRemoteDependencies( void );


};

#endif // _IAS_CONNECT_TO_SERVER_WIZARD_PAGE1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\componentdata.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ComponentData.cpp

Abstract:

	Implementation file for the CComponentData class.

	The CComponentData class implements several interfaces which MMC uses:
	
	The IComponentData interface is basically how MMC talks to the snap-in
	to get it to implement the left-hand-side "scope" pane.  There is only one
	object implementing this interface instantiated -- it is best thought of as
	the main "document" on which the objects implementing the IComponent interface
	(see Component.cpp) are "views".

	The IExtendPropertySheet interface is how the snap-in adds property sheets
	for any of the items a user might click on.

	The IExtendContextMenu interface what we do to add custom entries
	to the menu which appears when a user right-clicks on a node.
	
	The IExtendControlBar interface allows us to support a custom
	iconic toolbar.

Note:

	Much of the functionality of this class is implemented in atlsnap.h
	by IComponentDataImpl.  We are mostly overriding here.


Author:

    Michael A. Maguire 11/6/97

Revision History:
	mmaguire 11/6/97	- created using MMC snap-in wizard
	mmaguire 11/24/97	- hurricaned for better project structure

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"


// server applications node guid definition
#include "compuuid.h"
//
// where we can find declaration for main class in this file:
//
#include "ComponentData.h"
//
// where we can find declarations needed in this file:
//
#include "ServerNode.h"
#include "ClientsNode.h"
#include "ClientNode.h"
#include "ChangeNotification.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::CComponentData

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData::CComponentData()
{
	ATLTRACE(_T("# +++ CComponentData::CComponentData\n"));
	

	// Check for preconditions:
	// None.


	// We pass our root node a pointer to this CComponentData.
	// In our case, the root node is CServerNode.
	// This is so that it and any of its children nodes have
	// access to our member variables and services,
	// and thus we have snapin-global data if we need it
	// using the GetComponentData function.
	m_pNode = new CServerNode( this );
	_ASSERTE(m_pNode != NULL);


	m_pComponentData = this;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::~CComponentData

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData::~CComponentData()
{
	ATLTRACE(_T("# --- CComponentData::~CComponentData\n"));
	

	// Check for preconditions:
	// None.


	delete m_pNode;
	m_pNode = NULL;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::Initialize

HRESULT Initialize(
  LPUNKNOWN pUnknown  // Pointer to console's IUnknown.
);

Called by MMC to initialize the IComponentData object.


Parameters

	pUnknown	[in] Pointer to the console's IUnknown interface. This interface
	pointer can be used to call QueryInterface for IConsole and IConsoleNameSpace.


Return Values

	S_OK	The component was successfully initialized.

	E_UNEXPECTED
	An unexpected error occurred.


Remarks

	IComponentData::Initialize is called when a snap-in is being created and has
	items in the scope pane to enumerate. The pointer to IConsole that is passed
	in is used to make QueryInterface calls to the console for interfaces such as
	IConsoleNamespace. The snap-in should also call IConsole::QueryScopeImageList
	to get the image list for the scope pane and add images to be displayed on
	the scope pane side.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::Initialize (LPUNKNOWN pUnknown)
{

	ATLTRACE(_T("# CComponentData::Initialize\n"));
		

	// Check for preconditions:
	// None.


	HRESULT hr = IComponentDataImpl<CComponentData, CComponent >::Initialize(pUnknown);
	if (FAILED(hr))
	{
		ATLTRACE(_T("# ***FAILED***: CComponentData::Initialize -- Base class initialization\n"));
		return hr;
	}


	// Check this should have been set in base class initialization above:
	_ASSERTE( m_spConsole != NULL );


	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("# ***FAILED***: IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list

	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_IASSNAPIN_16));
	if (hBitmap16 == NULL)
	{
		ATLTRACE(_T("# ***FAILED***: CComponentData::Initialize -- LoadBitmap\n"));

		//ISSUE: Will MMC still be able to function if this fails?
		return S_OK;
	}

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_IASSNAPIN_32));
	if (hBitmap32 == NULL)
	{
		ATLTRACE(_T("# ***FAILED***: CComponentData::Initialize -- LoadBitmap\n"));

		//ISSUE: Should we DeleteObject previous hBitmap16 since it was successfully loaded
		// but we failed here?
		
		//ISSUE: Will MMC still be able to function if this fails?
		return S_OK;
	}

	if (spImageList->ImageListSetStrip((LONG_PTR*)hBitmap16, (LONG_PTR*)hBitmap32, 0, RGB(255, 0, 255)) != S_OK)
	{
		ATLTRACE(_T("# ***FAILED***: CComponentData::Initialize  -- ImageListSetStrip\n"));
		return E_UNEXPECTED;
	}

	if ( hBitmap16 != NULL )
	{
      DeleteObject(hBitmap16);
   }

	if ( hBitmap32 != NULL )
	{
      DeleteObject(hBitmap32);
   }

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::CompareObjects

Needed so that IPropertySheetProvider::FindPropertySheet will work.

FindPropertySheet is used to bring a pre-existing property sheet to the foreground
so that we don't open multiple copies of Properties on the same node.

It requires CompareObjects to be implemented on both IComponent and IComponentData.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::CompareObjects(
		  LPDATAOBJECT lpDataObjectA
		, LPDATAOBJECT lpDataObjectB
		)
{
	ATLTRACE(_T("# CComponentData::CompareObjects\n"));
	

	// Check for preconditions:
	_ASSERTE( lpDataObjectA != NULL );
	_ASSERTE( lpDataObjectB != NULL );


	HRESULT hr;

	CSnapInItem *pDataA, *pDataB;
	DATA_OBJECT_TYPES typeA, typeB;

	hr = GetDataClass(lpDataObjectA, &pDataA, &typeA);
	if ( FAILED( hr ) )
	{
		return hr;
	}
	
	hr = GetDataClass(lpDataObjectB, &pDataB, &typeB);
	if ( FAILED( hr ) )
	{
		return hr;
	}

	if( pDataA == pDataB )
	{
		// They are the same object.
		return S_OK;
	}
	else
	{
		// They are different.
		return S_FALSE;
	}

}


///////////////////////////////
// CComponentData::OnExpand
///////////////////////////////

HRESULT CComponentData::AddRootNode(LPCWSTR machinename, HSCOPEITEM parent)
{
	CComPtr<IConsoleNameSpace> spNameSpace;
	HRESULT		hr = S_OK;

	// Try to create the children of this Machine node
	if( NULL == m_pNode )
	{
		m_pNode = new CServerNode( this );
	}

	if( NULL == m_pNode )
	{
		hr = E_OUTOFMEMORY;
			// Use MessageBox() rather than IConsole::MessageBox() here because the
			// first time this gets called m_ipConsole is not fully initialized
			// ISSUE: The above statement is probably not true for this node.
		::MessageBox( NULL, L"@Unable to allocate new nodes", L"CMachineNode::OnExpand", MB_OK );

		return(hr);
	}

	// But to get that, first we need IConsole

	if(!m_spConsole)
		return S_FALSE;
		
	hr = m_spConsole->QueryInterface(IID_IConsoleNameSpace, (void**)&spNameSpace);

	SCOPEDATAITEM	item;
	ZeroMemory(&item, sizeof(item));
	CServerNode* pServer = (CServerNode*)m_pNode;

	pServer->SetServerAddress(machinename);

	pServer->m_bstrDisplayName = CServerNode::m_szRootNodeBasicName;
	
	// This was done in MeanGene's Step 3 -- I'm guessing MMC wants this filled in
	pServer->m_scopeDataItem.relativeID = (HSCOPEITEM) parent;

// #ifndef	ALWAYS_SHOW_RAP_NODE
//		hr = TryShow(NULL);
// #else		
		hr = spNameSpace->InsertItem( &(pServer->m_scopeDataItem) );
		_ASSERT( NULL != pServer->m_scopeDataItem.ID );
//#endif

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::CreateComponent

We override the ATLsnap.h implementation so that we can save away our 'this'
pointer into the CComponent object we create.  This way the IComponent object
has knowledge of the CComponentData object to which it belongs.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
	ATLTRACE(_T("# CComponentData::CreateComponent\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(ppComponent != NULL);
	if (ppComponent == NULL)
		ATLTRACE(_T("# IComponentData::CreateComponent called with ppComponent == NULL\n"));
	else
	{
		*ppComponent = NULL;
		
		CComObject< CComponent >* pComponent;
		hr = CComObject< CComponent >::CreateInstance(&pComponent);
		ATLASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			ATLTRACE(_T("# IComponentData::CreateComponent : Could not create IComponent object\n"));
		else
		{
			hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
		
			pComponent->m_pComponentData = this;
		}
		
	}
	return hr;
}

//---------------------------------------------------------------------------
//  Extracts data based on the passed-in clipboard format

HRESULT ExtractMachineName( IDataObject* piDataObject, BSTR* 
pMachineName )
{
    
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; 
	FORMATETC formatetc = { CServerNode::m_CCF_MMC_SNAPIN_MACHINE_NAME, 
			NULL, 
			DVASPECT_CONTENT, 
			-1, 
			TYMED_HGLOBAL 
	}; 

	stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); 
	if (stgmedium.hGlobal == NULL) 
		return E_OUTOFMEMORY; 

	HRESULT hr = piDataObject->GetDataHere(&formatetc, &stgmedium); 
	if (FAILED(hr)) 
	{ 
		GlobalFree(stgmedium.hGlobal); 
		return hr; 
	} 

	*pMachineName = SysAllocString((OLECHAR*)stgmedium.hGlobal);

	GlobalFree(stgmedium.hGlobal); 
	hr = S_OK;
    
    return hr;
}


//---------------------------------------------------------------------------
//  Extracts data based on the passed-in clipboard format

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* 
pguidObjectType )
{
    
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; 
	FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, 
			NULL, 
			DVASPECT_CONTENT, 
			-1, 
			TYMED_HGLOBAL 
	}; 

	stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); 
	if (stgmedium.hGlobal == NULL) 
		return E_OUTOFMEMORY; 

	HRESULT hr = piDataObject->GetDataHere(&formatetc, &stgmedium); 
	if (FAILED(hr)) 
	{ 
		GlobalFree(stgmedium.hGlobal); 
		return hr; 
	} 

	memcpy(pguidObjectType, stgmedium.hGlobal, sizeof(GUID)); 

	GlobalFree(stgmedium.hGlobal); 
	hr = S_OK;
    
    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::Notify

Notifies the snap-in of actions taken by the user.

HRESULT Notify(
  LPDATAOBJECT lpDataObject,  // Pointer to a data object
  MMC_NOTIFY_TYPE event,      // Action taken by a user
  LPARAM arg,                 // Depends on event
  LPARAM param                // Depends on event
);


Parameters

	lpDataObject
	[in] Pointer to the data object of the currently selected item.

	event
	[in] Identifies an action taken by a user. IComponent::Notify can receive the
	following notifications:

		MMCN_ACTIVATE
		MMCN_ADD_IMAGES
		MMCN_BTN_CLICK
		MMCN_CLICK
		MMCN_DBLCLICK
		MMCN_DELETE
		MMCN_EXPAND
		MMCN_MINIMIZED
		MMCN_PROPERTY_CHANGE
		MMCN_REMOVE_CHILDREN
		MMCN_RENAME
		MMCN_SELECT
		MMCN_SHOW
		MMCN_VIEW_CHANGE

	All of which are forwarded to each node's Notify method, as well as:

		MMCN_COLUMN_CLICK
		MMCN_SNAPINHELP

	Which are handled here.


	arg
	Depends on the notification type.

	param
	Depends on the notification type.


Return Values

	S_OK
	Depends on the notification type.

	E_UNEXPECTED
	An unexpected error occurred.


Remarks

	We are overiding the ATLsnap.h implementation of IComponentImpl because
	it always returns E_UNEXPECTED when lpDataObject == NULL.
	Unfortunately, some valid message (e.g. MMCN_SNAPINHELP and MMCN_COLUMN_CLICK)
	pass in lpDataObject = NULL	by design.

	Also, there seems to be some problem with Sridhar's latest
	IComponentImpl::Notify method, because it causes MMC to run-time error.


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::Notify (
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
{
	ATLTRACE(_T("# CComponentData::Notify\n"));


	// Check for preconditions:
	// None.

	HRESULT hr;

	// check if this is an extension
	if (event == MMCN_EXPAND)
	{

			GUID myGuid;
			GUID* pGUID= &myGuid;
			// extract GUID of the the currently selected node type from the data object
			hr = ExtractObjectTypeGUID(lpDataObject, pGUID);
			_ASSERT( S_OK == hr );    


			// compare node type GUIDs of currently selected node and the node type 
			// we want to extend. If they are are equal, currently selected node
			// is the type we want to extend, so we add our items underneath it
			GUID	ServerAppsGuid = structuuidNodetypeServerApps;
			if (IsEqualGUID(*pGUID, ServerAppsGuid))
			{
				BOOL bIASInstalled = FALSE;
				BSTR MachineName = NULL;

				ExtractMachineName(lpDataObject, &MachineName);

				// get computer name
				hr = IfServiceInstalled(MachineName, _T("IAS"), &bIASInstalled);
				if(bIASInstalled)
					AddRootNode(MachineName, (HSCOPEITEM)param);
			}
	}
	

	// lpDataObject should be a pointer to a node object.
	// If it is NULL, then we are being notified of an event
	// which doesn't pertain to any specific node.

	if ( NULL == lpDataObject )
	{
		// respond to events which have no associated lpDataObject

		switch( event )
		{
		case MMCN_PROPERTY_CHANGE:
			hr = OnPropertyChange( arg, param );
			break;

//		case MMCN_VIEW_CHANGE:
//			hr = OnViewChange( arg, param );
//			break;

		default:
			ATLTRACE(_T("# CComponent::Notify - called with lpDataObject == NULL and no event handler\n"));
			hr = E_NOTIMPL;
			break;
		}
		return hr;
	}

	// We were passed a LPDATAOBJECT which corresponds to a node.
	// We convert this to the ATL ISnapInDataInterface pointer.
	// This is done in GetDataClass (a static method of ISnapInDataInterface)
	// by asking the dataobject via a supported clipboard format (CCF_GETCOOKIE)
	// to write out a pointer to itself on a stream and then
	// casting this value to a pointer.
	// We then call the Notify method on that object, letting
	// the node object deal with the Notify event itself.

	CSnapInItem* pItem = NULL;
	DATA_OBJECT_TYPES type;
	hr = m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
	
	ATLASSERT(SUCCEEDED(hr));
	
	if (SUCCEEDED(hr))
	{
		hr = pItem->Notify( event, arg, param, this, NULL, type );
	}

	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::OnPropertyChange

HRESULT OnPropertyChange(	
			  LPARAM arg
			, LPARAM param
			)

This is where we respond to an MMCN_PROPERTY_CHANGE notification.

This notification is sent when we call MMCPropertyChangeNotify.
We call this in our property pages when changes are made to the data
they contain and we may need to update of view of the data.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentData::OnPropertyChange(	
			  LPARAM arg
			, LPARAM param
			)
{
	ATLTRACE(_T("# CComponentData::OnPropertyChange\n"));


	// Check for preconditions:
	_ASSERTE( m_spConsole != NULL );

	
	HRESULT hr = S_FALSE;

	if( param )
	{

		// We were passed a pointer to a CChangeNotification in the param argument.

		CChangeNotification * pChangeNotification = (CChangeNotification *) param;

		
		// We call notify on the node specified, passing it our own custom event type
		// so that it knows that it must refresh its data.


		// Call notify on this node with the MMCN_PROPERTY_CHANGE notification.
		// We had to use this trick because of the fact that we are using template
		// classes and so we have no common object among all our nodes
		// other than CSnapInItem.  But we can't change CSnapInItem
		// so instead we use the notify method it already has with a new
		// notification.
		
		// Note:  We are trying to deal gracefully here with the fact that the
		// MMCN_PROPERTY_CHANGE notification doesn't pass us an lpDataObject
		// so we have to have our own protocol for picking out which node
		// needs to update itself.
		
		hr = pChangeNotification->m_pNode->Notify( MMCN_PROPERTY_CHANGE
							, NULL
							, NULL
							, NULL
							, NULL
							, (DATA_OBJECT_TYPES) 0
							);

		// We want to make sure all views with this node select also get updated.
		// Pass it the CChangeNotification pointer we were passed in param.
		hr = m_spConsole->UpdateAllViews( NULL, param, 0);

		pChangeNotification->Release();
	
	
	}

	return hr;


}



//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::GetHelpTopic

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::GetHelpTopic( LPOLESTR * lpCompiledHelpFile )
{
	ATLTRACE(_T("CComponentData::GetHelpTopic\n"));

	// Check for preconditions.
	_ASSERTE( lpCompiledHelpFile != NULL );

	if( ! lpCompiledHelpFile )
	{
		return E_INVALIDARG;
	}

	WCHAR szTemp[IAS_MAX_STRING*2];

	// Use system API to get windows directory.
	UINT uiResult = GetWindowsDirectory( szTemp, IAS_MAX_STRING );
	if( uiResult <=0 || uiResult > IAS_MAX_STRING )
	{
		return E_FAIL;
	}

	WCHAR *szTempAfterWindowsDirectory = szTemp + lstrlen(szTemp);

	// Load path under windows system directory to help file.
	// Note: IDS_HTMLHELP_PATH = "\help\iasmmc.chm".  If the "help" directory is localized
	// on a localized machine, the path to the file can be changed in our resources
	// e.g. to something like "\hilfe\iasmmc.chm" on German.
	int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_HTMLHELP_PATH, szTempAfterWindowsDirectory, IAS_MAX_STRING );
	if( nLoadStringResult <= 0 )
	{
		return E_FAIL;
	}


	// Try to allocate the buffer.
	*lpCompiledHelpFile = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(szTemp)+1) );
	if( ! *lpCompiledHelpFile )
	{
		return E_OUTOFMEMORY;
	}

	// Copy the string to the allocated memory.
	if( NULL == lstrcpy( *lpCompiledHelpFile, szTemp) )
	{
		// Need to clean up a bit.
		CoTaskMemFree( *lpCompiledHelpFile );
		return E_FAIL;
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::GetClassID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::GetClassID(CLSID* pClassID)
{
	ATLTRACE(_T("CComponentData::GetClassID\n"));
	_ASSERTE( pClassID != NULL );

	*pClassID = CLSID_IASSnapin;
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::IsDirty

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::IsDirty()
{
	ATLTRACE(_T("CComponentData::IsDirty\n"));

	// We just return S_OK because we're always dirty.
	// We always want to save the computer name and flags
	return S_OK;
}




//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::Load

Load the name of the machine we were connected to when this console was saved.


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::Load(IStream* pStream)
{
	ATLTRACE(_T("ComponentData::Load"));

	
	_ASSERTE( pStream != NULL );
	if( m_pNode == NULL )
	{
		return S_FALSE;
	}

	HRESULT hr = S_OK;
	do
	{

		// Read size of string.
		size_t len = 0;
		hr = pStream->Read(&len, sizeof(len), 0);
		if( FAILED( hr ) )
		{
			break;
		}


		if( len > IAS_MAX_COMPUTERNAME_LENGTH )
		{
			// Something's wrong -- the string stored should be no
			// longer than IAS_MAX_COMPUTERNAME_LENGTH.
			break;
		}


		// Read string provided we had saved more than just the NULL terminator.
		if (--len)
		{
			OLECHAR szName[IAS_MAX_COMPUTERNAME_LENGTH];
			hr =
			pStream->Read(
						 szName
						, len * sizeof(OLECHAR)
						, 0
						);
			if( FAILED( hr ) )
			{
				break;
			}

			// NULL terminate the string.
			szName[len] = 0;

			((CServerNode *) m_pNode)->m_bstrServerAddress = szName;
			
			((CServerNode *) m_pNode)->m_bConfigureLocal = FALSE;

		}
		else
		{
			((CServerNode *) m_pNode)->m_bConfigureLocal = TRUE;
		}

		// Null terminator.
		OLECHAR c;
		hr = pStream->Read(&c, sizeof(OLECHAR), 0);
		_ASSERTE( c == 0 );
	}
	while (0);

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::Save

Save the name of the machine we are connected to so that it can be loaded later.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::Save(IStream* pStream, BOOL /* clearDirty */)
{
	ATLTRACE(_T("CComponentData::Save"));


	// Check for preconditions:
	_ASSERTE( pStream != NULL );
	if( m_pNode == NULL )
	{
		return S_FALSE;
	}


	HRESULT hr = S_OK;


	do
	{
		size_t len;
		
		// We will save the length of the string as the first item in the stream.
		if( ((CServerNode *) m_pNode)->m_bstrServerAddress == NULL )
		{
			// No string pointer, so just the NULL terminator.
			len = 1;
		}
		else
		{
			// Length of computer name, plus space for NULL terminator.
			len = lstrlen( ((CServerNode *) m_pNode)->m_bstrServerAddress ) + 1;
		}
		hr = pStream->Write(&len, sizeof(len), 0);
		if( FAILED( hr ) )
		{
			break;
		}

		// Write the actual string, taking into account that we added one above.
		if (--len)
		{
			hr = pStream->Write(
							  ((CServerNode *) m_pNode)->m_bstrServerAddress
							, len * sizeof(OLECHAR)
							, 0
							);
			if( FAILED( hr ) )
			{
				break;
			}
		}

		// Write a null terminator
		OLECHAR c = 0;
		hr = pStream->Write(&c, sizeof(OLECHAR), 0);
	}
	while (0);

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::GetSizeMax

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::GetSizeMax(ULARGE_INTEGER* size)
{
	ATLTRACE(_T("ComponentData::GetSizeMax\n"));

	size->HighPart = 0;
	size->LowPart =
	     sizeof(size_t)    // computer name length, incl null terminator
	  +  sizeof(OLECHAR) * (IAS_MAX_COMPUTERNAME_LENGTH);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\globals.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    Globals.h

Abstract:

   Header file with common declarations


Author:

    Michael A. Maguire 12/03/97

Revision History:
   mmaguire 12/03/97 - created

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_GLOBALS_H_)
#define _IAS_GLOBALS_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this file needs:
//
// Moved to Precompiled.h: #include <atlsnap.h>
#include "resource.h"
#include "IASMMC.h"
#include "dns.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

// ISSUE: I don't know what the appropriate length should be here -- perhaps MMC imposes a limit somehow?
#define IAS_MAX_STRING MAX_PATH

extern unsigned int CF_MMC_NodeID;

// Note: We can't just use MAX_COMPUTERNAME_LENGTH anymore because this is 15 characters
// wide and now, with Active Directory, people can enter full DNS names that are much longer
#define IAS_MAX_COMPUTERNAME_LENGTH (DNS_MAX_NAME_LENGTH + 3)

// These are the icon indices within the bitmaps we pass in for IComponentData::Initialize
#define IDBI_NODE_SERVER_OK_OPEN       0
#define IDBI_NODE_SERVER_OK_CLOSED        1
#define IDBI_NODE_CLIENTS_OPEN            2
#define IDBI_NODE_CLIENTS_CLOSED       3
#define IDBI_NODE_LOGGING_METHODS_OPEN    4
#define IDBI_NODE_LOGGING_METHODS_CLOSED  5
#define IDBI_NODE_SERVER_BUSY_OPEN        6
#define IDBI_NODE_SERVER_BUSY_CLOSED      7
#define IDBI_NODE_CLIENT               8
#define IDBI_NODE_LOCAL_FILE_LOGGING      9
#define IDBI_NODE_SERVER_ERROR_OPEN       10
#define IDBI_NODE_SERVER_ERROR_CLOSED     11

// ISSUE: We may need to change this later to use a variable 
// which can read in (perhaps from registry?) the location of these files
// as they may be found in a different place depending on where the user 
// chose to install them

#define CLIENT_HELP_INDEX 1

#define HELPFILE_NAME TEXT("iasmmc.hlp")

#ifdef UNICODE_HHCTRL
// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
// installed on this machine -- it appears to be non-unicode.
#define HTMLHELP_NAME TEXT("iasmmc.chm")
#else
#define HTMLHELP_NAME "iasmmc.chm"
#endif


#endif // _IAS_GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\helpconstants.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       helpconstants.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\iashlp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       iashlp.cpp
//
//--------------------------------------------------------------------------

#include "Precompiled.h"
#include "iashlp.h"
#include "hlptable.h"
#include "cnctdlg.cpp"
#include "dlgcshlp.cpp"

const CGlobalHelpTable __pGlobalCSHelpTable[] =
{
	DLG_HELP_ENTRY(IDD_PROPPAGE_SERVER3),
	DLG_HELP_ENTRY(IDD_REPLACE_REALMS),
	DLG_HELP_ENTRY(IDD_ADD_CLIENT),
	DLG_HELP_ENTRY(IDD_PROPPAGE_CLIENT1),
	DLG_HELP_ENTRY(IDD_PROPPAGE_SERVER1),
	DLG_HELP_ENTRY(IDD_PROPPAGE_SERVER2),
	DLG_HELP_ENTRY(IDD_RESOLVE_DNS_NAME),
	DLG_HELP_ENTRY(IDD_WIZPAGE_ADD_CLIENT1),
	DLG_HELP_ENTRY(IDD_WIZPAGE_ADD_CLIENT2),
	DLG_HELP_ENTRY(IDD_WIZPAGE_STARTUP_CONECT_TO_MACHINE),
	{0,0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\precompiled.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       precompiled.cpp
//
//--------------------------------------------------------------------------

// Precompiled.cpp : source file that includes just the standard includes
//  Precompiled.pch will be the pre-compiled header
//  Precompiled.obj will contain the pre-compiled type information

#include "Precompiled.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\iasmmcdll.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    IASMMCDLL.cpp

Abstract:

	Implementation of DLL Exports.

Proxy/Stub Information:

	To build a separate proxy/stub DLL, 
	run nmake -f IASMMCps.mk in the project directory.

Author:

    Michael A. Maguire 11/6/97

Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//

//
// where we can find declarations needed in this file:
//
#include "initguid.h"
#include "IASMMC.h"
#include "IASMMC_i.c"
#include "ComponentData.h"
#include "About.h"
#include "ClientNode.h"
#include "ServerNode.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

unsigned int CF_MMC_NodeID = RegisterClipboardFormatW(CCF_NODEID2);


CComModule _Module;



BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_IASSnapin, CComponentData)
	OBJECT_ENTRY(CLSID_IASSnapinAbout, CSnapinAbout)
END_OBJECT_MAP()



#if 1  // Use CWinApp for MFC support -- some of the COM objects in this dll use MFC.



class CIASMMCApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CIASMMCApp theApp;

//////////////////////////////////////////////////////////////////////////////
/*++

CNAPMMCApp::InitInstance

	MFC's dll entry point.
	
--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CIASMMCApp::InitInstance()
{
		_Module.Init(ObjectMap, m_hInstance);
		// Initialize static class variables of CSnapInItem.
		CSnapInItem::Init();

		// Initialize any other static class variables.
		CServerNode::InitClipboardFormat();
		CClientNode::InitClipboardFormat();

		DisableThreadLibraryCalls(m_hInstance);

	return CWinApp::InitInstance();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNAPMMCApp::ExitInstance

	MFC's dll exit point.
	
--*/
//////////////////////////////////////////////////////////////////////////////
int CIASMMCApp::ExitInstance()
{
	_Module.Term();

	return CWinApp::ExitInstance();
}



#else // Use CWinApp




//////////////////////////////////////////////////////////////////////////////
/*++

	DllMain


	Remarks
		
		DLL Entry Point
	
--*/
//////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	ATLTRACE(_T("# DllMain\n"));
	

	// Check for preconditions:
	// None.	


	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		 AfxSetResourceHandle(hInstance);
		// Initialize static class variables of CSnapInItem.
		CSnapInItem::Init();

		// Initialize any other static class variables.
		CServerNode::InitClipboardFormat();
		CClientNode::InitClipboardFormat();

		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

#endif	// if 1

//////////////////////////////////////////////////////////////////////////////
/*++

	DllCanUnloadNow


	Remarks
		
		Used to determine whether the DLL can be unloaded by OLE

--*/
//////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow(void)
{
	ATLTRACE(_T("# DllCanUnloadNow\n"));
		

	// Check for preconditions:
	// None.


	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

	DllGetClassObject


	Remarks
		
		Returns a class factory to create an object of the requested type

--*/
//////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	ATLTRACE(_T("# DllGetClassObject\n"));
		

	// Check for preconditions:
	// None.


	return _Module.GetClassObject(rclsid, riid, ppv);
}



//////////////////////////////////////////////////////////////////////////////
/*++

	DllRegisterServer


	Remarks
		
		  Adds entries to the system registry

--*/
//////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer(void)
{
	ATLTRACE(_T("# DllRegisterServer\n"));

	TCHAR	ModuleName[MAX_PATH];

	GetModuleFileNameOnly(_Module.GetModuleInstance(), ModuleName, MAX_PATH);

	// Set the protocol.
	TCHAR IASName[IAS_MAX_STRING];
	TCHAR IASName_Indirect[IAS_MAX_STRING];
	int iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_SNAPINNAME_IAS, IASName, IAS_MAX_STRING );
	swprintf(IASName_Indirect, L"@%s,-%-d", ModuleName, IDS_SNAPINNAME_IAS);
	
    struct _ATL_REGMAP_ENTRY regMap[] = {
        {OLESTR("IASSNAPIN"), IASName}, // subsitute %IASSNAPIN% for registry
        {OLESTR("IASSNAPIN_INDIRECT"), IASName_Indirect}, // subsitute %IASSNAPIN% for registry
        {0, 0}
    };
    
    HRESULT hr = _Module.UpdateRegistryFromResource(IDR_IASSNAPIN, TRUE, regMap);

    _Module.RegisterServer(TRUE);

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

	DllUnregisterServer


	Remarks
		
		Removes entries from the system registry

--*/
//////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
	ATLTRACE(_T("# DllUnregisterServer\n"));
	

	// Set the protocol.
	TCHAR IASName[IAS_MAX_STRING];
	int iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_SNAPINNAME_IAS, IASName, IAS_MAX_STRING );

	
    struct _ATL_REGMAP_ENTRY regMap[] = {
        {OLESTR("IASSNAPIN"), IASName}, // subsitute %IASSNAPIN% for registry
        {0, 0}
    };
    
    _Module.UpdateRegistryFromResource(IDR_IASSNAPIN, FALSE, regMap);
    _Module.UnregisterServer();

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\iashlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       iashlp.h
//
//--------------------------------------------------------------------------

#define	IDH_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT	800010052
#define	IDH_BUTTON_CLIENT_PAGE1__FIND	800010077
#define	IDH_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE	800010134
#define	IDH_BUTTON_REALMS_ADD	800010003
#define	IDH_BUTTON_REALMS_EDIT	800010005
#define	IDH_BUTTON_REALMS_MOVE_DOWN	800010002
#define	IDH_BUTTON_REALMS_MOVE_UP	800010001
#define	IDH_BUTTON_REALMS_REMOVE	800010004
#define	IDH_BUTTON_RESOLVE_DNS_NAME__RESOLVE	800010201
#define	IDH_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS	800010079
#define	IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__ACCOUNTING	800010100
#define	IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__AUTHENTICATION	800010101
#define	IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__INTERIM_ACCT	800010102
#define	IDH_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKETS	800010152
#define	IDH_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS	800010151
#define	IDH_COMBO_ADD_CLIENT__PROTOCOL	800010051
#define	IDH_COMBO_CLIENT_PAGE1__MANUFACTURER	800010078
#define	IDH_COMBO_RESOLVE_DNS_NAME__RESULT	800010202
#define	IDH_EDIT_ADD_CLIENT__NAME	800010050
#define	IDH_EDIT_CLIENT_PAGE1__ADDRESS	800010076
#define	IDH_EDIT_CLIENT_PAGE1__NAME	800010075
#define	IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET	800010080
#define	IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM	800010081
#define	IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__DIRECTORY	800010133
#define	IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE	800010132
#define	IDH_EDIT_REALMS_FIND	800010025
#define	IDH_EDIT_REALMS_REPLACE	800010026
#define	IDH_EDIT_RESOLVE_DNS_NAME__DNS_NAME	800010200
#define	IDH_EDIT_SERVER_PAGE1__NAME	800010150
#define	IDH_EDIT_SERVER_PAGE2_ACCOUNTING_PORT	800010176
#define	IDH_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT	800010175
#define	IDH_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME	800010277
#define	IDH_LIST_REALMS_REPLACEMENTS	800010000
#define	IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY	800010127
#define	IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1	800010126
#define	IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC	800010125
#define	IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__LOG_LIMIT	800010131
#define	IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY	800010129
#define	IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED	800010130
#define	IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY	800010128
#define	IDH_RADIO_STARTUP_WIZARD_CONNECT__ANOTHER_COMPUTER	800010276
#define	IDH_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER	800010275

#define IDH_BUTTON_RESOLVE_DNS_NAME__USE_THIS_IP 900000000

const DWORD g_aHelpIDs_IDD_PROPPAGE_SERVER3[]=
{
	IDC_LIST_REALMS_REPLACEMENTS,IDH_LIST_REALMS_REPLACEMENTS,
	IDC_BUTTON_REALMS_MOVE_UP,IDH_BUTTON_REALMS_MOVE_UP,
	IDC_BUTTON_REALMS_MOVE_DOWN,IDH_BUTTON_REALMS_MOVE_DOWN,
	IDC_BUTTON_REALMS_ADD,IDH_BUTTON_REALMS_ADD,
	IDC_BUTTON_REALMS_REMOVE,IDH_BUTTON_REALMS_REMOVE,
	IDC_BUTTON_REALMS_EDIT,IDH_BUTTON_REALMS_EDIT,
	0,0
};


const DWORD g_aHelpIDs_IDD_REPLACE_REALMS[]=
{
	IDC_EDIT_REALMS_FIND,IDH_EDIT_REALMS_FIND,
	IDC_EDIT_REALMS_REPLACE,IDH_EDIT_REALMS_REPLACE,
	0,0
};

const DWORD g_aHelpIDs_IDD_ADD_CLIENT[]=
{
	IDC_EDIT_ADD_CLIENT__NAME,IDH_EDIT_ADD_CLIENT__NAME,
	IDC_COMBO_ADD_CLIENT__PROTOCOL,IDH_COMBO_ADD_CLIENT__PROTOCOL,
	IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT,IDH_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT,
	0,0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_CLIENT1[]=
{
	IDC_EDIT_CLIENT_PAGE1__NAME,IDH_EDIT_CLIENT_PAGE1__NAME,
	IDC_EDIT_CLIENT_PAGE1__ADDRESS,IDH_EDIT_CLIENT_PAGE1__ADDRESS,
	IDC_BUTTON_CLIENT_PAGE1__FIND,IDH_BUTTON_CLIENT_PAGE1__FIND,
	IDC_COMBO_CLIENT_PAGE1__MANUFACTURER,IDH_COMBO_CLIENT_PAGE1__MANUFACTURER,
	IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE,IDH_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS,
	IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET,IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET,
	IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM,IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM,
	0,0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_LOCAL_FILE_LOGGING1[]=
{
	IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS,IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__ACCOUNTING,
	IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS,IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__AUTHENTICATION,
	IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS,IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__INTERIM_ACCT,
	0,0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_LOCAL_FILE_LOGGING2[]=
{
	IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC,
	IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1,
	IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY,
	IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY,
	IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY,
	IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED,
	IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__LOG_LIMIT,
	IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE,IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE,
	IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY,IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__DIRECTORY,
	IDC_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE,IDH_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE,
	0,0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_SERVER1[]=
{
	IDC_EDIT_SERVER_PAGE1__NAME,IDH_EDIT_SERVER_PAGE1__NAME,
	IDC_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS,IDH_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS,
	IDC_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKETS,IDH_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKETS,
	0,0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_SERVER2[]=
{
	IDC_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT,IDH_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT,
	IDC_EDIT_SERVER_PAGE2_ACCOUNTING_PORT,IDH_EDIT_SERVER_PAGE2_ACCOUNTING_PORT,
	0,0
};

const DWORD g_aHelpIDs_IDD_RESOLVE_DNS_NAME[]=
{
	IDC_EDIT_RESOLVE_DNS_NAME__DNS_NAME,IDH_EDIT_RESOLVE_DNS_NAME__DNS_NAME,
	IDC_BUTTON_RESOLVE_DNS_NAME__RESOLVE,IDH_BUTTON_RESOLVE_DNS_NAME__RESOLVE,
	IDC_COMBO_RESOLVE_DNS_NAME__RESULT,IDH_COMBO_RESOLVE_DNS_NAME__RESULT,
	IDOK, IDH_BUTTON_RESOLVE_DNS_NAME__USE_THIS_IP ,
	0,0
};

const DWORD g_aHelpIDs_IDD_WIZPAGE_ADD_CLIENT1[]=
{
	IDC_EDIT_ADD_CLIENT__NAME,IDH_EDIT_ADD_CLIENT__NAME,
	IDC_COMBO_ADD_CLIENT__PROTOCOL,IDH_COMBO_ADD_CLIENT__PROTOCOL,
	0,0
};

const DWORD g_aHelpIDs_IDD_WIZPAGE_ADD_CLIENT2[]=
{
	IDC_EDIT_CLIENT_PAGE1__ADDRESS,IDH_EDIT_CLIENT_PAGE1__ADDRESS,
	IDC_BUTTON_CLIENT_PAGE1__FIND,IDH_BUTTON_CLIENT_PAGE1__FIND,
	IDC_COMBO_CLIENT_PAGE1__MANUFACTURER,IDH_COMBO_CLIENT_PAGE1__MANUFACTURER,
	IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE,IDH_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS,
	IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET,IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET,
	IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM,IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM,
	0,0
};

const DWORD g_aHelpIDs_IDD_WIZPAGE_STARTUP_CONECT_TO_MACHINE[]=
{
	IDC_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER,IDH_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER,
	IDC_RADIO_STARTUP_WIZARD_CONNECT__ANOTHER_COMPUTER,IDH_RADIO_STARTUP_WIZARD_CONNECT__ANOTHER_COMPUTER,
	IDC_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME,IDH_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME,
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\realmdialog.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	RealmDialog.cpp

Abstract:

	Implementation file for the CRealmDialog class.

Author:

    Michael A. Maguire 01/15/98

Revision History:
	mmaguire 01/15/98 - created
	sbens    01/25/00 - use winsock2


--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "RealmDialog.h"
//
// where we can find declarations needed in this file:
//
#include <winsock2.h>
#include <stdio.h>
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CRealmDialog::CRealmDialog

--*/
//////////////////////////////////////////////////////////////////////////////
CRealmDialog::CRealmDialog()
{
	ATLTRACE(_T("# +++ RealmDialogDialog::RealmDialogDialog\n"));


	// Check for preconditions:

}




//////////////////////////////////////////////////////////////////////////////
/*++

CRealmDialog::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CRealmDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE(_T("# CRealmDialog::OnInitDialog\n"));


	SetDlgItemText(IDC_EDIT_REALMS_FIND, (LPCTSTR) m_bstrFindText );

	SetDlgItemText(IDC_EDIT_REALMS_REPLACE, (LPCTSTR) m_bstrReplaceText );


	return TRUE;	// ISSUE: what do we need to be returning here?
}





//////////////////////////////////////////////////////////////////////////////
/*++

CRealmDialog::OnOK

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CRealmDialog::OnOK(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# RealmDialogDialog::OnOK\n"));

	BOOL bResult;

	bResult = GetDlgItemText( IDC_EDIT_REALMS_FIND, (BSTR &) m_bstrFindText );
	if( ! bResult )
	{
		// We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
		m_bstrFindText = _T("");
	}

	if( wcslen( m_bstrFindText ) == 0 )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR_REALM_FIND_CANT_BE_EMPTY );
		return 0;
	}

	bResult = GetDlgItemText( IDC_EDIT_REALMS_REPLACE, (BSTR &) m_bstrReplaceText );
	if( ! bResult )
	{
		// We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
		m_bstrReplaceText = _T("");
	}


	EndDialog(TRUE);

	return 0;


}



//////////////////////////////////////////////////////////////////////////////
/*++

CRealmDialog::OnCancel

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CRealmDialog::OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# RealmDialogDialog::OnCancel\n"));


	// Check for preconditions:



	EndDialog(FALSE);

	return 0;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CRealmDialog::GetHelpPath

Remarks:

	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help
	button of a property sheet.

	It is an override of CIASDialog::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CRealmDialog::GetHelpPath( LPTSTR szHelpPath )
{
	ATLTRACE(_T("# CRealmDialog::GetHelpPath\n"));


	// Check for preconditions:



#if 0
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("html/idh_proc_realm_add.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "html/idh_proc_realm_add.htm" );
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\precompiled.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       precompiled.h
//
//--------------------------------------------------------------------------

// Precompiled.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__32A4883A_5713_11D1_9551_0060B0576642__INCLUDED_)
#define AFX_STDAFX_H__32A4883A_5713_11D1_9551_0060B0576642__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

// Define this if you don't want taskpad support
#define NO_TASKPAD


// We don't want our wizards to be wizard97 style for now.
#define NOWIZARD97


// Define this if you want new clients added via a wizard.
#define ADD_CLIENT_WIZARD

#define UNICODE_HHCTRL

#define _ATL_APARTMENT_THREADED

// Don't know why yet, but we lose context menus if this is not set to 0x0400 instead of 0x0500
///#define _WIN32_WINNT 0x0400

// Needed for COleSafeArray in serverpage3.cpp.
// This needs to be included before windows.h.
#include <afxdisp.h>


#ifdef BUILDING_IN_DEVSTUDIO
#else
#include <windows.h>
#include <shellapi.h>
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#include <htmlhelp.h>
#include <oledberr.h>

#if __RPCNDR_H_VERSION__ < 440             // This may be needed when building
#define __RPCNDR_H_VERSION__ 440           // on NT5 (1671) to prevent MIDL errors
#define MIDL_INTERFACE(x) interface
#endif

#ifndef ATLASSERT
#define ATLASSERT	_ASSERTE
#endif // ATLASSERT

#include <atlsnap.h>

#include "sdoias.h"
#include "iascomp.h"

#include "Globals.h"

#include "MMCUtility.h"
#include "SdoHelperFuncs.h"


// ISSUE:  Should start using this once integrated into build environment.
//#include "iasdebug.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__32A4883A_5713_11D1_9551_0060B0576642__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\nodetypeguids.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    IASSnapin.cpp

Abstract:

	Contains GUIDs and static member variable initializations

Author:

    Michael A. Maguire 11/6/97

Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//

//
// where we can find declarations needed in this file:
//
#include "ServerNode.h"
#include "ClientsNode.h"
#include "ClientNode.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//static const GUID CRootNodeGUID_NODETYPE = 
//{ 0x8f8f8dc2, 0x5713, 0x11d1, { 0x95, 0x51, 0x0, 0x60, 0xb0, 0x57, 0x66, 0x42 } };
//const GUID*  CRootNode::m_NODETYPE = &CRootNodeGUID_NODETYPE;
//const TCHAR* CRootNode::m_SZNODETYPE = _T("8F8F8DC2-5713-11D1-9551-0060B0576642");
//const TCHAR* CRootNode::m_SZDISPLAY_NAME = _T("@CIASSnapinRoot");
//const CLSID* CRootNode::m_SNAPIN_CLASSID = &CLSID_IASSnapin;

static const GUID CServerNodeGUID_NODETYPE = 
{ 0x2bbe102, 0x6c29, 0x11d1, { 0x95, 0x63, 0x0, 0x60, 0xb0, 0x57, 0x66, 0x42 } };
const GUID*  CServerNode::m_NODETYPE = &CServerNodeGUID_NODETYPE;
const TCHAR* CServerNode::m_SZNODETYPE = _T("02BBE102-6C29-11d1-9563-0060B0576642");
//const TCHAR* CServerNode::m_SZDISPLAY_NAME = _T("@CIASSnapinRoot");
const CLSID* CServerNode::m_SNAPIN_CLASSID = &CLSID_IASSnapin;

static const GUID CClientsNodeGUID_NODETYPE = 
{ 0x87580048, 0x611c, 0x11d1, { 0x95, 0x5a, 0x0, 0x60, 0xb0, 0x57, 0x66, 0x42 } };
const GUID*  CClientsNode::m_NODETYPE = &CClientsNodeGUID_NODETYPE;
const TCHAR* CClientsNode::m_SZNODETYPE = _T("87580048-611C-11d1-955A-0060B0576642");
//const TCHAR* CClientsNode::m_SZDISPLAY_NAME = _T("@CClients");
const CLSID* CClientsNode::m_SNAPIN_CLASSID = &CLSID_IASSnapin;

static const GUID CClientNodeGUID_NODETYPE = 
{ 0xa218ef76, 0x6137, 0x11d1, { 0x95, 0x5a, 0x0, 0x60, 0xb0, 0x57, 0x66, 0x42 } };
const GUID*  CClientNode::m_NODETYPE = &CClientNodeGUID_NODETYPE;
const TCHAR* CClientNode::m_SZNODETYPE = _T("A218EF76-6137-11d1-955A-0060B0576642");
//const TCHAR* CClientNode::m_SZDISPLAY_NAME = _T("@CClient");
const CLSID* CClientNode::m_SNAPIN_CLASSID = &CLSID_IASSnapin;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\realmdialog.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	RealmDialog.h

Abstract:

	Header file for the CRealmDialog class.

	See CRealmDialog.cpp for implementation.

Author:

    Michael A. Maguire 01/15/98

Revision History:
	mmaguire 01/15/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_REALM_DIALOG_H_)
#define _IAS_REALM_DIALOG_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "Dialog.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


// We set second template parameter to false because we don't want this
// class to auto-delete itself when it's window is destroyed.

class CRealmDialog;

typedef CIASDialog<CRealmDialog, FALSE> CREALMDIALOG;


class CRealmDialog : public CREALMDIALOG
{

public:

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of 
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_REPLACE_REALMS };

	BEGIN_MSG_MAP(CRealmDialog)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDOK, OnOK )
		COMMAND_ID_HANDLER( IDCANCEL, OnCancel )
		CHAIN_MSG_MAP( CREALMDIALOG )
	END_MSG_MAP()

	CRealmDialog();

	LRESULT OnInitDialog( 
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);
	
	LRESULT OnOK(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);


	HRESULT GetHelpPath( LPTSTR szHelpPath );

	// The strings containing the text the user will enter.
	CComBSTR m_bstrFindText;
	CComBSTR m_bstrReplaceText;


private:


};

#endif // _IAS_REALM_DIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\resolvednsname.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	ResolveDNSName.h

Abstract:

	Header file for the CResolveDNSNameDialog class.

	See CResolveDNSNameDialog.cpp for implementation.

Author:

    Michael A. Maguire 01/15/98

Revision History:
	mmaguire 01/15/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_RESOLVE_DNS_NAME_DIALOG_H_)
#define _IAS_RESOLVE_DNS_NAME_DIALOG_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "Dialog.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////
class CResolveDNSNameDialog;
typedef CIASDialog<CResolveDNSNameDialog,FALSE> CResolveDNSNameDialogFALSE;


class CResolveDNSNameDialog : public CIASDialog<CResolveDNSNameDialog, FALSE>
{

public:

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of 
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_RESOLVE_DNS_NAME };

	BEGIN_MSG_MAP(CResolveDNSNameDialog)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDOK, OnOK )
		COMMAND_ID_HANDLER( IDCANCEL, OnCancel )
		COMMAND_ID_HANDLER( IDC_BUTTON_RESOLVE_DNS_NAME__RESOLVE, OnResolve )
//		CHAIN_MSG_MAP(CIASDialog<CResolveDNSNameDialog, FALSE > )	// Second template parameter causes preprocessor grief.
		CHAIN_MSG_MAP(CResolveDNSNameDialogFALSE )	
	END_MSG_MAP()

	CResolveDNSNameDialog();

	// Must call after you create, before you display.
	HRESULT SetAddress( BSTR *bstrAddress );

	LRESULT OnInitDialog( 
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);
	
	LRESULT OnResolve(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnOK(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);


	HRESULT GetHelpPath( LPTSTR szHelpPath );


private:

	BSTR *m_pbstrAddress;

	int AddIPAddressesToComboBox( HWND hWndComboBox, LPCTSTR szHostName );

};

#endif // _IAS_RESOLVE_DNS_NAME_DIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iasmmc.rc
//
#define IDC_BUTTON_HELP                 9
#define IDS_PROJNAME                    100
#define IDB_IASSNAPIN_16                101
#define IDB_IASSNAPIN_32                102
#define IDD_IASSNAPIN                   104
#define IDM_CLIENT_NODE                 104
#define IDS_IASSNAPIN_DESC              105
#define IDM_MACHINE_NODE                105
#define IDS_ABOUT__SNAPIN_DESCRIPTION   105
#define IDS_IASSNAPIN_PROVIDER          106
#define IDM_POLICIES_NODE               106
#define IDS_ABOUT__SNAPIN_PROVIDER      106
#define IDS_IASSNAPIN_VERSION           107
#define IDM_ROOT_NODE                   107
#define IDS_ABOUT__SNAPIN_VERSION       107
#define IDR_IASSNAPIN                   108
#define IDM_LOGGING_NODE                108
#define IDS_CLIENTS_NODE                108
#define IDM_LOGGING_METHODS_NODE        108
#define IDS_CLIENTS_NODE__NAME          108
#define IDS_ROOT_NAME                   109
#define IDM_CLIENTS_NODE                109
#define IDS_ROOT_NODE__NAME             109
#define IDS_POLICIES_NODE               110
#define IDM_POLICY_NODE                 110
#define IDS_LOGGING_METHODS_NODE        111
#define IDM_LOCAL_FILE_LOGGING_NODE     111
#define IDS_LOGGING_METHODS_NODE__NAME  111
#define IDS_CLIENT_PAGE1__TAB_NAME      112
#define IDS_LOCAL_FILE_LOGGING_PAGE1__TAB_NAME 113
#define IDS_LOCAL_FILE_LOGGING_PAGE2__TAB_NAME 114
#define IDS_LOCAL_FILE_LOGGING_NODE__NAME 115
#define IDS_MACHINE_PAGE1__TAB_NAME     116
#define IDS_MACHINE_PAGE2__TAB_NAME     117
#define IDS_LOCAL_FILE_LOGGING_BROWSE_DIALOG__TITLE 118
#define IDS_TASKPAD_TEXT__REGISTER_NEW_RADIUS_CLIENT 119
#define IDS_TASKPAD_HELP_TEXT__REGISTER_NEW_RADIUS_CLIENT 120
#define IDS_TASKPAD_TEXT__CONFIGURE_LOGGING 121
#define IDS_TASKPAD_TEXT__START_THE_SERVICE 122
#define IDS_TASKPAD_HELP_TEXT__START_THE_SERVICE 123
#define IDS_TASKPAD_HELP_TEXT__CONFIGURE_LOGGING 124
#define IDS_ROOT_NODE__ON_WORD          125
#define IDS_ROOT_NODE__PRE_MACHINE_NAME 125
#define IDS_ERROR__NO_CONNECTION        126
#define IDS_ERROR__GENERIC              127
#define IDS_ERROR__GENERIC_TITLE        128
#define IDS_ERROR__NO_SDO               129
#define IDS_ERROR__CANT_READ_DATA_FROM_SDO 130
#define IDS_ERROR__SERVER_ADDRESS_EMPTY 131
#define IDS_ERROR__OUT_OF_MEMORY        132
#define IDS_ERROR__ADDING_OBJECT_TO_COLLECTION 133
#define IDS_ERROR__CLIENT_NOT_YET_CONFIGURED 134
#define IDS_ERROR__CLOSE_PROPERTY_SHEET 135
#define IDS_ERROR__CANT_WRITE_DATA_TO_SDO 136
#define IDS_ERROR__DELETING_OBJECT      137
#define IDS_ERROR__DELETE_CLIENT_PROMPT 138
#define IDS_ERROR__DELETE_CLIENT_PROMPT_TITLE 139
#define IDS_ERROR__SHARED_SECRETS_DONT_MATCH 140
#define IDS_ERROR__OPENING_WINSOCK      141
#define IDS_TASKPAD_TEXT__STOP_THE_SERVICE 142
#define IDS_TASKPAD_HELP_TEXT__STOP_THE_SERVICE 143
#define IDS_PROTOCOL_RADIUS             144
#define IDS_ERROR__AUTHENTICATION_PORT_CANT_BE_BLANK 145
#define IDS_ERROR__ACCOUNTING_PORT_CANT_BE_BLANK 146
#define IDS_CLIENT_INFO__OTHER_NAS_TYPE 147
#define IDS_CLIENTS_NODE__FRIENDLY_NAME 148
#define IDS_CLIENTS_NODE__PROTOCOL      149
#define IDS_CLIENTS_NODE__NAS_TYPE      150
#define IDS_LOGGING_METHODS_NODE__LOGGING_METHOD 151
#define IDS_LOGGING_METHODS_NODE__DESCRIPTION 152
#define IDS_CLIENTS_NODE__ADDRESS       153
#define IDS_CONNECT_TO_SERVER_WIZPAGE__TITLE 154
#define IDS_TASKPAD_SERVER__TITLE       155
#define IDS_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_SIZE_REACHES_FORMAT 156
#define IDS_LOCAL_FILE_LOGGING_PAGE2__DAILY_FORMAT 157
#define IDS_LOCAL_FILE_LOGGING_PAGE2__WEEKLY_FORMAT 158
#define IDS_LOCAL_FILE_LOGGING_PAGE2__MONTHLY_FORMAT 159
#define IDS_STARTING_SERVICE            160
#define IDS_STARTING_SERVICE_TITLE      161
#define IDS_STOPPING_SERVICE            162
#define IDS_STOPPING_SERVICE_TITLE      163
#define IDS_ROOT_NODE__LOCAL_WORD       164
#define IDS_RADIUS_PROTOCOL             165
#define IDS_ERROR__CANT_STOP_SERVICE    166
#define IDS_ERROR__CANT_START_SERVICE   167
#define IDS_ERROR__NO_CONNECTION_ATTEMPTED 168
#define IDS_ERROR__CONNECTION_IN_PROGRESS 169
#define IDS_ERROR__CONNECTION_ATTEMPT_FAILED 170
#define IDS_ERROR__CONNECTION_INTERRUPTED 171
#define IDS_ERROR__NOT_NUMBER           172
#define IDS_ERROR__NO_IAS_INSTALLED     173
#define IDI_IAS_SNAPIN_IMAGE            201
#define IDC_CHECK1                      202
#define IDR_CLIENT2_TOOLBAR             202
#define IDR_CLIENT1_TOOLBAR             203
#define IDC_CHECK5                      203
#define IDC_BUTTON1                     204
#define IDR_CLIENTS_TOOLBAR             204
#define IDI_RESULT_NODE_LOGGING_METHOD  204
#define IDC_EDIT_CLIENT_PAGE1_NAME      205
#define IDC_BUTTON3                     205
#define IDC_BUTTON2                     205
#define IDI_PROPSHEET_PROFILE           205
#define IDC_EDIT_CLIENT_PAGE1__NAME     205
#define IDC_EDIT_CLIENT_PAGE1_IP1       206
#define IDC_BUTTON4                     206
#define IDI_RESULT_NODE_CLIENT          206
#define IDC_EDIT_CLIENT_PAGE1__IP1      206
#define IDC_EDIT_CLIENT_PAGE1__ADDRESS  206
#define IDD_CONNECT_TO_MACHINE          207
#define IDC_EDIT_CLIENT_PAGE1_IP2       207
#define IDI_RESULT_NODE_POLICY          207
#define IDC_EDIT_CLIENT_PAGE1__IP2      207
#define IDD_PROPPAGE_CLIENT1            208
#define IDC_EDIT_CLIENT_PAGE1_IP3       208
#define IDC_EDIT_CLIENT_PAGE1__IP3      208
#define IDC_EDIT_CLIENT_PAGE1_IP4       209
#define IDD_PROPPAGE_MACHINE1           209
#define IDC_EDIT_CLIENT_PAGE1__IP4      209
#define IDD_PROPPAGE_SERVER1            209
#define IDC_COMBO1                      210
#define IDD_PROPPAGE_MACHINE2           210
#define IDC_COMBO_RESOLVE_DNS_NAME__RESULT 210
#define IDD_PROPPAGE_SERVER2            210
#define IDC_CHECK2                      211
#define IDD_ADD_CLIENT                  211
#define IDD_PROPPAGE_LOCAL_FILE_LOGGING1 212
#define IDC_EDIT_CLIENT_PAGE1_SHARED_SECRET 213
#define IDD_PROPPAGE_LOCAL_FILE_LOGGING2 213
#define IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET 213
#define IDC_EDIT_CLIENT_PAGE1_SHARED_SECRET_CONFIRM 214
#define IDD_PROPPAGE_POLICIES1          214
#define IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM 214
#define IDC_BUTTON_CLIENT_PAGE1_FIND    215
#define IDD_PROPPAGE_POLICIES2          215
#define IDC_BUTTON_CLIENT_PAGE1__FIND   215
#define IDC_EDIT1                       216
#define IDC_EDIT_MACHINE_PAGE2_AUTHENTICATION 216
#define IDD_PROPPAGE_POLICY1            216
#define IDC_EDIT_MACHINE_PAGE2_AUTHENTICATION_PORT 216
#define IDC_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME 216
#define IDC_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT 216
#define IDC_CHECK3                      217
#define IDD_PROPPAGE_POLICY2            217
#define IDC_EDIT3                       217
#define IDC_EDIT2                       218
#define IDC_EDIT_MACHINE_PAGE2_ACCOUNTING 218
#define IDD_ADD_POLICY                  218
#define IDC_EDIT_MACHINE_PAGE2_ACCOUNTING_PORT 218
#define IDC_EDIT_SERVER_PAGE2_ACCOUNTING_PORT 218
#define IDC_EDIT_MACHINE_PAGE1_NAME     219
#define IDD_PROPPAGE_PROFILE1           219
#define IDC_EDIT_MACHINE_PAGE1__NAME    219
#define IDC_EDIT_SERVER_PAGE1__NAME     219
#define IDC_CHECK4                      220
#define IDD_PROPPAGE_PROFILE2           220
#define IDC_RADIO1                      221
#define IDD_PROPPAGE_PROFILE3           221
#define IDC_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER 221
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1 221
#define IDC_RADIO2                      222
#define IDD_PROPPAGE_PROFILE4           222
#define IDC_RADIO_STARTUP_WIZARD_CONNECT__ANOTHER_COMPUTER 222
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC 222
#define IDC_RADIO3                      223
#define IDD_PROPPAGE_PROFILE5           223
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED 223
#define IDC_RADIO4                      224
#define IDD_TIME_OF_DAY_CONSTRAINTS     224
#define IDC_RADIO5                      225
#define IDD_RESOLVE_DNS_NAME            225
#define IDC_BUTTON_POLICY_PAGE2_EDIT_PROFILE 226
#define IDC_RADIO6                      226
#define IDC_BUTTON_RESOLVE_DNS_NAME__RESOLVE 226
#define IDD_WIZPAGE_STARTUP_CONECT_TO_MACHINE 226
#define IDR_MACHINE_TOOLBAR             227
#define IDC_EDIT4                       228
#define IDR_LOGGING_METHODS_TOOLBAR     228
#define IDC_SPIN3                       229
#define IDR_POLICIES_TOOLBAR            229
#define IDC_SPIN4                       230
#define IDB_BITMAP1                     230
#define IDC_EDIT5                       231
#define IDC_CHECK6                      232
#define IDR_HTML3                       232
#define IDC_EDIT6                       233
#define IDB_STATIC_FOLDER_32            233
#define IDC_EDIT7                       234
#define IDB_STATIC_FOLDER_OPEN_16       234
#define IDB_STATIC_FOLDER_16            235
#define IDD_START_STOP_SERVER           236
#define IDC_LISTVIEWCTRL1               237
#define IDD_WIZPAGE_ADD_CLIENT1         237
#define IDC_BUTTON_PROFILE_PAGE3_EDIT   238
#define IDD_WIZPAGE_ADD_CLIENT2         238
#define IDD_WIZPAGE_ADD_CLIENT3         239
#define IDC_EDIT_CONNECT_TO_SERVER__DNS_NAME 240
#define IDC_EDIT_ADD_CLIENT__CLIENT_NAME 241
#define IDC_EDIT_ADD_CLIENT__NAME       241
#define IDC_EDIT_ADD_POLICY__POLICY_NAME 242
#define IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT 244
#define IDC_COMBO_CLIENT_PAGE1__MANUFACTURER 245
#define IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE 247
#define IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__ENABLE_LOGGING 248
#define IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS 249
#define IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS 250
#define IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS 251
#define IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG 252
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY 253
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY 254
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY 255
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES 256
#define IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE 257
#define IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY 258
#define IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME 259
#define IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__USE_V1_FORMAT 260
#define IDC_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE 261
#define IDC_CHECK_MACHINE_PAGE1__CAPTURE_APPLICATION_EVENTS 262
#define IDC_CHECK_SERVER_PAGE1__CAPTURE_APPLICATION_EVENTS 262
#define IDC_CHECK_MACHINE_PAGE1__CAPTURE_MALFORMED_PACKETS 263
#define IDC_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS 263
#define IDC_CHECK_MACHINE_PAGE1__CAPTURE_DEBUG_PACKETS 264
#define IDC_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKETS 264
#define IDC_COMBO_ADD_CLIENT__PROTOCOL  265
#define IDC_EDIT_RESOLVE_DNS_NAME__DNS_NAME 266
#define IDC_STATIC_RESULT               267
#define IDC_STATIC_RESOLVE_DNS_NAME__RESULT 267
#define IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE_UNITS 268
#define IDC_COMBO2                      269
#define IDC_CONNECTION_STATUS__DIALOG__STATUS 270
#define IDC_STATIC_SERVER_STATUS        271
#define ID_BUTTON32768                  32768
#define ID_BUTTON32769                  32769
#define ID_BUTTON32770                  32770
#define ID_BUTTON32771                  32771
#define ID_BUTTON32772                  32772
#define ID_BUTTON32773                  32773
#define ID_BUTTON32774                  32774
#define ID_MENUITEM32775                32775
#define ID_MENUITEM_DO_SOMETHING_TO_CLIENT 32777
#define ID_MENUITEM_MACHINE_TOP__START_SERVICE 32778
#define ID_MENUITEM_MACHINE_TOP__STOP_SERVICE 32779
#define ID_MENUITEM_CLIENTS_NEW__CLIENT 32780
#define ID_MENUITEM_ROOT_TOP__CONNECT_TO_SERVER 32781
#define ID_MENUITEM_CLIENTS_TOP__NEW_CLIENT 32783
#define ID_BUTTON32785                  32785
#define ID_BUTTON32786                  32786
#define ID_BUTTON32787                  32787
#define ID_BUTTON32788                  32788
#define ID_MENUITEM_POLICIES_TOP__NEW_POLICY 32790
#define ID_MENUITEM_POLICIES_NEW__POLICY 32791
#define ID_MENUITEM_POLICY_TOP__MOVE_UP 32792
#define ID_MENUITEM_POLICY_TOP__MOVE_DOWN 32793
#define ID_BUTTON_MACHINE__START_SERVICE 32794
#define ID_BUTTON_MACHINE__STOP_SERVICE 32795
#define IDS_SERVER_STATUS__STARTING_THE_SERVER 32796
#define IDS_SERVER_STATUS__STOPPING_THE_SERVER 32797
#define IDS_ERROR__COULD_NOT_RESOLVE_HOST_NAME 32798
#define IDS_ROOT_NODE__POST_MACHINE_NAME 32799
#define IDS_CLIENT_NODE__DELETE_CLIENT__PROMPT1 32800
#define IDS_CLIENT_NODE__DELETE_CLIENT__PROMPT2 32801
#define IDS__ON_MACHINE                 32801
#define IDS_CLIENT_NODE__DELETE_CLIENT__PROMPT_TITLE 32802
#define IDS_CLIENT_NODE__DELETE_CLIENT__PROMPT3 32803
#define IDS_CLIENT_NODE__DELETE_CLIENT__PROMPT2_LOCAL 32804
#define IDS__ON_LOCAL_MACHINE           32804
#define IDS_ERROR__NOT_A_VALID_DIRECTORY 32805
#define IDS_SNAPINNAME_IAS              32806
#define IDS_ERROR__SERVER_READING_NAME  32900
#define IDS_ERROR__SERVER_WRITING_NAME  32901
#define IDS_ERROR__SERVER_READING_CAPTURE_APPLICATION_EVENTS 32902
#define IDS_ERROR__SERVER_WRITING_CAPTURE_APPLICATION_EVENTS 32903
#define IDS_ERROR__SERVER_READING_RADIUS_LOG_MALFORMED 32904
#define IDS_ERROR__SERVER_WRITING_RADIUS_LOG_MALFORMED 32905
#define IDS_ERROR__SERVER_READING_RADIUS_LOG_ALL 32906
#define IDS_ERROR__SERVER_WRITING_RADIUS_LOG_ALL 32907
#define IDS_ERROR__SERVER_READING_RADIUS_AUTHENTICATION_PORT 32910
#define IDS_ERROR__SERVER_WRITING_RADIUS_AUTHENTICATION_PORT 32911
#define IDS_ERROR__SERVER_READING_RADIUS_ACCOUNTING_PORT 32912
#define IDS_ERROR__SERVER_WRITING_RADIUS_ACCOUNTING_PORT 32913
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_ENBABLE 32914
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_ENABLE 32915
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_ACCOUNTING_PACKETS 32916
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_ACCOUNTING_PACKETS 32917
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_AUTHENTICATION_PACKETS 32920
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_AUTHENTICATION_PACKETS 32921
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_INTERIM_ACCOUNTING_PACKETS 32922
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_INTERIM_ACCOUNTING_PACKETS 32923
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_AUTOMATICALLY_OPEN_NEW_LOG 32924
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_AUTOMATICALLY_OPEN_NEW_LOG 32925
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_NEW_LOG_FREQUENCY 32926
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_NEW_LOG_FREQUENCY 32927
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_WHEN_LOG_FILE_SIZE 32928
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_WHEN_LOG_FILE_SIZE 32929
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_LOG_FILE_DIRECTORY 32930
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_LOG_FILE_DIRECTORY 32931
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_LOG_FILE_FORMAT 32932
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_LOG_FILE_FORMAT 32933
#define IDS_ERROR__CLIENT_READING_NAME  32934
#define IDS_ERROR__CLIENT_WRITING_NAME  32935
#define IDS_ERROR__CLIENT_READING_ADDRESS 32936
#define IDS_ERROR__CLIENT_WRITING_ADDRESS 32937
#define IDS_ERROR__CLIENT_READING_MANUFACTURER 32938
#define IDS_ERROR__CLIENT_WRITING_MANUFACTURER 32939
#define IDS_ERROR__CLIENT_READING_FILTER_VSAS 32940
#define IDS_ERROR__CLIENT_WRITING_FILTER_VSAS 32941
#define IDS_ERROR__CLIENT_READING_REQUIRE_SIGNATURE 32942
#define IDS_ERROR__CLIENT_WRITING_REQUIRE_SIGNATURE 32943
#define IDS_ERROR__CLIENT_READING_SHARED_SECRET 32944
#define IDS_ERROR__CLIENT_WRITING_SHARED_SECRET 32945
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_WHEN_LOG_FILE_SIZE_NOT_ZERO 32946
#define IDS_ERROR__SERVER_WRITING_RADIUS_AUTHENTICATION_PORT_NOT_ZERO 32947
#define IDS_ERROR__SERVER_WRITING_RADIUS_ACCOUNTING_PORT_NOT_ZERO 32948
#define IDS_ADD_CLIENT_WIZPAGE1__TAB_NAME 32949
#define IDS_ADD_CLIENT_WIZPAGE2__TAB_NAME 32950
#define IDS_ADD_CLIENT_WIZPAGE3__TAB_NAME 32951
#define IDS_HTMLHELPLINKS_PATH          32952
#define IDS_HTMLHELP_PATH               32953
#define IDS_WARNING__SERVICE_MUST_BE_RESTARTED_FOR_PORTS 32954
#define IDS_WARNING_TITLE__SERVICE_MUST_BE_RESTARTED_FOR_PORTS 32955
#define IDS_ADD_CLIENT__REQUIRES_NAME   32956
#define IDS_TASKPAD_TEXT__SETUP_DS_ACL  32957
#define IDS_TASKPAD_HELP_TEXT__SETUP_DS_ACL 32958
#define IDS_DSACL__ALREADY_SETUP        32959
#define IDS_DSACL__THIS_WILL_SETUP      32960
#define IDS_ERROR__COULD_NOT_LOAD_DLL   32961
#define IDS_ERROR__DLL_ENTRY_POINT_COULD_NOT_BE_FOUND 32962
#define IDS_DSACL__TITLE_THIS_WILL_SETUP 32963
#define IDS_ERROR__DS_NO_PERMISSION     32965
#define IDS_ERROR__DS_SCHEMA_CANNOT_BE_UPGRADED 32966
#define IDS_DSACL__CHANGES_SUCCESSFUL   32967
#define IDS_ERROR__DSACL_SETUP_FAILED   32968
#define IDS_DSACL__TITLE_CHANGES_SUCCESSFUL 32969
#define IDS_ERROR__DSACL_DLL_NOT_FOUND  32970
#define IDS_ERROR__DSACL_ESTABLISHCOMPUTERASDOMAINRASSERVER_NOT_FOUND 32971
#define IDS_INFO__RESTART_SERVER        32972
#define IDS_INFO_TITLE__RESTART_SERVER  32973
#define ID_MENUITEM_MACHINE_TOP__REGISTER_SERVER 32974
#define IDS_INFO_TITLE__SERVER_ALREADY_REGISTERED 32975
#define IDS_ERROR__DSACL_NO_SUPPORTED_FOR_THIS_MACHINE 32976
#define IDS_COPY_OF                     32977
#define IDS__STARTING_ON_MACHINE        32978
#define IDS__STARTING_ON_LOCAL_MACHINE  32979
#define IDS_MACHINE_PAGE3__TAB_NAME     32980
#define IDD_PROPPAGE_SERVER3            32981
#define IDD_REPLACE_REALMS              33001
#define IDC_LIST_REALMS_REPLACEMENTS    33002
#define IDC_BUTTON_REALMS_MOVE_UP       33003
#define IDC_BUTTON_REALMS_MOVE_DOWN     33004
#define IDC_BUTTON_REALMS_ADD           33005
#define IDC_BUTTON_REALMS_REMOVE        33006
#define IDC_BUTTON_REALMS_EDIT          33007
#define IDC_EDIT_REALMS_FIND            33008
#define IDC_EDIT_REALMS_REPLACE         33009
#define IDS_DISPLAY_REALMS_FIRSTCOLUMN  33010
#define IDS_DISPLAY_REALMS_SECONDCOLUMN 33011
#define IDS_ERROR_REALM_FIND_CANT_BE_EMPTY 33012
#define IDS_ERROR_REALM_SDO_GET         33013
#define IDS_ERROR_REALM_SDO_PUT         33014
#define IDS_ERROR__CLIENTNAME_EMPTY    33015
#define IDS_ERROR__NOTABLE_TO_WRITE_SDO   33016
#define IDS_ERROR__RESTART_SNAPIN     33017
#define IDS_INFO_IASNOTINSTALLED      33018
#define IDS_TEXT_SERVERNODE_DESC_TITLE   33019
#define IDS_TEXT_SERVERNODE_DESC_TEXT1   33020
#define IDS_TEXT_SERVERNODE_DESC_TEXT2   33021
#define IDS_TEXT_SERVERNODE_DESC_TEXT3   33022
#define IDS_TEXT_SERVERNODE_DESC_TEXT4   33023
#define IDS_ERROR_START_NT4_ADMIN      33025
#define IDS_INFO_START_NT4_ADMIN    33026
#define IDS_INFO_USE_NT4_ADMIN         33027
#define IDS_INFO_NO_DOWNLEVEL_ON_WIN64 33028


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        241
#define _APS_NEXT_COMMAND_VALUE         32990
#define _APS_NEXT_CONTROL_VALUE         272
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\resolvednsname.cpp ===
//////////////////////////////////////////////////////////////////////////////
// 
// 
// Copyright (C) Microsoft Corporation
// 
// Module Name:
// 
//    ResolveDNSName.cpp
// 
// Abstract:
// 
//    Implementation file for the CResolveDNSNameDialog class.
// 
// Author:
// 
//     Michael A. Maguire 01/15/98
// 
// Revision History:
//    mmaguire 01/15/98 - created
//    sbens    01/25/00 - use Unicode APIs to resolve hostnames
// 
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ResolveDNSName.h"
//
// where we can find declarations needed in this file:
//
#include <winsock2.h>
#include <svcguid.h>
#include <stdio.h>
#include "iasutil.h"

//
// END INCLUDES

/////////
// Unicode version of gethostbyname. The caller must free the returned hostent
// struct by calling LocalFree.
/////////
PHOSTENT
WINAPI
IASGetHostByName(
    IN PCWSTR name
    );

//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CResolveDNSNameDialog::CResolveDNSNameDialog

--*/
//////////////////////////////////////////////////////////////////////////////
CResolveDNSNameDialog::CResolveDNSNameDialog()
{
   ATLTRACE(_T("# +++ ResolveDNSNameDialog::ResolveDNSNameDialog\n"));
   // This is initially NULL and must be set using the SetAddress method.
   m_pbstrAddress = NULL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CResolveDNSNameDialog::SetAddress

  Use this to set the BSTR from which the initial machine address will be drawn and into
  which the chosen address will be stored.

  You are required to call this after you create the CResolveDNSNameDialog and
  before you try to display the dialog.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CResolveDNSNameDialog::SetAddress( BSTR *pbstrAddress )
{
   ATLTRACE(_T("# ResolveDNSNameDialog::SetAddress\n"));

   // Check for preconditions:
   _ASSERTE( pbstrAddress != NULL );

   m_pbstrAddress = pbstrAddress;
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CResolveDNSNameDialog::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CResolveDNSNameDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   ATLTRACE(_T("# CResolveDNSNameDialog::OnInitDialog\n"));

   // Check for preconditions:
   _ASSERTE( m_pbstrAddress != NULL );

   SetDlgItemText(IDC_EDIT_RESOLVE_DNS_NAME__DNS_NAME, *m_pbstrAddress );
   return TRUE;   // ISSUE: what do we need to be returning here?
}


//////////////////////////////////////////////////////////////////////////////
/* ++

CResolveDNSNameDialogAddIPAddressesToComboBox

Given a hostname, resolves it into an IP address or addresses and adds them to
the given combobox.

Return value:

     int number of IP address added

-- */
//////////////////////////////////////////////////////////////////////////////
int CResolveDNSNameDialog::AddIPAddressesToComboBox( HWND hWndComboBox, LPCTSTR szHostName )
{
   // Quick pre-check to see if the user entered an IP address or subnet.
   ULONG width;
   ULONG address = (szHostName != NULL)?IASStringToSubNetW(szHostName, &width):INADDR_NONE;
   if (address != INADDR_NONE)
   {
      ::SendMessage(hWndComboBox, CB_RESETCONTENT, 0, 0);
      ::SendMessage(hWndComboBox, CB_ADDSTRING, 0, (LPARAM)szHostName);
      ::SendMessage(hWndComboBox, CB_SETCURSEL, 0, 0);
      return 1;
   }

// WSAStartup is now called from ISdoServer::Connect
// WSADATA              wsaData;
   struct hostent FAR * hostentAddressInfo;
   char FAR * FAR *     ppIPAddress;
   TCHAR                szIPAddress[IAS_MAX_STRING];
   int                  iCountOfIPAddresses = 0;

// WSAStartup is now called from ISdoServer::Connect
// // Startup winsock, version 1.1
//
// int iError = WSAStartup(MAKEWORD(1,1), &wsaData);
// if( iError )
// {
//    ShowErrorDialog( m_hWnd, IDS_ERROR__OPENING_WINSOCK );
//    return 0;
// }


      // Save old cursor.
      HCURSOR hSavedCursor = GetCursor();

      // Change cursor here to wait cursor.
      SetCursor( LoadCursor( NULL, IDC_WAIT ) );

      // Make winsock API call to get the TCP/IP address(es) of the machine name passed in.
      hostentAddressInfo = IASGetHostByName( szHostName );

      // Change cursor back to normal cursor.
      SetCursor( hSavedCursor );

      // Initialize the combo box.
      // We want to to this regardless of whether we succeed above or not.
      // If we fail, this will empy the combo box (as desired).
      LRESULT lresResult = ::SendMessage( hWndComboBox, CB_RESETCONTENT, 0, 0);

      // Check to see if there was at least one valid address.
      if( hostentAddressInfo != NULL )
      {

         // Enumerate through the IP addresses.
         // If you try using dial-up networking while you have
         // TCP/IP attached to a network card---you'll see you
         // have two addresses.

         for( ppIPAddress = hostentAddressInfo->h_addr_list; *ppIPAddress; ppIPAddress++ )
         {
            _stprintf( szIPAddress, _T("%d.%d.%d.%d"),
               (unsigned char)(*ppIPAddress)[0],
               (unsigned char)(*ppIPAddress)[1],
               (unsigned char)(*ppIPAddress)[2],
               (unsigned char)(*ppIPAddress)[3]);


            // Add the address string to the combo box.
            lresResult = ::SendMessage( hWndComboBox, CB_ADDSTRING, 0, (LPARAM) szIPAddress );


            iCountOfIPAddresses++;

         }

         // Make sure to select the first object in the combo box.
         lresResult = ::SendMessage( hWndComboBox, CB_SETCURSEL, 0, 0 );

         LocalFree(hostentAddressInfo);
      }
      else
      {

         // Not sure exactly why I need any more specific information here.
         // Is there any reason why "Could not resolve host name" is not enough?
         // int iError = WSAGetLastError();

         ShowErrorDialog( m_hWnd, IDS_ERROR__COULD_NOT_RESOLVE_HOST_NAME );
      }


   return iCountOfIPAddresses;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CResolveDNSNameDialog::OnResolve

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CResolveDNSNameDialog::OnResolve(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
      )
{
   ATLTRACE(_T("# ResolveDNSNameDialog::OnResolve\n"));

   // Check for preconditions:

   long lButtonStyle;
   CComBSTR bstrHostName;
   GetDlgItemText(IDC_EDIT_RESOLVE_DNS_NAME__DNS_NAME, (BSTR &) bstrHostName);
   int iCount = AddIPAddressesToComboBox(GetDlgItem(IDC_COMBO_RESOLVE_DNS_NAME__RESULT), bstrHostName);
   
   if( 0 == iCount)
   {
      // We did not add any IP addresses to the combo box.

      // Disable the "Use" (IDOK) button.
      ::EnableWindow( GetDlgItem( IDOK ), FALSE );

      // Make sure the "Resolve" button is the default button.
      lButtonStyle = ::GetWindowLong( GetDlgItem( IDC_BUTTON_RESOLVE_DNS_NAME__RESOLVE), GWL_STYLE );
      lButtonStyle = lButtonStyle | BS_DEFPUSHBUTTON;
      SendDlgItemMessage( IDC_BUTTON_RESOLVE_DNS_NAME__RESOLVE, BM_SETSTYLE, LOWORD(lButtonStyle), MAKELPARAM(1,0) );

   }
   else
   {
      // We did not added at least one IP address to the combo box.

      // Enable the "Use" (IDOK) button.
      ::EnableWindow( GetDlgItem( IDOK ), TRUE );

      // Make sure the "Use" button is the default button.
      lButtonStyle = ::GetWindowLong( GetDlgItem(IDOK), GWL_STYLE );
      lButtonStyle = lButtonStyle | BS_DEFPUSHBUTTON;
      SendDlgItemMessage( IDOK, BM_SETSTYLE, LOWORD(lButtonStyle), MAKELPARAM(1,0) );
      ::SetFocus( GetDlgItem(IDOK) );

      // Make sure the "Resolve" button is not the default button.
      lButtonStyle = ::GetWindowLong( GetDlgItem(IDC_BUTTON_RESOLVE_DNS_NAME__RESOLVE), GWL_STYLE );
      lButtonStyle = lButtonStyle & ~BS_DEFPUSHBUTTON;
      SendDlgItemMessage( IDC_BUTTON_RESOLVE_DNS_NAME__RESOLVE, BM_SETSTYLE, LOWORD(lButtonStyle), MAKELPARAM(1,0) );

   }


   return 0;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CResolveDNSNameDialog::OnOK

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CResolveDNSNameDialog::OnOK(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
      )
{
   ATLTRACE(_T("# ResolveDNSNameDialog::OnOK\n"));

   // Check for preconditions:
   _ASSERTE( m_pbstrAddress != NULL );

   TCHAR szAddress[IAS_MAX_STRING];

   // Get the currently selected IP address.
   LRESULT lresIndex = ::SendMessage( GetDlgItem( IDC_COMBO_RESOLVE_DNS_NAME__RESULT ), CB_GETCURSEL, 0, 0);

   if( lresIndex != CB_ERR )
   {

      // Retrieve the text for the currently selected item.
      LRESULT lresResult = ::SendMessage( GetDlgItem( IDC_COMBO_RESOLVE_DNS_NAME__RESULT ), CB_GETLBTEXT, (WPARAM) lresIndex, (LPARAM) (LPCSTR) szAddress );

      if( lresResult )
      {
         // Change the BSTR in the original dialog so that it uses the selected IP address.
         SysReAllocString( m_pbstrAddress, szAddress );
      }
      else
      {
         // Error -- couldn't retrieve the selected item.
         // Do nothing.
      }

   }
   else
   {
      // Error -- no item selected.
      // Do nothing.
   }

   EndDialog(TRUE);
   return 0;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CResolveDNSNameDialog::OnCancel

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CResolveDNSNameDialog::OnCancel(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
      )
{
   ATLTRACE(_T("# ResolveDNSNameDialog::OnCancel\n"));
   EndDialog(FALSE);
   return 0;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CResolveDNSNameDialog::GetHelpPath

Remarks:

   This method is called to get the help file path within
   an compressed HTML document when the user presses on the Help
   button of a property sheet.

   It is an override of CIASDialog::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CResolveDNSNameDialog::GetHelpPath( LPTSTR szHelpPath )
{
   ATLTRACE(_T("# CResolveDNSNameDialog::GetHelpPath\n"));


   // Check for preconditions:



#if 0
   // ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
   // installed on this machine -- it appears to be non-unicode.
   lstrcpy( szHelpPath, _T("html/idh_proc_client_information.htm") );
#else
   strcpy( (CHAR *) szHelpPath, "html/idh_proc_client_information.htm" );
#endif

   return S_OK;
}

/////////
// Unicode version of gethostbyname. The caller must free the returned hostent
// struct by calling LocalFree.
/////////
PHOSTENT
WINAPI
IASGetHostByName(
    IN PCWSTR name
    )
{
   // We put these at function scope, so we can clean them up on the way out.
   DWORD error = NO_ERROR;
   HANDLE lookup = NULL;
   union
   {
      WSAQUERYSETW querySet;
      BYTE buffer[512];
   };
   PWSAQUERYSETW result = NULL;
   PHOSTENT retval = NULL;

   do
   {
      //////////
      // Create the query set
      //////////

      GUID hostAddrByNameGuid = SVCID_INET_HOSTADDRBYNAME;
      AFPROTOCOLS protocols[2] =
      {
         { AF_INET, IPPROTO_UDP },
         { AF_INET, IPPROTO_TCP }
      };
      memset(&querySet, 0, sizeof(querySet));
      querySet.dwSize = sizeof(querySet);
      querySet.lpszServiceInstanceName = (PWSTR)name;
      querySet.lpServiceClassId = &hostAddrByNameGuid;
      querySet.dwNameSpace = NS_ALL;
      querySet.dwNumberOfProtocols = 2;
      querySet.lpafpProtocols = protocols;

      //////////
      // Execute the query.
      //////////

      error = WSALookupServiceBeginW(
                  &querySet,
                  LUP_RETURN_ADDR,
                  &lookup
                  );
      if (error)
      {
         error = WSAGetLastError();
         break;
      }

      //////////
      // How much space do we need for the result?
      //////////

      DWORD length = sizeof(buffer);
      error = WSALookupServiceNextW(
                    lookup,
                    0,
                    &length,
                    &querySet
                    );
      if (!error)
      {
         result = &querySet;
      }
      else
      {
         error = WSAGetLastError();
         if (error != WSAEFAULT)
         {
            break;
         }

         /////////
         // Allocate memory to hold the result.
         /////////

         result = (PWSAQUERYSETW)LocalAlloc(0, length);
         if (!result)
         {
            error = WSA_NOT_ENOUGH_MEMORY;
            break;
         }

         /////////
         // Get the result.
         /////////

         error = WSALookupServiceNextW(
                     lookup,
                     0,
                     &length,
                     result
                     );
         if (error)
         {
            error = WSAGetLastError();
            break;
         }
      }

      if (result->dwNumberOfCsAddrs == 0)
      {
         error = WSANO_DATA;
         break;
      }

      ///////
      // Allocate memory to hold the hostent struct
      ///////

      DWORD naddr = result->dwNumberOfCsAddrs;
      SIZE_T nbyte = sizeof(hostent) +
                     (naddr + 1) * sizeof(char*) +
                     naddr * sizeof(in_addr);
      retval = (PHOSTENT)LocalAlloc(0, nbyte);
      if (!retval)
      {
         error = WSA_NOT_ENOUGH_MEMORY;
         break;
      }

      ///////
      // Initialize the hostent struct.
      ///////

      retval->h_name = NULL;
      retval->h_aliases = NULL;
      retval->h_addrtype = AF_INET;
      retval->h_length = sizeof(in_addr);
      retval->h_addr_list = (char**)(retval + 1);

      ///////
      // Store the addresses.
      ///////

      u_long* nextAddr = (u_long*)(retval->h_addr_list + naddr + 1);

      for (DWORD i = 0; i < naddr; ++i)
      {
         sockaddr_in* sin = (sockaddr_in*)
            result->lpcsaBuffer[i].RemoteAddr.lpSockaddr;

         retval->h_addr_list[i] = (char*)nextAddr;

         *nextAddr++ = sin->sin_addr.S_un.S_addr;
      }

      ///////
      // NULL terminate the address list.
      ///////

      retval->h_addr_list[i] = NULL;

   } while (FALSE);

   //////////
   // Clean up and return.
   //////////

   if (result && result != &querySet) { LocalFree(result); }

   if (lookup) { WSALookupServiceEnd(lookup); }

   if (error)
   {
      if (error == WSASERVICE_NOT_FOUND) { error = WSAHOST_NOT_FOUND; }

      WSASetLastError(error);
   }

   return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\servernode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    RootNode.cpp

Abstract:

   Implementation file for the CServerNode class.


Author:

    Michael A. Maguire 12/03/97

Revision History:
   mmaguire 12/03/97


--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//

#include "ServerNode.h"
#include "SnapinNode.cpp"  // Template class implementation
//
// where we can find declarations needed in this file:
//
#include "ClientsNode.h"

#include "ComponentData.h"
#include "ServerEnumTask.h"
#include "lm.h" // For typedef's needed in lmapibuf.h
#include "dsgetdc.h" // For DsGetDcName
#include "lmapibuf.h" // For NetApiBufferAllocate
#include "mmcutility.h" // For GetUserAndDomainName
#include "lmcons.h" // For DNLEN, UNLEN

#include "dsrole.h"

// Need to include this at least once to get in build:
#include "sdohelperfuncs.cpp"
#include "ChangeNotification.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::InitClipboardFormat

--*/
//////////////////////////////////////////////////////////////////////////////
void CServerNode::InitClipboardFormat()
{
   ATLTRACE(_T("# CServerNode::InitClipboardFormat\n"));

   // Check for preconditions:
   // None.

   // Init a clipboard format which will allow us to exchange
   // machine name information.
   m_CCF_MMC_SNAPIN_MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::FillData

The server node need to override CSnapInItem's implementation of this so that we can
also support a clipformat for exchanging machine names with any snapins extending us.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CServerNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
   ATLTRACE(_T("# CServerNode::FillData\n"));

   // Check for preconditions:
   // None.

   HRESULT hr = DV_E_CLIPFORMAT;
   ULONG uWritten;

   // Extra to support machine name.
   if (cf == m_CCF_MMC_SNAPIN_MACHINE_NAME)
   {
      if( m_bstrServerAddress == NULL )
      {
         // Write a NULL to the stream.
         OLECHAR c = _T('\0');
         hr = pStream->Write(&c, sizeof(OLECHAR), &uWritten);
      }
      else
      {
         // Write the string to the stream, including its NULL terminator.
         unsigned long len = wcslen(m_bstrServerAddress)+1;
         hr = pStream->Write(m_bstrServerAddress, len*sizeof(wchar_t), &uWritten);
      }
      return hr;
   }
   else  if (cf == CF_MMC_NodeID)
   {
      ::CString   SZNodeID = (LPCTSTR)GetSZNodeType();
      SZNodeID += m_bstrServerAddress;

      DWORD dwIdSize = 0;

      SNodeID2* NodeId = NULL;
      BYTE *id = NULL;
      DWORD textSize = (SZNodeID.GetLength()+ 1) * sizeof(TCHAR);

      dwIdSize = textSize + sizeof(SNodeID2);

      try
      {
         NodeId = (SNodeID2 *)_alloca(dwIdSize);
      }
      catch(...)
      {
         hr = E_OUTOFMEMORY;
         return hr;
      }

      NodeId->dwFlags = 0;
      NodeId->cBytes = textSize;
      memcpy(NodeId->id,(BYTE*)(LPCTSTR)SZNodeID, textSize);

      hr = pStream->Write(NodeId, dwIdSize, &uWritten);
      return hr;
   }

   // Call the method which we're overriding to let it handle the
   // rest of the possible cases as usual.
   return CSnapinNode<CServerNode, CComponentData, CComponent>::FillData( cf, pStream );
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::UpdateMenuState

--*/
//////////////////////////////////////////////////////////////////////////////
void CServerNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
   ATLTRACE(_T("# CServerNode::UpdateMenuState\n"));

   // Check for preconditions:
   // None.
   BOOL  bIASInstalled = TRUE;
   IfServiceInstalled(m_bstrServerAddress, _T("IAS"), &bIASInstalled);

   if(!bIASInstalled)
   {
      *flags = MFS_GRAYED;
      return;
   }

   // Set the state of the appropriate context menu items.
   if( id == ID_MENUITEM_MACHINE_TOP__START_SERVICE )
   {
      if( m_pServerStatus == NULL || ! CanStartServer() )
      {
         *flags = MFS_GRAYED;
      }
      else
      {
         *flags = MFS_ENABLED;
      }
   }
   else
      if( id == ID_MENUITEM_MACHINE_TOP__STOP_SERVICE )
      {
         if( m_pServerStatus == NULL || ! CanStopServer() )
         {
            *flags = MFS_GRAYED;
         }
         else
         {
            *flags = MFS_ENABLED;
         }
      }
      else
         if ( id == ID_MENUITEM_MACHINE_TOP__REGISTER_SERVER )
         {
            if( ShouldShowSetupDSACL() )
            {
               *flags = MFS_ENABLED;
            }
            else
            {
               *flags = MFS_GRAYED;
            }
         }

   return;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::UpdateToolbarButton

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerNode::UpdateToolbarButton(UINT id, BYTE fsState)
{
   ATLTRACE(_T("# CServerNode::UpdateToolbarButton\n"));

   // Check for preconditions:
   // None.

   // Set whether the buttons should be enabled.
   if (fsState == ENABLED)
   {
      if( id == ID_BUTTON_MACHINE__START_SERVICE )
      {
         ATLTRACE(_T("# CServerNode::UpdateToolbarButton ID_BUTTON_MACHINE__START_SERVICE"));
         if( m_pServerStatus == NULL || ! CanStartServer() )
         {
            ATLTRACE(_T(" === FALSE \n"));
            return FALSE;
         }
         else
         {
            ATLTRACE(_T(" === TRUE \n"));
            return TRUE;
         }
      }
      else
         if ( id == ID_BUTTON_MACHINE__STOP_SERVICE )
         {
            ATLTRACE(_T("# CServerNode::UpdateToolbarButton ID_BUTTON_MACHINE__STOP_SERVICE"));
            if( m_pServerStatus == NULL || ! CanStopServer() )
            {
               ATLTRACE(_T(" === FALSE \n"));
               return FALSE;
            }
            else
            {
               ATLTRACE(_T(" === TRUE \n"));
               return TRUE;
            }
         }
   }

   // For all other possible button ID's and states, the correct answer here is FALSE.
   return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::GetResultViewType

See CSnapinNode::GetResultViewType (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CServerNode::GetResultViewType (
           LPOLESTR  *ppViewType
         , long  *pViewOptions
         )
{
   ATLTRACE(_T("# CServerNode::GetResultViewType\n"));

   HRESULT hr = S_OK;

   // Check for preconditions:
   // None.

   // In this code we are defaulting to a taskpad view for this node all the time.
   // It is the snapin's responsibility to put up a view menu selection that has a
   // selection for the taskpad. Do that in AddMenuItems.

   // We will use the default DHTML provided by MMC. It actually resides as a
   // resource inside MMC.EXE. We just get the path to it and use that.
   // The one piece of magic here is the text following the '#'. That is the special
   // way we have of identifying they taskpad we are talking about. Here we say we are
   // wanting to show a taskpad that we refer to as "CMTP1". We will actually see this
   // string pass back to us later. If someone is extending our taskpad, they also need
   // to know what this secret string is.

   // We are constructing a string pointing to the HTML resource
   // of the form: "res://d:\winnt\system32\mmc.exe/default.htm#CMTP1"

// 354294   1     mashab   DCR IAS: needs Welcome message and explantation of IAS application in the right pane
#ifdef   NOMESSAGE_VIEW_FOR_SERVER_NODE

   *pViewOptions = MMC_VIEW_OPTIONS_NONE;
   *ppViewType = NULL;

#else
    // create the message view thingie
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    LPOLESTR psz = NULL;
    StringFromCLSID(CLSID_MessageView, &psz);

    USES_CONVERSION;

    if (psz != NULL)
    {
        *ppViewType = psz;
        hr = S_OK;
    }

#endif

   return hr;

#ifndef NO_TASKPAD   // Don't even try checking below -- just fall through and return S_FALSE.

   // Query IConsole2 to see whether taskpad view is preferred.
   // If IConsole2 isn't implemented, we probably aren't running on MMC 1.1,
   //  so taskpad view isn't supported anyway.

   CComponentData *pComponentData = GetComponentData();
   _ASSERTE( pComponentData != NULL );
   _ASSERTE( pComponentData->m_spConsole != NULL );

   CComQIPtr<IConsole2, &IID_IConsole2> spIConsole2(pComponentData->m_spConsole);

   if( spIConsole2 != NULL )
   {
      hr = spIConsole2->IsTaskpadViewPreferred();

      if( hr == S_OK )
      {
         // The user prefers taskpad views.

         OLECHAR szBuffer[MAX_PATH*2]; // A little extra.

         lstrcpy (szBuffer, L"res://");
         OLECHAR * temp = szBuffer + lstrlen(szBuffer);

         // Get "res://"-type string for custom taskpad.
         ::GetModuleFileName (NULL, temp, MAX_PATH);
         lstrcat (szBuffer, L"/default.htm#CMTP1");

         // Alloc and copy bitmap resource string.
         *ppViewType = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(szBuffer)+1));
         if ( NULL == *ppViewType)
         {
            return E_OUTOFMEMORY;   // or S_FALSE ???
         }

         lstrcpy (*ppViewType, szBuffer);

         return S_OK;
      }
   }

#endif  // NO_TASKPAD

   // If we fell through to here, no taskpad view.
   return S_FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::TaskNotify

See CSnapinNode::TaskNotify (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CServerNode::TaskNotify(
           IDataObject * pDataObject
         , VARIANT * pvarg
         , VARIANT * pvparam
         )
{
   ATLTRACE(_T("# CServerNode::TaskNotify\n"));

   // Check for preconditions:
   // None.

   HRESULT hr = S_FALSE;

   if (pvarg->vt == VT_I4)
   {
      switch (pvarg->lVal)
      {
      case SERVER_TASK__ADD_CLIENT:
         hr = OnTaskPadAddClient( pDataObject, pvarg, pvparam );
         break;
      case SERVER_TASK__START_SERVICE:
         hr = StartStopService( TRUE );
         break;
      case SERVER_TASK__STOP_SERVICE:
         hr = StartStopService( FALSE );
         break;
      case SERVER_TASK__SETUP_DS_ACL:
         hr = OnTaskPadSetupDSACL( pDataObject, pvarg, pvparam );
         break;
      default:
         break;
      }
   }

   // ISSUE: What should I be returning here?
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::EnumTasks

See CSnapinNode::EnumTasks (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CServerNode::EnumTasks(
           IDataObject * pDataObject
         , BSTR szTaskGroup
         , IEnumTASK** ppEnumTASK
         )
{
   ATLTRACE(_T("# CServerNode::EnumTasks\n"));

   // Check for preconditions:
   // None.

   HRESULT hr = S_OK;
   CServerEnumTask * pServerEnumTask = new CServerEnumTask( this );

   if ( pServerEnumTask == NULL )
   {
      hr = E_OUTOFMEMORY;
   }
   else
   {
      // Make sure release works properly on failure.
      pServerEnumTask->AddRef ();

      hr = pServerEnumTask->Init( pDataObject, szTaskGroup);
      if( hr == S_OK )
      {
         hr = pServerEnumTask->QueryInterface( IID_IEnumTASK, (void **)ppEnumTASK );
      }

      pServerEnumTask->Release();
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::OnTaskPadAddClient

Respond to the Add Client taskpad command.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::OnTaskPadAddClient(
                    IDataObject * pDataObject
                  , VARIANT * pvarg
                  , VARIANT * pvparam
                  )
{
   ATLTRACE(_T("# CServerNode::OnTaskPadAddClient\n"));

   // Check for preconditions:
   HRESULT hr = CheckConnectionToServer();
   if( FAILED( hr ) )
   {
      return hr;
   }

   // Simulate a call to the OnAddNewClient message on the CClientsNode object,
   // just as if the user had clicked on Add Client.
   _ASSERTE( m_pClientsNode != NULL );

   bool bDummy;

   // The process command message will need a pointer to CSnapInObjectRoot
   CComponentData *pComponentData = GetComponentData();
   _ASSERTE( pComponentData != NULL );

   hr = m_pClientsNode->OnAddNewClient(
                       bDummy    // Not needed.
                     , pComponentData
                     );

   // ISSUE: Add code to check that count of client items in Clients collection
   // is greater than or equal to 1.
   m_fClientAdded = TRUE;

   return hr;
}


WCHAR CServerNode::m_szRootNodeBasicName[IAS_MAX_STRING];


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::CServerNode

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerNode::CServerNode( CComponentData * pComponentData )
   : CSnapinNode<CServerNode, CComponentData, CComponent>( NULL ),
     m_serverType(unknown)
{
   ATLTRACE(_T("# +++ CServerNode::CServerNode\n"));

   // Load the name of the Internet Authentication Server.
   LoadString(  _Module.GetResourceInstance(), IDS_ROOT_NODE__NAME, m_szRootNodeBasicName, IAS_MAX_STRING );

   // Check for preconditions:
   _ASSERTE( pComponentData != NULL );

   // The root node doesn't have a parent node, which is why we set
   // this to NULL above in the call to the base constructor.
   // However, the root node is owned by the unique CComponentData
   // object for this snapin.
   // Here we save a pointer to the CComponentData object which owns us.
   m_pComponentData = pComponentData;

   // The children subnodes have not yet been created.
   m_pClientsNode = NULL;

   // In IComponentData::Initialize, we are asked to inform MMC of
   // the icons we would like to use for the scope pane.
   // Here we store an index to which of these images we
   // want to be used to display this node
   m_scopeDataItem.nImage =      IDBI_NODE_SERVER_OK_CLOSED;
   m_scopeDataItem.nOpenImage =  IDBI_NODE_SERVER_OK_OPEN;

   m_bstrDisplayName = m_szRootNodeBasicName;

   // These are helper class which keep track of server information.
   m_pConnectionToServer = NULL;
   m_pServerStatus = NULL;

   // ISSUE: These will need to be read in from the server data object.
   m_fClientAdded = FALSE;
   m_fLoggingConfigured = FALSE;

   m_hNT4Admin = INVALID_HANDLE_VALUE;

   m_eIsSetupDSACLTaskValid = IsSetupDSACLTaskValid_NEED_CHECK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::~CServerNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerNode::~CServerNode()
{
   ATLTRACE(_T("# --- CServerNode::~CServerNode\n"));

   // Check for preconditions:
   // None.

   // Delete children nodes
   delete m_pClientsNode;

   if( NULL != m_pConnectionToServer )
   {
      m_pConnectionToServer->Release();
   }

   if( NULL != m_pServerStatus )
   {
      m_pServerStatus->Release();
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::CheckConnectionToServer

Use this to check that the connection to the server is up before you do
anything with SDO pointers.

Parameters

  BOOL fVerbose  - set this to TRUE if you want messages output to user.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CServerNode::CheckConnectionToServer( BOOL fVerbose )
{
   ATLTRACE(_T("# CServerNode::CheckConnectionToServer\n"));

   if( NULL == m_pConnectionToServer )
   {
      if( fVerbose )
      {
         ShowErrorDialog( NULL, IDS_ERROR__NO_CONNECTION_ATTEMPTED, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      }
      return RPC_E_DISCONNECTED;
   }

   switch( m_pConnectionToServer->GetConnectionStatus() )
   {
   case NO_CONNECTION_ATTEMPTED:
      if( fVerbose )
      {
         ShowErrorDialog( NULL, IDS_ERROR__NO_CONNECTION_ATTEMPTED, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      }
      return RPC_E_DISCONNECTED;
      break;
   case CONNECTING:
      if( fVerbose )
      {
         ShowErrorDialog( NULL, IDS_ERROR__CONNECTION_IN_PROGRESS, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      }
      return RPC_E_DISCONNECTED;
      break;
   case CONNECTED:
      return S_OK;
      break;
   case CONNECTION_ATTEMPT_FAILED:
      if( fVerbose )
      {
         ShowErrorDialog( NULL, IDS_ERROR__CONNECTION_ATTEMPT_FAILED, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      }
      return RPC_E_DISCONNECTED;
      break;
   case CONNECTION_INTERRUPTED:
      if( fVerbose )
      {
         ShowErrorDialog( NULL, IDS_ERROR__CONNECTION_INTERRUPTED, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      }
      return RPC_E_DISCONNECTED;
      break;
   default:
      // We shouldn't get here.
      _ASSERTE( FALSE );
      return E_FAIL;
      break;
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::CreatePropertyPages

See CSnapinNode::CreatePropertyPages (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CServerNode::CreatePropertyPages (
                             LPPROPERTYSHEETCALLBACK pPropertySheetCallback
                           , LONG_PTR hNotificationHandle
                           , IUnknown* pUnknown
                           , DATA_OBJECT_TYPES type
                           )
{
   ATLTRACE(_T("# CServerNode::CreatePropertyPages\n"));

   // Check for preconditions:
   _ASSERTE( pPropertySheetCallback != NULL );

   HRESULT hr = S_OK;

   if( type == CCT_SCOPE )
   {
      BOOL  bIASInstalled = TRUE;
      hr = IfServiceInstalled(m_bstrServerAddress, _T("IAS"), &bIASInstalled);

      if(hr == S_OK && !bIASInstalled)
      {
         if (IsNt4Server())
         {
            hr = StartNT4AdminExe();
            if (FAILED(hr))
            {
               ::CString           strText;
               ::CString           strTemp;

               ShowErrorDialog( NULL, IDS_ERROR_START_NT4_ADMIN, NULL, hr, 0, GetComponentData()->m_spConsole  );
            }
         }
         else
         {
            ShowErrorDialog( NULL, IDS_ERROR__NO_IAS_INSTALLED, NULL, S_OK, 0, GetComponentData()->m_spConsole );
         }

         return E_FAIL;
      }

      // _ASSERTE( m_spSdo != NULL ); We check for this below if call to CoMarshalInterThreadInterfaceInStream fails.

      hr = CheckConnectionToServer();
      if( FAILED( hr ) )
      {
         if (IsNt4Server())
         {
            hr = StartNT4AdminExe();
            if (FAILED(hr))
            {
               ::CString           strText;
               ::CString           strTemp;

               ShowErrorDialog( NULL, IDS_ERROR_START_NT4_ADMIN, NULL, hr, 0, GetComponentData()->m_spConsole  );
            }
         }
         return hr;
      }

      // We are being asked for normal properties on this node.

      TCHAR lpszTab1Name[IAS_MAX_STRING];
      TCHAR lpszTab2Name[IAS_MAX_STRING];
      TCHAR lpszTab3Name[IAS_MAX_STRING];
      int nLoadStringResult;

      // Load property page tab name from resource.
      nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_MACHINE_PAGE1__TAB_NAME, lpszTab1Name, IAS_MAX_STRING );
      _ASSERT( nLoadStringResult > 0 );

      // This page will take care of deleting itself when it
      // receives the PSPCB_RELEASE message.

      // Note: The name supplied here in lpszTab1Name will not be copied
      // until we do Create, so we can't just re-use this string
      // for another tab's title or the first title will get clobbered.
      // We specify TRUE for the bOwnsNotificationHandle parameter so that this page's destructor will be
      // responsible for freeing the notification handle.  Only one page per sheet should do this.
      CServerPage1 * pServerPage1 = new CServerPage1( hNotificationHandle, lpszTab1Name, TRUE );

      if( NULL == pServerPage1 )
      {
         ATLTRACE(_T("***FAILED***: CServerNode::CreatePropertyPages -- Couldn't create property pages\n"));
         return E_OUTOFMEMORY;
      }

      // Load property page tab name from resource.
      nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_MACHINE_PAGE2__TAB_NAME, lpszTab2Name, IAS_MAX_STRING );
      _ASSERT( nLoadStringResult > 0 );

      // This page will take care of deleting itself when it
      // receives the PSPCB_RELEASE message.
      CServerPage2 * pServerPage2 = new CServerPage2( hNotificationHandle, lpszTab2Name );

      if( NULL == pServerPage2 )
      {
         ATLTRACE(_T("***FAILED***: CServerNode::CreatePropertyPages -- Couldn't create property pages\n"));

         // Clean up the first page we created.
         delete pServerPage1;

         return E_OUTOFMEMORY;
      }

      // Load property page tab name from resource.
      nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_MACHINE_PAGE3__TAB_NAME, lpszTab3Name, IAS_MAX_STRING );
      _ASSERT( nLoadStringResult > 0 );

      // This page will take care of deleting itself when it
      // receives the PSPCB_RELEASE message.
      CServerPage3 * pServerPage3 = new CServerPage3( hNotificationHandle, lpszTab3Name );

      if( NULL == pServerPage3 )
      {
         ATLTRACE(_T("***FAILED***: CServerNode::CreatePropertyPages -- Couldn't create property pages\n"));

         // Clean up the first page we created.
         delete pServerPage1;
         delete pServerPage2;
         return E_OUTOFMEMORY;
      }

      // Marshall the ISdo pointer so that the property page, which
      // runs in another thread, can unmarshall it and use it properly.
      hr = CoMarshalInterThreadInterfaceInStream(
                    IID_ISdo                 //Reference to the identifier of the interface
                  , m_spSdo                  //Pointer to the interface to be marshaled
                  , &( pServerPage1->m_pStreamSdoMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
                  );

      if( FAILED( hr ) )
      {
         delete pServerPage1;
         delete pServerPage2;
         delete pServerPage3;

         ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, 0, GetComponentData()->m_spConsole  );

         return E_FAIL;
      }

      // Marshall the ISdo pointer so that the property page, which
      // runs in another thread, can unmarshall it and use it properly.
      hr = CoMarshalInterThreadInterfaceInStream(
                    IID_ISdo                 //Reference to the identifier of the interface
                  , m_spSdo                  //Pointer to the interface to be marshaled
                  , &( pServerPage2->m_pStreamSdoMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
                  );

      if( FAILED( hr ) )
      {
         delete pServerPage1;
         delete pServerPage2;
         delete pServerPage3;

         ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, 0, GetComponentData()->m_spConsole );

         return E_FAIL;
      }

      // Marshall the ISdo pointer so that the property page, which
      // runs in another thread, can unmarshall it and use it properly.
      hr = CoMarshalInterThreadInterfaceInStream(
              IID_ISdo                 //Reference to the identifier of the interface
            , m_spSdo                  //Pointer to the interface to be marshaled
            , &( pServerPage3->m_pStreamSdoMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
            );

      if( FAILED( hr ) )
      {
         delete pServerPage1;
         delete pServerPage2;
         delete pServerPage3;

         ShowErrorDialog(
            NULL,
            IDS_ERROR__NO_SDO,
            NULL,
            hr,
            0,
            GetComponentData()->m_spConsole
            );

         return E_FAIL;
      }

      CComPtr<ISdo> tmp;
      hr = ::SDOGetSdoFromCollection(
                m_spSdo,
                PROPERTY_IAS_REQUESTHANDLERS_COLLECTION,
                PROPERTY_COMPONENT_ID,
                IAS_PROVIDER_MICROSOFT_NTSAM_NAMES,
                &tmp
                );

      // If the SDO doesn't exist, we'll assume that we're connected to a
      // Whistler machine, and we won't display the realms page.
      bool showPage3 = SUCCEEDED(hr);


      // Add the pages to the MMC property sheet.
      hr = pPropertySheetCallback->AddPage( pServerPage1->Create() );
      _ASSERT( SUCCEEDED( hr ) );

      hr = pPropertySheetCallback->AddPage( pServerPage2->Create() );
      _ASSERT( SUCCEEDED( hr ) );

      if (showPage3)
      {
         hr = pPropertySheetCallback->AddPage( pServerPage3->Create() );
         _ASSERT( SUCCEEDED( hr ) );
      }
      else
      {
         delete pServerPage3;
      }

      // Add a synchronization object which makes sure we only commit data
      // when all pages are OK with their data.
      CSynchronizer * pSynchronizer = new CSynchronizer();
      _ASSERTE( pSynchronizer != NULL );

      // Hand the sycnchronizer off to the pages.
      pServerPage1->m_pSynchronizer = pSynchronizer;
      pSynchronizer->AddRef();

      pServerPage2->m_pSynchronizer = pSynchronizer;
      pSynchronizer->AddRef();

      if (showPage3)
      {
         pServerPage3->m_pSynchronizer = pSynchronizer;
         pSynchronizer->AddRef();
      }
   }
   else
   {
      if( type == CCT_SNAPIN_MANAGER )
      {
         // We are being called from the snapin manager.

         TCHAR szWizardName[IAS_MAX_STRING];
         TCHAR szWizardSubTitle[IAS_MAX_STRING];
         TCHAR szWizardTitle[IAS_MAX_STRING];

         // Load wizard page title name from resource.
         int nLoadStringResult = LoadString(
                                    _Module.GetResourceInstance(),
                                    IDS_TASKPAD_SERVER__TITLE,
                                    szWizardName,
                                    IAS_MAX_STRING
                                    );
         _ASSERT( nLoadStringResult > 0 );

         // Load wizard page title name from resource.
         nLoadStringResult = LoadString(
                                _Module.GetResourceInstance(),
                                IDS_CONNECT_TO_SERVER_WIZPAGE__TITLE,
                                szWizardTitle,
                                IAS_MAX_STRING
                                );
         _ASSERT( nLoadStringResult > 0 );

         // Load wizard page title name from resource.
         nLoadStringResult = LoadString(
                                _Module.GetResourceInstance(),
                                IDS_ABOUT__SNAPIN_DESCRIPTION,
                                szWizardSubTitle,
                                IAS_MAX_STRING
                                );
         _ASSERT( nLoadStringResult > 0 );

         // This page will take care of deleting itself when it
         // receives the PSPCB_RELEASE message.
         CConnectToServerWizardPage1* pConnectToServerWizardPage1
                 = new CConnectToServerWizardPage1(hNotificationHandle,
                                                   szWizardName,
                                                   TRUE);

         if( NULL == pConnectToServerWizardPage1 )
         {
            ATLTRACE(_T("***FAILED***: CServerNode::CreatePropertyPages -- Couldn't create property pages\n"));
            return E_OUTOFMEMORY;
         }

         pConnectToServerWizardPage1->SetTitles(szWizardTitle, szWizardSubTitle);

         pConnectToServerWizardPage1->m_pServerNode = this;

         hr = pPropertySheetCallback->AddPage( pConnectToServerWizardPage1->Create() );
         _ASSERT( SUCCEEDED( hr ) );
      }
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::QueryPagesFor

See CSnapinNode::CreatePropertyPages (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CServerNode::QueryPagesFor ( DATA_OBJECT_TYPES type )
{
   ATLTRACE(_T("# CServerNode::QueryPagesFor\n"));

   // Check for preconditions:
   // None.

   // we have property pages
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::StartStopService

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::StartStopService( BOOL bStart )
{
   ATLTRACE(_T("# CServerNode::StartService\n"));

   // Check for preconditions:
   HRESULT hr = CheckConnectionToServer();
   if( FAILED( hr ) )
   {
      return hr;
   }
   if( ! m_spSdo )
   {
      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, S_OK, 0, GetComponentData()->m_spConsole  );
      return S_FALSE;
   }
   if( ! m_pServerStatus )
   {
      return S_FALSE;
   }

   m_pServerStatus->StartServer( bStart );
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::IsServerRunning

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerNode::IsServerRunning( void )
{
   if( m_pServerStatus != NULL )
   {
      LONG lServerStatus = m_pServerStatus->GetServerStatus();

      if(   lServerStatus == SERVICE_RUNNING
         || lServerStatus == SERVICE_START_PENDING
         || lServerStatus == SERVICE_CONTINUE_PENDING
         )
      {
         return TRUE;
      }
   }

   return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::IsServerRunning

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerNode::CanStartServer( void )
{
   if( m_pServerStatus != NULL )
   {
      LONG lServerStatus = m_pServerStatus->GetServerStatus();

      if(      lServerStatus == SERVICE_STOPPED
//       || lServerStatus == SERVICE_PAUSED
//       || lServerStatus == SERVICE_STOP_PENDING
         )
      {
         return TRUE;
      }
   }

   return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::IsServerRunning

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerNode::CanStopServer( void )
{
   if( m_pServerStatus != NULL )
   {
      LONG lServerStatus = m_pServerStatus->GetServerStatus();

      if(      lServerStatus == SERVICE_RUNNING
//          || lServerStatus == SERVICE_START_PENDING
//          || lServerStatus == SERVICE_CONTINUE_PENDING
//          || lServerStatus == SERVICE_PAUSE_PENDING
//          || lServerStatus == SERVICE_PAUSED
         )
      {
         return TRUE;
      }
   }

   return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::RefreshServerStatus

Gets called both by member functions of CServerNode as well as by the
OnReceiveThreadNotification method of CServerStatus when we should
update the service status we are displaying for our server node.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::RefreshServerStatus( void )
{
   ATLTRACE(_T("# CServerNode::RefreshServerStatus\n"));

   // Check for preconditions:
   if( m_spSdo == NULL )
   {
      return S_FALSE;
   }

   HRESULT hr;
   CComBSTR bstrError;

   // We will need this below.
   CComponentData * pComponentData = GetComponentData();
   _ASSERTE( pComponentData != NULL );
   _ASSERTE( pComponentData->m_spConsole != NULL );

   if( NULL == m_pServerStatus )
   {
      // We try to create a new CServerStatus object to
      // help us keep track of the state of the server.

      // Get the ISdoServiceControl interface on the SDO we have.
      CComQIPtr<ISdoServiceControl, &IID_ISdoServiceControl> spSdoServiceControl(m_spSdo);
      _ASSERTE( spSdoServiceControl != NULL );

      m_pServerStatus = new CServerStatus( this, spSdoServiceControl );
      if( NULL == m_pServerStatus )
      {
         ShowErrorDialog( NULL, IDS_ERROR__OUT_OF_MEMORY, NULL, S_OK, 0, pComponentData->m_spConsole );
         return E_OUTOFMEMORY;
      }

      // It uses COM-style lifetime management.
      m_pServerStatus->AddRef();

      // Create a (currently invisible) modeless dialog which will
      // be used later when we want to start or stop the server
      // as a message sink within the main MMC thread for
      // messages from our worker thread.

      HWND hWndMainWindow;

      hr = pComponentData->m_spConsole->GetMainWindow( &hWndMainWindow );
      _ASSERTE( SUCCEEDED( hr ) );
      _ASSERTE( NULL != hWndMainWindow );

      // This does not put the window up, it only creates the server status object.
      HWND hWndStartStopDialog = m_pServerStatus->Create( hWndMainWindow );

      if( NULL == hWndStartStopDialog )
      {
         // Error -- couldn't create window.
         return E_FAIL;
      }

      // We should have this pointer by now.
      _ASSERTE( m_pServerStatus != NULL );
      m_pServerStatus->UpdateServerStatus();
   }

   // We want to make sure all views get updated.
   CChangeNotification *pChangeNotification = new CChangeNotification();
   pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE;
   hr = pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
   pChangeNotification->Release();

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
LPOLESTR CServerNode::GetResultPaneColInfo(int nCol)
{
   ATLTRACE(_T("# CServerNode::GetResultPaneColInf\n"));

   // Check for preconditions:
   // None.

// if (nCol == 0)
   {
      return m_bstrDisplayName;
   }

   // TODO : Return the text for other columns
   return OLESTR("Running");
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::SetServerAddress

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::SetServerAddress( LPCWSTR szServerAddress )
{
  ATLTRACE(L"# CServerNode::SetServerAddress\n");

   // Load the name of the Internet Authentication Server.
   WCHAR szName[IAS_MAX_STRING];
   int nLoadStringResultName = LoadStringW(
                                             _Module.GetResourceInstance(),
                                             IDS_ROOT_NODE__NAME,
                                             szName,
                                             IAS_MAX_STRING
                                          );
   _ASSERT( nLoadStringResultName > 0 );

   // Load some stock strings.
   WCHAR szPreMachineName[IAS_MAX_STRING];
   int nLoadStringResultPre = LoadStringW(
                                            _Module.GetResourceInstance(),
                                            IDS_ROOT_NODE__PRE_MACHINE_NAME,
                                            szPreMachineName,
                                            IAS_MAX_STRING
                                         );
   _ASSERT( nLoadStringResultPre > 0 );

   WCHAR szLocal[IAS_MAX_STRING];
   int nLoadStringResultLocal = LoadStringW(
                                              _Module.GetResourceInstance(),
                                              IDS_ROOT_NODE__LOCAL_WORD,
                                              szLocal,
                                              IAS_MAX_STRING
                                           );
   _ASSERT( nLoadStringResultLocal > 0 );

   WCHAR szPostMachineName[IAS_MAX_STRING];
   int nLoadStringResultPost = LoadStringW(
                                             _Module.GetResourceInstance(),
                                             IDS_ROOT_NODE__POST_MACHINE_NAME,
                                             szPostMachineName,
                                             IAS_MAX_STRING
                                          );
   _ASSERT( nLoadStringResultPost > 0 );

   // Add whatever text should appear before the machine name.
   int maxSize = nLoadStringResultName +
                 nLoadStringResultPre +
                 nLoadStringResultPost;

   if ( maxSize >= IAS_MAX_STRING )
   {
      return E_FAIL;
   }

   wcscat( szName, szPreMachineName );

   // Add the text to appear for the machine name.
   if( m_bConfigureLocal )
   {
      maxSize += nLoadStringResultLocal;

      if ( maxSize >= IAS_MAX_STRING )
      {
         return E_FAIL;
      }

      wcscat( szName, szLocal );
   }
   else
   {
      maxSize += wcslen(szServerAddress);
      if ( maxSize >= IAS_MAX_STRING )
      {
         return E_FAIL;
      }

      wcscat( szName, szServerAddress );
   }

   // Add whatever text should appear after the machine name.
   wcscat( szName, szPostMachineName );

   m_bstrDisplayName = szName;
   m_bstrServerAddress = szServerAddress;

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::BeginConnectAction


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::BeginConnectAction( void )
{
   ATLTRACE(_T("# CServerNode::BeginConnectAction\n"));

   // Check for preconditions:
   // None.

   HRESULT hr;

   if( NULL != m_pConnectionToServer )
   {
      // Already begun.
      return S_FALSE;
   }

   m_pConnectionToServer = new CConnectionToServer( this, m_bConfigureLocal, m_bstrServerAddress );
   if( NULL == m_pConnectionToServer )
   {
      ShowErrorDialog( NULL, IDS_ERROR__OUT_OF_MEMORY, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      return E_OUTOFMEMORY;
   }

   m_pConnectionToServer->AddRef();

   // This starts the connect action off in another thread.

   CComponentData * pComponentData = GetComponentData();
   _ASSERTE( pComponentData != NULL );
   _ASSERTE( pComponentData->m_spConsole != NULL );

   HWND hWndMainWindow;

   hr = pComponentData->m_spConsole->GetMainWindow( &hWndMainWindow );
   _ASSERTE( SUCCEEDED( hr ) );
   _ASSERTE( NULL != hWndMainWindow );

   // This modeless dialog will take care of calling InitSdoPointers
   // when it is notified by the worker thread it creates that
   // the connect action got an SDO pointer.
   HWND hWndConnectDialog = m_pConnectionToServer->Create( hWndMainWindow );

   if( ! hWndConnectDialog )
   {
      // Error -- couldn't create window.
      ShowErrorDialog( NULL, 0, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      return E_FAIL;
   }

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::LoadCachedInfoFromSdo

Causes this node and its children to re-read all their cached info from
the SDO's.  Call if you change something and you want to make sure that
the display reflects this change.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::LoadCachedInfoFromSdo( void )
{
   ATLTRACE(_T("# CServerNode::LoadCachedInfoFromSdo\n"));

   // Check for preconditions:

   HRESULT hr = m_pClientsNode->LoadCachedInfoFromSdo();
   // Ignore failed HRESULT.

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++
CServerNode::SetIconMode
--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT  CServerNode::SetIconMode(HSCOPEITEM scopeId, IconMode mode)
{
      // Check for preconditions:
   CComponentData *pComponentData  = GetComponentData();
   _ASSERTE( pComponentData != NULL );
   _ASSERTE( pComponentData->m_spConsole != NULL );


   // Change the icon for the scope node from being normal to a busy icon.
   CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > spConsoleNameSpace( pComponentData->m_spConsole );

   SCOPEDATAITEM sdi;
   sdi.mask = SDI_IMAGE | SDI_OPENIMAGE;
   sdi.nImage = IDBI_NODE_SERVER_OK_CLOSED;
   sdi.nOpenImage = IDBI_NODE_SERVER_OK_OPEN;
   sdi.ID = scopeId;

   switch(mode)
   {
   case  IconMode_Normal:
      break;

   case  IConMode_Busy:
      sdi.nImage = IDBI_NODE_SERVER_BUSY_CLOSED;
      sdi.nOpenImage = IDBI_NODE_SERVER_BUSY_OPEN;
      break;

   case  IConMode_Error:
      sdi.nImage = IDBI_NODE_SERVER_ERROR_CLOSED;
      sdi.nOpenImage = IDBI_NODE_SERVER_ERROR_OPEN;

      break;

   }

   spConsoleNameSpace->SetItem( &sdi );

   pComponentData->m_spConsole->UpdateAllViews( NULL, 0, 0 );

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::OnExpand

The root node in MMC is a special node because it is never inserted into the
scope or result pane using InsertItem.  MMC automatically assumes this node
exists for stand-alone snapins and this node is special-cased in the
the ATL notification handlers e.g.

      if (cookie == NULL)
         return m_pNode->GetDataObject(ppDataObject);

Because this node is never added using InsertItem, we never get a chance
to assign it an HSCOPEITEM ID in its m_scopeDataItem member variable.

When inserting items, we need to provide the parent's HSCOPEITEM.
We have no trouble inserting children when responding to MMCN_EXPAND
messages because there the parent's HSCOPEITEM is handed to it in the
'param' argument, Unfortunately, we sometimes need to add children at
other times than in response to the MMCN_EXPAND message.

For this reason, we intercept the MMCN_EXPAND message for the CServerNode
and save away its HSCOPEITEM for later use.

For more information, see CSnapinNode::OnExpand which this method overrides.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::OnExpand(
                    LPARAM arg
                  , LPARAM param
                  , IComponentData * pComponentData
                  , IComponent * pComponent
                  , DATA_OBJECT_TYPES type
                  )
{
   ATLTRACE(_T("# CServerNode::OnExpand\n"));

   // Check for preconditions:
   _ASSERTE( pComponentData != NULL || pComponent != NULL );
   // _ASSERTE( m_spSdo != NULL );  We check for this later, just before needed.

   HRESULT hr = S_FALSE;
   BOOL  bIASInstalled = FALSE;
   UINT  nErrId = 0;

   SetIconMode((HSCOPEITEM) param, IConMode_Busy);
   hr = IfServiceInstalled(m_bstrServerAddress, _T("IAS"), &bIASInstalled);
   if(hr == S_OK)
   {
      SetIconMode((HSCOPEITEM) param, IconMode_Normal);
      if(!bIASInstalled)
      {
         nErrId = IDS_ERROR__NO_IAS_INSTALLED;
         BOOL  bShowErr = TRUE;

         // maybe because it's NT4 server
         if (IsNt4Server())
         {
            hr = StartNT4AdminExe();

            if (FAILED(hr))
               nErrId = IDS_ERROR_START_NT4_ADMIN;
            else
               bShowErr = FALSE;
         }

         if (bShowErr)
         {
            ShowErrorDialog( NULL, nErrId, NULL, hr, 0, GetComponentData()->m_spConsole);
            // set icon
            SetIconMode((HSCOPEITEM) param, IConMode_Error);
         }
      }
   }
   else
   {
      SetIconMode((HSCOPEITEM) param, IConMode_Error);
   }

   // Save our HSCOPEITEM
   m_scopeDataItem.ID = (HSCOPEITEM) param;

   if( TRUE == arg && bIASInstalled && hr == S_OK)
   {
      // We are expanding.

      // We'll need a valid IConsole pointer below.
      CComPtr<IConsole> spConsole;
      if( pComponentData != NULL )
      {
          spConsole = ((CComponentData*)pComponentData)->m_spConsole;
      }
      else
      {
         // We should have a non-null pComponent
          spConsole = ((CComponent*)pComponent)->m_spConsole;
      }
      _ASSERTE( spConsole != NULL );

      // Try to create the children of this Machine node

      if( NULL == m_pClientsNode )
      {
         m_pClientsNode = new CClientsNode( this );

         if( NULL == m_pClientsNode )
         {
            ShowErrorDialog( NULL, IDS_ERROR__OUT_OF_MEMORY, NULL, S_OK, 0, spConsole  );

            // Clean up.

            return E_OUTOFMEMORY;
         }
      }

      // Make sure we have begun our connect action to the SDO's.
      // We defer this until this point, when the user actually needs the SDO's.
      // It is best to do this here rather than trying to do this sooner
      // in the "Connect" wizard, since that code will never get executed if
      // we run from a saved .msc file.
      hr = BeginConnectAction();
      _ASSERTE( SUCCEEDED( hr ) );

      // show the children nodes to the world

      // Need IConsoleNameSpace

      CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
      _ASSERT( spConsoleNameSpace != NULL );

      // For CClientsNode:

      // This was done in MeanGene's Step 3 -- I'm guessing MMC wants this filled in
      m_pClientsNode->m_scopeDataItem.relativeID = (HSCOPEITEM) param;

      hr = spConsoleNameSpace->InsertItem( &(m_pClientsNode->m_scopeDataItem) );

      // On return, the ID member of m_scopeDataItem should
      // contain HSCOPEITEM handle to the newly inserted item.
      _ASSERT( NULL != m_pClientsNode->m_scopeDataItem.ID );
   }
   else  // arg != TRUE so not expanding
   {
      // do nothing for now -- I don't think arg = FALSE is even implemented
      // for MMC v. 1.0 or 1.1
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::DoRefresh

--*/
//////////////////////////////////////////////////////////////////////////////

// called to refresh the nodes
HRESULT  CServerNode::DataRefresh()
{
   // there should be already something in SDO
   ASSERT(m_spSdo);

   // reload SDO
   m_spSdo.Release();

   HRESULT hr = m_pConnectionToServer->ReloadSdo(&m_spSdo);

   // refresh client node
   if(hr == S_OK)
   {
      hr = m_pClientsNode->DataRefresh(m_spSdo);
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::OnRefresh

For more information, see CSnapinNode::OnRefresh which this method overrides.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::OnRefresh(
                    LPARAM arg
                  , LPARAM param
                  , IComponentData * pComponentData
                  , IComponent * pComponent
                  , DATA_OBJECT_TYPES type
                  )
{
   ATLTRACE(_T("# CServerNode::OnRefresh\n"));

   // Check for preconditions:
   //_ASSERTE( pComponentData != NULL || pComponent != NULL );

   HRESULT hr = LoadCachedInfoFromSdo();
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::OnSelect

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::OnSelect(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   ATLTRACE(_T("# CSnapinNode::OnSelect\n"));

   _ASSERTE( pComponentData != NULL || pComponent != NULL );

   HRESULT hr = S_FALSE;

   hr = CSnapinNode< CServerNode, CComponentData, CComponent >::OnSelect(arg, param, pComponentData, pComponent, type);

   BOOL bSelect = (BOOL) HIWORD(arg);

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::OnShow

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::OnShow(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   ATLTRACE(_T("# CSnapinNode::OnSelect\n"));

   _ASSERTE( pComponentData != NULL || pComponent != NULL );

   HRESULT hr = S_FALSE;

   hr = CSnapinNode< CServerNode, CComponentData, CComponent >::OnShow(arg, param, pComponentData, pComponent, type);

   if (FAILED(hr)) return hr;

   BOOL bSelected = (BOOL) ( arg );

   if( bSelected && pComponent)
   {
      CComPtr<IMessageView>  spMessageView;
      CComPtr<IUnknown>      spUnknown;
      CComPtr<IConsole>      spConsole;
      LPOLESTR               pText = NULL;
      UINT                   uTextIds[] = {IDS_TEXT_SERVERNODE_DESC_TITLE, \
                                           Icon_Information,
                                           IDS_TEXT_SERVERNODE_DESC_TEXT1,
                                           IDS_TEXT_SERVERNODE_DESC_TEXT2,
                                           IDS_TEXT_SERVERNODE_DESC_TEXT3,
                                           IDS_TEXT_SERVERNODE_DESC_TEXT4,
                                           0};
      ::CString            strTemp;
      ::CString            strText;

      // We should have a non-null pComponent
       spConsole = ((CComponent*)pComponent)->m_spConsole;

      // 354294   1     mashab   DCR IAS: needs Welcome message and
      // explantation of IAS application in the right pane
      hr = spConsole->QueryResultView(&spUnknown);

      if (FAILED(hr)) goto Err;

      hr = spUnknown->QueryInterface(IID_IMessageView, (void**)&spMessageView);
      if (FAILED(hr)) goto Err;

        // set the title text
      strText.LoadString(uTextIds[0]);

      pText = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR) * (strText.GetLength() + 1));
      if (pText)
      {
         lstrcpy (pText, strText);
         hr = spMessageView->SetTitleText(pText);

         if (FAILED(hr))
            goto Err;
      }

      // set the icon
      hr = spMessageView->SetIcon((IconIdentifier)uTextIds[1]);

      if (FAILED(hr))
         goto Err;

        // set the body text
      strText = _T("");
      if (IsNt4Server())
      {
#ifdef _WIN64
         AfxFormatString1(
            strText,
            IDS_INFO_NO_DOWNLEVEL_ON_WIN64,
            m_bstrServerAddress
            );
#else
         strTemp.LoadString(IDS_INFO_USE_NT4_ADMIN);
         strText.Format(strTemp, m_bstrServerAddress);
#endif
      }
      else
      {
         for (unsigned int i = 2; uTextIds[i] != 0; i++)
         {
            strTemp.LoadString(uTextIds[i]);
            strText += strTemp;
         }
       }

      // 354294   1     mashab   DCR IAS: needs Welcome message and
      // explantation of IAS application in the right pane
      pText = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR) * (strText.GetLength() + 1));
      if (pText)
      {
         lstrcpy (pText, strText);
         hr = spMessageView->SetBodyText(pText);

         if (FAILED(hr))
            goto Err;
      }

Err:
   ;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::InitSdoPointers

Called by the CConnectionToServer worker thread class when it finished it's task of
connecting up to the SDO.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::InitSdoPointers(void)
{
   ATLTRACE(_T("# CServerNode::InitSdoPointers\n"));

   // Check for preconditions:
   _ASSERTE( m_pClientsNode != NULL );

   if( NULL == m_pConnectionToServer )
   {
      return S_FALSE;
   }

   if( CONNECTED != m_pConnectionToServer->GetConnectionStatus() )
   {
      return S_FALSE;
   }

   // Make sure this is NULL before we try to set it.
   m_spSdo = NULL;
   HRESULT hr = m_pConnectionToServer->GetSdoServer( &m_spSdo );

   if( FAILED( hr ) || m_spSdo == NULL )
   {
      return hr;
   }

   // We must manually AddRef here because we just copied a pointer
   // into our smart pointer and the smart pointer won't catch that.
// WEI_TRY
// m_spSdo->AddRef();

   // If we got here, we should be good to go.

   // Store the correct SDO pointers into their respective nodes.

   m_pClientsNode->InitSdoPointers( m_spSdo );

   // Refresh the currently displayed status of the server.
   RefreshServerStatus();

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
   ATLTRACE(_T("# CServerNode::SetVerbs\n"));

   // Check for preconditions:
   _ASSERTE( pConsoleVerb != NULL );

   HRESULT hr = S_OK;

   // We want the user to be able to choose Properties on this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

   // We want the default verb to be Properties
   hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );

   // We want the user to be able to choose Refresh on this node.
   // The refresh verb will attempt to make sure that the
   // connection to the server is valid.

   // Our Refresh method is not needed now that our Connect thread
   // knows how to send a message to a window owned by the main thread.
   // Also calling OnRefresh for the server would allow the user to
   // repeatedly call InitSdoPointer.  This should be harmless,
   // but it was having unpleasant side effects which we didn't have
   // time to investigate.
   // hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );

   // hr = pConsoleVerb->SetVerbState( MMC_VERB_OPEN, ENABLED, TRUE );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::OnStartServer

Called when the Start Server context menu item or toolbar button is clicked.

pUnknown is either an IExtendControlbar or an IExtendContextMenu interface pointer.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::OnStartServer( bool &bHandled, CSnapInObjectRootBase* pObj )
{
   ATLTRACE(_T("# CServerNode::OnStartServer\n"));

   // Check for preconditions:
   // None.

   HRESULT hr = StartStopService( TRUE );

   bHandled = TRUE;

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::OnStopServer

Called when the Stop Server context menu item or toolbar button is clicked.

pUnknown is either an IExtendControlbar or an IExtendContextMenu interface pointer.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::OnStopServer( bool &bHandled, CSnapInObjectRootBase* pObj )
{
   ATLTRACE(_T("# CServerNode::OnStopServer\n"));

   // Check for preconditions:
   // None.

   HRESULT hr = StartStopService( FALSE );

   bHandled = TRUE;

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData * CServerNode::GetComponentData( void )
{
   ATLTRACE(_T("# CServerNode::GetComponentData\n"));

   // Check for preconditions:
   // None.

   return m_pComponentData;
}


//////////////////////////////////////////////////////////////////////////////
/*++

BOOL IsSetupDSACLTaskValid()

Called to see whether the DSACL Setup Task is valid for the server we are
administering.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerNode::IsSetupDSACLTaskValid()
{

#if 1 // Use ServerInfoSdo

   BOOL bResult = FALSE;
   HRESULT hr;

   try
   {
      // Check the domain type for this machine.
      CComPtr<ISdoMachine>    spMachineSdo;
      hr = ::CoCreateInstance(
                CLSID_SdoMachine,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_ISdoMachine,
                (LPVOID *) &spMachineSdo
                );

      if( FAILED(hr) || spMachineSdo == NULL )
      {
         ATLTRACE(L"CoCreateInstance(Machine) failed: %ld", hr);
         throw hr;
      }

      hr = spMachineSdo->Attach(m_bstrServerAddress);
      if ( FAILED(hr) )
      {
         ATLTRACE(L"ISdoMachine::Attach failed.");
         throw hr;
      }

      IASDOMAINTYPE serverDomainType;
      hr = spMachineSdo->GetDomainType(&serverDomainType);
      if ( FAILED(hr) )
      {
         ATLTRACE(L"ISdoMachine::GetDomainType failed.");
         throw hr;
      }

      if ( serverDomainType == DOMAIN_TYPE_NT5 ||
           serverDomainType == DOMAIN_TYPE_MIXED )
      {
         bResult = TRUE;
      }
   }
   catch(...)
   {
      // Do nothing.  We fail silently by falling through and returning FALSE.
   }

   return bResult;

#else // Don't use ServerInfoSdo

   BOOL bAnswer = FALSE;

   PDOMAIN_CONTROLLER_INFO pdciInfo = NULL;

   // We use Run-time dynamic linking here so that we will still
   // regsvr32 on Nt4 systems without the DsGetDcName entry point in netapi32.
   // Load the DLL which has the functionality we will need.
   HINSTANCE hiDsModule = LoadLibrary(L"netapi32");
   if( NULL == hiDsModule )
   {
      // If we can't find this dll, then we are probably not on a system with Active Directory.
      return FALSE;
   }

   // Find the function we want to use to see if we are in an NT5 DS.
   DSGETDCNAMEW pfnDsGetDcNameW = (DSGETDCNAMEW) GetProcAddress(
                                                    hiDsModule,
                                                    "DsGetDcNameW"
                                                    );
   if( NULL == pfnDsGetDcNameW )
   {
      // If we can't find this entry point, then we are probably not on a system with Active Directory.
      return FALSE;
   }

   // See whether our machine is a part of an NT5 Active Directory domain.
   DWORD dwReturnValue = (*pfnDsGetDcNameW)(
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              DS_DIRECTORY_SERVICE_REQUIRED,
                              &pdciInfo
                              );

   if( dwReturnValue == NO_ERROR )
   {
      // We are a part of an Active Directory domain, so show the task.
      bAnswer = TRUE;

      // Free the dciInfo structure.
      if( NULL != pdciInfo )
      {
         NetApiBufferFree( pdciInfo );
      }
   }
   else
   {
      // We are not a part of an Active Directory domain, so don't show the task.
      bAnswer = FALSE;
   }

   FreeLibrary( hiDsModule );

   return bAnswer;

#endif // Use ServerIndoSdo
}


// Declare a function pointer that we can use for Run-time Dynamic Linking below.
typedef
DSGETDCAPI
DWORD
(*DSGETDCNAMEW)(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);


/*!--------------------------------------------------------------------------
   HrIsStandaloneServer
      Returns S_OK if the machine name passed in is a standalone server,
      or if pszMachineName is S_FALSE.

      Returns FALSE otherwise.
   Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT  HrIsStandaloneServer(LPCWSTR pMachineName)
{
   HRESULT hr = S_OK;
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdsRole = NULL;

   DWORD netRet = DsRoleGetPrimaryDomainInformation(pMachineName, DsRolePrimaryDomainInfoBasic, (LPBYTE*)&pdsRole);

   if(netRet != 0)
   {
      hr = HRESULT_FROM_WIN32(netRet);
      goto L_ERR;
   }

   ASSERT(pdsRole);

   // if the machine is not a standalone server
   if(pdsRole->MachineRole != DsRole_RoleStandaloneServer)
   {
      hr = S_FALSE;
   }

L_ERR:
   if(pdsRole)
      DsRoleFreeMemory(pdsRole);

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

BOOL ShouldShowSetupDSACL()

This method is used by the TaskPad enumerator so that it knows whether is should
should the Setup DS ACL taskpad item.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerNode::ShouldShowSetupDSACL()
{
   ATLTRACE(_T("# CServerNode::ShouldShowSetupDSACL\n"));

#if 1 // Don't call DsGetDcName, just show the items.

   BOOL bAnswer = TRUE;

   if ( m_eIsSetupDSACLTaskValid == IsSetupDSACLTaskValid_NEED_CHECK)
   {
      // if standalone server, should not setup DS ACL
      if(HrIsStandaloneServer(m_bstrServerAddress) == S_OK)
         bAnswer = FALSE;
      else
         bAnswer= IsSetupDSACLTaskValid();

      if(bAnswer)
         m_eIsSetupDSACLTaskValid = IsSetupDSACLTaskValid_VALID;
      else
         m_eIsSetupDSACLTaskValid = IsSetupDSACLTaskValid_INVALID;
   }

   if(m_eIsSetupDSACLTaskValid == IsSetupDSACLTaskValid_INVALID)
      bAnswer = FALSE;


#else // Don't call DsGetDcName, just show the items.

   BOOL bAnswer = FALSE;

   DWORD dwReturnValue;
   PDOMAIN_CONTROLLER_INFO pdciInfo = NULL;

   // We use Run-time dynamic linking here so that we will still
   // regsvr32 on Nt4 systems without the DsGetDcName entry point in netapi32.
   // Load the DLL which has the functionality we will need.
   HINSTANCE hiDsModule = LoadLibrary(L"netapi32");
   if( NULL == hiDsModule )
   {
      // If we can't find this dll, then we are probably not on a system with Active Directory.
      return FALSE;
   }


   // Find the function we want to use to see if we are in an NT5 DS.
   DSGETDCNAMEW pfnDsGetDcNameW = (DSGETDCNAMEW) GetProcAddress( hiDsModule, "DsGetDcNameW");
   if( NULL == pfnDsGetDcNameW )
   {
      // If we can't find this entry point, then we are probably not on a system with Active Directory.
      return FALSE;
   }


   // See whether our machine is a part of an NT5 Active Directory domain.
   dwReturnValue = (*pfnDsGetDcNameW)( NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED, &pdciInfo );

   if( dwReturnValue == NO_ERROR )
   {
      // We are a part of an Active Directory domain, so show the task.
      bAnswer = TRUE;

      // Free the dciInfo structure.
      if( NULL != pdciInfo )
      {
         NetApiBufferFree( pdciInfo );
      }
   }
   else
   {
      // We are not a part of an Active Directory domain, so don't show the task.
      bAnswer = FALSE;
   }

   FreeLibrary( hiDsModule );

#endif // Don't call DsGetDcName, just show the items.

   return bAnswer;
}



// Declare some function pointers that we can use for Run-time Dynamic Linking below.
typedef DWORD (*ISMACHINERASSERVERINDOMAIN)(
   IN PWCHAR pszDomain,
   IN PWCHAR pszMachine,
   OUT PBOOL pbIsRasServer
   );
typedef DWORD (*ESTABLISHCOMPUTERASDOMAINRASSERVER)(
   IN PWCHAR pszDomain,
   IN PWCHAR pszMachine,
   IN BOOL bEnable
   );


//////////////////////////////////////////////////////////////////////////////
/*++

BOOL OnTaskPadSetupDSACL()

This method is invoked when the user clicks on the Setup DS ACL task.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::OnTaskPadSetupDSACL(
           IDataObject * pDataObject
         , VARIANT * pvarg
         , VARIANT * pvparam
         )
{
   ATLTRACE(_T("# CServerNode::OnTaskPadSetupDSACL\n"));

   HCURSOR hSavedCursor;

   // Save old cursor.
   hSavedCursor = GetCursor();

   // Change cursor here to wait cursor.
   SetCursor( LoadCursor( NULL, IDC_WAIT ) );


   // Need m_spConsole for message boxes.
   CComponentData *pComponentData  = GetComponentData();
   _ASSERTE( pComponentData != NULL );
   _ASSERTE( pComponentData->m_spConsole != NULL );

   if( ! IsSetupDSACLTaskValid() )
   {
      // This machine isn't registered on a domain where this option should be supported.
      ShowErrorDialog(
                 NULL
               , IDS_ERROR__DSACL_NO_SUPPORTED_FOR_THIS_MACHINE
               , NULL
               , S_OK
               , 0
               , pComponentData->m_spConsole
               );
      return S_FALSE;
   }

   // Change cursor back to normal cursor.
   SetCursor( hSavedCursor );

   // Save old cursor.
   hSavedCursor = GetCursor();

   // Change cursor here to wait cursor.
   SetCursor( LoadCursor( NULL, IDC_WAIT ) );

   // Change cursor back to normal cursor.
   SetCursor( hSavedCursor );

   DWORD dwRetVal;
   TCHAR szMachineName[IAS_MAX_STRING];
   TCHAR * pszMachine;

   // We use Run-time dynamic linking here so that we will deal
   // gracefully with the case where API calls below are not found.
   // Load the DLL which has the functionality we will need.
   HINSTANCE hiRasModule = LoadLibrary(L"mprapi");
   if( NULL == hiRasModule )
   {
      ShowErrorDialog(
                 NULL
               , IDS_ERROR__DSACL_DLL_NOT_FOUND
               , NULL
               , S_OK
               , 0
               , pComponentData->m_spConsole
               );
      return S_FALSE;
   }


   // Make sure the machine name string is initialized.
   szMachineName[0] = NULL;
   if( m_bConfigureLocal )
   {
      DWORD dwSize = IAS_MAX_STRING;
      BOOL bRetVal = GetComputerName( szMachineName, &dwSize );
      _ASSERT( bRetVal );
   }
   else
   {
      // Remote machine.
      wcscpy( szMachineName, m_bstrServerAddress );
   }

   // Check to make sure we have a machine name.
   if( wcslen( szMachineName ) <= 0 )
   {
      ShowErrorDialog( NULL, 0, NULL, S_OK, 0, GetComponentData()->m_spConsole );
      return S_FALSE;
   }

   pszMachine = szMachineName;

   // Make sure we have no \ at beginning of our machine name.
   if( pszMachine[0]  == L'\\' )
   {
      pszMachine++;
   }
   // Could be a second one.
   if( pszMachine[0] == L'\\' )
   {
      pszMachine++;
   }


   // Find the function we want to use to see if already setup.
   ISMACHINERASSERVERINDOMAIN pfnIsMachineRasServerInDomain = (ISMACHINERASSERVERINDOMAIN) GetProcAddress( hiRasModule, "MprDomainQueryRasServer");
   if( NULL != pfnIsMachineRasServerInDomain )
   {
      BOOL bIsRasServer = FALSE;

      // Save old cursor.
      hSavedCursor = GetCursor();

      // Change cursor here to wait cursor.
      SetCursor( LoadCursor( NULL, IDC_WAIT ) );

      // Check to see if we are already setup.
      dwRetVal = (*pfnIsMachineRasServerInDomain)( NULL, pszMachine, &bIsRasServer );

      // Change cursor back to normal cursor.
      SetCursor( hSavedCursor );

      // Check using new API whether already setup and show dialog if this the case
      if( dwRetVal == NO_ERROR && bIsRasServer )
      {
         // Dialog saying already setup.
         ShowErrorDialog(
                 NULL
               , IDS_DSACL__ALREADY_SETUP
               , NULL
               , S_OK
               , IDS_INFO_TITLE__SERVER_ALREADY_REGISTERED
               , pComponentData->m_spConsole
               );
         return S_FALSE;
      }
   }

   // If we couldn't find the IsMachineRasServerInDomain entry point,
   // just keep going and try EstablishComputerAsDomainRasServer
   // -- the code below will catch any problem.

   WCHAR szDomain[ DNLEN + 1 ];
   DWORD dwDomainSize = DNLEN;
   WCHAR szMessageWithDomainName[ IAS_MAX_STRING*3 ];
   WCHAR szMessageFormatString[ IAS_MAX_STRING*2 ];
   int nLoadStringResult = LoadString( _Module.GetResourceInstance(), IDS_DSACL__THIS_WILL_SETUP, szMessageFormatString, IAS_MAX_STRING*2 );
   _ASSERT( nLoadStringResult > 0 );

   GetComputerNameEx( ComputerNameDnsDomain, szDomain, &dwDomainSize );

   swprintf( szMessageWithDomainName, szMessageFormatString, szDomain );

   CComBSTR bstrMessage = szMessageWithDomainName;

   // Display message that indicates what will take place.
   int iChoice = ShowErrorDialog(
              NULL
            , USE_SUPPLEMENTAL_ERROR_STRING_ONLY
            , bstrMessage
            , S_OK
            , IDS_DSACL__TITLE_THIS_WILL_SETUP
            , pComponentData->m_spConsole
            , MB_OKCANCEL
            );
   if( IDOK != iChoice )
   {
      return S_FALSE;
   }

   // Find the function we want to use to setup the DS ACL's.
   ESTABLISHCOMPUTERASDOMAINRASSERVER pfnEstablishComputerAsDomainRasServer = (ESTABLISHCOMPUTERASDOMAINRASSERVER) GetProcAddress( hiRasModule, "MprDomainRegisterRasServer");
   if( NULL == pfnEstablishComputerAsDomainRasServer )
   {
      ShowErrorDialog(
              NULL
            , IDS_ERROR__DSACL_ESTABLISHCOMPUTERASDOMAINRASSERVER_NOT_FOUND
            , NULL
            , S_OK
            , 0
            , pComponentData->m_spConsole
            );
      return S_FALSE;
   }

   // Save old cursor.
   hSavedCursor = GetCursor();

   // Change cursor here to wait cursor.
   SetCursor( LoadCursor( NULL, IDC_WAIT ) );

   // Setup the DS ACL's.
   dwRetVal = (*pfnEstablishComputerAsDomainRasServer)( NULL, pszMachine, TRUE);

   // Change cursor back to normal cursor.
   SetCursor( hSavedCursor );

   FreeLibrary( hiRasModule );

   // For use below.
   WCHAR szTemp[ IAS_MAX_STRING*2];
   WCHAR szStatus[IAS_MAX_STRING*2];
   CComBSTR bstrStatus;

   // Give an appropriate status message.
   switch( dwRetVal )
   {
   case NO_ERROR:
      {
      int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_DSACL__CHANGES_SUCCESSFUL, szTemp, IAS_MAX_STRING*2 );
      _ASSERT( nLoadStringResult > 0 );

      // Copy the domain name into the string.
      swprintf( szStatus, szTemp, szDomain );

      bstrStatus = szStatus;

      ShowErrorDialog(
              NULL
            , USE_SUPPLEMENTAL_ERROR_STRING_ONLY
            , bstrStatus
            , S_OK
            , IDS_DSACL__TITLE_CHANGES_SUCCESSFUL
            , pComponentData->m_spConsole
            );
      }
      break;
   default:
      {
      int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_ERROR__DSACL_SETUP_FAILED, szTemp, IAS_MAX_STRING*2 );
      _ASSERT( nLoadStringResult > 0 );

      // Copy the domain name into the string.
      swprintf( szStatus, szTemp, szDomain );

      bstrStatus = szStatus;

      ShowErrorDialog(
              NULL
            , USE_SUPPLEMENTAL_ERROR_STRING_ONLY
            , bstrStatus
            , S_OK
            , USE_DEFAULT
            , pComponentData->m_spConsole
            );
      }
      break;
   }
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::OnRegisterServer

Called when the Register Server in DS context menu item is clicked.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerNode::OnRegisterServer( bool &bHandled, CSnapInObjectRootBase* pObj )
{
   ATLTRACE(_T("# CServerNode::OnStartServer\n"));

   // Check for preconditions:
   // None.

   // Pretend as thought the user clicked on this taskpad item.
   HRESULT hr = OnTaskPadSetupDSACL( NULL, NULL, NULL );

   bHandled = TRUE;

   return hr;
}


/*!--------------------------------------------------------------------------
   CServerNode::StartNT4AdminExe
      -

 ---------------------------------------------------------------------------*/
#if defined(_WIN64)

HRESULT CServerNode::StartNT4AdminExe()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   try
   {
      CString text;
      AfxFormatString1(
         text,
         IDS_INFO_NO_DOWNLEVEL_ON_WIN64,
         m_bstrServerAddress
         );
      CString caption;
      caption.LoadString(IDS_ROOT_NODE__NAME);
      int retval;
      GetComponentData()->m_spConsole->MessageBox(
                                          text,
                                          caption,
                                          (MB_OK | MB_ICONINFORMATION),
                                          &retval
                                          );
   }
   catch (CException* e)
   {
      e->ReportError();
      e->Delete();
   }
   return S_OK;
}

#else // defined(_WIN64)

HRESULT CServerNode::StartNT4AdminExe()
{
   // Locals.
   CString             stAdminExePath;
   CString             stCommandLine;
   LPTSTR              pszAdminExe = NULL;
   STARTUPINFO         si;
   PROCESS_INFORMATION pi;
   HRESULT             hr = S_OK;
   UINT                nCnt = 0;
   DWORD               cbAppCnt = 0;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // Check the handle to see if rasadmin is running
   if (m_hNT4Admin != INVALID_HANDLE_VALUE)
   {
      DWORD   dwReturn = 0;
      // If the state is not signalled, then the process has
      // not exited (or some other occurred).
      dwReturn = WaitForSingleObject(m_hNT4Admin, 0);

      if (dwReturn == WAIT_TIMEOUT)
      {
         // The process has not signalled (it's still running);
         return S_OK;
      }
      else
      {
         // the process has signalled or the call failed, close the handle
         // and call up RasAdmin
         ::CloseHandle(m_hNT4Admin);
         m_hNT4Admin = INVALID_HANDLE_VALUE;
      }
   }

   try
   {
      // Looks like the RasAdmin.Exe is not running on this
      // workstation's desktop; so, start it!

      // Figure out where the \\WinNt\System32 directory is.
      pszAdminExe = stAdminExePath.GetBuffer((MAX_PATH*sizeof(TCHAR)));
      nCnt = ::GetSystemDirectory(pszAdminExe,
                                 (MAX_PATH*sizeof(TCHAR)));
      stAdminExePath.ReleaseBuffer();
      if (nCnt == 0)
         throw (HRESULT_FROM_WIN32(::GetLastError()));

      // Complete the construction of the executable's name.
      stAdminExePath += _T("\\adminui.exe");

      { // strip off the leading back slashes ...
         int n = 0;

         while(*(m_bstrServerAddress + n) == L'\\') n++;


         // Build command line string
         stCommandLine.Format(_T("%s %s"),
                          (LPCTSTR) stAdminExePath,
                          (LPCTSTR) (m_bstrServerAddress + n));

      }
      // Start RasAdmin.Exe.
      ::ZeroMemory(&si, sizeof(STARTUPINFO));
      si.cb = sizeof(STARTUPINFO);
      si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
      si.wShowWindow = SW_SHOW;
      ::ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

      CString  msg, tempMsg, title;
      int      ret;

      title.LoadString(IDS_ROOT_NODE__NAME);

      tempMsg.LoadString(IDS_INFO_START_NT4_ADMIN);

      msg.Format(tempMsg, m_bstrServerAddress);

      CComponentData *pComponentData  = GetComponentData();
      _ASSERTE( pComponentData != NULL );
      _ASSERTE( pComponentData->m_spConsole != NULL );

      pComponentData->m_spConsole->MessageBox(msg, title, MB_OKCANCEL | MB_ICONINFORMATION  , &ret);

      if (ret == IDOK)
      {
         if (!::CreateProcess(NULL,
                  (LPTSTR) (LPCTSTR) stCommandLine,
                  NULL,
                  NULL,
                  FALSE,
                  CREATE_NEW_CONSOLE,
                  NULL,
                  NULL,
                  &si,
                  &pi))
         {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            ::CloseHandle(pi.hProcess);
         }
         else
         {
            ASSERT(m_hNT4Admin == INVALID_HANDLE_VALUE);
            m_hNT4Admin = pi.hProcess;
         }
         ::CloseHandle(pi.hThread);
      }
      //
      // Maybe we should have used the ShellExecute() API rather than
      //        the CreateProcess() API. Why? The ShellExecute() API will
      //        give the shell the opportunity to check the current user's
      //        system policy settings before allowing the executable to execute.
      //
   }
   catch (CException * e)
   {
      hr = E_OUTOFMEMORY;
   }
   catch (HRESULT hrr)
   {
      hr = hrr;
   }
   catch (...)
   {
      hr = E_UNEXPECTED;
   }

   //Assert(SUCCEEDED(hr));
   return hr;
}

#endif // defined(_WIN64)

BOOL CServerNode::IsNt4Server() const throw ()
{
   if (m_serverType == unknown)
   {
      BOOL isNt4;
      if (IsNT4Machine(m_bstrServerAddress, &isNt4) == NO_ERROR)
      {
         m_serverType = isNt4 ? nt4 : win2kOrLater;
      }
   }

   return m_serverType == nt4;
}

// helper functions to detect if machine is NT4
//----------------------------------------------------------------------------
// Function:    ConnectRegistry
//
// Connects to the registry on the specified machine
//----------------------------------------------------------------------------
DWORD
ConnectRegistry(
    IN  LPCTSTR pszMachine,
    OUT HKEY*   phkeyMachine
    )
{
   //
   // if no machine name was specified, connect to the local machine.
   // otherwise, connect to the specified machine
   //

   DWORD dwErr = NO_ERROR;

   if (!pszMachine || !lstrlen(pszMachine))
   {
      *phkeyMachine = HKEY_LOCAL_MACHINE;
   }
   else
   {
      //
      // Make the connection
      //

      dwErr = ::RegConnectRegistry(
                 (LPTSTR)pszMachine, HKEY_LOCAL_MACHINE, phkeyMachine
                 );
   }
   return dwErr;
}


//----------------------------------------------------------------------------
// Function:    DisconnectRegistry
//
// Disconnects the specified config-handle. The handle is assumed to have been
// acquired by calling 'ConnectRegistry'.
//----------------------------------------------------------------------------

VOID
DisconnectRegistry(
    IN  HKEY    hkeyMachine
    )
{
   if (hkeyMachine != HKEY_LOCAL_MACHINE) { ::RegCloseKey(hkeyMachine); }
}


/*!--------------------------------------------------------------------------
   IsNT4Machine
      -
   Author: KennT
 ---------------------------------------------------------------------------*/

const TCHAR c_szSoftware[]              = TEXT("Software");
const TCHAR c_szMicrosoft[]             = TEXT("Microsoft");
const TCHAR c_szWindowsNT[]             = TEXT("Windows NT");
const TCHAR c_szCurrentVersion[]        = TEXT("CurrentVersion");

#define CheckRegOpenError(d,p1,p2)
#define CheckRegQueryValueError(d,p1,p2,p3)


DWORD IsNT4Machine(LPCTSTR pszMachine, BOOL *pfNt4)
{
   // Look at the HKLM\Software\Microsoft\Windows NT\CurrentVersion
   //             CurrentVersion = REG_SZ "4.0"

   HKEY hkeyMachine;
   CString skey;
   DWORD dwType;
   DWORD dwSize;
   TCHAR szVersion[64];
   HKEY  hkeySubkey;

   DWORD dwErr = ConnectRegistry(pszMachine, &hkeyMachine);

   ASSERT(pfNt4);

   skey = c_szSoftware;
   skey += TEXT('\\');
   skey += c_szMicrosoft;
   skey += TEXT('\\');
   skey += c_szWindowsNT;
   skey += TEXT('\\');
   skey += c_szCurrentVersion;

   dwErr = ::RegOpenKeyEx(hkeyMachine, (LPCTSTR) skey, NULL, KEY_READ, &hkeySubkey);

   CheckRegOpenError(dwErr, (LPCTSTR) skey, _T("IsNT4Machine"));
   if (dwErr != ERROR_SUCCESS)
      return dwErr;

   // Ok, now try to get the current version value
   dwType = REG_SZ;
   dwSize = sizeof(szVersion);
   dwErr = ::RegQueryValueEx(hkeySubkey, c_szCurrentVersion, NULL,
                       &dwType, (BYTE *) szVersion, &dwSize);
   CheckRegQueryValueError(dwErr, (LPCTSTR) skey, c_szCurrentVersion,
                     _T("IsNTMachine"));
   if (dwErr == ERROR_SUCCESS)
   {
      ASSERT(dwType == REG_SZ);
      *pfNt4 = ((szVersion[0] == _T('4')) && (szVersion[1] == _T('.')));
      if ((szVersion[0] == _T('5')) && (szVersion[1] == _T('.')))
      {
         ASSERT(*pfNt4 == FALSE);
         // We need to check to see if the build number if less than
         // 1597, if so treat it as a NT 4.0 router.  This if for
         // the NciDev checkin (which is when the registry changed).
         dwType = REG_SZ;
         dwSize = sizeof(szVersion);
         dwErr = ::RegQueryValueEx(hkeySubkey, _T("CurrentBuildNumber"), NULL,
                             &dwType, (BYTE *) szVersion, &dwSize);
         if (dwErr == ERROR_SUCCESS)
         {
            DWORD dwBuild = _ttoi(szVersion);
            if (dwBuild < 1597)
               *pfNt4 = TRUE;
         }
      }
   }

   RegCloseKey(hkeySubkey);

   DisconnectRegistry(hkeyMachine);

   return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverenumtask.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ServerEnumTask.cpp

Abstract:

	This class implements the CServerEnumTask class, an enumerator for 
	tasks to populate the main IAS Server taskpad.

Author:

    Michael A. Maguire 02/05/98

Revision History:
	mmaguire 02/05/98 - created from MMC taskpad sample code


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ServerEnumTask.h"
//
// where we can find declarations needed in this file:
//
#include "ServerNode.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CServerEnumTask::CServerEnumTask

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerEnumTask::CServerEnumTask( CServerNode * pServerNode )
{

	
	// Check for preconditions.	
	_ASSERTE( pServerNode != NULL );


	m_pServerNode = pServerNode;


}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerEnumTask::CServerEnumTask

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerEnumTask::CServerEnumTask()
{

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerEnumTask::Init

Here is where we see what taskpad we are providing tasks for.
In our case we know that we only have one taskpad.
The string we test for is "CMTP1". This was the string following the '#'
that we passed in GetResultViewType.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CServerEnumTask::Init (IDataObject * pdo, LPOLESTR szTaskGroup)
{
	// Return ok, if we can handle data object and group.
	if( !lstrcmp(szTaskGroup, L"CMTP1") )
	{
		m_type = 1; // default tasks
	}
	else
	{
		_ASSERTE(FALSE);
	}
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerEnumTask::Next

We get called here over and over untill we have no more tasks to provide.
Other tasks may still appear on our taskpad as a result of what extensions add.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CServerEnumTask::Next (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched)
{
	// Caller alloc's array of MMC_TASKs.
   	// Callee fills MMC_TASK elements (via CoTaskMemAlloc).

	
	
	// Check for preconditions.	
	if ((rgelt == NULL) || (pceltFetched == NULL))
	{
		return E_INVALIDARG;
	}
	_ASSERTE(!IsBadWritePtr (rgelt, celt*sizeof(MMC_TASK)));
	_ASSERTE(!IsBadWritePtr (pceltFetched, sizeof(ULONG)));
	_ASSERTE( m_type == 1 );
	_ASSERTE( m_pServerNode != NULL );

	
	UINT uintTextResourceID;
	UINT uintHelpTextResourceID;
	TCHAR lpszTemp[IAS_MAX_STRING];
	int nLoadStringResult;
	

	// Setup a path to resources used in each case.
	// In each case, we are constructing a string pointing to the resource 
	// of the form: "res://D:\MyPath\MySnapin.dll/img\SomeImage.bmp"

	// Make the mouse over bitmap address.
	OLECHAR szMouseOverBuffer[MAX_PATH*2];    // A little extra.

	lstrcpy (szMouseOverBuffer, L"res://");

	HINSTANCE hInstance = _Module.GetModuleInstance();

	::GetModuleFileName (hInstance, szMouseOverBuffer + lstrlen(szMouseOverBuffer), MAX_PATH);
	OLECHAR * szMouseOverBufferAfterFileName = szMouseOverBuffer + lstrlen(szMouseOverBuffer);


	// Make a copy of the string we built above for the mouse off bitmap address.
	OLECHAR szMouseOffBuffer[MAX_PATH*2];    // A little extra.
	
	lstrcpy( szMouseOffBuffer, szMouseOverBuffer );

	OLECHAR * szMouseOffBufferAfterFileName = szMouseOffBuffer + lstrlen(szMouseOffBuffer);


	// celt will actually always only be 1
	for (ULONG i=0; i<celt; i++)
	{
		// make an MMC_TASK pointer to make life easier below.
		MMC_TASK * task = &rgelt[i];

		// Add action.
		task->eActionType = MMC_ACTION_ID;
		task->sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;	// Non-transparent raster.

		// Decide on the appropriate resource to use based on m_index, 
		// which tells us which task we are enumerating.
		switch( m_index )
		{
		case 0:
//			if( m_pServerNode->m_fClientAdded )
//			{
//				lstrcpy (szBufferAfterFileName , L"/img\\TaskClientDone.gif");
//			}
//			else
//			{
				lstrcpy (szMouseOffBufferAfterFileName , L"/img\\TaskClient.gif");
				lstrcpy (szMouseOverBufferAfterFileName , L"/img\\TaskClientMouseOver.gif");
//			}
			uintTextResourceID = IDS_TASKPAD_TEXT__REGISTER_NEW_RADIUS_CLIENT;
			uintHelpTextResourceID = IDS_TASKPAD_HELP_TEXT__REGISTER_NEW_RADIUS_CLIENT;
			task->nCommandID = SERVER_TASK__ADD_CLIENT;		// Set the task identifier.
			break;


		case 1:
			if( m_pServerNode->IsServerRunning() )
			{
				lstrcpy (szMouseOffBufferAfterFileName , L"/img\\TaskStartDone.gif");
				lstrcpy (szMouseOverBufferAfterFileName , L"/img\\TaskStartDoneMouseOver.gif");
				uintTextResourceID = IDS_TASKPAD_TEXT__STOP_THE_SERVICE;
				uintHelpTextResourceID = IDS_TASKPAD_HELP_TEXT__STOP_THE_SERVICE;
				task->nCommandID = SERVER_TASK__STOP_SERVICE;		// Set the task identifier.
			}
			else
			{
				lstrcpy (szMouseOffBufferAfterFileName , L"/img\\TaskStart.gif");
				lstrcpy (szMouseOverBufferAfterFileName , L"/img\\TaskStartMouseOver.gif");
				uintTextResourceID = IDS_TASKPAD_TEXT__START_THE_SERVICE;
				uintHelpTextResourceID = IDS_TASKPAD_HELP_TEXT__START_THE_SERVICE;
				task->nCommandID = SERVER_TASK__START_SERVICE;		// Set the task identifier.
			}
			break;

		case 2:
			if( m_pServerNode->ShouldShowSetupDSACL() )
			{
				lstrcpy (szMouseOffBufferAfterFileName , L"/img\\TaskSetupDSACL.gif");
				lstrcpy (szMouseOverBufferAfterFileName , L"/img\\TaskSetupDSACLMouseOver.gif");
				uintTextResourceID = IDS_TASKPAD_TEXT__SETUP_DS_ACL;
				uintHelpTextResourceID = IDS_TASKPAD_HELP_TEXT__SETUP_DS_ACL;
				task->nCommandID = SERVER_TASK__SETUP_DS_ACL;		// Set the task identifier.
				// Break here.
				break;
			}
			// Don't break here -- if the check above is false, we want to fall through to the
			// default case below so that this taskpad item won't show up.
		default:
			// We only have the tasks listed above.
			if (pceltFetched)
			{
				*pceltFetched = i;	// Note that this is accurate because i above is zero based.
			}
			return S_FALSE;   // Failed to enumerate any more tasks.
			break;
		}

		task->sDisplayObject.uBitmap.szMouseOverBitmap = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(szMouseOverBuffer)+1) );
		
		if( task->sDisplayObject.uBitmap.szMouseOverBitmap )
		{
			// Copy the string to the allocated memory.
			lstrcpy( task->sDisplayObject.uBitmap.szMouseOverBitmap, szMouseOverBuffer );

			task->sDisplayObject.uBitmap.szMouseOffBitmap = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(szMouseOffBuffer)+1) );

			if( task->sDisplayObject.uBitmap.szMouseOffBitmap ) 
			{
				// Copy the string to the allocated memory.
				lstrcpy( task->sDisplayObject.uBitmap.szMouseOffBitmap, szMouseOffBuffer );

				 // Add button text, loaded from resources.
				nLoadStringResult = LoadString(  _Module.GetResourceInstance(), uintTextResourceID, lpszTemp, IAS_MAX_STRING );
				_ASSERT( nLoadStringResult > 0 );
				task->szText = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(lpszTemp)+1) );

				if (task->szText) 
				{
					// Copy the string to the allocated memory.
					lstrcpy( task->szText, lpszTemp );

					// Add help string, loaded from resources.

					// ISSUE: Why don't I seem to be loading the whole string here sometimes
					// e.g.: for IDS_TASKPAD_HELP_TEXT__REGISTER_NEW_RADIUS_CLIENT ?

					nLoadStringResult = LoadString(  _Module.GetResourceInstance(), uintHelpTextResourceID, lpszTemp, IAS_MAX_STRING );
					_ASSERT( nLoadStringResult > 0 );
					task->szHelpString = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(lpszTemp)+1) );

					if (task->szHelpString) 
					{
						// Copy the string to the allocated memory.
						lstrcpy( task->szHelpString, lpszTemp );
						
						m_index++;
						continue;   // all is well
					}

					// If we get here, there was an error, and we didn't "continue".
					CoTaskMemFree(task->szText);

				}

				// If we get here, there was an error, and we didn't "continue".
				CoTaskMemFree(task->sDisplayObject.uBitmap.szMouseOffBitmap);

			}

			// If we get here, there was an error, and we didn't "continue".
			CoTaskMemFree(task->sDisplayObject.uBitmap.szMouseOverBitmap);

		}


		// If we get here, we didn't "continue" and therefore fail.
		if ( NULL != pceltFetched)
		{
			*pceltFetched = i;	// Note that this is accurate because i above is zero based.
		}
		return S_FALSE;   // Failure.
	}

	// If we get here all is well.
	if (pceltFetched)
	  *pceltFetched = celt;
	return S_OK;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerEnumTask::CopyState

Used by the clone method.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CServerEnumTask::CopyState( CServerEnumTask * pSourceServerEnumTask )
{
	ATLTRACE(_T("# CServerEnumTask::CopyState\n"));

	m_pServerNode  = pSourceServerEnumTask->m_pServerNode;
	m_index = pSourceServerEnumTask->m_index;
	m_type = pSourceServerEnumTask->m_type;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverpage1.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ServerPage1.cpp

Abstract:

	Implementation file for the CServerPage1 class.

	We implement the class needed to handle the first property page for a Machine node.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ServerPage1.h"
//
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage1::CServerPage1

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerPage1::CServerPage1( LONG_PTR hNotificationHandle, TCHAR* pTitle, BOOL bOwnsNotificationHandle)
						: CIASPropertyPage<CServerPage1> ( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
	// Add the help button to the page
//	m_psp.dwFlags |= PSP_HASHELP;

	// Initialize the pointer to the stream into which the Sdo pointer will be marshalled.
	m_pStreamSdoMarshal = NULL;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage1::~CServerPage1

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerPage1::~CServerPage1()
{
	// Release this stream pointer if this hasn't already been done.
	if( m_pStreamSdoMarshal != NULL )
	{
		m_pStreamSdoMarshal->Release();
	};

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage1::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE(_T("# CServerPage1::OnInitDialog\n"));
	

	// Check for preconditions:
	_ASSERTE( m_pStreamSdoMarshal != NULL );
	_ASSERT( m_pSynchronizer != NULL );


	// Since we've been examined, we must add to the ref count of pages who need to
	// give their approval before they can be allowed to commit changes.
	m_pSynchronizer->RaiseCount();



	HRESULT					hr;
	CComPtr<IUnknown>		spUnknown;
	CComPtr<IEnumVARIANT>	spEnumVariant;
	long					ulCount;
	ULONG					ulCountReceived;
	CComBSTR			bstrTemp;
	BOOL				bTemp;

	
	// Unmarshall an ISdo interface pointer.
	// The code setting up this page should make sure that it has
	// marshalled the Sdo interface pointer into m_pStreamSdoMarshal.
	hr =  CoGetInterfaceAndReleaseStream(
						  m_pStreamSdoMarshal		  //Pointer to the stream from which the object is to be marshaled
						, IID_ISdo				//Reference to the identifier of the interface
						, (LPVOID *) &m_spSdoServer    //Address of output variable that receives the interface pointer requested in riid
						);

	// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
	// We set it to NULL so that our destructor doesn't try to release this again.
	m_pStreamSdoMarshal = NULL;

	if( FAILED( hr) || m_spSdoServer == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr );

		return 0;
	}




	hr = m_spSdoServer->QueryInterface( IID_ISdoServiceControl, (void **) & m_spSdoServiceControl );
	if( FAILED( hr ) )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr );

		return 0;
	}		
	m_spSdoServiceControl->AddRef();


	// Get all the data from the Server Sdo.

	hr = GetSdoBSTR( m_spSdoServer, PROPERTY_SDO_DESCRIPTION, &bstrTemp, IDS_ERROR__SERVER_READING_NAME, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SetDlgItemText(IDC_EDIT_SERVER_PAGE1__NAME, bstrTemp );

		// Initialize the dirty bits;
		// We do this after we've set all the data above otherwise we get false
		// notifications that data has changed when we set the edit box text.
		m_fDirtyServerDescription = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			// This means that this property has not yet been initialized
			// with a valid value and the user must enter something.
			SetDlgItemText(IDC_EDIT_SERVER_PAGE1__NAME, _T("") );
			m_fDirtyServerDescription = TRUE;
			SetModified( TRUE );
		}

	}
	bstrTemp.Empty();




	// Get the SDO event log auditor.

	hr = ::SDOGetSdoFromCollection(		  m_spSdoServer
										, PROPERTY_IAS_AUDITORS_COLLECTION
										, PROPERTY_COMPONENT_ID
										, IAS_AUDITOR_MICROSOFT_NT_EVENT_LOG
										, &m_spSdoEventLog
										);
	
	if( FAILED(hr) || m_spSdoEventLog == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_READ_DATA_FROM_SDO, NULL, hr );

		return 0;
	}


// ISSUE: This is being removed from the UI -- make sure that it gets removed from the SDO's as well.
//	hr = GetSdoBOOL( m_spSdoEventLog, PROPERTY_EVENTLOG_LOG_APPLICATION_EVENTS, &bTemp, IDS_ERROR__CANT_READ_DATA_FROM_SDO, m_hWnd, NULL );
//	if( SUCCEEDED( hr ) )
//	{
//		SendDlgItemMessage( IDC_CHECK_SERVER_PAGE1__CAPTURE_APPLICATION_EVENTS, BM_SETCHECK, bTemp, 0);
//		m_fDirtyApplicationEvents = FALSE;
//	}
//	else
//	{
//		if( OLE_E_BLANK == hr )
//		{
//			SendDlgItemMessage( IDC_CHECK_SERVER_PAGE1__CAPTURE_APPLICATION_EVENTS, BM_SETCHECK, FALSE, 0);
//			m_fDirtyApplicationEvents = TRUE;
//			SetModified( TRUE );
//		}
//	}


	hr = GetSdoBOOL( m_spSdoEventLog, PROPERTY_EVENTLOG_LOG_MALFORMED, &bTemp, IDS_ERROR__SERVER_READING_RADIUS_LOG_MALFORMED, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SendDlgItemMessage(IDC_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS, BM_SETCHECK, bTemp, 0);
		m_fDirtyMalformedPackets = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			SendDlgItemMessage(IDC_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS, BM_SETCHECK, FALSE, 0);
			m_fDirtyMalformedPackets = TRUE;
			SetModified( TRUE );
		}
	}
	


	hr = GetSdoBOOL( m_spSdoEventLog, PROPERTY_EVENTLOG_LOG_DEBUG, &bTemp, IDS_ERROR__SERVER_READING_RADIUS_LOG_ALL, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SendDlgItemMessage( IDC_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKETS, BM_SETCHECK, bTemp, 0);
		m_fDirtyVerboseLogging = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			SendDlgItemMessage( IDC_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKETS, BM_SETCHECK, FALSE, 0);
			m_fDirtyVerboseLogging = TRUE;
			SetModified( TRUE );
		}
	}


	
	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage1::OnChange

Called when the WM_COMMAND message is sent to our page with any of the
BN_CLICKED, EN_CHANGE or CBN_SELCHANGE notifications.

This is our chance to check to see what the user has touched, set the
dirty bits for these items so that only they will be saved,
and enable the Apply button.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage1::OnChange(		
							  UINT uMsg
							, WPARAM wParam
							, HWND hwnd
							, BOOL& bHandled
							)
{
	ATLTRACE(_T("# CServerPage1::OnChange\n"));

	
	// Check for preconditions:
	// None.
	

	// We don't want to prevent anyone else down the chain from receiving a message.
	bHandled = FALSE;


	// Figure out which item has changed and set the dirty bit for that item.
	int iItemID = (int) LOWORD(wParam);

	switch( iItemID )
	{
	case IDC_EDIT_SERVER_PAGE1__NAME:
		m_fDirtyServerDescription = TRUE;
		break;
	case IDC_CHECK_SERVER_PAGE1__CAPTURE_APPLICATION_EVENTS:
		m_fDirtyApplicationEvents = TRUE;
		break;
	case IDC_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS:
		m_fDirtyMalformedPackets = TRUE;
		break;
	case IDC_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKETS:
		m_fDirtyVerboseLogging = TRUE;
		break;
	default:
		return TRUE;
		break;
	}

	// We should only get here if the item that changed was
	// one of the ones we were checking for.
	// This enables the Apply button.
	SetModified( TRUE );

	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage1::OnApply

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnApply gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnApply method will never get called.


--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerPage1::OnApply()
{
	ATLTRACE(_T("# CServerPage1::OnApply\n"));
	

	// Check for preconditions:
	_ASSERT( m_pSynchronizer != NULL );


	if( m_spSdoServer == NULL || m_spSdoEventLog == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO );
		return FALSE;
	}

	
	BOOL		bResult;
	HRESULT		hr;
	CComBSTR	bstrTemp;
	BOOL		bTemp;


	if( m_fDirtyServerDescription )
	{
		bResult = GetDlgItemText( IDC_EDIT_SERVER_PAGE1__NAME, (BSTR &) bstrTemp );
		if( ! bResult )
		{
			// We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
			bstrTemp = _T("");
		}
		hr = PutSdoBSTR( m_spSdoServer, PROPERTY_SDO_DESCRIPTION, &bstrTemp, IDS_ERROR__SERVER_WRITING_NAME, m_hWnd, NULL );
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );

			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyServerDescription = FALSE;
		}
		bstrTemp.Empty();
	}

// ISSUE: This is being removed from the UI -- make sure that it gets removed from the SDO's as well.
//	if( m_fDirtyApplicationEvents )
//	{
//		bTemp = SendDlgItemMessage(IDC_CHECK_SERVER_PAGE1__CAPTURE_APPLICATION_EVENTS, BM_GETCHECK, 0, 0);
		bTemp = TRUE;
//		hr = PutSdoBOOL( m_spSdoServer, PROPERTY_EVENTLOG_LOG_APPLICATION_EVENTS, bTemp, IDS_ERROR__SERVER_WRITING_CAPTURE_APPLICATION_EVENTS, m_hWnd, NULL );
//		if( FAILED( hr ) )
//		{
//			// Reset the ref count so all pages know that we need to play the game again.
//			m_pSynchronizer->ResetCountToHighest();
//
//			// This uses the resource ID of this page to make this page the current page.
//			PropSheet_SetCurSelByID( GetParent(), IDD );
//			
//			return FALSE;
//		}
//		else
//		{
//			// We succeeded.
//
//			// Turn off the dirty bit.
//			m_fDirtyApplicationEvents = FALSE;
//		}
//	}

	if( m_fDirtyMalformedPackets )
	{
		bTemp = SendDlgItemMessage(IDC_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS, BM_GETCHECK, 0, 0);
		hr = PutSdoBOOL( m_spSdoEventLog, PROPERTY_EVENTLOG_LOG_MALFORMED, bTemp, IDS_ERROR__SERVER_WRITING_RADIUS_LOG_MALFORMED, m_hWnd, NULL );
 		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			
			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyMalformedPackets = FALSE;
		}
	}

	if( m_fDirtyVerboseLogging )
	{
		bTemp = SendDlgItemMessage(IDC_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKETS, BM_GETCHECK, 0, 0);
		hr = PutSdoBOOL( m_spSdoEventLog, PROPERTY_EVENTLOG_LOG_DEBUG, bTemp, IDS_ERROR__SERVER_WRITING_RADIUS_LOG_ALL, m_hWnd, NULL );
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			
			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyVerboseLogging = FALSE;
		}
	}

	// If we made it to here, try to apply the changes.

	


	// Now try to apply changes made to Radius Protocol.

	// Check to see if there are other pages which have not yet validated their data.
	LONG lRefCount = m_pSynchronizer->LowerCount();
	if( lRefCount <= 0 )
	{
		// There is nobody else left, so now we can commit the data.
	
		// First try to apply changes made to server.
		hr = m_spSdoServer->Apply();
		if( FAILED( hr ) )
		{
			if(hr == DB_E_NOTABLE)	// assume, the RPC connection has problem
				ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
			else		
			{
//			m_spSdoServer->LastError( &bstrError );
//			ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, bstrError );
				ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO );
			}
			
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );

			return FALSE;
		}
		else
		{
			// We succeeded.
		}

		// Now try to apply the changes made to the Radius Protocol.
		hr = m_spSdoEventLog->Apply();
		if( FAILED( hr ) )
		{
			if(hr == DB_E_NOTABLE)	// assume, the RPC connection has problem
				ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
			else		
			{
//			m_spSdoEventLog->LastError( &bstrError );
//			ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, bstrError );
				ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO );
			}
			
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );

			return FALSE;
		}
		else
		{
			// We succeeded.


			// Tell the service to reload data.
			HRESULT hrTemp = m_spSdoServiceControl->ResetService();
			if( FAILED( hrTemp ) )
			{
				// Fail silently.
			}
		}
	}


	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage1::OnQueryCancel

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnQueryCancel gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnQueryCancel method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerPage1::OnQueryCancel()
{
	ATLTRACE(_T("# CServerPage1::OnQueryCancel\n"));
	
	HRESULT hr;

	if( m_spSdoServer != NULL )
	{
		// If the user wants to cancel, we should make sure that we rollback
		// any changes the user may have started.

		// If the user had not already tried to commit something,
		// a cancel on an SDO will hopefully be designed to be benign.
		
		hr = m_spSdoServer->Restore();
		// Don't care about the HRESULT.

	}

	if( m_spSdoEventLog != NULL )
	{
		// If the user wants to cancel, we should make sure that we rollback
		// any changes the user may have started.

		// If the user had not already tried to commit something,
		// a cancel on an SDO will hopefully be designed to be benign.
		
		hr = m_spSdoEventLog->Restore();
		// Don't care about the HRESULT.

	}

	return TRUE;

}



/////////////////////////////////////////////////////////////////////////////
/*++

CServerPage1::GetHelpPath

Remarks:

	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help
	button of a property sheet.

	It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerPage1::GetHelpPath( LPTSTR szHelpPath )
{
	ATLTRACE(_T("# CServerPage1::GetHelpPath\n"));


	// Check for preconditions:



#ifdef UNICODE_HHCTRL
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("idh_proppage_server1.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "idh_proppage_server1.htm" );
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverenumtask.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ServerEnumTask.h

Abstract:

	Header file for the CServerEnumTask class -- this class implements 
	an enumerator for tasks to populate a taskpads.

	See ServerEnumTask.cpp for implementation details.


Author:

    Michael A. Maguire 02/05/98

Revision History:
	mmaguire 02/05/98 -  created from MMC taskpad sample code


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_SERVER_ENUM_TASKS_H_)
#define _IAS_SERVER_ENUM_TASKS_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "EnumTask.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



#define SERVER_TASK__ADD_CLIENT				0
#define SERVER_TASK__CONFIGURE_LOGGING		1
#define SERVER_TASK__START_SERVICE			2
#define SERVER_TASK__STOP_SERVICE			3
#define SERVER_TASK__SETUP_DS_ACL			4


class CServerNode;

class CServerEnumTask : public IEnumTASKImpl<CServerEnumTask>
{

public:

	// Use this constructor - pass in a pointer to CServerNode.
	CServerEnumTask( CServerNode * pServerNode );

	// This constructor is used only by IEnumTASKImpl's Clone method.
	CServerEnumTask();



	STDMETHOD(Init)(
		  IDataObject * pdo
		, LPOLESTR szTaskGroup
		);

	STDMETHOD(Next)( 
		  ULONG celt
		, MMC_TASK *rgelt
		, ULONG *pceltFetched
		);

	STDMETHOD(CopyState)( CServerEnumTask * pSourceServerEnumTask );


	CServerNode * m_pServerNode;

};


#endif // _IAS_SERVER_ENUM_TASKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\servernode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    ServerNode.h

Abstract:

	Header file for the ServerNode subnode.

	See ServerNode.cpp for implementation.

Author:

    Michael A. Maguire 12/03/97

Revision History:
	mmaguire 12/03/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_SERVER_NODE_H_)
#define _IAS_SERVER_NODE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "SnapinNode.h"
//
//
// where we can find what this class has or uses:
//
#include "ServerPage1.h"
#include "ServerPage2.h"
#include "ServerPage3.h"
#include "ConnectToServerWizardPage1.h"
#include "ConnectionToServer.h"
#include "ServerStatus.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CClientsNode;
class CLoggingMethodsNode;
class CComponentData;
class CComponent;

class CServerNode : public CSnapinNode< CServerNode, CComponentData, CComponent >
{

public:


	SNAPINMENUID(IDM_MACHINE_NODE)


	BEGIN_SNAPINTOOLBARID_MAP(CServerNode)
		SNAPINTOOLBARID_ENTRY(IDR_MACHINE_TOOLBAR)
	END_SNAPINTOOLBARID_MAP()



	BEGIN_SNAPINCOMMAND_MAP(CServerNode, FALSE)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_MACHINE_TOP__START_SERVICE, OnStartServer)
		SNAPINCOMMAND_ENTRY(ID_BUTTON_MACHINE__START_SERVICE, OnStartServer)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_MACHINE_TOP__STOP_SERVICE, OnStopServer)
		SNAPINCOMMAND_ENTRY(ID_BUTTON_MACHINE__STOP_SERVICE, OnStopServer)
		SNAPINCOMMAND_ENTRY(ID_MENUITEM_MACHINE_TOP__REGISTER_SERVER, OnRegisterServer)
		//CHAIN_SNAPINCOMMAND_MAP( CSnapinNode<CServerNode, CComponentData, CComponent> )
		//CHAIN_SNAPINCOMMAND_MAP( CServerNode )
	END_SNAPINCOMMAND_MAP()


	// Constructor/Destructor.
	CServerNode( CComponentData * pComponentData);
	~CServerNode();



	// Used to get access to snapin-global data.
public:
	CComponentData * GetComponentData( void );
protected:
	CComponentData * m_pComponentData;


public:

	static	WCHAR m_szRootNodeBasicName[IAS_MAX_STRING];

	// called to refresh the nodes
	HRESULT	DataRefresh();


	// Clipboard stuff needed so that this node can communicate a
	// machine name via a clipboard format to any node which extend might it.
	static CLIPFORMAT m_CCF_MMC_SNAPIN_MACHINE_NAME;
	static void InitClipboardFormat();
	STDMETHOD(FillData)(CLIPFORMAT cf, LPSTREAM pStream);


	// Some overrides for standard MMC functionality.
	virtual HRESULT OnExpand(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			);
	virtual HRESULT OnRefresh(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			);

// 354294	1	 	mashab	DCR IAS: needs Welcome message and explantation of IAS application in the right pane

	virtual HRESULT OnShow(
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type
				);

	virtual HRESULT OnSelect(
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type
				);


    STDMETHOD(CreatePropertyPages)(
		  LPPROPERTYSHEETCALLBACK pPropertySheetCallback
        , LONG_PTR handle
		, IUnknown* pUnk
		, DATA_OBJECT_TYPES type
		);
    STDMETHOD(QueryPagesFor)( DATA_OBJECT_TYPES type );
	LPOLESTR GetResultPaneColInfo(int nCol);
	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);
	BOOL UpdateToolbarButton( UINT id, BYTE fsState );
	virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );


	// SDO management.
	HRESULT InitSdoPointers( void );
	HRESULT LoadCachedInfoFromSdo( void );


	// Management of connection to server.
	HRESULT SetServerAddress( LPCWSTR szServerAddress );
	CComBSTR m_bstrServerAddress;
	HRESULT BeginConnectAction( void );
	STDMETHOD(CheckConnectionToServer)( BOOL fVerbose = TRUE );
	CConnectionToServer		* m_pConnectionToServer;
	BOOL m_bConfigureLocal;


	// Server status management.
	HRESULT OnStartServer( bool &bHandled, CSnapInObjectRootBase* pObj );
	HRESULT OnStopServer( bool &bHandled, CSnapInObjectRootBase* pObj );
	HRESULT StartStopService( BOOL bStart );
	BOOL IsServerRunning( void );

	// two functions used for giving menu / tool bar state
	BOOL CanStartServer( void );
	BOOL CanStopServer( void );


	HRESULT RefreshServerStatus( void );
	CServerStatus			* m_pServerStatus;



	// Taskpad methods for the taskpad on this node.
	STDMETHOD(GetResultViewType)(
				  LPOLESTR  *ppViewType
				, long  *pViewOptions
				);
	STDMETHOD(TaskNotify)(
				  IDataObject * pDataObject
				, VARIANT * pvarg
				, VARIANT * pvparam
				);
	STDMETHOD(EnumTasks)(
				  IDataObject * pDataObject
				, BSTR szTaskGroup
				, IEnumTASK** ppEnumTASK
				);
	BOOL IsSetupDSACLTaskValid();
	BOOL ShouldShowSetupDSACL();
	HRESULT OnRegisterServer( bool &bHandled, CSnapInObjectRootBase* pObj );

	HRESULT StartNT4AdminExe();

private:
	HRESULT OnTaskPadAddClient(
				  IDataObject * pDataObject
				, VARIANT * pvarg
				, VARIANT * pvparam
				);

	enum IconMode {
		IconMode_Normal,
		IConMode_Busy,
		IConMode_Error
	};

	HRESULT	SetIconMode(HSCOPEITEM scopeId, IconMode mode);

	HRESULT OnTaskPadSetupDSACL(
				  IDataObject * pDataObject
				, VARIANT * pvarg
				, VARIANT * pvparam
				);
	// Status flags to figure out how configered the server is.
	BOOL m_fClientAdded;
	BOOL m_fLoggingConfigured;


private:
	// Pointer to our root Server Data Object.
	CComPtr<ISdo>	m_spSdo;


	// Pointers to child nodes.
	CClientsNode * m_pClientsNode;					// this is one CClientsNode object

	// This is the hProcess of NT4 IAS admin UI (this is so we only have one running)
    HANDLE      m_hNT4Admin;

    enum ServerType
    {
       unknown,
       nt4,
       win2kOrLater
    };

    mutable ServerType m_serverType;

    BOOL IsNt4Server() const throw ();

    //IsSetupDSACLTaskValid : 1: valid, 0: invalid, -1: need to check
	enum {
	IsSetupDSACLTaskValid_NEED_CHECK = -1,
	IsSetupDSACLTaskValid_INVALID = 0,
	IsSetupDSACLTaskValid_VALID = 1
	} m_eIsSetupDSACLTaskValid;


};


_declspec( selectany ) CLIPFORMAT CServerNode::m_CCF_MMC_SNAPIN_MACHINE_NAME = 0;

DWORD IsNT4Machine(LPCTSTR pszMachine, BOOL *pfNt4);

#endif // _IAS_ROOT_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverpage1.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	ServerPage1.h

Abstract:

	Header file for the CServerPage1 class.

	This is our handler class for the first CMachineNode property page.

	See ServerPage1.cpp for implementation.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_SERVER_PAGE_1_H_)
#define _IAS_SERVER_PAGE_1_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class CServerPage1 : public CIASPropertyPage<CServerPage1>
{

public :
	
	CServerPage1( LONG_PTR hNotificationHandle, TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );
	
	~CServerPage1();


	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_PROPPAGE_SERVER1 };

	BEGIN_MSG_MAP(CServerPage1)
		COMMAND_CODE_HANDLER(BN_CLICKED, OnChange)		
		COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
		COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		CHAIN_MSG_MAP(CIASPropertyPage<CServerPage1>)
	END_MSG_MAP()

	BOOL OnApply();

	BOOL OnQueryCancel();

	HRESULT GetHelpPath( LPTSTR szFilePath );


	// Pointer to stream into which this page's Sdo interface
	// pointer will be marshalled.
	LPSTREAM m_pStreamSdoMarshal;

private:

	// Interface pointer for this page's sdo.
	CComPtr<ISdo>	m_spSdoServer;
	CComPtr<ISdo>	m_spSdoEventLog;
	CComPtr<ISdoServiceControl>	m_spSdoServiceControl;


	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnChange(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

protected:
	// Dirty bits -- for keeping track of data which has been touched
	// so that we only save data we have to.
	BOOL m_fDirtyServerDescription;
	BOOL m_fDirtyApplicationEvents;
	BOOL m_fDirtyMalformedPackets;
	BOOL m_fDirtyVerboseLogging;

};

#endif // _IAS_SERVER_PAGE_1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverpage2.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ServerPage2.cpp

Abstract:

	Implementation file for the CServerPage2 class.

	We implement the class needed to handle the second property page for a Machine node.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ServerPage2.h"
//
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage2::CServerPage2

Construtor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerPage2::CServerPage2( LONG_PTR hNotificationHandle, TCHAR* pTitle, BOOL bOwnsNotificationHandle)
						: CIASPropertyPage<CServerPage2> ( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
	// Add the help button to the page
//	m_psp.dwFlags |= PSP_HASHELP;

	// Initialize the pointer to the stream into which the Sdo pointer will be marshalled.
	m_pStreamSdoMarshal = NULL;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage2::~CServerPage2

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerPage2::~CServerPage2()
{
	// Release this stream pointer if this hasn't already been done.
	if( m_pStreamSdoMarshal != NULL )
	{
		m_pStreamSdoMarshal->Release();
	};

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage2::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage2::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE(_T("# CServerPage2::OnInitDialog\n"));
	

	// Check for preconditions:
	_ASSERTE( m_pStreamSdoMarshal != NULL );
	_ASSERT( m_pSynchronizer != NULL );


	// Since we've been examined, we must add to the ref count of pages who need to
	// give their approval before they can be allowed to commit changes.
	m_pSynchronizer->RaiseCount();



	HRESULT					hr;
	CComPtr<IUnknown>		spUnknown;
	CComPtr<IEnumVARIANT>	spEnumVariant;
	long					ulCount;
	ULONG					ulCountReceived;
	CComBSTR				bstrTemp;


	// Unmarshall an ISdo interface pointer.
	// The code setting up this page should make sure that it has
	// marshalled the Sdo interface pointer into m_pStreamSdoMarshal.
	hr =  CoGetInterfaceAndReleaseStream(
						  m_pStreamSdoMarshal		  //Pointer to the stream from which the object is to be marshaled
						, IID_ISdo				//Reference to the identifier of the interface
						, (LPVOID *) &m_spSdoServer    //Address of output variable that receives the interface pointer requested in riid
						);

	// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
	// We set it to NULL so that our destructor doesn't try to release this again.
	m_pStreamSdoMarshal = NULL;

	if( FAILED( hr) || m_spSdoServer == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr );

		return 0;
	}
	


	hr = m_spSdoServer->QueryInterface( IID_ISdoServiceControl, (void **) & m_spSdoServiceControl );
	if( FAILED( hr ) )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr );

		return 0;
	}		
	m_spSdoServiceControl->AddRef();







	// Get the SDO protocols collection so that we can get the RADIUS protocol.

	hr = ::SDOGetSdoFromCollection(		  m_spSdoServer
										, PROPERTY_IAS_PROTOCOLS_COLLECTION
										, PROPERTY_COMPONENT_ID
										, IAS_PROTOCOL_MICROSOFT_RADIUS
										, &m_spSdoRadiusProtocol
										);
	
	if( FAILED(hr) || m_spSdoRadiusProtocol == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_READ_DATA_FROM_SDO, NULL, hr );

		return 0;
	}



	// Get all the data from the RADIUS Sdo.


	hr = GetSdoBSTR( m_spSdoRadiusProtocol, PROPERTY_RADIUS_AUTHENTICATION_PORT, &bstrTemp, IDS_ERROR__SERVER_READING_RADIUS_AUTHENTICATION_PORT, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SetDlgItemText(IDC_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT, bstrTemp );

		// Initialize the dirty bits;
		// We do this after we've set all the data above otherwise we get false
		// notifications that data has changed when we set the edit box text.
		m_fDirtyAuthenticationPort = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			// This item has not yet been initialized.
			SetDlgItemText(IDC_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT, _T("") );
			m_fDirtyAuthenticationPort = TRUE;
			SetModified( TRUE );
		}

	}
	bstrTemp.Empty();


	
	hr = GetSdoBSTR( m_spSdoRadiusProtocol, PROPERTY_RADIUS_ACCOUNTING_PORT, &bstrTemp, IDS_ERROR__SERVER_READING_RADIUS_ACCOUNTING_PORT, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SetDlgItemText(IDC_EDIT_SERVER_PAGE2_ACCOUNTING_PORT, bstrTemp );
		m_fDirtyAccountingPort = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			SetDlgItemText(IDC_EDIT_SERVER_PAGE2_ACCOUNTING_PORT, _T("") );
			m_fDirtyAccountingPort = TRUE;
			SetModified( TRUE );
		}
	}


	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage2::OnChange

Called when the WM_COMMAND message is sent to our page with any of the
BN_CLICKED, EN_CHANGE or CBN_SELCHANGE notifications.

This is our chance to check to see what the user has touched, set the
dirty bits for these items so that only they will be saved,
and enable the Apply button.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage2::OnChange(		
							  UINT uMsg
							, WPARAM wParam
							, HWND hwnd
							, BOOL& bHandled
							)
{
	ATLTRACE(_T("# CServerPage2::OnChange\n"));

	
	// Check for preconditions:
	// None.
	

	// We don't want to prevent anyone else down the chain from receiving a message.
	bHandled = FALSE;


	// Figure out which item has changed and set the dirty bit for that item.
	int iItemID = (int) LOWORD(wParam);

	switch( iItemID )
	{
	case IDC_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT:
		m_fDirtyAuthenticationPort = TRUE;
		break;
	case IDC_EDIT_SERVER_PAGE2_ACCOUNTING_PORT:
		m_fDirtyAccountingPort = TRUE;
		break;
	default:
		return TRUE;
		break;
	}

	// We should only get here if the item that changed was
	// one of the ones we were checking for.
	// This enables the Apply button.
	SetModified( TRUE );

	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage2::OnApply

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnApply gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnApply method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerPage2::OnApply()
{
	ATLTRACE(_T("# CServerPage2::OnApply\n"));
	

	// Check for preconditions:
	_ASSERT( m_pSynchronizer != NULL );


	if( m_spSdoRadiusProtocol == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO );

		return FALSE;
	}


	HRESULT hr;
	CComBSTR bstrTemp;
	BOOL bResult;
	BOOL bAccountingPortChanged = FALSE;
	BOOL bAuthenticationPortChanged = FALSE;

	// Save data from property page to the RADIUS protocol Sdo.


	if( m_fDirtyAuthenticationPort )
	{
		bResult = GetDlgItemText( IDC_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT, (BSTR &) bstrTemp );
		if( ! bResult )
		{
			// We couldn't retrieve a BSTR, in other words the field was blank.
			// This is an error.
			ShowErrorDialog( m_hWnd, IDS_ERROR__AUTHENTICATION_PORT_CANT_BE_BLANK );

			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			
			return FALSE;
		}
		hr = PutSdoBSTR( m_spSdoRadiusProtocol, PROPERTY_RADIUS_AUTHENTICATION_PORT, &bstrTemp, IDS_ERROR__SERVER_WRITING_RADIUS_AUTHENTICATION_PORT, m_hWnd, NULL );
		bstrTemp.Empty();
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			
			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyAuthenticationPort = FALSE;
			
			// Set the flag that determines whether we need
			// to put up the restart server warning dialog.
			bAuthenticationPortChanged = TRUE;
		}

	}

	if( m_fDirtyAccountingPort )
	{
		bResult = GetDlgItemText( IDC_EDIT_SERVER_PAGE2_ACCOUNTING_PORT, (BSTR &) bstrTemp );
		if( ! bResult )
		{
			// We couldn't retrieve a BSTR, in other words the field was blank.
			// This is an error.
			ShowErrorDialog( m_hWnd, IDS_ERROR__ACCOUNTING_PORT_CANT_BE_BLANK );

			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );

			::PostMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(IDC_EDIT_SERVER_PAGE2_ACCOUNTING_PORT), 1 );
			
			return FALSE;
		}
		hr = PutSdoBSTR( m_spSdoRadiusProtocol, PROPERTY_RADIUS_ACCOUNTING_PORT, &bstrTemp, IDS_ERROR__SERVER_WRITING_RADIUS_ACCOUNTING_PORT, m_hWnd, NULL );
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			::PostMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(IDC_EDIT_SERVER_PAGE2_ACCOUNTING_PORT), 1 );
			
			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyAccountingPort = FALSE;

			// Set the flag that determines whether we need
			// to put up the restart server warning dialog.
			bAccountingPortChanged = TRUE;
		}
	}

	// If we made it to here, try to apply the changes.
	// Try to apply changes made to Radius Protocol.

	// Check to see if there are other pages which have not yet validated their data.
	LONG lRefCount = m_pSynchronizer->LowerCount();
	if( lRefCount <= 0 )
	{
		// There is nobody else left, so now we can commit the data.
	
		// First try to apply changes made to server.
		hr = m_spSdoServer->Apply();
		if( FAILED( hr ) )
		{
			if(hr == DB_E_NOTABLE)	// assume, the RPC connection has problem
				ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
			else		
			{		
//			m_spSdoServer->LastError( &bstrError );
//			ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, bstrError );
				ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO );
			}
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );

			return FALSE;
		}
		else
		{
			// We succeeded.
		}

		// Now try to apply the changes made to the Radius Protocol.
		hr = m_spSdoRadiusProtocol->Apply();
		if( FAILED( hr ) )
		{
			if(hr == DB_E_NOTABLE)	// assume, the RPC connection has problem
				ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
			else		
			{
//			m_spSdoRadiusProtocol->LastError( &bstrError );
//			ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, bstrError );
				ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO );
			}
			
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );

			return FALSE;
		}
		else
		{
			// We succeeded.



			// Tell the service to reload data.
			HRESULT hrTemp = m_spSdoServiceControl->ResetService();
			if( FAILED( hrTemp ) )
			{
				// Fail silently.
			}


			// Check to see whether we need to put up a dialog which
			// informs the user that they will need to restart the
			// service for changes in port values to take effect.
			if( bAuthenticationPortChanged || bAccountingPortChanged )
			{

				// This uses the resource ID of this page to make this page the current page.
				PropSheet_SetCurSelByID( GetParent(), IDD );

				// Put up the informational dialog.
				ShowErrorDialog(
							  m_hWnd
							, IDS_WARNING__SERVICE_MUST_BE_RESTARTED_FOR_PORTS
							, NULL
							, S_OK
							, IDS_WARNING_TITLE__SERVICE_MUST_BE_RESTARTED_FOR_PORTS
							, NULL
							, MB_OK | MB_ICONINFORMATION
							);

			}
		}
	}


	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage2::OnQueryCancel

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnQueryCancel gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnQueryCancel method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerPage2::OnQueryCancel()
{
	ATLTRACE(_T("# CServerPage2::OnQueryCancel\n"));
	
	HRESULT hr;

	if( m_spSdoRadiusProtocol != NULL )
	{
		// If the user wants to cancel, we should make sure that we rollback
		// any changes the user may have started.

		// If the user had not already tried to commit something,
		// a cancel on an SDO will hopefully be designed to be benign.
		
		hr = m_spSdoRadiusProtocol->Restore();
		// Don't care about the HRESULT.

	}

	return TRUE;

}



/////////////////////////////////////////////////////////////////////////////
/*++

CServerPage2::GetHelpPath

Remarks:

	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help
	button of a property sheet.

	It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerPage2::GetHelpPath( LPTSTR szHelpPath )
{
	ATLTRACE(_T("# CServerPage2::GetHelpPath\n"));


	// Check for preconditions:



#ifdef UNICODE_HHCTRL
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("idh_proppage_server2.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "idh_proppage_server2.htm" );
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverpage3.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	ServerPage3.h

Abstract:

	Header file for the CServerPage3 class.

	This is our handler class for the first CMachineNode property page.

	See ServerPage3.cpp for implementation.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_SERVER_PAGE_3_H_)
#define _IAS_SERVER_PAGE_3_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//
#include <vector>
#include <utility>	// For "pair"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



// Some typedefs for types storing the realms.
typedef std::pair< CComBSTR /* bstrFindText */, CComBSTR /* bstrReplaceText */ > REALMPAIR;
typedef std::vector< REALMPAIR > REALMSLIST;


class CServerPage3 : public CIASPropertyPage<CServerPage3>
{

public :
	
	CServerPage3( LONG_PTR hNotificationHandle, TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );
	
	~CServerPage3();


	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_PROPPAGE_SERVER3 };

	BEGIN_MSG_MAP(CServerPage3)
		COMMAND_ID_HANDLER(IDC_BUTTON_REALMS_ADD, OnRealmAdd)
		COMMAND_ID_HANDLER(IDC_BUTTON_REALMS_REMOVE, OnRealmRemove)
		COMMAND_ID_HANDLER(IDC_BUTTON_REALMS_EDIT, OnRealmEdit)
		COMMAND_ID_HANDLER(IDC_BUTTON_REALMS_MOVE_UP, OnRealmMoveUp)
		COMMAND_ID_HANDLER(IDC_BUTTON_REALMS_MOVE_DOWN, OnRealmMoveDown)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnListViewItemChanged)
		NOTIFY_CODE_HANDLER(NM_DBLCLK, OnListViewDoubleClick)
		CHAIN_MSG_MAP(CIASPropertyPage<CServerPage3>)
	END_MSG_MAP()

	BOOL OnApply();

	BOOL OnQueryCancel();

	HRESULT GetHelpPath( LPTSTR szFilePath );


	// Pointer to stream into which this page's Sdo interface
	// pointer will be marshalled.
	LPSTREAM m_pStreamSdoMarshal;

private:

	// Interface pointer for this page's sdo.
	CComPtr<ISdo>	m_spSdoServer;
	CComPtr<ISdo>	m_spSdoRealmsNames;
	CComPtr<ISdoServiceControl>	m_spSdoServiceControl;


	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnRealmAdd(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnRealmRemove(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnRealmEdit(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnRealmMoveUp(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnRealmMoveDown(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	BOOL PopulateRealmsList( int iStartIndex );

	LRESULT OnListViewItemChanged(
				  int idCtrl
				, LPNMHDR pnmh
				, BOOL& bHandled
				);

	LRESULT OnListViewDoubleClick(
				  int idCtrl
				, LPNMHDR pnmh
				, BOOL& bHandled
				);

	BOOL UpdateItemDisplay( int iItem );


	// Reading/writing between SDO's and m_RealmsList.
	HRESULT GetNames( void );
	HRESULT PutNames( void );

protected:
	// Dirty bits -- for keeping track of data which has been touched
	// so that we only save data we have to.
	BOOL m_fDirtyRealmsList;

	HWND m_hWndRealmsList;

	REALMSLIST m_RealmsList;

	HRESULT GetSDO( void );


};

#endif // _IAS_SERVER_PAGE_3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverstatus.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ServerStatus.cpp

Abstract:

	Implementation file for utility functions for connecting to a server.


Author:

    Michael A. Maguire 03/02/97

Revision History:
	mmaguire 03/02/97 - created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ServerStatus.h"
//
//
// where we can find declarations needed in this file:
//
#include "ServerNode.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



// Initialize the Help ID pairs
//const DWORD CServerStatus::m_dwHelpMap[] = 
//{
//	0, 0
//};



//////////////////////////////////////////////////////////////////////////////
/*++

CServerStatus::CServerStatus

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerStatus::CServerStatus( CServerNode *pServerNode, ISdoServiceControl * pSdoServiceControl )
{
	ATLTRACE(_T("# +++ CServerStatus::CServerStatus\n"));


	// Check for preconditions:
	_ASSERTE( pServerNode != NULL );
	_ASSERTE( pSdoServiceControl != NULL );


	m_pServerNode = pServerNode;
	m_spSdoServiceControl = pSdoServiceControl;

	m_pStreamSdoMarshal = NULL;
	m_dwLastTick = 0;
	m_lServerStatus_Should = 0;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerStatus::~CServerStatus

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerStatus::~CServerStatus()
{
	ATLTRACE(_T("# --- CServerStatus::~CServerStatus\n"));


	// Check for preconditions:

	// Release this stream pointer if this hasn't already been done.
	if( m_pStreamSdoMarshal != NULL )
	{
		m_pStreamSdoMarshal->Release();
	};

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerStatus::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerStatus::OnInitDialog(
	  UINT uMsg
	, WPARAM wParam
	, LPARAM lParam
	, BOOL& bHandled
	)
{
	ATLTRACE(_T("# CServerStatus::OnInitDialog\n"));


	// Check for preconditions:
	// None.

	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerStatus::StartServer

Call this to start (BOOL bStart = TRUE) or stop (bStart = FALSE) the server.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerStatus::StartServer( BOOL bStartServer )
{
	ATLTRACE(_T("# CServerStatus::OnInitDialog\n"));


	// Check for preconditions:
	// None.



	HRESULT hr;


	// Make sure we already aren't in the process of trying to start or 
	// stop the server.

	WORKER_THREAD_STATUS wtsStatus = GetWorkerThreadStatus();
	
	if( wtsStatus == WORKER_THREAD_STARTING ||
		wtsStatus == WORKER_THREAD_STARTED )
	{
		// We are already in progress.
		ShowWindow( SW_SHOW );
		return S_FALSE;
	}


	// Save what the user wants us to be trying to do.
	m_bStartServer = bStartServer;


	// Set what the text should be in the dialog.
	int nLoadStringResult;
	TCHAR szServerStatus[IAS_MAX_STRING];
	TCHAR szTemp[IAS_MAX_STRING];
	UINT uiStringID;

	if( m_bStartServer )
	{
		uiStringID = IDS_SERVER_STATUS__STARTING_THE_SERVER;
	}
	else
	{
		uiStringID = IDS_SERVER_STATUS__STOPPING_THE_SERVER;
	}

	nLoadStringResult = LoadString(  _Module.GetResourceInstance(), uiStringID, szServerStatus, IAS_MAX_STRING );
	_ASSERT( nLoadStringResult > 0 );

	if( m_pServerNode->m_bConfigureLocal )
	{
		nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS__STARTING_ON_LOCAL_MACHINE, szTemp, IAS_MAX_STRING );
		_ASSERT( nLoadStringResult > 0 );
		
		_tcscat( szServerStatus, szTemp );

	}
	else
	{
		nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS__STARTING_ON_MACHINE, szTemp, IAS_MAX_STRING );
		_ASSERT( nLoadStringResult > 0 );
		
		_tcscat( szServerStatus, szTemp );
		_tcscat( szServerStatus, m_pServerNode->m_bstrServerAddress );
	}

	SetDlgItemText( IDC_STATIC_SERVER_STATUS, szServerStatus );


	// Show the window.
	ShowWindow( SW_SHOW );


	// Marshall the ISdoServiceControl pointer so that worker thread will be able
	// to unmarshall it and use it properly to start/stop the server.
	hr = CoMarshalInterThreadInterfaceInStream(
					  IID_ISdoServiceControl					//Reference to the identifier of the interface.
					, m_spSdoServiceControl						//Pointer to the interface to be marshaled.
					, &( m_pStreamSdoMarshal )			//Address of output variable that receives the IStream interface pointer for the marshaled interface.
					);

	if( FAILED( hr ) )
	{
		// We failed, so make sure that we have a null pointer here.
		m_pStreamSdoMarshal = NULL;
		return S_FALSE;
	}


	m_dwLastTick = GetTickCount();

	if(m_bStartServer)
	{
		m_lServerStatus_Should = SERVICE_RUNNING;
	}
	else
	{
		m_lServerStatus_Should = SERVICE_STOPPED;
	}
	
	hr = StartWorkerThread();
	if( FAILED( hr) )
	{
		ShowWindow( SW_HIDE );
		return hr;
	}


	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerStatus::GetServerStatus

--*/
//////////////////////////////////////////////////////////////////////////////
long CServerStatus::GetServerStatus( void )
{
	DWORD	tick = GetTickCount();

	// if the stop / start command is just started
	if(tick - m_dwLastTick < USE_SHOULD_STATUS_PERIOD)
		return m_lServerStatus_Should;

	UpdateServerStatus();
	return m_lServerStatus;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerStatus::UpdateServerStatus

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerStatus::UpdateServerStatus( void )
{
	ATLTRACE(_T("# CServerStatus::UpdateServerStatus\n"));


	// Check for preconditions:
	_ASSERTE( m_spSdoServiceControl != NULL );

	
	HRESULT hr;

	hr = m_spSdoServiceControl->GetServiceStatus( &m_lServerStatus );

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerStatus::OnReceiveThreadMessage

Called when the worker thread wants to inform the main MMC thread of something.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerStatus::OnReceiveThreadMessage(
	  UINT uMsg
	, WPARAM wParam
	, LPARAM lParam
	, BOOL& bHandled
	)
{
	ATLTRACE(_T("# CServerStatus::OnReceiveThreadMessage\n"));


	// Check for preconditions:
	_ASSERTE( m_pServerNode != NULL );
	

	// The worker thread has notified us that it has finished.
	LONG lServerStatus = GetServerStatus();

	m_pServerNode->RefreshServerStatus();

	// Figure out what the worker thread did and update the UI accordingly.
	if( wParam == 0 )
	{
		// Success -- do nothing for now.
	}
	else
	{
		// Figure out appropriate error message depending on what we
		// were trying to do.

		if( m_bStartServer )
		{
			ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_START_SERVICE );
		}
		else
		{
			ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_STOP_SERVICE );
		}

		m_dwLastTick = 0;	// force not to use status_should
		m_lServerStatus_Should = 0;

	}

	// We don't want to destroy the dialog, we just want to hide it.
	ShowWindow( SW_HIDE );

	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerStatus::OnCancel

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerStatus::OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# CServerStatus::OnCancel\n"));


	// Check for preconditions:


	// We don't want to destroy the dialog, we just want to hide it.
	ShowWindow( SW_HIDE );


	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerStatus::DoWorkerThreadAction

Called by the worker thread to have this class perform its action
in the new thread.

--*/
//////////////////////////////////////////////////////////////////////////////
DWORD CServerStatus::DoWorkerThreadAction()
{
	ATLTRACE(_T("# CServerStatus::DoWorkerThreadAction\n"));


	// Check for preconditions:



	HRESULT hr;
	DWORD dwReturnValue;
	LONG lServerStatus;
	CComPtr<ISdoServiceControl> spSdoServiceControl;

	// We must call CoInitialize because we are in a new thread.
	hr = CoInitialize( NULL );


	if( FAILED( hr ) )
	{
		return( -1 );
		// Tell the main MMC thread what's up.
		PostMessageToMainThread( -1, NULL );

	}

	do	// Loop for error checking only.
	{

		// Unmarshall an ISdoServiceControl interface pointer to the server.
		hr =  CoGetInterfaceAndReleaseStream(
							  m_pStreamSdoMarshal		//Pointer to the stream from which the object is to be marshaled.
							, IID_ISdoServiceControl			//Reference to the identifier of the interface.
							, (LPVOID *) &spSdoServiceControl	//Address of output variable that receives the interface pointer requested in riid.
							);

		// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
		// We set it to NULL so that our destructor doesn't try to release this again.
		m_pStreamSdoMarshal = NULL;

		if( FAILED (hr ) )
		{
			// Error -- couldn't unmarshall SDO pointer.
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = -1;	// ISSUE: Need to figure out better return codes.
			break;
		}
		

		// Figure out what we were supposed to do.
		if( m_bStartServer )
		{
			// Start the service.
			hr = spSdoServiceControl->StartService();
		}
		else
		{
			// Stop the service.
			hr = spSdoServiceControl->StopService();
		}

		
		if( FAILED( hr ) )
		{
			// Error -- couldn't perform its job.
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = -1;	// ISSUE: Need to figure out better return codes.
			break;
		
		}

		// If we made it to here, we are OK.

		m_wtsWorkerThreadStatus = WORKER_THREAD_FINISHED;

		dwReturnValue = 0;

	} while (0);	// Loop for error checking only.

	hr = spSdoServiceControl->GetServiceStatus( &lServerStatus );

	if( SUCCEEDED( hr ) )
	{
		m_lServerStatus = lServerStatus;
	}
	else
	{
		m_lServerStatus = 0;
	}

	CoUninitialize(); 

	// Tell the main MMC thread what's up.
	PostMessageToMainThread( dwReturnValue, NULL );
	
	return dwReturnValue;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverpage2.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	ServerPage2.h

Abstract:

	Header file for the CServerPage2 class.

	This is our handler class for the second CMachineNode property page.

	See MachinePage1.cpp for implementation.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_SERVER_PAGE_2_H_)
#define _IAS_SERVER_PAGE_2_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class CServerPage2 : public CIASPropertyPage<CServerPage2>
{

public :
	
	CServerPage2( LONG_PTR hNotificationHandle, TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );

	~CServerPage2();

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_PROPPAGE_SERVER2 };

	BEGIN_MSG_MAP(CServerPage2)
		COMMAND_CODE_HANDLER(BN_CLICKED, OnChange)		
		COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
		COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		CHAIN_MSG_MAP(CIASPropertyPage<CServerPage2>)
	END_MSG_MAP()

	BOOL OnApply();

	BOOL OnQueryCancel();

	HRESULT GetHelpPath( LPTSTR szFilePath );


	// Pointer to stream into which this page's Sdo interface
	// pointer will be marshalled.
	LPSTREAM m_pStreamSdoMarshal;

private:

	// Interface pointer for this page's sdo.
	CComPtr<ISdo>	m_spSdoServer;
	CComPtr<ISdo>	m_spSdoRadiusProtocol;
	CComPtr<ISdoServiceControl>	m_spSdoServiceControl;

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnChange(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

protected:
	// Dirty bits -- for keeping track of data which has been touched
	// so that we only save data we have to.
	BOOL m_fDirtyAuthenticationPort;
	BOOL m_fDirtyAccountingPort;

};

#endif // _IAS_SERVER_PAGE_2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverstatus.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ServerStatus.h

Abstract:

	Header file for class which starts up and stops a server.

	The start/stop action takes place in a worker thread.

	See ServerStatus.cpp for implementation.

Author:

    Michael A. Maguire 03/02/98

Revision History:
	mmaguire 03/02/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_SERVER_STATUS_H_)
#define _IAS_SERVER_STATUS_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "DialogWithWorkerThread.h"
//
//
// where we can find what this class has or uses:
//
#include "sdoias.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

#define	USE_SHOULD_STATUS_PERIOD	3000	// in millisecond


class CServerNode;

class CServerStatus : public CDialogWithWorkerThread<CServerStatus>
{

public:

	CServerStatus( CServerNode *pServerNode, ISdoServiceControl *pSdoServiceControl );

	// Pass TRUE if you want to start the service, FALSE if you want to stop it.
	HRESULT StartServer( BOOL bStartServer = TRUE );


	// This asks for the most recently known status of the server.
	LONG GetServerStatus( void );

	// This instructs this class to go out (possibly over the network) and 
	// get the up-to-date status of the server.
	HRESULT UpdateServerStatus( void );


// Sort of private:

	// Things which you shouldn't need when using this class but which
	// which can't be declared private or protected for various 
	// (usually ATL template class) reasons.


	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of 
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_START_STOP_SERVER };

	BEGIN_MSG_MAP(CServerStatus)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDCANCEL, OnCancel )
		CHAIN_MSG_MAP(CDialogWithWorkerThread<CServerStatus>)
	END_MSG_MAP()

	LRESULT OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnReceiveThreadMessage(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);


	~CServerStatus( void );

	// You should not need to call this.
	DWORD DoWorkerThreadAction();


private:

	BOOL m_bStartServer;
	
	long m_lServerStatus;

	// use this status when query just after 
	// start / stop command is issued -- USE_SHOULD_STATUS_PERIOD
	long m_lServerStatus_Should;
	DWORD	m_dwLastTick;
	
	// Pointer to stream into which then main thread should marshal 
	// it's ISdoServiceControl interface so that the worker thread
	// can unmarshal it and use it to start the server.
	LPSTREAM m_pStreamSdoMarshal;

	CServerNode *m_pServerNode;

	// This pointer is used in the main thread to keep track 
	// of the ISdoServiceControl interface.
	CComPtr<ISdoServiceControl> m_spSdoServiceControl;

};


#endif // _IAS_SERVER_STATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\serverpage3.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    ServerPage3.cpp

Abstract:

	Implementation file for the CServerPage3 class.

	We implement the class needed to handle the first property page for a Machine node.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
// Needed for COleSafeArray in serverpage3.cpp.
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ServerPage3.h"
//
//
// where we can find declarations needed in this file:
//
#include "RealmDialog.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


#define NOTHING_SELECTED (-1)



// We needed this because the standard macro doesn't return the value from SNDMSG and
// sometimes we need to know whether the operation succeeded or failed.
static inline LRESULT CustomListView_SetItemState( HWND hwndLV, int i, UINT  data, UINT mask)
{
	LV_ITEM _ms_lvi;
	_ms_lvi.stateMask = mask;
	_ms_lvi.state = data;
	return SNDMSG((hwndLV), LVM_SETITEMSTATE, (WPARAM)i, (LPARAM)(LV_ITEM FAR *)&_ms_lvi);
}







/////////////////////////////////////////////////////////////////////////////
// CMyOleSafeArrayLock
//
//	Small utility class for correct locking and unlocking of safe array.
//
class CMyOleSafeArrayLock
{
	public:
	CMyOleSafeArrayLock( COleSafeArray & osa )
	{
		m_posa = & osa;
		m_posa->Lock();
	}

	~CMyOleSafeArrayLock()
	{	
		m_posa->Unlock();
	}

	private:
		
	COleSafeArray * m_posa;

};


//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::CServerPage3

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerPage3::CServerPage3( LONG_PTR hNotificationHandle, TCHAR* pTitle, BOOL bOwnsNotificationHandle)
						: CIASPropertyPage<CServerPage3> ( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
	// Add the help button to the page
//	m_psp.dwFlags |= PSP_HASHELP;

	// Initialize the pointer to the stream into which the Sdo pointer will be marshalled.
	m_pStreamSdoMarshal = NULL;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::~CServerPage3

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CServerPage3::~CServerPage3()
{
	// Release this stream pointer if this hasn't already been done.
	if( m_pStreamSdoMarshal != NULL )
	{
		m_pStreamSdoMarshal->Release();
	};

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage3::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE(_T("# CServerPage3::OnInitDialog\n"));
	

	// Check for preconditions:
	_ASSERTE( m_pStreamSdoMarshal != NULL );
	_ASSERT( m_pSynchronizer != NULL );

	HRESULT					hr;

	m_hWndRealmsList = GetDlgItem(IDC_LIST_REALMS_REPLACEMENTS);

	//
	// first, set the list box to 2 columns
	//
	LVCOLUMN lvc;
	int iCol;
	WCHAR  achColumnHeader[256];
	HINSTANCE hInst;

	// initialize the LVCOLUMN structure
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvc.fmt = LVCFMT_LEFT;
	
	lvc.cx = 150;
	lvc.pszText = achColumnHeader;

	// First column's header: Find
	hInst = _Module.GetModuleInstance();

	::LoadStringW(hInst, IDS_DISPLAY_REALMS_FIRSTCOLUMN, achColumnHeader, sizeof(achColumnHeader)/sizeof(achColumnHeader[0]));
	lvc.iSubItem = 0;
	ListView_InsertColumn(m_hWndRealmsList, 0,  &lvc);

	lvc.cx = 150;
	lvc.pszText = achColumnHeader;

	// Second column's header: Replace

	::LoadStringW(hInst, IDS_DISPLAY_REALMS_SECONDCOLUMN, achColumnHeader, sizeof(achColumnHeader)/sizeof(achColumnHeader[0]));
	lvc.iSubItem = 1;
	ListView_InsertColumn(m_hWndRealmsList, 1, &lvc);


	// Make sure that these buttons are by default disabled.
	::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_REMOVE), FALSE);
	::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_EDIT), FALSE);
	::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_MOVE_UP), FALSE);
	::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_MOVE_DOWN), FALSE);


	// Set the listview control so that click anywhere in row selects.
	// ISSUE: Won't compile when USE_MFCUNICODE=1 is set.
//	ListView_SetExtendedListViewStyleEx(m_hWndRealmsList, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);
	

	// Unmarshall our SDO interfaces.
	hr = GetSDO();
	
	if( FAILED( hr) || m_spSdoRealmsNames == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr );

		return 0;
	}


	hr = GetNames();

	hr = PopulateRealmsList( 0 );

	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnApply

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnApply gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnApply method will never get called.


--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerPage3::OnApply()
{
	ATLTRACE(_T("# CServerPage3::OnApply\n"));
	

	// Check for preconditions:
	_ASSERT( m_pSynchronizer != NULL );


	if( m_spSdoServer == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO );
		return FALSE;
	}

	
	HRESULT		hr;
	

	// ISSUE: Finish the error checking here and use the m_pSynchronizer.

	hr = PutNames();

	if( SUCCEEDED( hr ) )
	{
		hr = m_spSdoRealmsNames->Apply();
		if( SUCCEEDED( hr ) )
		{

			// Tell the service to reload data.
			HRESULT hrTemp = m_spSdoServiceControl->ResetService();
			if( FAILED( hrTemp ) )
			{
				// Fail silently.
			}

			return TRUE;
		}
		else
		{
		if(hr == DB_E_NOTABLE)	// assume, the RPC connection has problem
			ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
		else		
			ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO );
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}



}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnQueryCancel

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnQueryCancel gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnQueryCancel method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerPage3::OnQueryCancel()
{
	ATLTRACE(_T("# CServerPage3::OnQueryCancel\n"));
	
	HRESULT hr;


	return TRUE;

}



/////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::GetHelpPath

Remarks:

	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help
	button of a property sheet.

	It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerPage3::GetHelpPath( LPTSTR szHelpPath )
{
	ATLTRACE(_T("# CServerPage3::GetHelpPath\n"));


	// Check for preconditions:



#ifdef UNICODE_HHCTRL
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("idh_proppage_server3.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "idh_proppage_server3.htm" );
#endif

	return S_OK;
}





//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnRealmAdd

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage3::OnRealmAdd(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	ATLTRACE(_T("# CServerPage3::OnRealmAdd\n"));

	HRESULT hr = S_OK;

    // create the dialog box to select a condition attribute
	CRealmDialog * pRealmDialog = new CRealmDialog();
	if (NULL == pRealmDialog)
	{
		// ISSUE: Should we put up an error message here?
		return FALSE;
	}

	// Put up the dialog.
	int iResult = pRealmDialog->DoModal( m_hWnd );

	if( iResult )
	{
		// The user selected hit OK.


		try
		{

			REALMPAIR thePair = std::make_pair( pRealmDialog->m_bstrFindText, pRealmDialog->m_bstrReplaceText );


// Ashwin says 09/08/98 we will allow duplicate entries
//			// First, check to see if the pair is already in the group.
//
//			REALMSLIST::iterator theIterator;
//
//			for( theIterator = begin(); theIterator != end(); ++theIterator )
//			{
//				if( 0 == wcscmp( theIterator->first, thePair.first ) )
//				{
//					return S_FALSE;
//				}
//			}

			m_RealmsList.push_back( thePair );
		
			// Update the UI.
			PopulateRealmsList( m_RealmsList.size() -1 );

			SetModified( TRUE );

		}
		catch(...)
		{
			// Do nothing -- cleanup will happen below.
		}

	}
	else
	{
		// The user hit Cancel.
	}

	delete pRealmDialog;
	
	return TRUE;	// ISSUE: what do we need to be returning here?

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnRealmEdit

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage3::OnRealmEdit(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	ATLTRACE(_T("# CServerPage3::OnRealmEdit\n"));


	HRESULT hr = S_OK;


    // Find out what's selected.
	int iSelected = ListView_GetNextItem(m_hWndRealmsList, -1, LVNI_SELECTED);
	
	if( NOTHING_SELECTED != iSelected )
	{

		// Create the dialog box to select a condition attribute.
		CRealmDialog * pRealmDialog = new CRealmDialog();
		if (NULL == pRealmDialog)
		{
			// ISSUE: Should we put up an error message here?
			return FALSE;
		}


		pRealmDialog->m_bstrFindText = m_RealmsList[ iSelected ].first;
		pRealmDialog->m_bstrReplaceText = m_RealmsList[ iSelected ].second;


		// Put up the dialog.
		int iResult = pRealmDialog->DoModal();

		if( iResult )
		{
			// The user selected hit OK.
			m_RealmsList[ iSelected ].first = pRealmDialog->m_bstrFindText;
			m_RealmsList[ iSelected ].second = pRealmDialog->m_bstrReplaceText;

			UpdateItemDisplay( iSelected );

			SetModified( TRUE );

		}
		else
		{
			// The user hit Cancel.
		}

		delete pRealmDialog;


	}


	return TRUE;	// ISSUE: what do we need to be returning here?

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnRealmRemove

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage3::OnRealmRemove(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	ATLTRACE(_T("# CServerPage3::OnRealmRemove\n"));



	//
    // Has the user chosen any condition type yet?
    //
	LVITEM lvi;

    // Find out what's selected.
	int iSelected = ListView_GetNextItem(m_hWndRealmsList, -1, LVNI_SELECTED);
	
	if( NOTHING_SELECTED != iSelected )
	{
		// The index inside the attribute list is stored as the lParam of this item.

		m_RealmsList.erase( m_RealmsList.begin() + iSelected );
		ListView_DeleteItem(m_hWndRealmsList, iSelected );

		// Try to make sure that the same position remains selected.
		if( ! CustomListView_SetItemState(m_hWndRealmsList, iSelected, LVIS_SELECTED, LVIS_SELECTED) )
		{
			// We failed to select the same position, probably because we just
			// deleted the last element.  Try to select the position before it.
			ListView_SetItemState(m_hWndRealmsList, iSelected -1, LVIS_SELECTED, LVIS_SELECTED);
		}

		SetModified( TRUE );

	}






	return TRUE;	// ISSUE: what do we need to be returning here?

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnRealmMoveUp

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage3::OnRealmMoveUp(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	ATLTRACE(_T("# CServerPage3::OnRealmMoveUp\n"));


	// Find out what's selected.
	int iSelected = ListView_GetNextItem(m_hWndRealmsList, -1, LVNI_SELECTED);
	
	if( NOTHING_SELECTED != iSelected && iSelected > 0 )
	{
		CComBSTR bstrTempFirst;
		CComBSTR bstrTempSecond;

		// Swap the items.

		bstrTempFirst = m_RealmsList[ iSelected ].first;
		bstrTempSecond = m_RealmsList[ iSelected ].second;

		m_RealmsList[ iSelected ].first = m_RealmsList[ iSelected -1].first;
		m_RealmsList[ iSelected ].second = m_RealmsList[ iSelected -1].second;

		m_RealmsList[ iSelected -1].first = bstrTempFirst;
		m_RealmsList[ iSelected -1].second = bstrTempSecond;

		// Update items that have changed.
		UpdateItemDisplay( iSelected - 1 );
		UpdateItemDisplay( iSelected );

		// Move the selection up one item.
		ListView_SetItemState(m_hWndRealmsList, iSelected, 0, LVIS_SELECTED);
		ListView_SetItemState(m_hWndRealmsList, iSelected -1, LVIS_SELECTED, LVIS_SELECTED);

		SetModified( TRUE );


	}





	return TRUE;	// ISSUE: what do we need to be returning here?

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnRealmMoveDown

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage3::OnRealmMoveDown(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	ATLTRACE(_T("# CServerPage3::OnRealmMoveDown\n"));


	// Find out what's selected.
	int iSelected = ListView_GetNextItem(m_hWndRealmsList, -1, LVNI_SELECTED);
	
	if( NOTHING_SELECTED != iSelected && iSelected < m_RealmsList.size() -1 )
	{
		CComBSTR bstrTempFirst;
		CComBSTR bstrTempSecond;

		// Swap the items.

		bstrTempFirst = m_RealmsList[ iSelected ].first;
		bstrTempSecond = m_RealmsList[ iSelected ].second;

		m_RealmsList[ iSelected ].first = m_RealmsList[ iSelected +1].first;
		m_RealmsList[ iSelected ].second = m_RealmsList[ iSelected +1].second;

		m_RealmsList[ iSelected +1].first = bstrTempFirst;
		m_RealmsList[ iSelected +1].second = bstrTempSecond;

		// Update items that have changed.
		UpdateItemDisplay( iSelected + 1 );
		UpdateItemDisplay( iSelected );

		// Move the selection up one item.
		ListView_SetItemState(m_hWndRealmsList, iSelected, 0, LVIS_SELECTED);
		ListView_SetItemState(m_hWndRealmsList, iSelected + 1, LVIS_SELECTED, LVIS_SELECTED);


		SetModified( TRUE );

	}



	return TRUE;	// ISSUE: what do we need to be returning here?

}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::PopulateRealmsList

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerPage3::PopulateRealmsList( int iStartIndex )
{
	ATLTRACE(_T("# CServerPage3::PopulateRealmsList\n"));

	int iIndex;
	WCHAR wzText[MAX_PATH];
	WCHAR * pszNextRealm;

	LVITEM lvi;
	
	lvi.mask = LVIF_TEXT | LVIF_STATE;
	lvi.state = 0;
	lvi.stateMask = 0;
	lvi.iSubItem = 0;
	lvi.iItem = iStartIndex;


	REALMSLIST::iterator thePair;
	for( thePair = m_RealmsList.begin() + iStartIndex ; thePair != m_RealmsList.end(); ++thePair )
	{
		lvi.pszText = thePair->first;
		ListView_InsertItem(m_hWndRealmsList, &lvi);

		ListView_SetItemText(m_hWndRealmsList, lvi.iItem, 1, thePair->second);
        		
		++lvi.iItem;
    }

	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::UpdateItemDisplay

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CServerPage3::UpdateItemDisplay( int iItem )
{
	ATLTRACE(_T("# CServerPage3::UpdateItemDisplay\n"));


	ListView_SetItemText(m_hWndRealmsList, iItem, 0, m_RealmsList[iItem].first);
	ListView_SetItemText(m_hWndRealmsList, iItem, 1, m_RealmsList[iItem].second);
        		

	return TRUE;
}




//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnListViewItemChanged

We enable or disable the Remove button depending on whether an item is selected.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage3::OnListViewItemChanged(int idCtrl,
											   LPNMHDR pnmh,
											   BOOL& bHandled)
{
	ATLTRACE(_T("CServerPage3::OnListViewItemChanged\n"));

    // Find out what's selected.
	int iSelected = ListView_GetNextItem(m_hWndRealmsList, -1, LVNI_SELECTED);
	

	if ( NOTHING_SELECTED == iSelected )
	{
		// The user selected nothing, let's disable the remove button.
		::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_REMOVE), FALSE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_EDIT), FALSE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_MOVE_UP), FALSE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_MOVE_DOWN), FALSE);
	}
	else
	{
		// Yes, enable the remove button.
		::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_REMOVE), TRUE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_EDIT), TRUE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_MOVE_UP), TRUE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_REALMS_MOVE_DOWN), TRUE);
	}


	bHandled = FALSE;
	return 0;
}




//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::OnListViewDoubleClick

We enable or disable the Remove button depending on whether an item is selected.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CServerPage3::OnListViewDoubleClick(int idCtrl,
											   LPNMHDR pnmh,
											   BOOL& bHandled)
{
	ATLTRACE(_T("CServerPage3::OnListViewDoubleClick\n"));

	// Act as though the user hit Edit.
	OnRealmEdit( 0,0,0, bHandled );

	bHandled = FALSE;
	return 0;
}




//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::GetSDO

We unmarshall the interface pointers and query for the Realms SDO.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerPage3::GetSDO( void )
{
	ATLTRACE(_T("CServerPage3::GetSDO\n"));


	// Check for preconditions:
	_ASSERTE( m_pStreamSdoMarshal );


	HRESULT hr;


	// Unmarshall an ISdo interface pointer.
	// The code setting up this page should make sure that it has
	// marshalled the Sdo interface pointer into m_pStreamSdoMarshal.
	hr =  CoGetInterfaceAndReleaseStream(
						  m_pStreamSdoMarshal		  //Pointer to the stream from which the object is to be marshaled
						, IID_ISdo				//Reference to the identifier of the interface
						, (LPVOID *) &m_spSdoServer    //Address of output variable that receives the interface pointer requested in riid
						);

	// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
	// We set it to NULL so that our destructor doesn't try to release this again.
	m_pStreamSdoMarshal = NULL;

	if( FAILED( hr) || m_spSdoServer == NULL )
	{
		return E_FAIL;
	}



	hr = m_spSdoServer->QueryInterface( IID_ISdoServiceControl, (void **) & m_spSdoServiceControl );
	if( FAILED( hr ) )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr );

		return 0;
	}		
	m_spSdoServiceControl->AddRef();




	// Get the SDO event log auditor.

	hr = ::SDOGetSdoFromCollection(		  m_spSdoServer
										, PROPERTY_IAS_REQUESTHANDLERS_COLLECTION
										, PROPERTY_COMPONENT_ID
										, IAS_PROVIDER_MICROSOFT_NTSAM_NAMES
										, &m_spSdoRealmsNames
										);
	
	if( FAILED(hr) || m_spSdoRealmsNames == NULL )
	{
		return E_FAIL;
	}



	return hr;
}




//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::GetNames

Reads the list of Find/Replace strings from the SDO's into the m_RealmsList vector.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerPage3::GetNames()
{
	ATLTRACE(_T("CServerPage3::GetNames\n"));

	// Check for preconditions:
	_ASSERTE( m_spSdoRealmsNames );

	HRESULT hr;

	CComVariant spVariant;

	hr = GetSdoVariant(
					  m_spSdoRealmsNames
					, PROPERTY_NAMES_REALMS
					, &spVariant
					, IDS_ERROR_REALM_SDO_GET
					, m_hWnd
				);

	if( FAILED( hr ) )
	{
		return hr;
	}

	try
	{


		// This creates a new copy of the SAFEARRAY pointed to by m_pvarData
		// wrapped by the standard COleSafeArray instance m_osaValueList.
		COleSafeArray osaRealmsList = &spVariant;


		// Lock the safearray.  This wrapper class will unlock as soon as it goes out of scope.
		CMyOleSafeArrayLock osaLock( osaRealmsList );

		DWORD dwSize = osaRealmsList.GetOneDimSize();
		
		// We should have an even number of strings -- Find 1, Replace 1, Find 2, Replace 2, etc.
		_ASSERTE( ( dwSize % 2 ) == 0 );

		for( LONG lFindIndex = 0; lFindIndex < dwSize; lFindIndex += 2 )
		{
			VARIANT *pvarFind, *pvarReplace;

			LONG lSafeArrayReplaceIndex = lFindIndex + 1;

			osaRealmsList.PtrOfIndex( &lFindIndex, (void **) &pvarFind );
			osaRealmsList.PtrOfIndex( &lSafeArrayReplaceIndex, (void **) &pvarReplace );

			_ASSERTE( V_VT( pvarFind ) == VT_BSTR );
			_ASSERTE( V_VT( pvarReplace ) == VT_BSTR );

			CComBSTR bstrFind = V_BSTR( pvarFind );
			CComBSTR bstrReplace = V_BSTR( pvarReplace );

			REALMPAIR thePair = std::make_pair( bstrFind, bstrReplace );

			m_RealmsList.push_back( thePair );

		}



	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerPage3::PutNames

Writes the list of Find/Replace strings in the m_RealmsList
vector out to the SDO's.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CServerPage3::PutNames()
{
   ATLTRACE(_T("CServerPage3::PutNames\n"));

   // Check for preconditions:
   _ASSERTE( m_spSdoRealmsNames );

   HRESULT hr;

   LONG lSize = m_RealmsList.size();
   
   SAFEARRAY * psa;

   psa = SafeArrayCreateVector( VT_VARIANT, 0, 2 * lSize );

   for( LONG lIndex = 0; lIndex < lSize; ++lIndex )
   {

      VARIANT varFind, varReplace;

      LONG lSafeArrayFindIndex = 2 * lIndex;
      LONG lSafeArrayReplaceIndex = lSafeArrayFindIndex + 1;


      VariantInit( &varFind );
      V_VT( &varFind ) = VT_BSTR;
      V_BSTR( &varFind ) = m_RealmsList[ lIndex ].first;

      VariantInit( &varReplace );
      V_VT( &varReplace ) = VT_BSTR;
      V_BSTR( &varReplace ) = m_RealmsList[ lIndex ].second;

      hr = SafeArrayPutElement( psa, &lSafeArrayFindIndex, &varFind );
      if (FAILED(hr))
      {
         SafeArrayDestroy(psa); // ignore the return value
         return hr;
      }
      hr = SafeArrayPutElement( psa, &lSafeArrayReplaceIndex, &varReplace );
      if (FAILED(hr))
      {
         SafeArrayDestroy(psa); // ignore the return value
         return hr;
      }
   }

   VARIANT spVariant;

   VariantInit( &spVariant );

   V_VT( &spVariant ) = VT_VARIANT | VT_ARRAY;

   V_ARRAY( &spVariant ) = psa;


   hr = PutSdoVariant(
                 m_spSdoRealmsNames
               , PROPERTY_NAMES_REALMS
               , &spVariant
               , IDS_ERROR_REALM_SDO_PUT
               , m_hWnd
            );

   VariantClear( &spVariant );

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\vendors.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the classes VendorData and Vendors.
//
///////////////////////////////////////////////////////////////////////////////

#include "precompiled.h"
#include "vendors.h"

// Reference counted collection of NAS vendors. This data is shared by mutliple
// instances of Vendors since it's read only.
class VendorData
{
public:
   // Control the reference count.
   void AddRef() throw ();
   void Release() throw ();

   // Sentinel value used by VendorIdToOrdinal.
   static const size_t invalidOrdinal;

   // Returns the ordinal for a given VendorId or invalidOrdinal if the
   // vendorId doesn't exist.
   size_t VendorIdToOrdinal(long vendorId) const throw ();

   // Returns the vendor ID for ordinal or zero if the ordinal is out of range.
   const OLECHAR* GetName(size_t ordinal) const throw ();

   // Returns the vendor ID for ordinal or zero if the ordinal is out of range.
   long GetVendorId(size_t ordinal) const throw ();

   // Returns the number of entries in the vendors collection.
   size_t Size() const throw ();

   // Creates a new instance of VendorData from the SDO collection.
   static HRESULT CreateInstance(
                     ISdoCollection* vendorsSdo,
                     VendorData** newObj
                     ) throw ();

private:
   // These are private since VendorData is ref counted.
   VendorData() throw ();
   ~VendorData() throw ();

   // Helper function used by CreateInstance.
   HRESULT Initialize(ISdoCollection* vendorsSdo) throw ();

   // Struct binding a vendor ID to the corresponding vendor name.
   struct Entry
   {
      long vendorId;
      CComBSTR name;
   };

   Entry* entries;   // Array of vendors.
   long numEntries;  // Number of vendors.
   long refCount;    // Current reference count.

   // Not implemented.
   VendorData(const VendorData&);
   VendorData& operator=(const VendorData&);
};


inline VendorData::VendorData() throw ()
   : entries(0), numEntries(0), refCount(1)
{
}


inline VendorData::~VendorData() throw ()
{
   delete[] entries;
}


inline void VendorData::AddRef() throw ()
{
   InterlockedIncrement(&refCount);
}


inline void VendorData::Release() throw ()
{
   if (InterlockedDecrement(&refCount) == 0)
   {
      delete this;
   }
}


const size_t VendorData::invalidOrdinal = static_cast<size_t>(-1);


size_t VendorData::VendorIdToOrdinal(long vendorId) const throw ()
{
   for (size_t i = 0; i < numEntries; ++i)
   {
      if (entries[i].vendorId == vendorId)
      {
         return i;
      }
   }

   return invalidOrdinal;
}


inline const OLECHAR* VendorData::GetName(size_t ordinal) const throw ()
{
   return (ordinal < numEntries) ? entries[ordinal].name.m_str : 0;
}


inline long VendorData::GetVendorId(size_t ordinal) const throw ()
{
   return (ordinal < numEntries) ? entries[ordinal].vendorId : 0;
}


inline size_t VendorData::Size() const throw ()
{
   return numEntries;
}


HRESULT VendorData::CreateInstance(
                       ISdoCollection* vendorsSdo,
                       VendorData** newObj
                       ) throw ()
{
   if (vendorsSdo == 0 || newObj == 0) { return E_POINTER; }

   *newObj = new (std::nothrow) VendorData;
   if (*newObj == 0) { return E_OUTOFMEMORY; }

   HRESULT hr = (*newObj)->Initialize(vendorsSdo);
   if (FAILED(hr))
   {
      delete *newObj;
      *newObj = 0;
   }

   return hr;
}


HRESULT VendorData::Initialize(ISdoCollection* vendorsSdo)
{
   HRESULT hr;

   // How many vendors are there?
   long value;
   hr = vendorsSdo->get_Count(&value);
   if (FAILED(hr)) { return hr; }
   size_t count = static_cast<size_t>(value);

   // Allocate space to hold the entries.
   entries = new (std::nothrow) Entry[count];
   if (entries == 0) { return E_OUTOFMEMORY; }

   // Get an enumerator for the collection.
   CComPtr<IUnknown> unk;
   hr = vendorsSdo->get__NewEnum(&unk);
   if (FAILED(hr)) { return hr; }

   CComPtr<IEnumVARIANT> iter;
   hr = unk->QueryInterface(
                __uuidof(IEnumVARIANT),
                reinterpret_cast<void**>(&iter)
                );
   if (FAILED(hr)) { return hr; }

   // Iterate through the collection.
   CComVariant element;
   unsigned long fetched;
   while (iter->Next(1, &element, &fetched) == S_OK &&
          fetched == 1 &&
          numEntries < count)
   {
      // Convert the entry to an Sdo.
      hr = element.ChangeType(VT_DISPATCH);
      if (FAILED(hr)) { return hr; }

      if (V_DISPATCH(&element) == 0) { return E_POINTER; }

      CComPtr<ISdo> attribute;
      hr = V_DISPATCH(&element)->QueryInterface(
                                    __uuidof(ISdo),
                                    reinterpret_cast<void**>(&attribute)
                                    );
      if (FAILED(hr)) { return hr; }

      // Clear the VARIANT, so we can use it on the next iteration.
      element.Clear();

      // Get the vendor ID and validate the type.
      CComVariant vendorId;
      hr = attribute->GetProperty(PROPERTY_NAS_VENDOR_ID, &vendorId);
      if (FAILED(hr)) { return hr; }

      if (V_VT(&vendorId) != VT_I4) { return DISP_E_TYPEMISMATCH; }

      // Get the vendor name and validate the type.
      CComVariant name;
      hr = attribute->GetProperty(PROPERTY_SDO_NAME, &name);
      if (FAILED(hr)) { return hr; }

      if (V_VT(&name) != VT_BSTR) { return DISP_E_TYPEMISMATCH; }

      // Store away the data.
      entries[numEntries].vendorId = V_I4(&vendorId);
      entries[numEntries].name.Attach(V_BSTR(&name));
      V_VT(&name) = VT_EMPTY;

      // We successfully added an entry.
      ++numEntries;
   }

   return S_OK;
}


Vendors::Vendors() throw ()
   : data(0)
{
}


inline void Vendors::AddRef() throw ()
{
   if (data)
   {
      data->AddRef();
   }
}


inline void Vendors::Release() throw ()
{
   if (data)
   {
      data->Release();
   }
}


Vendors::Vendors(const Vendors& original) throw ()
   : data(original.data)
{
   AddRef();
}


Vendors& Vendors::operator=(const Vendors& rhs) throw ()
{
   if (data != rhs.data)
   {
      Release();
      data = rhs.data;
      AddRef();
   }

   return *this;
}


Vendors::~Vendors() throw ()
{
   Release();
}


const size_t Vendors::invalidOrdinal = VendorData::invalidOrdinal;


size_t Vendors::VendorIdToOrdinal(long vendorId) const throw ()
{
   return data ? data->VendorIdToOrdinal(vendorId) : invalidOrdinal;
}


const OLECHAR* Vendors::GetName(size_t ordinal) const throw ()
{
   return data ? data->GetName(ordinal) : 0;
}


long Vendors::GetVendorId(size_t ordinal) const throw ()
{
   return data ? data->GetVendorId(ordinal) : 0;
}


size_t Vendors::Size() const throw ()
{
   return data ? data->Size() : 0;
}


HRESULT Vendors::Reload(ISdoCollection* vendorsSdo) throw ()
{
   VendorData* newData;
   HRESULT hr = VendorData::CreateInstance(vendorsSdo, &newData);
   if (SUCCEEDED(hr))
   {
      Release();
      data = newData;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\vendors.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class Vendors.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef VENDORS_H
#define VENDORS_H
#pragma once

struct ISdoCollection;
class VendorData;

// Maintains the collection of NAS vendors.
class Vendors
{
public:
   // Construct an empty vendors collection.
   Vendors() throw ();

   Vendors(const Vendors& original) throw ();
   Vendors& operator=(const Vendors& rhs) throw ();
   ~Vendors() throw ();

   // Sentinel value used by VendorIdToOrdinal.
   static const size_t invalidOrdinal;

   // Returns the ordinal for a given VendorId or invalidOrdinal if the
   // vendorId doesn't exist.
   size_t VendorIdToOrdinal(long vendorId) const throw ();

   // Returns the name for ordinal or null if the ordinal is out of range.
   const OLECHAR* GetName(size_t ordinal) const throw ();

   // Returns the vendor ID for ordinal or zero if the ordinal is out of range.
   long GetVendorId(size_t ordinal) const throw ();

   // Returns the number of entries in the vendors collection.
   size_t Size() const throw ();

   // Reload the collection from an Sdo collection.
   HRESULT Reload(ISdoCollection* vendorsSdo) throw ();

private:
   void AddRef();
   void Release();
   VendorData* data;
};

#endif // VENDORS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\about.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    About.h

Abstract:

	Header file for the CSnapinAbout class.

	The CSnapinAbout class implements the ISnapinAbout interface which enables the MMC 
	console to get copyright and version information from the snap-in.
	The console also uses this interface to obtain images for the static folder
	from the snap-in.

	See About.cpp for implementation.


Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_ABOUT_H_)
#define _NAP_ABOUT_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class ATL_NO_VTABLE CSnapinAbout : 
	  public ISnapinAbout
	, public CComObjectRoot
	, public CComCoClass< CSnapinAbout, &CLSID_NAPSnapinAbout>
{

public:
	
	DECLARE_REGISTRY(CSnapinAbout, _T("NAPSnapinAbout.1"), _T("NAPSnapinAbout.1"), IDS_NAPSNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CSnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)( LPOLESTR *lpDescription );

    STDMETHOD(GetProvider)( LPOLESTR *lpName );

    STDMETHOD(GetSnapinVersion)( LPOLESTR *lpVersion );

    STDMETHOD(GetSnapinImage)( HICON *hAppIcon );

    STDMETHOD(GetStaticFolderImage)(
		  HBITMAP *hSmallImage
		, HBITMAP *hSmallImageOpen
		, HBITMAP *hLargeImage
		, COLORREF *cMask
		);

};

#endif // _NAP_ABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\about.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    About.cpp

Abstract:

	Implementation file for the CSnapinAbout class.

	The CSnapinAbout class implements the ISnapinAbout interface which enables the MMC 
	console to get copyright and version information from the snap-in.
	The console also uses this interface to obtain images for the static folder
	from the snap-in.


Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "About.h"
//
//
// where we can find declarations needed in this file:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetSnapinDescription


Enables the console to obtain the text for the snap-in's description box.


HRESULT GetSnapinDescription(
  LPOLESTR * lpDescription  // Pointer to the description text.
);

  
Parameters

lpDescription 
[out] Pointer to the text for the description box on an About property page. 


Return Values

S_OK 
The text was successfully obtained. 


Remarks
Memory for out parameters must be allocated using CoTaskMemAlloc. This function is documented in the Platform SDK.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription (LPOLESTR *lpDescription)
{
	ATLTRACE(_T("+NAPMMC+:# CSnapinAbout::GetSnapinDescription\n"));

	USES_CONVERSION;

	TCHAR szBuf[256];
	if (::LoadString(_Module.GetResourceInstance(), IDS_NAPSNAPIN_DESC, szBuf, 256) == 0)
		return E_FAIL;

	*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
	if (*lpDescription == NULL)
		return E_OUTOFMEMORY;

	ocscpy(*lpDescription, T2OLE(szBuf));

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetProvider


Enables the console to obtain the snap-in provider's name.


HRESULT GetProvider(
  LPOLESTR * lpName  // Pointer to the provider's name
);

  
Parameters

lpName 
[out] Pointer to the text making up the snap-in provider's name. 


Return Values

S_OK 
The name was successfully obtained. 


Remarks

Memory for out parameters must be allocated using CoTaskMemAlloc. This function is documented in the Platform SDK.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetProvider (LPOLESTR *lpName)
{
	ATLTRACE(_T("+NAPMMC+:# CSnapinAbout::GetProvider\n"));

	USES_CONVERSION;
	TCHAR szBuf[256];
	if (::LoadString(_Module.GetResourceInstance(), IDS_NAPSNAPIN_PROVIDER, szBuf, 256) == 0)
		return E_FAIL;

	*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
	if (*lpName == NULL)
		return E_OUTOFMEMORY;

	ocscpy(*lpName, T2OLE(szBuf));

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetSnapinVersion


Enables the console to obtain the snap-in's version number.


HRESULT GetSnapinVersion(
  LPOLESTR* lpVersion  // Pointer to the version number.
);
 

Parameters

lpVersion 
[out] Pointer to the text making up the snap-in's version number. 


Return Values

S_OK 
The version number was successfully obtained. 


Remarks

Memory for out parameters must be allocated using CoTaskMemAlloc. This function is documented in the Platform SDK.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinVersion (LPOLESTR *lpVersion)
{
	ATLTRACE(_T("+NAPMMC+:# CSnapinAbout::GetSnapinVersion\n"));

	USES_CONVERSION;
	TCHAR szBuf[256];
	if (::LoadString(_Module.GetResourceInstance(), IDS_NAPSNAPIN_VERSION, szBuf, 256) == 0)
		return E_FAIL;

	*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
	if (*lpVersion == NULL)
		return E_OUTOFMEMORY;

	ocscpy(*lpVersion, T2OLE(szBuf));

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetSnapinImage


Enables the console to obtain the snap-in's main icon to be used in the About box.


HRESULT GetSnapinImage(
  HICON * hAppIcon  // Pointer to the application's main icon
);
 

Parameters

hAppIcon 
[out] Pointer to the handle of the main icon of the snap-in that is to be used in the About property page. 


Return Values

S_OK 
The handle to the icon was successfully obtained. 

  ISSUE: What do I return if I can't get the icon?

Remarks

Memory for out parameters must be allocated using CoTaskMemAlloc. This function is documented in the Platform SDK.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinImage (HICON *hAppIcon)
{
	ATLTRACE(_T("+NAPMMC+:# CSnapinAbout::GetSnapinImage\n"));

	
	// ISSUE: be sure it is GetSnapinImage that returns this icon and not something
	// from GetStaticFolderImage.

	// ISSUE: should probably use LoadImage here instead
	if ( NULL == (*hAppIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_NAP_SNAPIN_IMAGE) ) ) )
		return E_FAIL;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinAbout::GetStaticFolderImage


Allows the console to obtain the static folder images for the scope and result panes.

As of version 1.1 of MMC, the icon returned here will be the icon used on
the root node of our snapin. 



HRESULT GetStaticFolderImage(
  HBITMAP * hSmallImage,  // Pointer to a handle to a small icon.
  HBITMAP * hSmallImageOpen,  // Pointer to a handle to open folder 
                              // icon.
  HBITMAP * hLargeImage,  // Pointer to a handle to a large icon.
  COLORREF * cMask        // Color used to generate a mask.
);
 

Parameter

hSmallImage 
[out] Pointer to the handle of a small icon (16x16n pixels) in either the scope or result view pane.

hSmallImageOpen 
[out] Pointer to the handle of a small open-folder icon (16x16n pixels).

hLargImage 
[out] Pointer to the handle of a large icon (32x32n pixels).

cMask 
[out] Pointer to a COLORREF structure that specifies the color used to generate a mask. This structure is documented in the Platform SDK. 


Return Values

S_OK 
The icon was successfully obtained. 

  ISSUE: What should we return if we fail?

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapinAbout::GetStaticFolderImage (
	HBITMAP *hSmallImage,
    HBITMAP *hSmallImageOpen,
    HBITMAP *hLargeImage,
    COLORREF *cMask)
{

	ATLTRACE(_T("+NAPMMC+:# CSnapinAbout::GetStaticFolderImage\n"));
	
/*	
	
	if( NULL == (*hSmallImageOpen = (HBITMAP) LoadImage(
		_Module.GetResourceInstance(),   // handle of the instance that contains the image  
		MAKEINTRESOURCE(IDB_CRAPWIZ_OPEN_16),  // name or identifier of image
		IMAGE_BITMAP,        // type of image  
		0,     // desired width
		0,     // desired height  
		LR_DEFAULTCOLOR        // load flags
		) ) )
	{
		return E_FAIL;
	}


	if( NULL == (*hSmallImage = (HBITMAP) LoadImage(
		_Module.GetResourceInstance(),   // handle of the instance that contains the image  
		MAKEINTRESOURCE(IDB_CRAPWIZ_16),  // name or identifier of image
		IMAGE_BITMAP,        // type of image  
		0,     // desired width
		0,     // desired height  
		LR_DEFAULTCOLOR        // load flags
		) ) )
	{
		return E_FAIL;
	}

	if( NULL == (*hLargeImage = (HBITMAP) LoadImage(
		_Module.GetResourceInstance(),   // handle of the instance that contains the image  
		MAKEINTRESOURCE(IDB_CRAPWIZ_32),  // name or identifier of image
		IMAGE_BITMAP,        // type of image  
		0,     // desired width
		0,     // desired height  
		LR_DEFAULTCOLOR        // load flags
		) ) )
	{
		return E_FAIL;
	}


*/
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\component.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    Component.cpp

Abstract:

   Implementation file for the CComponent class.

   The CComponent class implements several interfaces which MMC uses:
   
   The IComponent interface is basically how MMC talks to the snap-in
   to get it to implement a right-hand-side "scope" pane.  There can be several
   objects implementing this interface instantiated at once.  These are best
   thought of as "views" on the single object implementing the IComponentData
   "document" (see ComponentData.cpp).

   The IExtendPropertySheet interface is how the snap-in adds property sheets
   for any of the items a user might click on.

   The IExtendContextMenu interface what we do to add custom entries
   to the menu which appears when a user right-clicks on a node.
   
   The IExtendControlBar interface allows us to support a custom
   iconic toolbar.

   The IResultDataCompare interface allows us to support a custom
   sorting algorithm for result pane items

Note:

   Much of the functionality of this class is implemented in atlsnap.h
   by IComponentDataImpl.  We are mostly overriding here.

Revision History:
   mmaguire 11/6/97  - created using MMC snap-in wizard
   mmaguire 11/24/97 - hurricaned for better project structure

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "proxyres.h"
#include "Component.h"
//
// where we can find declarations needed in this file:
//
#include "MachineNode.h"
#include "PoliciesNode.h"
#include "PolicyNode.h"
#include "ChangeNotification.h"
#include "globals.h"
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::CComponent

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CComponent::CComponent()
   :m_pSelectedNode(NULL),
    m_nLastClickedColumn(1),
    m_dwLastSortOptions(0)
{
   TRACE_FUNCTION("CComponent::CComponent");
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::~CComponent

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CComponent::~CComponent()
{
   TRACE_FUNCTION("CComponent::~CComponent");
}


//+---------------------------------------------------------------------------
//
// Function:  Compare
//
// Class:     CComponent  (inherited from IResultDataCompare)
//
// Synopsis:  customized sorting algorithm
//         This method will be called whenever MMC console needs to
//         compare two result pane data items, for example, when user
//         clicks on the column header
//
// Arguments:
//   LPARAM lUserParam,   User-provided information
//   MMC_COOKIE cookieA,  Unique identifier of first object
//   MMC_COOKIE cookieB,  Unique identifier of second object
//   int * pnResult       Column being sorted//
//
// Returns:   STDMETHODIMP -
//
// History:   Created byao    2/5/98 4:19:10 PM
//
//+---------------------------------------------------------------------------
STDMETHODIMP CComponent::Compare(LPARAM lUserParam,
                     MMC_COOKIE cookieA,
                     MMC_COOKIE cookieB,
                     int *pnResult)
{
   TRACE_FUNCTION("CComponent::Compare");

   //
   // sort policies node according to their merit value
   //
   CPolicyNode *pA = (CPolicyNode*)cookieA;
   CPolicyNode *pB = (CPolicyNode*)cookieB;

   ATLASSERT(pA != NULL);
   ATLASSERT(pB != NULL);

   int nCol = *pnResult;

   switch(nCol)
   {
   case  0:
      *pnResult = wcscmp(pA->GetResultPaneColInfo(0), pB->GetResultPaneColInfo(0));
      break;
   case  1:
      *pnResult = pA->GetMerit() - pB->GetMerit();
      if(*pnResult)
         *pnResult /= abs(*pnResult);

      break;
   }

   return S_OK;
}


/*!--------------------------------------------------------------------------
   CComponent::OnResultContextHelp
      Implementation of OnResultContextHelp
   Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CComponent::OnResultContextHelp(LPDATAOBJECT lpDataObject)
{
   // Need to find if the context is running in the Remote Access snap-in 
   // or in the IAS snapin.
   // path if in IAS: ias_ops.chm::/sag_ias_rap_node.htm
   // path in RAS snapin: rrasconcepts.chm::/sag_rap_node.htm
   
   const WCHAR szIASDefaultHelpTopic[] = L"ias_ops.chm::" \
                                         L"/sag_ias_rap_node.htm";
   const WCHAR szRASDefaultHelpTopic[] = L"RRASconcepts.chm::" \
                                         L"/sag_rap_node.htm";

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   bool isRasSnapin = false;

   CSnapInItem* pItem;
   DATA_OBJECT_TYPES type;

   HRESULT hr = GetDataClass(lpDataObject, &pItem, &type);
   if ( SUCCEEDED(hr) ) 
   {
      isRasSnapin = (pItem->m_helpIndex == RAS_HELP_INDEX);
   } 

   CComPtr<IDisplayHelp>  spDisplayHelp;

   hr = m_spConsole->QueryInterface(
                        __uuidof(IDisplayHelp), 
                        (LPVOID*) &spDisplayHelp
                        );
   
   ASSERT (SUCCEEDED (hr));
   if ( SUCCEEDED (hr) )
   {
      if ( isRasSnapin )
      {
         hr = spDisplayHelp->ShowTopic(W2OLE ((LPWSTR)szRASDefaultHelpTopic));
      }
      else
      {
         hr = spDisplayHelp->ShowTopic(W2OLE ((LPWSTR)szIASDefaultHelpTopic));
      }

      ASSERT (SUCCEEDED (hr));
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::Notify

Notifies the snap-in of actions taken by the user.

HRESULT Notify(
  LPDATAOBJECT lpDataObject,  // Pointer to a data object
  MMC_NOTIFY_TYPE event,      // Action taken by a user
  LPARAM arg,                 // Depends on event
  LPARAM param                // Depends on event
);


Parameters

   lpDataObject
   [in] Pointer to the data object of the currently selected item.

   event
   [in] Identifies an action taken by a user. IComponent::Notify can receive the
   following notifications:

      MMCN_ACTIVATE
      MMCN_ADD_IMAGES
      MMCN_BTN_CLICK
      MMCN_CLICK
      MMCN_DBLCLICK
      MMCN_DELETE
      MMCN_EXPAND
      MMCN_MINIMIZED
      MMCN_PROPERTY_CHANGE
      MMCN_REMOVE_CHILDREN
      MMCN_RENAME
      MMCN_SELECT
      MMCN_SHOW
      MMCN_VIEW_CHANGE

   All of which are forwarded to each node's Notify method, as well as:

      MMCN_COLUMN_CLICK
      MMCN_SNAPINHELP

   Which are handled here.


   arg
   Depends on the notification type.

   param
   Depends on the notification type.


Return Values

   S_OK
   Depends on the notification type.

   E_UNEXPECTED
   An unexpected error occurred.


Remarks

   We are overiding the ATLsnap.h implementation of IComponentImpl because
   it always returns E_UNEXPECTED when lpDataObject == NULL.
   Unfortunately, some valid message (e.g. MMCN_SNAPINHELP and MMCN_COLUMN_CLICK)
   pass in lpDataObject = NULL   by design.

   Also, there seems to be some problem with Sridhar's latest
   IComponentImpl::Notify method, because it causes MMC to run-time error.


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponent::Notify (
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param
      )
{
   TRACE_FUNCTION("CComponent::Notify");

   HRESULT hr;

   // deal with help
   if(event == MMCN_CONTEXTHELP)
   {
       return OnResultContextHelp(lpDataObject);
   }

   // lpDataObject should be a pointer to a node object.
   // If it is NULL, then we are being notified of an event
   // which doesn't pertain to any specific node.

   if ( NULL == lpDataObject )
   {
      // respond to events which have no associated lpDataObject

      switch( event )
      {
      case MMCN_COLUMN_CLICK:
         hr = OnColumnClick( arg, param );
         break;

      case MMCN_PROPERTY_CHANGE:
         hr = OnPropertyChange( arg, param );
         break;

      case MMCN_VIEW_CHANGE:
         hr = OnViewChange( arg, param );
         break;

      default:
         ATLTRACE(_T("+NAPMMC+:# CComponent::Notify - called with lpDataObject == NULL and no event handler\n"));
         hr = E_NOTIMPL;
         break;
      }
      return hr;
   }

   // Respond to some notifications where the lpDataObject is not NULL
   // but we nevertheless have decided that we want to handle them on a
   // per-IComponent basis.

   switch( event )
   {
   case MMCN_ADD_IMAGES:
      return OnAddImages( arg, param );
      break;
   }

   // We were passed a LPDATAOBJECT which corresponds to a node.
   // We convert this to the ATL ISnapInDataInterface pointer.
   // This is done in GetDataClass (a static method of ISnapInDataInterface)
   // by asking the dataobject via a supported clipboard format (CCF_GETCOOKIE)
   // to write out a pointer to itself on a stream and then
   // casting this value to a pointer.
   // We then call the Notify method on that object, letting
   // the node object deal with the Notify event itself.

   CSnapInItem* pData;
   DATA_OBJECT_TYPES type;
   hr = CSnapInItem::GetDataClass(lpDataObject, &pData, &type);
   
   if (SUCCEEDED(hr))
   {
      // We need a richer Notify method which has information about the IComponent and IComponentData objects
      //hr = pData->Notify(event, arg, param, TRUE, m_spConsole, NULL, NULL);

      hr = pData->Notify(event, arg, param, NULL, this, type );
   }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CComponent::CompareObjects

Needed so that IPropertySheetProvider::FindPropertySheet will work.

FindPropertySheet is used to bring a pre-existing property sheet to the foreground
so that we don't open multiple copies of Properties on the same node.

It requires CompareObjects to be implemented on both IComponent and IComponentData.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponent::CompareObjects(
        LPDATAOBJECT lpDataObjectA
      , LPDATAOBJECT lpDataObjectB
      )
{
   TRACE_FUNCTION("CComponent::CompareObjects");

   HRESULT hr;

   CSnapInItem *pDataA, *pDataB;
   DATA_OBJECT_TYPES typeA, typeB;

   hr = GetDataClass(lpDataObjectA, &pDataA, &typeA);
   if ( FAILED( hr ) )
   {
      return hr;
   }
   
   hr = GetDataClass(lpDataObjectB, &pDataB, &typeB);
   if ( FAILED( hr ) )
   {
      return hr;
   }

   if( pDataA == pDataB )
   {
      // They are the same object.
      return S_OK;
   }
   else
   {
      // They are different.
      return S_FALSE;
   }
}


/////////////////////////////////////////////////////////////////////////////
/*++

CComponent::OnColumnClick

HRESULT OnColumnClick(  
           LPARAM arg
         , LPARAM param
         )

In our implementation, this method gets called when the MMCN_COLUMN_CLICK
Notify message is sent for our IComponent object.

MMC sends this message when the user clicks on a result-list view column header.


Parameters

   arg
   Column number.

   param
   Sort option flags. By default, the sort is in ascending order. To specify descending order, use the RSI_DESCENDING (0x0001) flag.


Return Values
   
   Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::OnColumnClick(
     LPARAM arg
   , LPARAM param
   )
{
   TRACE_FUNCTION("CComponent::OnColumnClick -- Not implemented");

   m_nLastClickedColumn = arg;
   m_dwLastSortOptions = param;

   return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::OnViewChange

HRESULT OnViewChange(   
           LPARAM arg
         , LPARAM param
         )

This is where we respond to an MMCN_VIEW_CHANGE notification which was
set without any reference to a specific node.

In our implementation, this is a signal to refresh the view of the currently
selected node for this IComponent's view.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::OnViewChange(   
           LPARAM arg
         , LPARAM param
         )
{
   ATLTRACE(_T("+NAPMMC+:# CComponent::OnViewChange\n"));

   HRESULT hr = S_FALSE;

   CChangeNotification *pChangeNotification = NULL;

   try
   {
      // If arg here is non-NULL, it should be a pointer to a CChangeNotification object.
      if( arg != NULL )
      {
         pChangeNotification = (CChangeNotification *) arg;

         // For now, just call update item on the node.
         
         // ISSUE: Later, we should have a switch on m_dwFlags to see what we should do.
         // e.g. in the case of a deletion, we should (maybe?) reselect parent node or something.

         switch( pChangeNotification->m_dwFlags )
         {
         case CHANGE_UPDATE_RESULT_NODE:
            {
               // We need to update a single node.
               
               CComQIPtr< IResultData, &IID_IResultData > spResultData( m_spConsole );
               if( ! spResultData )
               {
                  throw hr;
               }

               if( pChangeNotification->m_pNode )
               {
                  HRESULTITEM item;
                  hr = spResultData->FindItemByLParam( (LPARAM) pChangeNotification->m_pNode, &item );
                  // Note: You can't use the itemID stored in CSnapInItem's RESULTDATAITEM structure
                  // as this itemID is unique to each view -- so when you add the same item in each
                  // result pane view, you get a different itemID from each call to InsertItem.
                  // CSnapInItem's RESULTDATAITEM structure only stores the last one stored.
                  // This is a flaw in the atlsnap.h architecture, which is why we use
                  // MMC's FindItemByLParam instead to get the appropriate itemID.
                  hr = spResultData->UpdateItem( item );
               }
            }
            break;
         
            case CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE:
            {
               // reselecting the node was causing too many message to fly around and
                    // causing a deadlock condition when extending RRAS.
                    // The correct way to do this is to just add the result pane items if we are selected.
               if( m_pSelectedNode )
               {
                  SCOPEDATAITEM *pScopeDataItem;
                  m_pSelectedNode->GetScopeData( &pScopeDataItem );

                  CComQIPtr< IResultData, &IID_IResultData > spResultData( m_spConsole );
                  if( ! spResultData )
                  {
                     throw hr;
                  }

                  ((CPoliciesNode *) m_pSelectedNode)->UpdateResultPane(spResultData);
               }
            }
            break;

            case CHANGE_UPDATE_CHILDREN_OF_THIS_NODE:
            {
               // We basically tell MMC to simulate reselecting the
               // currently selected scope-pane node, which causes it to redraw.
               // This will cause MMC to send the MMCN_SHOW notification
               // to the selected node.
               if( pChangeNotification->m_pNode && m_pSelectedNode && pChangeNotification->m_pNode == m_pSelectedNode )
               {
                  SCOPEDATAITEM *pScopeDataItem;
                  m_pSelectedNode->GetScopeData( &pScopeDataItem );
                  hr = m_spConsole->SelectScopeItem( pScopeDataItem->ID );
               }

            }
         case CHANGE_RESORT_PARENT:
            {
               // We need to swap a node's display with the one above it and make
               // sure that the node appears to remain selected.

               // We only want to bother here if the currently selected node in this view
               // is the parent of the node which needs to be moved up.
               if( pChangeNotification->m_pParentNode && m_pSelectedNode && pChangeNotification->m_pParentNode == m_pSelectedNode )
               {

                  CComQIPtr< IResultData, &IID_IResultData > spResultData( m_spConsole );
                  if( ! spResultData )
                  {
                     throw hr;
                  }

                  // Our IResultDataCompare implementation returns an answer based on
                  // each policy's relative merit.
                  // The first parameter below is the 0-based column,
                  // in this case the Order column.
                  
                  hr = spResultData->Sort( m_nLastClickedColumn, m_dwLastSortOptions, NULL );

                  // This is a bit of a work-around for the fact
                  // that MMC doesn't seem to update the item's
                  // toolbar buttons (e.g. Up/Down enabled) unless
                  // The items are reselected.
                  if( pChangeNotification->m_pNode )
                  {
                     HRESULTITEM item;
                     HRESULT hrTemp = spResultData->FindItemByLParam( (LPARAM) pChangeNotification->m_pNode, &item );
                     if( SUCCEEDED(hrTemp) )
                     {
                        // See whether the item is selected.
                        RESULTDATAITEM rdi;
                        ZeroMemory( &rdi, sizeof(rdi) );
                        rdi.itemID = item;
                        rdi.mask = RDI_STATE;
                        hrTemp = spResultData->GetItem( &rdi );
                        if( SUCCEEDED( hrTemp ) && (rdi.nState & LVIS_SELECTED) )
                        {
                           // De-select and re-select the node.
                           // This causes the toolbar buttons to be redrawn.
                           hrTemp = spResultData->ModifyItemState( 0, item, 0, LVIS_SELECTED );
                           hrTemp = spResultData->ModifyItemState( 0, item, LVIS_SELECTED, 0 );
                        }
                     }

                  }
               }
            }
            break;

         default:
            break;
         }

      }
   }
   catch(...)
   {
      // Do nothing -- just need to catch for proper clean-up below.
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::OnAddImages

HRESULT OnAddImages( 
           LPARAM arg
         , LPARAM param
         )

This is where we respond to an MMCN_ADD_IMAGES notification to
this IComponent object.

We add images to the image list used to display result pane
items corresponding to this IComponent's view.

MMC sends this message to the snap-in's IComponent implementation
to add images for the result pane.

Parameters

   arg
   Pointer to the result pane's image list (IImageList).

   param
   Specifies the HSCOPEITEM of the item that was selected or deselected.


Return Values

   Not used.


Remarks

   The primary snap-in should add images for both folders and leaf
   items. Extension snap-ins should add only folder images.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::OnAddImages( 
           LPARAM arg
         , LPARAM param
         )
{
   ATLTRACE(_T("# CComponent::OnAddImages\n"));

   // Check for preconditions:
   _ASSERTE( arg != NULL );

   HRESULT hr = S_FALSE;

   // ISSUE: sburns in localsec does a trick where he combines
   // scope and result pane ImageLists into one
   // is this necessary?
   
   CComPtr<IImageList> spImageList = reinterpret_cast<IImageList*>(arg);
   _ASSERTE( spImageList != NULL );

   HBITMAP hBitmap16 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_NAPSNAPIN_16 ) );
   HBITMAP hBitmap32 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_NAPSNAPIN_32 ) );

   if( hBitmap16 != NULL && hBitmap32 != NULL )
   {
      hr = spImageList->ImageListSetStrip( (LONG_PTR*) hBitmap16, (LONG_PTR*) hBitmap32, 0, RGB(255, 0, 255) );
      if( FAILED( hr ) )
      {
         ATLTRACE(_T("# *** CSnapinNode::OnAddImages  -- Failed to add images.\n"));
      }
   }

   if ( hBitmap16 != NULL )
   {
      DeleteObject(hBitmap16);
   }

   if ( hBitmap32 != NULL )
   {
      DeleteObject(hBitmap32);
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponent::GetWatermarks(
                                 LPDATAOBJECT lpIDataObject,
                                 HBITMAP *lphWatermark,
                                 HBITMAP *lphHeader,
                                 HPALETTE *lphPalette,
                                 BOOL *bStretch
                                 )
{
   if(!lphWatermark || !lphHeader || !lphPalette || !bStretch)
      return E_INVALIDARG;
      
   *lphWatermark = LoadBitmap(
                      _Module.GetResourceInstance(),
                     MAKEINTRESOURCE(IDB_RAP_WATERMARK)
                     );

   *lphHeader = LoadBitmap(
                   _Module.GetResourceInstance(),
                   MAKEINTRESOURCE(IDB_RAP_HEADER)
                   );

   *lphPalette = NULL;
   *bStretch = FALSE;
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponent::OnPropertyChange

HRESULT OnPropertyChange(  
           LPARAM arg
         , LPARAM param
         )

This is where we respond to an MMCN_PROPERTY_CHANGE notification.

This notification is sent when we call MMCPropertyChangeNotify.
We call this in our property pages when changes are made to the data
they contain and we may need to update of view of the data.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponent::OnPropertyChange(  
           LPARAM lArg
         , LPARAM lParam
         )
{
   ATLTRACE(_T("# CNodeWithResultChildrenList::OnPropertyChange\n"));

   // Check for preconditions:
   _ASSERTE( m_spConsole != NULL );

   HRESULT hr = S_FALSE;

   if( lParam )
   {
      // We were passed a pointer to a CChangeNotification in the param argument.

      CChangeNotification * pChangeNotification = (CChangeNotification *) lParam;
      
      // We call notify on the node specified, passing it our own custom event type
      // so that it knows that it must refresh its data.

      // Call notify on this node with the MMCN_PROPERTY_CHANGE notification.
      // We had to use this trick because of the fact that we are using template
      // classes and so we have no common object among all our nodes
      // other than CSnapInItem.  But we can't change CSnapInItem
      // so instead we use the notify method it already has with a new
      // notification.
      
      // Note:  We are trying to deal gracefully here with the fact that the
      // MMCN_PROPERTY_CHANGE notification doesn't pass us an lpDataObject
      // so we have to have our own protocol for picking out which node
      // needs to update itself.
      
      hr = pChangeNotification->m_pNode->Notify( MMCN_PROPERTY_CHANGE
                     , NULL
                     , NULL
                     , NULL
                     , NULL
                     , (DATA_OBJECT_TYPES) 0
                     );

      // We want to make sure all views with this node select also get updated.
      // Pass it the CChangeNotification pointer we were passed in param.
      hr = m_spConsole->UpdateAllViews( NULL, lParam, 0);
   
      pChangeNotification->Release();
   
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\component.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    Component.h

Abstract:

   The CComponent class implements several interfaces which MMC uses:
   
   The IComponent interface is basically how MMC talks to the snap-in
   to get it to implement a right-hand-side "scope" pane.  There can be several
   objects implementing this interface instantiated at once.  These are best
   thought of as "views" on the single object implementing the IComponentData
   "document" (see ComponentData.cpp).

   The IExtendPropertySheet interface is how the snap-in adds property sheets
   for any of the items a user might click on.

   The IExtendContextMenu interface what we do to add custom entries
   to the menu which appears when a user right-clicks on a node.
   
   The IExtendControlBar interface allows us to support a custom
   iconic toolbar.

   See Component.cpp for implementation details.

Note:

   Much of the functionality of this class is implemented in atlsnap.h
   by IComponentImpl.  We are mostly overriding here.


Revision History:
   mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_COMPONENT_H_)
#define _NAP_COMPONENT_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//Moved to Precompiled.h: #include <atlsnap.h>
//
//
// where we can find what this class has or uses:
//
#include "ComponentData.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class CComponent :
     public CComObjectRootEx<CComSingleThreadModel>
   , public CSnapInObjectRoot<2, CComponentData>
   , public IExtendPropertySheetImpl<CComponent>
   , public IExtendContextMenuImpl<CComponent>
   , public IExtendControlbarImpl<CComponent>
   , public IResultDataCompare
   , public IExtendTaskPadImpl<CComponent>
   , public IComponentImpl<CComponent>
{

public:

   BEGIN_COM_MAP(CComponent)
      COM_INTERFACE_ENTRY(IComponent)
      COM_INTERFACE_ENTRY(IExtendPropertySheet2)
      COM_INTERFACE_ENTRY(IExtendContextMenu)
      COM_INTERFACE_ENTRY(IExtendControlbar)
      COM_INTERFACE_ENTRY(IResultDataCompare)
      COM_INTERFACE_ENTRY(IExtendTaskPad)
   END_COM_MAP()

   CComponent();

   ~CComponent();

   // We are overiding ATLsnap.h's IComponentImpl implementation of this
   // in order to correctly handle messages which it is incorrectly
   // ignoring (e.g. MMCN_COLUMN_CLICK and MMCN_SNAPINHELP)

   STDMETHOD(Notify)(
          LPDATAOBJECT lpDataObject
        , MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
      );

   STDMETHOD(CompareObjects)(
           LPDATAOBJECT lpDataObjectA
         , LPDATAOBJECT lpDataObjectB
         );

   // IResultDataCompare
   STDMETHOD(Compare)(LPARAM lUserParam,
        MMC_COOKIE cookieA,
        MMC_COOKIE cookieB,
        int *pnResult);

   // IExtendPropertySheet2 -- to support wizard 97
   STDMETHOD(GetWatermarks)( 
            LPDATAOBJECT lpIDataObject,
             HBITMAP *lphWatermark,
             HBITMAP *lphHeader,
             HPALETTE *lphPalette,
             BOOL *bStretch);

   CSnapInItem * m_pSelectedNode;

protected:

   virtual HRESULT OnColumnClick(
        LPARAM arg
      , LPARAM param
      );

   virtual HRESULT OnViewChange( 
        LPARAM arg
      , LPARAM param
      );

   virtual HRESULT OnPropertyChange(   
        LPARAM arg
      , LPARAM param
      );

   virtual HRESULT OnAddImages(  
           LPARAM arg
         , LPARAM param
         );

   // html help
   HRESULT OnResultContextHelp(LPDATAOBJECT lpDataObject);

public:
   int   m_nLastClickedColumn;
   DWORD m_dwLastSortOptions;
};


#endif // _NAP_COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\componentdata.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ComponentData.cpp

Abstract:

   Implementation file for the CComponentData class.

   The CComponentData class implements several interfaces which MMC uses:
   
   The IComponentData interface is basically how MMC talks to the snap-in
   to get it to implement the left-hand-side "scope" pane.  There is only one
   object implementing this interface instantiated -- it is best thought of as
   the main "document" on which the objects implementing the IComponent interface
   (see Component.cpp) are "views".

   The IExtendPropertySheet interface is how the snap-in adds property sheets
   for any of the items a user might click on.

   The IExtendContextMenu interface what we do to add custom entries
   to the menu which appears when a user right-clicks on a node.
   
   The IExtendControlBar interface allows us to support a custom
   iconic toolbar.

Note:

   Much of the functionality of this class is implemented in atlsnap.h
   by IComponentDataImpl.  We are mostly overriding here.


Revision History:
   mmaguire 11/6/97  - created using MMC snap-in wizard
   mmaguire 11/24/97 - hurricaned for better project structure

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ComponentData.h"
//
// where we can find declarations needed in this file:
//
#include "MachineNode.h"
#include "PoliciesNode.h"
#include "PolicyNode.h"
#include "Component.h"
#include <stdio.h>
#include "ChangeNotification.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::CComponentData

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData::CComponentData()
{
   ATLTRACE(_T("+NAPMMC+:# +++ CComponentData::CComponentData\n"));

   // We pass our CRootNode a pointer to this CComponentData.  This is so that
   // it and any of its children nodes have access to our member variables
   // and services, and thus we have snapin-global data if we need it
   // using the GetComponentData function.
// m_pNode = new CRootNode( this );
// _ASSERTE(m_pNode != NULL);

   m_pComponentData = this;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::~CComponentData

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData::~CComponentData()
{
   ATLTRACE(_T("+NAPMMC+:# --- CComponentData::~CComponentData\n"));

// delete m_pNode;
// m_pNode = NULL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::Initialize

HRESULT Initialize(
  LPUNKNOWN pUnknown  // Pointer to console's IUnknown.
);

Called by MMC to initialize the IComponentData object.


Parameters

   pUnknown [in] Pointer to the console's IUnknown interface. This interface
   pointer can be used to call QueryInterface for IConsole and IConsoleNameSpace.


Return Values

   S_OK  The component was successfully initialized.

   E_UNEXPECTED
   An unexpected error occurred.


Remarks

   IComponentData::Initialize is called when a snap-in is being created and has
   items in the scope pane to enumerate. The pointer to IConsole that is passed
   in is used to make QueryInterface calls to the console for interfaces such as
   IConsoleNamespace. The snap-in should also call IConsole::QueryScopeImageList
   to get the image list for the scope pane and add images to be displayed on
   the scope pane side.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::Initialize (LPUNKNOWN pUnknown)
{

   ATLTRACE(_T("+NAPMMC+:# CComponentData::Initialize\n"));

   // MAM: special for extention snapin:
   m_CMachineNode.m_pComponentData = this;


   HRESULT hr = IComponentDataImpl<CComponentData, CComponent >::Initialize(pUnknown);
   if (FAILED(hr))
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CComponentData::Initialize -- Base class initialization\n"));
      return hr;
   }

   CComPtr<IImageList> spImageList;

   if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: IConsole::QueryScopeImageList failed\n"));
      return E_UNEXPECTED;
   }

   // Load bitmaps associated with the scope pane
   // and add them to the image list

   HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NAPSNAPIN_16));
   if (hBitmap16 == NULL)
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CComponentData::Initialize -- LoadBitmap\n"));
      //ISSUE: Will MMC still be able to function if this fails?
      return S_OK;
   }

   HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NAPSNAPIN_32));
   if (hBitmap32 == NULL)
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CComponentData::Initialize -- LoadBitmap\n"));
      //ISSUE: Will MMC still be able to function if this fails?

      //ISSUE: Should DeleteObject previous hBitmap16 since it was successfully loaded.
      
      return S_OK;
   }

   if (spImageList->ImageListSetStrip((LONG_PTR*)hBitmap16, (LONG_PTR*)hBitmap32, 0, RGB(255, 0, 255)) != S_OK)
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CComponentData::Initialize  -- ImageListSetStrip\n"));
      return E_UNEXPECTED;
   }

   // ISSUE: Do we need to release the HBITMAP objects?
   // This wasn't done wizard-generated code -- does MMC make a copy of these or
   // does it take care of deleting the ones we passed to it?
   // DeleteObject( hBitmap16 );
   // DeleteObject( hBitmap32 );

   //
   //  NAP snap-in will need to use ListView common control to display
   //  attribute types for a particular rule. We need to initialize the common
   //  controls during initialization. This can ensure COMTRL32.DLL is loaded
   //
   INITCOMMONCONTROLSEX initCommCtrlsEx;

   initCommCtrlsEx.dwSize = sizeof(INITCOMMONCONTROLSEX);
   initCommCtrlsEx.dwICC = ICC_WIN95_CLASSES ;

   if (!InitCommonControlsEx(&initCommCtrlsEx))
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CComponentData::Initialize  -- InitCommonControlsEx()\n"));

      return E_UNEXPECTED;
   }
   return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::CompareObjects

Needed so that IPropertySheetProvider::FindPropertySheet will work.

FindPropertySheet is used to bring a pre-existing property sheet to the foreground
so that we don't open multiple copies of Properties on the same node.

It requires CompareObjects to be implemented on both IComponent and IComponentData.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::CompareObjects(
        LPDATAOBJECT lpDataObjectA
      , LPDATAOBJECT lpDataObjectB
      )
{
   ATLTRACE(_T("+NAPMMC+:# CComponentData::CompareObjects\n"));

   HRESULT hr;

   CSnapInItem *pDataA, *pDataB;
   DATA_OBJECT_TYPES typeA, typeB;

   hr = GetDataClass(lpDataObjectA, &pDataA, &typeA);
   if ( FAILED( hr ) )
   {
      return hr;
   }
   
   hr = GetDataClass(lpDataObjectB, &pDataB, &typeB);
   if ( FAILED( hr ) )
   {
      return hr;
   }

   if( pDataA == pDataB )
   {
      // They are the same object.
      return S_OK;
   }
   else
   {
      // They are different.
      return S_FALSE;
   }
}


/////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::CreateComponent

We override the ATLsnap.h implementation so that we can save away our 'this'
pointer into the CComponent object we create.  This way the IComponent object
has knowledge of the CComponentData object to which it belongs.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
   ATLTRACE(_T("# CComponentData::CreateComponent\n"));

   HRESULT hr = E_POINTER;

   ATLASSERT(ppComponent != NULL);
   if (ppComponent == NULL)
      ATLTRACE(_T("# IComponentData::CreateComponent called with ppComponent == NULL\n"));
   else
   {
      *ppComponent = NULL;
      
      CComObject< CComponent >* pComponent;
      hr = CComObject< CComponent >::CreateInstance(&pComponent);
      ATLASSERT(SUCCEEDED(hr));
      if (FAILED(hr))
         ATLTRACE(_T("# IComponentData::CreateComponent : Could not create IComponent object\n"));
      else
      {
         hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
      
         pComponent->m_pComponentData = this;
      }
      
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::Notify

Notifies the snap-in of actions taken by the user.

HRESULT Notify(
  LPDATAOBJECT lpDataObject,  // Pointer to a data object
  MMC_NOTIFY_TYPE event,  // Action taken by a user
  LPARAM arg,               // Depends on event
  LPARAM param              // Depends on event
);


Parameters

   lpDataObject
   [in] Pointer to the data object of the currently selected item.

   event
   [in] Identifies an action taken by a user. IComponent::Notify can receive the
   following notifications:

      MMCN_ACTIVATE
      MMCN_ADD_IMAGES
      MMCN_BTN_CLICK
      MMCN_CLICK
      MMCN_DBLCLICK
      MMCN_DELETE
      MMCN_EXPAND
      MMCN_MINIMIZED
      MMCN_PROPERTY_CHANGE
      MMCN_REMOVE_CHILDREN
      MMCN_RENAME
      MMCN_SELECT
      MMCN_SHOW
      MMCN_VIEW_CHANGE

   All of which are forwarded to each node's Notify method, as well as:

      MMCN_COLUMN_CLICK
      MMCN_SNAPINHELP

   Which are handled here.


   arg
   Depends on the notification type.

   param
   Depends on the notification type.


Return Values

   S_OK
   Depends on the notification type.

   E_UNEXPECTED
   An unexpected error occurred.


Remarks

   We are overiding the ATLsnap.h implementation of IComponentImpl because
   it always returns E_UNEXPECTED when lpDataObject == NULL.
   Unfortunately, some valid message (e.g. MMCN_SNAPINHELP and MMCN_COLUMN_CLICK)
   pass in lpDataObject = NULL   by design.

   Also, there seems to be some problem with Sridhar's latest
   IComponentImpl::Notify method, because it causes MMC to run-time error.


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::Notify (
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
{
   ATLTRACE(_T("# CComponentData::Notify\n"));


   // Check for preconditions:
   // None.

   HRESULT hr;

   // lpDataObject should be a pointer to a node object.
   // If it is NULL, then we are being notified of an event
   // which doesn't pertain to any specific node.

   if ( NULL == lpDataObject )
   {
      // respond to events which have no associated lpDataObject
      switch( event )
      {

      case MMCN_PROPERTY_CHANGE:
         hr = OnPropertyChange( arg, param );
         break;

      default:
         ATLTRACE(_T("# CComponent::Notify - called with lpDataObject == NULL and no event handler\n"));
         hr = E_NOTIMPL;
         break;
      }

      return hr;
   }

   // We were passed a LPDATAOBJECT which corresponds to a node.
   // We convert this to the ATL ISnapInDataInterface pointer.
   // This is done in GetDataClass (a static method of ISnapInDataInterface)
   // by asking the dataobject via a supported clipboard format (CCF_GETCOOKIE)
   // to write out a pointer to itself on a stream and then
   // casting this value to a pointer.
   // We then call the Notify method on that object, letting
   // the node object deal with the Notify event itself.

   CSnapInItem* pItem;
   DATA_OBJECT_TYPES type;
   hr = m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
   
   ATLASSERT(SUCCEEDED(hr));
   
   if (SUCCEEDED(hr))
   {
      hr = pItem->Notify( event, arg, param, this, NULL, type );
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::OnPropertyChange

HRESULT OnPropertyChange(  
           LPARAM arg
         , LPARAM param
         )

This is where we respond to an MMCN_PROPERTY_CHANGE notification.

This notification is sent when we call MMCPropertyChangeNotify.
We call this in our property pages when changes are made to the data
they contain and we may need to update of view of the data.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentData::OnPropertyChange( 
           LPARAM arg
         , LPARAM lParam
         )
{
   ATLTRACE(_T("# CComponentData::OnPropertyChange\n"));

   // Check for preconditions:
   _ASSERTE( m_spConsole != NULL );
   
   HRESULT hr = S_FALSE;

   if( lParam != NULL )
   {
      // We were passed a pointer to a CChangeNotification in the param argument.

      CChangeNotification * pChangeNotification = (CChangeNotification *) lParam;

      // We call notify on the node specified, passing it our own custom event type
      // so that it knows that it must refresh its data.

      // Call notify on this node with the MMCN_PROPERTY_CHANGE notification.
      // We had to use this trick because of the fact that we are using template
      // classes and so we have no common object among all our nodes
      // other than CSnapInItem.  But we can't change CSnapInItem
      // so instead we use the notify method it already has with a new
      // notification.
      
      // Note:  We are trying to deal gracefully here with the fact that the
      // MMCN_PROPERTY_CHANGE notification doesn't pass us an lpDataObject
      // so we have to have our own protocol for picking out which node
      // needs to update itself.
      
      hr = pChangeNotification->m_pNode->Notify( MMCN_PROPERTY_CHANGE
                     , NULL
                     , NULL
                     , NULL
                     , NULL
                     , (DATA_OBJECT_TYPES) 0
                     );

      // We want to make sure all views with this node select also get updated.
      // Pass it the CChangeNotification pointer we were passed in param.
      hr = m_spConsole->UpdateAllViews( NULL, lParam, 0);

      pChangeNotification->Release();
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CComponentData::GetWatermarks

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CComponentData::GetWatermarks( 
                                LPDATAOBJECT lpIDataObject,
                                HBITMAP *lphWatermark,
                                HBITMAP *lphHeader,
                                HPALETTE *lphPalette,
                                BOOL *bStretch
                                )
{
   *lphWatermark = LoadBitmap(
                      _Module.GetResourceInstance(),
                      MAKEINTRESOURCE(IDB_RAP_WATERMARK)
                      );
   *lphHeader = LoadBitmap(
                   _Module.GetResourceInstance(),
                   MAKEINTRESOURCE(IDB_RAP_HEADER)
                   );

   *lphPalette = NULL;
   *bStretch = FALSE;
   return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\condition.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       condition.h
//
//--------------------------------------------------------------------------

// Condition.h: interface for the CCondition class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _CONDITION__INCLUDE_
#define _CONDITION__INCLUDE_

#include "atltmp.h"


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000



typedef enum _CONDITIONTYPE
{
	IAS_MATCH_CONDITION		= 0x01,
	IAS_TIMEOFDAY_CONDITION = IAS_MATCH_CONDITION + 1,
	IAS_NTGROUPS_CONDITION	= IAS_TIMEOFDAY_CONDITION + 1
}	CONDITIONTYPE;




class CCondition  
{
public:
	CCondition(IIASAttributeInfo* pAttributeInfo, ATL::CString& strConditionText);
	CCondition(IIASAttributeInfo* pAttributeInfo);
	virtual ~CCondition() {};

	// editor for this conditon type
	// must be implemented by subclass
	virtual HRESULT Edit() = 0; 
	virtual ATL::CString GetDisplayText();
	virtual WCHAR*  GetConditionText();

public:
	//
    // pointer to the condition attribute
	//
	CComPtr<IIASAttributeInfo>	m_spAttributeInfo;

	// condition text for the condition
	// this is public so client can access this string very easily
	ATL::CString			m_strConditionText; 

};


// Useful function for adding condition lists to SdoCollections.
// Used in both PolicyPage1.cpp and AddPolicyWizardPage2.cpp
HRESULT WriteConditionListToSDO( 		CSimpleArray<CCondition*> & ConditionList 
									,	ISdoCollection * pConditionCollectionSdo
									,	HWND hWnd
									);


#endif // ifndef _CONDITION__INCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\condlist.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    condlist.cpp
//
// SYNOPSIS
//
//    Defines the class ConditionList.
//
// MODIFICATION HISTORY
//
//    03/01/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <precompiled.h>
#include <condlist.h>
#include <condition.h>
#include <iasattrlist.h>
#include <enumcondition.h>
#include <matchcondition.h>
#include <todcondition.h>
#include <ntgcond.h>
#include <selcondattr.h>

CIASAttrList*
WINAPI
CreateCIASAttrList() throw ()
{
   return new CIASAttrList();
}

VOID
WINAPI
DestroyCIASAttrList(CIASAttrList* attrList) throw ()
{
   delete attrList;
}

PVOID
WINAPI
ExtractCIASAttrList(CIASAttrList* attrList) throw ()
{
   return &attrList->m_AttrList;
}

#define SetModified(x) modified = x

ConditionList::~ConditionList() throw ()
{
   clear();
}

void ConditionList::finalConstruct(
                        HWND dialog,
                        CIASAttrList* attrList,
                        LONG attrFilter,
                        ISdoDictionaryOld* dnary,
                        ISdoCollection* conditions,
                        PCWSTR machineName,
                        PCWSTR policyName
                        ) throw ()
{
   m_hWnd = dialog;
   m_pIASAttrList = attrList;
   m_filter = attrFilter;
   m_spDictionarySdo = dnary;
   m_spConditionCollectionSdo = conditions;
   m_pPolicyNode->m_bstrDisplayName = const_cast<PWSTR>(policyName);
   m_pPolicyNode->m_pszServerAddress = const_cast<PWSTR>(machineName);
}

void ConditionList::clear()
{
   for (int i = 0; i < m_ConditionList.GetSize(); ++i)
   {
      delete m_ConditionList[i];
   }

   m_ConditionList.RemoveAll();
}

::CString ConditionList::getDisplayText()
{
   CreateConditions();

   ::CString text;

   for (int i = 0; i < m_ConditionList.GetSize(); ++i)
   {
      text += L"    ";

      text += m_ConditionList[i]->GetDisplayText();

      if (i != m_ConditionList.GetSize() - 1)
      {
         // it's not the last condition, then we put an 'AND' at the
         // end of the condition text
         text += L" AND\n";
      }
   }

   return text;
}

HRESULT   StripCondTextPrefix(
               ATL::CString& strExternCondText,
               ATL::CString& strCondText,
               ATL::CString& strCondAttr,
               CONDITIONTYPE*   pdwCondType
               );

BOOL ConditionList::onInitDialog()
{
   if (!CreateConditions()) { return FALSE; }

   HRESULT hr = PopulateConditions();
   if ( FAILED(hr) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "PopulateConditions() returns %x", hr);
      return FALSE;
   }

   return TRUE;   // ISSUE: what do we need to be returning here?
}

BOOL ConditionList::onApply()
{
   HRESULT      hr = S_OK;
   int         iIndex;

   //
   // do we have any conditions for this policy?
   // We don't allow policy with no conditions
   //
   if ( ! m_ConditionList.GetSize() )
   {
      ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "The policy has no condition");
      ShowErrorDialog(m_hWnd
                  , IDS_ERROR_ZERO_CONDITION_POLICY
                  , NULL
                  );
      return FALSE;
   }

   // Save the conditions to the SDO
   hr = WriteConditionListToSDO( m_ConditionList, m_spConditionCollectionSdo, m_hWnd );
   if( FAILED( hr ) )
   {
      // We output an error message in the function.
      return FALSE;
   }

   return TRUE;
}

HRESULT ConditionList::onAdd(BOOL& modified)
{
   HRESULT hr = S_OK;
   CCondition *pCondition;

    // create the dialog box to select a condition attribute
   CSelCondAttrDlg * pSelCondAttrDlg = new CSelCondAttrDlg(m_pIASAttrList, m_filter);
   if (NULL == pSelCondAttrDlg)
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't create the CSelCondAttrDlg, err = %x", hr);
      ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_CREATE_OBJECT, NULL, hr);
      return hr;
   }

   // Put up the dialog.
   int iResult = pSelCondAttrDlg -> DoModal();

   // The pSelCondAttrDlg->DoModal call returns TRUE if the user selected something.
   if( iResult && pSelCondAttrDlg->m_nSelectedCondAttr != -1)
   {
      //
      // The user selected something and chose OK -- create the condition object
      //
      IIASAttributeInfo* pSelectedAttr = m_pIASAttrList->GetAt(pSelCondAttrDlg->m_nSelectedCondAttr);

      ATTRIBUTEID id;
      pSelectedAttr->get_AttributeID( &id );
      switch( id )
      {

      case IAS_ATTRIBUTE_NP_TIME_OF_DAY:
         // time of day condition

         pCondition = (CCondition*) new CTodCondition(pSelectedAttr);
         break;

      case IAS_ATTRIBUTE_NTGROUPS   :
         // nt group condition

         pCondition = (CCondition*) new CNTGroupsCondition(
                                          pSelectedAttr,
                                          m_hWnd,
                                          m_pPolicyNode->m_pszServerAddress
                                       );
         break;

      default:
            //
            // is this attribute an enumerator?
            //
         ATTRIBUTESYNTAX as;
         pSelectedAttr->get_AttributeSyntax( &as );
         if ( as == IAS_SYNTAX_ENUMERATOR )
         {

            // enum-type condition
            CEnumCondition *pEnumCondition = new CEnumCondition(pSelectedAttr);

            pCondition = pEnumCondition;
         }
         else
         {
            // match condition
            pCondition = (CCondition*) new CMatchCondition(pSelectedAttr);

         }
         break;

      } // switch

      if ( pCondition==NULL)
      {
         hr = E_OUTOFMEMORY;
         ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_CREATE_COND, NULL, hr);
         goto failure;
      }

        //
        // now edit the condition
        //
      hr = pCondition->Edit();
      if ( FAILED(hr) )
      {
         ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "pCondition->Edit() returns %x", hr);
         return hr;
      }


      // if the condition text is empty, then do nothing
      if ( pCondition->m_strConditionText.GetLength() == 0)
      {
         delete pSelCondAttrDlg;
         delete pCondition;
         return S_OK;
      }


        //
        // now, update the UI: add the new condition to the listbox
        //

      if (m_ConditionList.GetSize())
      {
         // before we do that, add an "AND" to the current last condition
         ATL::CString strDispCondText;

         SendDlgItemMessage(   IDC_LIST_POLICYPAGE1_CONDITIONS,
                        LB_DELETESTRING,
                        m_ConditionList.GetSize()-1,
                         0L);
         strDispCondText = m_ConditionList[m_ConditionList.GetSize()-1]->GetDisplayText() + _T(" AND");

         SendDlgItemMessage(   IDC_LIST_POLICYPAGE1_CONDITIONS,
                        LB_ADDSTRING,
                        0,
                         (LPARAM)(LPCTSTR)strDispCondText);
      }

      SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
                     LB_ADDSTRING,
                     0,
                     (LPARAM)(LPCTSTR)pCondition->GetDisplayText());

      SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
                     LB_SETCURSEL,
                     SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS, LB_GETCOUNT, 0,0L)-1,
                     (LPARAM)(LPCTSTR)pCondition->GetDisplayText());
      ::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_REMOVE), TRUE);
      ::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_EDIT), TRUE);

      //
      // add this condition to the condition list
      //
      m_ConditionList.Add((CCondition*)pCondition);

      // set the dirty bit
      SetModified(TRUE);
   } // if  // iResult

   delete pSelCondAttrDlg;

   AdjustHoritontalScroll();

   return TRUE;   // ISSUE: what do we need to be returning here?



failure:
   if (pSelCondAttrDlg)
   {
      delete pSelCondAttrDlg;
   }

   if (pCondition)
   {
      delete pCondition;
   }
   return hr;
}

HRESULT ConditionList::onEdit(BOOL& modified, BOOL& bHandled)
{
   LRESULT lRes, lCurSel;

   //
   // Has the user selected someone from the condition list?
   //
   lCurSel = SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
                         LB_GETCURSEL,
                         0,
                         0L);
   if (lCurSel == LB_ERR)
   {
      // no selection -- do nothing
      bHandled = TRUE;
      return S_OK;
   }

   //
   // Edit the condition
   //
   CCondition *pCondition = m_ConditionList[lCurSel];
   HRESULT hr = pCondition->Edit();

    //
    // change the displayed condition text
    //

   // is this the last condition?
   ATL::CString strDispCondText = m_ConditionList[lCurSel]->GetDisplayText();

   if ( lCurSel != m_ConditionList.GetSize()-1 )
   {
      // put an extra 'AND' at the end
      strDispCondText += _T(" AND");
   }

   // replace it with new
   lRes = SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
                       LB_INSERTSTRING,
                       lCurSel,
                       (LPARAM)(LPCTSTR)strDispCondText);

   // select the new one
   lRes = SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
                       LB_SETCURSEL,
                       lCurSel,
                       (LPARAM)0);
   // delete the old text
   lRes = SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
                       LB_DELETESTRING,
                       lCurSel+1,
                       0L);

   // set the dirty bit
   SetModified(TRUE);

   bHandled = TRUE;

   AdjustHoritontalScroll();

   return hr;
}

HRESULT ConditionList::onRemove(BOOL& modified, BOOL& bHandled)
{
   LRESULT lCurSel;
   HRESULT hr;

   //
   // Has the user selected someone from the condition list?
   //
   lCurSel = SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
                         LB_GETCURSEL,
                         0,
                         0L);
   if (lCurSel == LB_ERR)
   {
      //
      // no selection -- do nothing
      //
      bHandled = TRUE;
      return S_OK;
   }


   // check whether this is the last one in the list.
   // if it is, we also need to delete the " AND" operator from
   // the next-to-last item
   if ( lCurSel!=0 && lCurSel == m_ConditionList.GetSize()-1 )
   {
      // delete the old one with an " AND"
      hr = SendDlgItemMessage( IDC_LIST_POLICYPAGE1_CONDITIONS,
                         LB_DELETESTRING,
                         lCurSel-1,
                          0L
                        );

      // insert the one without 'AND"
      hr = SendDlgItemMessage( IDC_LIST_POLICYPAGE1_CONDITIONS,
                         LB_INSERTSTRING,
                         lCurSel-1,
                          (LPARAM)(LPCTSTR)m_ConditionList[lCurSel-1]->GetDisplayText());
   }

   // delete the condition
   CCondition *pCondition = m_ConditionList[lCurSel];

   m_ConditionList.Remove(pCondition);
   delete pCondition;

   // delete the old text
   hr = SendDlgItemMessage(  IDC_LIST_POLICYPAGE1_CONDITIONS,
                       LB_DELETESTRING,
                       lCurSel,
                       0L);

   bHandled = TRUE;

   // set the dirty bit
   SetModified(TRUE);

   if ( m_ConditionList.GetSize() == 0)
   {
      // no condition, then disable "Remove" and "Edit"
      ::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_REMOVE), FALSE);
      ::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_EDIT), FALSE);
   }
   else
   {
      // re-select another condition
      if ( lCurSel > 0 )
      {
         lCurSel--;
      }

      SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS, LB_SETCURSEL, lCurSel, 0L);
   }

   //
   // adjust the scroll bar
   //
   AdjustHoritontalScroll();

   return hr;
}

void ConditionList::AdjustHoritontalScroll()
{
   //
   // According to the maximum length of all list box items,
   // set the horizontal scrolling range
   //
   HDC hDC = ::GetDC(GetDlgItem(IDC_LIST_POLICYPAGE1_CONDITIONS));
   int iItemCount = m_ConditionList.GetSize();
   int iMaxLength = 0;

    for (int iIndex=0; iIndex<iItemCount; iIndex++)
   {
      ATL::CString strCondText;
      strCondText = m_ConditionList[iIndex]->GetDisplayText();

      SIZE  szText;

      if ( GetTextExtentPoint32(hDC, (LPCTSTR)strCondText, strCondText.GetLength(), &szText) )
      {
         DebugTrace(DEBUG_NAPMMC_POLICYPAGE1,
                  "Condition: %ws, Length %d, PixelSize %d",
                  (LPCTSTR)strCondText,
                  strCondText.GetLength(),
                  szText.cx
               );
         if (iMaxLength < szText.cx )
         {
            iMaxLength = szText.cx;
         }
      }
      DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Maximum item length is %d", iMaxLength);
   }

   SendDlgItemMessage( IDC_LIST_POLICYPAGE1_CONDITIONS,
                  LB_SETHORIZONTALEXTENT,
                  iMaxLength,
                  0L);
}

BOOL ConditionList::CreateConditions()
{
   HRESULT               hr = S_OK;
   BOOL               fRet;
   CComPtr<IUnknown>      spUnknown;
   CComPtr<IEnumVARIANT>   spEnumVariant;
   long               ulCount;
   ULONG               ulCountReceived;

    //
    // initialize the condition attribute list
    //
   hr = m_pIASAttrList->Init(m_spDictionarySdo);
   if ( FAILED(hr) )
   {
      // Inside Init() there're already error reporting
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "m_pIASAttrList->Init() failed, err = %x", hr);
      return FALSE;
   }

   if (m_ConditionList.GetSize() == 0)
   {
      // how many conditions do we have for this policy right now?
      m_spConditionCollectionSdo->get_Count( & ulCount );
      DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Number of conditions %d", ulCount);

      CComVariant varCond;
      CCondition *pCondition;

      if( ulCount > 0 )
      {
         //
         // Get the enumerator for the Clients collection.
         //
         hr = m_spConditionCollectionSdo->get__NewEnum( (IUnknown **) & spUnknown );
         if ( FAILED(hr) )
         {
            ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "get__NewEnum() failed, err = %x", hr);
            ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_ENUMCOND, NULL, hr);
            return FALSE;
         }


         hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
         if ( FAILED(hr) )
         {
            ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "QueryInterface(IEnumVARIANT) failed, err = %x", hr);
            ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_QUERYINTERFACE, NULL, hr);
            return FALSE;
         }


         _ASSERTE( spEnumVariant != NULL );
         spUnknown.Release();

         // Get the first item.
         hr = spEnumVariant->Next( 1, &varCond, &ulCountReceived );

         while( SUCCEEDED( hr ) && ulCountReceived == 1 )
         {
            // Get an sdo pointer from the variant we received.
            _ASSERTE( V_VT(&varCond) == VT_DISPATCH );
            _ASSERTE( V_DISPATCH(&varCond) != NULL );

            CComPtr<ISdo> spConditionSdo;
            hr = varCond.pdispVal->QueryInterface( IID_ISdo, (void **) &spConditionSdo );
            _ASSERTE( SUCCEEDED( hr ) );

            //
            // get condition text
            //
            CComVariant         varCondProp;
            ATL::CString      strCondText, strExternCondText, strCondAttr;
            ATTRIBUTEID AttrId;
            CONDITIONTYPE CondType;

            // get condition text -- with AttributeMatch, TimeOfDay, NTMembership
            // prefix strings
            hr = spConditionSdo->GetProperty(PROPERTY_CONDITION_TEXT,
                                     &varCondProp);

            if ( FAILED(hr) )
            {
               ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't get condition text, err = %x", hr);
               ShowErrorDialog(m_hWnd,
                           IDS_ERROR_SDO_ERROR_GET_CONDTEXT,
                           NULL,
                           hr
                           );
               return FALSE;
            }

            _ASSERTE( V_VT(&varCondProp) == VT_BSTR);
            strExternCondText = V_BSTR(&varCondProp);
            DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "ConditionText: %ws",strExternCondText);

            // we are done with this condition sdo
            spConditionSdo.Release();

            varCondProp.Clear();

            // now we need to strip off the unnecessary prefix string in
            // the condition text
            hr = StripCondTextPrefix(
                     strExternCondText,
                     strCondText,
                     strCondAttr,
                     &CondType
                  );

            if (  FAILED(hr) )
            {
               ErrorTrace(ERROR_NAPMMC_POLICYPAGE1,"StripCondTextPrefix() failed, err = %x", hr);
               ShowErrorDialog(m_hWnd,
                           IDS_ERROR_INVALID_COND_SYNTAX,
                           m_pPolicyNode->m_bstrDisplayName
                        );

               // go to the next condition
               varCond.Clear();
               hr = spEnumVariant->Next( 1, &varCond, &ulCountReceived );
               continue;
            }
            DebugTrace(DEBUG_NAPMMC_POLICYPAGE1,
                     "ConditionText: %ws, CondAttr: %ws, CondType: %d",
                     strCondText,
                     strCondAttr,
                     (int)CondType
                    );

            switch(CondType)
            {
            case IAS_TIMEOFDAY_CONDITION:  AttrId = IAS_ATTRIBUTE_NP_TIME_OF_DAY; break;
            case IAS_NTGROUPS_CONDITION:   AttrId = IAS_ATTRIBUTE_NTGROUPS;  break;
            case IAS_MATCH_CONDITION: {
                     BSTR bstrName = SysAllocString(strCondAttr);
                     if ( bstrName == NULL )
                     {
                        ShowErrorDialog(m_hWnd,
                                    IDS_ERROR_CANT_CREATE_CONDATTR,
                                    (LPTSTR)(LPCTSTR)strCondAttr,
                                    hr
                                 );
                        return FALSE;
                     }

                     hr = m_spDictionarySdo->GetAttributeID(bstrName, &AttrId);
                     if ( FAILED(hr) )
                     {
                         ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetAttributeID() failed, err = %x", hr);
                        ShowErrorDialog(m_hWnd,
                                    IDS_ERROR_SDO_ERROR_GETATTROD,
                                    bstrName,
                                    hr
                                 );
                        SysFreeString(bstrName);
                        return FALSE;
                     }
                     SysFreeString(bstrName);
                  }
                  break;
            }

            // GetAt can throw exceptions.
            try
            {

               //
               // find the condition attribute ID in the attribute list
               //
               int nAttrIndex = m_pIASAttrList->Find(AttrId);

               if (nAttrIndex == -1)
               {
                  //
                  // the attribute is not even found in the attribute list
                  //
                  ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, " Can't find this condattr in the list");
                  ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_FIND_ATTR);
                  return FALSE;
               }

               switch( AttrId )
               {
                  case IAS_ATTRIBUTE_NP_TIME_OF_DAY:
                        // time of day condition
                        pCondition = (CCondition*) new CTodCondition(m_pIASAttrList->GetAt(nAttrIndex),
                                                          strCondText
                                                          );
                        break;

                  case IAS_ATTRIBUTE_NTGROUPS:
                        // nt group condition
                        pCondition = (CCondition*) new CNTGroupsCondition(m_pIASAttrList->GetAt(nAttrIndex),
                                                              strCondText,
                                                              m_hWnd,
                                                              m_pPolicyNode->m_pszServerAddress
                                                            );

                  break;

                  default:
                  {
                     CComPtr<IIASAttributeInfo> spAttributeInfo = m_pIASAttrList->GetAt(nAttrIndex);
                     _ASSERTE(spAttributeInfo);

                     ATTRIBUTESYNTAX as;
                     hr = spAttributeInfo->get_AttributeSyntax( &as );
                     _ASSERTE( SUCCEEDED(hr) );

                     if( as == IAS_SYNTAX_ENUMERATOR )
                     {
                        // enum-type condition
                        CEnumCondition *pEnumCondition = new CEnumCondition(m_pIASAttrList->GetAt(nAttrIndex),
                                                               strCondText
                                                               );
                        pCondition = pEnumCondition;

                     }
                     else
                     {
                        // match condition
                        pCondition = (CCondition*) new CMatchCondition(m_pIASAttrList->GetAt(nAttrIndex),
                                                            strCondText
                                                           );
                     }
                  }
                  break;

               } // switch


               // Add the newly created node to the list of Policys.
               m_ConditionList.Add(pCondition);


               // get the next condition
               varCond.Clear();
               hr = spEnumVariant->Next( 1, &varCond, &ulCountReceived );

            }
            catch(...)
            {
               ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Exception thrown while populating condition list");
               continue;
            }

         } // while
      } // if
   }

   return TRUE;
}

HRESULT ConditionList::PopulateConditions()
{
   SendDlgItemMessage(   IDC_LIST_POLICYPAGE1_CONDITIONS,
                   LB_RESETCONTENT,
                  0,
                  0L
               );
   ATL::CString strDispCondText;

   for (int iIndex=0; iIndex<m_ConditionList.GetSize(); iIndex++)
   {
      strDispCondText = m_ConditionList[iIndex]->GetDisplayText();

      if ( iIndex != m_ConditionList.GetSize()-1 )
      {
         // it's not the last condition, then we put an 'AND' at the
         // end of the condition text
         strDispCondText += " AND";
      }

      // display it
      SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
                     LB_ADDSTRING,
                     0,
                     (LPARAM)(LPCTSTR)strDispCondText);

   }

   if ( m_ConditionList.GetSize() == 0)
   {
      // no condition, then disable "Remove" and "Edit"
      ::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_REMOVE), FALSE);
      ::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_EDIT), FALSE);
   }
   else
   {
      SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS, LB_SETCURSEL, 0, 0L);
      ::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_EDIT), TRUE);
      ::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_REMOVE), TRUE);
   }

   AdjustHoritontalScroll();

   return S_OK;
}

HRESULT StripCondTextPrefix(
                  ATL::CString& strExternCondText,
                  ATL::CString& strCondText,
                  ATL::CString& strCondAttr,
                  CONDITIONTYPE* pCondType
                  )
{
   HRESULT hr = S_OK;

   // is it an empty string
   if ( strExternCondText.GetLength() == 0 )
   {
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1,"Can't parse prefix: empty condition text");
      return E_INVALIDARG;
   }

   // a temporary copy
   ATL::CString strTempStr = (LPCTSTR)strExternCondText;
   WCHAR   *pwzCondText = (WCHAR*)(LPCTSTR)strTempStr;

   strCondAttr = _T("");
   strCondText = _T("");

   // condition text will look like : AttributeMatch("attr=<reg>")
   // strip off the "AttributeMatch(" prefix
   WCHAR   *pwzBeginCond = wcschr(pwzCondText, _T('('));
   WCHAR   *pwzEndCond = wcsrchr(pwzCondText, _T(')'));

   if ( ( pwzBeginCond == NULL ) || ( pwzEndCond == NULL ) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1,"Can't parse prefix: no ( or ) found");
      return E_INVALIDARG;
   }

   //
   // now we should decide what kind of condition this is:
   //
   *pwzBeginCond = _T('\0');
   DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "ConditionType: %ws", pwzCondText);

   if ( _wcsicmp(pwzCondText, TOD_PREFIX) == 0 )
   {
      *pCondType = IAS_TIMEOFDAY_CONDITION;
   }
   else if ( _wcsicmp(pwzCondText, NTG_PREFIX) == 0 )
   {
      *pCondType = IAS_NTGROUPS_CONDITION;
   }
   else if ( _wcsicmp(pwzCondText, MATCH_PREFIX ) == 0  )
   {
      *pCondType = IAS_MATCH_CONDITION;
   }
   else
   {
      return E_INVALIDARG;
   }

   // skip the '(' sign
   pwzBeginCond += 2 ;

   // skip the ')' sign
   *(pwzEndCond-1) = _T('\0');

   // So right now the string between pwzBeginCond and pwzEndCond is the
   // real condition text
   strCondText = pwzBeginCond;

   if ( IAS_MATCH_CONDITION == *pCondType )
   {
      // for match-type condition, we need to get the condition attribute name
      WCHAR *pwzEqualSign = wcschr(pwzBeginCond, _T('='));

      if ( pwzEqualSign == NULL )
      {
         ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't parse : there's no = found");
         return E_INVALIDARG;
      }

      *pwzEqualSign = _T('\0');

      strCondAttr = pwzBeginCond;
   }
   else
   {
      strCondAttr = _T("");
   }

   DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Condition Attr: %ws", strCondAttr);
   return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

WriteConditionListToSDO

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT WriteConditionListToSDO( 		CSimpleArray<CCondition*> & ConditionList
									,	ISdoCollection * pConditionCollectionSdo
									,	HWND hWnd
									)
{
	TRACE_FUNCTION("WriteConditionListToSDO()");

	HRESULT hr = S_OK;
	CComVariant		var;


	// remove all the condition SDOs from the policy's sdo collection,
	// re-add everything if any condition has been changed
	DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Regenerate all the conditions");
	hr = pConditionCollectionSdo->RemoveAll();
	if( FAILED( hr ) )
	{
		// We could not create the object.
		ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Couldn't clear conditions for this policy, err = %x", hr);
		ShowErrorDialog(hWnd,IDS_ERROR_SDO_ERROR_ADDCOND,NULL,hr);
		return hr;
	}

	// Hack for semi-randomly generated Condition names.
	static dwConditionName = 0;

	// add all conditions in the condition collection sdo
	for (int iIndex=0; iIndex< ConditionList.GetSize(); iIndex++)
	{
		// Add a condition object in the policy's condition collection
		CComPtr<IDispatch> spDispatch;

		// we have to set the pointer to NULL in order for the collection Sdo
		// to create a brand new one for us
		spDispatch.p = NULL;


		// We need random temp names for conditions we add.

		CComBSTR	bstrName;

		TCHAR	tzTempName[MAX_PATH+1];
		do
		{
			// Create a temporary name. We used a random number
			// so the chance of getting identical names is very small.
			wsprintf(tzTempName, _T("Condition%lu"), dwConditionName++ );

			ATLTRACE(L"tzTempName: %ls\n", tzTempName );

			bstrName.Empty();
			bstrName =  tzTempName; // temporary policy name

			ATLTRACE(L"conditionSdoCollection->Add(%ls)\n", bstrName );

			hr =  pConditionCollectionSdo->Add(bstrName, (IDispatch **) &spDispatch.p);

			//
			// we keep looping around until the policy can be successfully added.
			// We will get E_INVALIDARG when the name already exists
			//
		} while ( hr == E_INVALIDARG );


		if( FAILED( hr ) )
		{
			// We could not create the object.
			ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Couldn't add condition for this policy, err = %x", hr);
			ShowErrorDialog(hWnd,IDS_ERROR_SDO_ERROR_ADDCOND,NULL,hr);
			return hr;
		}
		DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "conditionCollection->Add() succeeded");


		CComPtr<ISdo> spConditionSdo;

		// Query the returned IDispatch interface for an ISdo interface.
		_ASSERTE( spDispatch.p != NULL );
		hr = spDispatch.p->QueryInterface( IID_ISdo, (void **) &spConditionSdo );

		if( spConditionSdo == NULL )
		{
			ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "QueryInterface for this a condition failed, err = %x", hr);
			ShowErrorDialog( hWnd
							 , IDS_ERROR_SDO_ERROR_QUERYINTERFACE
							 , NULL
							 , hr
							);
			return hr;
		}

		// set condition text
		var.Clear();
		WCHAR *pwzCondText = ConditionList[iIndex]->GetConditionText();

		DebugTrace(DEBUG_NAPMMC_POLICYPAGE1,"ConditionText: %ws", pwzCondText);

		V_VT(&var)=VT_BSTR;
		V_BSTR(&var) = SysAllocString(pwzCondText);
		delete[] pwzCondText;

		hr = spConditionSdo->PutProperty(PROPERTY_CONDITION_TEXT, &var);
		if( FAILED (hr) )
		{
			ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Couldn't save this condition, err = %x", hr);
			ShowErrorDialog( hWnd
							 , IDS_ERROR_SDO_ERROR_PUTPROP_CONDTEXT
							 , NULL
							 , hr
							);
			return hr;
		}
		var.Clear();

	} // for

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\condition.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       condition.cpp
//
//--------------------------------------------------------------------------

// Condition.cpp: implementation of the CCondition class.
//
//////////////////////////////////////////////////////////////////////

#include "precompiled.h"
#include "Condition.h"
#include "iasdebug.h"
//
// constructor
//
CCondition::CCondition(IIASAttributeInfo* pAttributeInfo, ATL::CString &strConditionText )
				: m_strConditionText(strConditionText)
{
	m_spAttributeInfo = pAttributeInfo;
}

CCondition::CCondition(IIASAttributeInfo* pAttributeInfo)
				: m_strConditionText(L"")
{
	m_spAttributeInfo = pAttributeInfo;
}

//+---------------------------------------------------------------------------
//
// Function:  CCondition::GetDisplayText
//
// Synopsis:  Get the displayable text for this condition
//			  This is the default implementation, which simply returns the
//			  condition text. The subclass should override this function
//
// Arguments: None
//
// Returns:   ATL::CString& - displayable text
//
// History:   Created Header    byao	2/22/98 11:38:41 PM
//
//+---------------------------------------------------------------------------
ATL::CString CCondition::GetDisplayText()
{
	TRACE_FUNCTION("CCondition::GetDisplayText");

	// default implementation: as as condition text
	DebugTrace(DEBUG_NAPMMC_CONDITION, "GetDisplayText() returning %ws", m_strConditionText);
	return m_strConditionText;
}

//+---------------------------------------------------------------------------
//
// Function:  CCondition::GetConditionText
//
// Synopsis:  Get the condition text for this condition
//			  This is the default implementation, which simply returns the
//			  AttributeMatch-typed condition text. The subclass should override 
//			  this function
//
// Arguments: None
//
// Returns:   WCHAR*  - displayable text
//
// History:   Created Header    byao	2/22/98 11:38:41 PM
//
//+---------------------------------------------------------------------------
WCHAR* CCondition::GetConditionText()
{	
	TRACE_FUNCTION("CCondition::GetConditionText");

	WCHAR *pwzCondText;
	
	pwzCondText = new WCHAR[m_strConditionText.GetLength()+128];

	if (pwzCondText == NULL)
	{
		ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_GET_CONDTEXT, NULL);
		return NULL;
	}

	//
	// can't use wsprintf() here, because wsprintf() requires a buffer smaller than
	// 1024 chars
	//
	// wsprintf(pwzCondText, _T("%ws(\"%ws\")"), MATCH_PREFIX, (LPCTSTR)m_strConditionText);
	//
	wcscpy(pwzCondText, MATCH_PREFIX);
	wcscat(pwzCondText, _T("(\"") );
	wcscat(pwzCondText, (LPCTSTR)m_strConditionText);
	wcscat(pwzCondText, _T("\")"));

	DebugTrace(DEBUG_NAPMMC_CONDITION, "GetConditionText() returning %ws", pwzCondText);
	return pwzCondText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\componentdata.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ComponentData.cpp

Abstract:

   The CComponentData class implements several interfaces which MMC uses:
   
   The IComponentData interface is basically how MMC talks to the snap-in
   to get it to implement the left-hand-side "scope" pane.

   The IExtendPropertySheet interface is how the snap-in adds property sheets
   for any of the items a user might click on.

   The IExtendContextMenu interface what we do to add custom entries
   to the menu which appears when a user right-clicks on a node.
   
   The IExtendControlBar interface allows us to support a custom
   iconic toolbar.

   See ComponentData.cpp for implementation.

Note:

   Much of the functionality of this class is implemented in atlsnap.h
   by IComponentDataImpl.  We are mostly overriding here.

Revision History:
   mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_COMPONENT_DATA_H_)
#define _NAP_COMPONENT_DATA_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//Moved to Precompiled.h: #include <atlsnap.h>
//
//
// where we can find what this class has or uses:
//
#include "MachineNode.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

   //
   // hack start
   //

   // This is a big hack to work around a atlsnap.h bug: Atlsnap.h
   // can't support extending multiple nodes. So we basically just
   // copied EXTENSION_SNAPIN_NODEINFO_ENTRY() here. We need to change
   // this after the atlsnap.h fix -- MAM: 08-06-98 -- yeah right
   //

   //
   // The following statements are copied from atlsnap.h and then changed
   // to support multiple extending node
   //
   // IsSupportedGUID will also set the m_enumExtendedSnapin flag in side m_##dataClass object
   // which, in our case, is CMachineNode
   //

#define EXTENSION_SNAPIN_NODEINFO_ENTRY_EX(dataClass) \
   if ( m_##dataClass.IsSupportedGUID( guid ) )\
   { \
      *ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
      _ASSERTE(*ppItem != NULL); \
      (*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
      return hr; \
   }

   //
   // hack end
   //

class CComponent;

class CComponentData :
     public CComObjectRootEx<CComSingleThreadModel>
   , public CSnapInObjectRoot<1, CComponentData>
   , public IComponentDataImpl<CComponentData, CComponent>
   , public IExtendPropertySheetImpl<CComponentData>
   , public IExtendContextMenuImpl<CComponentData>
   , public IExtendControlbarImpl<CComponentData>
   , public ISnapinHelp
   , public CComCoClass<CComponentData, &CLSID_NAPSnapin>
{

public:

   CComponentData();

   ~CComponentData();

   EXTENSION_SNAPIN_DATACLASS(CMachineNode)

   BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CComponentData)
   EXTENSION_SNAPIN_NODEINFO_ENTRY_EX(CMachineNode)
   END_EXTENSION_SNAPIN_NODEINFO_MAP()

   BEGIN_COM_MAP(CComponentData)
      COM_INTERFACE_ENTRY(IComponentData)
      COM_INTERFACE_ENTRY(IExtendPropertySheet2)
      COM_INTERFACE_ENTRY(IExtendContextMenu)
      COM_INTERFACE_ENTRY(IExtendControlbar)
      COM_INTERFACE_ENTRY(ISnapinHelp)
   END_COM_MAP()

   DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)

   DECLARE_NOT_AGGREGATABLE(CComponentData)

   STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

   STDMETHOD(CompareObjects)(
        LPDATAOBJECT lpDataObjectA
      , LPDATAOBJECT lpDataObjectB
      );

   STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent);

   // ISnapinHelp method(s)
   STDMETHOD(GetHelpTopic)(LPOLESTR * lpCompiledHelpFile)
   {return E_UNEXPECTED;};

   // We are overiding ATLsnap.h's IComponentImpl implementation of this
   // in order to correctly handle messages which it is incorrectly
   // ignoring (e.g. MMCN_COLUMN_CLICK and MMCN_SNAPINHELP)
   STDMETHOD(Notify)(
          LPDATAOBJECT lpDataObject
        , MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
      );

   virtual HRESULT OnPropertyChange(   
        LPARAM arg
      , LPARAM param
      );

   // IExtendPropertySheet2 -- to support wizard 97
   STDMETHOD(GetWatermarks)( 
             LPDATAOBJECT lpIDataObject,
             HBITMAP *lphWatermark,
             HBITMAP *lphHeader,
             HPALETTE *lphPalette,
             BOOL *bStretch
             );
};

#endif // _NAP_COMPONENT_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\condlist.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    condlist.h
//
// SYNOPSIS
//
//    Declares the class ConditionList.
//
// MODIFICATION HISTORY
//
//    03/01/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef CONDLIST_H
#define CONDLIST_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <atlapp.h>
#include <atltmp.h>
class CCondition;
class CIASAttrList;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    CreateCIASAttrList, DestroyCIASAttrList, and ExtractAttrList
//
// DESCRIPTION
//
//    Functions for creating and destroying the CIASAttrList object used by the
//    ConditionList class below. This is useful if you want to avoid
//    dependencies.
//
///////////////////////////////////////////////////////////////////////////////
CIASAttrList*
WINAPI
CreateCIASAttrList() throw ();

VOID
WINAPI
DestroyCIASAttrList(CIASAttrList* attrList) throw ();

PVOID
WINAPI
ExtractCIASAttrList(CIASAttrList* attrList) throw ();

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ConditionList
//
// DESCRIPTION
//
//    Manages a ListBox control containing a list of policy conditions.
//
///////////////////////////////////////////////////////////////////////////////
class ConditionList
{
public:
   ConditionList() throw ()
      : m_pPolicyNode(&node)
   { }
   ~ConditionList() throw ();

   // This must be called before onInitDialog.
   void finalConstruct(
            HWND dialog,
            CIASAttrList* attrList,
            LONG attrFilter,
            ISdoDictionaryOld* dnary,
            ISdoCollection* conditions,
            PCWSTR machineName,
            PCWSTR policyName
            ) throw ();

   void clear() throw ();
   ::CString getDisplayText();

   BOOL onInitDialog() throw ();
   BOOL onApply() throw ();

   HRESULT onAdd(BOOL& modified) throw ();
   HRESULT onEdit(BOOL& modified, BOOL& bHandled) throw ();
   HRESULT onRemove(BOOL& modified, BOOL& bHandled) throw ();

protected:
	void AdjustHoritontalScroll();
   BOOL CreateConditions();
   HRESULT PopulateConditions();

   // These let use masquerade as a CWnd.
   HWND GetDlgItem(int nID)
   { return ::GetDlgItem(m_hWnd, nID); }
   LRESULT SendDlgItemMessage(
               int nID,
               UINT message,
               WPARAM wParam = 0,
               LPARAM lParam = 0
               )
   { return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam); }

private:
   // Mimics the CPolicyNode class.
   struct PolicyNode
   {
      PWSTR m_bstrDisplayName;
      PWSTR m_pszServerAddress;
   } node;

   HWND m_hWnd;
   PolicyNode* m_pPolicyNode;
   CIASAttrList* m_pIASAttrList;
   LONG m_filter;
   CComPtr<ISdoDictionaryOld> m_spDictionarySdo;
   CComPtr<ISdoCollection> m_spConditionCollectionSdo;
   CSimpleArray<CCondition*> m_ConditionList;

   // Not implemented.
   ConditionList(ConditionList&);
   ConditionList& operator=(ConditionList&);
};

#endif // CONDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\connectiontoserver.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ConnectionToServer.cpp

Abstract:

	Implementation file for utility functions for connecting to a server.


Revision History:
	mmaguire 11/10/97	- created
	byao	 4/24/98	- modified for Remote Access Policy UI
	
--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "ConnectionToServer.h"
//
//
// where we can find declarations needed in this file:
//
#include "MachineNode.h"
#include "Component.h"
#include "ComponentData.h"
#include "ChangeNotification.h"

#include "LogMacNd.h"
#include "LogComp.h"
#include "LogCompD.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



// Initialize the Help ID pairs
//const DWORD CConnectionToServer::m_dwHelpMap[] =
//{
//	0, 0
//};


// reload Sdo for refresh
// happening in the main thread
HRESULT CConnectionToServer::ReloadSdo(ISdo** ppSdoService, ISdoDictionaryOld **ppSdoDictionaryOld)
{
	HRESULT hr = S_OK;

	// this is reload
	ASSERT(m_spSdoMachine);
	ASSERT(m_spSdoDictionaryOld);
	ASSERT(m_spSdo);

	CComPtr<IUnknown>	spUnk;

	// service Sdo
	if(ppSdoService)
	{
		CComBSTR bstrServiceName;
		
		if( m_fExtendingIAS )
		{
			bstrServiceName = L"IAS";
		}
		else
		{
			bstrServiceName = L"RemoteAccess";
		}

		// Get the service Sdo.
		hr = m_spSdoMachine->GetServiceSDO (	  DATA_STORE_LOCAL
											, bstrServiceName
											, (IUnknown **)&spUnk
											);
											
		if ( FAILED(hr) )
			return hr;

		m_spSdo.Release();
	
		hr = spUnk->QueryInterface( IID_ISdo, (void **) &m_spSdo );
		*ppSdoService = m_spSdo;
		(*ppSdoService)->AddRef();
	}

	if ( FAILED(hr) )
		return hr;

	// Dictionary Sdo
	if (ppSdoDictionaryOld)
	{
		spUnk.Release();
		m_spSdoDictionaryOld.Release();
	
		// Get the dictionary Sdo.
		hr = m_spSdoMachine->GetDictionarySDO ( (IUnknown **)&spUnk );

		if ( FAILED(hr) )
			return hr;


		hr = spUnk->QueryInterface( IID_ISdoDictionaryOld, (void **) &m_spSdoDictionaryOld );

		if ( FAILED(hr) )
			return hr;

		*ppSdoDictionaryOld = m_spSdoDictionaryOld;
		(*ppSdoDictionaryOld)->AddRef();
	}
	
	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::CConnectionToServer

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CConnectionToServer::CConnectionToServer
							(
								CMachineNode*	pMachineNode,	
								BSTR			bstrServerAddress, // server we are connecting to
								BOOL			fExtendingIAS	   // are we extending IAS or Network Console
							)
{
	TRACE_FUNCTION("CConnectionToServer::CConnectionToServer");

	// Check for preconditions:
    // may be null when doing the logging node
	//_ASSERTE( pMachineNode != NULL );

	m_pMachineNode		= pMachineNode;
	m_bstrServerAddress = bstrServerAddress;
	m_fExtendingIAS		= fExtendingIAS;

	m_pStreamSdoServiceMarshal = NULL;
	m_pStreamSdoDictionaryOldMarshal = NULL;
	m_fDSAvailable		= FALSE;

	if ( !m_bstrServerAddress.Length() )
	{
		DWORD dwBufferSize = IAS_MAX_COMPUTERNAME_LENGTH;

		if ( !GetComputerName(m_szLocalComputerName, &dwBufferSize) )
		{
			m_szLocalComputerName[0]=_T('\0');
		}
	}
}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::~CConnectionToServer

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CConnectionToServer::~CConnectionToServer()
{
	TRACE_FUNCTION("CConnectionToServer::~CConnectionToServer");

	// Check for preconditions:
	HRESULT hr;


	// Release this stream pointer if this hasn't already been done.
	if( m_pStreamSdoServiceMarshal != NULL )
	{
		m_pStreamSdoServiceMarshal->Release();
	};

	if( m_pStreamSdoDictionaryOldMarshal != NULL )
	{
		m_pStreamSdoDictionaryOldMarshal->Release();
	};

}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CConnectionToServer::OnInitDialog(
	  UINT uMsg
	, WPARAM wParam
	, LPARAM lParam
	, BOOL& bHandled
	)
{
	TRACE_FUNCTION("CConnectionToServer::OnInitDialog");




	// Check for preconditions:
	_ASSERTE( m_pMachineNode != NULL );
	CComponentData *pComponentData  = m_pMachineNode->GetComponentData();
	_ASSERTE( pComponentData != NULL );
	_ASSERTE( pComponentData->m_spConsole != NULL );
	_ASSERTE( m_pMachineNode->m_pPoliciesNode != NULL );


	// Change the icon for the scope node from being normal to a busy icon.
	CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > spConsoleNameSpace( pComponentData->m_spConsole );
	LPSCOPEDATAITEM psdiPoliciesNode;
	m_pMachineNode->m_pPoliciesNode->GetScopeData( &psdiPoliciesNode );
	_ASSERTE( psdiPoliciesNode );
	SCOPEDATAITEM sdi;
	sdi.mask = SDI_IMAGE | SDI_OPENIMAGE;
	sdi.nImage = IDBI_NODE_POLICIES_BUSY_CLOSED;
	sdi.nOpenImage = IDBI_NODE_POLICIES_BUSY_OPEN;
	sdi.ID = psdiPoliciesNode->ID;		

	
	// Change the stored indices as well so that MMC will use them whenever it queries
	// the node for its images.
	LPRESULTDATAITEM prdiPoliciesNode;
	m_pMachineNode->m_pPoliciesNode->GetResultData( &prdiPoliciesNode );
	_ASSERTE( prdiPoliciesNode );
	prdiPoliciesNode->nImage = IDBI_NODE_POLICIES_BUSY_CLOSED;
	psdiPoliciesNode->nImage = IDBI_NODE_POLICIES_BUSY_CLOSED;
	psdiPoliciesNode->nOpenImage = IDBI_NODE_POLICIES_BUSY_OPEN;
	
	spConsoleNameSpace->SetItem( &sdi );






//	int		nLoadStringResult;
//	TCHAR	szConnectingStr[256];
//	TCHAR	szConnectingMsg[1024];
//
//	// Set the display name for this object
//	if ( LoadString( _Module.GetResourceInstance(),
//									IDS_CONNECTION_CONNECTING_TO_STR,
//									szConnectingStr,
//									256
//				   ) <= 0 )
//	{
//		_tcscpy( szConnectingMsg, _T("Connecting to ") );
//	}
//
//	if ( !m_bstrServerAddress.Length() )
//	{
//		wsprintf(szConnectingMsg, _T("%ws %ws"), szConnectingStr, m_szLocalComputerName);
//	}
//	else
//	{
//		wsprintf(szConnectingMsg, _T("%ws %ws"), szConnectingStr, m_bstrServerAddress);
//	}
//
//	SetDlgItemText(IDC_CONNECTION_STATUS__DIALOG__STATUS, szConnectingMsg);

	//
	// start the worker thread
	//
	StartWorkerThread();

	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::OnReceiveThreadMessage

Called when the worker thread wants to inform the main MMC thread of something.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CConnectionToServer::OnReceiveThreadMessage(
	  UINT uMsg
	, WPARAM wParam
	, LPARAM lParam
	, BOOL& bHandled
	)
{
	TRACE_FUNCTION("CConnectionToServer::OnReceiveThreadMessage");

	// Check for preconditions:
	_ASSERTE( m_pMachineNode != NULL );
	CComponentData *pComponentData  = m_pMachineNode->GetComponentData();
	_ASSERTE( pComponentData != NULL );
	_ASSERTE( pComponentData->m_spConsole != NULL );
	_ASSERTE( m_pMachineNode->m_pPoliciesNode != NULL );


	// The worker thread has notified us that it has finished.


	// Change the icon for the Policies node.
	CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > spConsoleNameSpace( pComponentData->m_spConsole );
	LPSCOPEDATAITEM psdiPoliciesNode = NULL;
	m_pMachineNode->m_pPoliciesNode->GetScopeData( &psdiPoliciesNode );
	_ASSERTE( psdiPoliciesNode );
	SCOPEDATAITEM sdi;
	sdi.mask = SDI_IMAGE | SDI_OPENIMAGE;
	if( wParam == CONNECT_NO_ERROR )
	{
		// Everything was OK -- change the icon to the OK icon.
		
		sdi.nImage = IDBI_NODE_POLICIES_OK_CLOSED;
		sdi.nOpenImage = IDBI_NODE_POLICIES_OK_OPEN;

		// Change the stored indices as well so that MMC will use them whenever it queries
		// the node for its images.
		LPRESULTDATAITEM prdiPoliciesNode;
		m_pMachineNode->m_pPoliciesNode->GetResultData( &prdiPoliciesNode );
		m_pMachineNode->m_pPoliciesNode->m_fSdoConnected = TRUE;
		_ASSERTE( prdiPoliciesNode );
		prdiPoliciesNode->nImage = IDBI_NODE_POLICIES_OK_CLOSED;
		psdiPoliciesNode->nImage = IDBI_NODE_POLICIES_OK_CLOSED;
		psdiPoliciesNode->nOpenImage = IDBI_NODE_POLICIES_OK_OPEN;
	}
	else
	{
		// There was an error -- change the icon to the error icon.

		sdi.nImage = IDBI_NODE_POLICIES_ERROR_CLOSED;
		sdi.nOpenImage = IDBI_NODE_POLICIES_ERROR_OPEN;

		// Change the stored indices as well so that MMC will use them whenever it queries
		// the node for its images.
		LPRESULTDATAITEM prdiPoliciesNode;
		m_pMachineNode->m_pPoliciesNode->GetResultData( &prdiPoliciesNode );
		m_pMachineNode->m_pPoliciesNode->m_fSdoConnected = FALSE;
		_ASSERTE( prdiPoliciesNode );
		prdiPoliciesNode->nImage = IDBI_NODE_POLICIES_ERROR_CLOSED;
		psdiPoliciesNode->nImage = IDBI_NODE_POLICIES_ERROR_CLOSED;
		psdiPoliciesNode->nOpenImage = IDBI_NODE_POLICIES_ERROR_OPEN;
	}
	sdi.ID = psdiPoliciesNode->ID;		
	spConsoleNameSpace->SetItem( &sdi );





	// We don't want to destroy the dialog, we just want to hide it.
	//ShowWindow( SW_HIDE );

	if( wParam == CONNECT_NO_ERROR )
	{
		// Tell the server node to grab its Sdo pointers.
		m_pMachineNode->LoadSdoData(m_fDSAvailable);

		//
		// Cause a view update.
		//
		CComponentData *pComponentData  = m_pMachineNode->GetComponentData();
		_ASSERTE( pComponentData != NULL );
		_ASSERTE( pComponentData->m_spConsole != NULL );

		CChangeNotification *pChangeNotification = new CChangeNotification();
		pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE;
		pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0 );
		pChangeNotification->Release();
	
	
	
	}
	else if (wParam == CONNECT_SERVER_NOT_SUPPORTED)
	{
		m_pMachineNode->m_bServerSupported = FALSE;
		//
		// Cause a view update -- hide the node.
		//
		CComponentData *pComponentData  = m_pMachineNode->GetComponentData();
		_ASSERTE( pComponentData != NULL );
		_ASSERTE( pComponentData->m_spConsole != NULL );

		CChangeNotification *pChangeNotification = new CChangeNotification();
		pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE;
		pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0 );
		pChangeNotification->Release();
	}
	else
	{
		// There was an error connecting.
		ShowErrorDialog( m_hWnd, IDS_ERROR_CANT_CONNECT);
	}

	return 0;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::GetConnectionStatus

Our connection status is basically a function of the status of the underlying
worker thread.  So here we give a connection status based on the worker thread's.

--*/
//////////////////////////////////////////////////////////////////////////////
CONNECTION_STATUS CConnectionToServer::GetConnectionStatus( void )
{
	TRACE_FUNCTION("CConnectionToServer::GetConnectionStatus");

	// Check for preconditions:
	CONNECTION_STATUS csStatus;


	switch( GetWorkerThreadStatus() )
	{
	case WORKER_THREAD_NEVER_STARTED:
		csStatus = NO_CONNECTION_ATTEMPTED;
		break;

	case WORKER_THREAD_STARTING:
	case WORKER_THREAD_STARTED:
		csStatus = CONNECTING;
		break;
	
	case WORKER_THREAD_FINISHED:
		csStatus = CONNECTED;
		break;
	
	case WORKER_THREAD_START_FAILED:
	case WORKER_THREAD_ACTION_INTERRUPTED:
		csStatus = CONNECTION_ATTEMPT_FAILED;
		break;
	
	default:
		csStatus = UNKNOWN;
		break;
	}

	return csStatus;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::GetSdoService

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CConnectionToServer::GetSdoService( ISdo **ppSdoService )
{
	TRACE_FUNCTION("CConnectionToServer::GetSdoService");


	// Check for preconditions:
	_ASSERTE( ppSdoService != NULL );

	if( CONNECTED != GetConnectionStatus() )
	{
		*ppSdoService = NULL;
		return E_FAIL;
	}



	HRESULT hr = S_OK;

	// If we get here, our status is CONNECTED, in which case
	// our worker thread should have marshalled an ISdo interface
	// of the server into the m_pStreadSdoMarshal.

	if( m_pStreamSdoServiceMarshal == NULL )
	{
		// We have already unmarshalled our ISdo interface to the server.
		_ASSERTE( m_spSdo != NULL );
	
	}
	else
	{
		// Unmarshall an ISdo interface pointer to the server.
		hr =  CoGetInterfaceAndReleaseStream(
							  m_pStreamSdoServiceMarshal			//Pointer to the stream from which the object is to be marshaled.
							, IID_ISdo						//Reference to the identifier of the interface.
							, (LPVOID *) &m_spSdo		//Address of output variable that receives the interface pointer requested in riid.
							);

		// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
		// We set it to NULL so that our destructor doesn't try to release this again.
		m_pStreamSdoServiceMarshal = NULL;

		// Unmarshall an ISdo interface pointer to the server.
		hr =  CoGetInterfaceAndReleaseStream(
							  m_pStreamSdoMachineMarshal			//Pointer to the stream from which the object is to be marshaled.
							, IID_ISdoMachine						//Reference to the identifier of the interface.
							, (LPVOID *) &m_spSdoMachine			//Address of output variable that receives the interface pointer requested in riid.
							);

		// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
		// We set it to NULL so that our destructor doesn't try to release this again.
		m_pStreamSdoMachineMarshal = NULL;
	}

	*ppSdoService = m_spSdo;
	

	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::GetSdoDictionaryOld

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CConnectionToServer::GetSdoDictionaryOld( ISdoDictionaryOld **ppSdoDictionaryOld  )
{
	TRACE_FUNCTION("CConnectionToServer::GetSdoDictionaryOld");


	// Check for preconditions:
	_ASSERTE( ppSdoDictionaryOld != NULL );

	if( CONNECTED != GetConnectionStatus() )
	{
		*ppSdoDictionaryOld = NULL;
		return E_FAIL;
	}



	HRESULT hr = S_OK;

	// If we get here, our status is CONNECTED, in which case
	// our worker thread should have marshalled an ISdo interface
	// of the server into the m_pStreadSdoMarshal.

	if( m_pStreamSdoDictionaryOldMarshal == NULL )
	{
		// We have already unmarshalled our ISdo interface to the server.
		_ASSERTE( m_spSdoDictionaryOld != NULL );
	
	}
	else
	{
		// Unmarshall an ISdo interface pointer to the server.
		hr =  CoGetInterfaceAndReleaseStream(
							  m_pStreamSdoDictionaryOldMarshal			//Pointer to the stream from which the object is to be marshaled.
							, IID_ISdoDictionaryOld						//Reference to the identifier of the interface.
							, (LPVOID *) &m_spSdoDictionaryOld		//Address of output variable that receives the interface pointer requested in riid.
							);

		// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
		// We set it to NULL so that our destructor doesn't try to release this again.
		m_pStreamSdoDictionaryOldMarshal = NULL;

	}

	*ppSdoDictionaryOld = m_spSdoDictionaryOld;
	

	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::OnCancel

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CConnectionToServer::OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	TRACE_FUNCTION("CConnectionToServer::OnCancel");


	// Check for preconditions:

	// We don't want to destroy the dialog, we just want to hide it.
	//ShowWindow( SW_HIDE );


	return 0;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CConnectionToServer::DoWorkerThreadAction

Called by the worker thread to have this class perform its action
in the new thread.

--*/

//////////////////////////////////////////////////////////////////////////////
DWORD CConnectionToServer::DoWorkerThreadAction()
{
	TRACE_FUNCTION("CConnectionToServer::DoWorkerThreadAction");

	HRESULT hr;
	DWORD dwReturnValue;
	CComPtr<ISdoMachine> spSdoMachine;

	// We must call CoInitialize because we are in a new thread.
	hr = CoInitialize( NULL );

	WriteTrace("RAP NODE: CoInitialize() , hr = %x", hr);
	if( FAILED( hr ) )
	{
		ErrorTrace(ERROR_NAPMMC_CONNECTION, "CoInitialize() failed, err = %x", hr);
		WriteTrace("RAP NODE: ERROR, hr = %x ", hr);
		return( CONNECT_FAILED );
	}

	do	// Loop for error checking only.
	{

// MAM: 08/04/98 - no DS policy location support anymore
#ifdef STORE_DATA_IN_DIRECTORY_SERVICE
		try
		{

			//
			// first, we check the domain type for this machine
			//
			CComPtr<ISdoMachineInfo>		spServerInfoSdo;
			hr = ::CoCreateInstance(
						CLSID_SdoServerInfo,      //Class identifier (CLSID) of the object
						NULL,				  //Pointer to whether object is or isn't part
											  // of an aggregate
						CLSCTX_INPROC_SERVER, //Context for running executable code,
						IID_ISdoMachineInfo,             //Reference to the identifier of the interface
						(LPVOID *) &spServerInfoSdo   //Address of output variable that receives
													// the interface pointer requested in riid
				);

			if( FAILED(hr) || spServerInfoSdo == NULL )
			{
				ErrorTrace(ERROR_NAPMMC_MACHINENODE, "CoCreateInstance(ServerInfo) failed, err=%x", hr);
				// MAM: Don't fail entire connect action if we couldn't figure out what we are --
				// just assume we don't have the DS available.
				//m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
				//dwReturnValue = -1;	// ISSUE: Need to figure out better return codes.
				//break;
				throw hr;
			}

			DOMAINTYPE serverDomainType;
			if (m_bstrServerAddress.Length())
			{
				hr = spServerInfoSdo->GetDomainInfo
										(
											OBJECT_TYPE_COMPUTER,
											m_bstrServerAddress,
											&serverDomainType
										);
			}
			else
			{
				BSTR bstrAddress = SysAllocString(m_szLocalComputerName);
				if ( bstrAddress )
				{
					hr = spServerInfoSdo->GetDomainInfo
											(
												OBJECT_TYPE_COMPUTER,
												bstrAddress,
												&serverDomainType
											);
					SysFreeString(bstrAddress);
				}
				else
				{
					hr = HRESULT_FROM_WIN32(GetLastError());
					ErrorTrace(ERROR_NAPMMC_CONNECTION,"GetComputerName() failed, err =%x", GetLastError());
				}
			}		

			if ( FAILED(hr) )
			{
				ErrorTrace(ERROR_NAPMMC_CONNECTION, "GetDomainInfo() failed, err = %x", hr);
				// MAM: Don't fail entire connect action if we couldn't figure out what we are --
				// just assume we don't have the DS available.
				//m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
				//dwReturnValue = -1;	// ISSUE: Need to figure out better return codes.
				//break;
				throw hr;
			}

			if ( serverDomainType == DOMAIN_TYPE_NT5 )
			{
				m_fDSAvailable = TRUE;
			}
			else
			{
				//
				// for all other domain types, DS is treated as not available
				//
				m_fDSAvailable = FALSE;
			}

		}
		catch(...)
		{
			// MAM: Don't fail entire connect action if something failed here --
			// just assume we don't have the DS available.
			m_fDSAvailable  = FALSE;
		}

#else	// STORE_DATA_IN_DIRECTORY_SERVICE

		m_fDSAvailable = FALSE;

#endif	// STORE_DATA_IN_DIRECTORY_SERVICE

		//
		// now, we can connect to the server based on the domain type
		//
		hr = CoCreateInstance(
				  CLSID_SdoMachine		//Class identifier (CLSID) of the object
				, NULL					//Pointer to whether object is or isn't part of an aggregate
				, CLSCTX_INPROC_SERVER	//Context for running executable code
				, IID_ISdoMachine				//Reference to the identifier of the interface
				, (LPVOID *) &spSdoMachine	//Address of output variable that receives the interface pointer requested in riid
				);


		WriteTrace("RAP NODE: CoCreateInstance , hr = %x", hr);
		if( FAILED (hr ) )
		{
			// Error -- couldn't CoCreate SDO.
			ErrorTrace(ERROR_NAPMMC_CONNECTION, "CoCreateInstance failed, err = %x", hr);
			WriteTrace("RAP NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		}


#ifdef STORE_DATA_IN_DIRECTORY_SERVICE

		LONG lFlags=0;
		if ( m_fDSAvailable )
		{
			lFlags |= RETRIEVE_SERVER_DATA_FROM_DS;
		}

#endif	// STORE_DATA_IN_DIRECTORY_SERVICE


		if( !m_bstrServerAddress.Length() )
		{
			hr = spSdoMachine->Attach( NULL );
		}
		else
		{
			hr = spSdoMachine->Attach( m_bstrServerAddress );
		}
		
		WriteTrace("RAP NODE: ISdoMachine::Attach , hr = %x", hr);
		if( FAILED( hr ) )
		{
			// Error -- couldn't connect SDO up to this server.
			ErrorTrace(ERROR_NAPMMC_CONNECTION, "ISdoMachine::Connect failed, err = %x", hr);
			WriteTrace("RAP NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		
		}


		// Marshall the ISdo pointer so that the main thread can unmarshall
		// it and use the connection we have established.
		hr = CoMarshalInterThreadInterfaceInStream(
						  IID_ISdoMachine									//Reference to the identifier of the interface.
						, spSdoMachine										//Pointer to the interface to be marshaled.
						, &( m_pStreamSdoMachineMarshal )	//Address of output variable that receives the IStream interface pointer for the marshaled interface.
						);

		// check if the machine is downlevel servers -- NT4, if it is, return CONNECT_SERVER_NOT_SUPPORTED
		{
			IASOSTYPE	OSType;

			spSdoMachine->GetOSType(&OSType);

			if(SYSTEM_TYPE_NT4_WORKSTATION == OSType || SYSTEM_TYPE_NT4_SERVER == OSType)
			{
				WriteTrace("RAP NODE: NT4 machine, not supported ", hr);
				m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
				dwReturnValue = CONNECT_SERVER_NOT_SUPPORTED;	// ISSUE: Need to figure out better return codes.
				break;
			}
		}
		



		CComPtr<IUnknown> spUnknownServiceSdo;


		CComBSTR bstrServiceName;
		
		if( m_fExtendingIAS )
		{
			bstrServiceName = L"IAS";
		}
		else
		{
			bstrServiceName = L"RemoteAccess";
		}

		// Get the service Sdo.
		hr = spSdoMachine->GetServiceSDO (	  DATA_STORE_LOCAL
											, bstrServiceName
											, (IUnknown **)&spUnknownServiceSdo
											);
		WriteTrace("RAP NODE: ISdoMachine::GetServiceSDO , hr = %x", hr);
		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get dictionary object, err = %x", hr);
			WriteTrace("RAP NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		}

		CComPtr<ISdo> spServiceSdo;

		hr = spUnknownServiceSdo->QueryInterface( IID_ISdo, (void **) &spServiceSdo );

		WriteTrace("RAP NODE: spUnknownServiceSdo->QueryInterface( IID_ISdo, hr = %x", hr);
		
		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get service object, err = %x", hr);
			WriteTrace("RAP NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		}

		// We must manually AddRef here because we just copied a pointer
		// into our smart pointer and the smart pointer won't catch that.
		// 39470	*RRAS snapin mmc process does not get shut down upon closing if F1 help is used.
		//		spServiceSdo->AddRef();



		CComPtr<IUnknown> spUnknownDictionarySdo;

		// Get the dictionary Sdo.
		hr = spSdoMachine->GetDictionarySDO ( (IUnknown **)&spUnknownDictionarySdo );
		WriteTrace("RAP NODE: spSdoMachine->GetDictionarySDO , hr = %x", hr);
		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get dictionary object, err = %x", hr);
			WriteTrace("RAP NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		}


		CComPtr<ISdoDictionaryOld> spSdoDictionaryOld;

		hr = spUnknownDictionarySdo->QueryInterface( IID_ISdoDictionaryOld, (void **) &spSdoDictionaryOld );
		WriteTrace("RAP NODE: spUnknownDictionarySdo->QueryInterface( IID_ISdoDictionaryOld, hr = %x", hr);
		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get dictionary object, err = %x", hr);
			WriteTrace("RAP NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		}
		
		// We must manually AddRef here because we just copied a pointer
		// into our smart pointer and the smart pointer won't catch that.
		// 39470	*RRAS snapin mmc process does not get shut down upon closing if F1 help is used.
		//		spSdoDictionaryOld->AddRef();



		// Marshall the ISdo pointer so that the main thread can unmarshall
		// it and use the connection we have established.
		hr = CoMarshalInterThreadInterfaceInStream(
						  IID_ISdo										//Reference to the identifier of the interface.
						, spServiceSdo										//Pointer to the interface to be marshaled.
						, &( m_pStreamSdoServiceMarshal )	//Address of output variable that receives the IStream interface pointer for the marshaled interface.
						);

		WriteTrace("RAP NODE: CoMarshalInterThreadInterfaceInStream  IID_ISdo	, spServiceSdo, hr = %x", hr);
		if( FAILED( hr ) )
		{
			ErrorTrace(ERROR_NAPMMC_CONNECTION, "CoMarshalInterThreadInterfaceInStream failed, err = %x", hr);
			WriteTrace("RAP NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = -1;
			break;
		}



		// Marshall the ISdo pointer so that the main thread can unmarshall
		// it and use the connection we have established.
		hr = CoMarshalInterThreadInterfaceInStream(
						  IID_ISdoDictionaryOld										//Reference to the identifier of the interface.
						, spSdoDictionaryOld										//Pointer to the interface to be marshaled.
						, &( m_pStreamSdoDictionaryOldMarshal )	//Address of output variable that receives the IStream interface pointer for the marshaled interface.
						);

		WriteTrace("RAP NODE: CoMarshalInterThreadInterfaceInStream  IID_ISdoDictionaryOld	, spSdoDictionaryOld, hr = %x", hr);
		if( FAILED( hr ) )
		{
			ErrorTrace(ERROR_NAPMMC_CONNECTION, "CoMarshalInterThreadInterfaceInStream failed, err = %x", hr);
			WriteTrace("RAP NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = -1;
			break;
		}





		// If we made it to here, we are OK.

		_ASSERTE( m_pStreamSdoServiceMarshal != NULL );
		_ASSERTE( m_pStreamSdoDictionaryOldMarshal != NULL );

		m_wtsWorkerThreadStatus = WORKER_THREAD_FINISHED;

		dwReturnValue = 0;

	} while (0);	// Loop for error checking only.

	CoUninitialize();

	DebugTrace(DEBUG_NAPMMC_CONNECTION, "NAP seems to have a valid connection to Sdo");

	// Tell the main MMC thread what's up.
	PostMessageToMainThread( dwReturnValue, NULL );
	
	return dwReturnValue;

}


















//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingConnectionToServer::CLoggingConnectionToServer

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingConnectionToServer::CLoggingConnectionToServer
(
	CLoggingMachineNode *	pMachineNode,	
	BSTR			        bstrServerAddress, // server we are connecting to
	BOOL			        fExtendingIAS	   // are we extending IAS or Network Console
) : CConnectionToServer(NULL, bstrServerAddress, fExtendingIAS)
{
	TRACE_FUNCTION("CLoggingConnectionToServer::CConnectionToServer");

	// Check for preconditions:
	_ASSERTE( pMachineNode != NULL );

	m_pMachineNode		= pMachineNode;
	m_bstrServerAddress = bstrServerAddress;
	m_fExtendingIAS		= fExtendingIAS;

	m_pStreamSdoServiceMarshal = NULL;
	m_fDSAvailable		= FALSE;

	if ( !m_bstrServerAddress.Length() )
	{
		DWORD dwBufferSize = IAS_MAX_COMPUTERNAME_LENGTH;

		if ( !GetComputerName(m_szLocalComputerName, &dwBufferSize) )
		{
			m_szLocalComputerName[0]=_T('\0');
		}
	}
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingConnectionToServer::~CLoggingConnectionToServer

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingConnectionToServer::~CLoggingConnectionToServer()
{
	TRACE_FUNCTION("CLoggingConnectionToServer::~CConnectionToServer");

	// Check for preconditions:
	HRESULT hr;


	// Release this stream pointer if this hasn't already been done.
	if( m_pStreamSdoServiceMarshal != NULL )
	{
		m_pStreamSdoServiceMarshal->Release();
	};

}



//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingConnectionToServer::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLoggingConnectionToServer::OnInitDialog(
	  UINT uMsg
	, WPARAM wParam
	, LPARAM lParam
	, BOOL& bHandled
	)
{
	TRACE_FUNCTION("CLoggingConnectionToServer::OnInitDialog");

	// Check for preconditions:
	_ASSERTE( m_pMachineNode != NULL );
	CLoggingComponentData *pComponentData  = m_pMachineNode->GetComponentData();
	_ASSERTE( pComponentData != NULL );
	_ASSERTE( pComponentData->m_spConsole != NULL );
	_ASSERTE( m_pMachineNode->m_pLoggingNode != NULL );

	// Change the icon for the scope node from being normal to a busy icon.
	CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > spConsoleNameSpace( pComponentData->m_spConsole );
	LPSCOPEDATAITEM psdiLoggingNode;
	m_pMachineNode->m_pLoggingNode->GetScopeData( &psdiLoggingNode );
	_ASSERTE( psdiLoggingNode );
	SCOPEDATAITEM sdi;
	sdi.mask = SDI_IMAGE | SDI_OPENIMAGE;
	sdi.nImage = IDBI_NODE_LOGGING_METHODS_BUSY_CLOSED;
	sdi.nOpenImage = IDBI_NODE_LOGGING_METHODS_BUSY_OPEN;
	sdi.ID = psdiLoggingNode->ID;		

	
	// Change the stored indices as well so that MMC will use them whenever it queries
	// the node for its images.
	LPRESULTDATAITEM prdiLoggingNode;
	m_pMachineNode->m_pLoggingNode->GetResultData( &prdiLoggingNode );
	_ASSERTE( prdiLoggingNode );
	prdiLoggingNode->nImage = IDBI_NODE_LOGGING_METHODS_BUSY_CLOSED;
	psdiLoggingNode->nImage = IDBI_NODE_LOGGING_METHODS_BUSY_CLOSED;
	psdiLoggingNode->nOpenImage = IDBI_NODE_LOGGING_METHODS_BUSY_OPEN;
	
	spConsoleNameSpace->SetItem( &sdi );


//	int		nLoadStringResult;
//	TCHAR	szConnectingStr[256];
//	TCHAR	szConnectingMsg[1024];
//
//	// Set the display name for this object
//	if ( LoadString( _Module.GetResourceInstance(),
//									IDS_CONNECTION_CONNECTING_TO_STR,
//									szConnectingStr,
//									256
//				   ) <= 0 )
//	{
//		_tcscpy( szConnectingMsg, _T("Connecting to ") );
//	}
//
//	if ( !m_bstrServerAddress.Length() )
//	{
//		wsprintf(szConnectingMsg, _T("%ws %ws"), szConnectingStr, m_szLocalComputerName);
//	}
//	else
//	{
//		wsprintf(szConnectingMsg, _T("%ws %ws"), szConnectingStr, m_bstrServerAddress);
//	}
//
//	SetDlgItemText(IDC_CONNECTION_STATUS__DIALOG__STATUS, szConnectingMsg);

	//
	// start the worker thread
	//
	StartWorkerThread();

	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingConnectionToServer::OnReceiveThreadMessage

Called when the worker thread wants to inform the main MMC thread of something.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLoggingConnectionToServer::OnReceiveThreadMessage(
	  UINT uMsg
	, WPARAM wParam
	, LPARAM lParam
	, BOOL& bHandled
	)
{
	TRACE_FUNCTION("CLoggingConnectionToServer::OnReceiveThreadMessage");

	// Check for preconditions:
	_ASSERTE( m_pMachineNode != NULL );
	CLoggingComponentData *pComponentData  = m_pMachineNode->GetComponentData();
	_ASSERTE( pComponentData != NULL );
	_ASSERTE( pComponentData->m_spConsole != NULL );
	_ASSERTE( m_pMachineNode->m_pLoggingNode != NULL );


	// The worker thread has notified us that it has finished.

	// Change the icon for the Policies node.
	CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > spConsoleNameSpace( pComponentData->m_spConsole );

    LPSCOPEDATAITEM psdiLoggingNode = NULL;
    m_pMachineNode->m_pLoggingNode->GetScopeData( &psdiLoggingNode );
	_ASSERTE( psdiLoggingNode );
	
    SCOPEDATAITEM sdi;
	sdi.mask = SDI_IMAGE | SDI_OPENIMAGE;

    if ( wParam == CONNECT_NO_ERROR )
	{
		// Everything was OK -- change the icon to the OK icon.
		
		sdi.nImage = IDBI_NODE_LOGGING_METHODS_CLOSED;
		sdi.nOpenImage = IDBI_NODE_LOGGING_METHODS_OPEN;

		// Change the stored indices as well so that MMC will use them whenever it queries
		// the node for its images.
		LPRESULTDATAITEM prdiLoggingNode;
		m_pMachineNode->m_pLoggingNode->GetResultData( &prdiLoggingNode );
		_ASSERTE( prdiLoggingNode );
		
        prdiLoggingNode->nImage = IDBI_NODE_LOGGING_METHODS_CLOSED;
		psdiLoggingNode->nImage = IDBI_NODE_LOGGING_METHODS_CLOSED;
		psdiLoggingNode->nOpenImage = IDBI_NODE_LOGGING_METHODS_OPEN;
	}
	else
	{
		// There was an error -- change the icon to the error icon.

		sdi.nImage = IDBI_NODE_LOGGING_METHODS_ERROR_CLOSED;
		sdi.nOpenImage = IDBI_NODE_LOGGING_METHODS_ERROR_OPEN;

		// Change the stored indices as well so that MMC will use them whenever it queries
		// the node for its images.
		LPRESULTDATAITEM prdiLoggingNode;
		m_pMachineNode->m_pLoggingNode->GetResultData( &prdiLoggingNode );
		_ASSERTE( prdiLoggingNode );
		
        prdiLoggingNode->nImage = IDBI_NODE_LOGGING_METHODS_ERROR_CLOSED;
		psdiLoggingNode->nImage = IDBI_NODE_LOGGING_METHODS_ERROR_CLOSED;
		psdiLoggingNode->nOpenImage = IDBI_NODE_LOGGING_METHODS_ERROR_OPEN;
	}

    sdi.ID = psdiLoggingNode->ID;		
	spConsoleNameSpace->SetItem( &sdi );

	// We don't want to destroy the dialog, we just want to hide it.
	//ShowWindow( SW_HIDE );

	if( wParam == CONNECT_NO_ERROR )
	{
		// Tell the server node to grab its Sdo pointers.
		m_pMachineNode->LoadSdoData(m_fDSAvailable);

		// Ask the server node to update all its info from the SDO's.
		m_pMachineNode->LoadCachedInfoFromSdo();

		//
		// Cause a view update.
		//
		CLoggingComponentData *pComponentData  = m_pMachineNode->GetComponentData();
		_ASSERTE( pComponentData != NULL );
		_ASSERTE( pComponentData->m_spConsole != NULL );

		CChangeNotification *pChangeNotification = new CChangeNotification();
		pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE;
		pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0 );
		pChangeNotification->Release();
	}
	else if (wParam == CONNECT_SERVER_NOT_SUPPORTED)
	{
		m_pMachineNode->m_bServerSupported = FALSE;
		//
		// Cause a view update -- hide the node.
		//
		CLoggingComponentData *pComponentData  = m_pMachineNode->GetComponentData();
		_ASSERTE( pComponentData != NULL );
		_ASSERTE( pComponentData->m_spConsole != NULL );

		CChangeNotification *pChangeNotification = new CChangeNotification();
		pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE;
		pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0 );
		pChangeNotification->Release();
	}
	else	// CONNECT_FAILED
	{
		// There was an error connecting.
		ShowErrorDialog( m_hWnd, IDS_ERROR_CANT_CONNECT, NULL, 0, IDS_ERROR__LOGGING_TITLE );
	}

	return 0;
}




//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingConnectionToServer::DoWorkerThreadAction

Called by the worker thread to have this class perform its action
in the new thread.

--*/
//////////////////////////////////////////////////////////////////////////////
DWORD CLoggingConnectionToServer::DoWorkerThreadAction()
{
	TRACE_FUNCTION("CLoggingConnectionToServer::DoWorkerThreadAction");

	HRESULT hr;
	DWORD dwReturnValue;
	CComPtr<ISdoMachine> spSdoMachine;

	// We must call CoInitialize because we are in a new thread.
	hr = CoInitialize( NULL );
	WriteTrace("LOGGING NODE: CoInitialize() , hr = %x", hr);

	if( FAILED( hr ) )
	{
		WriteTrace("LOGGING NODE: ERROR, hr = %x ", hr);
		ErrorTrace(ERROR_NAPMMC_CONNECTION, "CoInitialize() failed, err = %x", hr);
		return( CONNECT_FAILED );
	}

	do	// Loop for error checking only.
	{


		//
		// now, we can connect to the server based on the domain type
		//
		hr = CoCreateInstance(
				  CLSID_SdoMachine		//Class identifier (CLSID) of the object
				, NULL					//Pointer to whether object is or isn't part of an aggregate
				, CLSCTX_INPROC_SERVER	//Context for running executable code
				, IID_ISdoMachine				//Reference to the identifier of the interface
				, (LPVOID *) &spSdoMachine	//Address of output variable that receives the interface pointer requested in riid
				);


		WriteTrace("LOGGING NODE: CoCreateInstance, hr = %x", hr);
		if( FAILED (hr ) )
		{
			// Error -- couldn't CoCreate SDO.
			ErrorTrace(ERROR_NAPMMC_CONNECTION, "CoCreateInstance failed, err = %x", hr);
			WriteTrace("LOGGING NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		}


		if( !m_bstrServerAddress.Length() )
		{
			hr = spSdoMachine->Attach( NULL );
		}
		else
		{
			hr = spSdoMachine->Attach( m_bstrServerAddress );
		}
		
		WriteTrace("LOGGING NODE: ISdoMachine::Attach, hr = %x", hr);
		if( FAILED( hr ) )
		{
			// Error -- couldn't connect SDO up to this server.
			ErrorTrace(ERROR_NAPMMC_CONNECTION, "ISdoMachine::Connect failed, err = %x", hr);
			WriteTrace("LOGGING NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		
		}


		// Marshall the ISdo pointer so that the main thread can unmarshall
		// it and use the connection we have established.
		hr = CoMarshalInterThreadInterfaceInStream(
						  IID_ISdoMachine									//Reference to the identifier of the interface.
						, spSdoMachine										//Pointer to the interface to be marshaled.
						, &( m_pStreamSdoMachineMarshal )	//Address of output variable that receives the IStream interface pointer for the marshaled interface.
						);

		// check if the machine is downlevel servers -- NT4, if it is, return CONNECT_SERVER_NOT_SUPPORTED
		{
			IASOSTYPE	OSType;

			spSdoMachine->GetOSType(&OSType);

			if(SYSTEM_TYPE_NT4_WORKSTATION == OSType || SYSTEM_TYPE_NT4_SERVER == OSType)
			{
				WriteTrace("LOGGING NODE: NT4 machine, not supported ", hr);
				m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
				dwReturnValue = CONNECT_SERVER_NOT_SUPPORTED;	// ISSUE: Need to figure out better return codes.
				break;
			}
		}
		

		CComPtr<IUnknown> spUnknownServiceSdo;


		CComBSTR bstrServiceName;

		if( m_fExtendingIAS )
		{
			bstrServiceName = L"IAS";
		}
		else
		{
			bstrServiceName = L"RemoteAccess";
		}

		// Get the service Sdo.
		hr = spSdoMachine->GetServiceSDO (	  DATA_STORE_LOCAL
											, bstrServiceName
											, (IUnknown **)&spUnknownServiceSdo
										);
		WriteTrace("LOGGING NODE: spSdoMachine->GetServiceSDO, hr = %x", hr);
		
		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get dictionary object, err = %x", hr);
			WriteTrace("LOGGING NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		}

		CComPtr<ISdo> spServiceSdo;

		hr = spUnknownServiceSdo->QueryInterface( IID_ISdo, (void **) &spServiceSdo );

		WriteTrace("LOGGING NODE: spUnknownServiceSdo->QueryInterface IID_ISdo, hr = %x", hr);
		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get service object, err = %x", hr);
			WriteTrace("LOGGING NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;	// ISSUE: Need to figure out better return codes.
			break;
		}

		// We must manually AddRef here because we just copied a pointer
		// into our smart pointer and the smart pointer won't catch that.
		// 39470	*RRAS snapin mmc process does not get shut down upon closing if F1 help is used.
		//		spServiceSdo->AddRef();



		// Marshall the ISdo pointer so that the main thread can unmarshall
		// it and use the connection we have established.
		hr = CoMarshalInterThreadInterfaceInStream(
						  IID_ISdo										//Reference to the identifier of the interface.
						, spServiceSdo										//Pointer to the interface to be marshaled.
						, &( m_pStreamSdoServiceMarshal )	//Address of output variable that receives the IStream interface pointer for the marshaled interface.
						);

		WriteTrace("LOGGING NODE: CoMarshalInterThreadInterfaceInStream IID_ISdo spServiceSdo, hr = %x", hr);
		if( FAILED( hr ) )
		{
			ErrorTrace(ERROR_NAPMMC_CONNECTION, "CoMarshalInterThreadInterfaceInStream failed, err = %x", hr);
			WriteTrace("LOGGING NODE: ERROR, hr = %x ", hr);
			m_wtsWorkerThreadStatus = WORKER_THREAD_ACTION_INTERRUPTED;
			dwReturnValue = CONNECT_FAILED;
			break;
		}



		// If we made it to here, we are OK.

		_ASSERTE( m_pStreamSdoServiceMarshal != NULL );

		m_wtsWorkerThreadStatus = WORKER_THREAD_FINISHED;

		dwReturnValue = 0;

	} while (0);	// Loop for error checking only.

	CoUninitialize();

	DebugTrace(DEBUG_NAPMMC_CONNECTION, "NAP seems to have a valid connection to Sdo");

	// Tell the main MMC thread what's up.
	PostMessageToMainThread( dwReturnValue, NULL );
	
	return dwReturnValue;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\connectiontoserver.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ConectionToServer.h

Abstract:

	Header file for class which manages connection to a remote server.

	The connect action takes place in a worker thread.

	See ConnectionToServer.cpp for implementation.

Revision History:
	mmaguire 02/09/98 - created
	byao	 04/24/98 - Modified for NAPMMC.DLL (Remote Access Policies snap-in)

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_CONNECTION_TO_SERVER_H_)
#define _NAP_CONNECTION_TO_SERVER_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "DialogWithWorkerThread.h"
//
//
// where we can find what this class has or uses:
//
#include "sdoias.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

// return value for connection
#define	CONNECT_NO_ERROR				0
#define	CONNECT_SERVER_NOT_SUPPORTED	1
#define	CONNECT_FAILED					(-1)

typedef
enum _TAG_CONNECTION_STATUS
{
	NO_CONNECTION_ATTEMPTED = 0,
	CONNECTING,
	CONNECTED,
	CONNECTION_ATTEMPT_FAILED,
	CONNECTION_INTERRUPTED,
	UNKNOWN
} CONNECTION_STATUS;



class CMachineNode;
class CLoggingMachineNode;

class CConnectionToServer : public CDialogWithWorkerThread<CConnectionToServer>
{
public:
	CConnectionToServer( CMachineNode *pServerNode, 
						 BSTR bstrServerAddress,
						 BOOL fExtendingIAS	);

	~CConnectionToServer( void );

public:

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of 
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_CONNECT_TO_MACHINE };

	BEGIN_MSG_MAP(CConnectionToServer)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDCANCEL, OnCancel )
		CHAIN_MSG_MAP(CDialogWithWorkerThread<CConnectionToServer>)
	END_MSG_MAP()

	LRESULT OnCancel(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnReceiveThreadMessage(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	void CleanupMachineRelated( void )
	{
		m_pMachineNode = NULL;
	}

	CONNECTION_STATUS GetConnectionStatus( void );

	HRESULT GetSdoService( ISdo **ppSdo );

	// happening in the main thread
	HRESULT ReloadSdo(ISdo** ppSdoService, ISdoDictionaryOld **ppSdoDictionaryOld);

	HRESULT GetSdoDictionaryOld( ISdoDictionaryOld **ppSdoDictionaryOld );


	DWORD DoWorkerThreadAction();


protected:

	CONNECTION_STATUS m_ConnectionStatus;

	// Pointer to stream into which the worker thread
	// this class creates will marshal the Sdo interface pointer it gets.
	LPSTREAM		m_pStreamSdoMachineMarshal;
	LPSTREAM		m_pStreamSdoServiceMarshal;
	LPSTREAM		m_pStreamSdoDictionaryOldMarshal;

	// SDO pointers for use in the main thread's context.
	CComPtr<ISdo>	m_spSdo;
	CComPtr<ISdoDictionaryOld>	m_spSdoDictionaryOld;
	CComPtr<ISdoMachine>		m_spSdoMachine;

	// 
	CMachineNode*	m_pMachineNode;
	CComBSTR		m_bstrServerAddress;
	BOOL			m_fExtendingIAS;
	BOOL			m_fDSAvailable; // is DS avilable for this machine?
									// DS is only available for NT5 domain
	void			WriteTrace(char* info, HRESULT hr)
	{
		::CString	str = info;
		::CString	str1;
		str1.Format(str, hr);
		TracePrintf(g_dwTraceHandle, str1);

	};

	//
	// local computer name.
	// We need this name to call ServerInfo->GetDomainInfo(), as well as showing
	// it in connecting message
	//
	TCHAR			m_szLocalComputerName[IAS_MAX_COMPUTERNAME_LENGTH];

};

class CLoggingConnectionToServer : public CConnectionToServer
{
public:
	CLoggingConnectionToServer( CLoggingMachineNode * pServerNode, 
						        BSTR bstrServerAddress,
						        BOOL fExtendingIAS );

	~CLoggingConnectionToServer( void );

public:
	BEGIN_MSG_MAP(CLoggingConnectionToServer)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		CHAIN_MSG_MAP(CConnectionToServer)
	END_MSG_MAP()

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnReceiveThreadMessage(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	DWORD DoWorkerThreadAction();


private:
    CLoggingMachineNode *   m_pMachineNode;
};

#endif // _IAS_CONNECTION_TO_SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\eaphlp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	eaphlp.cpp
			
    FILE HISTORY:
        
*/

#include <precompiled.h>
#include <afxtempl.h>
#include <winldap.h>
#include "eaphlp.h"
#include "resource.h"
#include "lm.h"
#include "dsrole.h"
#include "lmserver.h"

#include "tregkey.h"

/*!--------------------------------------------------------------------------
	HrIsStandaloneServer
		Returns S_OK if the machine name passed in is a standalone server,
		or if pszMachineName is S_FALSE.

		Returns FALSE otherwise.
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT	HrIsStandaloneServer(LPCWSTR pMachineName)
{
    DWORD		netRet = 0;
    HRESULT		hr = S_OK;
	DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdsRole = NULL;

	netRet = DsRoleGetPrimaryDomainInformation(pMachineName, DsRolePrimaryDomainInfoBasic, (LPBYTE*)&pdsRole);

	if(netRet != 0)
	{
		hr = HRESULT_FROM_WIN32(netRet);
		goto L_ERR;
	}

	ASSERT(pdsRole);
	
	// if the machine is not a standalone server
	if(pdsRole->MachineRole != DsRole_RoleStandaloneServer)
    {
		hr = S_FALSE;
    }
    
L_ERR:    	
	if(pdsRole)
		DsRoleFreeMemory(pdsRole);

    return hr;
}

#undef CONST_STRING
#undef CONST_STRINGA
#undef CONST_STRINGW

#define _STRINGS_DEFINE_STRINGS

#ifdef _STRINGS_DEFINE_STRINGS

    #define CONST_STRING(rg,s)   const TCHAR rg[] = TEXT(s);
    #define CONST_STRINGA(rg,s) const char rg[] = s;
    #define CONST_STRINGW(rg,s)  const WCHAR rg[] = s;

#else

    #define CONST_STRING(rg,s)   extern const TCHAR rg[];
    #define CONST_STRINGA(rg,s) extern const char rg[];
    #define CONST_STRINGW(rg,s)  extern const WCHAR rg[];

#endif


CONST_STRING(c_szRasmanPPPKey,      "System\\CurrentControlSet\\Services\\Rasman\\PPP")
CONST_STRING(c_szEAP,               "EAP")
CONST_STRING(c_szConfigCLSID,       "ConfigCLSID")
CONST_STRING(c_szFriendlyName,      "FriendlyName")
CONST_STRING(c_szMPPEEncryptionSupported, "MPPEEncryptionSupported")
CONST_STRING(c_szStandaloneSupported,	"StandaloneSupported")


// EAP helper functions


HRESULT  LoadEapProviders(HKEY hkeyBase, AuthProviderArray *pProvList, BOOL bStandAlone);

HRESULT  GetEapProviders(LPCTSTR pServerName, AuthProviderArray *pProvList)
{
	RegKey   m_regkeyRasmanPPP;
	RegKey      regkeyEap;
	DWORD	dwErr = ERROR_SUCCESS;
	HRESULT	hr = S_OK;

    BOOL		bStandAlone = ( S_OK == HrIsStandaloneServer(pServerName));

	// Get the list of EAP providers
	// ----------------------------------------------------------------
	dwErr = m_regkeyRasmanPPP.Open(HKEY_LOCAL_MACHINE,c_szRasmanPPPKey,KEY_ALL_ACCESS,pServerName);
    if ( ERROR_SUCCESS == dwErr )
    {
        if ( ERROR_SUCCESS == regkeyEap.Open(m_regkeyRasmanPPP, c_szEAP) )
            hr = LoadEapProviders(regkeyEap, pProvList, bStandAlone);
    }
    else
    	hr = HRESULT_FROM_WIN32(dwErr);

	return hr;
}

/*!--------------------------------------------------------------------------
   DATA_SRV_AUTH::LoadEapProviders
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT  LoadEapProviders(HKEY hkeyBase, AuthProviderArray *pProvList, BOOL bStandAlone)
{
    RegKey      regkeyProviders;
    HRESULT     hr = S_OK;
    HRESULT     hrIter;
    RegKeyIterator regkeyIter;
    CString     stKey;
    RegKey      regkeyProv;
    AuthProviderData  data;
    DWORD		dwErr;
    DWORD		dwData;

    ASSERT(hkeyBase);
    ASSERT(pProvList);

    // Open the providers key
	// ----------------------------------------------------------------
    regkeyProviders.Attach(hkeyBase);

    hr = regkeyIter.Init(&regkeyProviders);

    if (hr != S_OK)
    	goto L_ERR;

    for ( hrIter=regkeyIter.Next(&stKey); hrIter == S_OK;
        hrIter=regkeyIter.Next(&stKey), regkeyProv.Close() )
    {
        // Open the key
		// ------------------------------------------------------------
        dwErr = regkeyProv.Open(regkeyProviders, stKey, KEY_READ);
        if ( dwErr != ERROR_SUCCESS )
            continue;

        // Initialize the data structure
		// ------------------------------------------------------------
		data.m_stKey = stKey;
        data.m_stTitle.Empty();
        data.m_stConfigCLSID.Empty();
        data.m_stGuid.Empty();
        data.m_fSupportsEncryption = FALSE;
		data.m_dwStandaloneSupported = 0;

        // Read in the values that we require
		// ------------------------------------------------------------
        regkeyProv.QueryValue(c_szFriendlyName, data.m_stTitle);
        regkeyProv.QueryValue(c_szConfigCLSID, data.m_stConfigCLSID);
        regkeyProv.QueryValue(c_szMPPEEncryptionSupported, dwData);
        data.m_fSupportsEncryption = (dwData != 0);

		// Read in the standalone supported value.
		// ------------------------------------------------------------
		if (S_OK != regkeyProv.QueryValue(c_szStandaloneSupported, dwData))
			dwData = 1;	// the default
		data.m_dwStandaloneSupported = dwData;

		if(dwData == 0 /* standalone not supported */ && bStandAlone)
			;
		else
	        pProvList->Add(data);
    }

L_ERR:
	regkeyProviders.Detach();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\enumcondedit.h ===
/****************************************************************************************
 * NAME:	EnumCondEdit.h
 *
 * CLASS:	CEnumConditionEditor
 *
 * OVERVIEW
 *
 * Internet Authentication Server: 
 *			This dialog box is used to edit an enum-typed condition
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				1/27/98		Created by	Byao	(using ATL wizard)
 *
 *****************************************************************************************/

#ifndef __ENUMCONDEDIT_H_
#define __ENUMCONDEDIT_H_


#include "atltmp.h"

#include "dialog.h"

#include <vector>


/////////////////////////////////////////////////////////////////////////////
// CEnumConditionEditor
class CEnumConditionEditor;
typedef CIASDialog<CEnumConditionEditor, FALSE>  ENUMCONDEDITORFALSE;

class CEnumConditionEditor : public CIASDialog<CEnumConditionEditor, FALSE>
{
// FALSE means do not clean up the dialog box automatically, we clean up ourselves

public:
	CEnumConditionEditor();

	enum { IDD = IDD_DIALOG_ENUM_COND };

BEGIN_MSG_MAP(CEnumConditionEditor)

	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

	NOTIFY_HANDLER(IDC_LIST_ENUMCOND_CHOICE,    NM_DBLCLK , OnChoiceDblclk)
	NOTIFY_HANDLER(IDC_LIST_ENUMCOND_SELECTION, NM_DBLCLK , OnSelectionDblclk)

	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_ID_HANDLER(IDC_BUTTON_ENUMCOND_ADD, OnAdd)
	COMMAND_ID_HANDLER(IDC_BUTTON_ENUMCOND_DELETE, OnDelete)

	CHAIN_MSG_MAP(ENUMCONDEDITORFALSE)

END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnChoiceDblclk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnSelectionDblclk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
	ATL::CString m_strAttrName;
	
	CComPtr< IIASAttributeInfo >	m_spAttributeInfo;
	std::vector< CComBSTR > *	 m_pSelectedList;

	HRESULT GetHelpPath(LPTSTR szHelpPath);

protected:
	BOOL PopulateSelections();
	LRESULT SwapSelection(int iSource, int iDest);
};

#endif //__EnumCondEdit_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\eaphlp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	eaphlp.h
		This file defines the following macros helper classes and functions:

    FILE HISTORY:

*/
#ifndef _EAPHELPER_
#define _EAPHELPER_

#include <afxtempl.h>


/*!--------------------------------------------------------------------------
	EnableChildControls
		Use this function to enable/disable/hide/show all child controls
		on a page (actually it will work with any child windows, the
		parent does not have to be a property page).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT EnableChildControls(HWND hWnd, DWORD dwFlags);
#define PROPPAGE_CHILD_SHOW		0x00000001
#define PROPPAGE_CHILD_HIDE		0x00000002
#define PROPPAGE_CHILD_ENABLE	0x00000004
#define PROPPAGE_CHILD_DISABLE	0x00000008


/*---------------------------------------------------------------------------
   Struct:  AuthProviderData

   This structure is used to hold information for Authentication AND
   Accounting providers.
 ---------------------------------------------------------------------------*/
struct AuthProviderData
{
   // The following fields will hold data for ALL auth/acct/EAP providers
   ::CString  m_stTitle;
   ::CString  m_stConfigCLSID;  // CLSID for config object
   ::CString	m_stProviderTypeGUID;	// GUID for the provider type

   // These fields are used by auth/acct providers.
   ::CString  m_stGuid;         // the identifying guid

   // This flag is used for EAP providers
   ::CString	m_stKey;			// name of registry key (for this provider)
   BOOL  m_fSupportsEncryption;  // used by EAP provider data
   DWORD m_dwStandaloneSupported;
};

typedef CArray<AuthProviderData, AuthProviderData&> AuthProviderArray;

HRESULT  GetEapProviders(LPCTSTR machineName, AuthProviderArray *pProvList);

#endif //_EAPHELPER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\helpconstants.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    HelpConstants.h

Abstract:

	Header file with constants for HelpID's


Revision History:
	mmaguire 12/12/97 - created

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_HELP_CONSTANTS_H_)
#define _NAP_HELP_CONSTANTS_H_

//////////////////////////////////////////////////////////////////////////////
// NO INCLUDES
//////////////////////////////////////////////////////////////////////////////

// Help ID definitions for CAddPolicyPage
#define		IDH_BUTTON_ADD_POLICY__OK		4101
#define  	IDH_BUTTON_ADD_POLICY__CANCEL	4102


#define 	IDH_LIST_RULEDLG2_CHOICE			4201
#define 	IDH_BUTTON_RULEDLG1_ADD				4203
#define 	IDH_BUTTON_RULEDLG1_DELETE			4204
#define 	IDH_BUTTON_MULTIVALUE_RULE__OK		4205
#define 	IDH_BUTTON_MULTIVALUE_RULE__CANCEL	4206
#define 	IDH_BUTTON_MULTIVALUE_RULE__HELP	4207

// Help ID definitions for CLocalFileLoggingPage1 dialog
#define IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__ENABLE_LOGGING					1200
#define IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__LOG_ACCOUNTING_PACKETS			1210
#define IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__LOG_AUTHENTICATION_PACKETS		1220
#define IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS	1230



// Help ID definitions for CLocalFileLoggingPage2 dialog
#define IDH_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG		1300
#define IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY							1310
#define	IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY							1320
#define	IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY							1330
#define IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES			1340
#define IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE					1350
#define	IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY				1360
#define IDH_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE							1370
#define IDH_CHECK_LOCAL_FILE_LOGGING_PAGE2__USE_V1_FORMAT					1380
#define IDH_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME					1390
#define IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1						1392
#define IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC						1396

#endif // _NAP_HELP_CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\enumcondedit.cpp ===
/****************************************************************************************
 * NAME:	EnumCondEdit.cpp
 *
 * CLASS:	CEnumConditionEditor
 *
 * OVERVIEW
 *
 * Internet Authentication Server: 
 *			This dialog box is used to edit enum-typed editor
 *
 *			e.x.   attr = <value1>\|<value2>
 *
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				1/27/98		Created by	Byao	(using ATL wizard)
 *
 *****************************************************************************************/

#include "precompiled.h"
#include "EnumCondEdit.h"

//+---------------------------------------------------------------------------
//
// Function:  CEnumConditionEditor
//
// Class:	  CEnumConditionEditor
//
// Synopsis:  constructor for CEnumConditionEditor. 
//
// Arguments: LPTSTR pszAttrName - The attribute that needs to be edited
//
// Returns:   Nothing
//
// History:   Created byao 1/30/98 6:14:32 PM
//
//+---------------------------------------------------------------------------
CEnumConditionEditor::CEnumConditionEditor()
{

}


//+---------------------------------------------------------------------------
//
// Function:  OnInitDialog
//
// Class:	  CEnumConditionEditor
//
// Synopsis:  initialize the dialog box
//
// Arguments: UINT uMsg - 
//            WPARAM wParam - 
//            LPARAM lParam - 
//            BOOL& bHandled - 
//
// Returns:   LRESULT - 
//
// History:   Created Header    1/30/98 6:15:41 PM
//
//+---------------------------------------------------------------------------
LRESULT CEnumConditionEditor::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	TRACE_FUNCTION("CEnumConditionEditor::OnInitDialog");

	LVCOLUMN	lvCol;

	lvCol.mask = LVCF_FMT | LVCF_WIDTH ;
	lvCol.fmt = LVCFMT_LEFT;
	lvCol.cx = 200;	// will readjust with later in the program

	SendDlgItemMessage(IDC_LIST_ENUMCOND_CHOICE,
						   LVM_INSERTCOLUMN,
						   1,
						   (LPARAM) &lvCol
						  );

	SendDlgItemMessage(IDC_LIST_ENUMCOND_SELECTION,
						   LVM_INSERTCOLUMN,
						   1,
						   (LPARAM) &lvCol
						  );

    // 
    // populate the possible multiple selections
    // 
	PopulateSelections();

	// change the title to the name of the attribute
	SetWindowText(m_strAttrName);

	return 1;  // Let the system set the focus
}


LRESULT CEnumConditionEditor::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CEnumConditionEditor::OnOK");

	m_pSelectedList->clear();


	TCHAR	buffer[MAX_PATH * 2];
    // 
    // get the current selection index in the source list box
    // 

    // LVM_GETSELECTIONMARK
   int iTotal = SendDlgItemMessage(IDC_LIST_ENUMCOND_SELECTION,
						   LVM_GETITEMCOUNT,
						   0,
						   0);

	// put the text into the list
	for( int i = 0; i < iTotal; i++)
	{
		LVITEM	lvItem;


		lvItem.mask = 0;
		lvItem.iSubItem = 0;
		lvItem.iItem = i;
		lvItem.pszText = buffer;
		lvItem.cchTextMax = MAX_PATH * 2;
	
	
		if (SendDlgItemMessage(IDC_LIST_ENUMCOND_SELECTION,
						   LVM_GETITEMTEXT,
						   i,
						   (LPARAM)&lvItem
						  ) > 0)
		{
			try 
			{
				CComBSTR bstrValue = buffer;
				m_pSelectedList->push_back( bstrValue );
			}
			catch (...)
			{
				throw;
			}
		}
	}


	EndDialog(wID);
	return 0;
}

LRESULT CEnumConditionEditor::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CEnumConditionEditor::OnCancel");
	EndDialog(wID);
	return 0;
}

//+---------------------------------------------------------------------------
//
// Function:  OnAdd
//
// Class:	  CEnumConditionEditor
//
// Synopsis:  Add a selected value from the "Choices" list to "Selection" list
//
// Arguments: WORD wNotifyCode - notify code for this WM_COMMAND msg
//            WORD wID - ID of the control
//            HWND hWndCtl -  Window Handle for this msg
//            BOOL& bHandled - whether it's handled or not
//
// Returns:   LRESULT - 
//					S_FALSE:	failure
//					0:			succeed
//
// History:   Created    byao    1/30/98 3:47:33 PM
//
//+---------------------------------------------------------------------------
LRESULT CEnumConditionEditor::OnAdd(WORD wNotifyCode, 
							WORD wID,
							HWND hWndCtl,
							BOOL& bHandled)
{
	TRACE_FUNCTION("CEnumConditionEditor::OnAdd");

    // 
    // see if the current focus is in "Selection" listbox
    // 

	
	return SwapSelection(IDC_LIST_ENUMCOND_CHOICE, 
					IDC_LIST_ENUMCOND_SELECTION);
}

//+---------------------------------------------------------------------------
//
// Function:  OnDelete
//
// Class:	  CEnumConditionEditor
//
// Synopsis:  Delete a selected value from the "Selection" list
//			  and move it back to "Choices" list
//
// Arguments: WORD wNotifyCode - notify code for this WM_COMMAND msg
//            WORD wID - ID of the control
//            HWND hWndCtl -  Window Handle for this msg
//            BOOL& bHandled - whether it's handled or not
//
// Returns:   LRESULT - 
//					S_FALSE:	failure
//					0:			succeed
//
// History:   Created    byao    1/30/98 3:47:33 PM
//+---------------------------------------------------------------------------
LRESULT CEnumConditionEditor::OnDelete(WORD wNotifyCode, 
							WORD wID,
							HWND hWndCtl,
							BOOL& bHandled)
{
	TRACE_FUNCTION("CEnumConditionEditor::OnDelete");

	return SwapSelection(IDC_LIST_ENUMCOND_SELECTION,
						 IDC_LIST_ENUMCOND_CHOICE);
}


//+---------------------------------------------------------------------------
//
// Function:  OnChoiceDblclk
//
// Class:	  CEnumConditionEditor
//
// Synopsis:  Double click on the "Choice" list --> move it to selection list
//
// Arguments: WORD wNotifyCode - notify code for this WM_COMMAND msg
//            WORD wID - ID of the control
//            HWND hWndCtl -  Window Handle for this msg
//            BOOL& bHandled - whether it's handled or not
//
// Returns:   LRESULT - 
//					S_FALSE:	failure
//					0:			succeed
//
// History:   Created    byao    4/7/98 3:47:33 PM
//+---------------------------------------------------------------------------
LRESULT CEnumConditionEditor::OnChoiceDblclk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	TRACE_FUNCTION("CEnumConditionEditor::OnChoiceDblclk");

	return SwapSelection(IDC_LIST_ENUMCOND_CHOICE, 
					IDC_LIST_ENUMCOND_SELECTION);
}

//+---------------------------------------------------------------------------
//
// Function:  OnSelectionDblclk
//
// Class:	  CEnumConditionEditor
//
// Synopsis:  Double click on the "Selection" list --> move it back to choice list
//
// Arguments: WORD wNotifyCode - notify code for this WM_COMMAND msg
//            WORD wID - ID of the control
//            HWND hWndCtl -  Window Handle for this msg
//            BOOL& bHandled - whether it's handled or not
//
// Returns:   LRESULT - 
//					S_FALSE:	failure
//					0:			succeed
//
// History:   Created    byao    4/7/98 3:47:33 PM
//+---------------------------------------------------------------------------
LRESULT CEnumConditionEditor::OnSelectionDblclk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	TRACE_FUNCTION("CEnumConditionEditor::OnSelectionDblclk");

	return SwapSelection(IDC_LIST_ENUMCOND_SELECTION, 
					IDC_LIST_ENUMCOND_CHOICE);
}

//+---------------------------------------------------------------------------
//
// Function:	PopulateSelections
//
// Class:		CEnumConditionEditor
//
// Synopsis:	Populate the multiple selection list
//
// Arguments:	None
//
// Returns:		BOOL - 
//
// History:		Created    byao  1/30/98 3:24:22 PM
//
//+---------------------------------------------------------------------------
BOOL CEnumConditionEditor::PopulateSelections()
{
	TRACE_FUNCTION("CEnumConditionEditor::PopulateSelections");

	LONG lIndex;
	HRESULT hr;
	LONG lMaxWidth = 0;
	LONG tempSize;

	LVITEM	lvItem;

	lvItem.mask = LVIF_TEXT | LVIF_PARAM;

	CComQIPtr< IIASEnumerableAttributeInfo, &IID_IIASEnumerableAttributeInfo > spEnumerableAttributeInfo( m_spAttributeInfo );
	_ASSERTE( spEnumerableAttributeInfo );


	LONG lSize;
	LONG lTotalChoices; 
	hr = spEnumerableAttributeInfo->get_CountEnumerateDescription( &lSize );
	lTotalChoices = lSize;
	_ASSERTE( SUCCEEDED( hr ) );

	// set item count
	// LVM_SETITEMCOUNT 
	SendDlgItemMessage(IDC_LIST_ENUMCOND_CHOICE,
						   LVM_SETITEMCOUNT,
						   lSize + 1,
						   (LPARAM) 0
						  );
						  
	SendDlgItemMessage(IDC_LIST_ENUMCOND_SELECTION,
						   LVM_SETITEMCOUNT,
						   lSize + 1,
						   (LPARAM) 0
						  );
	for (lIndex=0; lIndex < lSize; lIndex++)
	{
		
		CComBSTR bstrDescription;
		hr = spEnumerableAttributeInfo->get_EnumerateDescription( lIndex, &bstrDescription );
		_ASSERTE( SUCCEEDED( hr ) );

		lvItem.mask = LVIF_PARAM;

		lvItem.pszText = bstrDescription;
		lvItem.lParam = lIndex;
		lvItem.iItem = lIndex;
		lvItem.iSubItem = 0;

		int lvItemIndex = SendDlgItemMessage(IDC_LIST_ENUMCOND_CHOICE,
						   LVM_INSERTITEM,
						   0,
						   (LPARAM) &lvItem
						  );

		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = lvItemIndex; 
		lvItem.iSubItem = 0;

		SendDlgItemMessage(IDC_LIST_ENUMCOND_CHOICE,
						   LVM_SETITEMTEXT,
						   lvItemIndex,
						   (LPARAM) &lvItem
						  );

		tempSize = SendDlgItemMessage(IDC_LIST_ENUMCOND_CHOICE,
						   LVM_GETSTRINGWIDTH,
						   0,
						   (LPARAM) (BSTR)bstrDescription
						  );
						  
		if(tempSize> lMaxWidth)
			lMaxWidth = tempSize;

	}

	lMaxWidth += 20;
	
	// set the width
	SendDlgItemMessage(IDC_LIST_ENUMCOND_CHOICE,
						   LVM_SETCOLUMNWIDTH,
						   0,
						   MAKELPARAM(lMaxWidth, 0)
						  );

	SendDlgItemMessage(IDC_LIST_ENUMCOND_SELECTION,
						   LVM_SETCOLUMNWIDTH,
						   0,
						   MAKELPARAM(lMaxWidth, 0)
						  );

	// now populate the pre-selected values;

	LVFINDINFO	lvFindInfo;
	lvFindInfo.flags = LVFI_STRING;
	lvFindInfo.psz = NULL;
	
	for (lIndex=0; lIndex < m_pSelectedList->size(); lIndex++)
	{
		CComBSTR bstrTemp = m_pSelectedList->at(lIndex);

		lvItem.mask = LVIF_PARAM;

		lvItem.pszText = bstrTemp;
		lvItem.lParam = lIndex;
		lvItem.iItem = lIndex;
		lvItem.iSubItem = 0;

		int lvItemIndex = SendDlgItemMessage(IDC_LIST_ENUMCOND_SELECTION,
						   LVM_INSERTITEM,
						   0,
						   (LPARAM) &lvItem
						  );

		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = lvItemIndex; 
		lvItem.iSubItem = 0;

		SendDlgItemMessage(IDC_LIST_ENUMCOND_SELECTION,
						   LVM_SETITEMTEXT,
						   lvItemIndex,
						   (LPARAM) &lvItem
						  );


		// remove the item from choice
		// find it and remove it
		lvFindInfo.psz = bstrTemp;
		int iDelIndex = SendDlgItemMessage(IDC_LIST_ENUMCOND_CHOICE,
						   LVM_FINDITEM,
						   -1,
						   (LPARAM) &lvFindInfo
						  );

		if(iDelIndex != -1)
			SendDlgItemMessage(IDC_LIST_ENUMCOND_CHOICE,
						   LVM_DELETEITEM,
						   iDelIndex,
						   (LPARAM) 0
						  );


	} // for

	if(m_pSelectedList->size() > 0)	// set default selection -- first one
		ListView_SetItemState(GetDlgItem(IDC_LIST_ENUMCOND_SELECTION), 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
		
	if(lTotalChoices > m_pSelectedList->size())	// still some in availableset default selection -- first one
		ListView_SetItemState(GetDlgItem(IDC_LIST_ENUMCOND_CHOICE), 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	return TRUE;
}


//+---------------------------------------------------------------------------
//
// Function:  SwapSelection
//
// Class:	  CEnumConditionEditor
//
// Synopsis:  move a selected item from one list box to another list box
//			  and move it back to "Choices" list
//
// Arguments: int iSource	- source list box
//			  int iDest		- destination list box
//
// Returns:   LRESULT - 
//					S_FALSE:	failure
//					S_OK:		succeed
//
// History:   Created    byao    1/30/98 3:47:33 PM
//+---------------------------------------------------------------------------
LRESULT CEnumConditionEditor::SwapSelection(int iSource, int iDest)
{
	TRACE_FUNCTION("CEnumConditionEditor::SwapSelection");

	LRESULT lErrCode;
	TCHAR	buffer[MAX_PATH * 2];
    // 
    // get the current selection index in the source list box
    // 

    // LVM_GETSELECTIONMARK
   int iTotalSel = SendDlgItemMessage(iSource,
						   LVM_GETSELECTEDCOUNT,
						   0,
						   0
						  );

   int iCurSel = SendDlgItemMessage(iSource,
						   LVM_GETSELECTIONMARK,
						   0,
						   0
						  );

	// no selection
	if(iCurSel == -1 || iTotalSel < 1)
		return S_OK;

	LVITEM	lvItem;


	lvItem.mask = 0;
	lvItem.iSubItem = 0;
	lvItem.iItem = iCurSel;
	lvItem.pszText = buffer;
	lvItem.cchTextMax = MAX_PATH * 2;
	
	// since we only allow single selection
	if (SendDlgItemMessage(iSource,
						   LVM_GETITEMTEXT,
						   iCurSel,
						   (LPARAM)&lvItem
						  ) > 0)
	{
		// remove the item from source
		SendDlgItemMessage(iSource,
						   LVM_DELETEITEM,
						   iCurSel,
							   (LPARAM)&lvItem
						  );

		// add the new item in the dest list
		lvItem.mask = 0;

		lvItem.iItem = 0;
		lvItem.iSubItem = 0;

		int lvItemIndex = SendDlgItemMessage(iDest,
						   LVM_INSERTITEM,
						   0,
						   (LPARAM) &lvItem
						  );

		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = lvItemIndex; 
		lvItem.iSubItem = 0;

		SendDlgItemMessage(iDest,
						   LVM_SETITEMTEXT,
						   lvItemIndex,
						   (LPARAM) &lvItem
						  );

		// total number of items
		int i = SendDlgItemMessage(iSource,
						   LVM_GETITEMCOUNT,
						   0,
						   0);
						   
		// select the new added on in dest						   
		ListView_SetItemState(GetDlgItem(iDest), lvItemIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
		
		// select next item -- source
		if ( i > iCurSel)
		{
			ListView_SetItemState(GetDlgItem(iSource), iCurSel, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
		}
		else if ( i > 0)
		{
			ListView_SetItemState(GetDlgItem(iSource), i - 1, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
		}
	}


	return S_OK;   // succeed
}


/////////////////////////////////////////////////////////////////////////////
/*++
CEnumConditionEditor::GetHelpPath

Remarks:
	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help 
	button of a property sheet.

	It is an override of CIASDialog::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CEnumConditionEditor::GetHelpPath( LPTSTR szHelpPath )
{
	TRACE_FUNCTION("CEnumCondEditor::GetHelpPath");

#if 0
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("html/idh_proc_cond.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "html/idh_proc_cond.htm" );
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\globals.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    Globals.h

Abstract:

   Header file with common declarations


Revision History:
   mmaguire 12/03/97 - created

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_GLOBALS_H_)
#define _NAP_GLOBALS_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this file needs:
//
#include "resource.h"
#include "dns.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

//The machine node is the root node in the extension snapin.
typedef enum 
{
   INTERNET_AUTHENTICATION_SERVICE_SNAPIN,
   NETWORK_MANAGEMENT_SNAPIN,
   RRAS_SNAPIN
}_enum_EXTENDED_SNAPIN;


// ISSUE: I don't know what the appropriate length should be here -- perhaps MMC imposes a limit somehow?
#define NAP_MAX_STRING MAX_PATH
#define IAS_MAX_STRING MAX_PATH

// Note: We can't just use MAX_COMPUTERNAME_LENGTH anymore because this is 15 characters
// wide and now, with Active Directory, people can enter full DNS names that are much longer
#define IAS_MAX_COMPUTERNAME_LENGTH (DNS_MAX_NAME_LENGTH + 3)

// These are the icon indices within the bitmaps we pass in for IComponentData::Initialize
#define IDBI_NODE_MACHINE_OPEN                 1
#define IDBI_NODE_MACHINE_CLOSED               1
#define IDBI_NODE_POLICIES_OK_CLOSED           1
#define IDBI_NODE_POLICIES_OK_OPEN             1
#define IDBI_NODE_POLICY                       0
#define IDBI_NODE_POLICIES_BUSY_CLOSED         2
#define IDBI_NODE_POLICIES_BUSY_OPEN           2
#define IDBI_NODE_POLICIES_ERROR_CLOSED        3
#define IDBI_NODE_POLICIES_ERROR_OPEN          3

#define IDBI_NODE_LOGGING_METHODS_OPEN         9
#define IDBI_NODE_LOGGING_METHODS_CLOSED       5
#define IDBI_NODE_LOCAL_FILE_LOGGING           4
#define IDBI_NODE_LOGGING_METHODS_BUSY_OPEN   10
#define IDBI_NODE_LOGGING_METHODS_BUSY_CLOSED  6
#define IDBI_NODE_LOGGING_METHODS_ERROR_OPEN   8
#define IDBI_NODE_LOGGING_METHODS_ERROR_CLOSED 7

// ISSUE: We will need to change this later to use a variable 
// which can read in (perhaps from registry?) the location of these files
// as they may be found in a different place depending on where the user 
// chose to install them
#define HELPFILE_NAME TEXT("napmmc.hlp")
#define HTMLHELP_NAME TEXT("napmmc.chm")


#define MATCH_PREFIX _T("MATCH")    // match-type condition prefix
#define TOD_PREFIX      _T("TIMEOFDAY")   // Time of day condition prefix
#define NTG_PREFIX      _T("NTGROUPS") // nt groups condition prefix

// defines that are used in DebugTrace and ErrorTrace
#define ERROR_NAPMMC_MATCHCOND      0x1001
#define DEBUG_NAPMMC_MATCHCOND      0x2001

#define ERROR_NAPMMC_IASATTR        0x1002
#define DEBUG_NAPMMC_IASATTR        0x2002

#define ERROR_NAPMMC_POLICIESNODE   0x1003
#define DEBUG_NAPMMC_POLICIESNODE   0x2003

#define ERROR_NAPMMC_POLICYPAGE1    0x1004
#define DEBUG_NAPMMC_POLICYPAGE1    0x2004

#define ERROR_NAPMMC_COMPONENT      0x1006
#define DEBUG_NAPMMC_COMPONENT      0x2006

#define ERROR_NAPMMC_COMPONENTDATA  0x1007
#define DEBUG_NAPMMC_COMPONENTDATA  0x2007

#define ERROR_NAPMMC_ENUMCONDATTR   0x1008
#define DEBUG_NAPMMC_ENUMCONDATTR   0x2008

#define ERROR_NAPMMC_CONDITION      0x1009
#define DEBUG_NAPMMC_CONDITION      0x2009

#define ERROR_NAPMMC_TODCONDITION   0x100A
#define DEBUG_NAPMMC_TODCONDITION   0x200A

#define ERROR_NAPMMC_NTGCONDITION   0x100A
#define DEBUG_NAPMMC_NTGCONDITION   0x200A

#define ERROR_NAPMMC_ENUMCONDITION  0x100B
#define DEBUG_NAPMMC_ENUMCONDITION  0x200B

#define ERROR_NAPMMC_IASATTRLIST    0x100C
#define DEBUG_NAPMMC_IASATTRLIST    0x200C

#define ERROR_NAPMMC_SELATTRDLG     0x100D
#define DEBUG_NAPMMC_SELATTRDLG     0x200D

#define ERROR_NAPMMC_MACHINENODE    0x100E
#define DEBUG_NAPMMC_MACHINENODE    0x200E

#define ERROR_NAPMMC_TIMEOFDAY      0x100F
#define DEBUG_NAPMMC_TIMEOFDAY      0x200F

#define ERROR_NAPMMC_ENUMTASK       0x1010
#define DEBUG_NAPMMC_ENUMTASK       0x2010

#define ERROR_NAPMMC_POLICYNODE     0x1011
#define DEBUG_NAPMMC_POLICYNODE     0x2011

#define ERROR_NAPMMC_CONNECTION     0x1012
#define DEBUG_NAPMMC_CONNECTION     0x2012

// 
// notification block
//
#define PROPERTY_CHANGE_GENERIC  0x01  // no special handling required
#define PROPERTY_CHANGE_NAME     0x02  // the policy name for this node has been 
                                 // changed. This is used for renaming of policy

// clipboard format for NodeID
extern unsigned int CF_MMC_NodeID;

                                 
typedef 
struct _PROPERTY_CHANGE_NOTIFY_DATA_
{
   DWORD    dwPropertyChangeType;   // what kind of property change?
   void*    pNode;            // the property for which node?
   DWORD    dwParam;          // extra data?
   CComBSTR bstrNewName;      // new name that has been changed
                              // we need to pass this new name back
                              // Please note: this is property change
                              // was actually designed for name change notify
                              // and is solely used for this purpose
} PROPERTY_CHANGE_NOTIFY_DATA;

#define RAS_HELP_INDEX 1

#endif // _NAP_GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\enumcondition.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       enumcondition.cpp
//
//--------------------------------------------------------------------------

// EnumCondition.cpp: implementation of the CEnumCondition class.
//
//////////////////////////////////////////////////////////////////////

#include "precompiled.h"
#include "EnumCondition.h"
#include "EnumCondEdit.h"
#include "iasdebug.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CEnumCondition::CEnumCondition(IIASAttributeInfo*pCondAttr)
			   :CCondition(pCondAttr)
{
	TRACE_FUNCTION("CEnumCondition::CEnumCondition");
	// no parsing needed
	m_fParsed = TRUE;

//	m_pValueIdList	= pCondAttr->GetValueIdList();  
//	m_pValueList	= pCondAttr->GetValueList();
}


CEnumCondition::CEnumCondition(IIASAttributeInfo *pCondAttr, ATL::CString& strConditionText)
			   :CCondition(pCondAttr, strConditionText)
{
	TRACE_FUNCTION("CEnumCondition::CEnumCondition");
	// parsing needed
	m_fParsed = FALSE;

//	m_pValueIdList	= pCondAttr->GetValueIdList();  
//	m_pValueList	= pCondAttr->GetValueList();
}

CEnumCondition::~CEnumCondition()
{
	TRACE_FUNCTION("CEnumCondition::~CEnumCondition");

//	for (int iIndex=0; iIndex<m_arrSelectedList.GetSize(); iIndex++)
//	{
//		LPTSTR pszValue = m_arrSelectedList[iIndex];
//		if ( pszValue )
//		{
//			delete[] pszValue;
//		}
//	}
//	m_arrSelectedList.RemoveAll();
}

//+---------------------------------------------------------------------------
//
// Function:  Edit
//
// Class:	  CEnumCondition
// 
// Synopsis:  edit the enumerated-typed condition
//
// Arguments: None
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao	2/20/98 12:42:59 AM
//
//+---------------------------------------------------------------------------
HRESULT CEnumCondition::Edit()
{
	TRACE_FUNCTION("CEnumCondition::Edit");
	
	HRESULT hr = S_OK;

	if ( !m_fParsed )
	{
		DebugTrace(DEBUG_NAPMMC_ENUMCONDITION, "Parsing %ws", (LPCTSTR)m_strConditionText);
		hr = ParseConditionText();

		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_ENUMCONDITION, "Invalid condition text, err = %x", hr);
			ShowErrorDialog(NULL, 
						    IDS_ERROR_PARSE_CONDITION, 
							(LPTSTR)(LPCTSTR)m_strConditionText, 
							hr
						);
			return hr;
		}
	}

	CEnumConditionEditor *pEditor = new CEnumConditionEditor();
	if (!pEditor)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());

		ErrorTrace(ERROR_NAPMMC_ENUMCONDITION, "Can't create CEnumConditionEditor, err = %x", hr);
		ShowErrorDialog(NULL
						, IDS_ERROR_CANT_EDIT_CONDITION
						, NULL
						, hr
	  				   );
		return hr;
	}
	
    // 
    // set the editor parameter
    // 

	CComBSTR bstrName;
	hr = m_spAttributeInfo->get_AttributeName( &bstrName );
	pEditor->m_strAttrName = bstrName;

	pEditor->m_spAttributeInfo = m_spAttributeInfo;

	pEditor->m_pSelectedList = &m_arrSelectedList; // preselected values

	if ( pEditor->DoModal() == IDOK)
	{
		// user clicked "OK"
		
		// get the list of valid value Ids for this attribute
		
//		_ASSERTE( m_pValueIdList->GetSize() == m_pValueList->GetSize() );

		//
		// generate the condition text
		//
		
		m_strConditionText = (ATL::CString) bstrName + L"=";


		CComQIPtr< IIASEnumerableAttributeInfo, &IID_IIASEnumerableAttributeInfo > spEnumerableAttributeInfo( m_spAttributeInfo );
		_ASSERTE( spEnumerableAttributeInfo );

		for (LONG iIndex=0; iIndex < m_arrSelectedList.size(); iIndex++ )
		{
			if ( iIndex > 0 ) m_strConditionText += L"|";  


			// get the Value Id (we use ID instead of value name in the condition text)
			LONG lSize;
			hr = spEnumerableAttributeInfo->get_CountEnumerateID( &lSize );
			_ASSERTE( SUCCEEDED( hr ) );

			for (LONG jIndex=0; jIndex < lSize; jIndex++)
			{
				CComBSTR bstrDescription;
				hr = spEnumerableAttributeInfo->get_EnumerateDescription( jIndex, &bstrDescription );
				_ASSERTE( SUCCEEDED( hr ) );
				
				if ( wcscmp( bstrDescription, m_arrSelectedList[iIndex]) == 0 ) 
				{
					WCHAR wz[32];


					LONG lID;
					hr = spEnumerableAttributeInfo->get_EnumerateID( jIndex, &lID );
					_ASSERTE( SUCCEEDED( hr ) );

					// add enclosing chars ^ and $
					wsprintf(wz, _T("^%ld$"), lID);
					m_strConditionText += wz; 
					break;
				}
			}
		}	
	}

	// clean up
	if ( pEditor )
	{
		delete pEditor;
	}
	return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CEnumCondition::GetDisplayText
//
// Synopsis:  Get the displayable text format for this condition,
//			  which should be like this:
//				
//					ServerType matches "type1|type2|type3" 
//			  
//			  compared to the condition text:
//				
//					ServerType = type1|,type2|,type3
//
// Arguments: None
//
// Returns:   ATL::CString& - the displayable text
//
// History:   Created Header    byao	2/22/98 11:41:28 PM
//
//+---------------------------------------------------------------------------
ATL::CString CEnumCondition::GetDisplayText()
{
	TRACE_FUNCTION("CEnumCondition::GetDisplayText");
	
	HRESULT hr = S_OK;

	if ( !m_fParsed)
	{
		DebugTrace(DEBUG_NAPMMC_ENUMCONDITION, "Parsing %ws", (LPCTSTR)m_strConditionText);
		hr = ParseConditionText();

		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_ENUMCONDITION, "Invalid condition text, err = %x", hr);
			ShowErrorDialog(NULL,
							IDS_ERROR_PARSE_CONDITION, 
							(LPTSTR)(LPCTSTR)m_strConditionText, 
							hr
						);
			return ATL::CString(L"");
		}
	}

	ATL::CString strDispText; 

	CComBSTR bstrName;
	hr = m_spAttributeInfo->get_AttributeName( &bstrName );
	_ASSERTE( SUCCEEDED( hr ) );

	strDispText = bstrName;

	{ ATL::CString	matches;
		matches.LoadString(IDS_TEXT_MATCHES);
		strDispText += matches;
	}
	
	strDispText += _T("\"");

	for (int iIndex=0; iIndex < m_arrSelectedList.size(); iIndex++ )
	{
		// add the separator between multiple values
		if (iIndex > 0) strDispText += _T(" OR ");

		strDispText += m_arrSelectedList[iIndex];
	}

	// the last " mark
	strDispText += _T("\"");
	return strDispText;
}

//+---------------------------------------------------------------------------
//
// Function:  CEnumCondition::ParseConditionText
//
// Synopsis:  Parse the condition text, to get the regular expression.
//
// Arguments: None
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao	2/22/98 11:58:38 PM
//
//+---------------------------------------------------------------------------
HRESULT CEnumCondition::ParseConditionText()
{
	TRACE_FUNCTION("CEnumCondition::ParseConditionText");
	
	_ASSERTE( !m_fParsed );
	
	HRESULT hr = E_FAIL;

	if (m_fParsed)
	{
		// do nothing
		return S_OK;
	}

	if ( m_strConditionText.GetLength() == 0 )
	{
		// no parsing needed
		m_fParsed = TRUE;

		DebugTrace(DEBUG_NAPMMC_ENUMCONDITION, "Null condition text");
		return S_OK;
	}


	try
	{

		//
		// using (LPCTSTR) cast will force a deep copy
		//
		ATL::CString strTempStr = (LPCTSTR)m_strConditionText;
		// 
		// parse strConditionText, return the regular expression only
		// 

		// first, make a local copy of the condition text
		WCHAR *pwzCondText = (WCHAR*)(LPCTSTR)strTempStr;

		// look for the '=' in the condition text
		WCHAR	*pwzStartPoint = NULL;
		WCHAR	*pwzSeparator = NULL;
		ATL::CString	*pStr;
		WCHAR	*pwzEqualSign = wcschr(pwzCondText, _T('='));
		DWORD	dwValueId;
		int		iIndex;

		// no '=' found -- something weird has happened
		if ( NULL == pwzEqualSign )
		{
			hr = E_OUTOFMEMORY;
			throw;
		}
		
		// the right side of the equal sign is the list of all preselected values
		pwzStartPoint = pwzEqualSign +1;


		CComQIPtr< IIASEnumerableAttributeInfo, &IID_IIASEnumerableAttributeInfo > spEnumerableAttributeInfo( m_spAttributeInfo );
		_ASSERTE( spEnumerableAttributeInfo );
		

		while (		pwzStartPoint 
				&&	*pwzStartPoint
				&&  (pwzSeparator = wcsstr(pwzStartPoint, _T("|") )) != NULL 
			  )
		{
			// we found the separator, stored at pwzSeparator
			
			// copy it over to the first value
			*pwzSeparator = _T('\0');  
			pStr = new ATL::CString;
			if ( NULL == pStr )
			{
				hr = E_UNEXPECTED;
				throw;
			}

			// string could be enclosed by ^ and $ for matching purpose
			// ^
			if(*pwzStartPoint == L'^')
			{
				pwzStartPoint++;
			}
			// $
			if (pwzSeparator > pwzStartPoint && *(pwzSeparator - 1) == L'$')
				*( pwzSeparator - 1 ) = _T('\0');

			*pStr = pwzStartPoint; // copy the string, which is the value ID in string format

			// now we get the valud name for this
			dwValueId = _wtol((*pStr));

			// valid value id, then search for the index of this value ID

			LONG lSize;
			hr = spEnumerableAttributeInfo->get_CountEnumerateID( &lSize );
			_ASSERTE( SUCCEEDED( hr ) );

			for (iIndex=0; iIndex < lSize; iIndex++ )
			{
				
				LONG lID;
				hr = spEnumerableAttributeInfo->get_EnumerateID( iIndex, &lID );
				_ASSERTE( SUCCEEDED( hr ) );

				if ( lID == dwValueId )
				{
					CComBSTR bstrDescription;
					hr = spEnumerableAttributeInfo->get_EnumerateDescription( iIndex, &bstrDescription );
					_ASSERTE( SUCCEEDED( hr ) );

					m_arrSelectedList.push_back(bstrDescription );
					break;
				}
			}

			pwzStartPoint = pwzSeparator+1;
		}
		
		// copy the last one
		
		// todo: this is redundant code. remove later.
		// now we get the valud name for this

		// string could be enclosed by ^ and $ for matching purpose
		// ^
		if(*pwzStartPoint == L'^')
		{
			pwzStartPoint++;
		}
		// $
		pwzSeparator = pwzStartPoint + wcslen(pwzStartPoint);
		if (pwzSeparator > pwzStartPoint && *(pwzSeparator - 1) == L'$')
			*( pwzSeparator - 1 ) = _T('\0');

		dwValueId = _wtol(pwzStartPoint);

		LONG lSize;
		hr = spEnumerableAttributeInfo->get_CountEnumerateID( &lSize );
		_ASSERTE( SUCCEEDED( hr ) );

		for (iIndex=0; iIndex < lSize; iIndex++ )
		{
			
			LONG lID;
			hr = spEnumerableAttributeInfo->get_EnumerateID( iIndex, &lID );
			_ASSERTE( SUCCEEDED( hr ) );

			if ( lID == dwValueId )
			{
				CComBSTR bstrDescription;
				hr = spEnumerableAttributeInfo->get_EnumerateDescription( iIndex, &bstrDescription );
				_ASSERTE( SUCCEEDED( hr ) );

				m_arrSelectedList.push_back(bstrDescription );
				break;
			}
		}

		m_fParsed = TRUE;
		
		hr = S_OK;

	}
	catch(...)
	{
		// Do GetLastError for HRESULT?
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\enumcondition.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       enumcondition.h
//
//--------------------------------------------------------------------------

// EnumCondition.h: interface for the CEnumCondition class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENUMCONDITION_H__9F917679_A693_11D1_BBEB_00C04FC31851__INCLUDED_)
#define AFX_ENUMCONDITION_H__9F917679_A693_11D1_BBEB_00C04FC31851__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "atltmp.h"

#include <vector>

#include "condition.h"

class CEnumCondition : public CCondition  
{
public:
	CEnumCondition( IIASAttributeInfo* pCondAttr, ATL::CString &strConditionText ); 
	CEnumCondition( IIASAttributeInfo* pCondAttr );
	virtual ~CEnumCondition();

	HRESULT Edit();
	virtual ATL::CString GetDisplayText();

protected:
	HRESULT ParseConditionText();	// parse the initial condition text

	BOOL m_fParsed;  // whether this condition text has been parsed 
				     // During initialization we need to parse the condition text
					 // to get the preselected values
	std::vector< CComBSTR >   m_arrSelectedList;  // preselected values

};

#endif // !defined(AFX_ENUMCONDITION_H__9F917679_A693_11D1_BBEB_00C04FC31851__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasattributeeditor.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASAttributeEditor.cpp

Abstract:

	Implementation file for the CIASAttributeEditor class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASAttributeEditor.h"
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CIASAttributeEditor::ShowEditor

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASAttributeEditor::ShowEditor( /*[in, out]*/ BSTR *pReserved )
{
	TRACE_FUNCTION("CIASAttributeEditor::ShowEditor");

	AFX_MANAGE_STATE(AfxGetStaticModuleState())


	return E_NOTIMPL;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASAttributeEditor::SetAttributeSchema

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASAttributeEditor::SetAttributeSchema(IIASAttributeInfo * pIASAttributeInfo)
{
	TRACE_FUNCTION("CIASAttributeEditor::SetAttributeSchema");

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pIASAttributeInfo )
	{
		return E_INVALIDARG;
	}

	m_spIASAttributeInfo = pIASAttributeInfo;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASAttributeEditor::SetAttributeValue

	Most of the time, before you can use an editor's functionality,
	you need to pass it a pointer to the value the editor's methods
	e.g. will modify.

	Note that this is not always the case, for example, to gather information
	about the attribute's vendor, you need not always specify a value.

	Pass a NULL pointer to SetAttributeValue to disassociate the
	editor from any value.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASAttributeEditor::SetAttributeValue(VARIANT * pValue)
{
	TRACE_FUNCTION("CIASAttributeEditor::SetAttributeValue");

	AFX_MANAGE_STATE(AfxGetStaticModuleState())


	// Check for preconditions.
	// None -- passing in a NULL pointer means we are "clearing" the
	// editor.
	ErrorTrace(0, "CIASAttributeEditor::SetAttributeValue pointer value %ld\n", pValue);

	m_pvarValue = pValue;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASAttributeEditor::get_ValueAsString

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASAttributeEditor::get_ValueAsString(BSTR * pbstrDisplayText )
{
	TRACE_FUNCTION("CIASAttributeEditor::get_ValueAsString");

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pbstrDisplayText )
	{
		return E_INVALIDARG;
	}

	CComBSTR bstrDisplay;

	// This method will be overriden.

	// We could do our best here to give back a default string,
	// but for now, just return an empty string.

	*pbstrDisplayText = bstrDisplay.Copy();

	return S_OK;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASAttributeEditor::put_ValueAsString

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASAttributeEditor::put_ValueAsString(BSTR newVal)
{
	TRACE_FUNCTION("CIASAttributeEditor::put_ValueAsString");

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// TODO: Add your implementation code here

	return E_NOTIMPL;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASAttributeEditor::get_VendorName

	For most attributes, vendor information is stored in the AttributeInfo.
	However, for some attributes, e.g. the RADIUS vendor specific 
	attribute (ID == 26), vendor information is stored in the value of the
	editor itself.
	
	For this reason, UI clients should always query an IASAttributeEditor for vendor 
	information rather than the AttributeInfo itself.

	In the default implementation here, we will query the AttributeInfo 
	for this information.  Some derived implementations of IASAttributeEditor
	(e.g. IASVendorSpecificAttributeEditor) will parse the value of the
	attribute itself to procide this info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASAttributeEditor::get_VendorName(BSTR * pVal)
{
	TRACE_FUNCTION("CIASAttributeEditor::get_VendorName");

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pVal )
	{
		return E_INVALIDARG;
	}
	if( ! m_spIASAttributeInfo )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}


	HRESULT hr;
	
	hr = m_spIASAttributeInfo->get_VendorName( pVal );
	
	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASAttributeEditor::put_VendorName

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASAttributeEditor::put_VendorName(BSTR newVal)
{
	TRACE_FUNCTION("CIASAttributeEditor::put_VendorName");

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	return E_NOTIMPL;

	// Check for preconditions.
//	if( ! m_spIASAttributeInfo )
//	{
//		// We are not initialized properly.
//		return OLE_E_BLANK;
//	}

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASAttributeEditor::Edit

We had a design change about the interface we want an editor to expose.

For now, this interface method just calls our old interface methods.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASAttributeEditor::Edit(IIASAttributeInfo * pIASAttributeInfo,  /*[in]*/ VARIANT *pAttributeValue, /*[in, out]*/ BSTR *pReserved )
{
	TRACE_FUNCTION("CIASAttributeEditor::Edit");

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr;

	hr = SetAttributeSchema( pIASAttributeInfo );
	if( FAILED( hr ) )
	{
		return hr;
	}
	
//	CComVariant varValue;
//
//	hr = pIASAttributeInfo->get_Value( &varValue );
	// We are ignoring return value here because if we can't get it, we'll just edit a new one.
//
//	hr = SetAttributeValue( &varValue );

	hr = SetAttributeValue( pAttributeValue );
	if( FAILED(hr ) )
	{
		return hr;
	}

	hr = ShowEditor( pReserved );
//	if( S_OK == hr )
//	{
//		hr = pIASAttributeInfo->put_Value( varValue );
//		if( FAILED(hr ) )
//		{
//			return hr;
//		}
//	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASAttributeEditor::GetDisplayInfo

We had a design change about the interface we want an editor to expose.

For now, this interface method just calls our old interface methods.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASAttributeEditor::GetDisplayInfo(IIASAttributeInfo * pIASAttributeInfo,  /*[in]*/ VARIANT *pAttributeValue, BSTR * pVendorName, BSTR * pValueAsString, /*[in, out]*/ BSTR *pReserved)
{
	TRACE_FUNCTION("CIASAttributeEditor::GetDisplayInfo");

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr;

	hr = SetAttributeSchema( pIASAttributeInfo );
	if( FAILED( hr ) )
	{
		return hr;
	}
	
	CComVariant varValue;

//	hr = pIASAttributeInfo->get_Value( &varValue );
//	if( FAILED(hr ) )
//	{
//		return hr;
//	}
//
//	hr = SetAttributeValue( &varValue );

	
	hr = SetAttributeValue( pAttributeValue );
	if( FAILED(hr ) )
	{
		return hr;
	}

	
	CComBSTR bstrVendorName;
	CComBSTR bstrValueAsString;

	hr = get_VendorName( &bstrVendorName );
	// Don't care if this failed -- we'll return empty string.

	hr = get_ValueAsString( &bstrValueAsString );
	// Don't care if this failed -- we'll return empty string.

	*pVendorName = bstrVendorName.Copy();
	*pValueAsString = bstrValueAsString.Copy();


	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasattributeinfo.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASAttributeInfo.h

Abstract:

	Declaration of the CAttributeInfo class.
	

	This class is the C++ implementation of the IIASAttributeInfo interface on
	the AttributeInfo COM object.


	See IASAttributeInfo.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_SCHEMA_ATTRIBUTE_H_)
#define _SCHEMA_ATTRIBUTE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "IASBaseAttributeInfo.h"
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CAttributeInfo
class ATL_NO_VTABLE CAttributeInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAttributeInfo, &CLSID_IASAttributeInfo>,
// Already in CBaseAttributeInfo:	public IDispatchImpl<IIASAttributeInfo, &IID_IIASAttributeInfo, &LIBID_NAPMMCLib>
	public CBaseAttributeInfo
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)

BEGIN_COM_MAP(CAttributeInfo)
	COM_INTERFACE_ENTRY(IIASAttributeInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//	STDMETHOD(get_Clone)(LPUNKNOWN * pVal);

};

#endif // _SCHEMA_ATTRIBUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasattributeinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASAttributeInfo.cpp 

Abstract:

	Implementation file for the CAttributeInfo class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASAttributeInfo.h"
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



// Nothing to it here -- just a compilation unit.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasattrlist.h ===
/****************************************************************************************
 * NAME:	CIASAttrList.h
 *
 * CLASS:	CIASAttrList
 *
 * OVERVIEW
 *
 * Internet Authentication Server: IAS Attribute list class
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				1/28/98		Created by	Byao	(using ATL wizard)
 *				3/19/98		Modified by Byao from CCondAttrList . The later ceased to exist
 *
 *****************************************************************************************/
#ifndef _IASATTRLIST_INCLUDE_
#define _IASATTRLIST_INCLUDE_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include <vector>

// 
// condition Attr collection - implemented using CSimpleArray
// 
class CIASAttrList  
{
public:
	CIASAttrList();
	virtual ~CIASAttrList();


	//
	// initialize the condition attribute list. Basically get all attributes
	// from the dictionary, and check whether they can be used in a condition
	//
	HRESULT Init(ISdoDictionaryOld *pIDictionary);
	IIASAttributeInfo* CreateAttribute(	ISdoDictionaryOld*	pIDictionary,
									ATTRIBUTEID		AttrId,
									LPTSTR			tszAttrName
								);

	int		Find(ATTRIBUTEID AttrId);
	DWORD	size() const;

	IIASAttributeInfo* operator[] (int nIndex) const;
	IIASAttributeInfo* GetAt(int nIndex) const;

	
public:
	std::vector< CComPtr<IIASAttributeInfo> > m_AttrList; // a list of all condition attributes

private:
	BOOL m_fInitialized;  // whether the list has been populated through SDO
};

#endif // ifndef _IASATTRLIST_INCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasbaseattributeinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASBaseAttributeInfo.cpp 

Abstract:

	Implementation file for the CBaseAttributeInfo class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASBaseAttributeInfo.h"
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_AttributeID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::get_AttributeID(ATTRIBUTEID * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	*pVal = m_AttributeID;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_AttributeID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::put_AttributeID(ATTRIBUTEID newVal)
{
	m_AttributeID = newVal;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_AttributeName

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::get_AttributeName(BSTR * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	*pVal = m_bstrAttributeName.Copy();

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_AttributeName

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::put_AttributeName(BSTR newVal)
{
	m_bstrAttributeName = newVal;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_AttributeSyntax

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::get_AttributeSyntax(ATTRIBUTESYNTAX * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	*pVal = m_AttributeSyntax;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_AttributeSyntax

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::put_AttributeSyntax(ATTRIBUTESYNTAX newVal)
{
	m_AttributeSyntax = newVal;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_AttributeRestriction

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::get_AttributeRestriction(long * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	*pVal = m_lAttributeRestriction;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_AttributeRestriction

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::put_AttributeRestriction(long newVal)
{
	m_lAttributeRestriction  = newVal;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_VendorID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::get_VendorID(long * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	*pVal = m_lVendorID;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_VendorID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::put_VendorID(long newVal)
{
	m_lVendorID = newVal;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_AttributeDescription

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::get_AttributeDescription(BSTR * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	*pVal = m_bstrAttributeDescription.Copy();

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_AttributeDescription

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::put_AttributeDescription(BSTR newVal)
{
	m_bstrAttributeDescription = newVal;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_VendorName

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::get_VendorName(BSTR * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	*pVal = m_bstrVendorName.Copy();

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_VendorName

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::put_VendorName(BSTR newVal)
{
	m_bstrVendorName = newVal;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_SyntaxString

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::get_SyntaxString(BSTR * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	*pVal = m_bstrSyntaxString.Copy();

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_SyntaxString

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::put_SyntaxString(BSTR newVal)
{
	m_bstrSyntaxString = newVal;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_EditorProgID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::get_EditorProgID(BSTR * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	*pVal = m_bstrEditorProgID.Copy();

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_EditorProgID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseAttributeInfo::put_EditorProgID(BSTR newVal)
{
	m_bstrEditorProgID = newVal;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::get_Value

--*/
//////////////////////////////////////////////////////////////////////////////
//STDMETHODIMP CBaseAttributeInfo::get_Value(VARIANT * pVal)
//{
//	HRESULT hr;
//
//	hr = VariantCopy( pVal, &m_varValue);
//
//	return hr;
//}



//////////////////////////////////////////////////////////////////////////////
/*++

CBaseAttributeInfo::put_Value
--*/
//////////////////////////////////////////////////////////////////////////////
//STDMETHODIMP CBaseAttributeInfo::put_Value(VARIANT newVal)
//{
//	m_varValue = newVal;
//
//	return S_OK;
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasattrlist.cpp ===
/****************************************************************************************
 * NAME: IASAttrList.cpp
 *
 * CLASS:   CIASAttrList
 *
 * OVERVIEW
 *
 * Internet Authentication Server: Condition type and collection definitions
 *
 *       CIASAttrList: a list of IIASAttributeInfo interface pointers
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History: 
 *          2/14/98     Created by  Byao  (using ATL wizard)
 *
 *****************************************************************************************/

#include "precompiled.h"
#include "IasAttrList.h"
#include "iasdebug.h"
#include "SafeArray.h"
#include "vendors.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CIASAttrList::CIASAttrList()
{
  TRACE_FUNCTION("CIASAttrList::CIASAttrList");
  m_fInitialized = FALSE;
}


CIASAttrList::~CIASAttrList()
{
   TRACE_FUNCTION("CIASAttrList::~CIASAttrList");
}


//+---------------------------------------------------------------------------
//
// Function:  CIASAttrList::CreateAttribute
//
// Synopsis:  Create and initialize an IIASAttributeInfo object
//
// Arguments: pIDictionary - Dictionary pointer
//            AttrId    - Attribute id
//         tszAttrName  - attribute name
//             
//
// Returns:   IIASAttributeInfo* -  a pointer to the newly created attribute object
//                      NULL if anything fails
//
// History:   Created Header    byao   3/20/98 11:16:07 AM
//
//+---------------------------------------------------------------------------
IIASAttributeInfo* CIASAttrList::CreateAttribute(  ISdoDictionaryOld*   pIDictionary,
                                    ATTRIBUTEID    AttrId,
                                    LPTSTR         tszAttrName
                                 )
{
   TRACE_FUNCTION("CIASAttrList::CreateAttribute");
   
   //
   // create a safearray to get the attribuet information
   //
   CSafeArray<DWORD, VT_I4>   InfoIds = Dim(4);

   InfoIds.Lock();
   InfoIds[0] = SYNTAX;
   InfoIds[1] = RESTRICTIONS;
   InfoIds[2] = VENDORID;
   InfoIds[3] = DESCRIPTION;
   InfoIds.Unlock();

   CComVariant vInfoIds, vInfoValues;

   SAFEARRAY         sa = (SAFEARRAY)InfoIds;
   V_VT(&vInfoIds)      = VT_ARRAY;
   V_ARRAY(&vInfoIds)   = &sa;

   // get the attribuet info
   HRESULT hr = S_OK;
   hr = pIDictionary->GetAttributeInfo(AttrId, &vInfoIds, &vInfoValues);
   if ( FAILED(hr) )
   {
      ErrorTrace(ERROR_NAPMMC_IASATTR,"GetAttributeInfo() failed, err = %x", hr);
      ShowErrorDialog(NULL
                  , IDS_ERROR_SDO_ERROR_GETATTRINFO
                  , NULL
                  , hr
                  );
      return NULL;
   }

   _ASSERTE(V_VT(&vInfoValues) == (VT_ARRAY|VT_VARIANT) );
   
   CSafeArray<CComVariant, VT_VARIANT> InfoValues = V_ARRAY(&vInfoValues);

   InfoValues.Lock();
   ATTRIBUTESYNTAX   asSyntax= (ATTRIBUTESYNTAX) V_I4(&InfoValues[0]);
   DWORD dwRestriction  = V_I4(&InfoValues[1]);
   DWORD dwVendorId     = V_I4(&InfoValues[2]);
   CComBSTR bstrDescription= V_BSTR(&InfoValues[3]);
   InfoValues.Unlock();

   //
   // check whether tszDESC could be NULL -- this happens when there's no 
   // description for this attribute.
   //
   if ( ! bstrDescription )
   {
      bstrDescription = L" ";
   }

   DebugTrace(DEBUG_NAPMMC_IASATTRLIST,
            "Attribute Infomation: %ws, Syntax=%x, Restrictions=%x, Vendor=%x, Desc=%ws", 
            (LPCTSTR)tszAttrName, 
            asSyntax, 
            dwRestriction,
            dwVendorId,
            bstrDescription 
         );


   // create the attribute ONLY if it can be in a profile or a condition
   const DWORD flags = ALLOWEDINCONDITION | ALLOWEDINPROFILE |
                       ALLOWEDINPROXYCONDITION | ALLOWEDINPROXYPROFILE;
   if (!( dwRestriction & flags ))
   {
      // don't create this attribute 'cause it's useless for us
      return NULL;
   }

   CComPtr<IIASAttributeInfo> spIASAttributeInfo;

   try 
   {
      HRESULT hr;

      // Decide which kind of AttributeInfo object we will need to pass attribute 
      // info around in -- enumerable attributes are a special case and need to 
      // support the IIASEnumerableAttributeInfo interface.
      if ( asSyntax == IAS_SYNTAX_ENUMERATOR )
      {
         hr = CoCreateInstance( CLSID_IASEnumerableAttributeInfo, NULL, CLSCTX_INPROC_SERVER, IID_IIASAttributeInfo, (LPVOID *) &spIASAttributeInfo );
      }
      else
      {
         hr = CoCreateInstance( CLSID_IASAttributeInfo, NULL, CLSCTX_INPROC_SERVER, IID_IIASAttributeInfo, (LPVOID *) &spIASAttributeInfo );
      }
      if( FAILED(hr) ) return NULL;


      // Determine the prog ID for the editor which should be used to edit
      // this attribute.  Later, this will be specified in the 
      // dictionary, but for now, make a decision based on attribute
      // ID and/or syntax.
      CComBSTR bstrEditorProgID;
      if ( AttrId == RADIUS_ATTRIBUTE_VENDOR_SPECIFIC )
      {
         bstrEditorProgID = L"IAS.VendorSpecificAttributeEditor.1";
         // ISSUE: Change to version independent ProgID later.
         // For some reason "IAS.XXXAttributeEditor" (without the .1) is not working.
      }
      else
      {
         switch(asSyntax)
         {
         case IAS_SYNTAX_ENUMERATOR:
            {
               bstrEditorProgID = L"IAS.EnumerableAttributeEditor.1";
               // ISSUE: Change to version independent ProgID later.
               break;
            }
         case IAS_SYNTAX_INETADDR:
            {
               bstrEditorProgID = L"IAS.IPAttributeEditor.1";
               // ISSUE: Change to version independent ProgID later.
               break;
            }
         case IAS_SYNTAX_BOOLEAN:
            {
               bstrEditorProgID = L"IAS.BooleanAttributeEditor.1";
               // ISSUE: Change to version independent ProgID later.
               break;
            }
         default:
            {
               bstrEditorProgID = L"IAS.StringAttributeEditor.1";
               // ISSUE: Change to version independent ProgID later.
            }
         }
      }

      // Store the editor Prog ID in the attribute info object.
      hr = spIASAttributeInfo->put_EditorProgID( bstrEditorProgID );
      if( FAILED( hr ) ) throw hr;

      // Store the rest of the attribute information.
      hr = spIASAttributeInfo->put_AttributeID(AttrId);
      if( FAILED( hr ) ) throw hr;

      hr = spIASAttributeInfo->put_AttributeSyntax(asSyntax);
      if( FAILED( hr ) ) throw hr;

      hr = spIASAttributeInfo->put_AttributeRestriction(dwRestriction);
      if( FAILED( hr ) ) throw hr;

      hr = spIASAttributeInfo->put_VendorID(dwVendorId);
      if( FAILED( hr ) ) throw hr;

      hr = spIASAttributeInfo->put_AttributeDescription( bstrDescription );
      if( FAILED( hr ) ) throw hr;

      CComBSTR bstrName = tszAttrName;
      hr = spIASAttributeInfo->put_AttributeName( bstrName );
      if( FAILED( hr ) ) throw hr;

      // Now get the vendor name and store in the attribute.
      CComBSTR bstrVendorName;

      CComPtr<IIASNASVendors> spIASNASVendors;
      hr = CoCreateInstance( CLSID_IASNASVendors, NULL, CLSCTX_INPROC_SERVER, IID_IIASNASVendors, (LPVOID *) &spIASNASVendors );
      if( SUCCEEDED(hr) )
      {

         LONG lIndex;
         hr = spIASNASVendors->get_VendorIDToOrdinal(dwVendorId, &lIndex);
         if( S_OK == hr )
         {
            hr = spIASNASVendors->get_VendorName( lIndex, &bstrVendorName );
         }
         else
            hr = ::MakeVendorNameFromVendorID(dwVendorId, &bstrVendorName );
      }

      // Note: If any of the above calls to the Vendor object failed, 
      // we will keep going, using a NULL vendor name.
      hr = spIASAttributeInfo->put_VendorName( bstrVendorName );
      if( FAILED( hr ) ) throw hr;

      // Now store an string form describing the attribute syntax.
      CComBSTR bstrSyntax;

      // ISSUE: Should these all have been localized or are they some kind
      // of RADIUS RFC standard?  I think they should have been loaded from resources.

      switch(asSyntax)
      {
      case IAS_SYNTAX_BOOLEAN       : bstrSyntax = L"Boolean";    break;
      case IAS_SYNTAX_INTEGER       : bstrSyntax = L"Integer";    break;
      case IAS_SYNTAX_ENUMERATOR    : bstrSyntax = L"Enumerator"; break;
      case IAS_SYNTAX_INETADDR      : bstrSyntax = L"InetAddr";      break;
      case IAS_SYNTAX_STRING        : bstrSyntax = L"String";     break;
      case IAS_SYNTAX_OCTETSTRING   : bstrSyntax = L"OctetString";   break;
      case IAS_SYNTAX_UTCTIME       : bstrSyntax = L"UTCTime";    break;
      case IAS_SYNTAX_PROVIDERSPECIFIC : bstrSyntax = L"ProviderSpecific"; break;
      case IAS_SYNTAX_UNSIGNEDINTEGER  : bstrSyntax = L"UnsignedInteger"; break;
      default              : bstrSyntax = L"Unknown Type";  break;
      }

      hr = spIASAttributeInfo->put_SyntaxString( bstrSyntax );
      if( FAILED(hr) ) throw hr;
   }
   catch (...)
   {
      _ASSERTE( FALSE );
      ErrorTrace(ERROR_NAPMMC_IASATTRLIST, "Can't create the attribute ,err = %x", GetLastError());
      return NULL;
   }

   // clean up -- we don't need to clean up vInfoIds. It's deleted by ~CSafeArray()
// VariantClear(&vInfoValues);

   //
   // 3) get the value list for this attribute, if it's enumerator
   //
   if ( asSyntax == IAS_SYNTAX_ENUMERATOR )
   {
      // get the enumerable list for this attribute
      CComVariant varValueIds, varValueNames;

      hr = pIDictionary->EnumAttributeValues(AttrId,
                                    &varValueIds,
                                    &varValueNames);
      if ( SUCCEEDED(hr) )
      {
         _ASSERTE(V_VT(&varValueNames) == (VT_ARRAY|VT_VARIANT) );
         _ASSERTE(V_VT(&varValueIds) & (VT_ARRAY|VT_I4) );


         // Up above, if the attribute was enumerable, we created
         // an attribute info object which implements the IIASEnumerableAttributeInfo
         // interface.  We query for this interface now
         // and load all the enumerates from pAttr into that
         // interface of the shema attribute.
         CComQIPtr< IIASEnumerableAttributeInfo, &IID_IIASEnumerableAttributeInfo > spIASEnumerableAttributeInfo( spIASAttributeInfo );
         if( ! spIASEnumerableAttributeInfo ) return NULL;


         // Make sure that the list of enumerates in consistent.
         // There should be a 1-1 correspondence between ID's and description strings.

//ISSUE: todo _ASSERTE( lSize == pAttr->m_arrValueIdList.GetSize() );

         // get the safearray data
         CSafeArray<CComVariant, VT_VARIANT> ValueIds = V_ARRAY(&varValueIds);
         CSafeArray<CComVariant, VT_VARIANT> ValueNames  = V_ARRAY(&varValueNames);

         ValueIds.Lock();
         ValueNames.Lock();

         int iSize = ValueIds.Elements();
         for (int iValueIndex=0; iValueIndex < iSize; iValueIndex++)
         {
            // ISSUE: Make sure this deep copies the name.        
            CComBSTR bstrValueName = V_BSTR(&ValueNames[iValueIndex]);

            hr = spIASEnumerableAttributeInfo->AddEnumerateDescription( bstrValueName );
            if( FAILED( hr ) ) return NULL;

            VARIANT * pVar = &ValueIds[iValueIndex];

            long lID = V_I4( pVar );

            hr = spIASEnumerableAttributeInfo->AddEnumerateID( lID );
            if( FAILED( hr ) ) return NULL;
         
         }

         ValueIds.Unlock();
         ValueNames.Unlock();
      }
      else
      {
         // can't get the list. 
         //todo: need any action here?
         hr = S_OK;
      }
   }
   
   // Note: We have a bit of a RefCounting issue here.
   // As soon as we leave this function, desstructor for CComPtr
   // will be called, Release'ing the IIASAttributeInfo interface.
   // This will happen before the CComPtr on the other side has
   // had a chance to AddRef it.  
   // As a temporary hack, we AddRef here and release on the other side.
   spIASAttributeInfo->AddRef();
   return spIASAttributeInfo.p;
}


//+---------------------------------------------------------------------------
//
// Function:  Init
//
// Class:     CIASAttrList
//
// Synopsis:  Populate the condition attribute list. Do nothing
//         if the list is already populated
//
// Arguments: [in]ISdo *pIDictionarySdo: dictionary sdo 
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao 2/16/98 4:57:07 PM
//
//+---------------------------------------------------------------------------
HRESULT CIASAttrList::Init(ISdoDictionaryOld *pIDictionarySdo)
{
   TRACE_FUNCTION("CIASAttrList::Init");

   _ASSERTE( pIDictionarySdo != NULL );

   if (m_fInitialized)
   {
      //
      // the list has already been populated  -- do nothing
      //
      return S_OK;
   }

   // The push_back call below can throw an exception.
   try
   {

      //
      // Get all the attributes that can be used in a condition
      //
      int            iIndex;
      HRESULT        hr = S_OK;
      CComVariant    vNames;
      CComVariant    vIds;

      hr = pIDictionarySdo -> EnumAttributes(&vIds, &vNames);
      if ( FAILED(hr) ) 
      {
         ErrorTrace(ERROR_NAPMMC_IASATTRLIST, "EnumAttributes() failed, err = %x", hr);
         ShowErrorDialog(NULL
                     , IDS_ERROR_SDO_ERROR_ENUMATTR
                     , NULL
                     , hr
                     );
         return hr;  
      }

      _ASSERTE(V_VT(&vIds) == (VT_ARRAY|VT_I4) );
      _ASSERTE(V_VT(&vNames) == (VT_ARRAY|VT_VARIANT) );

      CSafeArray<DWORD, VT_I4>         AttrIds     = V_ARRAY(&vIds);
      CSafeArray<CComVariant, VT_VARIANT> AttrNames   = V_ARRAY(&vNames);

      AttrIds.Lock();
      AttrNames.Lock();

      for (iIndex = 0; iIndex < AttrIds.Elements(); iIndex++)
      {
         // create an attribute object
         DebugTrace(DEBUG_NAPMMC_IASATTRLIST, "Creating an attribute, name = %ws", V_BSTR(&AttrNames[iIndex]) ); 

         _ASSERTE( V_BSTR(&AttrNames[iIndex]) );
         CComPtr<IIASAttributeInfo> spAttributeInfo = CreateAttribute(pIDictionarySdo,
                                          (ATTRIBUTEID)AttrIds[iIndex], 
                                          V_BSTR(&AttrNames[iIndex]) 
                                        );


         if ( ! spAttributeInfo )
         {
            continue; // create the next attribute
         }

         // See note in CreateAttribute for why we Release here.
         spAttributeInfo->Release();

         m_AttrList.push_back(spAttributeInfo);
      }  // for 

      AttrIds.Unlock();
      AttrNames.Unlock();

      m_fInitialized = TRUE;
   }
   catch(...)
   {
      return E_FAIL;
   }
   return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  GetSize
//
// Class:     CIASAttrList
//
// Synopsis:  get the number of elements in the condition attribute list
//
// Arguments: None
//
// Returns:   DWORD - list length
//
// History:   Created Header    byao   2/16/98 8:11:17 PM
//
//+---------------------------------------------------------------------------
DWORD CIASAttrList::size() const
{
   if (!m_fInitialized)
   {
      ::MessageBox(NULL,L"populate the list first!", L"", MB_OK);
      return E_NOTIMPL;
   }
   else
   {
      return m_AttrList.size();
   }
}


//+---------------------------------------------------------------------------
//
// Function:  operator[] 
//
// Class:     CIASAttrList
//
// Synopsis:  get the condition attribute pointer at index [nIndex]
//
// Arguments: int nIndex - index
//
// Returns:   IIASAttributeInfo* : pointer to a condition attribute object
//
// History:   Created Header    byao   2/16/98 8:16:37 PM
//
//+---------------------------------------------------------------------------
IIASAttributeInfo* CIASAttrList:: operator[] (int nIndex) const
{
   if (!m_fInitialized)
   {
      ::MessageBox(NULL,L"populate the list first!", L"", MB_OK);
      return NULL;
   }
   else
   {
      _ASSERTE(nIndex >= 0 && nIndex < m_AttrList.size());
      return m_AttrList[nIndex].p;
   }
}


//+---------------------------------------------------------------------------
//
// Function:  GetAt()
//
// Class:     CIASAttrList
//
// Synopsis:  get the condition attribute pointer at nIndex
//
// Arguments: int nIndex - index
//
// Returns:   IIASAttributeInfo* : pointer to a condition attribute object
//
// History:   Created Header    byao   2/16/98 8:16:37 PM
//
//+---------------------------------------------------------------------------
IIASAttributeInfo* CIASAttrList:: GetAt(int nIndex) const
{
   TRACE_FUNCTION("CIASAttrList::GetAt");

   if (!m_fInitialized)
   {
      ErrorTrace(ERROR_NAPMMC_IASATTRLIST, "The list is NOT initialized!");
      return NULL;
   }
   else
   {
      _ASSERTE(nIndex >= 0 && nIndex < m_AttrList.size());
      return m_AttrList[nIndex].p;
   }
}


//+---------------------------------------------------------------------------
//
// Function:  CIASAttrList::Find
//
// Synopsis:  Find an attribute based on attribute ID
//
// Arguments: ATTRIBUTEID AttrId - attribute id
//
// Returns:   int - index in the list
//
// History:   Created Header    2/22/98 1:52:36 AM
//
//+---------------------------------------------------------------------------
int CIASAttrList::Find(ATTRIBUTEID AttrId)
{
   int iIndex;

   // The operator [] below can throw exceptions.
   try
   {
      for (iIndex=0; iIndex<m_AttrList.size(); iIndex++)
      {
         ATTRIBUTEID id;
         m_AttrList[iIndex]->get_AttributeID( &id );
         if( id == AttrId )
         {
            // found
            return iIndex;
         }
      }
   }
   catch(...)
   {
      // Just catch the exception -- we'll return -1 below.
   }

   // not found
   return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasattributeeditor.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASAttributeEditor.h

Abstract:

	Declaration of the CIASAttributeEditor class.


	This class is the base C++ implementation of IIASAttributeEditor interface 
	methods common all our Attribute Editor COM objects.

	
	See IASAttributeEditor.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_ATTRIBUTE_EDITOR_H_)
#define _ATTRIBUTE_EDITOR_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
// where we can find what this class has or uses:
//
#include "iasdebug.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CIASAttributeEditor
class ATL_NO_VTABLE CIASAttributeEditor : 
	public IDispatchImpl<IIASAttributeEditor, &IID_IIASAttributeEditor, &LIBID_NAPMMCLib>
{
public:
	CIASAttributeEditor()
	{
		m_pvarValue = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)


// IIASAttributeEditor
public:
	STDMETHOD(GetDisplayInfo)(/*[in]*/ IIASAttributeInfo *pIASAttributeInfo, /*[in]*/ VARIANT *pAttributeValue, /*[out]*/ BSTR *pVendorName, /*[out]*/ BSTR *pValueAsString, /*[in, out]*/ BSTR *pReserved);
	STDMETHOD(Edit)(/*[in]*/ IIASAttributeInfo *pIASAttributeInfo, /*[in]*/ VARIANT *pAttributeValue, /*[in, out]*/ BSTR *pReserved);

protected:	
	STDMETHOD(get_VendorName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_VendorName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ValueAsString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ValueAsString)(/*[in]*/ BSTR newVal);
	STDMETHOD(SetAttributeValue)(VARIANT *pValue);
	STDMETHOD(SetAttributeSchema)(IIASAttributeInfo *pIASAttributeInfo);
	STDMETHOD(ShowEditor)( /*[in, out]*/ BSTR *pReserved );


protected:
	CComPtr<IIASAttributeInfo> m_spIASAttributeInfo;
	VARIANT		*m_pvarValue;
};

#endif // _ATTRIBUTE_EDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasbaseattributeinfo.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASBaseAttributeInfo.h

Abstract:

	Declaration of the CBaseAttributeInfo class.


	This class is the base C++ implementation of IIASAttributeInfo interface 
	methods common all our AttributeInfo COM objects.

	
	See IASBaseAttributeInfo.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_BASE_SCHEMA_ATTRIBUTE_H_)
#define _BASE_SCHEMA_ATTRIBUTE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CAttributeInfo
class ATL_NO_VTABLE CBaseAttributeInfo : 
	public IDispatchImpl<IIASAttributeInfo, &IID_IIASAttributeInfo, &LIBID_NAPMMCLib>
{
public:
	CBaseAttributeInfo()
	{
		// Set some default values.
		m_lVendorID = 0;
		m_AttributeID = ATTRIBUTE_UNDEFINED;
		m_AttributeSyntax = IAS_SYNTAX_BOOLEAN;
		m_lAttributeRestriction =0;
	}


// IAttributeInfo
public:
	STDMETHOD(get_EditorProgID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_EditorProgID)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SyntaxString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SyntaxString)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_VendorName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_VendorName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_AttributeDescription)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_AttributeDescription)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_VendorID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_VendorID)(/*[in]*/ long newVal);
	STDMETHOD(get_AttributeRestriction)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_AttributeRestriction)(/*[in]*/ long newVal);
	STDMETHOD(get_AttributeSyntax)(/*[out, retval]*/ ATTRIBUTESYNTAX *pVal);
	STDMETHOD(put_AttributeSyntax)(/*[in]*/ ATTRIBUTESYNTAX newVal);
	STDMETHOD(get_AttributeName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_AttributeName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_AttributeID)(/*[out, retval]*/ ATTRIBUTEID *pVal);
	STDMETHOD(put_AttributeID)(/*[in]*/ ATTRIBUTEID newVal);
//	STDMETHOD(get_Value)(/*[out, retval]*/ VARIANT *pVal);
//	STDMETHOD(put_Value)(/*[in]*/ VARIANT newVal);


protected:
	CComBSTR m_bstrAttributeName;
	CComBSTR m_bstrAttributeDescription;
	CComBSTR m_bstrSyntaxString;
	CComBSTR m_bstrVendorName;
	CComBSTR m_bstrEditorProgID;
	long m_lVendorID;
	long m_lAttributeRestriction;
	ATTRIBUTEID m_AttributeID;
	ATTRIBUTESYNTAX m_AttributeSyntax;
//	CComVariant	m_varValue;

};

#endif // _BASE_SCHEMA_ATTRIBUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasbooleanattributeeditor.cpp ===
//////////////////////////////////////////////////////////////////////////////
// 
// Copyright (C) Microsoft Corporation
// 
// Module Name:
// 
//     IASBooleanAttributeEditor.cpp 
// 
// Abstract:
// 
//    Implementation file for the CIASBooleanAttributeEditor class.
// 
//////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "IASBooleanAttributeEditor.h"
#include "IASBooleanEditorPage.h"
#include "iashelper.h"

//////////////////////////////////////////////////////////////////////////////
// CIASBooleanAttributeEditor::CIASBooleanAttributeEditor
//////////////////////////////////////////////////////////////////////////////
CIASBooleanAttributeEditor::CIASBooleanAttributeEditor()
{
	int nLoadStringResult = LoadString(
                              _Module.GetResourceInstance(), 
                              IDS_BOOLEAN_TRUE, 
                              szTrue, 
                              IAS_MAX_STRING);
	_ASSERT( nLoadStringResult > 0 );

	nLoadStringResult = LoadString(
                              _Module.GetResourceInstance(), 
                              IDS_BOOLEAN_FALSE, 
                              szFalse, 
                              IAS_MAX_STRING);
	_ASSERT( nLoadStringResult > 0 );

}


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanAttributeEditor::ShowEditor
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASBooleanAttributeEditor::ShowEditor(
   /*[in, out]*/ BSTR *pReserved 
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())
      
   HRESULT hr = S_OK;
   try
   {
      // 
      // Boolean Editor
      // 
      CIASBooleanEditorPage   cBoolPage;
      
      // Initialize the page's data exchange fields with info 
      // from IAttributeInfo

      CComBSTR bstrName;
      CComBSTR bstrSyntax;
      ATTRIBUTESYNTAX asSyntax = IAS_SYNTAX_BOOLEAN;
      ATTRIBUTEID Id = ATTRIBUTE_UNDEFINED;

      if( m_spIASAttributeInfo )
      {
         hr = m_spIASAttributeInfo->get_AttributeName( &bstrName );
         if( FAILED(hr) ) throw hr;

         hr = m_spIASAttributeInfo->get_SyntaxString( &bstrSyntax );
         if( FAILED(hr) ) throw hr;

         hr = m_spIASAttributeInfo->get_AttributeSyntax( &asSyntax );
         if( FAILED(hr) ) throw hr;

         hr = m_spIASAttributeInfo->get_AttributeID( &Id );
         if( FAILED(hr) ) throw hr;
      }

      cBoolPage.m_strAttrName = bstrName;
      cBoolPage.m_strAttrFormat  = bstrSyntax;

      // Attribute type is actually attribute ID in string format 
      WCHAR szTempId[MAX_PATH];
      wsprintf(szTempId, _T("%ld"), Id);
      cBoolPage.m_strAttrType = szTempId;

      // Initialize the page's data exchange fields with info 
      // from VARIANT value passed in.

      if ( V_VT(m_pvarValue) == VT_EMPTY )
      {
         V_VT(m_pvarValue) = VT_BOOL;
         V_BOOL(m_pvarValue) = VARIANT_FALSE;
      }

      cBoolPage.m_bValue = (V_BOOL(m_pvarValue) == VARIANT_TRUE);

      int iResult = cBoolPage.DoModal();
      if (IDOK == iResult)
      {
         CComVariant varTemp;
         varTemp = cBoolPage.m_bValue;
         put_ValueAsVariant(varTemp);
      }
      else
      {
         hr = S_FALSE;
      }
   }
   catch( HRESULT & hr )
   {
      return hr;  
   }
   catch(...)
   {
      return hr = E_FAIL;

   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASBooleanAttributeEditor::SetAttributeValue

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASBooleanAttributeEditor::SetAttributeValue(VARIANT * pValue)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())

   // Check for preconditions.
   if( ! pValue )
   {
      return E_INVALIDARG;
   }

   m_pvarValue = pValue;
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanAttributeEditor::get_ValueAsString
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASBooleanAttributeEditor::get_ValueAsString(
   BSTR * pbstrDisplayText)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())

   // Check for preconditions.
   if( ! pbstrDisplayText )
   {
      return E_INVALIDARG;
   }
   if( ! m_spIASAttributeInfo || ! m_pvarValue )
   {
      // We are not initialized properly.
      return OLE_E_BLANK;
   }

   HRESULT hr = S_OK;
   
   try
   {
      CComBSTR bstrDisplay;

      VARTYPE vType = V_VT(m_pvarValue); 

      switch( vType )
      {
      case VT_BOOL:
      {
         if( V_BOOL(m_pvarValue) )
         {
            bstrDisplay = szTrue; //L"TRUE";
         }
         else
         {        
            bstrDisplay = szFalse; //L"FALSE";
         }
         break;
      }
      case VT_EMPTY:
         // do nothing -- we will fall through and return a blank string.
         break;

      default:
         // need to check what is happening here, 
         ASSERT(0);
         break;

      }

      *pbstrDisplayText = bstrDisplay.Copy();

   }
   catch( HRESULT &hr )
   {
      return hr;
   }
   catch(...)
   {
      return E_FAIL;
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanAttributeEditor::put_ValueAsVariant
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASBooleanAttributeEditor::put_ValueAsVariant(
   const CComVariant& newVal)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())

   if( ! m_pvarValue )
   {
      // We are not initialized properly.
      return OLE_E_BLANK;
   }
   if( m_spIASAttributeInfo == NULL )
   {
      // We are not initialized properly.
      return OLE_E_BLANK;
   }

   if( V_VT(&newVal) != VT_BOOL)
   {
      ASSERT(true);
   }

   V_VT(m_pvarValue) = VT_BOOL;
   V_BOOL(m_pvarValue) = V_BOOL(&newVal);
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanAttributeEditor::put_ValueAsString
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASBooleanAttributeEditor::put_ValueAsString(BSTR newVal)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState())

   if( ! m_pvarValue )
   {
      // We are not initialized properly.
      return OLE_E_BLANK;
   }
   if( m_spIASAttributeInfo == NULL )
   {
      // We are not initialized properly.
      return OLE_E_BLANK;
   }

   CComBSTR bstrTemp(newVal);

   V_VT(m_pvarValue) = VT_BOOL;
   if( wcsncmp(newVal, szTrue, wcslen(szTrue) ) == 0 )
   {
      V_BOOL(m_pvarValue) = VARIANT_TRUE;
   }
   else
   {
      V_BOOL(m_pvarValue) = VARIANT_FALSE;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasbooleanattributeeditor.h ===
//////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (C) Microsoft Corporation
// 
// Module Name:
// 
//     IASBooleanAttributeEditor.h
// 
// Abstract:
// 
//    Declaration of the CIASBooleanAttributeEditor class.
//    
//    This class is the C++ implementation of the IIASAttributeEditor interface on
//    the Boolean  Attribute Editor COM object.
// 
//    See IASBooleanAttributeEditor.cpp for implementation.
// 
//////////////////////////////////////////////////////////////////////////////

#if !defined(_BOOLEAN_ATTRIBUTE_EDITOR_H_)
#define _BOOLEAN_ATTRIBUTE_EDITOR_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "IASAttributeEditor.h"
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CIASBooleanAttributeEditor
class ATL_NO_VTABLE CIASBooleanAttributeEditor : 
   public CComObjectRootEx<CComSingleThreadModel>,
   public CComCoClass<CIASBooleanAttributeEditor, &CLSID_IASBooleanAttributeEditor>,
   public CIASAttributeEditor
{
public:
   CIASBooleanAttributeEditor();

DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)

BEGIN_COM_MAP(CIASBooleanAttributeEditor)
   COM_INTERFACE_ENTRY(IIASAttributeEditor)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIASAttributeEditor overrides
protected:
   STDMETHOD(SetAttributeValue)(VARIANT *pValue);
   STDMETHOD(ShowEditor)( /*[in, out]*/ BSTR *pReserved );
   STDMETHOD(get_ValueAsString)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(put_ValueAsString)(/*[in]*/ BSTR newVal);
   STDMETHOD(put_ValueAsVariant)(/*[in]*/ const CComVariant& newVal);

private:
   WCHAR szTrue[IAS_MAX_STRING];
   WCHAR szFalse[IAS_MAX_STRING];
};

#endif // _BOOLEAN_ATTRIBUTE_EDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasenumerableattributeinfo.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASEnumerableAttributeInfo.h

Abstract:

	Declaration of the CEnumerableAttributeInfo class.

	This class is the C++ implementation of the IIASEnumerableAttributeInfo interface on
	the EnumerableAttributeInfo COM object.

	
	See IASEnumerableAttributeInfo.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_ENUMERABLE_SCHEMA_ATTRIBUTE_H_)
#define _ENUMERABLE_SCHEMA_ATTRIBUTE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "IASBaseAttributeInfo.h"
//
// where we can find what this class has or uses:
//
#include <vector>
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CEnumerableAttributeInfo
class ATL_NO_VTABLE CEnumerableAttributeInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEnumerableAttributeInfo, &CLSID_IASEnumerableAttributeInfo>,
	public IDispatchImpl<IIASEnumerableAttributeInfo, &IID_IIASEnumerableAttributeInfo, &LIBID_NAPMMCLib>,
	public CBaseAttributeInfo
{
public:
	CEnumerableAttributeInfo()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)

DECLARE_CLASSFACTORY()

BEGIN_COM_MAP(CEnumerableAttributeInfo)
	COM_INTERFACE_ENTRY(IIASAttributeInfo)
	COM_INTERFACE_ENTRY(IIASEnumerableAttributeInfo)
	COM_INTERFACE_ENTRY2(IDispatch, IIASEnumerableAttributeInfo)
END_COM_MAP()

// IEnumerableAttributeInfo
public:
	STDMETHOD(get_CountEnumerateDescription)(/*[out, retval]*/ long *pVal);
	STDMETHOD(AddEnumerateDescription)( /*[in]*/ BSTR newVal);
	STDMETHOD(get_CountEnumerateID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_EnumerateDescription)(long index, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(AddEnumerateID)( /*[in]*/ long newVal);
	STDMETHOD(get_EnumerateID)(long index, /*[out, retval]*/ long *pVal);


// IIASAttributeInfo overide.
//	STDMETHOD(get_Clone)(LPUNKNOWN * pVal);


private:
	std::vector<long>		m_veclEnumerateID;
	std::vector<CComBSTR>	m_vecbstrEnumerateDescription;
};

#endif // _ENUMERABLE_SCHEMA_ATTRIBUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasenumerableattributeinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASEnumerableAttributeInfo.cpp 

Abstract:

	Implementation file for the CEnumerableAttributeInfo class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASEnumerableAttributeInfo.h"
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CEnumerableAttributeInfo::get_CountEnumerateID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEnumerableAttributeInfo::get_CountEnumerateID(long * pVal)
{

	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	try
	{
		*pVal = m_veclEnumerateID.size();
	}
	catch(...)
	{
		return E_FAIL;
	}

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CEnumerableAttributeInfo::get_EnumerateID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEnumerableAttributeInfo::get_EnumerateID(long index, long * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;

	try
	{
		*pVal = m_veclEnumerateID[index] ;
	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CEnumerableAttributeInfo::AddEnumerateID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEnumerableAttributeInfo::AddEnumerateID( long newVal)
{
	// Check for preconditions:
	// None.


	HRESULT hr = S_OK;

	try
	{
		m_veclEnumerateID.push_back( newVal );
	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CEnumerableAttributeInfo::get_CountEnumerateDescription

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEnumerableAttributeInfo::get_CountEnumerateDescription(long * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	try
	{
		*pVal = m_vecbstrEnumerateDescription.size();
	}
	catch(...)
	{
		return E_FAIL;
	}

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CEnumerableAttributeInfo::get_EnumerateDescription

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEnumerableAttributeInfo::get_EnumerateDescription(long index, BSTR * pVal)
{
	// Check for preconditions:
	if( pVal == NULL )
	{
		return E_INVALIDARG;
	}

	try
	{
		*pVal = m_vecbstrEnumerateDescription[index].Copy();
	}
	catch(...)
	{
		return E_FAIL;
	}

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CEnumerableAttributeInfo::AddEnumerateDescription

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CEnumerableAttributeInfo::AddEnumerateDescription( BSTR newVal)
{
	// Check for preconditions:
	// None.

	HRESULT hr = S_OK;

	try
	{

		m_vecbstrEnumerateDescription.push_back( newVal );
	
	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasbooleaneditorpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
// 
// Copyright (C) Microsoft Corporation
// 
// Module Name:
// 
//     IASBooleanEditorPage.cpp
// 
// Abstract:
// 
// 	Implementation file for the CIASBooleanEditorPage class.
// 
//////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "IASBooleanEditorPage.h"
#include "iashelper.h"
#include "dlgcshlp.h"

IMPLEMENT_DYNCREATE(CIASBooleanEditorPage, CHelpDialog)

BEGIN_MESSAGE_MAP(CIASBooleanEditorPage, CHelpDialog)
	//{{AFX_MSG_MAP(CIASBooleanEditorPage)
	ON_BN_CLICKED(IDC_RADIO_TRUE, OnRadioTrue)
	ON_BN_CLICKED(IDC_RADIO_FALSE, OnRadioFalse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanEditorPage::CIASBooleanEditorPage
//////////////////////////////////////////////////////////////////////////////
CIASBooleanEditorPage::CIASBooleanEditorPage() 
   :CHelpDialog(CIASBooleanEditorPage::IDD)
{
	TRACE(_T("CIASBooleanEditorPage::CIASBooleanEditorPage\n"));

	//{{AFX_DATA_INIT(CIASBooleanEditorPage)
	m_strAttrFormat = _T("");
	m_strAttrName = _T("");
	m_strAttrType = _T("");
   m_bValue = true;
	//}}AFX_DATA_INIT

	//
	// set the initializing flag -- we shouldn't call custom data verification
	// routine when initializing, because otherwise we will report an error
	// for an attribute whose value has never been initialized
   //
	m_fInitializing = TRUE;
}


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanEditorPage::OnRadioTrue
//////////////////////////////////////////////////////////////////////////////
void CIASBooleanEditorPage::OnRadioTrue() 
{
   m_bValue = true;
   return;
}


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanEditorPage::OnRadioFalse
//////////////////////////////////////////////////////////////////////////////
void CIASBooleanEditorPage::OnRadioFalse() 
{
   m_bValue = false;
   return;
}


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanEditorPage::~CIASBooleanEditorPage
////////////////////////////////////////////////////////////////////////////////
CIASBooleanEditorPage::~CIASBooleanEditorPage()
{
	TRACE(_T("CIASBooleanEditorPage::~CIASBooleanEditorPage\n"));
}


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanEditorPage::OnInitDialog
////////////////////////////////////////////////////////////////////////////////
BOOL CIASBooleanEditorPage::OnInitDialog()
{
	CHelpDialog::OnInitDialog();
   ::SendMessage(::GetDlgItem(m_hWnd,IDC_RADIO_TRUE), 
                 BM_SETCHECK, 
                 (m_bValue)? BST_CHECKED:BST_UNCHECKED , 0 );

   ::SendMessage(::GetDlgItem(m_hWnd,IDC_RADIO_FALSE), 
                 BM_SETCHECK, 
                 (m_bValue)? BST_UNCHECKED:BST_CHECKED , 0 );

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
// CIASBooleanEditorPage::DoDataExchange
//////////////////////////////////////////////////////////////////////////////
void CIASBooleanEditorPage::DoDataExchange(CDataExchange* pDX)
{
	TRACE(_T("CIASBooleanEditorPage::DoDataExchange\n"));

	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIASBooleanEditorPage)
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRFORMAT, m_strAttrFormat);
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRNAME, m_strAttrName);
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRTYPE, m_strAttrType);
	//}}AFX_DATA_MAP

	if (m_fInitializing)
	{
		//
		// set the initializing flag -- we shouldn't call custom data verification
		// routine when initializing, because otherwise we will report an error
		// for an attribute whose value has never been initialized
		//
		m_fInitializing = FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CIASBooleanEditorPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasbooleaneditorpage.h ===
//////////////////////////////////////////////////////////////////////////////
// 
// Copyright (C) Microsoft Corporation
// 
// Module Name:
// 
//     IASBooleanEditorPage.h
// 
// Abstract:
// 
// 	Declaration of the CIASBooleanEditorPage class.
// 
// 	This dialog allows the user to edit an attribute value consisting 
// 	of a generic string.
// 
// 	See IASStringEditorPage.cpp for implementation.
//////////////////////////////////////////////////////////////////////////////

#if !defined(_BOOLEAN_ATTRIBUTE_EDITOR_PAGE_H_)
#define _BOOLEAN_ATTRIBUTE_EDITOR_PAGE_H_

#include "iasbooleanattributeeditor.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CIASBooleanEditorPage dialog

class CIASBooleanEditorPage : public CHelpDialog
{
	DECLARE_DYNCREATE(CIASBooleanEditorPage)

// Construction
public:
	CIASBooleanEditorPage();
	~CIASBooleanEditorPage();

// Dialog Data
	//{{AFX_DATA(CIASBooleanEditorPage)
	enum { IDD = IDD_IAS_BOOLEAN_ATTR };
	::CString	m_strAttrFormat;
	::CString	m_strAttrName;
	::CString	m_strAttrType;
   bool        m_bValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIASBooleanEditorPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
	BOOL  m_fInitializing;

protected:
	// Generated message map functions
	//{{AFX_MSG(CIASBooleanEditorPage)
	afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnRadioTrue();
	afx_msg void OnRadioFalse();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _BOOLEAN_ATTRIBUTE_EDITOR_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasenumerableattributeeditor.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASEnumerableAttributeEditor.h

Abstract:

	Declaration of the CIASEnumerableAttributeEditor class.


	This class is the C++ implementation of the IIASAttributeEditor interface on
	the Enumerable Attribute Editor COM object.

	
	See IASEnumerableAttributeEditor.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_ENUMERABLE_ATTRIBUTE_EDITOR_H_)
#define _ENUMERABLE_ATTRIBUTE_EDITOR_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "IASAttributeEditor.h"
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CIASEnumerableAttributeEditor
class ATL_NO_VTABLE CIASEnumerableAttributeEditor : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIASEnumerableAttributeEditor, &CLSID_IASEnumerableAttributeEditor>,
	public CIASAttributeEditor
{
public:
	CIASEnumerableAttributeEditor()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)

BEGIN_COM_MAP(CIASEnumerableAttributeEditor)
	COM_INTERFACE_ENTRY(IIASAttributeEditor)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIASAttributeEditor overrides
protected:
	STDMETHOD(SetAttributeValue)(VARIANT *pValue);
	STDMETHOD(ShowEditor)( /*[in, out]*/ BSTR *pReserved );
	STDMETHOD(get_ValueAsString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ValueAsString)(/*[in]*/ BSTR newVal);
	STDMETHOD(SetAttributeSchema)(IIASAttributeInfo *pIASAttributeInfo);

private:
	long ConvertEnumerateDescriptionToOrdinal( BSTR bstrDescription );
	long ConvertEnumerateIDToOrdinal( long ID );
	CComPtr<IIASEnumerableAttributeInfo> m_spIASEnumerableAttributeInfo;

};

#endif // _ENUMERABLE_ATTRIBUTE_EDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasenumerableattributeeditor.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASEnumerableAttributeEditor.cpp 

Abstract:

	Implementation file for the CIASEnumerableAttributeEditor class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASEnumerableAttributeEditor.h"
//
// where we can find declarations needed in this file:
//
#include "IASEnumerableEditorPage.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CIASEnumerableAttributeEditor



//////////////////////////////////////////////////////////////////////////////
/*++

CIASEnumerableAttributeEditor::ShowEditor

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASEnumerableAttributeEditor::ShowEditor( /*[in, out]*/ BSTR *pReserved )
{
	TRACE(_T("CIASEnumerableAttributeEditor::ShowEditor\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())


	// Check for preconditions.
	if( m_spIASAttributeInfo == NULL )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}


	HRESULT hr = S_OK;


	try
	{
		
		// Load page title.
//		::CString			strPageTitle;
//		strPageTitle.LoadString(IDS_IAS_IP_EDITOR_TITLE);
//
//		CPropertySheet	propSheet( (LPCTSTR)strPageTitle );
		

		// 
		// IP Address Editor
		// 
		CIASPgEnumAttr	cppPage;
		

		// Initialize the page's data exchange fields with info from IAttributeInfo

		CComBSTR bstrName;
		CComBSTR bstrSyntax;
		ATTRIBUTEID Id = ATTRIBUTE_UNDEFINED;

		hr = m_spIASAttributeInfo->get_AttributeName( &bstrName );
		if( FAILED(hr) ) throw hr;

		hr = m_spIASAttributeInfo->get_SyntaxString( &bstrSyntax );
		if( FAILED(hr) ) throw hr;

		hr = m_spIASAttributeInfo->get_AttributeID( &Id );
		if( FAILED(hr) ) throw hr;
		
		
		cppPage.m_strAttrName	= bstrName;
		
		cppPage.m_strAttrFormat	= bstrSyntax;

		// Attribute type is actually attribute ID in string format 
		WCHAR	szTempId[MAX_PATH];
		wsprintf(szTempId, _T("%ld"), Id);
		cppPage.m_strAttrType	= szTempId;



		// Initialize the page's data exchange fields with info from VARIANT value passed in.
		CComBSTR bstrTemp;
		hr = get_ValueAsString( &bstrTemp );
		if( FAILED( hr ) ) throw hr;


		cppPage.m_strAttrValue = bstrTemp;
		cppPage.SetData( m_spIASAttributeInfo.p );



//		propSheet.AddPage(&cppPage);

//		int iResult = propSheet.DoModal();
		int iResult = cppPage.DoModal();
		if (IDOK == iResult)
		{
			CComBSTR bstrTemp = cppPage.m_strAttrValue;

			hr = put_ValueAsString( bstrTemp );
			if( FAILED( hr ) ) throw hr;

		}
		else
		{
			hr = S_FALSE;
		}

		//
		// delete the property page pointer
		//
//		propSheet.RemovePage(&cppPage);

	}
	catch( HRESULT & hr )
	{
		return hr;	
	}
	catch(...)
	{
		return hr = E_FAIL;

	}
	
	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASEnumerableAttributeEditor::SetAttributeValue

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASEnumerableAttributeEditor::SetAttributeValue(VARIANT * pValue)
{
	TRACE(_T("CIASEnumerableAttributeEditor::SetAttributeValue\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( pValue == NULL )
	{
		return E_INVALIDARG;
	}
	if( V_VT(pValue) !=  VT_I4 && V_VT(pValue) != VT_EMPTY )
	{
		return E_INVALIDARG;
	}
	
	
	m_pvarValue = pValue;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASEnumerableAttributeEditor::get_ValueAsString

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASEnumerableAttributeEditor::get_ValueAsString(BSTR * pbstrDisplayText )
{
	TRACE(_T("CIASEnumerableAttributeEditor::get_ValueAsString\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pbstrDisplayText )
	{
		return E_INVALIDARG;
	}
	if( m_spIASAttributeInfo == NULL || m_spIASEnumerableAttributeInfo == NULL )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}
	if( m_pvarValue == NULL )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}


	HRESULT hr = S_OK;

	try
	{
	
		CComBSTR bstrDisplay;

		if( V_VT(m_pvarValue) == VT_I4 )
		{

			long lCurrentSelection = 0;

			long lCurrentEnumerateID = V_I4(m_pvarValue);

			// Figure out the position of this ID in the list of possible ID's.
			lCurrentSelection = ConvertEnumerateIDToOrdinal( lCurrentEnumerateID );

			// Get the description string for the specified ID.
			hr = m_spIASEnumerableAttributeInfo->get_EnumerateDescription( lCurrentSelection, &bstrDisplay );
			if( FAILED( hr ) ) throw hr;

		}

		*pbstrDisplayText = bstrDisplay.Copy();
	
	}
	catch(...)
	{
		return E_FAIL;
	}


	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASEnumerableAttributeEditor::put_ValueAsString

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASEnumerableAttributeEditor::put_ValueAsString(BSTR newVal)
{
	TRACE(_T("CIASEnumerableAttributeEditor::put_ValueAsString\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! m_spIASAttributeInfo || ! m_spIASEnumerableAttributeInfo )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}


	HRESULT hr = S_OK;

	try
	{
	
		// Initialize the variant that was passed in.
		VariantClear(m_pvarValue);

		// Figure out the position in the enumeration of the user's choice.
		long lCurrentEnumerateID = 0;
		CComBSTR bstrTemp = newVal;
		long lCurrentSelection = ConvertEnumerateDescriptionToOrdinal( bstrTemp );
				
		// Convert the position to an ID.
		m_spIASEnumerableAttributeInfo->get_EnumerateID( lCurrentSelection, &lCurrentEnumerateID );

		// Save the ID that the user chose to the variant.
		V_VT(m_pvarValue) = VT_I4;
		V_I4(m_pvarValue) = lCurrentEnumerateID;

	}
	catch(...)
	{
		return E_FAIL;
	}


	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASEnumerableAttributeEditor::SetAttributeSchema

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASEnumerableAttributeEditor::SetAttributeSchema(IIASAttributeInfo * pIASAttributeInfo)
{
	TRACE(_T("CIASEnumerableAttributeEditor::SetAttributeSchema\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())


	HRESULT hr = S_OK;	
		
	hr = CIASAttributeEditor::SetAttributeSchema( pIASAttributeInfo );
	if( FAILED( hr ) ) return hr;

	// This particular type of attribute editor requires that the AttributeInfo it was passed 
	// implement a specific type of interface.  We query for this interface now.


	CComQIPtr< IIASEnumerableAttributeInfo, &IID_IIASEnumerableAttributeInfo> spIASEnumerableAttributeInfo( m_spIASAttributeInfo );
	if( spIASEnumerableAttributeInfo == NULL )
	{
		return E_NOINTERFACE;
	}

	// Save away the interface.
	m_spIASEnumerableAttributeInfo = spIASEnumerableAttributeInfo;


	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/*++

CIASEnumerableAttributeEditor::ConvertEnumerateIDToOrdinal

Figure out the position in the enumeration of the specified ID.

--*/
//////////////////////////////////////////////////////////////////////////////
long CIASEnumerableAttributeEditor::ConvertEnumerateIDToOrdinal( long ID )
{
	TRACE(_T("CIASEnumerableAttributeEditor::ConvertEnumerateIDToOrdinal\n"));

	// Check for preconditions:
	_ASSERTE( m_spIASEnumerableAttributeInfo != NULL );



	HRESULT hr;
	
	long lCountEnumeration;
	
	hr = m_spIASEnumerableAttributeInfo->get_CountEnumerateID( & lCountEnumeration );
	if( FAILED( hr ) ) throw hr;


	for (long lIndex=0; lIndex < lCountEnumeration; lIndex++)
	{
		long lTemp;
		
		hr = m_spIASEnumerableAttributeInfo->get_EnumerateID( lIndex, &lTemp );
		if( FAILED( hr ) ) throw hr;
	
		if ( ID == lTemp )
		{
			return( lIndex );
		}

	}
	
	// If we got here, we couldn't find it.
	throw E_FAIL;
	return 0;

}




/////////////////////////////////////////////////////////////////////////////
/*++

CIASEnumerableAttributeEditor::ConvertEnumerateIDToOrdinal

Figure out the position in the enumeration of the specified description string.

--*/
//////////////////////////////////////////////////////////////////////////////
long CIASEnumerableAttributeEditor::ConvertEnumerateDescriptionToOrdinal( BSTR bstrDescription )
{
	TRACE(_T("CIASEnumerableAttributeEditor::ConvertEnumerateDescriptionToOrdinal\n"));


	// Check for preconditions:
	_ASSERTE( m_spIASEnumerableAttributeInfo != NULL );

	long lCountEnumeration;

	HRESULT hr = S_OK;

	hr = m_spIASEnumerableAttributeInfo->get_CountEnumerateDescription( & lCountEnumeration );
	if( FAILED( hr ) ) throw hr;


	for (long lIndex=0; lIndex < lCountEnumeration; lIndex++)
	{
		CComBSTR bstrTemp;
		
		hr = m_spIASEnumerableAttributeInfo->get_EnumerateDescription( lIndex, &bstrTemp );
		if( FAILED( hr ) ) throw hr;
	
		if ( wcscmp( bstrTemp , bstrDescription ) == 0 )
		{
			return( lIndex );
		}

	}

	// If we got here, we couldn't find it.
	throw E_FAIL;
	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasenumerableeditorpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASEnumerableEditorPage.cpp

Abstract:

	Implementation file for the CIASPgEnumAttr class.

Revision History:
	mmaguire 06/25/98	- revised Baogang Yao's original implementation

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASEnumerableEditorPage.h"
//
// where we can find declarations needed in this file:
//
#include "IASHelper.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CIASPgEnumAttr property page



IMPLEMENT_DYNCREATE(CIASPgEnumAttr, CHelpDialog)



BEGIN_MESSAGE_MAP(CIASPgEnumAttr, CHelpDialog)
	//{{AFX_MSG_MAP(CIASPgEnumAttr)
//	ON_WM_CONTEXTMENU()
//	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgEnumAttr::CIASPgEnumAttr

  Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CIASPgEnumAttr::CIASPgEnumAttr() : CHelpDialog(CIASPgEnumAttr::IDD)
{
	TRACE_FUNCTION("CIASPgEnumAttr::CIASPgEnumAttr\n");

	//{{AFX_DATA_INIT(CIASPgEnumAttr)
	m_strAttrFormat = _T("");
	m_strAttrName = _T("");
	m_strAttrType = _T("");
	m_strAttrValue = _T("");
	//}}AFX_DATA_INIT
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgEnumAttr::~CIASPgEnumAttr

--*/
//////////////////////////////////////////////////////////////////////////////
CIASPgEnumAttr::~CIASPgEnumAttr()
{
	TRACE_FUNCTION("CIASPgEnumAttr::~CIASPgEnumAttr\n");
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgEnumAttr::DoDataExchange

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASPgEnumAttr::DoDataExchange(CDataExchange* pDX)
{
	TRACE_FUNCTION("CIASPgEnumAttr::DoDataExchange\n");

	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIASPgEnumAttr)
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRFORMAT, m_strAttrFormat);
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRNAME, m_strAttrName);
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRTYPE, m_strAttrType);
	DDX_CBString(pDX, IDC_IAS_COMBO_ENUM_VALUES, m_strAttrValue);
	//}}AFX_DATA_MAP
}






/////////////////////////////////////////////////////////////////////////////
// CIASPgEnumAttr message handlers


//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgEnumAttr::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CIASPgEnumAttr::OnInitDialog()
{
	TRACE_FUNCTION("CIASPgEnumAttr::OnInitDialog");

	CHelpDialog::OnInitDialog();

	// Check for preconditions:
	_ASSERTE( m_spIASAttributeInfo != NULL );
	
	
	HRESULT hr;
	
    //
    // initialize the combo box
    //
	CComboBox *pcbValuesBox = (CComboBox *) GetDlgItem (IDC_IAS_COMBO_ENUM_VALUES);
	_ASSERTE( pcbValuesBox != NULL );


	CComQIPtr< IIASEnumerableAttributeInfo, &IID_IIASEnumerableAttributeInfo> spIASEnumerableAttributeInfo( m_spIASAttributeInfo );
	if( spIASEnumerableAttributeInfo == NULL )
	{
		ErrorTrace(ERROR_NAPMMC_IASATTR, "Cannot populate the combo box -- schema attribute was not enumerable.");
		throw E_NOINTERFACE;
	}

	
	long lCountEnumeration;
	
	hr = spIASEnumerableAttributeInfo->get_CountEnumerateDescription( & lCountEnumeration );
	if( FAILED( hr ) ) throw hr;


	for (long lIndex=0; lIndex < lCountEnumeration; lIndex++)
	{
		CComBSTR bstrTemp;
		
		hr = spIASEnumerableAttributeInfo->get_EnumerateDescription( lIndex, &bstrTemp );
		if( FAILED( hr ) ) throw hr;
	
		pcbValuesBox->AddString( bstrTemp );

	}

	// look for the value in the selection list, so we can pre-set the cur-sel item
	pcbValuesBox->SetCurSel(0);
	pcbValuesBox->SelectString(0, m_strAttrValue);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgEnumAttr::SetData

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CIASPgEnumAttr::SetData( IIASAttributeInfo *pIASAttributeInfo )
{
	TRACE_FUNCTION("CIASPgEnumAttr::SetData\n");


	// Check for preconditions:
	_ASSERTE( pIASAttributeInfo != NULL );
	

	HRESULT hr = S_OK;

	// Store off some pointers.
	m_spIASAttributeInfo = pIASAttributeInfo;


	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iashelper.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	helper.h
		This file defines the following macros helper classes and functions:

		IASGetSdoInterfaceProperty()

    FILE HISTORY:

		2/18/98			byao		Created
        
*/

#ifndef _IASHELPER_
#define _IASHELPER_

// According to ToddP on 5/20, maximum length for ANY attribute value is 253
#define MAX_ATTRIBUTE_VALUE_LEN		253

// SDO helper functions
extern HRESULT IASGetSdoInterfaceProperty(ISdo *pISdo, 
								LONG lPropID, 
								REFIID riid, 
								void ** ppvInterface);

LPTSTR GetValidVSAHexString(LPCTSTR tszStr);

HRESULT	GetVendorSpecificInfo(::CString&	strValue, 
							  DWORD&	dVendorId, 
							  BOOL&		fNonRFC,
							  DWORD&	dFormat, 
							  DWORD&	dType, 
							  ::CString&	strDispValue);

HRESULT	SetVendorSpecificInfo(::CString&	strValue, 
							  DWORD&	dVendorId, 
							  BOOL&		fNonRFC,
							  DWORD&	dFormat, 
							  DWORD&	dType, 
							  ::CString&	strDispValue);

void	DDV_BoolStr(CDataExchange* pDX, ::CString& strText);
void	DDV_IntegerStr(CDataExchange* pDX, ::CString& strText);
void	DDV_Unsigned_IntegerStr(CDataExchange* pDX, ::CString& strText);
void	DDV_VSA_HexString(CDataExchange* pDX, ::CString& strText);

size_t		BinaryToHexString(char* pData, size_t cch, TCHAR* pStr, size_t ctLen);
size_t		HexStringToBinary(TCHAR* pStr, char* pData, size_t cch);

#endif // _IASHELPER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iashelper.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1998 - 1999 **/
/**********************************************************************/

/*
	IASHelper.cpp
		Implementation of the following helper classes:
		
		

		And global functions:
		GetSdoInterfaceProperty - Get an interface property from a SDO 
								  through its ISdo interface
			
    FILE HISTORY:
		
		2/18/98			byao		Created
        
*/

#include "Precompiled.h"
#include <limits.h>
#include <winsock2.h>
#include "IASHelper.h"

//+---------------------------------------------------------------------------
//
// Function:  IASGetSdoInterfaceProperty
//
// Synopsis:  Get an interface property from a SDO through its ISdo interface
//
// Arguments: ISdo *pISdo - Pointer to ISdo
//            LONG lPropId - property id
//            REFIID riid - ref iid
//            void ** ppvObject - pointer to the requested interface property
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao	2/12/98 11:12:55 PM
//
//+---------------------------------------------------------------------------
HRESULT IASGetSdoInterfaceProperty(ISdo *pISdo, 
								LONG lPropID, 
								REFIID riid, 
								void ** ppvInterface)
{
	TRACE(_T("::IASGetSdoInterfaceProperty()\n"));
	
	CComVariant var;
	HRESULT hr;

	V_VT(&var) = VT_DISPATCH;
	V_DISPATCH(&var) = NULL;
	hr = pISdo->GetProperty(lPropID, &var);

	//ReportError(hr, IDS_IAS_ERR_SDOERROR_GETPROPERTY, NULL);
	_ASSERTE( V_VT(&var) == VT_DISPATCH );

    // query the dispatch pointer for interface
	hr = V_DISPATCH(&var) -> QueryInterface( riid, ppvInterface);
	//ReportError(hr, IDS_IAS_ERR_SDOERROR_QUERYINTERFACE, NULL);
	
	return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  Hex2DWord
//
// Synopsis:  hexadecimal string to dword value
//
// Arguments: TCHAR* tszStr - number in hexadecimal string format "FF"
//
// Returns:   DWORD - value
//
// History:   Created Header    byao	3/6/98 2:46:49 AM
//
//+---------------------------------------------------------------------------
DWORD Hex2DWord(TCHAR* tszStr)
{
	TRACE(_T("::Hex2DWord()\n"));
	
	DWORD dwTemp = 0;
	DWORD dwDigit = 0; 
	DWORD dwIndex = 0;

	for (dwIndex=0; dwIndex<_tcslen(tszStr); dwIndex++)
	{
		// get the current digit
		if ( tszStr[dwIndex]>= _T('0') && tszStr[dwIndex]<= _T('9') )
			dwDigit = tszStr[dwIndex] - _T('0');
		else if ( tszStr[dwIndex]>= _T('A') && tszStr[dwIndex]<= _T('F') )
			dwDigit = tszStr[dwIndex] - _T('A') + 10;
		else if ( tszStr[dwIndex]>= _T('a') && tszStr[dwIndex]<= _T('f') )
			dwDigit = tszStr[dwIndex] - _T('a') + 10;

		// accumulate the value
		dwTemp = dwTemp*16 + dwDigit;
	}

	return dwTemp;
}

//todo: where should we put these constants?

#define L_INT_SIZE_BYTES  4  // from BaseCamp

// position 0--1: value format
#define I_VENDOR_ID_POS			2	// vendor ID starts from position 2;
#define I_ATTRIBUTE_TYPE_POS	10	// either the vendor attribute type(RFC), 
									// or raw value (for NONRFC value)


//+---------------------------------------------------------------------------
//
// Function:  GetVendorSpecificInfo
//
// Synopsis:  Get the information for vendor-specific attribute type
//
// Arguments: [in]::CString& strValue		- OctetString value
//            [out]int& dVendorId		- Vendor ID
//            [out]fNonRFC				-	random/Radius RFC compatible
//            [out]dFormat				- value format: string, integer, etc.
//            [out]int&dType			-  data type
//            [out]::CString&strDispValue	- data displayable value
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao 2/28/98 12:12:11 AM
//
//+---------------------------------------------------------------------------
HRESULT	GetVendorSpecificInfo(::CString& strValue, 
							  DWORD&	dVendorId, 
							  BOOL&		fNonRFC,
							  DWORD&	dFormat, 
							  DWORD&	dType, 
							  ::CString&	strDispValue)
{
	TRACE(_T("::GetVendorSpecificInfo()\n"));
	
	::CString strVSAType;
	::CString strVSALen;
	::CString strVSAValue;
	::CString strVendorId;
	::CString strPrefix;
	TCHAR	tszTempStr[256];
	DWORD	dwIndex;


	if ( strValue.GetLength() < I_ATTRIBUTE_TYPE_POS)
	{
		// invalid attribute value;
		strDispValue = strValue;
		fNonRFC = TRUE;
		return E_FAIL;
	}

	strDispValue.Empty();

	// is it a RADIUS RFC compatible value?
	_tcsncpy(tszTempStr, strValue, 2);
	tszTempStr[2] = _T('\0');

	switch( _ttoi(tszTempStr) )
	{
	case 0:  fNonRFC = TRUE;  dFormat = 0; dType = 0;
			 break;
	case 1:  fNonRFC = FALSE; dFormat = 0;   // string
			 break;
	case 2:  fNonRFC = FALSE; dFormat = 1;   // integer
			 break;
	case 4:	// ipaddress
			fNonRFC = FALSE; dFormat = 3;   // hexadecimal
			 break;
	case 3:  
	default: fNonRFC = FALSE; dFormat = 2;   // hexadecimal
			 break;
	}

	// Vendor ID
	for (dwIndex=0; dwIndex<8; dwIndex++)
	{	
		tszTempStr[dwIndex] = ((LPCTSTR)strValue)[I_VENDOR_ID_POS+dwIndex];
	}
	tszTempStr[dwIndex] = _T('\0');
	dVendorId = Hex2DWord(tszTempStr);

	// non RFC data? 
	if ( fNonRFC )
	{
		_tcscpy(tszTempStr, (LPCTSTR)strValue + I_ATTRIBUTE_TYPE_POS);
		strDispValue = tszTempStr;
	}
	else
	{
		// Radius RFC format
				
		// find the attribute type
		tszTempStr[0] = ((LPCTSTR)strValue)[I_ATTRIBUTE_TYPE_POS];
		tszTempStr[1] = ((LPCTSTR)strValue)[I_ATTRIBUTE_TYPE_POS+1];
		tszTempStr[2] = _T('\0');
		dType = Hex2DWord(tszTempStr);

		TCHAR*  tszPrefixStart;
		// find the attribute value
		switch(dFormat)
		{
		case 0:  // string
				{
					DWORD   jIndex;
					TCHAR	tszTempChar[3];
					TCHAR	tszTemp[2];
										
					_tcscpy(tszTempStr, (LPCTSTR)strValue+I_ATTRIBUTE_TYPE_POS+4);
					strDispValue = tszTempStr;

					/*
					jIndex = 0;
					while ( jIndex < _tcslen(tszTempStr)-1 )
					{
						tszTempChar[0] = tszTempStr[jIndex];
						tszTempChar[1] = tszTempStr[jIndex+1];
						tszTempChar[2] = _T('\0');
						
						tszTemp[0] = (TCHAR) Hex2DWord(tszTempChar);
						tszTemp[1] = _T('\0');

						strDispValue += tszTemp;
						jIndex += 2;
					}
					*/
				}
				break;

		case 1:	 // decimal or hexadecimal
				 tszPrefixStart = _tcsstr(strValue, _T("0x"));
				 if (tszPrefixStart == NULL)
				 {
					 tszPrefixStart = _tcsstr(strValue, _T("0X"));
				 }

				 if (tszPrefixStart)
				 {
					 // hexadecimal
					 _tcscpy(tszTempStr, tszPrefixStart);
					strDispValue = tszTempStr;
				 }
				 else
				 {
					 // decimal
					 _tcscpy(tszTempStr, (LPCTSTR)strValue+I_ATTRIBUTE_TYPE_POS+4);
					DWORD dwValue = Hex2DWord(tszTempStr);
					wsprintf(tszTempStr, _T("%u"), dwValue);
					strDispValue = tszTempStr;
				 }	
				 break;

		case 3:	// ip address
				{
					 // like decimal
					 _tcscpy(tszTempStr, (LPCTSTR)strValue+I_ATTRIBUTE_TYPE_POS+4);
					 if(_tcslen(tszTempStr) != 0)
					 {
						DWORD dwValue = Hex2DWord(tszTempStr);
						in_addr ipaddr;
						ipaddr.s_addr = ntohl(dwValue);
						strDispValue = inet_ntoa(ipaddr);
					 }
					 else
						 strDispValue = _T("");
				}
				break;

		case 2:  // hexadecimal
				 _tcscpy(tszTempStr, (LPCTSTR)strValue+I_ATTRIBUTE_TYPE_POS+4);
				 strDispValue = tszTempStr;
				 break;
		}
	}

	return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  SetVendorSpecificInfo
//
// Synopsis:  Set the information for vendor-specific attribute type
//
// Arguments: [out]::CString& strValue	- OctetString value
//            [in]int& dVendorId		- Vendor ID
//            [in]fNonRFC				-	random or RADIUS RFC compatible	
//            [in]dFormat				- attribute format: string, integer; hexadecimal
//            [in]int&  dType			-  attribute type
//            [in]::CString& strDispValue - data displayable value
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao 2/28/98 12:12:11 AM
//
//+---------------------------------------------------------------------------
HRESULT	SetVendorSpecificInfo(::CString&	strValue, 
							  DWORD&	dVendorId, 
							  BOOL&		fNonRFC,
							  DWORD&	dFormat, 
							  DWORD&	dType, 
							  ::CString&	strDispValue)
{
	TRACE(_T("::SetVendorSpecificInfo()\n"));
	USES_CONVERSION;
	
	::CString strVSAType;
	::CString strVSALen;
	::CString strVSAValue;
	::CString strVendorId;
	::CString strPrefix;
	TCHAR	tszTempStr[256];
	DWORD	dwIndex;
	
	wsprintf(tszTempStr, _T("%08X"), dVendorId);
	_tcsupr(tszTempStr);
	strValue = tszTempStr; // vendor ID first

	if ( !fNonRFC )
	{
		// RFC compatible format

		// prefix determined by type
		
		// 1. VendorType -- an integer between 1-255
		wsprintf(tszTempStr, _T("%02X"), dType);
		strVSAType = tszTempStr;

		// 2. Vendor Format: string, raw or hexadecimal
		switch (dFormat)
		{
		case 0:  // string
				 wsprintf(tszTempStr, _T("%02X"), _tcslen(strDispValue)+2);
				 strVSALen = tszTempStr;

				 /*  removed per discussion with MKarki on 5/21/98. 
				     String will be saved in original format
				 for (dwIndex=0; dwIndex<_tcslen(strDispValue); dwIndex++)
				 {
					 wsprintf(tszTempStr, _T("%02X"), ((LPCTSTR)strDispValue)[dwIndex]);
					 strVSAValue += tszTempStr;
				 }
				 */

				 strVSAValue = strDispValue;
				 strPrefix = _T("01");

				 break;				 

		case 3:  // IP address : added F; 211265
				// the display string is in a.b.c.d format, we need to save it as decimal format
				//
				{
								// ip adress control
					unsigned long IpAddr = inet_addr(T2A(strDispValue));	
					IpAddr = htonl(IpAddr);

					strPrefix = _T("04");
					wsprintf(tszTempStr, _T("%08lX"), IpAddr);
					strVSAValue = tszTempStr;

					 // length
					 wsprintf(tszTempStr, _T("%02X"), L_INT_SIZE_BYTES + 2);
					 strVSALen = tszTempStr;
				}

				break;
		case 1:  // raw -- decimal or hexadecimal (0x... format)
				 if (_tcsstr(strDispValue, _T("0x")) != NULL  ||
					 _tcsstr(strDispValue, _T("0X")) != NULL)
				 {
					 // hexadecimal
					 strVSAValue = strDispValue;
				 }
				 else
				 { 

					//todo: hexLarge???
					wsprintf(tszTempStr, _T("%08lX"), _ttol(strDispValue));
					strVSAValue = tszTempStr;
				 }
				
				 // length
				 wsprintf(tszTempStr, _T("%02X"), L_INT_SIZE_BYTES + 2);
				 strVSALen = tszTempStr;

				 strPrefix = _T("02");
				 
				 break;

		case 2:  // hexadecimal format
				 wsprintf(tszTempStr, _T("%02X"), _tcslen(strDispValue)/2+2);
				 strVSALen = tszTempStr;
				 strVSAValue = strDispValue;
				 strPrefix = _T("03");
				 break;
				break;
		}
		
		if(strDispValue.IsEmpty())		// special case for nothing for value
		{

			strVSALen = _T("02");
			strVSAValue = _T("");
		}

		strVSAValue = strVSAType + strVSALen + strVSAValue;
	}
	else
	{
		strPrefix = _T("00");
		strVSAValue = strDispValue;
	}

	strValue += strVSAValue;
	strValue = strPrefix + strValue;

	return S_OK;
}

//+---------------------------------------------------------------------------
//
// Data validation and conversion routines: hexadecimal string to integer
//											decimal string to integer	
//
//+---------------------------------------------------------------------------

#define ISSPACE(ch)  (  ( ch==_T(' ') )  || ( ch==_T('\t') ) )
//+---------------------------------------------------------------------------
//
// Function:  'Decimal
//
// Synopsis:  Check whether a string is a valid 4-BYTE decimal integer
//
// Arguments: LPCTSTR tszStr		- input string
//            BOOL fUnsigned	- whether this is an unsigned integer
//            long *pdValue		- return the integer value back here
//
// Returns:   BOOL - TRUE:	valid decimal integer
//					 FALSE: otherwise
//
// History:   Created Header    byao	5/22/98 2:14:14 PM
//
//+---------------------------------------------------------------------------
BOOL IsValidDecimal(LPCTSTR tszStr, BOOL fUnsigned, long *pdValue)
{
	if ( !tszStr )
	{
		return FALSE;
	}

	*pdValue = 0;

	// first, skip the white space
	while ( *tszStr && ISSPACE(*tszStr) ) 
	{
		tszStr++;
	}
	
	if ( ! (*tszStr) )
	{
		// string has ended already -- which means this string has only
		// white space in it
		return FALSE;		
	}

	if (_tcslen(tszStr)>11)
	{
		//
		// since we only deal with 4-byte integer here, the standard value range
		// is :  -2147483648 to 2147483647; 
		// For unsigned number, that puts us to 0 to 4294967295, which has
		// maximum length 10.
		//
		return FALSE;
	}

	// 
	// negative integer?
	//
	BOOL fNegative = FALSE;
	if ( *tszStr == _T('-') )
	{
		if ( fUnsigned )
		{
			return FALSE;
		}

		fNegative = TRUE;
		tszStr++;
	}

	double dbTemp = 0; // we use a temporary double variable here
					  // so we can check whether the number is out of bounds
	while ( *tszStr )
	{
		if ( *tszStr <= '9' && *tszStr >='0' )
		{
			dbTemp = dbTemp*10 + (*tszStr - '0');
		}
		else
		{
			return FALSE;
		}

		tszStr++;
	}


	if ( fUnsigned && dbTemp > UINT_MAX )
	{
		// out of range
		return FALSE;
	}

	if ( !fUnsigned && fNegative )
	{
		// negative number??
		dbTemp =  (-dbTemp);
	}

	if ( !fUnsigned && (  dbTemp < INT_MIN || dbTemp > INT_MAX ) )
	{
		// integer out of range
		return FALSE;
	}

	*pdValue = (long)dbTemp;

	return TRUE;
}

//+---------------------------------------------------------------------------
//
// Function:  DDV_IntegerStr
//
// Synopsis:  custom data verification routine: an integer string.
//			  the string must be consisted of integer only and must be 
//			  in the right range for 4-byte integer
//
// Arguments: CDataExchange* pDX - data exchange context
//            ::CString& strText -  string to verify
//
// Returns:   void  - 
//
// History:   Created Header  byao  3/10/98 11:04:58 PM
//
//+---------------------------------------------------------------------------
void  DDV_IntegerStr(CDataExchange* pDX, ::CString& strText)
{
	TRACE(_T("DDV_IntegerStr"));
	
	TCHAR	wzMessage[MAX_PATH];
	::CString	strMessage;
	int		nIndex;

	long  lTempValue;
	BOOL fValid = IsValidDecimal((LPCTSTR)strText, FALSE, &lTempValue);

	if ( !fValid )
	{
			// invalid data
			ShowErrorDialog(pDX->m_pDlgWnd->GetSafeHwnd(),  IDS_IAS_ERR_INVALIDINTEGER, NULL);
			pDX->Fail();
			return;
	}
	TRACE(_T("Valid integer: %ws\n"), (LPCTSTR)strText);
}

//+---------------------------------------------------------------------------
//
// Function:  DDV_Unsigned_IntegerStr
//
// Synopsis:  custom data verification routine: an unsigned integer string.
//			  the string must be consisted of integer only and must be in 
//			  the range for a 4-byte unsigned integer
//
// Arguments: CDataExchange* pDX - data exchange context
//            ::CString& strText -  string to verify
//
// Returns:   void  - 
//
// History:   Created Header  byao  5/22/98 11:04:58 PM
//
//+---------------------------------------------------------------------------
void  DDV_Unsigned_IntegerStr(CDataExchange* pDX, ::CString& strText)
{
	TRACE(_T("DDV_Unsigned_IntegerStr\n"));
	
	TCHAR	wzMessage[MAX_PATH];
	::CString	strMessage;
	int		nIndex;

	long  lTempValue;
	BOOL fValid = IsValidDecimal((LPCTSTR)strText, TRUE, &lTempValue);

	if ( !fValid )
	{
			// invalid data
			ShowErrorDialog(pDX->m_pDlgWnd->GetSafeHwnd(),  IDS_IAS_ERR_INVALID_UINT, NULL);
			pDX->Fail();
			return;
	}
	TRACE(_T("Valid integer: %ws\n"), (LPCTSTR)strText);
}

//+---------------------------------------------------------------------------
//
// Function:  GetValidVSAHexString
//
// Synopsis:  check whether the input string is a valid VSA hexadecimal string
//			  and return a pointer to where the string actually starts
//				
//			  A valid VSA hexadecimal string must meet the following criteria:

// MAM 09/15/98 - _may_ start with 0x -- see 203334 -- we don't require 0x anymore.
//			    1)  _may_ start with 0x (no preceding white space)

//				2)  contains only valid hexadecimal digits
//				3)  contains even number of digits
//				4)  maximum string length is 246.
//
// Arguments: LPCTSTR tszStr - input string
//
// Returns:   NULL:  invalid VSA hex string
//			  otherwise return a pointer to the first character of the string
//
//			  e.g, if the string is: "    0xabcd", then return "abcd"
//
// History:   Created Header  byao  5/22/98 4:06:57 PM
//
//+---------------------------------------------------------------------------
LPTSTR GetValidVSAHexString(LPCTSTR tszStr)
{
	LPTSTR tszStartHex = NULL;

	if ( !tszStr )
	{
		return NULL;
	}


	// Maximum length: 246.  
	// We'll check using this below once we've dispensed with
	// any "0x" prefix if it exists.
	int iMaxLength = 246;


	// skip the white space
	while ( *tszStr && ISSPACE(*tszStr) ) 
	{
		tszStr++;
	}


	// MAM 09/15/98 - _may_ start with 0x -- see 203334 -- we don't require 0x anymore.
	//
	// does it start with 0x?
	//
	if ( tszStr[0]==_T('0') )
	{
		// If it starts with '0x', skip these two characters.
		if ( tszStr[1] == _T('x') || tszStr[1] == _T('X') )
		{
			// Skip "0x" prefix.
			tszStr++;
			tszStr++;
		}
	}

	// Check whether exceeds iMaxLength now that we have dispensed 
	// with "0x" if it was prefixed to the string.
	// Also check for minimum length: 2 (must have at least some data)
	// Also it must be even number length.

	int iLength = _tcslen(tszStr);
	if ( iLength > iMaxLength || iLength < 2 || iLength % 2 )
	{
		return NULL;
	}


	tszStartHex = (LPTSTR)tszStr;
	if ( !(*tszStartHex) )
	{
		// there's nothing followed by the prefix
		return NULL;
	}


	// does it contain any invalid character?
	while ( *tszStr )
	{
		if (!
			 ((*tszStr >= _T('0') && *tszStr <= _T('9')) ||
			  (*tszStr >= _T('a') && *tszStr <= _T('f')) ||
			  (*tszStr >= _T('A') && *tszStr <= _T('F'))
			 )
		   )
		{
			return NULL;
		}

		tszStr++;
	}
	
	// return the pointer
	return tszStartHex;
}

//+---------------------------------------------------------------------------
//
// Function:  DDV_VSA_HexString
//
// Synopsis:  custom data verification routine: VSA hexadecimal string
//			  A valid VSA hexadecimal string must meet the following criteria:

// MAM 09/15/98 - NO! see 203334 -- we don't require 0x anymore.
//			    1)  start with 0x (no preceding white space)

//				2)  contains only valid hexadecimal digits
//				3)  contains even number of digits
//				4)  maximum string length is 246.
//
// Arguments: CDataExchange* pDX - data exchange context
//            ::CString& strText -  string to verify
//
// Returns:   void  - 
//
// History:   Created Header  byao  5/22/98 11:04:58 PM
//
//+---------------------------------------------------------------------------
void  DDV_VSA_HexString(CDataExchange* pDX, ::CString& strText)
{
	TRACE(_T("::DDV_VSA_HexString()\n"));
	
	TCHAR	wzMessage[MAX_PATH];
	::CString	strMessage;

	LPTSTR	tszHex = GetValidVSAHexString( (LPCTSTR)strText );

	if ( !tszHex )
	{
		// invalid data
		ShowErrorDialog(pDX->m_pDlgWnd->GetSafeHwnd(), IDS_IAS_ERR_INVALID_VSAHEX, NULL);
		pDX -> Fail();
	}
	else
	{
		strText = tszHex;
		TRACE(_T("Valid VSA hex string %ws\n"), (LPCTSTR)strText);
	}
}


//+---------------------------------------------------------------------------
//
// Function:  DDV_BoolStr
//
// Synopsis:  custom data verification routine: a boolean string.
//			  the only valid values are "T", "F", "TRUE", "FALSE"
//
// Arguments: CDataExchange* pDX - data exchange context
//            ::CString& strText -  string to verify
//
// Returns:   void  - 
//
// History:   Created Header  byao  3/10/98 11:04:58 PM
//
//+---------------------------------------------------------------------------
void  DDV_BoolStr(CDataExchange* pDX, ::CString& strText)
{
	TRACE(_T("::DDV_BoolStr()\n"));
	
	TCHAR	wzMessage[MAX_PATH];
	::CString	strMessage;

	if (! ( _wcsicmp(strText, _T("TRUE")) == 0 || _wcsicmp(strText, _T("FALSE") ) == 0
	      ))
	{
		// invalid data
		ShowErrorDialog(pDX->m_pDlgWnd->GetSafeHwnd(), IDS_IAS_ERR_INVALIDBOOL, NULL);
		pDX -> Fail();
	}
	TRACE(_T("Valid bool value %ws\n"), (LPCTSTR)strText);
}

//////////////////////////////////////////////////////////////////////////////

TCHAR HexChar[] = {
			_T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'), _T('7'), 
			_T('8'), _T('9'), _T('a'), _T('b'), _T('c'), _T('d'), _T('e'), _T('f')
			};


// convert binary data to hex string, bytes 01 01 01 --> _T("0x010101")
size_t		BinaryToHexString(char* pData, size_t cch, TCHAR* pTStr, size_t ctLen)
{
	int	nRequiredLen = (cch * 2 + 2 + 1);	// two WCHAR for 1 byte, and 0x at begining and , \0 at end 

	if(ctLen == 0)
		return 	nRequiredLen;

	if(ctLen < nRequiredLen || pTStr == NULL ||  pData == NULL)
		return 0;

	// make the output string empty
	if(cch == 0)
	{
		*pTStr = 0;
		return 1;
	}

	// do converstion now		
	*pTStr = _T('0');
	*(pTStr + 1) = _T('x');


	// walk through each byte
	for(int i = 0; i < cch; i++)
	{
		int h = ((*(pData + i) & 0xf0) >> 4);

		// high 4 bits
		*(pTStr + i * 2 + 2) = HexChar[h];
				
		// low 4 bits
		h = (*(pData + i) & 0x0f);
		*(pTStr + i * 2 + 1+ 2 ) = HexChar[h];
	}

	*(pTStr + nRequiredLen - 1 ) = _T('\0');

	return nRequiredLen;

}


//
#define HexValue(h)	\
		( ((h) >= _T('a') && (h) <= _T('f')) ? ((h) - _T('a') + 0xa) : \
		( ((h) >= _T('A') && (h) <= _T('F')) ? ((h) - _T('A') + 0xa) : \
		( ((h) >= _T('0') && (h) <= _T('9')) ? ((h) - _T('0')) : 0)))

// convert HexString to binary value: _T("0x010101") convert to 3 bytes 01 01 01
size_t	HexStringToBinary(TCHAR* pStr, char* pData, size_t cch)
{
	// need to convert to binary before passing into SafeArray
	pStr =  GetValidVSAHexString(pStr);

	if(pStr == NULL)	return 0;
		
	
	size_t nLen = _tcslen(pStr) / 2;

	// if inquery for length
	if(cch == 0)	return nLen;
	
	// get the binary

	for(int i = 0; i < nLen; i++)
	{
		char h, l;

		// high 4 bits
		h = (char)HexValue(pStr[i * 2]);

		// low 4 bits
		l = (char)HexValue(pStr[i * 2 + 1]);

		*(pData + i) = (h << 4) + l;
	}

	return nLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasenumerableeditorpage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASEnumerableEditorPage.h

Abstract:

	Declaration of the CIASPgEnumAttr class.

	This dialog allows the user to choose an attribute value from an enumeration.	



	See IASEnumerableEditorPage.cpp for implementation.

Revision History:
	mmaguire 06/25/98	- revised Baogang Yao's original implementation 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_ENUMERABLE_ATTRIBUTE_EDITOR_PAGE_H_)
#define _ENUMERABLE_ATTRIBUTE_EDITOR_PAGE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// IASPgEnum.h : header file
//

#include "dlgcshlp.h"

/////////////////////////////////////////////////////////////////////////////
// CIASPgEnumAttr dialog

class CIASPgEnumAttr : public CHelpDialog
{
	DECLARE_DYNCREATE(CIASPgEnumAttr)

// Construction
public:
	CIASPgEnumAttr();
	~CIASPgEnumAttr();


	// Call this to pass this page an interface pointer to the "AttributeInfo"
	// which describes the attribute we are editing.
	HRESULT SetData( IIASAttributeInfo *pIASAttributeInfo );


	// Modify the m_strAttrXXXX members below before creating the page to
	// pass the value.


// Dialog Data
	//{{AFX_DATA(CIASPgEnumAttr)
	enum { IDD = IDD_IAS_ENUM_ATTR };
	::CString	m_strAttrFormat;
	::CString	m_strAttrName;
	::CString	m_strAttrType;
	::CString	m_strAttrValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIASPgEnumAttr)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CIASPgEnumAttr)
	virtual BOOL OnInitDialog();
//	afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CComPtr<IIASAttributeInfo>	m_spIASAttributeInfo;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _ENUMERABLE_ATTRIBUTE_EDITOR_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasipattributeeditor.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASIPAttributeEditor.cpp 

Abstract:

	Implementation file for the CIASIPAttributeEditor class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASIPAttributeEditor.h"
#include "IASIPEditorPage.h"
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CIASIPAttributeEditor::ShowEditor

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASIPAttributeEditor::ShowEditor( /*[in, out]*/ BSTR *pReserved )
{
	TRACE(_T("CIASIPAttributeEditor::ShowEditor\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		
		// Load page title.
//		::CString			strPageTitle;
//		strPageTitle.LoadString(IDS_IAS_IP_EDITOR_TITLE);
//
//		CPropertySheet	propSheet( (LPCTSTR)strPageTitle );
		

		// 
		// IP Address Editor
		// 
		IPEditorPage	cppPage;
		

		// Initialize the page's data exchange fields with info from IAttributeInfo

		CComBSTR bstrName;
		CComBSTR bstrSyntax;
		ATTRIBUTEID Id = ATTRIBUTE_UNDEFINED;

		if( m_spIASAttributeInfo )
		{
			hr = m_spIASAttributeInfo->get_AttributeName( &bstrName );
			if( FAILED(hr) ) throw hr;

			m_spIASAttributeInfo->get_SyntaxString( &bstrSyntax );
			if( FAILED(hr) ) throw hr;

			m_spIASAttributeInfo->get_AttributeID( &Id );
			if( FAILED(hr) ) throw hr;
		}
		
		cppPage.m_strAttrName	= bstrName;
		
		cppPage.m_strAttrFormat	= bstrSyntax;

		// Attribute type is actually attribute ID in string format 
		WCHAR	szTempId[MAX_PATH];
		wsprintf(szTempId, _T("%ld"), Id);
		cppPage.m_strAttrType	= szTempId;


		// Initialize the page's data exchange fields with info from VARIANT value passed in.

		if ( V_VT(m_pvarValue) != VT_EMPTY )
		{
			_ASSERTE( V_VT(m_pvarValue) == VT_I4 );
			cppPage.m_dwIpAddr	= V_I4(m_pvarValue);
			cppPage.m_fIpAddrPreSet = TRUE;
		}


//		propSheet.AddPage(&cppPage);

//		int iResult = propSheet.DoModal();
		int iResult = cppPage.DoModal();
		if (IDOK == iResult)
		{
			// Initialize the variant that was passed in.
			VariantClear(m_pvarValue);

			// Save the value that the user edited to the variant.
			V_VT(m_pvarValue) = VT_I4;
			V_I4(m_pvarValue) = cppPage.m_dwIpAddr;
		}
		else
		{
			hr = S_FALSE;
		}

		//
		// delete the property page pointer
		//
//		propSheet.RemovePage(&cppPage);

	}
	catch( HRESULT & hr )
	{
		return hr;	
	}
	catch(...)
	{
		return hr = E_FAIL;

	}
	
	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASIPAttributeEditor::SetAttributeValue

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASIPAttributeEditor::SetAttributeValue(VARIANT * pValue)
{
	TRACE(_T("CIASIPAttributeEditor::SetAttributeValue\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())


	// Check for preconditions.
	if( ! pValue )
	{
		return E_INVALIDARG;
	}
	if( V_VT(pValue) != VT_I4 && V_VT(pValue) != VT_EMPTY )
	{
		return E_INVALIDARG;
	}
	
	
	m_pvarValue = pValue;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASIPAttributeEditor::get_ValueAsString

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASIPAttributeEditor::get_ValueAsString(BSTR * pbstrDisplayText )
{
	TRACE(_T("CIASIPAttributeEditor::get_ValueAsString\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pbstrDisplayText )
	{
		return E_INVALIDARG;
	}

	CComBSTR bstrDisplay;

	// This if falls through so get a blank string for any other types.
	if( V_VT(m_pvarValue) == VT_I4 )
	{
		DWORD dwAddress = V_I4(m_pvarValue);
		WORD	hi = HIWORD(dwAddress);
		WORD	lo = LOWORD(dwAddress);
		
		WCHAR szTemp[255];

		wsprintf( szTemp, _T("%-d.%-d.%-d.%d"), HIBYTE(hi), LOBYTE(hi), HIBYTE(lo), LOBYTE(lo));
		bstrDisplay = szTemp;
	}

	*pbstrDisplayText = bstrDisplay.Copy();


	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasipattributeeditor.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASIPAttributeEditor.h

Abstract:

	Declaration of the CIASIPAttributeEditor class.


	This class is the C++ implementation of the IIASAttributeEditor interface on
	the IP Attribute Editor COM object.

  
	See IASIPAttributeEditor.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IP_ATTRIBUTE_EDITOR_H_)
#define _IP_ATTRIBUTE_EDITOR_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "IASAttributeEditor.h"
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CIASIPAttributeEditor
class ATL_NO_VTABLE CIASIPAttributeEditor : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIASIPAttributeEditor, &CLSID_IASIPAttributeEditor>,
	public CIASAttributeEditor
{
public:
	CIASIPAttributeEditor()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)

BEGIN_COM_MAP(CIASIPAttributeEditor)
	COM_INTERFACE_ENTRY(IIASAttributeEditor)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIASAttributeEditor overrides
protected:
	STDMETHOD(SetAttributeValue)(VARIANT *pValue);
	STDMETHOD(ShowEditor)( /*[in, out]*/ BSTR *pReserved );
	STDMETHOD(get_ValueAsString)(/*[out, retval]*/ BSTR *pVal);

};

#endif // _IP_ATTRIBUTE_EDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasipeditorpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASIPEditorPage.cpp

Abstract:

	Implementation file for the IPEditorPage class.

Revision History:
	mmaguire 06/25/98	- revised Baogang Yao's original implementation

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASIPEditorPage.h"
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



IMPLEMENT_DYNCREATE(IPEditorPage, CHelpDialog)



BEGIN_MESSAGE_MAP(IPEditorPage, CHelpDialog)
	//{{AFX_MSG_MAP(IPEditorPage)
//	ON_WM_CONTEXTMENU()
//	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//////////////////////////////////////////////////////////////////////////////
/*++

IPEditorPage::IPEditorPage

  Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
IPEditorPage::IPEditorPage() : CHelpDialog(IPEditorPage::IDD)
{
	TRACE(_T("IPEditorPage::IPEditorPage\n"));

	//{{AFX_DATA_INIT(IPEditorPage)
	m_strAttrFormat = _T("");
	m_strAttrName = _T("");
	m_strAttrType = _T("");
	//}}AFX_DATA_INIT


	m_dwIpAddr	 = 0;
	m_fIpAddrPreSet = FALSE;

	// init for using IPAddress common control
	INITCOMMONCONTROLSEX	INITEX;
	INITEX.dwSize = sizeof(INITCOMMONCONTROLSEX);
    INITEX.dwICC = ICC_INTERNET_CLASSES;
	::InitCommonControlsEx(&INITEX);

}



//////////////////////////////////////////////////////////////////////////////
/*++

IPEditorPage::~IPEditorPage

--*/
//////////////////////////////////////////////////////////////////////////////
IPEditorPage::~IPEditorPage()
{
	TRACE(_T("IPEditorPage::~IPEditorPage\n"));
}



//////////////////////////////////////////////////////////////////////////////
/*++

IPEditorPage::DoDataExchange

--*/
//////////////////////////////////////////////////////////////////////////////
void IPEditorPage::DoDataExchange(CDataExchange* pDX)
{
	TRACE(_T("IPEditorPage::DoDataExchange\n"));

	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(IPEditorPage)
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRFORMAT, m_strAttrFormat);
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRNAME, m_strAttrName);
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRTYPE, m_strAttrType);
	//}}AFX_DATA_MAP


	if(pDX->m_bSaveAndValidate)		// save data to this class
	{
		// ip adress control
		SendDlgItemMessage(IDC_IAS_EDIT_IPADDR, IPM_GETADDRESS, 0, (LPARAM)&m_dwIpAddr);
	}
	else		// put to dialog
	{
		// ip adress control
		if ( m_fIpAddrPreSet)
		{
			SendDlgItemMessage(IDC_IAS_EDIT_IPADDR, IPM_SETADDRESS, 0, m_dwIpAddr);
		}
		else
		{
			SendDlgItemMessage(IDC_IAS_EDIT_IPADDR, IPM_CLEARADDRESS, 0, 0L);
		}
	}

}


/////////////////////////////////////////////////////////////////////////////
// IPEditorPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasipeditorpage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASIPEditorPage.h

Abstract:

	Declaration of the IPEditorPage class.

	
	This page allows the user to edit an IPv4 attribute.


	See IASIPEditorPage.cpp for implementation.

Revision History:
	mmaguire 06/25/98	- revised Baogang Yao's original implementation 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IP_ATTRIBUTE_EDITOR_PAGE_H_)
#define _IP_ATTRIBUTE_EDITOR_PAGE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// IPEditorPage.h : header file
//

#include "dlgcshlp.h"

/////////////////////////////////////////////////////////////////////////////
// IPEditorPage dialog

class IPEditorPage : public CHelpDialog
{
	DECLARE_DYNCREATE(IPEditorPage)

// Construction
public:
	IPEditorPage();
	~IPEditorPage();

// Dialog Data
	//{{AFX_DATA(IPEditorPage)
	enum { IDD = IDD_IAS_IPADDR_ATTR };
	::CString	m_strAttrFormat;
	::CString	m_strAttrName;
	::CString	m_strAttrType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(IPEditorPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	public:
	DWORD	m_dwIpAddr; // ip address
	BOOL	m_fIpAddrPreSet;  // is the IP Address preset?


// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(IPEditorPage)
//	afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _IP_ATTRIBUTE_EDITOR_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasmultivaluedattributeeditor.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASMultivaluedAttributeEditor.h

Abstract:

	Declaration of the CIASMultivaluedAttributeEditor class.


	This class is the C++ implementation of the IIASAttributeEditor interface on
	the Multivalued Attribute Editor COM object.

	
	See IASMultivaluedAttributeEditor.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_MULTIVALUED_ATTRIBUTE_EDITOR_H_)
#define _MULTIVALUED_ATTRIBUTE_EDITOR_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "IASAttributeEditor.h"
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CIASMultivaluedAttributeEditor
class ATL_NO_VTABLE CIASMultivaluedAttributeEditor : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIASMultivaluedAttributeEditor, &CLSID_IASMultivaluedAttributeEditor>,
	public CIASAttributeEditor
{
public:
	CIASMultivaluedAttributeEditor()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)

BEGIN_COM_MAP(CIASMultivaluedAttributeEditor)
	COM_INTERFACE_ENTRY(IIASAttributeEditor)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIASAttributeEditor overrides
public:
	STDMETHOD(SetAttributeValue)(VARIANT *pValue);
	STDMETHOD(ShowEditor)( /*[in, out]*/ BSTR *pReserved );
	STDMETHOD(get_ValueAsString)(/*[out, retval]*/ BSTR *pVal);

};

#endif // _MULTIVALUED_ATTRIBUTE_EDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasmultivaluededitorpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    IASMultivaluedEditorPage.cpp

Abstract:

	Implementation file for the CMultivaluedEditorPage class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASMultivaluedEditorPage.h"
//
// where we can find declarations needed in this file:
//
#include "iasdebug.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

const int NOTHING_SELECTED = -1;



#define ATTRIBUTE_VENDOR_COLUMN_WIDTH		120
#define ATTRIBUTE_VALUE_COLUMN_WIDTH		300



//////////////////////////////////////////////////////////////////////////////
/*++

::GetSelectedItemIndex

	Utility function which returns index value of first selected item in list control.

	Returns NOTHING_SELECTED if no item is selected.

--*/
//////////////////////////////////////////////////////////////////////////////
inline int GetSelectedItemIndex( CListCtrl & ListCtrl )
{
	int iIndex = 0;
	int iFlags = LVNI_ALL | LVNI_SELECTED;

	// Note: GetNextItem excludes the current item passed in.  So to
	// find the first item which matches, you must pass in -1.
	iIndex = ListCtrl.GetNextItem( -1, iFlags );

	// Note: GetNextItem returns -1 (which is NOTHING_SELECTED for us) if it can't find anything.
	return iIndex;

}



/////////////////////////////////////////////////////////////////////////////
// CMultivaluedEditorPage property page



IMPLEMENT_DYNCREATE(CMultivaluedEditorPage, CHelpDialog)



BEGIN_MESSAGE_MAP(CMultivaluedEditorPage, CHelpDialog)
	//{{AFX_MSG_MAP(CMultivaluedEditorPage)
	ON_NOTIFY(NM_DBLCLK, IDC_IAS_LIST_MULTI_ATTRS, OnDblclkListIasMultiAttrs)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_IAS_LIST_MULTI_ATTRS, OnItemChangedListIasMultiAttrs)
	ON_BN_CLICKED(IDC_IAS_BUTTON_ADD_VALUE, OnButtonAddValue)
	ON_BN_CLICKED(IDC_IAS_BUTTON_MOVE_UP, OnButtonMoveUp)
	ON_BN_CLICKED(IDC_IAS_BUTTON_MOVE_DOWN, OnButtonMoveDown)
	ON_BN_CLICKED(IDC_IAS_BUTTON_REMOVE, OnButtonRemove)
	ON_BN_CLICKED(IDC_IAS_BUTTON_EDIT, OnButtonEdit)
//	ON_WM_CONTEXTMENU()
//	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::CMultivaluedEditorPage

  Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CMultivaluedEditorPage::CMultivaluedEditorPage() : CHelpDialog(CMultivaluedEditorPage::IDD)
{
	TRACE_FUNCTION("CMultivaluedEditorPage::CMultivaluedEditorPage");

	//{{AFX_DATA_INIT(CMultivaluedEditorPage)
	m_strAttrFormat = _T("");
	m_strAttrName = _T("");
	m_strAttrType = _T("");
	//}}AFX_DATA_INIT


	m_fIsDirty = FALSE;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::~CMultivaluedEditorPage

	Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CMultivaluedEditorPage::~CMultivaluedEditorPage()
{
	TRACE_FUNCTION("CMultivaluedEditorPage::~CMultivaluedEditorPage");

}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::SetData

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMultivaluedEditorPage::SetData( IIASAttributeInfo *pIASAttributeInfo, VARIANT * pvarVariant )
{
	TRACE_FUNCTION("CMultivaluedEditorPage::SetData");

	// ISSUE: Should assert that pvarVariant contains a safe array.

	HRESULT hr = S_OK;

	// Store off some pointers.
	m_spIASAttributeInfo = pIASAttributeInfo;
	m_pvarData = pvarVariant;

	// Open the variant up into a safe array of its constiuent parts.
	// To have this page close the array back up again and save it
	// using the pvarVariant pointer supplied above, call CommitArrayToVariant.
	try
	{
		// Check to see whether the variant passed was empty.
		if( V_VT( m_pvarData ) == VT_EMPTY )
		{
			// Create a new 1-dimensional safearray with no elements.
			DWORD dwInitialElements = 0;
			m_osaValueList.Create( VT_VARIANT, 1, &dwInitialElements );
		}
		else
		{
			_ASSERTE( V_VT( m_pvarData ) == (VT_VARIANT | VT_ARRAY) );

			// This creates a new copy of the SAFEARRAY pointed to by m_pvarData
			// wrapped by the standard COleSafeArray instance m_osaValueList.
			m_osaValueList = m_pvarData;
		}
	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::DoDataExchange

--*/
//////////////////////////////////////////////////////////////////////////////
void CMultivaluedEditorPage::DoDataExchange(CDataExchange* pDX)
{
	TRACE_FUNCTION("CMultivaluedEditorPage::DoDataExchange");

	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMultivaluedEditorPage)
	DDX_Control(pDX, IDC_IAS_LIST_MULTI_ATTRS, m_listMultiValues);
	DDX_Text(pDX, IDC_IAS_EDIT_MULTI_ATTR_FORMAT, m_strAttrFormat);
	DDX_Text(pDX, IDC_IAS_EDIT_MULTI_ATTR_NAME, m_strAttrName);
	DDX_Text(pDX, IDC_IAS_EDIT_MULTI_ATTR_NUMBER, m_strAttrType);
	//}}AFX_DATA_MAP
}



/////////////////////////////////////////////////////////////////////////////
// CMultivaluedEditorPage message handlers



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CMultivaluedEditorPage::OnInitDialog()
{
	TRACE_FUNCTION("CMultivaluedEditorPage::OnInitDialog");

	CHelpDialog::OnInitDialog();
	
	HRESULT hr = S_OK;


	//
	// first, set the list box to 3 columns
	//
	LVCOLUMN lvc;
	::CString strColumnHeader;
	WCHAR   wzColumnHeader[MAX_PATH];

	// initialize the LVCOLUMN structure
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvc.fmt = LVCFMT_LEFT;
	lvc.pszText = wzColumnHeader;
	

	// Add the vendor column.
	strColumnHeader.LoadString(IDS_IAS_MULTI_ATTR_COLUMN_VENDOR);
	wcscpy(wzColumnHeader, strColumnHeader);
	lvc.cx = ATTRIBUTE_VENDOR_COLUMN_WIDTH;
	m_listMultiValues.InsertColumn(0, &lvc);

	// Add the value column.
	strColumnHeader.LoadString(IDS_IAS_MULTI_ATTR_COLUMN_VALUE);
	wcscpy(wzColumnHeader, strColumnHeader);
	lvc.cx = ATTRIBUTE_VALUE_COLUMN_WIDTH;
	m_listMultiValues.InsertColumn(1, &lvc);


	hr = UpdateAttrListCtrl();

	
	// Take action based on whether list is empty or not.
	DWORD dwSize;
	try
	{
		dwSize = m_osaValueList.GetOneDimSize();
	}
	catch(...)
	{
		dwSize = 0;
	}
	if( dwSize > 0 )
	{
		// We have at least one element.

		// Select the first element.
		m_listMultiValues.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);
		m_listMultiValues.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);

	}
	else
	{
		// We are currently empty.
		GetDlgItem(IDOK)->EnableWindow(FALSE);

		GetDlgItem(IDC_IAS_BUTTON_MOVE_UP)->EnableWindow(FALSE);
		GetDlgItem(IDC_IAS_BUTTON_MOVE_DOWN)->EnableWindow(FALSE);
		GetDlgItem(IDC_IAS_BUTTON_REMOVE)->EnableWindow(FALSE);
		GetDlgItem(IDC_IAS_BUTTON_EDIT)->EnableWindow(FALSE);

	}

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::UpdateAttrListCtrl

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMultivaluedEditorPage::UpdateAttrListCtrl()
{
	TRACE_FUNCTION("CMultivaluedEditorPage::UpdateAttrListCtrl");

	HRESULT hr = S_OK;


	CComPtr<IIASAttributeEditor> spIASAttributeEditor;

	// Get the editor to use.
	hr = SetUpAttributeEditor( m_spIASAttributeInfo.p, &spIASAttributeEditor );
	if( FAILED( hr ) ) return hr;

	//
	// clear up the whole list first
	//
	m_listMultiValues.DeleteAllItems();


	try
	{
		DWORD dwSize = m_osaValueList.GetOneDimSize(); // number of multi-valued attrs.

		// Lock the safearray.  This wrapper class will unlock as soon as it goes out of scope.
		CMyOleSafeArrayLock osaLock( m_osaValueList );

		for (long lIndex = 0; (DWORD) lIndex < dwSize; lIndex++)
		{
			VARIANT * pvar;
			m_osaValueList.PtrOfIndex( &lIndex, (void**) &pvar );

			CComBSTR bstrVendor;
			CComBSTR bstrValue;
			CComBSTR bstrReserved;

			// Ignore HRESULT if fails -- we will just end up with empty strings.
			HRESULT hrTemp = spIASAttributeEditor->GetDisplayInfo(m_spIASAttributeInfo.p, pvar, &bstrVendor, &bstrValue, &bstrReserved );
				
			m_listMultiValues.InsertItem(lIndex, bstrVendor );

			m_listMultiValues.SetItemText( lIndex, 1, bstrValue );

		}

	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::OnDblclkListIasMultiAttrs

--*/
//////////////////////////////////////////////////////////////////////////////
void CMultivaluedEditorPage::OnDblclkListIasMultiAttrs(NMHDR* pNMHDR, LRESULT* pResult)
{
	TRACE_FUNCTION("CMultivaluedEditorPage::OnDblclkListIasMultiAttrs");

	//
    // see if there is an item already selected in ProfAttr list
    //

	int iSelected = GetSelectedItemIndex(m_listMultiValues);
	if (NOTHING_SELECTED == iSelected )
	{
		// do nothing
		return;
	}


	HRESULT hr;


	hr = EditItemInList( iSelected );


	*pResult = 0;
	
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::UpdateProfAttrListItem

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMultivaluedEditorPage::UpdateProfAttrListItem(int iItem)
{
	TRACE_FUNCTION("CMultivaluedEditorPage::UpdateProfAttrListItem");

	HRESULT hr = S_OK;


	CComBSTR bstrVendor;
	CComBSTR bstrValue;
	CComBSTR bstrReserved;

	try
	{

		// Get the editor to use.
		CComPtr<IIASAttributeEditor> spIASAttributeEditor;

		hr = SetUpAttributeEditor( m_spIASAttributeInfo.p, &spIASAttributeEditor );
		if( FAILED( hr ) ) throw hr;

		// Retrieve item from array.
		VARIANT *  pvar;

		// Scope for osaLock only.
		{
			// Lock the safearray.  This wrapper class will unlock as soon as it goes out of scope.
			CMyOleSafeArrayLock osaLock( m_osaValueList );

			long lIndex = iItem;
			m_osaValueList.PtrOfIndex( &lIndex, (void **) &pvar );
		}


		hr = spIASAttributeEditor->GetDisplayInfo(m_spIASAttributeInfo.p, pvar, &bstrVendor, &bstrValue, &bstrReserved );
		if( FAILED( hr ) ) throw hr;


	}
	catch(...)
	{
		// Do nothing -- we'll just show what we have.
	}


	// Update the item's display.
	m_listMultiValues.SetItemText( iItem, 0, bstrVendor );
	m_listMultiValues.SetItemText( iItem, 1, bstrValue );


	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::CommitArrayToVariant

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMultivaluedEditorPage::CommitArrayToVariant()
{
	TRACE_FUNCTION("CMultivaluedEditorPage::CommitArrayToVariant");


	// Commit the safe array passed in to the variant whose pointer
	// was passed in in set data.
	// Any changes made to the safe array won't be preserver unless
	// you call this method.

	HRESULT hr;

	// VariantCopy initializes the existing m_pvarData
	// -- releasing all data associated with it, before
	// copying the new value into this destination.
	try
	{
		hr = VariantCopy( m_pvarData, (LPVARIANT) m_osaValueList );
	}
	catch(...)
	{
		return E_FAIL;
	}


	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::OnButtonMoveUp

--*/
//////////////////////////////////////////////////////////////////////////////
void CMultivaluedEditorPage::OnButtonMoveUp()
{
	TRACE_FUNCTION("CMultivaluedEditorPage::OnButtonMoveUp");

	HRESULT hr;

	try
	{
		int iSelected = GetSelectedItemIndex(m_listMultiValues);
		if( NOTHING_SELECTED == iSelected )
		{
			// Do nothing.
			return;
		}
		
		// Swap the currently selected variant with the one above it.
		long lIndex = iSelected;

		// Lock the safearray.  This wrapper class will unlock as soon as it goes out of scope.
		CMyOleSafeArrayLock osaLock( m_osaValueList );
		
		VARIANT *pvarTop, *pvarBottom;

		m_osaValueList.PtrOfIndex( &lIndex, (void **) &pvarBottom );
		lIndex--;
		m_osaValueList.PtrOfIndex( &lIndex, (void **) &pvarTop );

      void* pvarTemp = pvarTop;
      pvarTop = pvarBottom;
      pvarBottom = reinterpret_cast<VARIANT*> (pvarTemp);
      
		// Update items that have changed.
		UpdateProfAttrListItem( iSelected - 1 );
		UpdateProfAttrListItem( iSelected );

		// Move the selection down one item.
		m_listMultiValues.SetItemState( iSelected, 0, LVIS_SELECTED);
		m_listMultiValues.SetItemState( iSelected - 1, LVIS_SELECTED, LVIS_SELECTED);

	}
	catch(...)
	{
		// Error message
	}
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::OnButtonMoveDown

--*/
//////////////////////////////////////////////////////////////////////////////
void CMultivaluedEditorPage::OnButtonMoveDown()
{
	TRACE_FUNCTION("CMultivaluedEditorPage::OnButtonMoveDown");

	HRESULT hr;

	try
	{
		long lSize = m_osaValueList.GetOneDimSize();

		int iSelected = GetSelectedItemIndex(m_listMultiValues);
		if( iSelected >= lSize )
		{
			// Do nothing.
			return;
		}
		
		// Swap the currently selected variant with the one below it.
		long lIndex = iSelected;

		// Lock the safearray.  This wrapper class will unlock as soon as it goes out of scope.
		CMyOleSafeArrayLock osaLock( m_osaValueList );

		VARIANT *pvarTop, *pvarBottom;

		m_osaValueList.PtrOfIndex( &lIndex, (void **) &pvarTop );
		lIndex++;
      m_osaValueList.PtrOfIndex( &lIndex, (void **) &pvarBottom );

      void* pvarTemp = pvarTop;
      pvarTop = pvarBottom;
      pvarBottom = reinterpret_cast<VARIANT*> (pvarTemp);
   
		// Update items that have changed.
		UpdateProfAttrListItem( iSelected );
		UpdateProfAttrListItem( iSelected + 1 );

		// Move the selection down one item.
		m_listMultiValues.SetItemState( iSelected, 0, LVIS_SELECTED);
		m_listMultiValues.SetItemState( iSelected + 1, LVIS_SELECTED, LVIS_SELECTED);

	}	
	catch(...)
	{
		// Error message
	}

}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::OnButtonAddValue

--*/
//////////////////////////////////////////////////////////////////////////////
void CMultivaluedEditorPage::OnButtonAddValue()
{
	TRACE_FUNCTION("CMultivaluedEditorPage::OnButtonAddValue");

	CComVariant varNewVariant;
	
	HRESULT hr = S_OK;

	try
	{
		CComPtr<IIASAttributeEditor> spIASAttributeEditor;

		// Get the editor to use.
		hr = SetUpAttributeEditor( m_spIASAttributeInfo.p, &spIASAttributeEditor );
		if( FAILED( hr ) ) throw hr;

		// Edit it!
		CComBSTR bstrReserved;
		hr = spIASAttributeEditor->Edit( m_spIASAttributeInfo.p, &varNewVariant, &bstrReserved );
		if( hr == S_OK )
		{
			VARIANT *pvar;

			// Make the safe array bigger by 1
			long lSize = m_osaValueList.GetOneDimSize();
			m_osaValueList.ResizeOneDim( lSize + 1 );

			// Get a pointer to the variant at new position (indexed by lSize+1-1 == lSize)

			// Scope for osaLock only.
			{
				// Lock the safearray.  This wrapper class will unlock as soon as it goes out of scope.
				CMyOleSafeArrayLock osaLock( m_osaValueList );
			
				m_osaValueList.PtrOfIndex( &lSize, (void **) &pvar );
			}

         hr = VariantCopy( pvar, &varNewVariant );
         if (FAILED(hr))
         {
            throw hr;
         }

         // The user added the value.
         m_fIsDirty = TRUE;



			// Make a new place for the newly added value in the list control.
			// We pass a null string because we will let UpdataProfAttrListItem do the display text.
			m_listMultiValues.InsertItem( lSize, L"" );

			// Update the view of that item.
			UpdateProfAttrListItem( lSize );


			// Take action based on whether list is no longer empty.
			DWORD dwSize;
			try
			{
				dwSize = m_osaValueList.GetOneDimSize();
			}
			catch(...)
			{
				dwSize = 0;
			}
			if( dwSize > 0 )
			{
				// We currently have at least one item.
				GetDlgItem(IDOK)->EnableWindow(TRUE);
			}


			// Deselect any currently selected item.
			int iSelected = GetSelectedItemIndex( m_listMultiValues );
			if( iSelected != NOTHING_SELECTED )
			{
				m_listMultiValues.SetItemState( iSelected, 0, LVIS_SELECTED);
			}

			// Select the newly added item.
			m_listMultiValues.SetItemState( lSize, LVIS_SELECTED, LVIS_SELECTED);


			if( FAILED( hr ) ) throw hr;
			
		}

	}
	catch( HRESULT &hr )
	{

		// Print out error message saying that there was an error adding.
		return;
	}
	catch(...)
	{

		// Print out error message saying that there was an error adding.
		return;
	}
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::OnButtonRemove

--*/
//////////////////////////////////////////////////////////////////////////////
void CMultivaluedEditorPage::OnButtonRemove()
{
	TRACE_FUNCTION("CMultivaluedEditorPage::OnButtonRemove");

	//
    // see if there is an item already selected in ProfAttr list
    //
	int iSelected = GetSelectedItemIndex(m_listMultiValues);
	if (NOTHING_SELECTED == iSelected )
	{
		// do nothing
		return;
	}




	HRESULT hr;


	try
	{
		// Swap the currently selected variant with the one below it.
		long lTarget = iSelected;

		
		VARIANT *pvarTop, *pvarBottom;

		long lSize = m_osaValueList.GetOneDimSize();

		// Do some sanity checks.
		_ASSERTE( lSize > 0 );
		_ASSERTE( lTarget >= 0 && lTarget < lSize );

		// Scope for osaLock only.
		{
			// Lock the safearray.  This wrapper class will unlock as soon as it goes out of scope.
			CMyOleSafeArrayLock osaLock( m_osaValueList );

			for( long lIndex = lTarget; lIndex < lSize - 1 ; lIndex++ )
			{

				m_osaValueList.PtrOfIndex( &lIndex, (void **) &pvarTop );
				long lNext = lIndex + 1;
				m_osaValueList.PtrOfIndex( &lNext, (void **) &pvarBottom );

				hr = VariantCopy( pvarTop, pvarBottom );
				if( FAILED( hr ) ) throw hr;

			}
		}		

		// Reduce the size of the safe array by one.
		// NOTE:  You must make sure that you have unlocked the safearray before calling this.
		// ISSUE: We are assuming this deletes the element in the last position.
		m_osaValueList.ResizeOneDim( lSize - 1 );

		m_listMultiValues.SetItemState( iSelected, 0, LVIS_SELECTED);

		// Remove the item from our list.
		if(m_listMultiValues.GetItemCount() > iSelected + 1)
			m_listMultiValues.SetItemState( iSelected + 1, LVIS_SELECTED, LVIS_SELECTED);
		else if (iSelected > 0)			
			m_listMultiValues.SetItemState( iSelected - 1, LVIS_SELECTED, LVIS_SELECTED);
		else // iSelected == 0; and it's the only one
			::SetFocus(GetDlgItem(IDC_IAS_BUTTON_ADD_VALUE)->m_hWnd);
		
		m_listMultiValues.DeleteItem( iSelected );


		// Take action based on whether list is empty or not.
		DWORD dwSize;
		try
		{
			dwSize = m_osaValueList.GetOneDimSize();
		}
		catch(...)
		{
			dwSize = 0;
		}
		if( dwSize > 0 )
		{
			// We have at least one element.

			// Make sure the selection stays on the same position in the list.
			if( ! m_listMultiValues.SetItemState( iSelected, LVIS_SELECTED, LVIS_SELECTED) )
			{
				// We failed, probably because the item that was deleted was the last
				// in the list, so try to select the one before the deleted item.
				m_listMultiValues.SetItemState( iSelected -1, LVIS_SELECTED  | LVIS_FOCUSED, LVIS_SELECTED  | LVIS_FOCUSED);
			}
		}
		else
		{
			// We are currently empty.
			GetDlgItem(IDOK)->EnableWindow(FALSE);
		}



	}
	catch(...)
	{
		//ISSUE: Put up error message.
	}

}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::OnButtonEdit

--*/
//////////////////////////////////////////////////////////////////////////////
void CMultivaluedEditorPage::OnButtonEdit()
{
	TRACE_FUNCTION("CMultivaluedEditorPage::OnButtonEdit");


	//
    // see if there is an item already selected in ProfAttr list
    //
	int iSelected  = GetSelectedItemIndex(m_listMultiValues);
	if (NOTHING_SELECTED == iSelected )
	{
		// do nothing
		return;
	}


	HRESULT hr;
	

	hr = EditItemInList( iSelected );
	
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMultivaluedEditorPage::EditItemInList

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMultivaluedEditorPage::EditItemInList( long lIndex )
{
	TRACE_FUNCTION("CMultivaluedEditorPage::EditItemInList");



	HRESULT hr = S_OK;
	VARIANT *  pvar;

	//
	// get the current node
	//
	try
	{
		// Scope for osaLock only.
		{
			// Lock the safearray.  This wrapper class will unlock as soon as it goes out of scope.
			CMyOleSafeArrayLock osaLock( m_osaValueList );

			m_osaValueList.PtrOfIndex( &lIndex, (void **) &pvar );
		}

		CComPtr<IIASAttributeEditor> spIASAttributeEditor;

		// Get the editor to use.
		hr = SetUpAttributeEditor( m_spIASAttributeInfo.p, &spIASAttributeEditor );
		if( FAILED( hr ) ) throw hr;





	
		// Edit it!
		CComBSTR bstrReserved;
		hr = spIASAttributeEditor->Edit( m_spIASAttributeInfo.p, pvar, &bstrReserved );

		if( hr == S_OK )
		{
			// The user changed the value.
			m_fIsDirty = TRUE;

			hr = UpdateProfAttrListItem(lIndex);
			if( FAILED( hr ) ) throw hr;

		}


	}
	catch( HRESULT & hr )
	{
		// ISSUE: Should put up an error message.
		return hr;
	}
	catch(...)
	{
		// ISSUE: Should put up an error message.
		return E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

::SetUpAttributeEditor

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP SetUpAttributeEditor(     /* in */ IIASAttributeInfo *pIASAttributeInfo
								, /* out */ IIASAttributeEditor ** ppIASAttributeEditor
								)
{
	TRACE_FUNCTION("::SetUpAttributeEditor");

	// Check for preconditions:
	_ASSERTE( pIASAttributeInfo );
	_ASSERTE( ppIASAttributeEditor );


	// Query the schema attribute to see which attribute editor to use.
	CLSID clsidEditorToUse;
	CComBSTR bstrProgID;
	HRESULT hr;

	hr = pIASAttributeInfo->get_EditorProgID( &bstrProgID );
	if( FAILED( hr ) )
	{
		// We could try putting up a default (e.g. hex) editor, but for now:
		return hr;
	}

	hr = CLSIDFromProgID( bstrProgID, &clsidEditorToUse );
	if( FAILED( hr ) )
	{
		// We could try putting up a default (e.g. hex) editor, but for now:
		return hr;
	}


	hr = CoCreateInstance( clsidEditorToUse , NULL, CLSCTX_INPROC_SERVER, IID_IIASAttributeEditor, (LPVOID *) ppIASAttributeEditor );
	if( FAILED( hr ) )
	{
		return hr;
	}
	if( ! *ppIASAttributeEditor )
	{
		return E_FAIL;
	}

	return hr;
}



//+---------------------------------------------------------------------------
//
// Function:  OnItemchangedListIasAllattrs
//
// Class:	  CDlgIASAddAttr
//
// Synopsis:  something has changed in All Attribute list box
//			  We'll try to get the currently selected one
//
// Arguments: NMHDR* pNMHDR -
//            LRESULT* pResult -
//
// Returns:   Nothing
//
// History:   Created Header    2/19/98 3:32:05 PM
//
//+---------------------------------------------------------------------------
void CMultivaluedEditorPage::OnItemChangedListIasMultiAttrs(NMHDR* pNMHDR, LRESULT* pResult)
{
	TRACE(_T("CDlgIASAddAttr::OnItemchangedListIasAllattrs\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

//	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
//	if (pNMListView->uNewState & LVIS_SELECTED)
//	{
//		m_dAllAttrCurSel = pNMListView->iItem;
//	}


    // Set button states depending on whether anything is selected.
	int iSelected = GetSelectedItemIndex(m_listMultiValues);
	if (NOTHING_SELECTED == iSelected )
	{
		HWND hFocus = ::GetFocus();

		if(hFocus == GetDlgItem(IDC_IAS_BUTTON_REMOVE)->m_hWnd)
			::SetFocus(GetDlgItem(IDC_IAS_BUTTON_ADD_VALUE)->m_hWnd);
		
		GetDlgItem(IDC_IAS_BUTTON_MOVE_UP)->EnableWindow(FALSE);
		GetDlgItem(IDC_IAS_BUTTON_MOVE_DOWN)->EnableWindow(FALSE);
		GetDlgItem(IDC_IAS_BUTTON_REMOVE)->EnableWindow(FALSE);
		GetDlgItem(IDC_IAS_BUTTON_EDIT)->EnableWindow(FALSE);
	
	}
	else
	{
		// Something is selected.

		GetDlgItem(IDC_IAS_BUTTON_MOVE_UP)->EnableWindow(TRUE);
		GetDlgItem(IDC_IAS_BUTTON_MOVE_DOWN)->EnableWindow(TRUE);
		GetDlgItem(IDC_IAS_BUTTON_REMOVE)->EnableWindow(TRUE);
		GetDlgItem(IDC_IAS_BUTTON_EDIT)->EnableWindow(TRUE);

	}

	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasmultivaluededitorpage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASMultivaluedEditorPage.h

Abstract:

	Declaration of the CMultivaluedEditorPage class.

	This class wraps a dialog which allows a user to edit the constituent
	items of a multivalued attribute.
  
	  
	Declaration (and inline implementation) of the CMyOleSafeArrayLock helper class.

	This class locks an OleSafeArray for element access until it goes out of scope.
	


	Declaration of the SetUpAttributeEditor utility function.

	CoCreate's the appropriate attribute editor based on ProgID.
  
	
	See IASMultivaluedEditorPage.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_MULTIVALUED_ATTRIBUTE_EDITOR_PAGE_H_)
#define _MULTIVALUED_ATTRIBUTE_EDITOR_PAGE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include "dlgcshlp.h"

/////////////////////////////////////////////////////////////////////////////
// CMultivaluedEditorPage dialog

class CMultivaluedEditorPage : public CHelpDialog
{
	DECLARE_DYNCREATE(CMultivaluedEditorPage)

public:
	CMultivaluedEditorPage();
	~CMultivaluedEditorPage();

	// Call this to pass this page an interface pointer to the "AttributeInfo"
	// which describes the attribute we are editing, and a pointer
	// to the variant containing the SafeArray of variant values.
	HRESULT SetData( IIASAttributeInfo *pIASAttributeInfo, VARIANT * pvarVariant );

	
	// Call this when you want the page to save its values to the 
	// variant whose pointer you passed in SetData.
	HRESULT CommitArrayToVariant();


	// Set the m_strAttrXXXX members below before creating the page.


// Dialog Data
	//{{AFX_DATA(CMultivaluedEditorPage)
	enum { IDD = IDD_IAS_MULTIVALUED_EDITOR };
	CListCtrl	m_listMultiValues;
	::CString	m_strAttrFormat;
	::CString	m_strAttrName;
	::CString	m_strAttrType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMultivaluedEditorPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMultivaluedEditorPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkListIasMultiAttrs(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemChangedListIasMultiAttrs(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonMoveUp();
	afx_msg void OnButtonMoveDown();
	afx_msg void OnButtonAddValue();
	afx_msg void OnButtonRemove();
	afx_msg void OnButtonEdit();
//	afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


	// We use the standard MFC wrapper for SafeArrays.
	// Note: This class throws exceptions!!!!  Use try{}catch{} blocks.
	COleSafeArray m_osaValueList;


	STDMETHOD(UpdateAttrListCtrl)();
	STDMETHOD(UpdateProfAttrListItem)(int nItem);
	STDMETHOD(EditItemInList)( long lIndex );

	// The "AttributeInfo" which contains info about the attribute we are editing.
	// Call SetData to set this.
	CComPtr<IIASAttributeInfo>	m_spIASAttributeInfo;

	// A pointer to the variant we are editing.  Call SetData to set this.
	VARIANT * m_pvarData;

	// Flag whether we value changed.
	// ISSUE: Is this used?  Inherited from Baogang's code.
	BOOLEAN m_fIsDirty;

};



/////////////////////////////////////////////////////////////////////////////
// CMyOleSafeArrayLock
//
//	Small utility class for correct locking and unlocking of safe array.
//
class CMyOleSafeArrayLock
{
	public:
	CMyOleSafeArrayLock( COleSafeArray & osa )
	{
		m_posa = & osa;
		m_posa->Lock();
	}

	~CMyOleSafeArrayLock()
	{	
		m_posa->Unlock();
	}

	private:
		
	COleSafeArray * m_posa;

};



//////////////////////////////////////////////////////////////////////////////
/*++

SetUpAttributeEditor

	Utility function which, given a schema attribute, CoCreates the correct
	editor and sets it up for use with the given schema attribute.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP SetUpAttributeEditor(  /* in */ IIASAttributeInfo *pAttributeInfo
								, /* out */ IIASAttributeEditor ** ppIIASAttributeEditor 
								);




//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _MULTIVALUED_ATTRIBUTE_EDITOR_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasstringattributeeditor.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASStringAttributeEditor.h

Abstract:

	Declaration of the CIASStringAttributeEditor class.

	
	This class is the C++ implementation of the IIASAttributeEditor interface on
	the String Attribute Editor COM object.


	See IASStringAttributeEditor.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_STRING_ATTRIBUTE_EDITOR_H_)
#define _STRING_ATTRIBUTE_EDITOR_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "IASAttributeEditor.h"
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////
enum EStringType
{
	STRING_TYPE_NULL = 0,
	STRING_TYPE_NORMAL,
	STRING_TYPE_UNICODE,
	STRING_TYPE_HEX_FROM_BINARY,
};

/////////////////////////////////////////////////////////////////////////////
// CIASStringAttributeEditor
class ATL_NO_VTABLE CIASStringAttributeEditor : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIASStringAttributeEditor, &CLSID_IASStringAttributeEditor>,
	public CIASAttributeEditor
{
public:
	CIASStringAttributeEditor()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)

BEGIN_COM_MAP(CIASStringAttributeEditor)
	COM_INTERFACE_ENTRY(IIASAttributeEditor)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIASAttributeEditor overrides
protected:
	STDMETHOD(SetAttributeValue)(VARIANT *pValue);
	STDMETHOD(ShowEditor)( /*[in, out]*/ BSTR *pReserved );
	STDMETHOD(get_ValueAsString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ValueAsString)(/*[in]*/ BSTR newVal);

	STDMETHOD(get_ValueAsStringEx)(/*[out, retval]*/ BSTR *pVal, OUT EStringType* pType);
	STDMETHOD(put_ValueAsStringEx)(/*[in]*/ BSTR newVal, IN EStringType type);
};

#endif // _STRING_ATTRIBUTE_EDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasstringattributeeditor.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASStringAttributeEditor.cpp 

Abstract:

	Implementation file for the CIASStringAttributeEditor class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASStringAttributeEditor.h"
//
// where we can find declarations needed in this file:
//
#include "IASStringEditorPage.h"

#include "iashelper.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

BYTE	PREFIX___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD[]	= {0,0,0,0};
UINT	PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD = 4;
UINT	PREFIX_OFFSET_DATALENBYTE___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD = 3;	// 0 based index -- the fourth byte
UINT	PREFIX_LEN_DATALENBYTE___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD = 1;		// one byte



//////////////////////////////////////////////////////////////////////////////
/*++

CIASStringAttributeEditor::ShowEditor

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASStringAttributeEditor::ShowEditor( /*[in, out]*/ BSTR *pReserved )
{
	TRACE(_T("CIASStringAttributeEditor::ShowEditor\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())


		
		
	HRESULT hr = S_OK;

	try
	{
		
		// Load page title.
//		::CString			strPageTitle;
//		strPageTitle.LoadString(IDS_IAS_IP_EDITOR_TITLE);
//
//		CPropertySheet	propSheet( (LPCTSTR)strPageTitle );
		

		// 
		// IP Address Editor
		// 
		CIASPgSingleAttr	cppPage;
		

		// Initialize the page's data exchange fields with info from IAttributeInfo

		CComBSTR bstrName;
		CComBSTR bstrSyntax;
		ATTRIBUTESYNTAX asSyntax = IAS_SYNTAX_OCTETSTRING;
		ATTRIBUTEID Id = ATTRIBUTE_UNDEFINED;

		if( m_spIASAttributeInfo )
		{
			hr = m_spIASAttributeInfo->get_AttributeName( &bstrName );
			if( FAILED(hr) ) throw hr;

			hr = m_spIASAttributeInfo->get_SyntaxString( &bstrSyntax );
			if( FAILED(hr) ) throw hr;

			hr = m_spIASAttributeInfo->get_AttributeSyntax( &asSyntax );
			if( FAILED(hr) ) throw hr;

			hr = m_spIASAttributeInfo->get_AttributeID( &Id );
			if( FAILED(hr) ) throw hr;
		}

		cppPage.m_strAttrName	= bstrName;

		cppPage.m_AttrSyntax	= asSyntax;
		cppPage.m_nAttrId		= Id;
		
		cppPage.m_strAttrFormat	= bstrSyntax;

		// Attribute type is actually attribute ID in string format 
		WCHAR	szTempId[MAX_PATH];
		wsprintf(szTempId, _T("%ld"), Id);
		cppPage.m_strAttrType	= szTempId;


		// Initialize the page's data exchange fields with info from VARIANT value passed in.

		if ( V_VT(m_pvarValue) != VT_EMPTY )
		{
			EStringType			sp; 
			CComBSTR bstrTemp;
			get_ValueAsStringEx( &bstrTemp, &sp );
			cppPage.m_strAttrValue	= bstrTemp;
			cppPage.m_OctetStringType = sp;
		}


//		propSheet.AddPage(&cppPage);

//		int iResult = propSheet.DoModal();
		int iResult = cppPage.DoModal();
		if (IDOK == iResult)
		{
			CComBSTR bstrTemp = (LPCTSTR)cppPage.m_strAttrValue;
			put_ValueAsStringEx( bstrTemp, cppPage.m_OctetStringType);
		}
		else
		{
			hr = S_FALSE;
		}

		//
		// delete the property page pointer
		//
//		propSheet.RemovePage(&cppPage);

	}
	catch( HRESULT & hr )
	{
		return hr;	
	}
	catch(...)
	{
		return hr = E_FAIL;

	}

	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASStringAttributeEditor::SetAttributeValue

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASStringAttributeEditor::SetAttributeValue(VARIANT * pValue)
{
	TRACE(_T("CIASStringAttributeEditor::SetAttributeValue\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pValue )
	{
		return E_INVALIDARG;
	}
	
	// From Baogang's old code, it appears that this editor should accept 
	// either VT_BSTR, VT_BOOL, VT_I4 or VT_EMPTY.
	if( V_VT(pValue) !=  VT_BSTR 
		&& V_VT(pValue) !=  VT_BOOL 
		&& V_VT(pValue) !=  VT_I4
		&& V_VT(pValue) != VT_EMPTY 
		&& V_VT(pValue) != (VT_ARRAY | VT_UI1))
	{
		return E_INVALIDARG;
	}
	
	
	m_pvarValue = pValue;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASStringAttributeEditor::get_ValueAsString

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASStringAttributeEditor::get_ValueAsString(BSTR * pbstrDisplayText )
{
	TRACE(_T("CIASStringAttributeEditor::get_ValueAsString\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pbstrDisplayText )
	{
		return E_INVALIDARG;
	}
	if( ! m_spIASAttributeInfo || ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}

	HRESULT hr = S_OK;

	
	try
	{

		CComBSTR bstrDisplay;


		VARTYPE vType = V_VT(m_pvarValue); 

		switch( vType )
		{
		case VT_BOOL:
		{
			if( V_BOOL(m_pvarValue) )
			{
				// ISSUE: This is not localizable!!!
				// Should it be?  Ask Ashwin about this as some of
				// Baogang's error checking code was specifically looking
				// for either hardcoded "TRUE" or "FALSE".
				// ISSUE: I think that for Boolean syntax attributes,
				// we should be popping up the same type of attribute
				// editor as for the enumerables only with TRUE and FALSE in it.
				bstrDisplay = L"TRUE";
			}
			else
			{			
				bstrDisplay = L"FALSE";
			}

		}
			break;
		case VT_I4:
		{
			// The variant is some type which must be coerced to a bstr.
			CComVariant	varValue;
			// Make sure you pass a VT_EMPTY variant to VariantChangeType
			// or it will assert.
			// So don't do:		V_VT(&varValue) = VT_BSTR;
		
			hr = VariantChangeType(&varValue, m_pvarValue, VARIANT_NOVALUEPROP, VT_BSTR);
			if( FAILED( hr ) ) throw hr;

			bstrDisplay = V_BSTR(&varValue);
		}
			break;
		
		case VT_BSTR:
			bstrDisplay = V_BSTR(m_pvarValue);
			break;

		case VT_UI1 | VT_ARRAY:	// Treat as Octet string
			{	
				EStringType t;
				return get_ValueAsStringEx(pbstrDisplayText, &t);
			}
			break;
		
		default:
			// need to check what is happening here, 
			ASSERT(0);
			break;

		case VT_EMPTY:
			// do nothing -- we will fall through and return a blank string.
			break;
		}

		*pbstrDisplayText = bstrDisplay.Copy();

	}
	catch( HRESULT &hr )
	{
		return hr;
	}
	catch(...)
	{
		return E_FAIL;
	}

	
	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASStringAttributeEditor::put_ValueAsString

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASStringAttributeEditor::put_ValueAsString(BSTR newVal)
{
	TRACE(_T("CIASStringAttributeEditor::put_ValueAsString\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}
	if( m_spIASAttributeInfo == NULL )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}


	HRESULT hr = S_OK;


	try
	{

		CComBSTR bstrTemp = newVal;

		CComVariant varValue;
		V_VT(&varValue) = VT_BSTR;
		V_BSTR(&varValue) = bstrTemp.Copy();


		VARTYPE vType = V_VT(m_pvarValue); 

		// Initialize the variant that was passed in.
		VariantClear(m_pvarValue);

		{
			ATTRIBUTESYNTAX asSyntax;

			hr = m_spIASAttributeInfo->get_AttributeSyntax( &asSyntax );
			if( FAILED(hr) ) throw hr;

			// if this Octet string, this should be BSTR, no matter what it was before.
			if(asSyntax == IAS_SYNTAX_OCTETSTRING)
				vType = VT_BSTR;

			if ( VT_EMPTY == vType)
			{
				
				// decide the value type:
				switch (asSyntax)
				{
				case IAS_SYNTAX_BOOLEAN:			
					vType = VT_BOOL;	
					break;

				case IAS_SYNTAX_INTEGER:
				case IAS_SYNTAX_UNSIGNEDINTEGER:			
				case IAS_SYNTAX_ENUMERATOR:		
				case IAS_SYNTAX_INETADDR:		
					vType = VT_I4;		
					break;

				case IAS_SYNTAX_STRING:
				case IAS_SYNTAX_UTCTIME:
				case IAS_SYNTAX_PROVIDERSPECIFIC:
				case IAS_SYNTAX_OCTETSTRING:
					vType = VT_BSTR;	
					break;	

				default:
					_ASSERTE(FALSE);
					vType = VT_BSTR;
					break;
				}
			}
		}

		hr = VariantChangeType(m_pvarValue, &varValue, VARIANT_NOVALUEPROP, vType);
		if( FAILED( hr ) ) throw hr;
	
	}
	catch( HRESULT &hr )
	{
		return hr;
	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASStringAttributeEditor::get_ValueAsStringEx

--*/
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIASStringAttributeEditor::get_ValueAsStringEx(BSTR * pbstrDisplayText, EStringType* pType )
{
	TRACE(_T("CIASStringAttributeEditor::get_ValueAsString\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	ATTRIBUTESYNTAX asSyntax;
	m_spIASAttributeInfo->get_AttributeSyntax( &asSyntax );

	if(asSyntax != IAS_SYNTAX_OCTETSTRING)
	{	
		if(pType)
			*pType = STRING_TYPE_NORMAL;
		return get_ValueAsString(pbstrDisplayText);
	}

	// only care about IAS_SYNTAX_OCTETSTRING
	ASSERT(pType);

	VARTYPE 	vType = V_VT(m_pvarValue); 
	SAFEARRAY*	psa = NULL; 
	HRESULT 	hr = S_OK;
	
	switch(vType)
	{
	case VT_ARRAY | VT_UI1:
		psa = V_ARRAY(m_pvarValue);
		break;
		
	case VT_EMPTY:
		if(pType)
			*pType = STRING_TYPE_NULL;
		return get_ValueAsString(pbstrDisplayText);
		break;

	case VT_BSTR:
		if(pType)
			*pType = STRING_TYPE_NORMAL;
		return get_ValueAsString(pbstrDisplayText);
	
		break;
	default:
		ASSERT(0);		// should not happen, should correct some code
		if(pType)
			*pType = STRING_TYPE_NORMAL;
		return get_ValueAsString(pbstrDisplayText);
	
		break;
	};
	

	// no data is available , or the safe array is not valid, don't intepret the string
	if(psa == NULL || psa->cDims != 1 || psa->cbElements != 1)
	{
		*pType = STRING_TYPE_NULL;
		return hr;
	}

	// need to figure out how to convert the binary to text
	
	char*	pData = NULL;
	int		nBytes = 0;
	WCHAR*	pWStr = NULL;
	int		nWStr = 0;
	DWORD	dwErr = 0;
	BOOL	bStringConverted = FALSE;
	CComBSTR bstrDisplay;
	EStringType	sType = STRING_TYPE_NULL; 

	hr = ::SafeArrayAccessData( psa, (void**)&pData);
	if(hr != S_OK)
		return hr;

	nBytes = psa->rgsabound[0].cElements;
	ASSERT(pData);
	if(!pData)	goto Error;

#ifdef	__WE_WANT_TO_USE_UTF8_FOR_NORMAL_STRING_AS_WELL_
	// UTF8 requires the flag to be 0
	nWStr = MultiByteToWideChar(CP_UTF8, 0, pData,	nBytes, NULL, 0);

	if(nWStr == 0)
		dwErr = GetLastError();

#endif

	try{
	
#ifdef	__WE_WANT_TO_USE_UTF8_FOR_NORMAL_STRING_AS_WELL_
		if(nWStr != 0)	// succ
		{
			pWStr = new WCHAR[nWStr  + 2];		// for the 2 "s
			int 	i = 0;

			nWStr == MultiByteToWideChar(CP_UTF8, 0, pData,	nBytes, pWStr , nWStr);
			
			// if every char is printable
			for(i = 0; i < nWStr -1; i++)
			{
				if(iswprint(pWStr[i]) == 0)	
					break;
			}
					
			if(0 == nWStr || i != nWStr - 1 || pWStr[i] != L'\0')
			{
				delete[] pWStr;
				pWStr = NULL;
			}
			else
			{
				// added quotes 
				memmove(pWStr + 1, pWStr, nWStr * sizeof(WCHAR));
				pWStr[0] = L'"';
				pWStr[nWStr] = L'"';
				pWStr[nWStr + 1 ] = 0;	// new end of string
				
				bStringConverted = TRUE;	// to prevent from furthe convertion to HEX
				sType = STRING_TYPE_UNICODE;
			}
		}
#endif	// __WE_WANT_TO_USE_UTF8_FOR_NORMAL_STRING_AS_WELL_

// check if the attriabute is   RADIUS_ATTRIBUTE_TUNNEL_PASSWORD,
// this attribute has special format  --- remove 0's from the binary and
// try to conver to text
		{
			ATTRIBUTEID	Id;
			hr = m_spIASAttributeInfo->get_AttributeID( &Id );
			if( FAILED(hr) ) goto Error;

			if ( Id ==  RADIUS_ATTRIBUTE_TUNNEL_PASSWORD)
			{
//BYTE	PREFIX___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD[]	= {0,0,0,0};
//UINT	PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD = 4;
//UINT	PREFIX_OFFSET_DATALENBYTE___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD = 3;	// 0 based index -- the fourth byte
//UINT  PREFIX_LEN_DATALENBYTE___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD = 1
				if(PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD <=nBytes && 
						memcmp(pData, 
						PREFIX___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD, 
						PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD - PREFIX_LEN_DATALENBYTE___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD) == 0)
				{
					// correct prefix, 
					// remove the prefix
					pData += PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD;
					nBytes -= PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD;

					// try to convert to UNICODE TEXT using CP_ACP -- get length
					nWStr = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, pData, nBytes, NULL, 0);

					if(nWStr != 0)	// which means, we can not convert
					{
						pWStr = new WCHAR[nWStr + 1];
						// try to convert to UNICODE TEXT using CP_ACP
						nWStr = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, pData, nBytes, pWStr, nWStr);

						if(nWStr != 0)
						{
							int i = 0;
							for(i = 0; i < nWStr; i++)
							{
								if(iswprint(pWStr[i]) == 0)	
									break;
							}

							if( i == nWStr)	// all printable
							{
								bStringConverted = TRUE;
								pWStr[nWStr] = 0;	// NULL terminator
							}
						}

						if (!bStringConverted)	// undo the thing
						{
							// release the buffer
							delete[] pWStr;
							pWStr = NULL;
							nWStr = 0;
						}
					}
				}
			}
		}

		if(!bStringConverted)	// not converted above, convert to HEX string
		{
			nWStr = BinaryToHexString(pData, nBytes, NULL, 0); // find out the size of the buffer
			pWStr = new WCHAR[nWStr];

			ASSERT(pWStr);	// should have thrown if there is not enough memory

			BinaryToHexString(pData, nBytes, pWStr, nWStr);
			
			bStringConverted = TRUE;	// to prevent from furthe convertion to HEX
			sType = STRING_TYPE_HEX_FROM_BINARY;
		}

		if(bStringConverted)
		{
			bstrDisplay = pWStr;

			// fill in the output parameters
			*pbstrDisplayText = bstrDisplay.Copy();
			*pType = sType;
				
			delete[] pWStr;
			pWStr = NULL;
		}
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	
Error:
	if(pWStr)
		delete[] pWStr;
		
	if(psa)
		::SafeArrayUnaccessData(psa);
	return hr;

}


//////////////////////////////////////////////////////////////////////////////
/*++

*/


//////////////////////////////////////////////////////////////////////////////
/*++

CIASStringAttributeEditor::put_ValueAsStringEx

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASStringAttributeEditor::put_ValueAsStringEx(BSTR newVal, EStringType type)
{
	TRACE(_T("CIASStringAttributeEditor::put_ValueAsStringEx\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	ATTRIBUTESYNTAX asSyntax;
	m_spIASAttributeInfo->get_AttributeSyntax( &asSyntax );

	if(asSyntax != IAS_SYNTAX_OCTETSTRING)
		return put_ValueAsString(newVal);

	// only care about IAS_SYNTAX_OCTETSTRING
	HRESULT	hr = S_OK;
	char*	pData = NULL;
	int		nLen = 0;

	switch(type)
	{
	case	STRING_TYPE_NULL:
		// remove the data
		break;

	case	STRING_TYPE_NORMAL:
	case	STRING_TYPE_UNICODE:

#ifdef 	__WE_WANT_TO_USE_UTF8_FOR_NORMAL_STRING_AS_WELL_
		// need to convert UTF8 before passing into SafeArray
		nLen = WideCharToMultiByte(CP_UTF8, 0, newVal, -1, NULL, 0, NULL, NULL);
		if(nLen != 0) // when == 0 , need not to do anything
		{
			try{
				pData = new char[nLen];
				nLen = WideCharToMultiByte(CP_UTF8, 0, newVal, -1, pData, nLen, NULL, NULL);
			}
			catch(...)
			{
				hr = E_OUTOFMEMORY;
				goto Error;
			}
		}
		break;
#else
// check if the attriabute is   RADIUS_ATTRIBUTE_TUNNEL_PASSWORD,
// this attribute has special format  --- remove 0's from the binary and
// try to conver to text
		{
			ATTRIBUTEID	Id;
			hr = m_spIASAttributeInfo->get_AttributeID( &Id );
			if( FAILED(hr) ) goto Error;

			if ( Id ==  RADIUS_ATTRIBUTE_TUNNEL_PASSWORD)
			{
				BOOL	bUsedDefault = FALSE;
				UINT	nStrLen = wcslen(newVal);
				// try to convert to UNICODE TEXT using CP_ACP -- get length
				nLen = ::WideCharToMultiByte(CP_ACP, 0, newVal, nStrLen, NULL, 0, NULL, &bUsedDefault);

				if(nLen != 0)	// which means, we can not convert
				{
					try{
						pData = new char[nLen];
						ASSERT(pData);

						// try to convert to UNICODE TEXT using CP_ACP
						nLen = ::WideCharToMultiByte(CP_ACP, 0, newVal, nStrLen, pData, nLen, NULL, &bUsedDefault);

					}
					catch(...)
					{
						hr = E_OUTOFMEMORY;
						goto Error;
					}
				}

				
				if(nLen == 0 || bUsedDefault)	// failed to convert, then error message
				{
					// ANSI code page is allowed
					hr = E_INVALIDARG;

					AfxMessageBox(IDS_IAS_ERR_INVALIDCHARINPASSWORD);
					goto Error;

				}
			}
			else
				return put_ValueAsString(newVal);
		}
		break;
#endif
	case	STRING_TYPE_HEX_FROM_BINARY:
		// need to convert to binary before passing into SafeArray
		if(wcslen(newVal) != 0)
		{
			newVal =  GetValidVSAHexString(newVal);

			if(newVal == NULL)
			{
				hr = E_INVALIDARG;
				goto Error;
			}
			nLen = HexStringToBinary(newVal, NULL, 0);	// find out the size of the buffer
		}
		else
			nLen = 0;
		
		// get the binary
		try{
			pData = new char[nLen];
			ASSERT(pData);

			HexStringToBinary(newVal, pData, nLen);

		}
		catch(...)
		{
			hr = E_OUTOFMEMORY;
			goto Error;
		}
			
		break;

	default:
		ASSERT(0);	// this should not happen
		break;
		
	}

// check if the attriabute is   RADIUS_ATTRIBUTE_TUNNEL_PASSWORD,
// this attribute has special format  --- remove 0's from the binary and
// try to conver to text
	{
		ATTRIBUTEID	Id;
		hr = m_spIASAttributeInfo->get_AttributeID( &Id );
		if( FAILED(hr) ) goto Error;

		if ( Id ==  RADIUS_ATTRIBUTE_TUNNEL_PASSWORD)
		{
			char*	pData1 = NULL;
			// get the binary
//BYTE	PREFIX___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD[]	= {0,0,0,0};
//UINT	PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD = 4;
//UINT	PREFIX_OFFSET_DATALENBYTE___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD = 3;	// 0 based index -- the fourth byte
//UINT  PREFIX_LEN_DATALENBYTE___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD = 1
			try{
				pData1 = new char[nLen + PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD];
				ASSERT(pData1);

				memcpy(pData1, PREFIX___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD, PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD);
				unsigned char	lenByte = (unsigned char)nLen;
				memcpy(pData1 + PREFIX_OFFSET_DATALENBYTE___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD, &lenByte, PREFIX_LEN_DATALENBYTE___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD);
			}
			catch(...)
			{
				hr = E_OUTOFMEMORY;
				goto Error;
			}

			if(pData)
			{
				
				memcpy(pData1 + PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD, pData, nLen);

				delete [] pData;

				pData = pData1;
				nLen += PREFIX_LEN___RADIUS_ATTRIBUTE_TUNNEL_PASSWORD;
			}
		}
	}
	
	// put the data into the safe array
	VariantClear(m_pvarValue);

	if(pData)	// need to put data to safe array
	{
		SAFEARRAY*	psa = NULL;
		SAFEARRAYBOUND sab[1];
		sab[0].cElements = nLen;
		sab[0].lLbound = 0;

		try{
			psa = SafeArrayCreate(VT_UI1, 1, sab);
			char*	pByte = NULL;
			if(S_OK == SafeArrayAccessData(psa, (void**)&pByte))
			{
				ASSERT(pByte);
				memcpy(pByte, pData, nLen);
				SafeArrayUnaccessData(psa);
				V_VT(m_pvarValue) = VT_ARRAY | VT_UI1;
				V_ARRAY(m_pvarValue) = psa;
			}
			else
				SafeArrayDestroy(psa);
		}
		catch(...)
		{
			hr = E_OUTOFMEMORY;
			goto Error;
		}

		psa = NULL;

	};
	
Error:

	if(pData)
	{
		delete [] pData;
		pData = NULL;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasmultivaluedattributeeditor.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	IASMultivaluedAttributeEditor.cpp 

Abstract:

	Implementation file for the CIASMultivaluedAttributeEditor class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASMultivaluedAttributeEditor.h"
//
// where we can find declarations needed in this file:
//
#include "IASMultivaluedEditorPage.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CIASMultivaluedAttributeEditor::ShowEditor

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASMultivaluedAttributeEditor::ShowEditor( /*[in, out]*/ BSTR *pReserved )
{
	TRACE(_T("CIASMultivaluedAttributeEditor::ShowEditor\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())


	// Check for preconditions.
	if( ! m_spIASAttributeInfo )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}


	HRESULT hr = S_OK;

	try
	{
		
		// Load page title.
//		::CString			strPageTitle;
//		strPageTitle.LoadString(IDS_IAS_MULTIVALUED_EDITOR_TITLE);
//
//		CPropertySheet	propSheet( (LPCTSTR)strPageTitle );
		

		// 
		// Multivalued Attribute Editor
		// 
		CMultivaluedEditorPage	cppPage;
		

		// Initialize the page's data exchange fields with info from IAttributeInfo

		CComBSTR bstrName;
		CComBSTR bstrSyntax;
		ATTRIBUTEID Id = ATTRIBUTE_UNDEFINED;

		hr = m_spIASAttributeInfo->get_AttributeName( &bstrName );
		if( FAILED(hr) ) throw hr;

		hr = m_spIASAttributeInfo->get_SyntaxString( &bstrSyntax );
		if( FAILED(hr) ) throw hr;

		hr = m_spIASAttributeInfo->get_AttributeID( &Id );
		if( FAILED(hr) ) throw hr;
		
		cppPage.m_strAttrName	= bstrName;
		
		cppPage.m_strAttrFormat	= bstrSyntax;

		// Attribute type is actually attribute ID in string format 
		WCHAR	szTempId[MAX_PATH];
		wsprintf(szTempId, _T("%ld"), Id);
		cppPage.m_strAttrType	= szTempId;


		// Initialize the page's data exchange fields with info from VARIANT value passed in.

		cppPage.SetData( m_spIASAttributeInfo.p, m_pvarValue );


//		propSheet.AddPage(&cppPage);

//		int iResult = propSheet.DoModal();
		int iResult = cppPage.DoModal();
		if (IDOK == iResult)
		{
			// Tell the page to commit the changes made to the m_pvarValue
			// pointer it was given.  It will take care of
			// packaging the array of variants back into a variant safearray.
			cppPage.CommitArrayToVariant();
		}
		else
		{
			hr = S_FALSE;
		}

		//
		// Remove Page pointer from propSheet
		//
//		propSheet.RemovePage(&cppPage);

	}
	catch( HRESULT & hr )
	{
		return hr;	
	}
	catch(...)
	{
		return hr = E_FAIL;

	}
	
	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASMultivaluedAttributeEditor::SetAttributeValue

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASMultivaluedAttributeEditor::SetAttributeValue(VARIANT * pValue)
{
	TRACE(_T("CIASMultivaluedAttributeEditor::SetAttributeValue\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( pValue == NULL )
	{
		return E_INVALIDARG;
	}
	if( !(V_VT(pValue) & VT_ARRAY) &&  V_VT(pValue) != VT_EMPTY )
	{
		return E_INVALIDARG;
	}
	
	
	m_pvarValue = pValue;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASMultivaluedAttributeEditor::get_ValueAsString

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASMultivaluedAttributeEditor::get_ValueAsString(BSTR * pbstrDisplayText )
{
	TRACE(_T("CIASMultivaluedAttributeEditor::get_ValueAsString\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( pbstrDisplayText == NULL )
	{
		return E_INVALIDARG;
	}
	if( ! m_spIASAttributeInfo )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}
	if( V_VT( m_pvarValue ) != (VT_VARIANT | VT_ARRAY) && V_VT( m_pvarValue ) != VT_EMPTY )
	{
		return OLE_E_BLANK;
	}


	CComBSTR bstrDisplay;
	HRESULT hr;

	// If the variant we were passed is empty, display and empty string.
	if( V_VT( m_pvarValue ) == VT_EMPTY )
	{
		*pbstrDisplayText = bstrDisplay.Copy();


		return S_OK;
	}
	

	CComBSTR bstrQuote = "\"";
	CComBSTR bstrComma = ", ";
	

	try
	{
		

		CComPtr<IIASAttributeEditor> spIASAttributeEditor;

		// Get attribute editor.
		hr = SetUpAttributeEditor( m_spIASAttributeInfo.p, &spIASAttributeEditor );
		if( FAILED( hr ) ) throw hr;

		// This creates a new copy of the SAFEARRAY pointed to by m_pvarData
		// wrapped by the standard COleSafeArray instance m_osaValueList.
		COleSafeArray osaValueList = m_pvarValue;


		// Note: GetOneDimSize returns a DWORD, but signed should be OK for few elements here.
		long lSize = osaValueList.GetOneDimSize(); // number of multi-valued attrs.

		// Lock the safearray.  This wrapper class will unlock as soon as it goes out of scope.
		CMyOleSafeArrayLock osaLock( osaValueList );




		for (long lIndex = 0; lIndex < lSize; lIndex++)
		{
			VARIANT * pvar;
			osaValueList.PtrOfIndex( &lIndex, (void**) &pvar );


// Not sure if I like these.
//			bstrDisplay += bstrQuote;
			
			// Get a string to display for the attribute value.
			CComBSTR bstrVendor;
			CComBSTR bstrValue;
			CComBSTR bstrReserved;
			hr = spIASAttributeEditor->GetDisplayInfo(m_spIASAttributeInfo.p, pvar, &bstrVendor, &bstrValue, &bstrReserved );
			if( SUCCEEDED( hr ) )
			{
				bstrDisplay += bstrValue;
			}

// Not sure if I like these.
//			bstrDisplay += bstrQuote;

			// Special -- for all but last item, add comma after entry.
			if( lIndex < lSize - 1 )
			{
				bstrDisplay += bstrComma;
			}

		}

	}
	catch(...)
	{
		bstrDisplay = "@Error reading display value";
	}

	*pbstrDisplayText = bstrDisplay.Copy();

	if( *pbstrDisplayText )
	{
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasstringeditorpage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASStringEditorPage.h

Abstract:

	Declaration of the CIASPgSingleAttr class.

	This dialog allows the user to edit an attribute value consisting 
	of a generic string.

	See IASStringEditorPage.cpp for implementation.

Revision History:
	mmaguire 06/25/98	- revised Baogang Yao's original implementation 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_STRING_ATTRIBUTE_EDITOR_PAGE_H_)
#define _STRING_ATTRIBUTE_EDITOR_PAGE_H_

#include "iasstringattributeeditor.h"

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// IASPgSing.h : header file
//

// Limit of the string length for each attribute

#if 1
#define LENGTH_LIMIT_RADIUS_ATTRIBUTE_FILTER_ID		1024
#define	LENGTH_LIMIT_RADIUS_ATTRIBUTE_REPLY_MESSAGE	1024
#define	LENGTH_LIMIT_OTHERS							253
#else	// to test how this works
#define LENGTH_LIMIT_RADIUS_ATTRIBUTE_FILTER_ID		10
#define	LENGTH_LIMIT_RADIUS_ATTRIBUTE_REPLY_MESSAGE	12
#define	LENGTH_LIMIT_OTHERS							5
#endif
/////////////////////////////////////////////////////////////////////////////
// CIASPgSingleAttr dialog

class CIASPgSingleAttr : public CHelpDialog
{
	DECLARE_DYNCREATE(CIASPgSingleAttr)

// Construction
public:
	CIASPgSingleAttr();
	~CIASPgSingleAttr();

	int				m_nAttrId;
	ATTRIBUTESYNTAX m_AttrSyntax;
	EStringType		m_OctetStringType;	// only useful when Octet

	int				m_nLengthLimit;		// the length limit of the string attribute

// Dialog Data
	//{{AFX_DATA(CIASPgSingleAttr)
	enum { IDD = IDD_IAS_SINGLE_ATTR };
	::CString	m_strAttrValue;
	::CString	m_strAttrFormat;
	::CString	m_strAttrName;
	::CString	m_strAttrType;
	INT			m_nOctetFormatChoice;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIASPgSingleAttr)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
	BOOL m_fInitializing;

protected:
	// Generated message map functions
	//{{AFX_MSG(CIASPgSingleAttr)
	afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnRadioString();
	afx_msg void OnRadioHex();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _STRING_ATTRIBUTE_EDITOR_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasvendorspecificattributeeditor.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASVendorSpecificAttributeEditor.cpp 

Abstract:

	Implementation file for the CIASVendorSpecificAttributeEditor class.

Revision History:
	mmaguire 06/25/98	- created

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASVendorSpecificAttributeEditor.h"
//
// where we can find declarations needed in this file:
//
#include "IASVendorSpecificEditorPage.h"
#include "iashelper.h"
#include "vendors.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::get_RFCCompliant

	IIASVendorSpecificAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::get_RFCCompliant(BOOL * pVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::get_RFCCompliant\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	// Check for preconditions.
	if( ! pVal )
	{
		return E_INVALIDARG;
	}
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}

	*pVal =  ( m_fNonRFC ? FALSE : TRUE );

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::put_RFCCompliant

	IIASVendorSpecificAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::put_RFCCompliant(BOOL newVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::put_RFCCompliant\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())


	// Check for preconditions.
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}

	HRESULT hr;

	m_fNonRFC = ( newVal ? FALSE : TRUE );

	// Call this to take our member variables and pack 
	// them into the variant we were passed.
	hr = RepackVSA();

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::get_VendorID

	IIASVendorSpecificAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::get_VendorID(long * pVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::get_VendorID\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pVal )
	{
		return E_INVALIDARG;
	}
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}

	*pVal = m_dwVendorId;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::put_VendorID

	IIASVendorSpecificAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::put_VendorID(long newVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::put_VendorID\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr;

	// Check for preconditions.
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}


	m_dwVendorId = newVal;

	// Call this to take our member variables and pack 
	// them into the variant we were passed.
	hr = RepackVSA();

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::get_VSAType

	IIASVendorSpecificAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::get_VSAType(long * pVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::get_VSAType\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pVal )
	{
		return E_INVALIDARG;
	}
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}

	*pVal = m_dwVSAType;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::put_VSAType

	IIASVendorSpecificAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::put_VSAType(long newVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::put_VSAType\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr;

	// Check for preconditions.
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}


	m_dwVSAType = newVal;

	// Call this to take our member variables and pack 
	// them into the variant we were passed.
	hr = RepackVSA();

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::get_VSAFormat

	IIASVendorSpecificAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::get_VSAFormat(long * pVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::get_VSAFormat\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pVal )
	{
		return E_INVALIDARG;
	}
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}

	*pVal = m_dwVSAFormat;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::put_VSAFormat

	IIASVendorSpecificAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::put_VSAFormat(long newVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::get_VSAFormat\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr;


	// Check for preconditions.
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}


	m_dwVSAFormat = newVal;

	// Call this to take our member variables and pack 
	// them into the variant we were passed.
	hr = RepackVSA();

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::SetAttributeValue

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::SetAttributeValue(VARIANT * pValue)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::SetAttributeValue\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pValue )
	{
		return E_INVALIDARG;
	}
	if( V_VT( pValue ) != VT_EMPTY && V_VT( pValue ) != VT_BSTR )
	{
		return E_INVALIDARG;
	}

	m_pvarValue = pValue;
	
	HRESULT	hr = S_OK;
	

	// Reset our member variables.
	m_dwVendorId = 0;
	m_fNonRFC = TRUE;
	m_dwVSAFormat = 0;
	m_dwVSAType = 0;
	m_bstrDisplayValue.Empty();
	m_bstrVendorName.Empty();


	if( V_VT( m_pvarValue ) == VT_BSTR )
	{
		hr = UnpackVSA();
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::get_ValueAsString

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::get_ValueAsString(BSTR * pbstrDisplayText )
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::get_ValueAsString\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pbstrDisplayText )
	{
		return E_INVALIDARG;
	}
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}

	*pbstrDisplayText = m_bstrDisplayValue.Copy();

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::ShowEditor

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::ShowEditor( /*[in, out]*/ BSTR *pReserved )
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::ShowEditor\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	if( ! m_spIASAttributeInfo )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}

	HRESULT hr = S_OK;

	try
	{
		
		// Load page title.
//		::CString			strPageTitle;
//		strPageTitle.LoadString(IDS_IAS_IP_EDITOR_TITLE);

//		CPropertySheet	propSheet( (LPCTSTR)strPageTitle );
		

		// 
		// IP Address Editor
		// 
		CIASPgVendorSpecAttr	cppPage;
		

		// Initialize the page's data exchange fields with info from IAttributeInfo

		CComBSTR bstrName;

		hr = m_spIASAttributeInfo->get_AttributeName( &bstrName );
		if( FAILED(hr) ) throw hr;
		

		cppPage.m_strName		= bstrName;


		LONG lVendorIndex = 0;
		CComPtr<IIASNASVendors> spIASNASVendors;
		HRESULT hrTemp = CoCreateInstance( CLSID_IASNASVendors, NULL, CLSCTX_INPROC_SERVER, IID_IIASNASVendors, (LPVOID *) &spIASNASVendors );
		if( SUCCEEDED(hrTemp) ) 
		{
			hrTemp = spIASNASVendors->get_VendorIDToOrdinal(m_dwVendorId, &lVendorIndex);
		}

		// Note: If vendor information fails, we'll just use 0.
	
		if(hrTemp == S_OK)	// converted to index
		{
			cppPage.m_dVendorIndex	= lVendorIndex;
			cppPage.m_bVendorIndexAsID = FALSE;
		}
		else
		{
			cppPage.m_dVendorIndex	= m_dwVendorId;
			cppPage.m_bVendorIndexAsID = TRUE;
		}
		
		cppPage.m_fNonRFC		= m_fNonRFC;
		cppPage.m_dType		= m_dwVSAType;
		cppPage.m_dFormat		= m_dwVSAFormat;
		cppPage.m_strDispValue = m_bstrDisplayValue;



		// Initialize the page's data exchange fields with info from VARIANT value passed in.

		if ( V_VT(m_pvarValue) != VT_EMPTY )
		{
//			_ASSERTE( V_VT(m_pvarValue) == VT_I4 );
//			cppPage.m_dwIpAddr	= V_I4(m_pvarValue);
//			cppPage.m_fIpAddrPreSet = TRUE;
		}


//		propSheet.AddPage(&cppPage);

//		int iResult = propSheet.DoModal();
		int iResult = cppPage.DoModal();
		if (IDOK == iResult)
		{
			// Load values from property page into our member variables.


			LONG lVendorID = 0;
			if(cppPage.m_bVendorIndexAsID == TRUE)
				lVendorID = cppPage.m_dVendorIndex;
			else
				HRESULT hrTemp = spIASNASVendors->get_VendorID(cppPage.m_dVendorIndex, &lVendorID);

			// Note: If vendor information fails, we'll just use 0.

			m_dwVendorId		= lVendorID;
			m_fNonRFC			= cppPage.m_fNonRFC;
			m_dwVSAType			= cppPage.m_dType;
			m_dwVSAFormat		= cppPage.m_dFormat;
			m_bstrDisplayValue	= cppPage.m_strDispValue;


			// Call this to take our member variables and pack 
			// them into the variant we were passed.
			hr = RepackVSA();
		}
		else
		{
			hr = S_FALSE;
		}

		//
		// delete the property page pointer
		//
//		propSheet.RemovePage(&cppPage);


	}
	catch( HRESULT & hr )
	{
		return hr;	
	}
	catch(...)
	{
		return hr = E_FAIL;

	}
	
	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::put_ValueAsString

	IIASAttributeEditor interface implementation

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::put_ValueAsString(BSTR newVal)
{
	TRACE(_T("CIASEnumerableAttributeEditor::put_ValueAsString\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! m_pvarValue )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}

 
	HRESULT hr;

	m_bstrDisplayValue = newVal;

	// Call this to take our member variables and pack 
	// them into the variant we were passed.
	hr = RepackVSA();


	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::UnpackVSA

	Parses a vendor specific attribute string into its consituent data.
	Stores this data in several member variables of this class.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::UnpackVSA()
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::UnpackVSA\n"));
	// Attempt to unpack the fields in the Vendor Specific Attribute
	// And store them in our member variables.

	HRESULT hr;

	if( V_VT(m_pvarValue) != VT_BSTR )
	{
		return E_FAIL;
	}

	::CString	cstrValue = V_BSTR(m_pvarValue);
	::CString cstrDispValue;

	// We will use Baogang's helper functions to extract the required info
	// from the vendor specific attribute's value.
	hr = ::GetVendorSpecificInfo(	  cstrValue
								, m_dwVendorId
								, m_fNonRFC
								, m_dwVSAFormat
								, m_dwVSAType
								, cstrDispValue
								);
	if( FAILED(hr) )
	{
		return hr;
	}


	// Save away the display string.
	m_bstrDisplayValue = (LPCTSTR) cstrDispValue;
		

	// Save away the vendor name in our member variable.

	CComPtr<IIASNASVendors> spIASNASVendors;
	HRESULT hrTemp = CoCreateInstance( CLSID_IASNASVendors, NULL, CLSCTX_INPROC_SERVER, IID_IIASNASVendors, (LPVOID *) &spIASNASVendors );
	if( SUCCEEDED(hrTemp) )
	{
		LONG lVendorIndex;
		hrTemp = spIASNASVendors->get_VendorIDToOrdinal(m_dwVendorId, &lVendorIndex);
		if( S_OK == hrTemp )
		{
			CComBSTR bstrVendorName;
			hrTemp = spIASNASVendors->get_VendorName( lVendorIndex, &m_bstrVendorName );
		}
		else
		{
				hr = ::MakeVendorNameFromVendorID(m_dwVendorId, &m_bstrVendorName );
		}
	}

	// Ignore any HRESULT from above.
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::RepackVSA

	Takes several member variables of this class and packs them
	into a vendor specific attribute string.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::RepackVSA()
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::RepackVSA\n"));

	HRESULT hr;

	::CString			cstrValue;
	::CString			cstrDisplayValue = m_bstrDisplayValue;

	// We will use Baogang's helper function to pack the required info
	// into the vendor specific attribute's value.
	hr = ::SetVendorSpecificInfo(	cstrValue, 
									m_dwVendorId, 
									m_fNonRFC,
									m_dwVSAFormat, 
									m_dwVSAType, 
									cstrDisplayValue
								);

	if( FAILED( hr ) )
	{
		return hr;
	}

	VariantClear(m_pvarValue);
	V_VT(m_pvarValue)	= VT_BSTR;
	V_BSTR(m_pvarValue)	= SysAllocString(cstrValue);

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::get_VendorName

	The default implementation of get_VendorName queries the AttributeInfo for this information.
		
	In the case of the RADIUS Vendor Specific Attribute (ID ==26), the AttributeInfo 
	itself will not have the information about vendor ID, rather this 
	information will be encapsulated in the attribute value itself.
		
	For this reason, UI clients should always query an attribute editor for vendor 
	information rather than the attribute itself.

	e.g., in the case of VSA's, the AttributeInfo will always return 
	RADIUS Standard for vendor type.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::get_VendorName(BSTR * pVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::get_VendorName\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	// Check for preconditions.
	if( ! pVal )
	{
		return E_INVALIDARG;
	}
	if( ! m_spIASAttributeInfo )
	{
		// We are not initialized properly.
		return OLE_E_BLANK;
	}
	
	HRESULT hr = S_OK;

	try
	{

		if( ! m_pvarValue )
		{
			// We have not been set with a value, so we can't read vendor ID
			// out of that string.  
			// Just give back the default implementations' answer,
			// which in this case will be "RADIUS standard".

			hr = CIASAttributeEditor::get_VendorName( pVal );
		}
		else
		{
			// We have a value, so pass back the vendor name which we 
			// extracted out of that value.

			*pVal = m_bstrVendorName.Copy();
		}

	}
	catch(HRESULT &hr)
	{
		return hr;
	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificAttributeEditor::put_VendorName

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASVendorSpecificAttributeEditor::put_VendorName(BSTR newVal)
{
	TRACE(_T("CIASVendorSpecificAttributeEditor::put_VendorName\n"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	return E_NOTIMPL;

	// Check for preconditions.
//	if( ! m_spIASAttributeInfo )
//	{
//		// We are not initialized properly.
//		return OLE_E_BLANK;
//	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasstringeditorpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASStringEditorPage.cpp

Abstract:

	Implementation file for the CIASPgSingleAttr class.

Revision History:
	mmaguire 06/25/98	- revised Baogang Yao's original implementation

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "IASStringEditorPage.h"
//
// where we can find declarations needed in this file:
//
#include "iashelper.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

#include "dlgcshlp.h"

IMPLEMENT_DYNCREATE(CIASPgSingleAttr, CHelpDialog)



BEGIN_MESSAGE_MAP(CIASPgSingleAttr, CHelpDialog)
	//{{AFX_MSG_MAP(CIASPgSingleAttr)
//	ON_WM_CONTEXTMENU()
//	ON_WM_HELPINFO()
	ON_BN_CLICKED(IDC_RADIO_STRING, OnRadioString)
	ON_BN_CLICKED(IDC_RADIO_HEX, OnRadioHex)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgSingleAttr::CIASPgSingleAttr

  Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CIASPgSingleAttr::CIASPgSingleAttr() : CHelpDialog(CIASPgSingleAttr::IDD)
{
	TRACE(_T("CIASPgSingleAttr::CIASPgSingleAttr\n"));

	//{{AFX_DATA_INIT(CIASPgSingleAttr)
	m_strAttrValue = _T("");
	m_strAttrFormat = _T("");
	m_strAttrName = _T("");
	m_strAttrType = _T("");
	m_nOctetFormatChoice = -1;
	//}}AFX_DATA_INIT

	m_OctetStringType = STRING_TYPE_NULL;
	m_nLengthLimit = LENGTH_LIMIT_OTHERS;
	
	//
	// set the initializing flag -- we shouldn't call custom data verification
	// routine when initializing, because otherwise we will report an error
	// for an attribute whose value has never been initialized
	//
	m_fInitializing = TRUE;

}



void CIASPgSingleAttr::OnRadioHex() 
{
	USES_CONVERSION;
	// convert HEX String to Unicode string, assume HEX is UTF8
	if(m_nOctetFormatChoice == 1)	// no change
		return;

	m_nOctetFormatChoice = 1;

	// Take value from text field
	CWnd* pEdit = GetDlgItem(IDC_IAS_EDIT_ATTRVALUE);

     // limit the control max-chars automatically
    ::SendMessage(pEdit->GetSafeHwnd(), EM_LIMITTEXT, m_nLengthLimit * 2, 0);

	::CString str;

	ASSERT(pEdit);

#ifdef __WE_WANT_TO_USE_UTF8_FOR_NORMAL_STRING_AS_WELL_
	pEdit->GetWindowText(str);

	// change it to Multibyte
	int	nLen = WideCharToMultiByte(CP_UTF8, 0, T2W((LPTSTR)(LPCTSTR)str), -1, NULL, 0, NULL, NULL);
	char* pData = NULL;
	WCHAR*	pWStr = NULL;
	int nWStr = 0;
	if(nLen != 0) // when == 0 , need not to do anything
	{
		try{
			pData = new char[nLen];
			nLen = WideCharToMultiByte(CP_UTF8, 0, T2W((LPTSTR)(LPCTSTR)str), -1, pData, nLen, NULL, NULL);
			nWStr = BinaryToHexString(pData, nLen, NULL, 0);
			pWStr = new WCHAR[nWStr];

			// the get the HexString out
			BinaryToHexString(pData, nLen, pWStr, nWStr);
			
		}
		catch(...)
		{
		;
		}
	}

	str = pWStr;
	delete[]  pWStr;
	delete[]  pData;
#endif // __WE_WANT_TO_USE_UTF8_FOR_NORMAL_STRING_AS_WELL_

	// assign it to text field
	pEdit->SetWindowText(str);
	
	return;
}

void CIASPgSingleAttr::OnRadioString() 
{
	if(m_nOctetFormatChoice == 0)	//no change
		return;

	m_nOctetFormatChoice = 0;
	// convert Unicde string to UTFs and display as hex
	// Take value from text field
	CWnd* pEdit = GetDlgItem(IDC_IAS_EDIT_ATTRVALUE);

     // limit the control max-chars automatically
    ::SendMessage(pEdit->GetSafeHwnd(), EM_LIMITTEXT, m_nLengthLimit, 0);

	::CString str;

	ASSERT(pEdit);

#ifdef __WE_WANT_TO_USE_UTF8_FOR_NORMAL_STRING_AS_WELL_

	pEdit->GetWindowText(str);


	// change it to Multibyte
	// need to convert UTF8 
	int	nLen = 0;
	char* pData = NULL;
	WCHAR*	pWStr = NULL;
	int nWStr= 0;
	nLen = HexStringToBinary((LPTSTR)(LPCTSTR)str, NULL, 0);	// find out the size of the buffer
	// get the binary
	if(nLen != 0)
	{
		try
		{
			pData = new char[nLen];
			ASSERT(pData);

			HexStringToBinary((LPTSTR)(LPCTSTR)str, pData, nLen);

			// UTF8 requires the flag to be 0
			nWStr = MultiByteToWideChar(CP_UTF8, 0, pData,	nLen, NULL, 0);


			if(nWStr != 0)	// succ
			{
				pWStr = new WCHAR[nWStr+1];	// + 1 for the addtional 0
				int 	i = 0;

				pWStr[nWStr] = 0;
				nWStr == MultiByteToWideChar(CP_UTF8, 0, pData,	nLen, pWStr, nWStr);
			
				// if every char is printable
				for(i = 0; i < nWStr -1; i++)
				{
					if(iswprint(pWStr[i]) == 0)	
						break;
				}
						
				if(0 == nWStr || i != nWStr - 1)
				{
					delete[] pWStr;
					pWStr = NULL;
				}
			}
		}
		catch(...)
		{
			;
		}
	}

	str = pWStr;
	delete[]  pWStr;
	delete[]  pData;

#endif

	// assign it to text field
	pEdit->SetWindowText(str);
	
	return;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgSingleAttr::~CIASPgSingleAttr

--*/
//////////////////////////////////////////////////////////////////////////////
CIASPgSingleAttr::~CIASPgSingleAttr()
{
	TRACE(_T("CIASPgSingleAttr::~CIASPgSingleAttr\n"));

}


BOOL CIASPgSingleAttr::OnInitDialog()
{
	// determine what's the length limit of the field
	if(m_nAttrId == RADIUS_ATTRIBUTE_FILTER_ID)
	{
		m_nLengthLimit = LENGTH_LIMIT_RADIUS_ATTRIBUTE_FILTER_ID;

	} 
	else if (m_nAttrId == RADIUS_ATTRIBUTE_REPLY_MESSAGE)
	{
		m_nLengthLimit = LENGTH_LIMIT_RADIUS_ATTRIBUTE_REPLY_MESSAGE;
	}
	else
	{
		m_nLengthLimit = LENGTH_LIMIT_OTHERS;
	}
	
	if (m_AttrSyntax == IAS_SYNTAX_OCTETSTRING)
	{
		// turn off the text string "Attribute value"
		GetDlgItem(IDC_TXT_ATTRIBUTEVALUE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TXT_CHOOSEFORMAT)->ShowWindow(SW_SHOW);

		GetDlgItem(IDC_RADIO_STRING)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_RADIO_HEX)->ShowWindow(SW_SHOW);
		

		// turn on the text string to allow user choose input type
		if(m_OctetStringType == STRING_TYPE_HEX_FROM_BINARY)
			m_nOctetFormatChoice = 1;	// hex string
		else
		{
			int n = m_strAttrValue.GetLength();

			// remove quotes
			if(n > 0 && m_strAttrValue[0] == _T('"') && m_strAttrValue[n - 1] == _T('"'))
			{
				m_strAttrValue = m_strAttrValue.Mid(1, n - 2);
			}
			m_nOctetFormatChoice = 0;	// default to string
		}
				
	}
	else
	{
		GetDlgItem(IDC_TXT_ATTRIBUTEVALUE)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_TXT_CHOOSEFORMAT)->ShowWindow(SW_HIDE);

		GetDlgItem(IDC_RADIO_STRING)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_RADIO_HEX)->ShowWindow(SW_HIDE);
	}

	CHelpDialog::OnInitDialog();


	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgSingleAttr::DoDataExchange

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASPgSingleAttr::DoDataExchange(CDataExchange* pDX)
{
	TRACE(_T("CIASPgSingleAttr::DoDataExchange\n"));

	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIASPgSingleAttr)
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRFORMAT, m_strAttrFormat);
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRNAME, m_strAttrName);
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRTYPE, m_strAttrType);
	DDX_Radio(pDX, IDC_RADIO_STRING, m_nOctetFormatChoice);
	DDX_Text(pDX, IDC_IAS_EDIT_ATTRVALUE, m_strAttrValue);
	
	// if user input hex, then we should double the limit
	if(IAS_SYNTAX_OCTETSTRING == m_AttrSyntax && m_nOctetFormatChoice == 1)
		DDV_MaxChars(pDX, m_strAttrValue, m_nLengthLimit * 2);
	else
		DDV_MaxChars(pDX, m_strAttrValue, m_nLengthLimit);

	//}}AFX_DATA_MAP

	if ( m_fInitializing )
	{
		//
		// set the initializing flag -- we shouldn't call custom data verification
		// routine when initializing, because otherwise we will report an error
		// for an attribute whose value has never been initialized
		//
		m_fInitializing = FALSE;
	}
	else
	{
		switch ( m_AttrSyntax )
		{
		case IAS_SYNTAX_BOOLEAN		: DDV_BoolStr(pDX, m_strAttrValue); break;
		case IAS_SYNTAX_INTEGER		: DDV_IntegerStr(pDX, m_strAttrValue); break;
		case IAS_SYNTAX_UNSIGNEDINTEGER	: DDV_Unsigned_IntegerStr(pDX, m_strAttrValue); break;
		case IAS_SYNTAX_ENUMERATOR	:
		case IAS_SYNTAX_INETADDR		:
		case IAS_SYNTAX_STRING		:
			break;
		case IAS_SYNTAX_OCTETSTRING	:
			// do processing based on 
			if(!m_strAttrValue.IsEmpty() && m_nOctetFormatChoice == 1)	DDV_VSA_HexString(pDX, m_strAttrValue);
			
			break;
		case IAS_SYNTAX_UTCTIME		:
		case IAS_SYNTAX_PROVIDERSPECIFIC	:
		default:	
							// do nothing  -- just normal string
							break;
		}
	}

	// calculate string value based on display string typed in by user
	if(pDX->m_bSaveAndValidate && m_AttrSyntax == IAS_SYNTAX_OCTETSTRING)
	{
		switch(m_nOctetFormatChoice)
		{
		case	0:	// Unicode string , need to convert to UTF-8
			m_OctetStringType = STRING_TYPE_UNICODE;
			break;

		case	1:	// HEX, need to covert to binary
			m_OctetStringType = STRING_TYPE_HEX_FROM_BINARY;
			break;

		default:
			ASSERT(0);	// this should not happen
			break;

		}
	}

}



/////////////////////////////////////////////////////////////////////////////
// CIASPgSingleAttr message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasvendorspecificeditorpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASVendorSpecificEditorPage.cpp

Abstract:

	Implementation file for the CIASPgVendorSpecAttr class.

Revision History:
	mmaguire 06/25/98	- revised Baogang Yao's original implementation

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
#include <winsock2.h>
//
// where we can find declaration for main class in this file:
//
#include "IASVendorSpecificEditorPage.h"
//
// where we can find declarations needed in this file:
//
#include "iashelper.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

// Some forward declarations of classes used only in this file.




/////////////////////////////////////////////////////////////////////////////
// CIASVendorSpecificConformsYes dialog

class CIASVendorSpecificConformsYes: public CHelpDialog
{
	DECLARE_DYNCREATE(CIASVendorSpecificConformsYes)

// Construction
public:
	CIASVendorSpecificConformsYes();
	~CIASVendorSpecificConformsYes();

// Dialog Data
	//{{AFX_DATA(CIASVendorSpecificConformsYes)
	enum { IDD = IDD_IAS_VENDORSPEC_ATTR_CONFORMS_YES };
	::CString	m_strDispValue;
	int		m_dType;
	int		m_dFormat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIASVendorSpecificConformsYes)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
	BOOL m_fInitializing;
protected:
	// Generated message map functions
	//{{AFX_MSG(CIASVendorSpecificConformsYes)
	virtual BOOL OnInitDialog();
//	afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnSelchangeFormat();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};







/////////////////////////////////////////////////////////////////////////////
// CIASVendorSpecificConformsNo dialog

class CIASVendorSpecificConformsNo: public CHelpDialog
{
	DECLARE_DYNCREATE(CIASVendorSpecificConformsNo)

// Construction
public:
	CIASVendorSpecificConformsNo();
	~CIASVendorSpecificConformsNo();


// Dialog Data
	//{{AFX_DATA(CIASVendorSpecificConformsNo)
	enum { IDD = IDD_IAS_VENDORSPEC_ATTR_CONFORMS_NO };
	::CString	m_strDispValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIASVendorSpecificConformsNo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
	BOOL m_fInitializing;
protected:
	// Generated message map functions
	//{{AFX_MSG(CIASVendorSpecificConformsNo)
	virtual BOOL OnInitDialog();
//	afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};




//////////////////////////////////////////////////////////////////////////////
// Implementation of the CIASPgVendorSpecAttr page.







IMPLEMENT_DYNCREATE(CIASPgVendorSpecAttr, CHelpDialog)



BEGIN_MESSAGE_MAP(CIASPgVendorSpecAttr, CHelpDialog)
	//{{AFX_MSG_MAP(CIASPgVendorSpecAttr)
	ON_BN_CLICKED(IDC_IAS_RADIO_HEX, OnRadioHex)
	ON_BN_CLICKED(IDC_IAS_RADIO_RADIUS, OnRadioRadius)
	ON_BN_CLICKED(IDC_RADIO_SELECTFROMLIST, OnRadioSelectFromList)
	ON_BN_CLICKED(IDC_RADIO_ENTERVERDORID, OnRadioEnterVendorId)
	ON_BN_CLICKED(IDC_IAS_BUTTON_CONFIGURE, OnButtonConfigure)
	ON_CBN_SELCHANGE(IDC_IAS_COMBO_VENDORID, OnVendorIdListSelChange)
//	ON_WM_CONTEXTMENU()
//	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgVendorSpecAttr::CIASPgVendorSpecAttr

  Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CIASPgVendorSpecAttr::CIASPgVendorSpecAttr() : CHelpDialog(CIASPgVendorSpecAttr::IDD)
{
	TRACE(_T("CIASPgVendorSpecAttr::CIASPgVendorSpecAttr\n"));

	m_strDispValue = _T("");

	//{{AFX_DATA_INIT(CIASPgVendorSpecAttr)
	m_strName = _T("");
	m_dType = 0;
	m_dFormat = -1;
	m_dVendorIndex = -1;
	//}}AFX_DATA_INIT

	m_bVendorIndexAsID = FALSE;
	
	m_fInitializing = TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgVendorSpecAttr::~CIASPgVendorSpecAttr

--*/
//////////////////////////////////////////////////////////////////////////////
CIASPgVendorSpecAttr::~CIASPgVendorSpecAttr()
{
	TRACE(_T("CIASPgVendorSpecAttr::~CIASPgVendorSpecAttr\n"));

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgVendorSpecAttr::DoDataExchange

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASPgVendorSpecAttr::DoDataExchange(CDataExchange* pDX)
{
	TRACE(_T("CIASPgVendorSpecAttr::DoDataExchange\n"));

	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIASPgVendorSpecAttr)
	DDX_Text(pDX, IDC_IAS_STATIC_ATTRNAME, m_strName);
	if (m_bVendorIndexAsID)
	{
		DDX_Text(pDX, IDC_EDIT_VENDORID, m_dVendorIndex);
	}
	
	//}}AFX_DATA_MAP

	if ( m_fInitializing )
	{
		//
		// set the initializing flag -- we shouldn't call custom data verification
		// routine when initializing, because otherwise we will report an error
		// for an attribute whose value has never been initialized
		//
		m_fInitializing = FALSE;
	}
	else
	{
		// Even though we validate data in the sub-dialogs,
		// we need to re-validate it here to make sure, e.g.
		// the user doesn't leave this dialog after setting
		// a value with the Non-conformant (hex) editor but then
		// switch the radio button to be conformant with a
		// decimal format type.

		// ISSUE: It would be nice if the error messages from the
		// validation routines below were a little more sensitive
		// to our current context and perhaps mentioned
		// something to the effect that the user should
		// click the "Configure Attribute..." button.

		if ( m_fNonRFC )
		{
			// hexadecimal string
			if(!m_strDispValue.IsEmpty())
				DDV_VSA_HexString(pDX, m_strDispValue);
		}
		else
		{
			// RFC compatible format  -- check data validation.
			switch ( m_dFormat )
			{
			case 1:  // decimal integer
				{
					if(!m_strDispValue.IsEmpty())
						DDV_Unsigned_IntegerStr(pDX, m_strDispValue);
				}
				break;

			case 2:	// hexadecimal string
				{
					if(!m_strDispValue.IsEmpty())
						DDV_VSA_HexString(pDX, m_strDispValue);
				}
				break;

			default:  // no error checking for other case
				break;

			} // switch

		}  // else



	} // else
}



/////////////////////////////////////////////////////////////////////////////
// CIASPgVendorSpecAttr message handlers



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgVendorSpecAttr::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CIASPgVendorSpecAttr::OnInitDialog()
{
	TRACE(_T("CIASPgVendorSpecAttr::OnInitDialog\n"));

    // Initialize the vendor id combo box.
	CComboBox *pVendorBox = (CComboBox *) GetDlgItem(IDC_IAS_COMBO_VENDORID);
	CEdit*		pVendorIdEdit = (CEdit*) GetDlgItem(IDC_EDIT_VENDORID);
	_ASSERTE( pVendorBox != NULL );
	_ASSERTE( pVendorIdEdit != NULL );

	// determine if to use edit box or list
	if (m_bVendorIndexAsID)
	{
		CheckDlgButton(IDC_RADIO_SELECTFROMLIST, 0); // uncheck the RADIUS radio button
		pVendorBox->EnableWindow(0);
		CheckDlgButton(IDC_RADIO_ENTERVERDORID, 1);    // check 
		pVendorIdEdit->EnableWindow(1);
	}
	else
	{
		CheckDlgButton(IDC_RADIO_SELECTFROMLIST, 1); // check the RADIUS radio button
		pVendorBox->EnableWindow(1);
		CheckDlgButton(IDC_RADIO_ENTERVERDORID, 0);    // uncheck 
		pVendorIdEdit->EnableWindow(0);
	}
	
	CHelpDialog::OnInitDialog();

	CComPtr<IIASNASVendors> spIASNASVendors;
	HRESULT hrTemp = CoCreateInstance( CLSID_IASNASVendors, NULL, CLSCTX_INPROC_SERVER, IID_IIASNASVendors, (LPVOID *) &spIASNASVendors );
	if( SUCCEEDED(hrTemp) )
	{
		LONG lSize;
		hrTemp = spIASNASVendors->get_Size( &lSize );
		if( SUCCEEDED(hrTemp) )
		{
			for ( LONG lIndex = 0; lIndex < lSize ; ++lIndex )
			{
				CComBSTR bstrVendorName;
				hrTemp = spIASNASVendors->get_VendorName( lIndex, &bstrVendorName );

				// Note: If vendor information fails us, we'll put a blank string.

				int iComboIndex = pVendorBox->AddString( bstrVendorName );

				if(iComboIndex != CB_ERR)
				{
					pVendorBox->SetItemData(iComboIndex, lIndex);
					// if selected
					if(!m_bVendorIndexAsID && m_dVendorIndex == lIndex)
						pVendorBox->SetCurSel(iComboIndex);
				}
			}
		}
	}


	if (m_fNonRFC)
	{
		CheckDlgButton(IDC_IAS_RADIO_RADIUS, 0); // uncheck the RADIUS radio button
		CheckDlgButton(IDC_IAS_RADIO_HEX, 1);    // check the non-rfc button
	}
	else
	{
		CheckDlgButton(IDC_IAS_RADIO_RADIUS, 1); // uncheck the RADIUS radio button
		CheckDlgButton(IDC_IAS_RADIO_HEX, 0);    // check the non-rfc button
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgVendorSpecAttr::OnRadioSelectFromList

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASPgVendorSpecAttr::OnRadioSelectFromList()
{
	TRACE(_T("CIASPgVendorSpecAttr::OnRadioSelectFromList\n"));

	if ( IsDlgButtonChecked(IDC_RADIO_SELECTFROMLIST) )
	{
		m_bVendorIndexAsID = FALSE;
	}

    // Initialize the vendor id combo box.
	CComboBox *pVendorBox = (CComboBox *) GetDlgItem(IDC_IAS_COMBO_VENDORID);
	CEdit*		pVendorIdEdit = (CEdit*) GetDlgItem(IDC_EDIT_VENDORID);
	_ASSERTE( pVendorBox != NULL );
	_ASSERTE( pVendorIdEdit != NULL );

	// determine if to use edit box or list
	if (m_bVendorIndexAsID)
	{
		pVendorBox->EnableWindow(0);
		pVendorIdEdit->EnableWindow(1);
	}
	else
	{
		pVendorBox->EnableWindow(1);
		pVendorIdEdit->EnableWindow(0);
	}
}


// selection change ... with combo box
void CIASPgVendorSpecAttr::OnVendorIdListSelChange()
{
	if(m_bVendorIndexAsID)
	{
		// doesn't matter
	}
	else
	{
		CComboBox *pVendorBox = (CComboBox *) GetDlgItem(IDC_IAS_COMBO_VENDORID);

		_ASSERTE(pVendorBox != NULL);
		int iSel = pVendorBox->GetCurSel();

		if(iSel != CB_ERR)
		{
			m_dVendorIndex = pVendorBox->GetItemData(iSel);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgVendorSpecAttr::OnRadioEnterVendorId

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASPgVendorSpecAttr::OnRadioEnterVendorId()
{
	TRACE(_T("CIASPgVendorSpecAttr::OnRadioEnterVendorId\n"));

	if ( IsDlgButtonChecked(IDC_RADIO_ENTERVERDORID) )
	{
		m_bVendorIndexAsID = TRUE;
	}
    // Initialize the vendor id combo box.
	CComboBox *pVendorBox = (CComboBox *) GetDlgItem(IDC_IAS_COMBO_VENDORID);
	CEdit*		pVendorIdEdit = (CEdit*) GetDlgItem(IDC_EDIT_VENDORID);
	_ASSERTE( pVendorBox != NULL );
	_ASSERTE( pVendorIdEdit != NULL );

	// determine if to use edit box or list
	if (m_bVendorIndexAsID)
	{
		pVendorBox->EnableWindow(0);
		pVendorIdEdit->EnableWindow(1);
	}
	else
	{
		pVendorBox->EnableWindow(1);
		pVendorIdEdit->EnableWindow(0);
	}
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgVendorSpecAttr::OnRadioHex

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASPgVendorSpecAttr::OnRadioHex()
{
	TRACE(_T("CIASPgVendorSpecAttr::OnRadioHex\n"));

	if ( IsDlgButtonChecked(IDC_IAS_RADIO_HEX) )
	{
		m_fNonRFC = TRUE;
	}

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgVendorSpecAttr::OnRadioRadius

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASPgVendorSpecAttr::OnRadioRadius()
{
	TRACE(_T("CIASPgVendorSpecAttr::OnRadioRadius\n"));

	if ( IsDlgButtonChecked(IDC_IAS_RADIO_RADIUS) )
	{
		m_fNonRFC = FALSE;
	}
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASPgVendorSpecAttr::OnButtonConfigure

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASPgVendorSpecAttr::OnButtonConfigure()
{
	TRACE_FUNCTION("CIASPgVendorSpecAttr::OnButtonConfigure");

	HRESULT hr;

	try
	{
		CHelpDialog * dialog = NULL;

		if( m_fNonRFC )
		{
			CIASVendorSpecificConformsNo dialog;

			// Initialize the sub-dialog.
			dialog.m_strDispValue = m_strDispValue;

			int iResult = dialog.DoModal();
			if (IDOK == iResult)
			{
				// Get data from sub-dialog and store values
				// to our own variables
				m_strDispValue = dialog.m_strDispValue;

			}			
			else
			{

			}
		
		}
		else
		{
			CIASVendorSpecificConformsYes dialog;

			// Initialize the sub-dialog.
			dialog.m_strDispValue = m_strDispValue;
			dialog.m_dType = m_dType;
			dialog.m_dFormat = m_dFormat;

				
			int iResult = dialog.DoModal();
			if (IDOK == iResult)
			{
				// Get data from sub-dialog and store values
				// to our own variables
				m_strDispValue = dialog.m_strDispValue;
				m_dType = dialog.m_dType;
				m_dFormat = dialog.m_dFormat;

			}
			else
			{

			}

		}


	}
	catch(...)
	{
		// Error message
	}
}








//////////////////////////////////////////////////////////////////////////////
// Implementation of classes used only in this file.


// Implementation for the page we pop up when the user chooses an attribute which conforms.


IMPLEMENT_DYNCREATE(CIASVendorSpecificConformsYes, CHelpDialog)



BEGIN_MESSAGE_MAP(CIASVendorSpecificConformsYes, CHelpDialog)
	//{{AFX_MSG_MAP(CIASVendorSpecificConformsYes)
//	ON_WM_CONTEXTMENU()
//	ON_WM_HELPINFO()
	ON_CBN_SELCHANGE(IDC_IAS_COMBO_VENDORSPEC_FORMAT, OnSelchangeFormat)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificConformsYes::CIASVendorSpecificConformsYes

  Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CIASVendorSpecificConformsYes::CIASVendorSpecificConformsYes() : CHelpDialog(CIASVendorSpecificConformsYes::IDD)
{
	TRACE(_T("CIASVendorSpecificConformsYes::CIASVendorSpecificConformsYes\n"));

	//{{AFX_DATA_INIT(CIASVendorSpecificConformsYes)
	m_strDispValue = _T("");
	m_dType = 0;
	m_dFormat = -1;
	//}}AFX_DATA_INIT

	m_fInitializing = TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificConformsYes::~CIASVendorSpecificConformsYes

--*/
//////////////////////////////////////////////////////////////////////////////
CIASVendorSpecificConformsYes::~CIASVendorSpecificConformsYes()
{
	TRACE(_T("CIASVendorSpecificConformsYes::~CIASVendorSpecificConformsYes\n"));

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificConformsYes::DoDataExchange

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASVendorSpecificConformsYes::DoDataExchange(CDataExchange* pDX)
{
	TRACE(_T("CIASVendorSpecificConformsYes::DoDataExchange\n"));
	USES_CONVERSION;

	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIASVendorSpecificConformsYes)
	DDX_Text(pDX, IDC_IAS_EDIT_VENDORSPEC_VALUE, m_strDispValue);
	DDV_MaxChars(pDX, m_strDispValue, 246);
	DDX_Text(pDX, IDC_IAS_EDIT_VENDORSPEC_TYPE, m_dType);
	DDV_MinMaxInt(pDX, m_dType, 0, 255);
	DDX_CBIndex(pDX, IDC_IAS_COMBO_VENDORSPEC_FORMAT, m_dFormat);
	//}}AFX_DATA_MAP

	if(m_dFormat == 3) // ipaddress
	{
		DWORD IpAddr = 0;
		if(pDX->m_bSaveAndValidate)		// save data to this class
		{
			// ip adress control
			if (0 != SendDlgItemMessage(IDC_IAS_IPADDR_VENDORSPEC_VALUE, IPM_GETADDRESS, 0, (LPARAM)&IpAddr))
			{
				in_addr Tmp_ipAddr;


				Tmp_ipAddr.s_addr = htonl(IpAddr);
			
				m_strDispValue = inet_ntoa(Tmp_ipAddr);

			}else	// no input from USer, 
				m_strDispValue = _T("");

			// write to the string
		}
		else		// put to dialog
		{
			// ip adress control
			if(!m_strDispValue.IsEmpty())
			{
				IpAddr = inet_addr(T2A(m_strDispValue));
				IpAddr = ntohl(IpAddr);
				SendDlgItemMessage(IDC_IAS_IPADDR_VENDORSPEC_VALUE, IPM_SETADDRESS, 0, IpAddr);
			}
		}
	}

	if ( m_fInitializing )
	{
		//
		// set the initializing flag -- we shouldn't call custom data verification
		// routine when initializing, because otherwise we will report an error
		// for an attribute whose value has never been initialized
		//
		m_fInitializing = FALSE;
	}
	else
	{

		// RFC compatible format  -- check data validation.
		switch ( m_dFormat )
		{
		case 1:  // decimal integer
			{
				if(!m_strDispValue.IsEmpty())
					DDV_Unsigned_IntegerStr(pDX, m_strDispValue);
			}
			break;

		case 2:	// hexadecimal string
			{
				if(!m_strDispValue.IsEmpty())
					DDV_VSA_HexString(pDX, m_strDispValue);
			}
			break;
		case 3: // ipaddress  IP address : added F; 211265

		default:  // no error checking for other case
			break;

		} // switch

	} // else
}



/////////////////////////////////////////////////////////////////////////////
// CIASVendorSpecificConformsYes message handlers



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificConformsYes::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CIASVendorSpecificConformsYes::OnInitDialog()
{
	TRACE(_T("CIASVendorSpecificConformsYes::OnInitDialog\n"));

	CHelpDialog::OnInitDialog();
	int iIndex;


	// initialize the format combo box

	CComboBox *pFormatBox = (CComboBox *) GetDlgItem(IDC_IAS_COMBO_VENDORSPEC_FORMAT);
	_ASSERTE( pFormatBox != NULL );


	::CString strFormatStr;

	strFormatStr.LoadString(IDS_IAS_VSA_FORMAT_STR);
	pFormatBox ->AddString((LPCTSTR)strFormatStr);

	strFormatStr.LoadString(IDS_IAS_VSA_FORMAT_DEC);
	pFormatBox ->AddString((LPCTSTR)strFormatStr);

	strFormatStr.LoadString(IDS_IAS_VSA_FORMAT_HEX);
	pFormatBox ->AddString((LPCTSTR)strFormatStr);

	strFormatStr.LoadString(IDS_IAS_VSA_FORMAT_INetAddr);
	pFormatBox ->AddString((LPCTSTR)strFormatStr);
	
	pFormatBox->SetCurSel(m_dFormat);

	OnSelchangeFormat();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CIASVendorSpecificConformsYes::OnSelchangeFormat() 
{
	// TODO: Add your control notification handler code here

	CComboBox *pFormatBox = (CComboBox *) GetDlgItem(IDC_IAS_COMBO_VENDORSPEC_FORMAT);
	int format = pFormatBox->GetCurSel();
	
	if(format == 3) // ipaddress
	{
		GetDlgItem(IDC_IAS_EDIT_VENDORSPEC_VALUE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_IAS_IPADDR_VENDORSPEC_VALUE)->ShowWindow(SW_SHOW);
	}
	else
	{
		GetDlgItem(IDC_IAS_EDIT_VENDORSPEC_VALUE)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_IAS_IPADDR_VENDORSPEC_VALUE)->ShowWindow(SW_HIDE);
	}
}


// Now the implementation for the page we pop up when the user chooses an attribute
// does not conform.




IMPLEMENT_DYNCREATE(CIASVendorSpecificConformsNo, CHelpDialog)



BEGIN_MESSAGE_MAP(CIASVendorSpecificConformsNo, CHelpDialog)
	//{{AFX_MSG_MAP(CIASVendorSpecificConformsNo)
//	ON_WM_CONTEXTMENU()
//	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificConformsNo::CIASVendorSpecificConformsNo

  Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CIASVendorSpecificConformsNo::CIASVendorSpecificConformsNo() : CHelpDialog(CIASVendorSpecificConformsNo::IDD)
{
	TRACE(_T("CIASVendorSpecificConformsNo::CIASVendorSpecificConformsNo\n"));

	//{{AFX_DATA_INIT(CIASVendorSpecificConformsNo)
	m_strDispValue = _T("");
	//}}AFX_DATA_INIT

	m_fInitializing = TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificConformsNo::~CIASVendorSpecificConformsNo

--*/
//////////////////////////////////////////////////////////////////////////////
CIASVendorSpecificConformsNo::~CIASVendorSpecificConformsNo()
{
	TRACE(_T("CIASVendorSpecificConformsNo::~CIASVendorSpecificConformsNo\n"));

}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificConformsNo::DoDataExchange

--*/
//////////////////////////////////////////////////////////////////////////////
void CIASVendorSpecificConformsNo::DoDataExchange(CDataExchange* pDX)
{
	TRACE(_T("CIASVendorSpecificConformsNo::DoDataExchange\n"));

	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIASVendorSpecificConformsNo)
	DDX_Text(pDX, IDC_IAS_EDIT_VENDORSPEC_VALUE, m_strDispValue);
	DDV_MaxChars(pDX, m_strDispValue, 246);
	//}}AFX_DATA_MAP

	if ( m_fInitializing )
	{
		//
		// set the initializing flag -- we shouldn't call custom data verification
		// routine when initializing, because otherwise we will report an error
		// for an attribute whose value has never been initialized
		//
		m_fInitializing = FALSE;
	}
	else
	{
		// hexadecimal string
		if(!m_strDispValue.IsEmpty())
			DDV_VSA_HexString(pDX, m_strDispValue);

	}
}



/////////////////////////////////////////////////////////////////////////////
// CIASVendorSpecificConformsNo message handlers



//////////////////////////////////////////////////////////////////////////////
/*++

CIASVendorSpecificConformsNo::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CIASVendorSpecificConformsNo::OnInitDialog()
{
	TRACE(_T("CIASVendorSpecificConformsNo::OnInitDialog\n"));

	CHelpDialog::OnInitDialog();
	int iIndex;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasvendorspecificattributeeditor.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASVendorSpecificAttributeEditor.h

Abstract:

	Declaration of the CIASVendorSpecificAttributeEditor class.

	
	This class is the C++ implementation of the IIASAttributeEditor interface on
	the Vendor Specific Attribute Editor COM object.


	See IASVendorSpecificAttributeEditor.cpp for implementation.

Revision History:
	mmaguire 06/25/98 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_VENDOR_SPECIFIC_ATTRIBUTE_EDITOR_H_)
#define _VENDOR_SPECIFIC_ATTRIBUTE_EDITOR_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "IASAttributeEditor.h"
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CIASVendorSpecificAttributeEditor
class ATL_NO_VTABLE CIASVendorSpecificAttributeEditor : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIASVendorSpecificAttributeEditor, &CLSID_IASVendorSpecificAttributeEditor>,
	public CIASAttributeEditor
{
public:
	CIASVendorSpecificAttributeEditor()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_NAPSNAPIN)

BEGIN_COM_MAP(CIASVendorSpecificAttributeEditor)
	COM_INTERFACE_ENTRY(IIASAttributeEditor)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()



// IIASVendorSpecificAttributeEditor
public:
	STDMETHOD(get_VSAFormat)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_VSAFormat)(/*[in]*/ long newVal);
	STDMETHOD(get_VSAType)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_VSAType)(/*[in]*/ long newVal);
	STDMETHOD(get_VendorID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_VendorID)(/*[in]*/ long newVal);
	STDMETHOD(get_RFCCompliant)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_RFCCompliant)(/*[in]*/ BOOL newVal);

// IIASAttributeEditor overrides
protected:
	STDMETHOD(get_VendorName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_VendorName)(/*[in]*/ BSTR newVal);
	STDMETHOD(ShowEditor)( /*[in, out]*/ BSTR *pReserved );
	STDMETHOD(put_ValueAsString)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ValueAsString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(SetAttributeValue)(VARIANT * pValue);

	
private:

	// We store info about a vendor specific attribute which we
	// unpack from the variant passed in when SetAttributeValue
	// is called.
	DWORD		m_dwVendorId;
	BOOL		m_fNonRFC;		// RFC compatible?
	DWORD		m_dwVSAFormat;
	DWORD		m_dwVSAType;	
	CComBSTR	m_bstrDisplayValue;
	CComBSTR	m_bstrVendorName;



	// Utility function which takes m_pvarValue and unpacks
	// its values into the member variables above.
	STDMETHOD(UnpackVSA)();


	// Utility function which takes member variables above and
	// packs them into m_pvarValue;
	STDMETHOD(RepackVSA)();


};

#endif // _VENDOR_SPECIFIC_ATTRIBUTE_EDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\localfileloggingnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LocalFileLoggingNode.cpp

Abstract:

   Implementation file for the CClient class.


Author:

    Michael A. Maguire 12/15/97

Revision History:
   mmaguire 12/15/97 - created

--*/
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"

//
// where we can find declaration for main class in this file:
//
#include "logcomp.h"
#include "LocalFileLoggingNode.h"
#include "LogCompD.h"
#include "SnapinNode.cpp"  // Template class implementation
//
//
// where we can find declarations needed in this file:
//
#include "LoggingMethodsNode.h"
#include "LocalFileLoggingPage1.h"
#include "LocalFileLoggingPage2.h"
#include "LogMacNd.h"

// Need to include this at least once to get in build:
#include "sdohelperfuncs.cpp"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::CLocalFileLoggingNode

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLocalFileLoggingNode::CLocalFileLoggingNode( CSnapInItem * pParentNode )
   :CSnapinNode<CLocalFileLoggingNode, CLoggingComponentData, CLoggingComponent>(pParentNode)
{
   ATLTRACE(_T("# +++ CLocalFileLoggingNode::CLocalFileLoggingNode\n"));
   
   // Check for preconditions:
   // None.

   // for help files
   m_helpIndex = (((CLoggingMethodsNode *)m_pParentNode)->m_ExtendRas)? RAS_HELP_INDEX:0;
    

   // Set the display name for this object
   TCHAR lpszName[IAS_MAX_STRING];
   int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_NODE__NAME, lpszName, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   m_bstrDisplayName = lpszName;

   m_resultDataItem.nImage =     IDBI_NODE_LOCAL_FILE_LOGGING;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::InitSdoPointers

Call as soon as you have constructed this class and pass in it's SDO pointer.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalFileLoggingNode::InitSdoPointers( ISdo *pSdoMachine )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::InitSdoPointers\n"));

   // Check for preconditions:
   _ASSERTE( pSdoMachine != NULL );

   HRESULT hr = S_OK;

   hr = pSdoMachine->QueryInterface( IID_ISdoServiceControl, (void **) &m_spSdoServiceControl );
   if( FAILED(hr) || ! m_spSdoServiceControl )
   {
      ShowErrorDialog( NULL, IDS_ERROR__CANT_READ_DATA_FROM_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
      return 0;
   }
   
   // Get the SDO accounting object.
   hr = ::SDOGetSdoFromCollection(       pSdoMachine
                              , PROPERTY_IAS_REQUESTHANDLERS_COLLECTION
                              , PROPERTY_COMPONENT_ID
                              , IAS_PROVIDER_MICROSOFT_ACCOUNTING
                              , &m_spSdoAccounting
                              );
   
   if( m_spSdoAccounting == NULL )
   {
      ShowErrorDialog( NULL, IDS_ERROR__CANT_READ_DATA_FROM_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
      return 0;
   }

   return hr;
}


// refresh date 
HRESULT CLocalFileLoggingNode::DataRefresh(ISdo* pSdoMachine)
{
   // Check for preconditions:
   _ASSERTE( pSdoMachine != NULL );

   HRESULT hr = S_OK;

   m_spSdoServiceControl.Release();
   
   hr = pSdoMachine->QueryInterface( IID_ISdoServiceControl, (void **) &m_spSdoServiceControl );
   if( FAILED(hr) || ! m_spSdoServiceControl )
   {
      ShowErrorDialog( NULL, IDS_ERROR__CANT_READ_DATA_FROM_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
      return 0;
   }

   // Get the SDO accounting object.
   m_spSdoAccounting.Release();
   hr = ::SDOGetSdoFromCollection(       pSdoMachine
                              , PROPERTY_IAS_REQUESTHANDLERS_COLLECTION
                              , PROPERTY_COMPONENT_ID
                              , IAS_PROVIDER_MICROSOFT_ACCOUNTING
                              , &m_spSdoAccounting
                              );
   
   if( m_spSdoAccounting == NULL )
   {
      ShowErrorDialog( NULL, IDS_ERROR__CANT_READ_DATA_FROM_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
      return 0;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::LoadCachedInfoFromSdo

For quick screen updates, we cache some information like client name,
address, protocol and NAS type.  Call this to load this information
from the SDO's into the caches.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalFileLoggingNode::LoadCachedInfoFromSdo( void )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::LoadCachedInfoFromSdo\n"));

   // Check for preconditions:
   if( m_spSdoAccounting == NULL )
   {
      return E_FAIL;
   }

   HRESULT hr;
   CComVariant spVariant;

   // Load the log file directory.
   hr = m_spSdoAccounting->GetProperty( PROPERTY_ACCOUNTING_LOG_FILE_DIRECTORY, &spVariant );
   if( SUCCEEDED( hr ) )
   {
      _ASSERTE( spVariant.vt == VT_BSTR );
      m_bstrDescription = spVariant.bstrVal;
   }
   spVariant.Clear();

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::~CLocalFileLoggingNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLocalFileLoggingNode::~CLocalFileLoggingNode()
{
   ATLTRACE(_T("# --- CLocalFileLoggingNode::~CLocalFileLoggingNode\n"));
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::CreatePropertyPages

See CSnapinNode::CreatePropertyPages (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CLocalFileLoggingNode::CreatePropertyPages (
                 LPPROPERTYSHEETCALLBACK pPropertySheetCallback
               , LONG_PTR hNotificationHandle
               , IUnknown* pUnknown
               , DATA_OBJECT_TYPES type
               )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::CreatePropertyPages\n"));

   // Check for preconditions:
   _ASSERTE( pPropertySheetCallback != NULL );

   HRESULT hr;

   CLoggingMachineNode * pServerNode = GetServerRoot();
   _ASSERTE( pServerNode != NULL );
   hr = pServerNode->CheckConnectionToServer();
   if( FAILED( hr ) )
   {
      return hr;
   }

   TCHAR lpszTab1Name[IAS_MAX_STRING];
   TCHAR lpszTab2Name[IAS_MAX_STRING];
   int nLoadStringResult;

   // Load property page tab name from resource.
   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE1__TAB_NAME, lpszTab1Name, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   // This page will take care of deleting itself when it
   // receives the PSPCB_RELEASE message.
   // We specify TRUE for the bOwnsNotificationHandle parameter so that this page's destructor will be
   // responsible for freeing the notification handle.  Only one page per sheet should do this.
   CLocalFileLoggingPage1 * pLocalFileLoggingPage1 = new CLocalFileLoggingPage1( hNotificationHandle, this, lpszTab1Name, TRUE );

   if( NULL == pLocalFileLoggingPage1 )
   {
      ATLTRACE(_T("# ***FAILED***: CLocalFileLoggingNode::CreatePropertyPages -- Couldn't create property pages\n"));
      return E_OUTOFMEMORY;
   }
   
   // Load property page tab name from resource.
   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__TAB_NAME, lpszTab2Name, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   // This page will take care of deleting itself when it
   // receives the PSPCB_RELEASE message.
   CLocalFileLoggingPage2 * pLocalFileLoggingPage2 = new CLocalFileLoggingPage2( hNotificationHandle, this, lpszTab2Name );

   if( NULL == pLocalFileLoggingPage2 )
   {
      ATLTRACE(_T("# ***FAILED***: CLocalFileLoggingNode::CreatePropertyPages -- Couldn't create property pages\n"));
      
      // Clean up the first page we created.
      delete pLocalFileLoggingPage1;

      return E_OUTOFMEMORY;
   }
   
   // Marshall the ISdo pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdo                 //Reference to the identifier of the interface
               , m_spSdoAccounting           //Pointer to the interface to be marshaled
               , &( pLocalFileLoggingPage1->m_pStreamSdoAccountingMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );

   if( FAILED( hr ) )
   {
      delete pLocalFileLoggingPage1;
      delete pLocalFileLoggingPage2;

      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );

      return E_FAIL;
   }

   // Marshall the ISdo pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdo                 //Reference to the identifier of the interface
               , m_spSdoAccounting                 //Pointer to the interface to be marshaled
               , &( pLocalFileLoggingPage2->m_pStreamSdoAccountingMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );

   if( FAILED( hr ) )
   {
      delete pLocalFileLoggingPage1;
      delete pLocalFileLoggingPage2;

      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );

      return E_FAIL;
   }

   // Marshall the ISdo pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdoServiceControl            //Reference to the identifier of the interface
               , m_spSdoServiceControl                //Pointer to the interface to be marshaled
               , &( pLocalFileLoggingPage1->m_pStreamSdoServiceControlMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );

   if( FAILED( hr ) )
   {
      delete pLocalFileLoggingPage1;
      delete pLocalFileLoggingPage2;

      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );

      return E_FAIL;
   }
   
   // Marshall the ISdo pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdoServiceControl            //Reference to the identifier of the interface
               , m_spSdoServiceControl                //Pointer to the interface to be marshaled
               , &( pLocalFileLoggingPage2->m_pStreamSdoServiceControlMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );

   if( FAILED( hr ) )
   {
      delete pLocalFileLoggingPage1;
      delete pLocalFileLoggingPage2;

      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );

      return E_FAIL;
   }

   // Add the pages to the MMC property sheet.
   hr = pPropertySheetCallback->AddPage( pLocalFileLoggingPage1->Create() );
   _ASSERT( SUCCEEDED( hr ) );

   hr = pPropertySheetCallback->AddPage( pLocalFileLoggingPage2->Create() );
   _ASSERT( SUCCEEDED( hr ) );

   // Add a synchronization object which makes sure we only commit data
   // when all pages are OK with their data.
   CSynchronizer * pSynchronizer = new CSynchronizer();
   _ASSERTE( pSynchronizer != NULL );

   // Hand the sycnchronizer off to the pages.
   pLocalFileLoggingPage1->m_pSynchronizer = pSynchronizer;
   pSynchronizer->AddRef();

   pLocalFileLoggingPage2->m_pSynchronizer = pSynchronizer;
   pSynchronizer->AddRef();

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::QueryPagesFor

See CSnapinNode::QueryPagesFor (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CLocalFileLoggingNode::QueryPagesFor ( DATA_OBJECT_TYPES type )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::QueryPagesFor\n"));

   // S_OK means we have pages to display
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
OLECHAR* CLocalFileLoggingNode::GetResultPaneColInfo(int nCol)
{
   ATLTRACE(_T("# CLocalFileLoggingNode::GetResultPaneColInfo\n"));
      
   // Check for preconditions:
   // None.

   switch( nCol )
   {
   case 0:
      return m_bstrDisplayName;
      break;
   case 1:
      return m_bstrDescription;
      break;
   default:
      // ISSUE: error -- should we assert here?
      return NULL;
      break;
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalFileLoggingNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::SetVerbs\n"));
   
   // Check for preconditions:
   _ASSERTE( pConsoleVerb != NULL );

   HRESULT hr = S_OK;

   // We want the user to be able to choose Properties on this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

   // We want Properties to be the default
   hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingComponentData * CLocalFileLoggingNode::GetComponentData( void )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::GetComponentData\n"));

   // Check for preconditions:
   _ASSERTE( m_pParentNode != NULL );

   return ((CLoggingMethodsNode *) m_pParentNode)->GetComponentData();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::GetServerRoot

This method returns the Server node under which this node can be found.

It relies upon the fact that each node has a pointer to its parent,
all the way up to the server node.

This would be a useful function to use if, for example, you need a reference
to some data specific to a server.

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingMachineNode * CLocalFileLoggingNode::GetServerRoot( void )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::GetServerRoot\n"));

   // Check for preconditions:
   _ASSERTE( m_pParentNode != NULL );

   return ((CLoggingMethodsNode *) m_pParentNode)->GetServerRoot();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::OnPropertyChange

This is our own custom response to the MMCN_PROPERTY_CHANGE notification.

MMC never actually sends this notification to our snapin with a specific lpDataObject,
so it would never normally get routed to a particular node but we have arranged it
so that our property pages can pass the appropriate CSnapInItem pointer as the param
argument.  In our CComponent::Notify override, we map the notification message to
the appropriate node using the param argument.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalFileLoggingNode::OnPropertyChange(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::OnPropertyChange\n"));

   // Check for preconditions:
   // None.
   
   return LoadCachedInfoFromSdo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\localfileloggingpage1.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LocalFileLoggingPage1.cpp

Abstract:

	Implementation file for the CLocalFileLoggingPage1 class.

	We implement the class needed to handle the first property page
	for the LocalFileLogging node.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "LocalFileLoggingPage1.h"
//
//
// where we can find declarations needed in this file:
//
#include "LocalFileLoggingNode.h"
#include "ChangeNotification.h"
//

#include "LoggingMethodsNode.h"
#include "LogMacNd.h"
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage1::CLocalFileLoggingPage1

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLocalFileLoggingPage1::CLocalFileLoggingPage1( LONG_PTR hNotificationHandle, CLocalFileLoggingNode *pLocalFileLoggingNode,  TCHAR* pTitle, BOOL bOwnsNotificationHandle)
						: CIASPropertyPage<CLocalFileLoggingPage1> ( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
	ATLTRACE(_T("# +++ CLocalFileLoggingPage1::CLocalFileLoggingPage1\n"));
	
	// Check for preconditions:
	_ASSERTE( pLocalFileLoggingNode != NULL );

	// Add the help button to the page
//	m_psp.dwFlags |= PSP_HASHELP;

	// Initialize the pointer to the stream into which the Sdo pointer will be marshalled.
	m_pStreamSdoAccountingMarshal = NULL;


	// Initialize the pointer to the stream into which the Sdo pointer will be marshalled.
	m_pStreamSdoServiceControlMarshal = NULL;


	// We immediately save off a parent to the client node.
	// We will use only the SDO, and notify the parent of the client object
	// we are modifying that it (and its children) may need to refresh
	// themselves with new data from the SDO's.
	m_pParentOfNodeBeingModified = pLocalFileLoggingNode->m_pParentNode;
	m_pNodeBeingModified = pLocalFileLoggingNode;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage1::~CLocalFileLoggingPage1

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLocalFileLoggingPage1::~CLocalFileLoggingPage1( void )
{
	ATLTRACE(_T("# --- CLocalFileLoggingPage1::~CLocalFileLoggingPage1\n"));

	// Release this stream pointer if this hasn't already been done.
	if( m_pStreamSdoAccountingMarshal != NULL )
	{
		m_pStreamSdoAccountingMarshal->Release();
	};

	if( m_pStreamSdoServiceControlMarshal != NULL )
	{
		m_pStreamSdoServiceControlMarshal->Release();
	};


}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage1::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLocalFileLoggingPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE(_T("# CLocalFileLoggingPage1::OnInitDialog\n"));
	

	// Check for preconditions:
	_ASSERTE( m_pStreamSdoAccountingMarshal != NULL );
	_ASSERT( m_pSynchronizer != NULL );


	// Since we've been examined, we must add to the ref count of pages who need to
	// give their approval before they can be allowed to commit changes.
	m_pSynchronizer->RaiseCount();


	HRESULT				hr;
	BOOL				bTemp;


	// Unmarshall an ISdo interface pointer.
	// The code setting up this page should make sure that it has
	// marshalled the Sdo interface pointer into m_pStreamSdoAccountingMarshal.
	hr =  CoGetInterfaceAndReleaseStream(
						  m_pStreamSdoAccountingMarshal		  //Pointer to the stream from which the object is to be marshaled
						, IID_ISdo				//Reference to the identifier of the interface
						, (LPVOID *) &m_spSdoAccounting    //Address of output variable that receives the interface pointer requested in riid
						);

	// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
	// We set it to NULL so that our destructor doesn't try to release this again.
	m_pStreamSdoAccountingMarshal = NULL;

	if( FAILED( hr) || m_spSdoAccounting == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE );

		return 0;
	}





	// Unmarshall an ISdo interface pointer.
	// The code setting up this page should make sure that it has
	// marshalled the Sdo interface pointer into m_pStreamSdoServiceControlMarshal.
	hr =  CoGetInterfaceAndReleaseStream(
						  m_pStreamSdoServiceControlMarshal		  //Pointer to the stream from which the object is to be marshaled
						, IID_ISdoServiceControl				//Reference to the identifier of the interface
						, (LPVOID *) &m_spSdoServiceControl    //Address of output variable that receives the interface pointer requested in riid
						);

	// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
	// We set it to NULL so that our destructor doesn't try to release this again.
	m_pStreamSdoServiceControlMarshal = NULL;

	if( FAILED( hr) || m_spSdoServiceControl == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr , IDS_ERROR__LOGGING_TITLE);

		return 0;
	}
	


	// Initialize the data on the property page.

// ISSUE: This is being removed from the UI -- make sure that it is removed from the SDO's as well.
//	hr = GetSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_ENABLE, &bTemp, IDS_ERROR__LOCAL_FILE_LOGGING_READING_ENBABLE, m_hWnd, NULL );
//	if( SUCCEEDED( hr ) )
//	{
//		SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__ENABLE_LOGGING, BM_SETCHECK, bTemp, 0);
//
//		// Initialize the dirty bits;
//		// We do this after we've set all the data above otherwise we get false
//		// notifications that data has changed when we set the edit box text.
//		m_fDirtyEnableLogging = FALSE;
//	}
//	else
//	{
//		if( OLE_E_BLANK == hr )
//		{
//			SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__ENABLE_LOGGING, BM_SETCHECK, FALSE, 0);
//			m_fDirtyEnableLogging = FALSE;
//			SetModified( TRUE );
//		}
//	}

	
	hr = GetSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_ACCOUNTING, &bTemp, IDS_ERROR__LOCAL_FILE_LOGGING_READING_ACCOUNTING_PACKETS, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS, BM_SETCHECK, bTemp, 0);
		m_fDirtyAccountingPackets = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS, BM_SETCHECK, FALSE, 0);
			m_fDirtyAccountingPackets = TRUE;
			SetModified( TRUE );
		}
	}
	
	
	hr = GetSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_AUTHENTICATION, &bTemp, IDS_ERROR__LOCAL_FILE_LOGGING_READING_AUTHENTICATION_PACKETS, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SendDlgItemMessage(IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS, BM_SETCHECK, bTemp, 0);
		m_fDirtyAuthenticationPackets = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			SendDlgItemMessage(IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS, BM_SETCHECK, FALSE, 0);
			m_fDirtyAuthenticationPackets = TRUE;
			SetModified( TRUE );
		}
	}
	
	
	hr = GetSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_ACCOUNTING_INTERIM, &bTemp, IDS_ERROR__LOCAL_FILE_LOGGING_READING_INTERIM_ACCOUNTING_PACKETS, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SendDlgItemMessage(IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS, BM_SETCHECK, bTemp, 0);
		m_fDirtyInterimAccounting = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			SendDlgItemMessage(IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS, BM_SETCHECK, FALSE, 0);
			m_fDirtyInterimAccounting = TRUE;
			SetModified( TRUE );
		}
	}


	// Manages some UI dependencies when certain buttons aren't checked.
	SetEnableLoggingDependencies();

	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage1::OnChange

Called when the WM_COMMAND message is sent to our page with any of the
BN_CLICKED, EN_CHANGE or CBN_SELCHANGE notifications.

This is our chance to check to see what the user has touched, set the
dirty bits for these items so that only they will be saved,
and enable the Apply button.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLocalFileLoggingPage1::OnChange(		
							  UINT uMsg
							, WPARAM wParam
							, HWND hwnd
							, BOOL& bHandled
							)
{
	ATLTRACE(_T("# CLocalFileLoggingPage1::OnChange\n"));

	
	// Check for preconditions:
	// None.
	

	// We don't want to prevent anyone else down the chain from receiving a message.
	bHandled = FALSE;


	// Figure out which item has changed and set the dirty bit for that item.
	int iItemID = (int) LOWORD(wParam);

	switch( iItemID )
	{
//	case IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__ENABLE_LOGGING:
//		m_fDirtyEnableLogging = TRUE;
//		break;
	case IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS:
		m_fDirtyAccountingPackets = TRUE;
		break;
	case IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS:
		m_fDirtyAuthenticationPackets = TRUE;
		break;
	case IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS:
		m_fDirtyInterimAccounting = TRUE;
		break;
	default:
		return TRUE;
		break;
	}

	// We should only get here if the item that changed was
	// one of the ones we were checking for.
	// This enables the Apply button.
	SetModified( TRUE );

	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage1::OnApply

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnApply gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnApply method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CLocalFileLoggingPage1::OnApply()
{
	ATLTRACE(_T("# CLocalFileLoggingPage1::OnApply\n"));
	

	// Check for preconditions:
	_ASSERT( m_pSynchronizer != NULL );



	if( m_spSdoAccounting == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO , NULL, 0, IDS_ERROR__LOGGING_TITLE);

		return FALSE;
	}

	
	HRESULT			hr;
	BOOL			bTemp;


// ISSUE: We are removing this from the UI -- make sure to remove it from the SDO's and accounting handler as well.
//	if( m_fDirtyEnableLogging )
//	{
//		bTemp = SendDlgItemMessage(IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__ENABLE_LOGGING, BM_GETCHECK, 0, 0);
//
//		bTemp = TRUE;
//		hr = PutSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_ENABLE, bTemp, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_ENABLE, m_hWnd, NULL );
//		if( FAILED( hr ) )
//		{
//			// Reset the ref count so all pages know that we need to play the game again.
//			m_pSynchronizer->ResetCountToHighest();
//
//			// This uses the resource ID of this page to make this page the current page.
//			PropSheet_SetCurSelByID( GetParent(), IDD );
//			
//			return FALSE;
//		}
//		else
//		{
//			// We succeeded.
//
//			// Turn off the dirty bit.
//			m_fDirtyEnableLogging = FALSE;
//		}
//	}

	if( m_fDirtyAccountingPackets )
	{
		bTemp = SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS, BM_GETCHECK, 0, 0);
		hr = PutSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_ACCOUNTING, bTemp, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_ACCOUNTING_PACKETS, m_hWnd, NULL );
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			
			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyAccountingPackets = FALSE;
		}
	}

	if( m_fDirtyAuthenticationPackets )
	{
		bTemp = SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS, BM_GETCHECK, 0, 0);
		hr = PutSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_AUTHENTICATION, bTemp, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, m_hWnd, NULL );
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			
			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyAuthenticationPackets = FALSE;
		}
	}

	if( m_fDirtyInterimAccounting )
	{
		bTemp = SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS, BM_GETCHECK, 0, 0);
		hr = PutSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_ACCOUNTING_INTERIM, bTemp, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, m_hWnd, NULL );
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			
			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyInterimAccounting = FALSE;
		}
	}


	// If we made it to here, try to apply the changes.

	// Check to see if there are other pages which have not yet validated their data.
	LONG lRefCount = m_pSynchronizer->LowerCount();
	if( lRefCount <= 0 )
	{
		// There is nobody else left, so now we can commit the data.
	
		hr = m_spSdoAccounting->Apply();
		if( FAILED( hr ) )
		{
			if(hr == DB_E_NOTABLE)	// assume, the RPC connection has problem
				ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO, NULL, 0, IDS_ERROR__LOGGING_TITLE );
			else 
			{
				ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, NULL, 0, IDS_ERROR__LOGGING_TITLE );
			}
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );

			return FALSE;
		}
		else
		{
			// We succeeded.

			// The data was accepted, so notify the main context of our snapin
			// that it may need to update its views.
			CChangeNotification * pChangeNotification = new CChangeNotification();
			pChangeNotification->m_dwFlags = CHANGE_UPDATE_RESULT_NODE;
			pChangeNotification->m_pNode = m_pNodeBeingModified;
			pChangeNotification->m_pParentNode = m_pParentOfNodeBeingModified;

			HRESULT hr = PropertyChangeNotify( (LPARAM) pChangeNotification );
			_ASSERTE( SUCCEEDED( hr ) );


			// Tell the service to reload data.
			HRESULT hrTemp = m_spSdoServiceControl->ResetService();
			if( FAILED( hrTemp ) )
			{
				// Fail silently.
			}


		}
	}


	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage1::OnQueryCancel

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnQueryCancel gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnQueryCancel method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CLocalFileLoggingPage1::OnQueryCancel()
{
	ATLTRACE(_T("# CLocalFileLoggingPage1::OnQueryCancel\n"));
	

	HRESULT hr;

	if( m_spSdoAccounting != NULL )
	{
		// If the user wants to cancel, we should make sure that we rollback
		// any changes the user may have started.

		// If the user had not already tried to commit something,
		// a cancel on an SDO will hopefully be designed to be benign.
		
		hr = m_spSdoAccounting->Restore();
		// Don't care about the HRESULT, but it might be good to see it for debugging.

	}

	return TRUE;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage1::OnEnableLogging


Remarks:

	Called when the user clicks on the Enable Logging check box.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLocalFileLoggingPage1::OnEnableLogging(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# CLocalFileLoggingPage1::OnEnableLogging\n"));

	// The Enable Logging button has been checked -- check dependencies.
	SetEnableLoggingDependencies();

	// This return value is ignored.
	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage1::SetEnableLoggingDependencies

Remarks:

	Utility to set state of items which may depend on the
	Enable Logging check box.

--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalFileLoggingPage1::SetEnableLoggingDependencies( void )
{
	ATLTRACE(_T("# CLocalFileLoggingPage1::SetEnableLoggingDependencies\n"));

	// disable some content when extending RRAS
		// We need access here to some server-global data.
	_ASSERTE( m_pParentOfNodeBeingModified != NULL );
	CLoggingMachineNode * pServerNode = ((CLoggingMethodsNode *) m_pParentOfNodeBeingModified)->GetServerRoot();
	BOOL bNTAcc = TRUE;
	BOOL bNTAuth = TRUE;
	
	_ASSERTE( pServerNode != NULL );

	if(pServerNode->m_enumExtendedSnapin == RRAS_SNAPIN)
	{
		BSTR	bstrMachine = NULL;
		
		if(!pServerNode->m_bConfigureLocal)
			bstrMachine = pServerNode->m_bstrServerAddress;

		bNTAcc = IsRRASUsingNTAccounting(bstrMachine);
		bNTAuth = IsRRASUsingNTAuthentication(bstrMachine);
	}


// We are getting rid of the ENABLE_LOGGING button.
//	// Ascertain what the state of the check box is.
//	int iChecked = ::SendMessage( GetDlgItem(IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__ENABLE_LOGGING), BM_GETCHECK, 0, 0 );
//
//	if( iChecked )
//	{
//		// Make sure the correct items are enabled.
	
		::EnableWindow( GetDlgItem( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS), bNTAcc );
		::EnableWindow( GetDlgItem( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS), bNTAuth );
		::EnableWindow( GetDlgItem( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS), bNTAcc);
	
//	}
//	else
//	{
//		// Make sure the correct items are enabled.
//		::EnableWindow( GetDlgItem( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS), FALSE );
//		::EnableWindow( GetDlgItem( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS), FALSE );
//		::EnableWindow( GetDlgItem( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS), FALSE );
//	}

}



/////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage1::GetHelpPath

Remarks:

	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help
	button of a property sheet.

	It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalFileLoggingPage1::GetHelpPath( LPTSTR szHelpPath )
{
	ATLTRACE(_T("# CLocalFileLoggingPage1::GetHelpPath\n"));


	// Check for preconditions:



#ifdef UNICODE_HHCTRL
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("idh_proppage_local_file_logging1.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "idh_proppage_local_file_logging1.htm" );
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\iasvendorspecificeditorpage.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    IASVendorSpecficEditorPage.h

Abstract:

	Declaration of the CIASPgVendorSpecAttr class.

	This dialog allows the user to configure a RADIUS vendor specific attribute.


	See IASVendorSpecificEditorPage.cpp for implementation.

Revision History:
	mmaguire 06/25/98	- revised Baogang Yao's original implementation 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_VENDOR_SPECIFIC_ATTRIBUTE_EDITOR_PAGE_H_)
#define _VENDOR_SPECIFIC_ATTRIBUTE_EDITOR_PAGE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CIASPgVendorSpecAttr dialog

class CIASPgVendorSpecAttr : public CHelpDialog
{
	DECLARE_DYNCREATE(CIASPgVendorSpecAttr)

// Construction
public:
	CIASPgVendorSpecAttr();
	~CIASPgVendorSpecAttr();

	BOOL m_fNonRFC;
	::CString	m_strDispValue;

// Dialog Data
	//{{AFX_DATA(CIASPgVendorSpecAttr)
	enum { IDD = IDD_IAS_VENDORSPEC_ATTR };
	::CString	m_strName;
	int		m_dType;
	int		m_dFormat;
	int		m_dVendorIndex;
	//}}AFX_DATA

	BOOL	m_bVendorIndexAsID;		// FALSE by default, true when inteprete Index as ID, and use Edit box for it.

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIASPgVendorSpecAttr)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
	BOOL m_fInitializing;
protected:
	// Generated message map functions
	//{{AFX_MSG(CIASPgVendorSpecAttr)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioHex();
	afx_msg void OnRadioRadius();
	afx_msg void OnRadioSelectFromList();
	afx_msg void OnRadioEnterVendorId();
	afx_msg void OnButtonConfigure();
	afx_msg void OnVendorIdListSelChange();
//	afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
//	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _VENDOR_SPECIFIC_ATTRIBUTE_EDITOR_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\localfileloggingnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LocalFileLoggingNode.h

Abstract:

	Header file for the CLocalFileLoggingNode subnode

	See LocalFileLoggingNode.cpp for implementation.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_LOCAL_FILE_LOGGING_NODE_H_)
#define _IAS_LOCAL_FILE_LOGGING_NODE_H_


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "SnapinNode.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CLocalFileLoggingPage1;
class CLocalFileLoggingPage2;
class CLoggingMachineNode;
class CLoggingComponentData;
class CLoggingComponent;




class CLocalFileLoggingNode : public CSnapinNode< CLocalFileLoggingNode, CLoggingComponentData, CLoggingComponent >
{

public:

	SNAPINMENUID(IDM_LOCAL_FILE_LOGGING_NODE)

	BEGIN_SNAPINTOOLBARID_MAP(CLocalFileLoggingNode)
//		SNAPINTOOLBARID_ENTRY(IDR_CLIENT1_TOOLBAR)
//		SNAPINTOOLBARID_ENTRY(IDR_CLIENT2_TOOLBAR)
	END_SNAPINTOOLBARID_MAP()

	
	// Constructor/Destructor.
	CLocalFileLoggingNode( CSnapInItem * pParentNode );
	~CLocalFileLoggingNode();

	
	
	// Used to get access to snapin-global data.
	CLoggingComponentData * GetComponentData( void );

	// Used to get access to server-global data.
	CLoggingMachineNode * GetServerRoot( void );



	HRESULT DataRefresh(ISdo* pSdo);

	// SDO management.
	HRESULT InitSdoPointers( ISdo *pSdoServer );
	HRESULT LoadCachedInfoFromSdo( void );



	// Some overrides for standard MMC functionality.
    STDMETHOD(CreatePropertyPages)(
		  LPPROPERTYSHEETCALLBACK pPropertySheetCallback
		, LONG_PTR handle
		, IUnknown* pUnk
		, DATA_OBJECT_TYPES type
		);
    STDMETHOD(QueryPagesFor)( DATA_OBJECT_TYPES type );
	virtual HRESULT OnPropertyChange(
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type
				);
	OLECHAR* GetResultPaneColInfo(int nCol);
	virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );



private:

	// This string contains a cache of the info from the SDO
	// which will show up in the description column for this node.
	// In the case of the local file logging node,
	// this is the log file directory.
	CComBSTR m_bstrDescription;

	// Pointer to our Accounting Server Data Object;
	CComPtr<ISdo>	m_spSdoAccounting;	

	// Smart pointer to interface for telling service to reload data.
	CComPtr<ISdoServiceControl>	m_spSdoServiceControl;

};

#endif // _IAS_LOCAL_FILE_LOGGING_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\localfileloggingpage1.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	LocalFileLoggingPage1.h

Abstract:

	Header file for the CLocalFileLoggingPage1 class.

	This is our handler class for the first CMachineNode property page.

	See LocalFileLoggingPage1.cpp for implementation.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_LOG_LOCAL_FILE_LOGGING_PAGE_1_H_)
#define _LOG_LOCAL_FILE_LOGGING_PAGE_1_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CLocalFileLoggingNode;

class CLocalFileLoggingPage1 : public CIASPropertyPage<CLocalFileLoggingPage1>
{

public :

	CLocalFileLoggingPage1( LONG_PTR hNotificationHandle, CLocalFileLoggingNode *pLocalFileLoggingNode,  TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );

	~CLocalFileLoggingPage1();

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_PROPPAGE_LOCAL_FILE_LOGGING1 };

	BEGIN_MSG_MAP(CLocalFileLoggingPage1)
		COMMAND_CODE_HANDLER(BN_CLICKED, OnChange)		
		COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
		COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__ENABLE_LOGGING, OnEnableLogging )
		CHAIN_MSG_MAP(CIASPropertyPage<CLocalFileLoggingPage1>)
	END_MSG_MAP()

	BOOL OnApply();

	BOOL OnQueryCancel();

	HRESULT GetHelpPath( LPTSTR szFilePath );


	// Pointer to stream into which this page's Sdo interface
	// pointer will be marshalled.
	LPSTREAM m_pStreamSdoAccountingMarshal;

	LPSTREAM m_pStreamSdoServiceControlMarshal;


protected:
	// Interface pointer for this page's client's sdo.
	CComPtr<ISdo>	m_spSdoAccounting;

	// Smart pointer to interface for telling service to reload data.
	CComPtr<ISdoServiceControl>	m_spSdoServiceControl;

	// When we are passed a pointer to the client node in our constructor,
	// we will save away a pointer to its parent, as this is the node
	// which will need to receive an update message once we have
	// applied any changes.
	CSnapInItem * m_pParentOfNodeBeingModified;
	CSnapInItem * m_pNodeBeingModified;

private:


	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnChange(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnEnableLogging(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	// Helper utilities for correctly handling UI changes.
	void SetEnableLoggingDependencies( void );

protected:

	// Dirty bits -- for keeping track of data which has been touched
	// so that we only save data we have to.
	BOOL m_fDirtyEnableLogging;
	BOOL m_fDirtyAccountingPackets;
	BOOL m_fDirtyAuthenticationPackets;
	BOOL m_fDirtyInterimAccounting;



};

#endif // _IAS_LOCAL_FILE_LOGGING_PAGE_1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\localfileloggingpage2.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LocalFileLoggingPage2.cpp

Abstract:

	Implementation file for the CLocalFileLoggingPage2 class.

	We implement the class needed to handle the second property page
	for the LocalFileLogging node.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "LocalFileLoggingPage2.h"
#include "ChangeNotification.h"
//
//
// where we can find declarations needed in this file:
//
#include <SHLOBJ.H>
#include "LocalFileLoggingNode.h"
#include "LoggingMethodsNode.h"
#include "LogMacNd.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


#define LOG_FILE_FORMAT__IAS1	 0
#define LOG_FILE_FORMAT__ODBC	 0xFFFF
#define LOG_SIZE_LIMIT			100000
#define LOG_SIZE_LIMIT_DIGITS	6 // log(100000)

//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::CLocalFileLoggingPage2

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLocalFileLoggingPage2::CLocalFileLoggingPage2( LONG_PTR hNotificationHandle, CLocalFileLoggingNode *pLocalFileLoggingNode,  TCHAR* pTitle, BOOL bOwnsNotificationHandle )
						: CIASPropertyPage<CLocalFileLoggingPage2> ( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
	ATLTRACE(_T("# +++ CLocalFileLoggingPage2::CLocalFileLoggingPage2\n"));
	_ASSERTE( pLocalFileLoggingNode != NULL );

	// Add the help button to the page
//	m_psp.dwFlags |= PSP_HASHELP;

	// Initialize the pointer to the stream into which the Sdo pointer will be marshalled.
	m_pStreamSdoAccountingMarshal = NULL;


	// Initialize the pointer to the stream into which the Sdo pointer will be marshalled.
	m_pStreamSdoServiceControlMarshal = NULL;


	// We immediately save off a parent to the client node.
	// We will use only the SDO, and notify the parent of the client object
	// we are modifying that it (and its children) may need to refresh
	// themselves with new data from the SDO's.
	m_pParentOfNodeBeingModified = pLocalFileLoggingNode->m_pParentNode;
	m_pNodeBeingModified = pLocalFileLoggingNode;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::~CLocalFileLoggingPage2

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLocalFileLoggingPage2::~CLocalFileLoggingPage2( void )
{
	ATLTRACE(_T("# --- CLocalFileLoggingPage2::~CLocalFileLoggingPage2\n"));

	// Release this stream pointer if this hasn't already been done.
	if( m_pStreamSdoAccountingMarshal != NULL )
	{
		m_pStreamSdoAccountingMarshal->Release();
	};

	if( m_pStreamSdoServiceControlMarshal != NULL )
	{
		m_pStreamSdoServiceControlMarshal->Release();
	};


}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLocalFileLoggingPage2::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE(_T("# CLocalFileLoggingPage2::OnInitDialog\n"));
	

	// Check for preconditions:
	_ASSERTE( m_pStreamSdoAccountingMarshal != NULL );
	_ASSERT( m_pSynchronizer != NULL );


	// Since we've been examined, we must add to the ref count of pages who need to
	// give their approval before they can be allowed to commit changes.
	m_pSynchronizer->RaiseCount();


	HRESULT				hr;
	CComBSTR			bstrTemp;
	BOOL				bTemp;
	LONG				lTemp;

	// Unmarshall an ISdo interface pointer.
	// The code setting up this page should make sure that it has
	// marshalled the Sdo interface pointer into m_pStreamSdoAccountingMarshal.
	hr =  CoGetInterfaceAndReleaseStream(
						  m_pStreamSdoAccountingMarshal		  //Pointer to the stream from which the object is to be marshaled
						, IID_ISdo				//Reference to the identifier of the interface
						, (LPVOID *) &m_spSdoAccounting    //Address of output variable that receives the interface pointer requested in riid
						);

	// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
	// We set it to NULL so that our destructor doesn't try to release this again.
	m_pStreamSdoAccountingMarshal = NULL;

	if( FAILED( hr) || m_spSdoAccounting == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE );

		return 0;
	}


	// Unmarshall an ISdo interface pointer.
	// The code setting up this page should make sure that it has
	// marshalled the Sdo interface pointer into m_pStreamSdoServiceControlMarshal.
	hr =  CoGetInterfaceAndReleaseStream(
						  m_pStreamSdoServiceControlMarshal		  //Pointer to the stream from which the object is to be marshaled
						, IID_ISdoServiceControl				//Reference to the identifier of the interface
						, (LPVOID *) &m_spSdoServiceControl    //Address of output variable that receives the interface pointer requested in riid
						);

	// CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
	// We set it to NULL so that our destructor doesn't try to release this again.
	m_pStreamSdoServiceControlMarshal = NULL;

	if( FAILED( hr) || m_spSdoServiceControl == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE );

		return 0;
	}
	


	// Initialize the data on the property page.

//	hr = GetSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_OPEN_NEW, &bTemp, IDS_ERROR__LOCAL_FILE_LOGGING_READING_AUTOMATICALLY_OPEN_NEW_LOG, m_hWnd, NULL );
//	if( SUCCEEDED( hr ) )
//	{
//		SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG, BM_SETCHECK, bTemp, 0);
//
//		// Initialize the dirty bits;
//		// We do this after we've set all the data above otherwise we get false
//		// notifications that data has changed when we set the edit box text.
//		m_fDirtyAutomaticallyOpenNewLog = FALSE;
//	}
//	else
//	{
//		if( OLE_E_BLANK == hr )
//		{
//			SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG, BM_SETCHECK, FALSE, 0);
//			m_fDirtyAutomaticallyOpenNewLog = TRUE;
//			SetModified( TRUE );
//		}
//	}
	
	lTemp = 0;
	hr = GetSdoI4( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_OPEN_NEW_FREQUENCY, &lTemp, IDS_ERROR__LOCAL_FILE_LOGGING_READING_NEW_LOG_FREQUENCY, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		m_fDirtyFrequency = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			m_fDirtyFrequency = TRUE;
			SetModified( TRUE );
		}
	}
		
	NEW_LOG_FILE_FREQUENCY nlffFrequency = (NEW_LOG_FILE_FREQUENCY) lTemp;
	switch( nlffFrequency )
	{
	case IAS_LOGGING_DAILY:
		::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY ), BM_SETCHECK, 1, 0 );
		break;
	case IAS_LOGGING_WEEKLY:
		::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY ), BM_SETCHECK, 1, 0 );
		break;
	case IAS_LOGGING_MONTHLY:
		::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY ), BM_SETCHECK, 1, 0 );
		break;
	case IAS_LOGGING_WHEN_FILE_SIZE_REACHES:
		::SendMessage( GetDlgItem(IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES ), BM_SETCHECK, 1, 0 );
		break;
	case IAS_LOGGING_UNLIMITED_SIZE:
		::SendMessage( GetDlgItem(IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED ), BM_SETCHECK, 1, 0 );
		break;
	default:
		// Invalid logging frequency.
		_ASSERTE( FALSE );
		break;
	}

	::SendMessage( GetDlgItem(IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE ), EM_LIMITTEXT, LOG_SIZE_LIMIT_DIGITS, 0 );

	hr = GetSdoI4( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_OPEN_NEW_SIZE, &lTemp, IDS_ERROR__LOCAL_FILE_LOGGING_READING_WHEN_LOG_FILE_SIZE, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		TCHAR szNumberAsText[IAS_MAX_STRING];
		_ltot( lTemp, szNumberAsText, 10 /* Base */ );
		SetDlgItemText(IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE, szNumberAsText );
		m_fDirtyLogFileSize = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			SetDlgItemText(IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE, _T("") );
			m_fDirtyLogFileSize = TRUE;
			SetModified( TRUE );
		}
	}

	

	hr = GetSdoBSTR( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_FILE_DIRECTORY, &bstrTemp, IDS_ERROR__LOCAL_FILE_LOGGING_READING_LOG_FILE_DIRECTORY, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		SetDlgItemText( IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY, bstrTemp );
		m_fDirtyLogFileDirectory = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			SetDlgItemText( IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY, _T("") );
			m_fDirtyLogFileDirectory = TRUE;
			SetModified( TRUE );
		}
	}
	bstrTemp.Empty();



// The log file name is not something we set -- the server's accounting provider determines it based on the frequency we choose.
//
//	hr = m_spSdoAccounting->GetProperty( PROPERTY_ACCOUNTING_LOG_FILE, &spVariant );
//	if( SUCCEEDED( hr ) )
//	{
//		_ASSERTE( spVariant.vt == VT_BSTR );
//		SetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, spVariant.bstrVal );
//	}
//	else
//	{
//		m_spSdoClient->LastError( &bstrError );
//		ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_READ_DATA_FROM_SDO, bstrError );
//	}
//	spVariant.Clear();


	hr = GetSdoI4( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_IAS1_FORMAT, &lTemp, IDS_ERROR__LOCAL_FILE_LOGGING_READING_LOG_FILE_FORMAT, m_hWnd, NULL );
	if( SUCCEEDED( hr ) )
	{
		switch( lTemp )
		{
		case LOG_FILE_FORMAT__IAS1:
			// W3C format (IAS 1.0)
			SendDlgItemMessage( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1, BM_SETCHECK, TRUE, 0);
			SendDlgItemMessage( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC, BM_SETCHECK, FALSE, 0);
			break;
		case LOG_FILE_FORMAT__ODBC:
			// ODBC format
			SendDlgItemMessage( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC, BM_SETCHECK, TRUE, 0);
			SendDlgItemMessage( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1, BM_SETCHECK, FALSE, 0);
			break;
		default:
			// Unknown log file format.
			_ASSERTE( FALSE );
		}

		m_fDirtyLogInV1Format = FALSE;
	}
	else
	{
		if( OLE_E_BLANK == hr )
		{
			SendDlgItemMessage( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC, BM_SETCHECK, TRUE, 0);
			SendDlgItemMessage( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1, BM_SETCHECK, FALSE, 0);
			m_fDirtyLogInV1Format = TRUE;
			SetModified( TRUE );
		}
	}


//	SetAutomaticallyOpenNewLogDependencies();
	SetLogFileFrequencyDependencies();


	// Check to see whether we are local or remote, and disable Browse
	// button if we are remote.
	
	// We need access here to some server-global data.
	_ASSERTE( m_pParentOfNodeBeingModified != NULL );
	CLoggingMachineNode * pServerNode = ((CLoggingMethodsNode *) m_pParentOfNodeBeingModified)->GetServerRoot();
	
	_ASSERTE( pServerNode != NULL );

	if( pServerNode->m_bConfigureLocal )
	{
		// We are local.
		::EnableWindow( GetDlgItem( IDC_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE ), TRUE );
	}
	else
	{
		// We are remote
		::EnableWindow( GetDlgItem( IDC_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE ), FALSE );
	}

	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::OnChange

Called when the WM_COMMAND message is sent to our page with any of the
BN_CLICKED, EN_CHANGE or CBN_SELCHANGE notifications.

This is our chance to check to see what the user has touched, set the
dirty bits for these items so that only they will be saved,
and enable the Apply button.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLocalFileLoggingPage2::OnChange(		
							  UINT uMsg
							, WPARAM wParam
							, HWND hwnd
							, BOOL& bHandled
							)
{
	ATLTRACE(_T("# CLocalFileLoggingPage2::OnChange\n"));

	
	// Check for preconditions:
	// None.
	

	// We don't want to prevent anyone else down the chain from receiving a message.
	bHandled = FALSE;


	// Figure out which item has changed and set the dirty bit for that item.
	int iItemID = (int) LOWORD(wParam);

	switch( iItemID )
	{
//	case IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG:
//		m_fDirtyAutomaticallyOpenNewLog = TRUE;
//		break;
	case IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY:
	case IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY:
	case IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY:
	case IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES:
	case IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED:
		m_fDirtyFrequency = TRUE;
		break;
	case IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE:
		m_fDirtyLogFileSize = TRUE;
		break;
	case IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY:
		m_fDirtyLogFileDirectory = TRUE;
		break;
	case IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC:
	case IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1:
		m_fDirtyLogInV1Format = TRUE;
		break;
	default:
		return TRUE;
		break;
	}

	// We should only get here if the item that changed was
	// one of the ones we were checking for.
	// This enables the Apply button.
	SetModified( TRUE );

	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::BrowseCallbackProc

Needed so that we can set the directory which the Browse for Directory dialog displays.

--*/
//////////////////////////////////////////////////////////////////////////////
int CALLBACK BrowseCallbackProc(HWND hwnd,UINT uMsg,LPARAM lp, LPARAM pData)
{


	switch(uMsg)
	{
		case BFFM_INITIALIZED:
			// pData contains the data we passed in as BROWSEINFO.lParam
			// It should a string form of the directory we want the browser to show initially.
			if( NULL != pData )
			{
				// WParam is TRUE since you are passing a path.
				// It would be FALSE if you were passing a pidl.
				SendMessage(hwnd,BFFM_SETSELECTION,TRUE,(LPARAM)pData);
			}
			break;
		default:
			break;
	}

	return 0;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::OnBrowse

Action to be taken when the user clicks on the browse button to choose
a directory where log files should be saved.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLocalFileLoggingPage2::OnBrowse(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# CLocalFileLoggingPage2::OnBrowse\n"));


#ifdef USE_GETSAVEFILENAME

	OPENFILENAME ofnInfo;
	TCHAR szFileName[MAX_PATH + 1];		// buffer must be one TCHAR longer than we say it is later -- see KB Q137194
	TCHAR szDialogTitle[IAS_MAX_STRING];



	// Initialize the data structure we will pass to GetSaveFileName.
	memset(&ofnInfo, 0, sizeof(OPENFILENAME));

	// Put a NULL in the first character of szFileName to indicate that
	// no initialization is necessary.
	szFileName[0] = NULL;

	// Set the dialog title.
	int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_BROWSE_DIALOG__TITLE, szDialogTitle, IAS_MAX_STRING );
	_ASSERT( nLoadStringResult > 0 );

	ofnInfo.lStructSize = sizeof(OPENFILENAME);
	ofnInfo.hwndOwner = hwnd;
	ofnInfo.lpstrFile = szFileName;
	ofnInfo.nMaxFile = MAX_PATH;
	ofnInfo.lpstrTitle = szDialogTitle;


	if( 0 != GetSaveFileName( &ofnInfo ) )
	{
		// The user hit OK.  We should save the chosen directory in the text box.

		CComBSTR bstrText = ofnInfo.lpstrFile;

		SetDlgItemText(IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY, bstrText );

	}
	else
	{

		// An error occured or the user hit cancel -- find out which.

		DWORD dwError = CommDlgExtendedError();

		if( 0 == dwError )
		{
			// The user simply cancelled or closed the dialog box -- no error occured.
		}
		else
		{

			// Some error occurred.
			// ISSUE: We should be giving more detailed error info here.
			ShowErrorDialog( m_hWnd, USE_DEFAULT,  NULL, 0, IDS_ERROR__LOGGING_TITLE);
		}


	}
	
#else // DON'T USE_GETSAVEFILENAME

	BROWSEINFO biInfo;

	TCHAR szFileName[MAX_PATH + 1];
	TCHAR szDialogTitle[IAS_MAX_STRING];


	// Initialize the data structure we will pass to GetSaveFileName.
	memset(&biInfo, 0, sizeof(BROWSEINFO));

	// Put a NULL in the first character of szFileName to indicate that
	// no initialization is necessary.
	szFileName[0] = NULL;

	// Set the dialog title.
	int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_BROWSE_DIALOG__TITLE, szDialogTitle, IAS_MAX_STRING );
	_ASSERT( nLoadStringResult > 0 );


	CComBSTR bstrText;
	GetDlgItemText(IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY,(BSTR &) bstrText );

	biInfo.hwndOwner = hwnd;
	biInfo.pszDisplayName = szFileName;
	biInfo.lpszTitle = szDialogTitle;
	biInfo.lpfn = BrowseCallbackProc;
	biInfo.lParam = (LPARAM) bstrText.m_str;

	LPITEMIDLIST lpItemIDList;

	lpItemIDList = SHBrowseForFolder( & biInfo );

	if( lpItemIDList != NULL )
	{
		// The user hit OK.  We should save the chosen directory in the text box.

		// ISSUE: Need to release the lpItemIDLust structure allocated by the call
		// using the shell's task allocator (how???)

		// Convert the ItemIDList to a path.
		// We clobber the old szFileName here because we don't care about it. (It didn't have the full path.)
		BOOL bSuccess = SHGetPathFromIDList( lpItemIDList, szFileName );

		if( bSuccess )
		{

			CComBSTR bstrText = szFileName;

			SetDlgItemText(IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY, bstrText );

		}
		else
		{
			// Handle error
			ShowErrorDialog( m_hWnd, IDS_ERROR__NOT_A_VALID_DIRECTORY, NULL, 0 , IDS_ERROR__LOGGING_TITLE );

		}

	}
	else
	{

		// An error occured or the user hit cancel -- find out which.

		// SHBrowseInfo seems to have no error checking capabilities.
		// The docs say that if it succeeded, it returns non-NULL, and
		// if the user chooses Cancel, it returns NULL.
		// I tried GetLastError to make sure that there was no error,
		// but it gives back 0x00000006 "Invalid handle" even if I
		// do SetLastError(0) before I make any calls.
		// So it seems that we have no choice but to assume that
		// if we get here, there was no error,
		// it was simply that the user chose Cancel.

	}


#endif // USE_GETSAVEFILENAME


	return TRUE;	// ISSUE: what do we need to be returning here?


}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::OnApply

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnApply gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnApply method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CLocalFileLoggingPage2::OnApply()
{
	ATLTRACE(_T("# CLocalFileLoggingPage2::OnApply\n"));
	

	// Check for preconditions:
	_ASSERT( m_pSynchronizer != NULL );


	if( m_spSdoAccounting == NULL )
	{
		ShowErrorDialog( m_hWnd, IDS_ERROR__NO_SDO, NULL, 0, IDS_ERROR__LOGGING_TITLE );
		return FALSE;
	}

	
	CComBSTR			bstrNumberAsText;
	BOOL				bResult;
	HRESULT				hr;
	BOOL				bTemp;
	LONG				lTemp;
	CComBSTR			bstrTemp;
	
//	if( m_fDirtyAutomaticallyOpenNewLog )
//	{
//		bTemp = SendDlgItemMessage( IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG, BM_GETCHECK, 0, 0);
//		hr = PutSdoBOOL( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_OPEN_NEW, bTemp, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_AUTOMATICALLY_OPEN_NEW_LOG, m_hWnd, NULL );
//		if( FAILED( hr ) )
//		{
//			// Reset the ref count so all pages know that we need to play the game again.
//			m_pSynchronizer->ResetCountToHighest();
//
//			// This uses the resource ID of this page to make this page the current page.
//			PropSheet_SetCurSelByID( GetParent(), IDD );
//			
//			return FALSE;
//		}
//		else
//		{
//			// We succeeded.
//
//			// Turn off the dirty bit.
//			m_fDirtyAutomaticallyOpenNewLog = FALSE;
//		}
//	}

	if( m_fDirtyFrequency )
	{
		NEW_LOG_FILE_FREQUENCY nlffFrequency = IAS_LOGGING_MONTHLY;

		if( ::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY ), BM_GETCHECK, 0, 0 ) )
			nlffFrequency = IAS_LOGGING_DAILY;
		else if( ::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY ), BM_GETCHECK, 0, 0 ) )
			nlffFrequency = IAS_LOGGING_WEEKLY;
		else if( ::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY ), BM_GETCHECK, 0, 0 ) )
			nlffFrequency = IAS_LOGGING_MONTHLY;
		else if( ::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED ), BM_GETCHECK, 0, 0 ) )
			nlffFrequency = IAS_LOGGING_UNLIMITED_SIZE;
		else
			nlffFrequency = IAS_LOGGING_WHEN_FILE_SIZE_REACHES;
		hr = PutSdoI4( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_OPEN_NEW_FREQUENCY, nlffFrequency, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_NEW_LOG_FREQUENCY, m_hWnd, NULL );
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			
			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyFrequency = FALSE;
		}
	}
	

	if( m_fDirtyLogFileSize )
	{


		// When a user enters some (potentially invalid) data, but
		// then disables the option using that data, we don't try to save this data.
		int iChecked = ::SendMessage( GetDlgItem(IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES), BM_GETCHECK, 0, 0 );
		int iEnabled = ::IsWindowEnabled( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES ) );

		if( iChecked && iEnabled )
		{
			bResult = GetDlgItemText( IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE, (BSTR &) bstrNumberAsText );
			if( ! bResult )
			{
				// We couldn't retrieve a BSTR, in other words the field was blank.
				// This is an error.
				ShowErrorDialog( m_hWnd, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_WHEN_LOG_FILE_SIZE_NOT_ZERO, NULL, 0, IDS_ERROR__LOGGING_TITLE );

				// Reset the ref count so all pages know that we need to play the game again.
				m_pSynchronizer->ResetCountToHighest();

				// This uses the resource ID of this page to make this page the current page.
				PropSheet_SetCurSelByID( GetParent(), IDD );
			
				return FALSE;
			}
			lTemp = _ttol( bstrNumberAsText );
			if( lTemp <= 0  || lTemp > LOG_SIZE_LIMIT)
			{
				// If result here was zero, this indicates an error.
				ShowErrorDialog( m_hWnd, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_WHEN_LOG_FILE_SIZE_NOT_ZERO, NULL, 0, IDS_ERROR__LOGGING_TITLE );

				// Reset the ref count so all pages know that we need to play the game again.
				m_pSynchronizer->ResetCountToHighest();

				// This uses the resource ID of this page to make this page the current page.
				PropSheet_SetCurSelByID( GetParent(), IDD );
			
				return FALSE;
			
			}
			bstrNumberAsText.Empty();
			hr = PutSdoI4( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_OPEN_NEW_SIZE, lTemp, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_WHEN_LOG_FILE_SIZE, m_hWnd, NULL );
			if( FAILED( hr ) )
			{
				// Reset the ref count so all pages know that we need to play the game again.
				m_pSynchronizer->ResetCountToHighest();

				// This uses the resource ID of this page to make this page the current page.
				PropSheet_SetCurSelByID( GetParent(), IDD );
			
				return FALSE;
			}
			else
			{
				// We succeeded.

				// Turn off the dirty bit.
				m_fDirtyLogFileSize = FALSE;
			}
		}
	}

	if( m_fDirtyLogFileDirectory )
	{
		bResult = GetDlgItemText( IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY, (BSTR &) bstrTemp );
		if( ! bResult )
		{
			// We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
			bstrTemp = _T("");
		}
		hr = PutSdoBSTR( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_FILE_DIRECTORY, &bstrTemp, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_LOG_FILE_DIRECTORY, m_hWnd, NULL );
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );

			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyLogFileDirectory = FALSE;

		}
		bstrTemp.Empty();
	}

// The log file name is not something we set -- the server's accounting provider determines it based on the frequency we choose.
//
//	spVariant.vt = VT_BSTR;
//	bResult = GetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, spVariant.bstrVal );
//	if( ! bResult )
//	{
//		// We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
//		spVariant.bstrVal = SysAllocString( _T("") );
//	}
//	hr = m_spSdoAccounting->PutProperty( PROPERTY_ACCOUNTING_LOG_FILE, &spVariant );
//	spVariant.Clear();
//	if( FAILED( hr ) )
//	{
//		// Figure out error and give back appropriate messsage.
//		
//		m_spSdoClient->LastError( &bstrError );
//		ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, bstrError );
//
//		// Reset the ref count so all pages know that we need to play the game again.
//		m_pSynchronizer->ResetCountToHighest();
//
//		// This uses the resource ID of this page to make this page the current page.
//		PropSheet_SetCurSelByID( GetParent(), IDD );
//
//		return FALSE;
//	}

	if( m_fDirtyLogInV1Format )
	{
		if( SendDlgItemMessage( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1, BM_GETCHECK, 0, 0) )
		{
			lTemp = LOG_FILE_FORMAT__IAS1;
		}
		else
		{
			lTemp = LOG_FILE_FORMAT__ODBC;
		}

 		hr = PutSdoI4( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_IAS1_FORMAT, lTemp, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_LOG_FILE_FORMAT, m_hWnd, NULL );
		if( FAILED( hr ) )
		{
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );
			
			return FALSE;
		}
		else
		{
			// We succeeded.

			// Turn off the dirty bit.
			m_fDirtyLogInV1Format = FALSE;
		}
	}


	// If we made it to here, try to apply the changes.

	// Check to see if there are other pages which have not yet validated their data.
	LONG lRefCount = m_pSynchronizer->LowerCount();
	if( lRefCount <= 0 )
	{
		// There is nobody else left, so now we can commit the data.
	
		hr = m_spSdoAccounting->Apply();
		if( FAILED( hr ) )
		{
			if(hr == DB_E_NOTABLE)	// assume, the RPC connection has problem
				ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO, NULL, 0, IDS_ERROR__LOGGING_TITLE );
			else 
			{		
//			m_spSdoAccounting->LastError( &bstrError );
//			ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, bstrError );
				ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, NULL, 0, IDS_ERROR__LOGGING_TITLE );
			}
			// Reset the ref count so all pages know that we need to play the game again.
			m_pSynchronizer->ResetCountToHighest();

			// This uses the resource ID of this page to make this page the current page.
			PropSheet_SetCurSelByID( GetParent(), IDD );

			return FALSE;
		}
		else
		{
			// We succeeded.

			// The data was accepted, so notify the main context of our snapin
			// that it may need to update its views.
			CChangeNotification * pChangeNotification = new CChangeNotification();
			pChangeNotification->m_dwFlags = CHANGE_UPDATE_RESULT_NODE;
			pChangeNotification->m_pNode = m_pNodeBeingModified;
			pChangeNotification->m_pParentNode = m_pParentOfNodeBeingModified;

			HRESULT hr = PropertyChangeNotify( (LPARAM) pChangeNotification );
			_ASSERTE( SUCCEEDED( hr ) );


			// Tell the service to reload data.
			HRESULT hrTemp = m_spSdoServiceControl->ResetService();
			if( FAILED( hrTemp ) )
			{
				// Fail silently.
			}

		}
	}


	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::OnQueryCancel

Return values:

	TRUE if the page can be destroyed,
	FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

	OnQueryCancel gets called for each page in on a property sheet if that
	page has been visited, regardless of whether any values were changed.

	If you never switch to a tab, then its OnQueryCancel method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CLocalFileLoggingPage2::OnQueryCancel()
{
	ATLTRACE(_T("# CLocalFileLoggingPage2::OnQueryCancel\n"));

	
	HRESULT hr;

	if( m_spSdoAccounting != NULL )
	{
		// If the user wants to cancel, we should make sure that we rollback
		// any changes the user may have started.

		// If the user had not already tried to commit something,
		// a cancel on an SDO will hopefully be designed to be benign.
		
		hr = m_spSdoAccounting->Restore();
		// Don't care about the HRESULT, but it might be good to see it for debugging.

	}

	return TRUE;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::OnAutomaticallyOpenNewLog


Remarks:

	Called when the user clicks on the Enable Logging check box.

--*/
//////////////////////////////////////////////////////////////////////////////
//LRESULT CLocalFileLoggingPage2::OnAutomaticallyOpenNewLog(
//		  UINT uMsg
//		, WPARAM wParam
//		, HWND hwnd
//		, BOOL& bHandled
//		)
//{
//	ATLTRACE(_T("# CLocalFileLoggingPage2::OnAutomaticallyOpenNewLog\n"));
//
//	// The Enable Logging button has been checked -- check dependencies.
//	SetAutomaticallyOpenNewLogDependencies();
//
//	// This return value is ignored.
//	return TRUE;
//}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::OnNewLogInterval


Remarks:

	Called when the user clicks on the Enable Logging check box.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLocalFileLoggingPage2::OnNewLogInterval(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		)
{
	ATLTRACE(_T("# CLocalFileLoggingPage2::OnNewLogInterval\n"));

	// The Enable Logging button has been checked -- check dependencies.
	SetLogFileFrequencyDependencies();

	// This return value is ignored.
	return TRUE;
}




//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::SetAutomaticallyOpenNewLogDependencies

Remarks:

	Utility to set state of items which may depend on the
	Enable Logging check box.

	Call whenever something changes the state of IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG.

	This will worry about all items dependent on this item.

--*/
//////////////////////////////////////////////////////////////////////////////
//void CLocalFileLoggingPage2::SetAutomaticallyOpenNewLogDependencies( void )
//{
//	ATLTRACE(_T("# CLocalFileLoggingPage2::SetAutomaticallyOpenNewLogDependencies\n"));
//
//	// Ascertain what the state of the check box is.
//	int iChecked = ::SendMessage( GetDlgItem(IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG), BM_GETCHECK, 0, 0 );
//
//	if( iChecked )
//	{
//		// Make sure the correct items are enabled.
//	
//		::EnableWindow( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY), TRUE );
//		::EnableWindow( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY), TRUE );
//		::EnableWindow( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY), TRUE );
//		::EnableWindow( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES), TRUE );
//	
//	}
//	else
//	{
//		// Make sure the correct items are enabled.
//
//		::EnableWindow( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY), FALSE );
//		::EnableWindow( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY), FALSE );
//		::EnableWindow( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY), FALSE );
//		::EnableWindow( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES), FALSE );
//
//	}
//
//	// WHEN_LOG_FILE_REACHES button has items depending on it
//	SetLogFileFrequencyDependencies();
//
//}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::SetLogFileFrequencyDependencies

Remarks:

	Utility to set state of items which may depend on the
	"When log file size reaches" radio button.

	Call whenever something changes the state of
	IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES
	or any of the other logging frequency radio buttons.

--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalFileLoggingPage2::SetLogFileFrequencyDependencies( void )
{
	ATLTRACE(_T("# CLocalFileLoggingPage2::SetLogFileFrequencyDependencies\n"));


	int nLoadStringResult;
	TCHAR szDaily[IAS_MAX_STRING];
	TCHAR szWeekly[IAS_MAX_STRING];
	TCHAR szMonthly[IAS_MAX_STRING];
	TCHAR szWhenLogFileSizeReaches[IAS_MAX_STRING];


	nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__DAILY_FORMAT, szDaily, IAS_MAX_STRING );
	_ASSERT( nLoadStringResult > 0 );

	nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__WEEKLY_FORMAT, szWeekly, IAS_MAX_STRING );
	_ASSERT( nLoadStringResult > 0 );

	nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__MONTHLY_FORMAT, szMonthly, IAS_MAX_STRING );
	_ASSERT( nLoadStringResult > 0 );

	nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_SIZE_REACHES_FORMAT, szWhenLogFileSizeReaches, IAS_MAX_STRING );
	_ASSERT( nLoadStringResult > 0 );



	// Set the text to appear as the log file name.
	if( ::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY ), BM_GETCHECK, 0, 0 ) )
		SetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, szDaily );
	else if( ::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY ), BM_GETCHECK, 0, 0 ) )
		SetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, szWeekly );
	else if( ::SendMessage( GetDlgItem(IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY ), BM_GETCHECK, 0, 0 ) )
		SetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, szMonthly );
	else
		// This takes care of both the UNLIMITED and the WHEN_LOG_FILE_SIZE_REACHES case -- they both
		// use the same format of filename.
		SetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, szWhenLogFileSizeReaches );
	
	
	// Ascertain what the state of the IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES radio button is.
	int iChecked = ::SendMessage( GetDlgItem(IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES), BM_GETCHECK, 0, 0 );
	int iEnabled = ::IsWindowEnabled( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES ) );

	if( iChecked && iEnabled )
	{
		// Make sure the correct items are enabled.
	
		::EnableWindow( GetDlgItem( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE_UNITS), TRUE );
		::EnableWindow( GetDlgItem( IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE), TRUE );
	
	}
	else
	{
		// Make sure the correct items are enabled.

		::EnableWindow( GetDlgItem( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE_UNITS), FALSE );
		::EnableWindow( GetDlgItem( IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE), FALSE );

	}

}



/////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::GetHelpPath

Remarks:

	This method is called to get the help file path within
	an compressed HTML document when the user presses on the Help
	button of a property sheet.

	It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalFileLoggingPage2::GetHelpPath( LPTSTR szHelpPath )
{
	ATLTRACE(_T("# CLocalFileLoggingPage2::GetHelpPath\n"));


	// Check for preconditions:



#ifdef UNICODE_HHCTRL
	// ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
	// installed on this machine -- it appears to be non-unicode.
	lstrcpy( szHelpPath, _T("idh_proppage_local_file_logging2.htm") );
#else
	strcpy( (CHAR *) szHelpPath, "idh_proppage_local_file_logging2.htm" );
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\locwarndlg.h ===
/****************************************************************************************
 * NAME:	LocWarnDlg.h
 *
 * CLASS:	CLocationWarningDialog
 *
 * OVERVIEW
 *
 * Internet Authentication Server: NAP Location dialog
 *			This dialog box is used to change the Network Access Policy Location 
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				4/12/98		Created by	Byao	
 *
 *****************************************************************************************/

#ifndef _LOCWARNDLG_H_
#define _LOCWARNDLG_H_

#include "dialog.h"

/////////////////////////////////////////////////////////////////////////////
// CLocationWarningDlg
class CLocationWarningDialog: public CIASDialog<CLocationWarningDialog>
{
public:
	CLocationWarningDialog();
	~CLocationWarningDialog();

	enum { IDD = IDD_DIALOG_POLICY_WARNING };

BEGIN_MSG_MAP(CLocationWarningDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	
	CHAIN_MSG_MAP(CIASDialog<CLocationWarningDialog>)
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
};

#endif //_LOCWARNDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\locwarndlg.cpp ===
/****************************************************************************************
 * NAME:	LocWarnDlg.cpp
 *
 * CLASS:	CLocationWarningDialog
 *
 * OVERVIEW
 *
 * Internet Authentication Server: 
 *			This dialog box is used to warn the user when user changes policy
 *			location
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				4/12/98		Created by	Byao	
 *
 *****************************************************************************************/

#include "Precompiled.h"
#include "LocWarnDlg.h"

// Constructor/Destructor
CLocationWarningDialog::CLocationWarningDialog()
{

}

CLocationWarningDialog::~CLocationWarningDialog()
{
}


LRESULT CLocationWarningDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	TRACE_FUNCTION("CLocationWarningDialog::OnInitDialog");

	return 1;  // Let the system set the focus
}


LRESULT CLocationWarningDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CLocationWarningDialog::OnOK");

	EndDialog(wID);
	return 0;
}


LRESULT CLocationWarningDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CLocationWarningDialog::OnCancel");
	EndDialog(wID);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\localfileloggingpage2.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	LocalFileLoggingPage2.h

Abstract:

	Header file for the CLocalFileLoggingPage2 class.

	This is our handler class for the second CMachineNode property page.

	See LocalFileLoggingPage2.cpp for implementation.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_LOG_LOCAL_FILE_LOGGING_PAGE_2_H_)
#define _LOG_LOCAL_FILE_LOGGING_PAGE_2_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CLocalFileLoggingNode;

class CLocalFileLoggingPage2 : public CIASPropertyPage<CLocalFileLoggingPage2>
{

public :
	
	CLocalFileLoggingPage2( LONG_PTR hNotificationHandle, CLocalFileLoggingNode *pLocalFileLoggingNode,  TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );

	~CLocalFileLoggingPage2();


	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_PROPPAGE_LOCAL_FILE_LOGGING2 };

	BEGIN_MSG_MAP(CLocalFileLoggingPage2)
		COMMAND_CODE_HANDLER(BN_CLICKED, OnChange)		
		COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
		COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDC_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE, OnBrowse )
//		COMMAND_ID_HANDLER( IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG, OnAutomaticallyOpenNewLog )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY, OnNewLogInterval )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY, OnNewLogInterval )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY, OnNewLogInterval )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED, OnNewLogInterval )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES, OnNewLogInterval )
		CHAIN_MSG_MAP(CIASPropertyPage<CLocalFileLoggingPage2>)
	END_MSG_MAP()

	BOOL OnApply();

	BOOL OnQueryCancel();

	HRESULT GetHelpPath( LPTSTR szFilePath );



	// Pointer to stream into which this page's Sdo interface
	// pointer will be marshalled.
	LPSTREAM m_pStreamSdoAccountingMarshal;

	LPSTREAM m_pStreamSdoServiceControlMarshal;

protected:
	// Interface pointer for this page's client's sdo.
	CComPtr<ISdo>	m_spSdoAccounting;

	// Smart pointer to interface for telling service to reload data.
	CComPtr<ISdoServiceControl>	m_spSdoServiceControl;

	// When we are passed a pointer to the client node in our constructor,
	// we will save away a pointer to its parent, as this is the node
	// which will need to receive an update message once we have
	// applied any changes.
	CSnapInItem * m_pParentOfNodeBeingModified;
	CSnapInItem * m_pNodeBeingModified;

private:

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnChange(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnBrowse(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

//	LRESULT OnAutomaticallyOpenNewLog(
//		  UINT uMsg
//		, WPARAM wParam
//		, HWND hwnd
//		, BOOL& bHandled
//		);

	LRESULT OnNewLogInterval(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);


//	void SetAutomaticallyOpenNewLogDependencies( void );
	void SetLogFileFrequencyDependencies( void );

protected:

	// Dirty bits -- for keeping track of data which has been touched
	// so that we only save data we have to.
	BOOL m_fDirtyAutomaticallyOpenNewLog;
	BOOL m_fDirtyFrequency;
	BOOL m_fDirtyLogFileSize;
	BOOL m_fDirtyLogFileDirectory;
	BOOL m_fDirtyLogInV1Format;

};

#endif // _LOG_LOCAL_FILE_LOGGING_PAGE_2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\logabout.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LogAbout.cpp

Abstract:

	Implementation file for the CLoggingSnapinAbout class.

	The CLoggingSnapinAbout class implements the ISnapinAbout interface which enables the MMC 
	console to get copyright and version information from the snap-in.
	The console also uses this interface to obtain images for the static folder
	from the snap-in.


Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "LogAbout.h"
//
//
// where we can find declarations needed in this file:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingSnapinAbout::GetSnapinDescription


Enables the console to obtain the text for the snap-in's description box.


HRESULT GetSnapinDescription(
  LPOLESTR * lpDescription  // Pointer to the description text.
);

  
Parameters

lpDescription 
[out] Pointer to the text for the description box on an About property page. 


Return Values

S_OK 
The text was successfully obtained. 


Remarks
Memory for out parameters must be allocated using CoTaskMemAlloc. This function is documented in the Platform SDK.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingSnapinAbout::GetSnapinDescription (LPOLESTR *lpDescription)
{
	ATLTRACE(_T("+NAPMMC+:# CLoggingSnapinAbout::GetSnapinDescription\n"));

	USES_CONVERSION;

	TCHAR szBuf[256];
	if (::LoadString(_Module.GetResourceInstance(), IDS_NAPSNAPIN_DESC, szBuf, 256) == 0)
		return E_FAIL;

	*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
	if (*lpDescription == NULL)
		return E_OUTOFMEMORY;

	ocscpy(*lpDescription, T2OLE(szBuf));

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingSnapinAbout::GetProvider


Enables the console to obtain the snap-in provider's name.


HRESULT GetProvider(
  LPOLESTR * lpName  // Pointer to the provider's name
);

  
Parameters

lpName 
[out] Pointer to the text making up the snap-in provider's name. 


Return Values

S_OK 
The name was successfully obtained. 


Remarks

M