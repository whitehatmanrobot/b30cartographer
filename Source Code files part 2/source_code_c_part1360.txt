          {
                    //--- Fill another frame of speech audio
                    hr = m_BEObj.RenderFrame( );
                }
                while( (hr == S_OK) && (m_BEObj.GetSpeechState() == SPEECH_CONTINUE) );            
            }
        }

        //--- Debug Macro - close debugging file
        TTSDBG_CLOSEFILE;
    }

    return hr;
} /* CTTSEngine::Speak */

/****************************************************************************
* CTTSEngine::GetOutputFormat *
*-----------------------------*
*   Description:
*
*   Returns:
*
******************************************************************* PACOG ***/

STDMETHODIMP CTTSEngine::GetOutputFormat(const GUID * pTargetFormatId, const WAVEFORMATEX * /* pTargetWaveFormatEx */,
                                         GUID * pDesiredFormatId, WAVEFORMATEX ** ppCoMemDesiredWaveFormatEx)
{
    SPDBG_FUNC("CTTSEngine::GetOutputFormat");
    HRESULT hr = S_OK;

    if( ( SP_IS_BAD_WRITE_PTR(pDesiredFormatId)  ) || 
		( SP_IS_BAD_WRITE_PTR(ppCoMemDesiredWaveFormatEx) ) )
    {
        hr = E_INVALIDARG;
    }
    else if (pTargetFormatId == NULL || *pTargetFormatId != SPDFID_Text)
    {
        *pDesiredFormatId = SPDFID_WaveFormatEx;
        *ppCoMemDesiredWaveFormatEx = (WAVEFORMATEX *)::CoTaskMemAlloc(sizeof(WAVEFORMATEX));
        if (*ppCoMemDesiredWaveFormatEx)
        {
            **ppCoMemDesiredWaveFormatEx = m_VoiceInfo.WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *pDesiredFormatId = SPDFID_Text;
        *ppCoMemDesiredWaveFormatEx = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/*****************************************************************************
* CTTSEngine::InitDriver *
*------------------------*
*   Description:
*       Init driver with new voice.
********************************************************************** MC ***/
HRESULT CTTSEngine::InitDriver()
{
    SPDBG_FUNC( "CTTSEngine::InitDriver" );
    HRESULT hr = S_OK;
    
    //--------------------------
    // Get voice information
    //--------------------------
    hr = m_pVoiceDataObj->GetVoiceInfo( &m_VoiceInfo );
	if( SUCCEEDED(hr) )
	{
		m_SampleRate = m_VoiceInfo.SampleRate;

		//-----------------------------
		// Reverb is always stereo
		//-----------------------------
		if (m_VoiceInfo.eReverbType != REVERB_TYPE_OFF )
		{
			//------------------
			// Stereo
			//------------------
			m_IsStereo = true;
			m_BytesPerSample = 4;
		}
		else
		{
			//------------------
			// MONO
			//------------------
			m_IsStereo = false;
			m_BytesPerSample = 2;
		}

		//--------------------------
		// Initialize BACKEND obj
		//--------------------------
		hr =  m_BEObj.Init( m_pVoiceDataObj, &m_FEObj, &m_VoiceInfo );

		//--------------------------
		// Initialize FRONTEND obj
		//--------------------------
		if( SUCCEEDED( hr ))
		{
			hr =  m_FEObj.Init( m_pVoiceDataObj, NULL, &m_VoiceInfo );
		}
    }
    return hr;
} /* CTTSEngine::InitDriver */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\ttsengine.h ===
/******************************************************************************
* TTSEngine.h *
*-------------*
*  This is the header file for the CTTSEngine implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef TTSEngine_h
#define TTSEngine_h

//--- Additional includes
#ifndef __spttseng_h__
#include "spttseng.h"
#endif

#ifndef SPDDKHLP_h
#include <spddkhlp.h>
#endif

#ifndef SPHelper_h
#include <sphelper.h>
#endif

#ifndef Backend_H
#include "Backend.h"
#endif

#ifndef Frontend_H
#include "Frontend.h"
#endif

#ifndef FeedChain_H
#include "FeedChain.h"
#endif

#include "resource.h"

//=== Constants ====================================================
#define TEXT_VOICE_FMT_INDEX    1

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CTTSEngine COM object ********************************
*/
class ATL_NO_VTABLE CTTSEngine : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTTSEngine, &CLSID_MSTTSEngine>,
	public ISpTTSEngine,
    public IMSTTSEngineInit
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_MSTTSENGINE)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CTTSEngine)
	    COM_INTERFACE_ENTRY(ISpTTSEngine)
	    COM_INTERFACE_ENTRY(IMSTTSEngineInit)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    HRESULT FinalConstruct();
    void FinalRelease();

    /*--- Non interface methods ---*/
	HRESULT InitDriver();
    
    /*=== Interfaces ====*/
  public:
    //--- IMSTTSEngineInit ----------------------------------------
    STDMETHOD(VoiceInit)( IMSVoiceData* pVoiceData );

    //--- ISpTTSEngine --------------------------------------------
    STDMETHOD(Speak)( DWORD dwSpeakFlags,
                      REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx,
                      const SPVTEXTFRAG* pTextFragList, ISpTTSEngineSite* pOutputSite );
    STDMETHOD(GetOutputFormat)( const GUID * pTargetFormatId, const WAVEFORMATEX * pTargetWaveFormatEx,
                                GUID * pDesiredFormatId, WAVEFORMATEX ** ppCoMemDesiredWaveFormatEx );

  private:
  /*=== Member Data ===*/
    CComPtr<IEnumSpSentence>    m_cpSentEnum;
	CBackend                    m_BEObj;
	CFrontend                   m_FEObj;
    IMSVoiceData				*m_pVoiceDataObj;        // This should not AddRef
	ULONG                       m_BytesPerSample;
    bool                        m_IsStereo;
    ULONG                       m_SampleRate;
    MSVOICEINFO                 m_VoiceInfo;
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\syllabletagger.cpp ===
/******************************************************************************
* SyllableTagger.cpp *
*--------------------*
*
*  This is an implementation of the CSyllableTagger class.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 04/28/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

//--- Additional includes
#include "stdafx.h"

#ifndef SPDebug_h
    #include <spdebug.h>
#endif
 
#ifndef AlloOps_H
    #include "AlloOps.h"
#endif

//-----------------------------
// Data.cpp
//-----------------------------
extern const unsigned long    g_AlloFlags[];

/*****************************************************************************
* CSyllableTagger::If_Consonant_Cluster *
*---------------------------------------*
*   Description:
*   Return TRUE if consoants can be clustered.
*       
********************************************************************** MC ***/
short CSyllableTagger::If_Consonant_Cluster( ALLO_CODE Consonant_1st, ALLO_CODE Consonant_2nd)
{
    SPDBG_FUNC( "CSyllableTagger::If_Consonant_Cluster" );
    short ret;
    
    ret = false;

    switch( Consonant_1st)
    {
        //---------------------------
        // f -> r,l
        //---------------------------
        case _f_:
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_:
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // v -> r,l
        //---------------------------
        case _v_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_: 
                {
                    ret = true;
                }
                break;
            }
        }
        break;

        //---------------------------
        // TH -> r,w
        //---------------------------
        case _TH_:
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _w_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // s -> w,l,p,t,k,m,n,f
        //---------------------------
        case _s_: 
        {
            switch( Consonant_2nd)
            {
                case _w_:
                case _l_:
                case _p_:
                case _t_:
                case _k_:
                case _m_:
                case _n_:
                case _f_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // SH -> w,l,p,t,r,m,n
        //---------------------------
        case _SH_: 
        {
            switch( Consonant_2nd)
            {
                case _w_:
                case _l_:
                case _p_:
                case _t_:
                case _r_:
                case _m_:
                case _n_: 
                {
                    ret = true;
                }
                break;
            }
        }
        break;

        //---------------------------
        // p -> r,l
        //---------------------------
        case _p_:
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // b -> r,l
        //---------------------------
        case _b_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // t -> r,w
        //---------------------------
        case _t_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _w_:
                {
                    ret = true;
                }
            }
        }
        break;

        //---------------------------
        // d -> r,w
        //---------------------------
        case _d_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _w_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // k -> r,l,w
        //---------------------------
        case _k_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_:
                case _w_:
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // g -> r,l,w
        //---------------------------
        case _g_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_:
                case _w_: 
                {
                    ret = true; 
                }
            break;
            }
        }
        break;
    }
    return ret;
} /* CSyllableTagger::If_Consonant_Cluster */





/*****************************************************************************
* CSyllableTagger::Find_Next_Word_Bound *
*---------------------------------------*
*   Description:
*   Return allo index for next word boundary
*       
********************************************************************** MC ***/
short CSyllableTagger::Find_Next_Word_Bound( short index )
{
    SPDBG_FUNC( "CSyllableTagger::Find_Next_Word_Bound" );
    ALLO_ARRAY   *pCurAllo;
    
    long   i;
    
    for( i = index+1; i < m_numOfCells; i++ )
    {
        pCurAllo = &m_pAllos[i];
        if( pCurAllo->ctrlFlags & (BOUNDARY_TYPE_FIELD | WORD_START) )
        {
            break;
        }
    }
    return (short)i;
} /* CSyllableTagger::Find_Next_Word_Bound */


/*****************************************************************************
* CSyllableTagger::MarkSyllableStart *
*------------------------------------*
*   Description:
*   Mark SYLLABLE_START positions
*  
********************************************************************** MC ***/
void CSyllableTagger::MarkSyllableStart()
{
    SPDBG_FUNC( "CSyllableTagger::MarkSyllableStart" );
    short       index;
    long        cur_Ctrl;
    long        cur_AlloFlags;
    short       dist, syllable_index;
    ALLO_CODE       phon_1st, phon_2nd;
    long        syllOrder;
    ALLO_ARRAY   *pCurAllo;
    
    syllable_index = 0;
    for( index = 0; index < m_numOfCells; )
    {
        pCurAllo = &m_pAllos[index];
        //-------------------------------
        // Skip SIL
        //-------------------------------
        while( pCurAllo->allo == _SIL_)
        {
            syllable_index++;
            index++;
            if( index >= m_numOfCells)
            {
                break;
            }
            pCurAllo = &m_pAllos[index];
        }
        if( index < m_numOfCells)
        {
            pCurAllo = &m_pAllos[index];
            cur_Ctrl = pCurAllo->ctrlFlags;
            cur_AlloFlags = ::g_AlloFlags[pCurAllo->allo];
            if( cur_AlloFlags & KVOWELF)
            {
                pCurAllo = &m_pAllos[syllable_index];
                pCurAllo->ctrlFlags |= SYLLABLE_START;
                syllOrder = cur_Ctrl & SYLLABLE_ORDER_FIELD;
                if( (syllOrder == ONE_OR_NO_SYLLABLE_IN_WORD) 
                    || (syllOrder == LAST_SYLLABLE_IN_WORD) )
                {
                    index = Find_Next_Word_Bound( index );
                    syllable_index = index;
                }
                else
                {
                    //----------------------------------------------
                    // It's either the 1st or mid vowel in word. 
                    // Scan forward for consonants.  
                    //----------------------------------------------
                    dist = (-1 );
                    do
                    {
                        index++;
                        pCurAllo = &m_pAllos[index];
                        cur_AlloFlags = g_AlloFlags[pCurAllo->allo];
                        dist++;         // count number of consonants   
                    }
                    while( !(cur_AlloFlags & KVOWELF) );
                
                    if( dist == 0)
                    {
                        syllable_index = index;
                    }
                
                    else if( dist == 1)
                    {
                        index--;        // start next syllable on consonant 
                        syllable_index = index;
                    }
                
                    else if( dist == 2)
                    {
                        pCurAllo = &m_pAllos[index-1];
                        phon_2nd = pCurAllo->allo;
                        pCurAllo = &m_pAllos[index-2];
                        phon_1st = pCurAllo->allo;
                        if( If_Consonant_Cluster( phon_1st, phon_2nd) )
                        {
                            index -= 2;     // start next syllable on cluster
                        }
                        else
                        {
                            index--;        // start next syllable on 2nd consonant 
                        }
                        syllable_index = index;
                    }
                
                    else if( dist == 3)
                    {
                        pCurAllo = &m_pAllos[index-1];
                        phon_2nd = pCurAllo->allo;
                        pCurAllo = &m_pAllos[index-2];
                        phon_1st = pCurAllo->allo;
                        if( If_Consonant_Cluster( phon_1st, phon_2nd) )
                        {
                         pCurAllo = &m_pAllos[index-3];
                           if( pCurAllo->allo == _s_)
                            {
                                index -= 3;     // start next syllable on s-cluster 
                            }
                            else
                            {
                                index -= 2;     // start next syllable on cluster 
                            }
                        }
                        else
                        {
                            index--;            // start next syllable on 3rd consonant 
                        }
                        syllable_index = index;
                    }
                    else
                    {
                        pCurAllo = &m_pAllos[index-dist];
                        phon_2nd = pCurAllo->allo;
                        pCurAllo = &m_pAllos[index-dist+1];
                        phon_1st = pCurAllo->allo;
                        if( If_Consonant_Cluster( phon_1st, phon_2nd) )
                        {
                            index = (short)(index - (dist - 2));   // start next syllable after cluster
                        }
                        else
                        {
                            index = (short)(index - (dist >> 1));  // start next syllable somewhere 
                                                    // in the middle  
                        }
                        syllable_index = index;
                    }
                }
            }
            else
            {
                index++;
            }
        
        }
    }
    return;
} /* CSyllableTagger::MarkSyllableStart */




/*****************************************************************************
* CSyllableTagger::MarkSyllableBoundry *
*--------------------------------------*
*   Description:
*   Mark phons in last syllable before boundry with boundry type flag  
*       
********************************************************************** MC ***/
void CSyllableTagger::MarkSyllableBoundry( long scanIndex)
{
    SPDBG_FUNC( "CSyllableTagger::MarkSyllableBoundry" );

    long   index;
    ALLO_CODE   cur_Allo;
    long    cur_AlloFlags;
    long    cur_Bound;
    long    boundType;
    ALLO_ARRAY   *pCurAllo;
    
    for( index = scanIndex+1; index < m_numOfCells; index++)
    {
        pCurAllo = &m_pAllos[index];
        cur_Allo = pCurAllo->allo;
        cur_AlloFlags = g_AlloFlags[cur_Allo];
        cur_Bound = pCurAllo->ctrlFlags & BOUNDARY_TYPE_FIELD;
        if( cur_Bound)
        {
            boundType = 0;
            
            if( cur_Bound & TERM_BOUND )
            {
                boundType |= (TERM_END_SYLL + WORD_END_SYLL );
            }
            if( cur_Bound & WORD_START )
            {
                boundType |= WORD_END_SYLL;
            }
            
            pCurAllo = &m_pAllos[scanIndex];
            pCurAllo->ctrlFlags |= boundType;
        }
        
        if( cur_AlloFlags & KVOWELF)
        {
            break;
        }
    }
} /* CSyllableTagger::MarkSyllableBoundry */



/*****************************************************************************
* CSyllableTagger::MarkSyllableOrder *
*------------------------------------*
*   Description:
*   Tag syllable ordering
*       
********************************************************************** MC ***/
void CSyllableTagger::MarkSyllableOrder( long scanIndex )
{
    SPDBG_FUNC( "CSyllableTagger::MarkSyllableOrder" );
    long       index;
    ALLO_CODE   cur_Allo;
    long        cur_Bound;
    long        cur_AlloFlags;
    long        order;
    long        cur_SyllableType;
    ALLO_ARRAY   *pCurAllo;
    
    //------------------------------------------------------------------------------
    // Scan backwards in PhonBuf_1 till word boundry and look for any other vowels. 
    // Set 'order' to LAST_SYLLABLE_IN_WORD if there are any.  
    //------------------------------------------------------------------------------
    order = 0;
    for( index = scanIndex-1; index > 0; index-- )
    {
        pCurAllo = &m_pAllos[index];
        cur_Allo = pCurAllo->allo;
        cur_AlloFlags = g_AlloFlags[cur_Allo];
        cur_SyllableType = pCurAllo->ctrlFlags & SYLLABLE_TYPE_FIELD;
        if( cur_SyllableType >= WORD_END_SYLL )
        {
            break;
        }
        
        if( cur_AlloFlags & KVOWELF )
        {
            order = LAST_SYLLABLE_IN_WORD;  // there's at least one proceeding vowel    
            break;
        }
    }
    
    //----------------------------------------------------------------------------------
    // Scan forward in PhonBuf_1 till word boundry and look for any other vowels 
    // If there's a fwd vowel but no bkwd vowel:  'order' = FIRST_SYLLABLE_IN_WORD 
    // If there's a fwd vowel and a bkwd vowel:  'order' = MID_SYLLABLE_IN_WORD 
    // If there's no fwd vowel but a bkwd vowel:  'order' = LAST_SYLLABLE_IN_WORD 
    // If there's no fwd vowel and no bkwd vowel:  'order' = 0  
    //----------------------------------------------------------------------------------
    for( index = scanIndex+1; index < m_numOfCells; index++ )
    {
        pCurAllo = &m_pAllos[index];
        cur_Allo = pCurAllo->allo;
        cur_AlloFlags = g_AlloFlags[cur_Allo];
        cur_Bound = pCurAllo->ctrlFlags & BOUNDARY_TYPE_FIELD;
        if( cur_Bound)
        {
            pCurAllo = &m_pAllos[scanIndex];
            pCurAllo->ctrlFlags |= order;
            break;
        }
        if( cur_AlloFlags & KVOWELF)
        {
            if( order == LAST_SYLLABLE_IN_WORD)
            {
                order = MID_SYLLABLE_IN_WORD;
            }
            else if( order == 0)
            {
                order = FIRST_SYLLABLE_IN_WORD;
            }
        }
    }
} /* CSyllableTagger::MarkSyllableOrder */







/*****************************************************************************
* CSyllableTagger::ListToArray *
*------------------------------*
*   Description:
*   Copy list to array
*       
********************************************************************** MC ***/
void CSyllableTagger::ListToArray( CAlloList *pAllos )
{
   SPDBG_FUNC( "CSyllableTagger::ListToArray" );
   CAlloCell   *pCurCell;
	long		cAllo;

	cAllo = 0;
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
		if( cAllo >= m_numOfCells )
		{
			break;
		}
		m_pAllos[cAllo].allo = pCurCell->m_allo;
		m_pAllos[cAllo].ctrlFlags = pCurCell->m_ctrlFlags;
		pCurCell = pAllos->GetNextCell();
		cAllo++;
    }
} /* CSyllableTagger::ListToArray */


/*****************************************************************************
* CSyllableTagger::ArrayToList *
*------------------------------*
*   Description:
*   Copy array values back into list
*       
********************************************************************** MC ***/
void CSyllableTagger::ArrayToList( CAlloList *pAllos )
{
    SPDBG_FUNC( "CSyllableTagger::ArrayToList" );
    CAlloCell   *pCurCell;
	long		cAllo;

	cAllo = 0;
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
		if( cAllo >= m_numOfCells )
		{
			break;
		}
		pCurCell->m_allo = m_pAllos[cAllo].allo;
		pCurCell->m_ctrlFlags = m_pAllos[cAllo].ctrlFlags;
		pCurCell = pAllos->GetNextCell();
		cAllo++;
    }
} /* CSyllableTagger::ArrayToList */


/*****************************************************************************
* CSyllableTagger::TagSyllables *
*---------------------------------*
*   Description:
*   Tag syllable boundaries
*       
********************************************************************** MC ***/
void CSyllableTagger::TagSyllables( CAlloList *pAllos )
{
    SPDBG_FUNC( "CSyllableTagger::TagSyllables" );
    ALLO_ARRAY   *pCurAllo;
    ALLO_CODE   cur_Allo;
    long    cur_Ctrl;
    long    scanIndex;
    long    cur_AlloFlags; 
    
	// Get allo count
	//------------------------------
    m_numOfCells = pAllos->GetCount();
	if( m_numOfCells > 0 )
	{
		m_pAllos = new ALLO_ARRAY[m_numOfCells];
		if( m_pAllos )
		{
			ListToArray( pAllos );
			for( scanIndex = 0; scanIndex < m_numOfCells; scanIndex++ )
			{
				pCurAllo = &m_pAllos[scanIndex];
				cur_Allo = pCurAllo->allo;
				cur_AlloFlags = g_AlloFlags[cur_Allo];
				cur_Ctrl = pCurAllo->ctrlFlags;
        
				if( cur_AlloFlags & KVOWELF)
				{
					//--------------------------
					// Phon is a VOWEL
					//--------------------------
					MarkSyllableOrder( scanIndex );
				}
				else
				{
					//--------------------------
					// Phon is a CONSONANT
					// move stress??
					//--------------------------
				}
        
				MarkSyllableBoundry( scanIndex );
			}
    
			MarkSyllableStart();
			ArrayToList( pAllos );
			delete m_pAllos;
		}
	}
} /* CSyllableTagger::TagSyllables */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\voicedataobj.h ===
/******************************************************************************
* VoiceDataObj.h *
*----------------*
*   This is the header file for the CVoiceDataObj implementation. This object
*   is used to provide shared access to a specific voice data file.
*------------------------------------------------------------------------------
*   Copyright (C) 1999 Microsoft Corporation         Date: 05/06/99
*   All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef VoiceDataObj_h
#define VoiceDataObj_h

//--- Additional includes
#ifndef __spttseng_h__
#include "spttseng.h"
#endif

#ifndef SPDDKHLP_h
#include <spddkhlp.h>
#endif

#ifndef SPHelper_h
#include <sphelper.h>
#endif

#include <MMREG.H>

#include "resource.h"

#include "SpTtsEngDebug.h"

//=== Constants ====================================================
static const long VOICE_VERSION   = 0x10001;
static const long HEADER_VERSION  = 0x10000;
static const long MS_VOICE_TYPE   = MAKEFOURCC('V','o','i','s');
static const long MS_DATA_TYPE    = MAKEFOURCC('D','a','t','a');
static const float SIL_DURATION    = 0.01f;


//=== Class, Enum, Struct and Union Declarations ===================

//------------------------------------
// Selector for 'GetData()'
// For accessing voice data blocks
//------------------------------------
enum VOICEDATATYPE
{   
    MSVD_PHONE,
    MSVD_SENONE,
    MSVD_TREEIMAGE,
    MSVD_INVENTORY,
    MSVD_ALLOID
};

//---------------------------
// VOICEINFO data types
//---------------------------
enum GENDER
{   
    GENDER_NEUTRAL = 0,
    GENDER_FEMALE,
    GENDER_MALE
};
enum COMPRESS_TYPE
{   
    COMPRESS_NONE = 0,
    COMPRESS_LPC
};


// THis is the data 
#pragma pack (1)
struct VOICEINFO
{
    long            Type;               // Always 'MS_VOICE_TYPE'
    ULONG           Version;            // Always 'VOICE_VERSION'
    WCHAR           Copyright[256];     // INFO:
    WCHAR           VoiceName[64];      // INFO:
    WCHAR           Example[64];        // INFO: 
    LCID			LangID;
    GENDER          Gender;             // INFO: Male, female or neuter
    ULONG           Age;                // INFO: Speaker age in years
    ULONG           Rate;               // INFO & FE: Words-per-minute
    ULONG           Pitch;              // INFO & FE: Average pitch in Hz 
    COMPRESS_TYPE   CompressionType;    // BE: Always 'COMPRESS_LPC'
    REVERBTYPE      ReverbType;         // BE: Reverb param
    ULONG           NumOfTaps;          // BE: Whisper param
    float           TapCoefficients[8]; // BE: Whisper param
    ULONG           ProsodyGain;        // FE: 0 = monotone
    float           VibratoFreq;        // Hertz
    ULONG           VibratoDepth;       // 0 - 100%
    ULONG           SampleRate;         // 22050 typical
    GUID            formatID;           // SAPI audio format ID
    long            Unused[4];
};
#pragma pack ()
typedef VOICEINFO *PVOICEINFO;



//---------------------------------------------------
// Header definition for voice data block
//---------------------------------------------------
#pragma pack (1)
struct VOICEBLOCKOFFSETS
{
    long    Type;           // Always 'MS_DATA_TYPE'
    long    Version;        // Always 'HEADER_VERSION'
    GUID    DataID;         // File ID
    long    PhonOffset;     // Offset to PHON block (from beginning of file)
    long    PhonLen;        // Length of PHON block
    long    SenoneOffset;   // Offset to SENONE block (from beginning of file)
    long    SenoneLen;      // Length of SENONE block
    long    TreeOffset;     // Offset to TREE block (from beginning of file)
    long    TreeLen;        // Length of TREE block
    long    InvOffset;      // Offset to INV block (from beginning of file)
    long    InvLen;         // Length of INV block
    long    AlloIDOffset;      // Offset to AlloId block (from beginning of file)
    long    AlloIDLen;         // Length of AlloID block
};
#pragma pack ()


// Single VQ Codebook
#pragma pack (1)
typedef struct Book 
{
    long    cCodeSize;          // Number of codewords
    long    cCodeDim;           // Dimension of codeword
    long    pData;              // Offset to data (INVENTORY rel)
} BOOK, *PBOOK;
#pragma pack ()


static const long BOOKSHELF   = 32;

#pragma pack (1)
typedef struct Inventory 
{
    long        SampleRate;             // Sample rate in Hz
    long        cNumLPCBooks;           // Number of LPC Codebooks
    long        cNumResBooks;           // Number of Residual Codebooks
    long        cNumDresBooks;          // Number of Delta Residual Codebooks
    BOOK        LPCBook[BOOKSHELF];     // LPC Codebook array
    BOOK        ResBook[BOOKSHELF];     // Residual Codebook array
    BOOK        DresBook[BOOKSHELF];    // Delta residual Codebook array
    long        cNumUnits;              // Total number of units
    long        UnitsOffset;            // Offset to offset array to unit data (INVENTORY rel)
    long        cOrder;                 // LPC analysis order
    long        FFTSize;                // Size of FFT
    long        FFTOrder;               // Order of FFT
    long        TrigOffset;             // Offset to sine table (INVENTORY rel)
    long        WindowOffset;           // Offset to Hanning Window (INVENTORY rel)
    long        pGaussOffset;           // Offset to Gaussian Random noise (INVENTORY rel)
    long        GaussID;                // Gaussian sample index
} INVENTORY, *PINVENTORY;
#pragma pack ()

//------------------------
// LPC order * 2
//------------------------
static const long MAXNO   = 40;

static const float KONEPI  = 3.1415926535897931032f;
static const float KTWOPI  = (KONEPI * 2);
static const float K2 = 0.70710678118655f;


#pragma pack (1)
typedef struct 
{
    long    val;                // Phon ID
    long    obj;                // Offset to phon string
} HASH_ENTRY;
#pragma pack ()


#pragma pack (1)
typedef struct 
{
    long        size;               // Number entries in the table (127 typ.)
    long        UNUSED1; 
    long        entryArrayOffs;     // Offset to HASH_ENTRY array
    long        UNUSED2;
    long        UNUSED3;
    long        UNUSED4;
    long        UNUSED5;
} HASH_TABLE;
#pragma pack ()



#pragma pack (1)
typedef struct 
{
    HASH_TABLE      phonHash;
    long            phones_list;    // Offset to offsets to phon strings
    long            numPhones;
    long            numCiPhones;    // Number of context ind. phones
} PHON_DICT;
#pragma pack ()




#pragma pack (1)
typedef struct 
{
    long        nfeat;
    long        nint32perq;
    long        b_ques;
    long        e_ques;
    long        s_ques;
    long        eors_ques;
    long        wwt_ques;
    long        nstateq;
} FEATURE;
#pragma pack ()


#pragma pack (1)
typedef struct
{
    long        prod;           // For leaves, it means the counts.
                                //   For non-leaves, it is the offset 
                                //   into TRIPHONE_TREE.prodspace.
    short       yes;            // Negative means there is no child. so this is a leaf
    short       no;             // for leaves, it is lcdsid
    short       shallow_lcdsid; // negative means this is NOT a shallow leaf
} C_NODE;
#pragma pack ()


#pragma pack (1)
typedef struct 
{
    short       nnodes;
    short       nleaves;
    long        nodes;              // Offset
}TREE_ELEM;




#define NUM_PHONS_MAX   64

#pragma pack (1)
typedef struct 
{
    FEATURE         feat;
    long            UNUSED;                     // PHON_DICT *pd usually
    long            nsenones; 
    long            silPhoneId; 
    long            nonSilCxt; 
    
    long            nclass; 
    long            gsOffset[NUM_PHONS_MAX];    // nclass+1 entries
    
    TREE_ELEM       tree[NUM_PHONS_MAX];
    long            nuniq_prod;                 // not used for detailed tree
    long            uniq_prod_Offset;                   // Offset to table
    long            nint32perProd;
} TRIPHONE_TREE;
#pragma pack ()

static const long NO_PHON     = (-1);

#define ABS(x) ((x) >= 0 ? (x) : -(x))
#define MAX(x,y) (((x) >= (y)) ? (x) : (y))
#define MIN(x,y) (((x) <= (y)) ? (x) : (y))


#pragma pack (1)
typedef struct 
{
    float	dur;
    float	durSD;
    float	amp;
    float	ampRatio;
} UNIT_STATS;
#pragma pack ()



//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================



/*** CVoiceDataObj COM object ********************************
*/
class ATL_NO_VTABLE CVoiceDataObj : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CVoiceDataObj, &CLSID_MSVoiceData>,
    public IMSVoiceData,
    public ISpObjectWithToken
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_MSVOICEDATA)
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CVoiceDataObj)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
	    COM_INTERFACE_ENTRY(IMSVoiceData)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND( m_cpunkDrvVoice.p )
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    HRESULT FinalConstruct();
    void FinalRelease();
	ISpObjectToken* GetVoiceToken() {return m_cpToken;}

 private:
    /*--- Non interface methods ---*/
    HRESULT MapFile(const WCHAR * pszTokenValName, HANDLE * phMapping, void ** ppvData);
    HRESULT GetDataBlock( VOICEDATATYPE type, char **ppvOut, ULONG *pdwSize );
    HRESULT InitVoiceData();
    HRESULT DecompressUnit( ULONG UnitID, MSUNITDATA* pSynth );
    long DecompressEpoch( signed char *rgbyte, long cNumEpochs, float *pEpoch );
    long OrderLSP( PFLOAT pLSPFrame, INT cOrder );
    void LSPtoPC( float *pLSP, float *pLPC, long cOrder, long frame );
    void PutSpectralBand( float *pFFT, float *pBand, long StartBin, 
                          long cNumBins, long FFTSize );
    void AddSpectralBand( float *pFFT, float *pBand, long StartBin, 
                          long cNumBins, long FFTSize );
    void InverseFFT( float *pDest, long fftSize, long fftOrder, float *sinePtr );
    void SetEpochLen( float *pOutRes, long OutSize, float *pInRes, 
                      long InSize );
    void GainDeNormalize( float *pRes, long FFTSize, float Gain );
    long PhonToID( PHON_DICT *pd, char *phone_str );
    char *PhonFromID( PHON_DICT *pd, long phone_id );
    HRESULT GetTriphoneID( TRIPHONE_TREE *forest, 
                        long        phon,           // target phon              
                        long        leftPhon,       // left context
                        long        rightPhon,      // right context
                        long        pos,            // word position ("b", "e" or "s"
                        PHON_DICT   *pd,
                        ULONG       *pResult );
    long PhonHashLookup( PHON_DICT  *pPD,   // the hash table
                         char       *sym,   // The symbol to look up
                         long       *val );  // Phon ID
    void FIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps );
    void IIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps );
    HRESULT GetUnitDur( ULONG UnitID, float* pDur );
    
    /*=== Interfaces ====*/
  public:
    //--- ISpObjectWithToken ----------------------------------
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken)
        { return SpGenericGetObjectToken( ppToken, m_cpToken ); }

    //--- IMSVoiceData ----------------------------------------
    STDMETHOD(GetVoiceInfo)( MSVOICEINFO* pVoiceInfo );
    //STDMETHOD(GetUnitInfo)( UNIT_INFO* pUnitInfo );
    STDMETHOD(GetUnitIDs)( UNIT_CVT* pUnits, ULONG cUnits );
    STDMETHOD(GetUnitData)( ULONG unitID, MSUNITDATA* pUnitData );
    STDMETHOD(AlloToUnit)( short allo, long attributes, long* pUnitID );

  private:
  /*=== Member Data ===*/
    CComPtr<IUnknown> m_cpunkDrvVoice;
    CComPtr<ISpObjectToken> m_cpToken;
    HANDLE                  m_hVoiceDef;
    HANDLE                  m_hVoiceData;
    VOICEINFO*              m_pVoiceDef;
    VOICEBLOCKOFFSETS*      m_pVoiceData;

    PHON_DICT*      m_pd;
    TRIPHONE_TREE*  m_pForest;
    UNALIGNED long* m_SenoneBlock;
    ULONG           m_First_Context_Phone;
    ULONG           m_Sil_Index;

    // Unit Inventory
    INVENTORY*      m_pInv;
    float           m_SampleRate;
    long            m_cOrder;
    long           *m_pUnit;       // Pointer to offsets to unit data
    float          *m_pTrig;       // Sine table
    float          *m_pWindow;     // Hanning Window
    float          *m_pGauss;      // Gaussian Random noise
    COMPRESS_TYPE   m_CompressionType;
    ULONG           m_FFTSize;
    long            m_GaussID;
    short           *m_AlloToUnitTbl;
    long            m_NumOfAllos;
    ULONG           m_NumOfUnits;	// Inventory size
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\voicedataobj.cpp ===
/*******************************************************************************
* VoiceDataObj.cpp *
*------------------*
*   Description:
*       This module is the main implementation file for the CVoiceDataObj class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 05/06/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "VoiceDataObj.h"

/*****************************************************************************
* CVoiceDataObj::FinalConstruct *
*-------------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CVoiceDataObj::FinalConstruct()
{
    //--- Init vars
    m_hVoiceDef  = NULL;
    m_hVoiceData = NULL;
    m_pVoiceData = NULL;
    m_pVoiceDef  = NULL;

    //--- Create driver voice but initialize later
    return m_cpunkDrvVoice.CoCreateInstance( CLSID_MSTTSEngine, GetControllingUnknown() );
} /* CVoiceDataObj::FinalConstruct */

/*****************************************************************************
* CVoiceDataObj::FinalRelease *
*-----------------------------*
*   Description:
*       destructor
********************************************************************* EDC ***/
void CVoiceDataObj::FinalRelease()
{
    SPDBG_FUNC( "CVoiceDataObj::FinalRelease" );

    if( m_pVoiceDef )
    {
        ::UnmapViewOfFile( (void*)m_pVoiceDef );
    }

    if( m_pVoiceData )
    {
        ::UnmapViewOfFile( (void*)m_pVoiceData );
    }

    if( m_hVoiceDef  ) ::CloseHandle( m_hVoiceDef  );
    if( m_hVoiceData ) ::CloseHandle( m_hVoiceData );
} /* CVoiceDataObj::FinalRelease */


/*****************************************************************************
* CVoiceDataObj::MapFile *
*------------------------*
*   Description:
*       Helper function used by SetObjectToken to map file.  This function
*   assumes that m_cpToken has been initialized.+++
********************************************************************* RAL ***/
HRESULT CVoiceDataObj::MapFile( const WCHAR * pszTokenVal,   // Value that contains file path
                                HANDLE * phMapping,          // Pointer to file mapping handle
                                void ** ppvData )            // Pointer to the data
{
    HRESULT hr = S_OK;
    bool fWorked;

    CSpDynamicString dstrFilePath;
    hr = m_cpToken->GetStringValue( pszTokenVal, &dstrFilePath );
    if ( SUCCEEDED( hr ) )
    {
        fWorked = false;
        *phMapping = NULL;
        *ppvData = NULL;


        HANDLE  hFile;

#ifndef _WIN32_WCE
        hFile = g_Unicode.CreateFile( 
                    dstrFilePath, 
                    GENERIC_READ, 
                    FILE_SHARE_READ, 
                    NULL, 
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 
                    NULL );
#else   //_WIN32_WCE
        hFile = g_Unicode.CreateFileForMapping( 
                    dstrFilePath, 
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL, 
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 
                    NULL );
#endif  //_WIN32_WCE
        if (hFile != INVALID_HANDLE_VALUE)
        {
            //-------------------------------------
            // Make a unique map name from path
            //-------------------------------------
            long        i;

            for( i = 0; i < _MAX_PATH-1; i++ )
            {
                if( dstrFilePath[i] == 0 )
                {
                    // End of string
                    break;
                }
                if( dstrFilePath[i] == '\\' )
                {
                    //-------------------------------------
                    // Change backslash to underscore
                    //-------------------------------------
                    dstrFilePath[i] = '_';
                }
            }

            *phMapping = g_Unicode.CreateFileMapping( hFile, NULL, PAGE_READONLY, 0, 0, dstrFilePath );

            ::CloseHandle( hFile );

        }

        if (*phMapping)
        {
            *ppvData = ::MapViewOfFile( *phMapping, FILE_MAP_READ, 0, 0, 0 );
            if (*ppvData)
            {
                fWorked = true;
            }
        }
        if (!fWorked)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            if (hr == E_HANDLE)
            {
                hr &= 0xFFFFF000;
                hr |= ERROR_FILE_NOT_FOUND;
            }

            if (*phMapping)
            {
                ::CloseHandle(*phMapping);
                *phMapping = NULL;
            }
        }
    }
    return hr;
} /* CVoiceDataObj::MapFile */
 
/*****************************************************************************
* CVoiceDataObj::SetObjectToken *
*-------------------------------*
*   Description:
*       This function performs the majority of the initialization of the voice.
*   Once the object token has been provided, the filenames are read from the
*   token key and the files are mapped.+++
********************************************************************* RAL ***/
STDMETHODIMP CVoiceDataObj::SetObjectToken(ISpObjectToken * pToken)
{
    SPDBG_FUNC( "CVoiceDataObj::SetObjectToken" );
    HRESULT hr = SpGenericSetObjectToken(pToken, m_cpToken);

    if ( SUCCEEDED( hr ) )
    {
        hr = MapFile( L"VoiceDef", &m_hVoiceDef, (void **)&m_pVoiceDef );
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = MapFile( L"VoiceData", &m_hVoiceData, (void **)&m_pVoiceData );
    }

    //--- Init voice data pointers
    if (SUCCEEDED(hr))
    {
        hr = InitVoiceData();
    }

    if( SUCCEEDED( hr ))
    {
        CComQIPtr<IMSTTSEngineInit> cpInit( m_cpunkDrvVoice );
        SPDBG_ASSERT( cpInit );
        hr = cpInit->VoiceInit( this );
    }

    return hr;
} /* CVoiceDataObj::SetObjectToken */

/*****************************************************************************
* CVoiceDataObj::GetVoiceInfo *
*-----------------------------*
*   Description:
*       This method is used to retrieve the voice file data description.+++
********************************************************************* EDC ***/
STDMETHODIMP CVoiceDataObj::GetVoiceInfo( MSVOICEINFO* pVoiceInfo )
{
    SPDBG_FUNC( "CVoiceDataObj::GetVoiceInfo" );
    HRESULT hr = S_OK;
    long    i;

    //--- Check args
    if( ( SP_IS_BAD_WRITE_PTR( pVoiceInfo ) ) || ( m_pVoiceDef == NULL ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (!m_cpToken)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            pVoiceInfo->pWindow = m_pWindow;
            pVoiceInfo->FFTSize = m_FFTSize;
            pVoiceInfo->LPCOrder = m_cOrder;
            pVoiceInfo->ProsodyGain = m_pVoiceDef->ProsodyGain;
            pVoiceInfo->eReverbType = m_pVoiceDef->ReverbType;
            pVoiceInfo->Pitch = m_pVoiceDef->Pitch;
            pVoiceInfo->Rate = m_pVoiceDef->Rate;
            pVoiceInfo->LangID = m_pVoiceDef->LangID;
            pVoiceInfo->SampleRate = m_pVoiceDef->SampleRate;
            pVoiceInfo->VibratoFreq = m_pVoiceDef->VibratoFreq;
            pVoiceInfo->VibratoDepth = m_pVoiceDef->VibratoDepth;
            pVoiceInfo->NumOfTaps = m_pVoiceDef->NumOfTaps;

            // Assumes voices are ALWAYS 16-bit mono (probably valid for now)***
            pVoiceInfo->WaveFormatEx.wFormatTag         = WAVE_FORMAT_PCM;
            pVoiceInfo->WaveFormatEx.nSamplesPerSec     = pVoiceInfo->SampleRate;
            pVoiceInfo->WaveFormatEx.wBitsPerSample     = 16;   // ***
            pVoiceInfo->WaveFormatEx.nChannels          = 1;    // ***
            pVoiceInfo->WaveFormatEx.nBlockAlign        = (unsigned short)(pVoiceInfo->WaveFormatEx.nChannels * sizeof(short)); // ***
            pVoiceInfo->WaveFormatEx.nAvgBytesPerSec    = pVoiceInfo->WaveFormatEx.nSamplesPerSec * pVoiceInfo->WaveFormatEx.nBlockAlign;  
            pVoiceInfo->WaveFormatEx.cbSize             = 0;
            for (i = 0; i < MAXTAPS; i++)
            {
                pVoiceInfo->TapCoefficients[i] = m_pVoiceDef->TapCoefficients[i];
            }
        }
    }
    return hr;
} /* CVoiceDataObj::GetVoiceInfo */


/*****************************************************************************
* CVoiceDataObj::GetUnit *
*------------------------*
*   Description:
*   Retrieves and uncompresses audio data from the unit inventory. +++
*       
********************************************************************* EDC ***/
STDMETHODIMP CVoiceDataObj::GetUnitData( ULONG unitID, MSUNITDATA* pUnitData )
{
    SPDBG_FUNC( "CVoiceDataObj::GetUnit" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_WRITE_PTR( pUnitData ) )
    {
        hr = E_INVALIDARG;
    }
    else if( unitID > m_NumOfUnits )
    {
        //--------------------------
        // ID is out of range!
        //--------------------------
        hr = E_INVALIDARG;
    }
    else
    {
        if (!m_cpToken)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            if( m_CompressionType != COMPRESS_LPC ) 
            {
                //--------------------------------------
                // Unsupported compression type
                //--------------------------------------
                hr = E_FAIL;
            } 
            else 
            {
                //-------------------------------------------------------------------
                // Retrieve data from compressed inventory
                //-------------------------------------------------------------------
                hr = DecompressUnit( unitID, pUnitData );
            }
        }
    }
    return hr;
} /* CVoiceDataObj::GetUnit */


/*****************************************************************************
* CVoiceDataObj::AlloToUnit *
*---------------------------*
*   Description:
*   Converts FE allo code to BE unit phon code.+++
*       
********************************************************************* EDC ***/
STDMETHODIMP CVoiceDataObj::AlloToUnit( short allo, long attributes, long* pUnitID )
{
    SPDBG_FUNC( "CVoiceDataObj::AlloToUnit" );
    HRESULT hr = S_OK;
    long        index;
    union {
        char c[2];
        short s;
    } temp;
    char* pb;

    //--- Check args
    if( (SP_IS_BAD_READ_PTR( pUnitID )) || (allo >= m_NumOfAllos) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        index = (long)allo << 1;           // 2 entries per phon
        if( attributes & ALLO_IS_STRESSED )
        {
            //--- 2nd half
            pb = (char*) &m_AlloToUnitTbl[index + (m_NumOfAllos << 1)];
        }
        else
        {
            pb = (char*) &m_AlloToUnitTbl[index];
        }

        // We read this way to avoid missaligned data accesses in 64bit.
        temp.c[0] = *pb++;
        temp.c[1] = *pb;

        *pUnitID = (long) temp.s;            
    }

   return hr;
} /* CVoiceDataObj::AlloToUnit */



/*****************************************************************************
* CVoiceDataObj::GetUnitIDs *
*---------------------------*
*   Description:
*   Gets the inventory triphone (in context) unit code.+++
*       
********************************************************************* EDC ***/
STDMETHODIMP CVoiceDataObj::GetUnitIDs( UNIT_CVT* pUnits, ULONG cUnits )
{
    SPDBG_FUNC( "CVoiceDataObj::GetUnitIDs" );
    ULONG    i;
    ULONG    curID, prevID, nextID;
    ULONG    curF, prevF, nextF;
    char    cPos;
    ULONG    senoneID;
    UNALIGNED UNIT_STATS  *pStats;
    HRESULT hr = S_OK;

    //--- Check args
    if( (SP_IS_BAD_READ_PTR( pUnits)) ||
        (SP_IS_BAD_WRITE_PTR( pUnits)) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (!m_cpToken)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            for( i = 0; i < cUnits; i++ )
            {
                //---------------------------
                // CURRENT phon
                //---------------------------
                curID = pUnits[i].PhonID;
                curF = pUnits[i].flags;
        
                //---------------------------
                // PREVIOUS phon
                //---------------------------
                if( i == 0 )
                {
                    prevID = m_Sil_Index;
                    prevF = 0;
                }
                else
                {
                    prevID = pUnits[i-1].PhonID;
                    prevF = pUnits[i-1].flags;
                }
        
                //---------------------------
                // NEXT phon
                //---------------------------
                if( i >= cUnits -1 )
                {
                    nextID = m_Sil_Index;
                    nextF = 0;
                }
                else
                {
                    nextID = pUnits[i+1].PhonID;
                    nextF = pUnits[i+1].flags;
                }
        
                if( curID == m_Sil_Index )
                {
                    //----------------------
                    // SILENCE phon
                    //----------------------
                    pUnits[i].UnitID = 0;
                    pUnits[i].SenoneID = 0;
                    pUnits[i].szUnitName[0] = 0;
                    pUnits[i].Dur = SIL_DURATION;
                    pUnits[i].Amp = 0;
                    pUnits[i].AmpRatio = 1.0f;
                }
               else
                {
                    cPos = '\0';
                    if( curF & WORD_START_FLAG )
                    {
                        if( nextF & WORD_START_FLAG )
                            //---------------------------------------
                            // Both Cur and Next are word start
                            //---------------------------------------
                            cPos = 's';
                       else
                            //---------------------------------------
                            // Cur is word start
                            // Next is not
                            //---------------------------------------
                            cPos = 'b';
                    }
                    else if( nextF & WORD_START_FLAG )
                    {
                        //---------------------------------------
                        // Next is word start
                        // Cur is not
                        //---------------------------------------
                        cPos = 'e';
                    }
                    HRESULT     hrt;

                    hrt = GetTriphoneID( m_pForest, 
                                        curID, 
                                        prevID, 
                                        nextID, 
                                        cPos, 
                                        m_pd,
                                        &senoneID);
                    if( FAILED(hrt) )
                    {
                        //------------------------------------------------
                        // Instead of failing, I'll be robust and ignore 
                        // the error. Force triphone to something that's 
                        // valid.
                        //------------------------------------------------
                        senoneID = 0;
                    }
                    pUnits[i].UnitID = (m_pForest->gsOffset[curID] - 
                               m_First_Context_Phone) + (senoneID + 1);
                    pUnits[i].SenoneID = senoneID;

                    //-----------------------------
                    // Get phon name strings
                    //-----------------------------
                    char        *pName;
                    pName = PhonFromID( m_pd, pUnits[i].PhonID );
                    strcpy( &pUnits[i].szUnitName[0], pName );

                    //-----------------------------
                    // Get unit stats
                    //-----------------------------
                    pStats = (UNALIGNED UNIT_STATS*)(m_SenoneBlock[curID] + (char*)m_SenoneBlock);
                    pStats = &pStats[senoneID+1];
                    pStats = (UNALIGNED UNIT_STATS*)(m_SenoneBlock[curID] + (char*)m_SenoneBlock);
                    pStats = &pStats[senoneID-1];

                    pStats = (UNALIGNED UNIT_STATS*)(m_SenoneBlock[curID] + (char*)m_SenoneBlock);
                    pStats = &pStats[senoneID];
                    pUnits[i].Dur = pStats->dur / 1000.0f;      // ms -> sec
                    pUnits[i].Amp = pStats->amp;
                    pUnits[i].AmpRatio = (float)sqrt(pStats->ampRatio);

                    //----------------------------------------------------------
                    // Looks like the "SENONE" table durations are 
                    //   incorrect (not even close!).
                    // Calc the real duration from inv epochs
                    // TODO: Make new table in voice data block
                    //----------------------------------------------------------
                    //hr = GetUnitDur( pUnits[i].UnitID, &pUnits[i].Dur );
                    if( FAILED(hr) )
                    {
                        break;
                    }
                }
            }
        }
    }
    return hr;
} /* CVoiceDataObj::GetUnitIDs */



/*****************************************************************************
* GetDataBlock *
*--------------*
*   Description:
*       Return ptr and length of specified voice data block. +++
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::GetDataBlock( VOICEDATATYPE type, char **ppvOut, ULONG *pdwSize )
{
    SPDBG_FUNC( "CVoiceDataObj::GetDataBlock" );
    long    *offs;
    HRESULT hr = S_OK;
    long    dataType;
    
    if( !m_pVoiceData )
    {
        hr = E_INVALIDARG;
   }
    else
    {
        dataType    = (long)type * 2;               // x2 since each entry is an offset/length pair
        offs        = (long*)&m_pVoiceData->PhonOffset;    // Table start
        *ppvOut     = offs[dataType] + ((char*)m_pVoiceData);         // Offset -> abs address
        *pdwSize    = offs[dataType + 1];
    }
        
    
    return hr;
} /* CVoiceDataObj::GetDataBlock */




/*****************************************************************************
* InitVoiceData *
*---------------*
*   Description:
*       Create pointers to voice data blocks from m_pVoiceData offsets.+++
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::InitVoiceData()
{
    SPDBG_FUNC( "CVoiceDataObj::InitVoiceData" );
    char    *pRawData;
    ULONG    dataSize;
    HRESULT hr = S_OK;
    
    //------------------------------------------
    // Check data type and version
    //------------------------------------------
    if( (m_pVoiceData != NULL)  
        && (m_pVoiceData->Type == MS_DATA_TYPE) 
        && (m_pVoiceData->Version == HEADER_VERSION) )
    {
        //-------------------------------
        // Get ptr to PHONs
        //-------------------------------
        hr = GetDataBlock( MSVD_PHONE, &pRawData, &dataSize );
        m_pd = (PHON_DICT*)pRawData;
    
        //-------------------------------
        // Get ptr to TREE
        //-------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_TREEIMAGE, &pRawData, &dataSize );
            m_pForest = (TRIPHONE_TREE*)pRawData;
        }
    
        //-------------------------------
        // Get ptr to SENONE
        //-------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_SENONE, &pRawData, &dataSize );
            m_SenoneBlock = (long*)pRawData;
        }
        //-------------------------------
        // Get ptr to ALLOID
        //-------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_ALLOID, &pRawData, &dataSize );
            m_AlloToUnitTbl = (short*)pRawData;
            m_NumOfAllos = dataSize / 8;
        }
    
        if( SUCCEEDED(hr) )
        {
            m_First_Context_Phone = m_pd->numCiPhones;
            m_Sil_Index = PhonToID( m_pd, "SIL" );
        }
        //-----------------------------------------------------
        // Init voice data INVENTORY parameters
        //-----------------------------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_INVENTORY, &pRawData, &dataSize );
            if( SUCCEEDED(hr) )
            {
                m_pInv = (INVENTORY*)pRawData;
                m_CompressionType = m_pVoiceDef->CompressionType;
                //---------------------------------------------
                // Convert REL to ABS
                //---------------------------------------------
                m_pUnit      = (long*)((char*)m_pInv + m_pInv->UnitsOffset);
                m_pTrig      = (float*)((char*)m_pInv + m_pInv->TrigOffset);
                m_pWindow    = (float*)((char*)m_pInv + m_pInv->WindowOffset);
                m_pGauss     = (float*)((char*)m_pInv + m_pInv->pGaussOffset);
                m_SampleRate = (float)m_pInv->SampleRate;
                m_FFTSize    = m_pInv->FFTSize;
                m_cOrder     = m_pInv->cOrder;
                m_GaussID    = 0;
                m_NumOfUnits = m_pInv->cNumUnits;
           }    
        }
    }
    else
    {
        //-------------------------
        // Not a voice file!
        //-------------------------
        hr = E_FAIL;
    }

    return hr;
} /* CVoiceDataObj::InitVoiceData */





/*****************************************************************************
* CVoiceDataObj::DecompressUnit *
*-------------------------------*
*   Description:
*  Decompress acoustic unit.+++
* 
*   INPUT:
*       UnitID - unit number (1 - 3333 typ)
* 
*   OUTPUT:
*       Fills pSynth if success
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::DecompressUnit( ULONG UnitID, MSUNITDATA* pSynth )
{
    SPDBG_FUNC( "CVoiceDataObj::DecompressUnit" );
    long            i, j, k, cNumEpochs, cBytes, cOrder = 0, VectDim;
    long            frameSize, cNumBins, startBin;
    char            *pCurStor;
    unsigned char   index;
    float           pLSP[MAX_LPCORDER], pFFT[MAX_FFTSIZE], pRes[MAX_FFTSIZE], Gain;
    float           *pCurLSP, *pCurLPC, *pMean, *pCurRes;
    HRESULT         hr = S_OK;
    
    
    memset( pSynth, 0, sizeof(MSUNITDATA) );
    //-----------------------------------------
    // Pointer to unit data from inventory
    //-----------------------------------------
    pCurStor = (char*)((char*)m_pInv + m_pUnit[UnitID] );     // Rel to abs

    //---------------------------------
    // Get epoch count - 'cNumEpochs'
    //---------------------------------
    cBytes = sizeof(long);
    memcpy( &cNumEpochs, pCurStor, cBytes );
    pSynth->cNumEpochs = cNumEpochs;
    pCurStor += cBytes;

    //---------------------------------
    // Get epoch lengths - 'pEpoch'
    //---------------------------------
    pSynth->pEpoch = new float[cNumEpochs];
    if( pSynth->pEpoch == NULL )
    {
        hr = E_OUTOFMEMORY;
    }

    if( SUCCEEDED(hr) )
    {
        cBytes = DecompressEpoch( (signed char *) pCurStor, cNumEpochs, pSynth->pEpoch );
        pCurStor += cBytes;

        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        //
        // Uncompress LPC coefficients...
        //
        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        cOrder            = m_pInv->cOrder;
        pSynth->cOrder    = cOrder;
        pSynth->pLPC      = new float[cNumEpochs * (1 + cOrder)];
        if( pSynth->pLPC == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if( SUCCEEDED(hr) )
    {
        pCurLPC = pSynth->pLPC;
        //---------------------------------
        // ... for each epoch
        //---------------------------------
        for( i = 0; i < cNumEpochs; i++, pCurLPC += (1 + cOrder) )
        {
            //-------------------------------------
            // Decode quantized LSP's...
            //-------------------------------------
            pCurLSP = pLSP;
            for( k = 0; k < m_pInv->cNumLPCBooks; k++ )
            {
                VectDim = m_pInv->LPCBook[k].cCodeDim;
                memcpy( &index, pCurStor, sizeof(char));
                pCurStor += sizeof(char);
                pMean = ((float*)((char*)m_pInv + m_pInv->LPCBook[k].pData)) + (index * VectDim);
                for( j = 0; j < VectDim; j++ )
                    pCurLSP[j] = pMean[j];
                pCurLSP += VectDim;
            }
            //--------------------------------------------------
            // ...then convert to predictor coefficients
            // (LSP's quantize better than PC's)
            //--------------------------------------------------
            LSPtoPC( pLSP, pCurLPC, cOrder, i );
        }


        //---------------------------------------
        // Get pointer to residual gains
        //---------------------------------------
        cBytes          = cNumEpochs * sizeof(float);
        pSynth->pGain = (float*) pCurStor;
        pCurStor += cBytes;


        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        //
        // Uncompress residual waveform
        //
        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        //--------------------------------------------
        // First, figure out the buffer length...
        //--------------------------------------------
        pSynth->cNumSamples = 0;
        for( j = 0; j < cNumEpochs; j++ )
        {
            pSynth->cNumSamples += (long) ABS(pSynth->pEpoch[j]);
        }
        //--------------------------------------------
        // ...get buffer memory...
        //--------------------------------------------
        pSynth->pRes = new float[pSynth->cNumSamples];
        if( pSynth->pRes == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if( SUCCEEDED(hr) )
    {
        //--------------------------------------------
        // ...and fill with uncompressed residual
        //--------------------------------------------
        pCurRes = pSynth->pRes;
        for( i = 0; i < (long)pSynth->cNumEpochs; i++ )
        {
            //-------------------------------------
            // Get epoch length
            //-------------------------------------
            frameSize = (long)(ABS(pSynth->pEpoch[i]));

            // restore whisper
            //if( (pSynth->pEpoch[i] > 0) && !(m_fModifiers & BACKEND_BITFLAG_WHISPER) )
            if( pSynth->pEpoch[i] > 0 )
            {
                //-----------------------------------------------
                // VOICED epoch
                //-----------------------------------------------
                if( (m_pInv->cNumDresBooks == 0) || (i == 0) || (pSynth->pEpoch[i - 1] < 0) )
                {
                    //--------------------------------------
                    // Do static quantization
                    //--------------------------------------
                    for( j = 0; j < m_pInv->FFTSize; j++ ) 
                    {
                        pFFT[j] = 0.0f;
                    }
                    startBin = 1;
                    for( k = 0; k < m_pInv->cNumResBooks; k++ )
                    {
                        VectDim     = m_pInv->ResBook[k].cCodeDim;
                        cNumBins    = VectDim / 2;
                        memcpy( &index, pCurStor, sizeof(char) );
                        pCurStor    += sizeof(char);
                        //------------------------------------------
                        // Uncompress spectrum using 'pResBook'
                        //------------------------------------------
                        pMean = ((float*)((char*)m_pInv + m_pInv->ResBook[k].pData)) + (index * VectDim);
                        PutSpectralBand( pFFT, pMean, startBin, cNumBins, m_pInv->FFTSize );
                        startBin    += cNumBins;
                    }
                }
                else
                {
                    //--------------------------------------
                    // Do delta quantization
                    //--------------------------------------
                    startBin = 1;
                    for( k = 0; k < m_pInv->cNumDresBooks; k++ )
                    {
                        VectDim     = m_pInv->DresBook[k].cCodeDim;
                        cNumBins    = VectDim / 2;
                        memcpy( &index, pCurStor, sizeof(char));
                        pCurStor    += sizeof(char);
                        //------------------------------------------
                        // Uncompress spectrum using 'pDresBook'
                        //------------------------------------------
                        pMean = ((float*)((char*)m_pInv + m_pInv->DresBook[k].pData)) + (index * VectDim);
                        AddSpectralBand( pFFT, pMean, startBin, cNumBins, m_pInv->FFTSize );
                        startBin    += cNumBins;
                    }
                }

                //--------------------------------------------------------
                // Convert quantized FFT back to time residual
                //--------------------------------------------------------
                memcpy( pRes, pFFT, m_pInv->FFTSize * sizeof(float) );          // preserve original for delta residual
                InverseFFT( pRes, m_pInv->FFTSize, m_pInv->FFTOrder, m_pTrig );
                GainDeNormalize( pRes, (long)m_pInv->FFTSize, ((UNALIGNED float*)pSynth->pGain)[i] );
                SetEpochLen( pCurRes, frameSize, pRes, m_pInv->FFTSize );
            }
            else
            {
                //-----------------------------------------------
                // UNVOICED epoch
                // NOTE: Assumes 'm_pGauss' is 1 sec
                //-----------------------------------------------
                Gain = 0.02f * ((UNALIGNED float*)pSynth->pGain)[i];
                if( m_GaussID + frameSize >= m_pInv->SampleRate)
                {
                    m_GaussID = 0;
                }
                //----------------------------------------------------------
                // Generate gaussian random noise for unvoiced sounds
                //----------------------------------------------------------
                for( j = 0; j < frameSize; j++ )
                {
                    pCurRes[j] = Gain * m_pGauss[j + m_GaussID];
                }
                m_GaussID += frameSize;
            }
            // restore whisper
            /*if( (pSynth->pEpoch[i] > 0) && m_fModifiers & BACKEND_BITFLAG_WHISPER)
            {
                pSynth->pEpoch[i] = - pSynth->pEpoch[i];
            }*/
            pCurRes += frameSize;
        }
    }
    

    if( FAILED(hr) )
    {
        //----------------------------------
        // Cleanup allocated memory
        //----------------------------------
        if( pSynth->pEpoch )
        {
            delete pSynth->pEpoch;
            pSynth->pEpoch = NULL;
        }
        if( pSynth->pRes )
        {
            delete pSynth->pRes;
            pSynth->pRes = NULL;
        }
        if( pSynth->pLPC )
        {
            delete pSynth->pLPC;
            pSynth->pLPC = NULL;
        }
    }

    return hr;
} /* CVoiceDataObj::DecompressUnit */





/*****************************************************************************
* CVoiceDataObj::DecompressUnit *
*-------------------------------*
*   Description:
*  Decompress acoustic unit. +++
* 
*   INPUT:
*       UnitID - unit number (1 - 3333 typ)
* 
*   OUTPUT:
*       Fills pSynth if success
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::GetUnitDur( ULONG UnitID, float* pDur )
{
    SPDBG_FUNC( "CVoiceDataObj::GetUnitDur" );
    char        *pCurStor;
    float       *pEpoch = NULL;
    long        cBytes, cNumEpochs, i;
    float       totalDur;
    HRESULT     hr = S_OK;
   
    
    totalDur = 0;

    if( UnitID > m_NumOfUnits )
    {
        //--------------------------
        // ID is out of range!
        //--------------------------
        hr = E_INVALIDARG;
    }

    if( SUCCEEDED(hr) )
    {
        //-----------------------------------------
        // Pointer to unit data from inventory
        //-----------------------------------------
        pCurStor = (char*)((char*)m_pInv + m_pUnit[UnitID] );     // Rel to abs

        //---------------------------------
        // Get epoch count - 'cNumEpochs'
        //---------------------------------
        cBytes = sizeof(long);
        memcpy( &cNumEpochs, pCurStor, cBytes );
        pCurStor += cBytes;

        //---------------------------------
        // Get epoch lengths - 'pEpoch'
        //---------------------------------
        pEpoch = new float[cNumEpochs];
        if( pEpoch == NULL )
        {
            hr = E_OUTOFMEMORY;
        }

        if( SUCCEEDED(hr) )
        {
            cBytes = DecompressEpoch( (signed char *) pCurStor, cNumEpochs, pEpoch );
            for( i = 0; i < cNumEpochs; i++)
            {
                totalDur += ABS(pEpoch[i]);
            }
        }
    }
    *pDur = totalDur / 22050;

    //----------------------------------
    // Cleanup allocated memory
    //----------------------------------
    if( pEpoch )
    {
        delete pEpoch;
    }
    return hr;
} /* CVoiceDataObj::GetUnitDur */




/*****************************************************************************
* CVoiceDataObj::DecompressEpoch *
*--------------------------------*
*   Description:
*   Decompress epoch len stream from RLE. Fills 'pEpoch' with lengths. 
*   Returns number of 'rgbyte' src bytes consumed.
*       
********************************************************************** MC ***/
long CVoiceDataObj::DecompressEpoch( signed char *rgbyte, long cNumEpochs, float *pEpoch )
{
    SPDBG_FUNC( "CVoiceDataObj::DecompressEpoch" );
    long    iDest, iSrc;
    
    for( iSrc = 0, iDest = 0; iDest < cNumEpochs; ++iDest, ++iSrc )
    {
        //--------------------------------------
        // Decode RLE for VOICED epochs
        //--------------------------------------
        if( rgbyte[iSrc] == 127 )
        {
            pEpoch[iDest] = 127.0f;
            while( rgbyte[iSrc] == 127 )
            {
                pEpoch[iDest] += rgbyte[++iSrc];
            }
        }
        //--------------------------------------
        // Decode RLE for UNVOICED  epochs
        //--------------------------------------
        else if( rgbyte[iSrc] == - 128 )
        {
            pEpoch[iDest] = - 128.0f;
            while( rgbyte[iSrc] == - 128 )
                pEpoch[iDest] += rgbyte[++iSrc];
        }
        //--------------------------------------
        // No compression here
        //--------------------------------------
        else
        {
            pEpoch[iDest] = rgbyte[iSrc];
        }
    }
    return iSrc;
} /* CVoiceDataObj::DecompressEpoch */



/*****************************************************************************
* LSPCompare *
*------------*
*   Description:
*   QSORT callback
*       
********************************************************************** MC ***/
static  int __cdecl LSPCompare( const void *a, const void *b )
{
    SPDBG_FUNC( "LSPCompare" );

    if( *((PFLOAT) a) > *((PFLOAT) b) ) 
    {
        return 1;
    }
    else if( *((PFLOAT) a) == *((PFLOAT) b) ) 
    {
        return 0;
    }
    else 
    {
        return -1;
    }
} /* LSPCompare */


/*****************************************************************************
* CVoiceDataObj::OrderLSP *
*-------------------------*
*   Description:
*   This routine reorders the LSP frequencies so that they are monotonic
*       
********************************************************************** MC ***/
long CVoiceDataObj::OrderLSP( PFLOAT pLSPFrame, INT cOrder )
{
    SPDBG_FUNC( "CVoiceDataObj::OrderLSP" );
    long i, retCode = true;
    
    for( i = 1; i < cOrder; i++ )
    {
        if( pLSPFrame[i - 1] > pLSPFrame[i] ) 
        {
            retCode = false;
        }
    }
    qsort( (void *) pLSPFrame, (size_t) cOrder, (size_t) sizeof (float), LSPCompare );
        
    return retCode;
} /* CVoiceDataObj::OrderLSP */


/*****************************************************************************
* CVoiceDataObj::LSPtoPC *
*------------------------*
*   Description:
*   Converts line spectral frequencies to LPC predictor coefficients.
*       
********************************************************************** MC ***/
void CVoiceDataObj::LSPtoPC( float *pLSP, float *pLPC, long cOrder, long /*frame*/ )
{
    SPDBG_FUNC( "CVoiceDataObj::LSPtoPC" );
    long        i, j, k, noh;
    double      freq[MAXNO], p[MAXNO / 2], q[MAXNO / 2];
    double      a[MAXNO / 2 + 1], a1[MAXNO / 2 + 1], a2[MAXNO / 2 + 1];
    double      b[MAXNO / 2 + 1], b1[MAXNO / 2 + 1], b2[MAXNO / 2 + 1];
    double      pi, xx, xf;
    
    //----------------------------------
    // Check for non-monotonic LSPs
    //----------------------------------
    for( i = 1; i < cOrder; i++ )
    {
        if( pLSP[i] <= pLSP[i - 1] )
        {
            //-----------------------------
            // Reorder LSPs
            //-----------------------------
            OrderLSP( pLSP, cOrder );
            break;
        }
    }
    
    //--------------------------
    // Initialization
    //--------------------------
    pi = KTWOPI;
    noh = cOrder / 2;
    for( j = 0; j < cOrder; j++ )
    {
        freq[j] = pLSP[j];
    }
    for( i = 0; i < noh + 1; i++ )
    {
        a[i]    = 0.0f;
        a1[i]   = 0.0f;
        a2[i]   = 0.0f;
        b[i]    = 0.0f;
        b1[i]   = 0.0f;
        b2[i]   = 0.0f;
    }
    
    //-------------------------------------
    // LSP filter parameters
    //-------------------------------------
    for( i = 0; i < noh; i++ )
    {
        p[i] = - 2.0 * cos( pi * freq[2 * i] );
        q[i] = - 2.0 * cos( pi * freq[2 * i + 1] );
    }
    
    //-------------------------------------
    // Impulse response of analysis filter
    //-------------------------------------
    xf = 0.0f;
    for( k = 0; k < cOrder + 1; k++ )
    {
        xx = 0.0f;
        if( k == 0 )
        {
            xx = 1.0f;
        }
        a[0] = xx + xf;
        b[0] = xx - xf;
        xf = xx;
        for( i = 0; i < noh; i++ )
        {
            a[i + 1]    = a[i] + p[i] * a1[i] + a2[i];
            b[i + 1]    = b[i] + q[i] * b1[i] + b2[i];
            a2[i]       = a1[i];
            a1[i]       = a[i];
            b2[i]       = b1[i];
            b1[i]       = b[i];
        }
        if( k != 0)
        {
            pLPC[k - 1] = (float) (- 0.5 * (a[noh] + b[noh]));
        }
    }
    
    //-------------------------------------------------------
    // Convert to predictor coefficient array configuration
    //-------------------------------------------------------
    for( i = cOrder - 1; i >= 0; i-- )
    {
        pLPC[i + 1] = - pLPC[i];
    }
    pLPC[0] = 1.0f;
} /* CVoiceDataObj::LSPtoPC */



/*****************************************************************************
* CVoiceDataObj::PutSpectralBand *
*--------------------------------*
*   Description:
*   This routine copies the frequency band specified by StartBin as
*   is initial FFT bin, and containing cNumBins.
*       
********************************************************************** MC ***/
void CVoiceDataObj::PutSpectralBand( float *pFFT, float *pBand, long StartBin, 
                                    long cNumBins, long FFTSize )
{
    SPDBG_FUNC( "CVoiceDataObj::PutSpectralBand" );
    long        j, k, VectDim;
    
    VectDim = 2 * cNumBins;
    for( j = 0, k = StartBin; j < cNumBins; j++, k++ )
    {
        pFFT[k] = pBand[j];
    }
    k = FFTSize - (StartBin - 1 + cNumBins);
    for( j = cNumBins; j < 2 * cNumBins; j++, k++ )
    {
        pFFT[k] = pBand[j];
    }
} /* CVoiceDataObj::PutSpectralBand */


/*****************************************************************************
* CVoiceDataObj::AddSpectralBand *
*--------------------------------*
*   Description:
*   This routine adds the frequency band specified by StartBin as
*   is initial FFT bin, and containing cNumBins, to the existing band.
*       
********************************************************************** MC ***/
void CVoiceDataObj::AddSpectralBand( float *pFFT, float *pBand, long StartBin, 
                                    long cNumBins, long FFTSize )
{
    SPDBG_FUNC( "CVoiceDataObj::AddSpectralBand" );
    long        j, k, VectDim;
    
    VectDim = 2 * cNumBins;
    for( j = 0, k = StartBin; j < cNumBins; j++, k++ )
    {
        pFFT[k] += pBand[j];
    }
    k = FFTSize - (StartBin - 1 + cNumBins);
    for( j = cNumBins; j < 2 * cNumBins; j++, k++ )
    {
        pFFT[k] += pBand[j];
    }
} /* CVoiceDataObj::AddSpectralBand */


/*****************************************************************************
* CVoiceDataObj::InverseFFT *
*---------------------------*
*   Description:
*   Return TRUE if consoants can be clustered.
*   This subroutine computes a split-radix IFFT for real data
*   It is a C version of the FORTRAN program in "Real-Valued
*   Fast Fourier Transform Algorithms" by H. Sorensen et al.
*   in Trans. on ASSP, June 1987, pp. 849-863. It uses half 
*   of the operations than its counterpart for complex data.
*                                   *
*   Length is n = 2^(fftOrder). Decimation in frequency. Result is 
*   in place. It uses table look-up for the trigonometric functions.
* 
*   Input order:                            *
*       (Re[0], Re[1], ... Re[n/2], Im[n/2 - 1]...Im[1])
*   Output order:
*       (x[0], x[1], ... x[n - 1])
*   The output transform exhibit hermitian symmetry (i.e. real
*   part of transform is even while imaginary part is odd).
*   Hence Im[0] = Im[n/2] = 0; and n memory locations suffice.
*       
********************************************************************** MC ***/
void CVoiceDataObj::InverseFFT( float *pDest, long fftSize, long fftOrder, float *sinePtr )
{
    SPDBG_FUNC( "CVoiceDataObj::InverseFFT" );
    long    n1, n2, n4, n8, i0, i1, i2, i3, i4, i5, i6, i7, i8;
    long    is, id, i, j, k, ie, ia, ia3;
    float   xt, t1, t2, t3, t4, t5, *cosPtr, r1, cc1, cc3, ss1, ss3;
    
    cosPtr = sinePtr + (fftSize / 2);
    
    //---------------------------------
    // L shaped butterflies
    //---------------------------------
    n2 = 2 * fftSize;
    ie = 1;
    for( k = 1; k < fftOrder; k++ ) 
    {
        is = 0;
        id = n2;
        n2 = n2 / 2;
        n4 = n2 / 4;
        n8 = n4 / 2;
        ie *= 2;
        while( is < fftSize - 1 ) 
        {
            for( i = is; i < fftSize; i += id ) 
            {
                i1 = i;
                i2 = i1 + n4;
                i3 = i2 + n4;
                i4 = i3 + n4;
                t1 = pDest[i1] - pDest[i3];
                pDest[i1] = pDest[i1] + pDest[i3];
                pDest[i2] = 2 * pDest[i2];
                pDest[i3] = t1 - 2 * pDest[i4];
                pDest[i4] = t1 + 2 * pDest[i4];
                if( n4 > 1 ) 
                {
                    i1 = i1 + n8;
                    i2 = i2 + n8;
                    i3 = i3 + n8;
                    i4 = i4 + n8;
                    t1 = K2 * (pDest[i2] - pDest[i1]);
                    t2 = K2 * (pDest[i4] + pDest[i3]);
                    pDest[i1] = pDest[i1] + pDest[i2];
                    pDest[i2] = pDest[i4] - pDest[i3];
                    pDest[i3] = - 2 * (t1 + t2);
                    pDest[i4] = 2 * (t1 - t2);
                }
            }
            is = 2 * id - n2;
            id = 4 * id;
        }
        ia = 0;
        for( j = 1; j < n8; j++ ) 
        {
            ia += ie;
            ia3 = 3 * ia;
            cc1 = cosPtr[ia];
            ss1 = sinePtr[ia];
            cc3 = cosPtr[ia3];
            ss3 = sinePtr[ia3];
            is = 0;
            id = 2 * n2;
            while( is < fftSize - 1 ) 
            {
                for( i = is; i < fftSize; i += id ) 
                {
                    i1 = i + j;
                    i2 = i1 + n4;
                    i3 = i2 + n4;
                    i4 = i3 + n4;
                    i5 = i + n4 - j;
                    i6 = i5 + n4;
                    i7 = i6 + n4;
                    i8 = i7 + n4;
                    t1 = pDest[i1] - pDest[i6];
                    pDest[i1] = pDest[i1] + pDest[i6];
                    t2 = pDest[i5] - pDest[i2];
                    pDest[i5] = pDest[i2] + pDest[i5];
                    t3 = pDest[i8] + pDest[i3];
                    pDest[i6] = pDest[i8] - pDest[i3];
                    t4 = pDest[i4] + pDest[i7];
                    pDest[i2] = pDest[i4] - pDest[i7];
                    t5 = t1 - t4;
                    t1 = t1 + t4;
                    t4 = t2 - t3;
                    t2 = t2 + t3;
                    pDest[i3] = t5 * cc1 + t4 * ss1;
                    pDest[i7] = - t4 * cc1 + t5 * ss1;
                    pDest[i4] = t1 * cc3 - t2 * ss3;
                    pDest[i8] = t2 * cc3 + t1 * ss3;
                }
                is = 2 * id - n2;
                id = 4 * id;
            }
        }
    }
    //---------------------------------
    // length two butterflies
    //---------------------------------
    is = 0;
    id = 4;
    while( is < fftSize - 1 ) 
    {
        for( i0 = is; i0 < fftSize; i0 += id ) 
        {
            i1 = i0 + 1;
            r1 = pDest[i0];
            pDest[i0] = r1 + pDest[i1];
            pDest[i1] = r1 - pDest[i1];
        }
        is = 2 * (id - 1);
        id = 4 * id;
    }
    //---------------------------------
    // digit reverse counter
    //---------------------------------
    j = 0;
    n1 = fftSize - 1;
    for( i = 0; i < n1; i++ ) 
    {
        if( i < j ) 
        {
            xt = pDest[j];
            pDest[j] = pDest[i];
            pDest[i] = xt;
        }
        k = fftSize / 2;
        while( k <= j )
        {
            j -= k;
            k /= 2;
        }
        j += k;
    }
    for( i = 0; i < fftSize; i++ )
    {
        pDest[i] /= fftSize;
    }
} /* CVoiceDataObj::InverseFFT */


/*****************************************************************************
* CVoiceDataObj::SetEpochLen *
*----------------------*
*   Description:
*   Copy residual epoch to 'OutSize' length from 'pInRes' to 'pOutRes'
*       
********************************************************************** MC ***/
void CVoiceDataObj::SetEpochLen( float *pOutRes, long OutSize, float *pInRes, 
                                long InSize )
{
    SPDBG_FUNC( "CVoiceDataObj::AddSpectralBand" );
    long        j, curFrame;
    
    curFrame = MIN(InSize / 2, OutSize);
    
    //-------------------------------
    // Copy SRC to DEST
    //-------------------------------
    for( j = 0; j < curFrame; j++ )
        pOutRes[j] = pInRes[j];
    //-------------------------------
    // Pad DEST if longer
    //-------------------------------
    for( j = curFrame; j < OutSize; j++ )
        pOutRes[j] = 0.0f;
    //-------------------------------
    // Mix DEST if shorter
    //-------------------------------
    for( j = OutSize - curFrame; j < OutSize; j++ )
        pOutRes[j] += pInRes[InSize - OutSize + j];
} /* CVoiceDataObj::SetEpochLen */


/*****************************************************************************
* CVoiceDataObj::GainDeNormalize *
*--------------------------------*
*   Description:
*   Scale residual to given gain.
*       
********************************************************************** MC ***/
void CVoiceDataObj::GainDeNormalize( float *pRes, long FFTSize, float Gain )
{
    SPDBG_FUNC( "CVoiceDataObj::GainDeNormalize" );
    long        j;
    
    for( j = 0; j < FFTSize; j++ )
    {
        pRes[j] *= Gain;
    }
} /* CVoiceDataObj::GainDeNormalize */


/*****************************************************************************
* CVoiceDataObj::PhonHashLookup *
*-------------------------------*
*   Description:
*   Lookup 'sym' in 'ht' and place its associated value in
*   *val. If sym is not found place its key in *val.
*    RETURN
*   Return  0 indicating we found the 'sym' in the table.
*   Return -1 'sym' is not in ht.
*       
********************************************************************** MC ***/
long CVoiceDataObj::PhonHashLookup(    
                            PHON_DICT   *pPD,   // the hash table
                            char       *sym,    // The symbol to look up
                            long       *val )   // Phon ID
{
    SPDBG_FUNC( "CVoiceDataObj::PhonHashLookup" );
    char            *cp;
    unsigned long   key;
    long            i;
    HASH_TABLE      *ht;
    char            *pStr;
    HASH_ENTRY      *pHE;
    
    ht      = &pPD->phonHash;
    key     = 0;
    i       = -1;
    cp      = sym;
    pHE     = (HASH_ENTRY*)((char*)pPD + ht->entryArrayOffs);        // Offset to Abs address 
    do 
    {
        key += *cp++ << (0xF & i--);
    } 
    while( *cp );
    
    while( true )
    {
        key %= ht->size;
    
        if( pHE[key].obj == 0 ) 
        {
            //------------------------------
            // Not in hash table!
            //------------------------------
            *val = (long) key;
            return -1;
        }
    
        //-------------------------------
        // Offset to Abs address
        //-------------------------------
        pStr = (char*)((char*)pPD + pHE[key].obj);
        if( strcmp(pStr, sym) == 0 ) 
        {
            *val = pHE[key].val;
            return 0;
        }
        key++;
    }
} /* CVoiceDataObj::PhonHashLookup */


/*****************************************************************************
* CVoiceDataObj::PhonToID *
*-------------------------*
*   Description:
*   Return ID from phoneme string.
*       
********************************************************************** MC ***/
long CVoiceDataObj::PhonToID( PHON_DICT *pd, char *phone_str )
{
    SPDBG_FUNC( "CVoiceDataObj::PhonToID" );
    long    phon_id;
    
    if( PhonHashLookup( pd, phone_str, &phon_id ) )
    {
        phon_id = NO_PHON;
    }
    
    return phon_id;
} /* CVoiceDataObj::PhonToID */


/*****************************************************************************
* CVoiceDataObj::PhonFromID *
*---------------------------*
*   Description:
*   Return string from phoneme ID
*       
********************************************************************** MC ***/
char *CVoiceDataObj::PhonFromID( PHON_DICT *pd, long phone_id )
{
    SPDBG_FUNC( "CVoiceDataObj::PhonFromID" );
    char    *strPtr;
    long    *pOffs;
    
    pOffs = (long*)((char*)pd + pd->phones_list);
    strPtr = (char*) ((char*)pd + pOffs[phone_id]);
    return strPtr;
} /* CVoiceDataObj::PhonFromID */


#define CNODE_ISA_LEAF(n)   ((n)->yes < 0)

#define BADTREE_ERROR   (-1)
#define PARAM_ERROR (-2)
#define END_OF_PROD  65535


#define WB_BEGIN    1
#define WB_END      2
#define WB_SINGLE   4
#define WB_WWT      8

#define POS_TYPE    4

#define GET_BIT(p,feat,i,b)                             \
{                                                   \
    (i) = ( (p)+POS_TYPE+(feat)->nstateq ) / 32;        \
    (b) = 1 << ( ((p)+POS_TYPE+(feat)->nstateq ) % 32); \
}

#define GET_RBIT(p,feat,i,b)            \
{                                   \
    GET_BIT(p,feat,i,b);                \
    (i) += (feat)->nint32perq;          \
} 

#define GET_CBIT(p,feat,i,b)            \
{                                   \
    GET_BIT(p,feat,i,b);                \
    (i) += 2 * (feat)->nint32perq;      \
}

/*****************************************************************************
* AnswerQ *
*---------*
*   Description:
*   Tree node test.
*       
********************************************************************** MC ***/
static  _inline long AnswerQ( unsigned short *prod, long *uniq_prod, 
                              long li, long bitpos, long ri, long rbitpos, 
                              long pos, long nint32perProd)
{
    UNALIGNED long *p;
    
    for( ; *prod != END_OF_PROD; prod++ ) 
    {
        p = &uniq_prod[(*prod) * nint32perProd];
        if( ((p[0] & pos) == pos) && (p[li] & bitpos) && (p[ri] & rbitpos) )
        {
            return true;
        }
    }
    return false;
} /* AnswerQ */


/*****************************************************************************
* CVoiceDataObj::GetTriphoneID *
*------------------------------*
*   Description:
*   Retrieve triphone ID from phoneme context.+++
*   Store result into 'pResult'
*       
********************************************************************** MC ***/
HRESULT CVoiceDataObj::GetTriphoneID( TRIPHONE_TREE *forest, 
                        long        phon,           // target phon              
                        long        leftPhon,       // left context
                        long        rightPhon,      // right context
                        long        pos,            // word position ("b", "e" or "s"
                        PHON_DICT   *pd,
                        ULONG       *pResult)
{
    SPDBG_FUNC( "CVoiceDataObj::GetTriphoneID" );
    C_NODE          *cnode, *croot;
    TREE_ELEM       *tree = NULL;
    long            *uniq_prod;
    char            *ll, *rr;
    long            li, bitpos, ri, rbitpos, nint32perProd, c;
    unsigned short  *prodspace;
    FEATURE         *feat;
    long            *pOffs;
    HRESULT         hr = S_OK;
    long            triphoneID = 0;
    
    if( (phon       < 0)    ||  (phon       >= pd->numCiPhones) || 
        (leftPhon   < 0)    ||  (leftPhon   >= pd->numCiPhones) || 
        (rightPhon  < 0)    ||  (rightPhon  >= pd->numCiPhones) )
    {
        //--------------------------------
        // Phon out of range!
        //--------------------------------
        hr = E_INVALIDARG;
    }
    
    if( SUCCEEDED(hr) )
    {
        c = phon;
        tree = &forest->tree[c];
        if( tree->nnodes == 0 )
        {
            //--------------------------------
            // No CD triphones in tree!
            //--------------------------------
            hr = E_INVALIDARG;
        }
    }

    if( SUCCEEDED(hr) )
    {
        if( pos == 'b' || pos == 'B' ) 
        {
            pos = WB_BEGIN;
        }
        else if( pos == 'e' || pos == 'E' ) 
        {
            pos = WB_END;
        }
        else if( pos == 's' || pos == 'S' ) 
        {
            pos = WB_SINGLE;
        }
        else if( pos == '\0' ) 
        {
            pos = WB_WWT;
        }
        else 
        {
            //--------------------------------
            // Unknown word position
            //--------------------------------
            hr = E_INVALIDARG;
        }
    }
    
    if( SUCCEEDED(hr) )
    {
        pOffs = (long*)((char*)pd + pd->phones_list);
        ll = (char*) ((char*)pd + pOffs[leftPhon]);
    
        if( ll[0] == '+' || _strnicmp(ll, "SIL", 3) == 0 )
        {
            leftPhon = forest->silPhoneId;
        }
    
        rr = (char*) ((char*)pd + pOffs[rightPhon]);
        if( rr[0] == '+' || _strnicmp(rr, "SIL", 3) == 0 )      // includes SIL
        {
            rightPhon = forest->silPhoneId;
        }
        else if( forest->nonSilCxt >= 0 && (pos == WB_END || pos == WB_SINGLE) )
        {
            rightPhon = forest->nonSilCxt;
        }
    
        feat = &forest->feat;
        GET_BIT(leftPhon,feat,li,bitpos);
        GET_RBIT(rightPhon,feat,ri,rbitpos);
    
        uniq_prod = (long*)(forest->uniq_prod_Offset + (char*)forest);       // Offset to ABS
        croot = cnode = (C_NODE*)(tree->nodes + (char*)forest);              // Offset to ABS
        nint32perProd = forest->nint32perProd;
    
        while( ! CNODE_ISA_LEAF(cnode) ) 
        {
            prodspace = (unsigned short*)((char*)forest + cnode->prod);      // Offset to ABS
            if( AnswerQ (prodspace, uniq_prod, li, bitpos, ri, rbitpos, pos, nint32perProd) ) 
            {
                cnode = &croot[cnode->yes];
            }
            else 
            {
                cnode = &croot[cnode->no];
            }
        }
        //-----------------------------
        // Return successful result
        //-----------------------------
        triphoneID = (ULONG) cnode->no;
    }
    
    *pResult = triphoneID;
    return hr;
} /* CVoiceDataObj::GetTriphoneID */



/*****************************************************************************
* FIR_Filter *
*------------*
*   Description:
*   FIR filter. For an input x[n] it does an FIR filter with
*   output y[n]. Result is in place. pHistory contains the last
*   cNumTaps values.
*
*   y[n] = pFilter[0] * x[n] + pFilter[1] * x[n - 1]
*   + ... + pFilter[cNumTaps - 1] * x[n - cNumTaps - 1]
*       
 ********************************************************************** MC ***/
void CVoiceDataObj::FIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps )
{
    SPDBG_FUNC( "CVoiceDataObj::FIR_Filter" );
    long     i, j;
    float   sum;
    
    for( i = 0; i < cNumSamples; i++ )
    {
        pHistory[0] = pVector[i];
        sum = pHistory[0] * pFilter[0];
        for( j = cNumTaps - 1; j > 0; j-- )
        {
            sum += pHistory[j] * pFilter[j];
            pHistory[j] = pHistory[j - 1];
        }
        pVector[i] = sum;
    }
} /* CVoiceDataObj::FIR_Filter */





/*****************************************************************************
* IIR_Filter *
*------------*
*   Description:
*   IIR filter. For an input x[n] it does an IIR filter with
*   output y[n]. Result is in place. pHistory contains the last
*   cNumTaps values.
*
*   y[n] = pFilter[0] * x[n] + pFilter[1] * y[n - 1]
*   + ... + pFilter[cNumTaps - 1] * y[n - cNumTaps - 1]
*       
********************************************************************** MC ***/
void CVoiceDataObj::IIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps )
{
    SPDBG_FUNC( "CVoiceDataObj::IIR_Filter" );
    long     i, j;
    float   sum;
    
    for( i = 0; i < cNumSamples; i++ )
    {
        sum = pVector[i] * pFilter[0];
        for( j = cNumTaps - 1; j > 0; j-- )
        {
            pHistory[j] = pHistory[j - 1];
            sum += pHistory[j] * pFilter[j];
        }
        pVector[i] = sum;
        pHistory[0] = sum;
    }
} /* CVoiceDataObj::IIR_Filter */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\tools\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DebugSupport.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\regvoices\makefile.inc ===
RunProgram :
	$(O)\$(TARGETNAME).exe
!if defined(MAKEDLL)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\tools\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__44183539_C02F_475B_9A56_7260EDD0A7F4__INCLUDED_)
#define AFX_STDAFX_H__44183539_C02F_475B_9A56_7260EDD0A7F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <string.h>
#include <atlbase.h>
#include <sphelper.h>
#include <spcollec.h>
#include <sapi.h>
#include <commonlx.h>
#include <spttseng.h>

struct PRONUNIT
{
    ULONG           phon_Len;
    WCHAR           phon_Str[SP_MAX_PRON_LENGTH];		// Allo string
    ULONG			POScount;
    ENGPARTOFSPEECH	POScode[POS_MAX];
};


struct PRONRECORD
{
    WCHAR           orthStr[SP_MAX_WORD_LENGTH];      // Orth text
    WCHAR           lemmaStr[SP_MAX_WORD_LENGTH];     // Root word
    ULONG		    pronType;                   // Pronunciation is lex or LTS
    PRONUNIT        pronArray[2];
    ENGPARTOFSPEECH	POSchoice;
    ENGPARTOFSPEECH XMLPartOfSpeech;
    bool			hasAlt;
    ULONG			altChoice;
};

//--- This struct is just used as a helper to initialize the PRONRECORD to all zeroes
struct DebugPronRecord : PRONRECORD
{
public:
    DebugPronRecord() { ZeroMemory( (void*) this, sizeof( DebugPronRecord ) ); }
    operator =( PRONRECORD InRecord )
    {
        memcpy( this, &InRecord, sizeof( PRONRECORD ) );
    }
};

//--- This struct is used to replace the SPVCONTEXT struct for outputting to the debug streams -
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugContext
{
    WCHAR Category[32];
    WCHAR Before[32];
    WCHAR After[32];
public:
    DebugContext() { ZeroMemory( (void*) this, sizeof( DebugContext ) ); }
    operator =( SPVCONTEXT InContext )
    {
        if ( InContext.pCategory )
        {
            wcsncpy( Category, InContext.pCategory, 
                     wcslen(InContext.pCategory) > 31 ? 31 : wcslen(InContext.pCategory) );
        }
        if ( InContext.pBefore )
        {
            wcsncpy( Before, InContext.pBefore,
                     wcslen(InContext.pBefore) > 31 ? 31 : wcslen(InContext.pBefore) );
        }
        if ( InContext.pAfter )
        {
            wcsncpy( After, InContext.pAfter,
                     wcslen(InContext.pAfter) > 31 ? 31 : wcslen(InContext.pAfter) );
        }
    }
};

//--- This struct is used to replace the SPVSTATE struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugState
{
    SPVACTIONS      eAction;
    LANGID          LangID;
    WORD            wReserved;
    long            EmphAdj;
    long            RateAdj;
    ULONG           Volume;
    SPVPITCH        PitchAdj;
    ULONG           SilenceMSecs;
    SPPHONEID       PhoneIds[64];
    ENGPARTOFSPEECH  ePartOfSpeech;
    DebugContext    Context;
public:
    DebugState() { ZeroMemory( (void*) this, sizeof( DebugState ) ); }
    operator =( SPVSTATE InState )
    {
        eAction         = InState.eAction;
        LangID          = InState.LangID;
        wReserved       = InState.wReserved;
        EmphAdj         = InState.EmphAdj;
        RateAdj         = InState.RateAdj;
        Volume          = InState.Volume;
        PitchAdj        = InState.PitchAdj;
        SilenceMSecs    = InState.SilenceMSecs;
        ePartOfSpeech   = (ENGPARTOFSPEECH) InState.ePartOfSpeech;
        Context         = InState.Context;
        if ( InState.pPhoneIds )
        {
            wcsncpy( PhoneIds, InState.pPhoneIds,
                     wcslen(InState.pPhoneIds) > 63 ? 63 : wcslen(InState.pPhoneIds) );
        }
    }
};

//--- This struct is used to replace the TTSWord struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugWord
{
    DebugState      XmlState;
    WCHAR           WordText[32];
    ULONG           ulWordLen;
    WCHAR           LemmaText[32];
    ULONG           ulLemmaLen;
    SPPHONEID       WordPron[64];
    ENGPARTOFSPEECH  eWordPartOfSpeech;
public:
    DebugWord() { ZeroMemory( (void*) this, sizeof( DebugWord ) ); }
    operator =( TTSWord InWord )
    {
        XmlState = *(InWord.pXmlState);
        if ( InWord.pWordText )
        {
            wcsncpy( WordText, InWord.pWordText, InWord.ulWordLen > 31 ? 31 : InWord.ulWordLen );
        }
        ulWordLen = InWord.ulWordLen;
        if ( InWord.pLemma )
        {
            wcsncpy( LemmaText, InWord.pLemma, InWord.ulLemmaLen > 31 ? 31 : InWord.ulLemmaLen );
        }
        ulLemmaLen = InWord.ulLemmaLen;
        if ( InWord.pWordPron )
        {
            wcsncpy( WordPron, InWord.pWordPron,
                wcslen( InWord.pWordPron ) > 63 ? 63 : wcslen( InWord.pWordPron ) );
        }
        eWordPartOfSpeech = InWord.eWordPartOfSpeech;
    }
};

struct DebugItemInfo
{
    TTSItemType Type;
public:
    DebugItemInfo() { ZeroMemory( (void*) this, sizeof( DebugItemInfo ) ); }
    operator =( TTSItemInfo InItemInfo )
    {
        Type = InItemInfo.Type;
    }
};

//--- This struct is used to replace the TTSSentItem struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugSentItem
{
    WCHAR           ItemSrcText[32];
    ULONG           ulItemSrcLen;
    ULONG           ulItemSrcOffset;
    DebugWord         Words[32];
    ULONG           ulNumWords;
    ENGPARTOFSPEECH  eItemPartOfSpeech;
    DebugItemInfo   ItemInfo;
public:
    DebugSentItem() { ZeroMemory( (void*) this, sizeof( DebugSentItem ) ); }
    operator =( TTSSentItem InItem )
    {
        if ( InItem.pItemSrcText )
        {
            wcsncpy( ItemSrcText, InItem.pItemSrcText, InItem.ulItemSrcLen > 31 ? 31 : InItem.ulItemSrcLen );
        }
        ulItemSrcLen        = InItem.ulItemSrcLen;
        ulItemSrcOffset     = InItem.ulItemSrcOffset;
        for ( ULONG i = 0; i < InItem.ulNumWords; i++ )
        {
            Words[i] = InItem.Words[i];
        }
        ulNumWords          = InItem.ulNumWords;
        eItemPartOfSpeech   = InItem.eItemPartOfSpeech;
        ItemInfo            = *(InItem.pItemInfo);
    }
};

//--- This enumeration is used to index the array of IStreams used to write stuff to the debug file
typedef enum
{
    STREAM_WAVE = 0,
    STREAM_EPOCH,
    STREAM_UNIT,
    STREAM_WAVEINFO,
    STREAM_TOBI,
    STREAM_SENTENCEBREAKS,
    STREAM_NORMALIZEDTEXT,
    STREAM_LEXLOOKUP,
    STREAM_POSPOSSIBILITIES,
    STREAM_MORPHOLOGY,
    STREAM_LASTTYPE
} STREAM_TYPE;

//
//  String handling and conversion classes
//
/*** SPLSTR
*   This structure is for managing strings with known lengths
*/
struct SPLSTR
{
    WCHAR*  pStr;
    int     Len;
};
#define DEF_SPLSTR( s ) { L##s , sp_countof( s ) - 1 }

//--- This enumeration should correspond to the previous one, and is used to name the array of IStreams
//---   used to write stuff to the debug file
static const SPLSTR StreamTypeStrings[] =
{
    DEF_SPLSTR( "Wave"           ),
    DEF_SPLSTR( "Epoch"          ),
    DEF_SPLSTR( "Unit"           ),
    DEF_SPLSTR( "WaveInfo"       ),
    DEF_SPLSTR( "ToBI"           ),
    DEF_SPLSTR( "SentenceBreaks" ),
    DEF_SPLSTR( "NormalizedText" ),
    DEF_SPLSTR( "LexLookup"      ),
    DEF_SPLSTR( "PosPossibilities" ),
    DEF_SPLSTR( "Morphology" ),
};

//***************************
// ToBI Constants
//***************************
// !H is removed from consideration in the first pass processing
// !H can possibly be recovered from analysis of the labeling and
// contour at later stages (tilt, prominence, pitch range, downstep)
#define ACCENT_BASE   1
enum TOBI_ACCENT
{
    K_NOACC = 0,
    K_HSTAR = ACCENT_BASE,  // peak                         rise / fall
    K_LSTAR,                // acc syll nucleus valley      early fall
    K_LSTARH,               // late rise
    K_RSTAR,                //
    K_LHSTAR,               // early rise
    K_DHSTAR,               // 
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__44183539_C02F_475B_9A56_7260EDD0A7F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\regvoices\regvoices.cpp ===
#include <windows.h>
#include <atlbase.h>
#include "sapi.h"
#include "sphelper.h"
#include "spddkhlp.h"
#include "spttseng.h"
#include "spttseng_i.c"
#include "spcommon.h"
#include "spcommon_i.c"
#include <spunicode.h>

#include "ms1033ltsmap.h" 

// This code does not ship

// This code creates the registry entries for the TTS voices. The
// datafiles registered here are the ones checked in the slm source tree. This is not
// done using a reg file because we need to compute the absolute path of the datafiles
// which can be different on different machines because of different root slm directories.
// BUGBUG: Check out the ATL UpdateRegistryFromResource et al. and see whether you could
// use them instead, a la RegSR.  That seems much easier.

#ifndef _WIN32_WCE
#define DIRS_TO_GO_BACK_TTSENG     4        // Back 4 levels and up 1 to 'Voices" directory
#define DIRS_TO_GO_BACK_LEX        6        // Back 6 levels to Lex Data directory
#else
#define DIRS_TO_GO_BACK_TTSENG     1        // 
#define DIRS_TO_GO_BACK_LEX        1        // 
#endif

CSpUnicodeSupport g_Unicode;

/*****************************************************************************
* CreateLexSubKey  *
*------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateLexSubKey(
    ISpObjectToken * pToken,
    const WCHAR * pszSubKeyName,
    const CLSID * pclsid,
    const WCHAR * pszFilePath, 
    const WCHAR * pszLexName,
    const WCHAR * pszPhoneMap)
{
    HRESULT hr = S_OK;

    //---------------------------------------
    // Create the lex sub-key (Lex or LTS)
    //---------------------------------------
    CComPtr<ISpObjectToken> cpSubToken;
    hr = SpGetSubTokenFromToken(pToken, pszSubKeyName, &cpSubToken, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                cpSubToken, 
                pclsid, 
                NULL,
                0,
                NULL,
                NULL);
    }
    
    WCHAR szLexDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Lex DATA file location
        //--------------------------------
        wcscpy(szLexDataPath, pszFilePath);
        wcscat(szLexDataPath, pszLexName);

        hr = cpSubToken->SetStringValue(L"DataFile", szLexDataPath);
    }

    if (SUCCEEDED(hr) && pszPhoneMap)
    {
        CComPtr<ISpObjectToken> cpPhoneToken;

        if (SUCCEEDED(hr))
            hr = SpGetSubTokenFromToken(cpSubToken, L"PhoneConverter", &cpPhoneToken, TRUE);

        if (SUCCEEDED(hr))
            hr = SpSetCommonTokenData(cpPhoneToken, &CLSID_SpPhoneConverter, NULL, 0, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = cpPhoneToken->SetStringValue(L"PhoneMap", pszPhoneMap);
    }

    return hr;
}


/*****************************************************************************
* CreateVoiceSubKey  *
*--------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateVoiceSubKey(
    const WCHAR * pszSubKeyName, 
    const WCHAR  * pszDescription,
    BOOL fVendorDefault, 
    const WCHAR * pszGender,
    const WCHAR * pszAge,
    const WCHAR * pszVoicePath, 
    const WCHAR * pszVoiceName,
    const WCHAR * pszLexPath)
{
    HRESULT hr;

    CComPtr<ISpObjectToken> cpToken;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    hr = SpCreateNewTokenEx(
            SPCAT_VOICES, 
            pszSubKeyName, 
            &CLSID_MSVoiceData, 
            pszDescription,
            0x409,
            pszDescription,
            &cpToken,
            &cpDataKeyAttribs);

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Name", pszDescription);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Gender", pszGender);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Age", pszAge);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Vendor", L"Microsoft");
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Language", L"409");
    }

    if (SUCCEEDED(hr) && fVendorDefault)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"VendorPreferred", L"");
    }
    
    WCHAR szVoiceDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Voice DATA file location
        //--------------------------------
        wcscpy(szVoiceDataPath, pszVoicePath);
        wcscat(szVoiceDataPath, pszVoiceName);
        wcscat(szVoiceDataPath, L".SPD");

        hr = cpToken->SetStringValue(L"VoiceData", szVoiceDataPath);
    }
    
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Voice DEF file location
        //--------------------------------
        wcscpy(szVoiceDataPath, pszVoicePath);
        wcscat(szVoiceDataPath, pszVoiceName);
        wcscat(szVoiceDataPath, L".SDF");

        hr = cpToken->SetStringValue(L"VoiceDef", szVoiceDataPath);
    }

    //------------------------------------------------
    // Register TTS lexicons
    //------------------------------------------------
    if (SUCCEEDED(hr))
    {
        hr = CreateLexSubKey(cpToken, L"Lex", &CLSID_SpCompressedLexicon, pszLexPath, L"LTTS1033.LXA", NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = CreateLexSubKey(cpToken, L"LTS", &CLSID_SpLTSLexicon, pszLexPath, L"r1033tts.lxa", pszms1033ltsmap);
    }

    return hr;
}

/*****************************************************************************
* main  *
*-------*
*   Description:
*    Locate the abs path to the Mary, Mike and Sam voices
*    and register them in the system registry.
*       
********************************************************************** MC ***/
int _tmain()
{
    HRESULT hr = S_OK;

    CoInitialize(NULL);

    //----------------------------------------
    // Get the exe's location...
    //----------------------------------------
    WCHAR szVoiceDataPath[MAX_PATH];
    if (!g_Unicode.GetModuleFileName(NULL, szVoiceDataPath, MAX_PATH))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    WCHAR szLexDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        wcscpy(szLexDataPath, szVoiceDataPath);
    }

    //----------------------------------------
    // ...and derive abs path to VOICE data
    //----------------------------------------
    if (SUCCEEDED(hr))
    {
        // modulename is "<Speech>\TTS\msttsdrv\RegVoices\obj\i386\RegVoices.exe"
        // Data is at "<Speech>\TTS\msttsdrv\voices\"
        WCHAR * psz;
        psz = szVoiceDataPath;
        
        for (int i = 0; i < DIRS_TO_GO_BACK_TTSENG; i++)
        {
            psz = wcsrchr(psz, '\\');
            if (!psz)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                *psz = 0;
                psz = szVoiceDataPath;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
#ifndef _WIN32_WCE
        wcscat(szVoiceDataPath, L"\\Voices\\");
#else
        wcscat(szVoiceDataPath, L"\\");
#endif
    }

    //----------------------------------------
    // Derive abs path to LEX data
    //----------------------------------------
    if (SUCCEEDED(hr))
    {
        // modulename is "<sapi5>\Src\TTS\msttsdrv\voices\RegVoices\debug_x86\RegVoices.exe"
        // Data is at "<sapi5>\Src\lexicon\data\"
        WCHAR * psz = szLexDataPath;
        for (int i = 0; i < DIRS_TO_GO_BACK_LEX; i++)
        {
            psz = wcsrchr(psz, '\\');
            if (!psz)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                *psz = 0;
                psz = szLexDataPath;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
#ifndef _WIN32_WCE
        wcscat(szLexDataPath, L"\\src\\lexicon\\data\\");
#else
        wcscat(szLexDataPath, L"\\");
#endif
    }

    //------------------------------------------------
    // ...then register the three Microsoft voices..
    //------------------------------------------------
    if (SUCCEEDED(hr))
    {
        hr = CreateVoiceSubKey(L"MSMary", 
                               L"Microsoft Mary", 
                               TRUE,
                               L"Female",
                               L"Adult",
                               szVoiceDataPath,
                               L"Mary",
                               szLexDataPath);
    }
#ifndef _WIN32_WCE
    if (SUCCEEDED(hr))
    {
        hr = CreateVoiceSubKey(L"MSMike", 
                               L"Microsoft Mike", 
                               FALSE,
                               L"Male", 
                               L"Adult",
                               szVoiceDataPath, 
                               L"Mike",
                               szLexDataPath);
    }
    if (SUCCEEDED(hr))
    {
        hr = CreateVoiceSubKey(L"MSSam", 
                               L"Microsoft Sam", 
                               FALSE,
                               L"Male", 
                               L"Adult",
                               szVoiceDataPath, 
                               L"Sam",
                               szLexDataPath);
    }
#endif  //_WIN32_WCE

    CoUninitialize();

    if (FAILED(hr))
        return -1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\tools\ttsdbginfo.cpp ===
// DebugSupport.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

int g_StreamIndex = 0;
FILE *g_fpOutputFile = NULL;
IStorage *g_pDebugFile = NULL;

WCHAR* ConvertPOSToString( DWORD dwPartOfSpeech );
bool ParseCommandLine( int argc, char* argv[] );
void ExtractSentenceBreaks( void );
void ExtractNormalizedText( void );
void ExtractLexLookup( void );
void ExtractPOSPossibilities( void );
void ExtractMorphology( void );

int main(int argc, char* argv[])
{
    bool fSuccess = false;
    CoInitialize( NULL );

    fSuccess = ParseCommandLine( argc, argv );
    if ( fSuccess )
    {
        switch ( g_StreamIndex )
        {
        case STREAM_SENTENCEBREAKS:
            ExtractSentenceBreaks();
            break;
        case STREAM_NORMALIZEDTEXT:
            ExtractNormalizedText();
            break;
        case STREAM_LEXLOOKUP:
            ExtractLexLookup();
            break;
        case STREAM_POSPOSSIBILITIES:
            ExtractPOSPossibilities();
            break;
        case STREAM_MORPHOLOGY:
            ExtractMorphology();
            break;
        }
    }

    CoUninitialize();
	return 0;
}

bool ParseCommandLine( int argc, char* argv[] )
{
    bool fSuccess = true;

    //--- Check number of parameters
    if ( argc < 4 )
    {
        goto USAGE;
    }

    //--- Check streamname validity
    fSuccess = false;
    WCHAR StreamName[MAX_PATH];
    if ( !MultiByteToWideChar( CP_ACP, 0, argv[2], strlen( argv[2] ) + 1, StreamName, MAX_PATH ) )
    {
        goto MISC_ERROR;
    }
    else
    {
        for ( int i = 0; i < STREAM_LASTTYPE; i++ )
        {
            if ( wcscmp( StreamName, StreamTypeStrings[i].pStr ) == 0 )
            {
                fSuccess = true;
                g_StreamIndex = i;
                break;
            }
        }
    }
    if ( !fSuccess )
    {
        goto USAGE;
    }

    //--- Try to open debug info file
    WCHAR DebugFilename[MAX_PATH];
    if ( !MultiByteToWideChar( CP_ACP, 0, argv[1], strlen( argv[1] ) + 1, DebugFilename, MAX_PATH ) )
    {
        goto MISC_ERROR;
    }

    if ( FAILED( StgOpenStorage( DebugFilename, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, 
                                 NULL, 0, &g_pDebugFile ) ) )
    {
        goto MISC_ERROR;
    }

    //--- Try to open file for output
    WCHAR OutputFilename[MAX_PATH];
    if ( !MultiByteToWideChar( CP_ACP, 0, argv[3], strlen( argv[3] ) + 1, OutputFilename, MAX_PATH ) )
    {
        goto MISC_ERROR;
    }

    g_fpOutputFile = _wfopen( OutputFilename, L"w" );
    if ( !g_fpOutputFile )
    {
        printf( "\n\nUnable to open file: %s\n", argv[3] );
        goto MISC_ERROR;
    }

    return true;

USAGE:
    printf( "\n\nUSAGE:\n\n\tDebugSupport [debug filename] [streamname] [output filename]\n" );
    printf( "\tStream names are:\n\t\tSentenceBreaks\n\t\tNormalizedText\n\t\tMorphology" );
    printf( "\n\t\tLexLookup\n\n" );

    return false;

MISC_ERROR:
    printf( "\n\n\tERROR in ParseCommandLine(...)\n\n" );

    return false;
}

//--- Just print the original text out, with a newline character between each sentence.
void ExtractSentenceBreaks( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[g_StreamIndex].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 
                                   0, &pStgStream) == S_OK )
    {
        DebugSentItem Item, EmptyItem;
        ULONG cbRead = 0, ulOffset = 0;
        bool fResetOffset = true;

        while ( SUCCEEDED( pStgStream->Read( (void*) &Item, sizeof( Item ), &cbRead ) ) &&
                cbRead == sizeof( Item ) )
        {
            //--- Check for delimiter
            if ( memcmp( &Item, &EmptyItem, sizeof( Item ) ) == 0 )
            {
                fwprintf( g_fpOutputFile, L"\n" );
            }
            else
            {
                //--- Print item
                fwprintf ( g_fpOutputFile, L"%s ", Item.ItemSrcText );
            }
        }
    }
}

//--- Just print the normalized text of each item out, separated by single spaces, 
//---   with a newline character between each sentence.
void ExtractNormalizedText( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[5].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 
                                   0, &pStgStream) == S_OK )
    {
        DebugSentItem Item, EmptyItem;
        ULONG cbRead = 0;

        while ( SUCCEEDED( pStgStream->Read( (void*) &Item, sizeof( Item ), &cbRead ) ) &&
                cbRead == sizeof( Item ) )
        {
            //--- Check for delimiter
            if ( memcmp( &Item, &EmptyItem, sizeof( Item ) ) == 0 )
            {
                fwprintf( g_fpOutputFile, L"\n" );
            }
            else
            {
                //--- Print item
                if ( Item.ItemInfo.Type != eALPHA_WORD          &&
                     Item.ItemInfo.Type != eOPEN_PARENTHESIS    &&
                     Item.ItemInfo.Type != eOPEN_BRACKET        &&
                     Item.ItemInfo.Type != eOPEN_BRACE          &&
                     Item.ItemInfo.Type != eCLOSE_PARENTHESIS   &&
                     Item.ItemInfo.Type != eCLOSE_BRACKET       &&
                     Item.ItemInfo.Type != eCLOSE_BRACE         &&
                     Item.ItemInfo.Type != eSINGLE_QUOTE        &&
                     Item.ItemInfo.Type != eDOUBLE_QUOTE        &&
                     Item.ItemInfo.Type != ePERIOD              &&
                     Item.ItemInfo.Type != eEXCLAMATION         &&
                     Item.ItemInfo.Type != eQUESTION            &&
                     Item.ItemInfo.Type != eCOMMA               &&
                     Item.ItemInfo.Type != eSEMICOLON           &&
                     Item.ItemInfo.Type != eCOLON               &&
                     Item.ItemInfo.Type != eHYPHEN )
                {
                    fwprintf( g_fpOutputFile, L"[ " );
                }
                for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                {
                    if ( Item.Words[i].ulWordLen > 0 )
                    {
                        fwprintf( g_fpOutputFile, L"%s ", Item.Words[i].WordText );
                    }
                    else
                    {
                        fwprintf( g_fpOutputFile, L"%s ", Item.ItemSrcText );
                    }
                }
                if ( Item.ItemInfo.Type != eALPHA_WORD          &&
                     Item.ItemInfo.Type != eOPEN_PARENTHESIS    &&
                     Item.ItemInfo.Type != eOPEN_BRACKET        &&
                     Item.ItemInfo.Type != eOPEN_BRACE          &&
                     Item.ItemInfo.Type != eCLOSE_PARENTHESIS   &&
                     Item.ItemInfo.Type != eCLOSE_BRACKET       &&
                     Item.ItemInfo.Type != eCLOSE_BRACE         &&
                     Item.ItemInfo.Type != eSINGLE_QUOTE        &&
                     Item.ItemInfo.Type != eDOUBLE_QUOTE        &&
                     Item.ItemInfo.Type != ePERIOD              &&
                     Item.ItemInfo.Type != eEXCLAMATION         &&
                     Item.ItemInfo.Type != eQUESTION            &&
                     Item.ItemInfo.Type != eCOMMA               &&
                     Item.ItemInfo.Type != eSEMICOLON           &&
                     Item.ItemInfo.Type != eCOLON               &&
                     Item.ItemInfo.Type != eHYPHEN )
                {
                    fwprintf( g_fpOutputFile, L"] " );
                }
            }
        }
    }
}

//--- Print the text of each item, and then its Pronunciation and Part of Speech. 
//---   Separate each with a newline character.
void ExtractLexLookup( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[g_StreamIndex].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 
                                   0, &pStgStream) == S_OK )
    {
        DebugSentItem Item, EmptyItem;
        ULONG cbRead = 0;

        while ( SUCCEEDED( pStgStream->Read( (void*) &Item, sizeof( Item ), &cbRead ) ) &&
                cbRead == sizeof( Item ) )
        {
            if ( memcmp( &Item, &EmptyItem, sizeof( Item ) ) == 0 )
            {
                fwprintf( g_fpOutputFile, L"\n" );
            }
            else
            {
                //--- Print Normalization delimiter
                if ( Item.ItemInfo.Type != eALPHA_WORD          &&
                     Item.ItemInfo.Type != eOPEN_PARENTHESIS    &&
                     Item.ItemInfo.Type != eOPEN_BRACKET        &&
                     Item.ItemInfo.Type != eOPEN_BRACE          &&
                     Item.ItemInfo.Type != eCLOSE_PARENTHESIS   &&
                     Item.ItemInfo.Type != eCLOSE_BRACKET       &&
                     Item.ItemInfo.Type != eCLOSE_BRACE         &&
                     Item.ItemInfo.Type != eSINGLE_QUOTE        &&
                     Item.ItemInfo.Type != eDOUBLE_QUOTE        &&
                     Item.ItemInfo.Type != ePERIOD              &&
                     Item.ItemInfo.Type != eEXCLAMATION         &&
                     Item.ItemInfo.Type != eQUESTION            &&
                     Item.ItemInfo.Type != eCOMMA               &&
                     Item.ItemInfo.Type != eSEMICOLON           &&
                     Item.ItemInfo.Type != eCOLON               &&
                     Item.ItemInfo.Type != eHYPHEN )
                {
                    fwprintf( g_fpOutputFile, L"[ " );
                }
                for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                {
                    //--- Print item
                    if ( Item.Words[i].WordText[0] != 0 )
                    {
                        fwprintf ( g_fpOutputFile, L"%s ", Item.Words[i].WordText );
                    }
                    else
                    {
                        fwprintf ( g_fpOutputFile, L"%s ", Item.ItemSrcText );
                    }
                    //--- Print pronunciation
                    //CComPtr<ISpPhoneConverter> pPhoneConv;
                    //if ( SUCCEEDED( SpCreatePhoneConverter(1033, NULL, NULL, &pPhoneConv) ) )
                    //{
                    //    if ( SUCCEEDED( pPhoneConv->IdToPhone( Item.Words[i].WordPron, Item.Words[i].WordPron ) ) )
                    //    {
                    //        fwprintf( g_fpOutputFile, L"%s", Item.Words[i].WordPron );
                    //        for ( long j = 0; j < (long)( (long)45 - (long)wcslen( Item.Words[i].WordPron ) ); j++ )
                    //        {
                    //            fwprintf( g_fpOutputFile, L" " );
                    //        }
                    //    }
                    //}
                    //--- Print POS
                    fwprintf ( g_fpOutputFile, L"(%s) ", ConvertPOSToString( Item.Words[i].eWordPartOfSpeech ) );
                }
                //--- Print Normalization delimiter
                if ( Item.ItemInfo.Type != eALPHA_WORD          &&
                     Item.ItemInfo.Type != eOPEN_PARENTHESIS    &&
                     Item.ItemInfo.Type != eOPEN_BRACKET        &&
                     Item.ItemInfo.Type != eOPEN_BRACE          &&
                     Item.ItemInfo.Type != eCLOSE_PARENTHESIS   &&
                     Item.ItemInfo.Type != eCLOSE_BRACKET       &&
                     Item.ItemInfo.Type != eCLOSE_BRACE         &&
                     Item.ItemInfo.Type != eSINGLE_QUOTE        &&
                     Item.ItemInfo.Type != eDOUBLE_QUOTE        &&
                     Item.ItemInfo.Type != ePERIOD              &&
                     Item.ItemInfo.Type != eEXCLAMATION         &&
                     Item.ItemInfo.Type != eQUESTION            &&
                     Item.ItemInfo.Type != eCOMMA               &&
                     Item.ItemInfo.Type != eSEMICOLON           &&
                     Item.ItemInfo.Type != eCOLON               &&
                     Item.ItemInfo.Type != eHYPHEN )
                {
                    fwprintf( g_fpOutputFile, L"] " );
                }
            }
        }
    }
}

void ExtractPOSPossibilities( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[g_StreamIndex].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 
                                   0, &pStgStream) == S_OK )
    {
        DebugPronRecord PronRecord, EmptyPronRecord;
        ULONG cbRead = 0;

        while ( SUCCEEDED( pStgStream->Read( (void*) &PronRecord, sizeof( PronRecord ), &cbRead ) ) &&
                cbRead == sizeof( PronRecord ) )
        {
            //--- Check for delimiter
            if ( memcmp( &PronRecord, &EmptyPronRecord, sizeof( PronRecord ) ) == 0 )
            {
                fwprintf( g_fpOutputFile, L"\n" );
            }
            else
            {
                fwprintf( g_fpOutputFile, PronRecord.orthStr );
                fwprintf( g_fpOutputFile, L" [ " );
                fwprintf( g_fpOutputFile, L"%s - ", ConvertPOSToString( PronRecord.POSchoice ) );
                for ( ULONG i = 0; i < PronRecord.pronArray[0].POScount; i++ )
                {
                    fwprintf( g_fpOutputFile, L"%s,", ConvertPOSToString( (DWORD)PronRecord.pronArray[0].POScode[i] ) );
                }
                for ( i = 0; i < PronRecord.pronArray[1].POScount; i++ )
                {
                    fwprintf( g_fpOutputFile, L"%s,", ConvertPOSToString( (DWORD)PronRecord.pronArray[1].POScode[i] ) );
                }
                fwprintf( g_fpOutputFile, L" ]\n" );
            }
        }
    }
}

void ExtractMorphology( void )
{
    IStream *pStgStream = NULL;

    if ( g_pDebugFile->OpenStream( StreamTypeStrings[g_StreamIndex].pStr, 0, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0, &pStgStream ) == S_OK )
    {
        CComPtr<ISpPhoneConverter> pPhoneConv;
        if ( SUCCEEDED( SpCreatePhoneConverter( 1033, NULL, NULL, &pPhoneConv ) ) )
        {
            WCHAR Buffer[SP_MAX_WORD_LENGTH], EmptyBuffer[SP_MAX_WORD_LENGTH];
            ULONG cbRead = 0;
            ZeroMemory( EmptyBuffer, SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );
            BOOL fRoot = true;

            while ( SUCCEEDED( pStgStream->Read( (void*) &Buffer, SP_MAX_WORD_LENGTH * sizeof( WCHAR ), &cbRead ) ) &&
                    cbRead == SP_MAX_WORD_LENGTH * sizeof( WCHAR ) )
            {
                //--- Check for delimiter
                if ( memcmp( &Buffer, &EmptyBuffer, SP_MAX_WORD_LENGTH * sizeof( WCHAR ) ) == 0 )
                {
                    fwprintf( g_fpOutputFile, L"\n" );
                    fRoot = true;
                }
                else if ( fRoot )
                {
                    fwprintf( g_fpOutputFile, L"%s ", Buffer );
                    fRoot = false;
                }
                else
                {
                    if ( SUCCEEDED( pPhoneConv->IdToPhone( Buffer, Buffer ) ) )
                    {
                        fwprintf( g_fpOutputFile, L"- %s ", Buffer );
                    }
                }
            }
        }
    }
}

WCHAR* ConvertPOSToString( DWORD dwPartOfSpeech )
{
    switch (dwPartOfSpeech)
    {
    case MS_NotOverriden:
        return L"Noun";
    case MS_Unknown:
        return L"Unknown";
    case MS_Punctuation:
        return L"Punctuation";
    case MS_Noun:
        return L"Noun";
    case MS_Verb:
        return L"Verb";
    case MS_Modifier:
        return L"Modifier";
    case MS_Function:
        return L"Function";
    case MS_Interjection:
        return L"Interj";
    case MS_Pron:
        return L"Pron";
    case MS_SubjPron:
        return L"SubjPron";
    case MS_ObjPron:
        return L"ObjPron";
    case MS_RelPron:
        return L"RelPron";
//    case MS_PPron:
//        return L"PPron";
//    case MS_IPron:
//        return L"IPron";
//    case MS_RPron:
//        return L"RPron";
//    case MS_DPron:
//       return L"DPron";
    case MS_Adj:
        return L"Adj";
    case MS_Adv:
        return L"Adv";
    case MS_VAux:
        return L"VAux";
//    case MS_RVAux:
//        return L"RVAux";
    case MS_Conj:
        return L"Conj";
    case MS_CConj:
        return L"CConj";
    case MS_Interr:
        return L"WHWord";
    case MS_Det:
        return L"Det";
    case MS_Contr:
        return L"Contr";
//    case MS_VPart:
//        return L"VPart";
    case MS_Prep:
        return L"Prep";
//    case MS_Quant:
//        return L"Quant";
    default:
        return L"Unknown";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\data.cpp ===
/*******************************************************************************
* Data.cpp *
*----------*
*   Description:
*       Constant data tables.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

#include "stdafx.h"

#include "AlloOps.h"
#include "ms_entropicengine.h"
#include "Frontend.h"

#pragma warning(disable : 4305)
#pragma warning(disable : 4309)

#define	PUNCT_GAIN		1.67
#define	PUNCT_GAIN1		1.33
#define	SUB1_GAIN		1.00
#define	SUB2_GAIN		1.00




// I don't understand why I had to add "extern" here.
// If YOU do, please explain here for the rest of us:

extern const float g_BoundryStretchTbl[] =
{
    1.0,			// NULL_BOUNDARY = 0,  // no boundary
    PUNCT_GAIN1,    // PHRASE_BOUNDARY,    // comma
    PUNCT_GAIN,    // EXCLAM_BOUNDARY,    // exclamatory utterance terminator
    PUNCT_GAIN,    // YN_QUEST_BOUNDARY,     // yes-no question terminator
    PUNCT_GAIN,    // WH_QUEST_BOUNDARY,     // yes-no question terminator
    PUNCT_GAIN,    // DECLAR_BOUNDARY,    // declarative terminator
    SUB1_GAIN,    // PAREN_L_BOUNDARY,   // left paren
    SUB1_GAIN,    // PAREN_R_BOUNDARY,   // right paren
    SUB1_GAIN,    // QUOTE_L_BOUNDARY,   // left quote
    SUB1_GAIN,    // QUOTE_R_BOUNDARY,   // right quote
    SUB1_GAIN,    // PHONE_BOUNDARY,	// Telephone number
    1.30,			// TOD_BOUNDARY,		// Time-of-day

    SUB2_GAIN,    // SUB_BOUNDARY_1,     // NOTE: always put these at the end
    SUB2_GAIN,    // SUB_BOUNDARY_2,
    SUB2_GAIN,    // SUB_BOUNDARY_3,
    SUB2_GAIN,    // SUB_BOUNDARY_4,
    SUB2_GAIN,    // SUB_BOUNDARY_5,
    SUB2_GAIN,    // SUB_BOUNDARY_6,
    SUB2_GAIN,    // NUMBER_BOUNDARY,

	1.0,			// TAIL_BOUNDARY
};



extern const float   g_BoundryDurTbl[] =
{
    0.200,    // NULL_BOUNDARY = 0,  // no boundary
    0.200,    // PHRASE_BOUNDARY,    // comma
    0.300,    // EXCLAM_BOUNDARY,    // exclamatory utterance terminator
    0.300,    // YN_QUEST_BOUNDARY,     // yes-no question terminator
    0.300,    // WH_QUEST_BOUNDARY,     // wh question terminator
    0.300,    // DECLAR_BOUNDARY,    // declarative terminator
    0.200,    // PAREN_L_BOUNDARY,   // left paren
    0.200,    // PAREN_R_BOUNDARY,   // right paren
    0.200,    // QUOTE_L_BOUNDARY,   // left quote
    0.200,    // QUOTE_R_BOUNDARY,   // right quote
    0.100,    // PHONE_BOUNDARY,	// Telephone number
    0.010,    // TOD_BOUNDARY,		// Time-of-day
    0.200,    // ELLIPSIS_BOUNDARY,		// Ellipsis

    0.001,    // SUB_BOUNDARY_1,     // NOTE: always put these at the end
    0.001,    // SUB_BOUNDARY_2,
    0.001,    // SUB_BOUNDARY_3,
    0.001,    // SUB_BOUNDARY_4,
    0.001,    // SUB_BOUNDARY_5,
    0.001,    // SUB_BOUNDARY_6,

    0.001,    // NUMBER_BOUNDARY,

    0.001,    // TAIL_BOUNDARY,
};






//-------------------------------------------
// Translate -24 <--> +24 pitch control to 
// 24th root of two pitch scale
//-------------------------------------------
extern const float   g_PitchScale[] =
{
    1.0,
    1.0293022366434920287823718007739,
    1.0594630943592952645618252949463,
    1.0905077326652576592070106557607,
    1.1224620483093729814335330496792,
    1.1553526968722730102453370986819,
    1.1892071150027210667174999705605,
    1.2240535433046552391321602168255,
    1.2599210498948731647672106072777,
    1.2968395546510096659337541177919,
    1.3348398541700343648308318811839,
    1.3739536474580891017766557477492,
    1.4142135623730950488016887242091,
    1.4556531828421873543551155614673,
    1.4983070768766814987992807320292,
    1.5422108254079408236122918620901,
    1.5874010519681994747517056392717,
    1.6339154532410998436782440504114,
    1.6817928305074290860622509524658,
    1.7310731220122860533901844375553,
    1.7817974362806786094804524111803,
    1.8340080864093424634870831895876,
    1.8877486253633869932838263133343,
    1.9430638823072117374865788316417,
    2.0
};

//-------------------------------------------
// Translate -10 <--> +10 rate control to 
// 10th root of three rate scale
//-------------------------------------------
extern const float   g_RateScale[] =
{
    1.0,
    1.1161231740339044344426141383771,
    1.2457309396155173259666803366403,
    1.3903891703159093404852542946161,
    1.5518455739153596742733451355167,
    1.7320508075688772935274463415059,
    1.9331820449317627515248789432662,
    2.1576692799745930995549489159803,
    2.4082246852806920462855086141912,
    2.6878753795222865835819210737269,
    3,
    3.348369522101713303327842415131,
    3.7371928188465519779000410099203,
    4.1711675109477280214557628838472,
    4.6555367217460790228200354065486,
    5.1961524227066318805823390245155,
    5.7995461347952882545746368297956,
    6.4730078399237792986648467479371,
    7.2246740558420761388565258425687,
};







extern const unsigned short  g_Opcode_To_ASCII[] =
{
    'IY',   'IH',   'EH',   'AE',   'AA',   'AH',   'AO',   'UH',   'AX',   'ER',
    'EY',   'AY',   'OY',   'AW',   'OW',   'UW',
    'IX',   '_',   'w',    'y',
    'r',    'l',    'h',    'm',    'n',    'NG',   'f',    'v',    'TH',   'DH',
    's',    'z',    'SH',   'ZH',   'p',    'b',    't',    'd',    'k',    'g',
    'CH',   'JH',   'DX',   '1',    '2',    '3',    '/',
    0x5C,   '>',    '<',    '=',    '_',    '*',    '$',    ',',    '.',    '?',
    '!',    '-',    '#',    '+',    '~',    '@',    0,      0,      0,      0
};



extern const unsigned long   g_AlloFlags[] =
{

// IY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KYGLIDEENDF + KFRONTF,

// IH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// EH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// AE
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// AA
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// AH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// AO
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// UH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// AX
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// ER
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// EY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KYGLIDEENDF + KFRONTF + KDIPHTHONGF,

// AY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// OY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// AW
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// OW
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// UW
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// IX
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// SIL
    KSONORANT1F,

// W
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF + KLIQGLIDE2F,

// Y
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF + KYGLIDESTARTF + KYGLIDEENDF,

// R
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF + KLIQGLIDE2F,

// L
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF,

// H
    KSONORANT1F + KCONSONANTF,

// M
    KVOICEDF + KSONORANTF + KSONORANT1F + KNASALF + KCONSONANTF + KSONORCONSONF + KOBSTF + KLABIALF + KHASRELEASEF,

// N
    KVOICEDF + KSONORANTF + KSONORANT1F + KNASALF + KCONSONANTF + KSONORCONSONF + KOBSTF + KALVEOLARF + KHASRELEASEF,

// NG
    KVOICEDF + KSONORANTF + KSONORANT1F + KNASALF + KCONSONANTF + KSONORCONSONF + KOBSTF + KVELAR + KHASRELEASEF,

// F
    KPLOSFRICF + KCONSONANTF + KLABIALF + KFRIC,

// V
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KLABIALF + KFRIC,

// TH
    KPLOSFRICF + KCONSONANTF + KDENTALF + KFRIC,

// DH
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KDENTALF + KFRIC,

// S
    KPLOSFRICF + KCONSONANTF + KALVEOLARF + KFRIC,

// Z
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KALVEOLARF + KFRIC,

// SH
    KPLOSFRICF + KCONSONANTF + KPALATALF + KFRIC,

// ZH
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KPALATALF + KFRIC,

// P
    KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KLABIALF + KHASRELEASEF,

// B
    KVOICEDF + KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KLABIALF + KHASRELEASEF,

// T
    KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KALVEOLARF + KHASRELEASEF,

// D
    KVOICEDF + KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KALVEOLARF + KHASRELEASEF,

// K
    KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KVELAR + KHASRELEASEF,

// G
    KVOICEDF + KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KVELAR + KHASRELEASEF,

// CH
    KPLOSFRICF + KCONSONANTF + KPLOSIVEF + KOBSTF + KPALATALF + KAFFRICATEF,

// JH
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KPLOSIVEF + KOBSTF + KPALATALF + KAFFRICATEF,

// DX
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KOBSTF,
};








extern const short   g_IPAToAllo[] =
{
    28,     // _IY_
    27,     // _IH_
    21,     // _EH_
    11,     // _AE_
    10,     // _AA_
    12,     // _AH_
    13,     // _AO_
    43,     // _UH_
    15,     // _AX_
    22,     // _ER_
    23,     // _EY_
    16,     // _AY_
    36,     // _OY_
    14,     // _AW_
    35,     // _OW_
    44,     // _UW_
    NO_IPA,     // _IX_
    7,     // _SIL_
    46,       // _w_
    47,       // _y_
    38,       // _r_     0x279
    31,       // _l_
    26,      // _h_      0x68
    32,       // _m_
    33,       // _n_
    34,      // _NG_
    24,       // _f_
    45,       // _v_
    42,      // _TH_
    20,      // _DH_
    39,       // _s_
    48,       // _z_
    40,      // _SH_
    49,      // _ZH_
    37,       // _p_
    17,       // _b_
    41,       // _t_
    19,       // _d_
    30,       // _k_
    25,       // _g_     0x67
    18,      // _CH_
    29,      // _JH_     0x2a4
    NO_IPA,       // _DX_       // @@@@
    8,      // _STRESS1_
    9,      // _STRESS2_
    NO_IPA,      // _EMPHSTRESS_
    1,      // _SYLLABLE_
};




extern const short   g_AlloToViseme[] =
{
    SP_VISEME_6,     // _IY_
    SP_VISEME_6,     // _IH_
    SP_VISEME_4,     // _EH_
    SP_VISEME_1,     // _AE_
    SP_VISEME_2,     // _AA_
    SP_VISEME_1,     // _AH_
    SP_VISEME_3,     // _AO_
    SP_VISEME_4,     // _UH_
    SP_VISEME_1,     // _AX_
    SP_VISEME_5,     // _ER_
    SP_VISEME_4,     // _EY_
    SP_VISEME_11,    // _AY_
    SP_VISEME_10,    // _OY_
    SP_VISEME_9,     // _AW_
    SP_VISEME_8,     // _OW_
    SP_VISEME_7,     // _UW_
    SP_VISEME_6,     // _IX_
    SP_VISEME_0,     // _SIL_
    SP_VISEME_7,       // _w_
    SP_VISEME_6,       // _y_
    SP_VISEME_13,       // _r_ 
    SP_VISEME_14,       // _l_
    SP_VISEME_12,      // _h_ 
    SP_VISEME_21,       // _m_
    SP_VISEME_19,       // _n_
    SP_VISEME_20,      // _NG_
    SP_VISEME_18,       // _f_
    SP_VISEME_18,       // _v_
    SP_VISEME_17,      // _TH_
    SP_VISEME_17,      // _DH_
    SP_VISEME_15,       // _s_
    SP_VISEME_15,       // _z_
    SP_VISEME_16,      // _SH_
    SP_VISEME_16,      // _ZH_
    SP_VISEME_21,       // _p_
    SP_VISEME_21,       // _b_
    SP_VISEME_19,       // _t_
    SP_VISEME_19,       // _d_
    SP_VISEME_20,       // _k_
    SP_VISEME_20,       // _g_
    SP_VISEME_16,      // _CH_
    SP_VISEME_16,      // _JH_ 
    SP_VISEME_13,       // _DX_       // @@@@
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\alphanorm.cpp ===
/***********************************************************************************************
* AlphaNorm.cpp *
*---------------*
*  Description:
*   These functions normalize mostly-alpha strings.
*-----------------------------------------------------------------------------------------------
*  Created by AARONHAL                                                           August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"
#include "stdsentenum.h"

/***********************************************************************************************
* IsAbbreviationEOS *
*-------------------*
*   Description:
*       Abbreviations which get here are ALWAYS abbreviations.  This function tries to determine 
*   whether or not the period at the end of the abbreviation is the end of the sentence.  
*
*   If match made:
*       Sets the Item in the ItemList at ItemPos to the abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsAbbreviationEOS( const AbbrevRecord* pAbbreviation, CItemList &ItemList, SPLISTPOS ItemPos, 
                                         CSentItemMemory &MemoryManager, BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IsAbbreviationEOS" );
    HRESULT hr = S_OK;
    BOOL fMatchedEOS = false;

    //--- Need to determine whether the abbreviation's period is also the end of the sentence.
    if ( !(*pfIsEOS) )
    {
        //--- Advance to the beginning of the next token
        const WCHAR *pTempNextChar = (WCHAR*) m_pEndOfCurrToken, *pTempEndChar = (WCHAR*) m_pEndChar;
        const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
        hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

        if ( SUCCEEDED( hr ) )
        {

            //--- If we have reached the end of the buffer, consider the abbreviation's period as
            //--- the end of the sentence.
            if ( !pTempNextChar )
            {
                *pfIsEOS = true;
                fMatchedEOS = true;
            }
            //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
            //--- the next token is a common first word (which must be capitalized).
            else if ( IsCapital( *pTempNextChar ) )
            {
                WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                //--- Try to match a first word.
                WCHAR temp = (WCHAR) *pTempEndOfItem;
                *pTempEndOfItem = 0;
                
                if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                              sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                {
                    *pfIsEOS = true;
                    fMatchedEOS = true;
                }

                *pTempEndOfItem = temp;
            }
        }
    }

    //--- Insert abbreviation into the ItemList
    if ( SUCCEEDED( hr ) )
    {
        CSentItem Item;

        Item.pItemSrcText       = m_pNextChar;
        Item.ulItemSrcLen       = (long) (m_pEndOfCurrItem - m_pNextChar);
        Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                  (long)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords         = 1;
        Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState  = &m_pCurrFrag->State;
            Item.Words[0].pWordText  = Item.pItemSrcText;
            Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
            Item.Words[0].pLemma     = Item.pItemSrcText;
            Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                if ( NeedsToBeNormalized( pAbbreviation ) )
                {
                    Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                }
                else
                {
                    Item.pItemInfo->Type = eABBREVIATION;
                }
                ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbreviation;
                ItemList.SetAt( ItemPos, Item );
            }
        }
    }

    return hr;
} /* IsAbbreviationEOS */

/***********************************************************************************************
* IfEOSNotAbbreviation *
*----------------------*
*   Description:
*       Abbreviations which get here may or may not be abbreviations.  If the period is EOS,
*   this is not an abbreviation (and return will be E_INVALIDARG), otherwise, it is an
*   abbreviation.
*
*   If match made:
*       Sets the Item in the ItemList at ItemPos to the abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IfEOSNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList &ItemList, SPLISTPOS ItemPos, 
                                            CSentItemMemory &MemoryManager, BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IfEOSNotAbbreviation" );
    HRESULT hr = S_OK;

    //--- Need to determine whether the abbreviation's period is also the end of the sentence.
    if ( !(*pfIsEOS) )
    {
        //--- Advance to the beginning of the next token
        const WCHAR *pTempNextChar = m_pEndOfCurrToken, *pTempEndChar = m_pEndChar;
        const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
        hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

        if ( !pTempNextChar )
        {
            hr = E_INVALIDARG;
        }

        if ( SUCCEEDED( hr ) )
        {

            //--- If we have reached the end of the buffer, consider the abbreviation's period as
            //--- the end of the sentence.
            if ( !pTempNextChar )
            {
                *pfIsEOS = true;
            }
            //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
            //--- the next token is a common first word (which must be capitalized).
            else if ( IsCapital( *pTempNextChar ) )
            {
                WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                //--- Try to match a first word.
                WCHAR temp = (WCHAR) *pTempEndOfItem;
                *pTempEndOfItem = 0;
                
                if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                              sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                {
                    *pfIsEOS = true;
                }

                *pTempEndOfItem = temp;
            }
        }
    }
    
    if ( *pfIsEOS )
    {
        //--- EOS - not an abbreviation
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Insert abbreviation into the ItemList
        CSentItem Item;

        Item.pItemSrcText       = m_pNextChar;
        Item.ulItemSrcLen       = (long)(m_pEndOfCurrItem - m_pNextChar);
        Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                  (long)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords         = 1;
        Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState  = &m_pCurrFrag->State;
            Item.Words[0].pWordText  = Item.pItemSrcText;
            Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
            Item.Words[0].pLemma     = Item.pItemSrcText;
            Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                if ( NeedsToBeNormalized( pAbbreviation ) )
                {
                    Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                }
                else
                {
                    Item.pItemInfo->Type = eABBREVIATION;
                }
                ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbreviation;
                ItemList.SetAt( ItemPos, Item );
            }
        }
    }

    return hr;
} /* IfEOSNotAbbreviation */

/***********************************************************************************************
* IfEOSAndLowercaseNotAbbreviation *
*----------------------------------*
*   Description:
*       Abbreviations which get here may or may not be abbreviations.  If the period is EOS,
*   and the next item is lowercase this is not an abbreviation (and return will be E_INVALIDARG), 
*   otherwise, it is an abbreviation.
*
*   If match made:
*       Sets the Item in the ItemList at ItemPos to the abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IfEOSAndLowercaseNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList &ItemList, 
                                                        SPLISTPOS ItemPos, CSentItemMemory &MemoryManager, 
                                                        BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IfEOSAndLowercaseNotAbbreviation" );
    HRESULT hr = S_OK;

    //--- Need to determine whether the abbreviation's period is also the end of the sentence.
    if ( !(*pfIsEOS) )
    {
        //--- Advance to the beginning of the next token
        const WCHAR *pTempNextChar = m_pEndOfCurrToken, *pTempEndChar = m_pEndChar;
        const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
        hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

        if ( SUCCEEDED( hr ) )
        {

            //--- If we have reached the end of the buffer, consider the abbreviation's period as
            //--- the end of the sentence.
            if ( !pTempNextChar )
            {
                *pfIsEOS = true;
            }
            //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
            //--- the next token is a common first word (which must be capitalized).
            else if ( IsCapital( *pTempNextChar ) )
            {
                WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                //--- Try to match a first word.
                WCHAR temp = (WCHAR) *pTempEndOfItem;
                *pTempEndOfItem = 0;
                
                if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                              sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                {
                    *pfIsEOS = true;
                }

                *pTempEndOfItem = temp;
            }
        }
    }
    
    if ( *pfIsEOS &&
         !iswupper( *m_pNextChar ) )
    {
        //--- EOS - not an abbreviation
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Insert abbreviation into the ItemList
        CSentItem Item;

        Item.pItemSrcText       = m_pNextChar;
        Item.ulItemSrcLen       = (long)(m_pEndOfCurrItem - m_pNextChar);
        Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                  (long)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords         = 1;
        Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState  = &m_pCurrFrag->State;
            Item.Words[0].pWordText  = Item.pItemSrcText;
            Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
            Item.Words[0].pLemma     = Item.pItemSrcText;
            Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                if ( NeedsToBeNormalized( pAbbreviation ) )
                {
                    Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                }
                else
                {
                    Item.pItemInfo->Type = eABBREVIATION;
                }
                ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbreviation;
                ItemList.SetAt( ItemPos, Item );
            }
        }
    }

    return hr;
} /* IfEOSNotAbbreviation */

/***********************************************************************************************
* SingleOrPluralAbbreviation *
*----------------------------*
*   Description:
*       At this point, we are already sure that the item is an abbreviation, and just need to
*   determine whether it should take its singular form, plural form, or some alternate.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::SingleOrPluralAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                                  CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::SingleOrPluralAbbreviation" );
    HRESULT hr = S_OK;

    //--- Get Item which comes before the abbreviation
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        pPron->pronArray[PRON_A].POScount = 1;
        pPron->pronArray[PRON_B].POScount = 0;
        pPron->pronArray[PRON_B].phon_Len = 0;
        pPron->hasAlt                     = false;
        pPron->altChoice                  = PRON_A;
        //--- Abbreviation table pronunciations are basically just vendor lex prons...
        pPron->pronType                   = eLEXTYPE_PRIVATE1;

        //--- If a cardinal number, need to do singular vs. plural logic
        if ( TempItem.pItemInfo->Type == eNUM_CARDINAL ||
             TempItem.pItemInfo->Type == eDATE_YEAR )
        {
            if ( ( TempItem.ulItemSrcLen == 1 &&
                   wcsncmp( TempItem.pItemSrcText, L"1", 1 ) == 0 ) ||
                 ( TempItem.ulItemSrcLen == 2 &&
                   wcsncmp( TempItem.pItemSrcText, L"-1", 2 ) == 0 ) )
            {
                //--- Use singular form - first entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
            else
            {
                //--- Use plural form - second entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
        }
        //--- If a decimal number, pick plural
        else if ( TempItem.pItemInfo->Type == eNUM_DECIMAL )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
        //--- If an ordinal number or fraction, pick singular
        else if ( TempItem.pItemInfo->Type == eNUM_ORDINAL )
        {
            //--- Use singular form - first entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Fractions and mixed fractions require some more work...
        else if ( TempItem.pItemInfo->Type == eNUM_FRACTION )
        {
            if ( ( (TTSNumberItemInfo*) TempItem.pItemInfo )->pFractionalPart->fIsStandard )
            {
                //--- Standard fractions (e.g. 11/20) get the plural form
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;

            }
            else
            {
                //--- Singular form with [of a] or [of an] inserted beforehand
                if ( bsearch( (void*) pAbbrevInfo->pPron1, (void*) g_Vowels, sp_countof( g_Vowels ), 
                     sizeof( WCHAR ), CompareWCHARAndWCHAR ) )
                {
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, g_pOfAn );
                    pPron->pronArray[PRON_A].phon_Len = wcslen( g_pOfAn );
                }
                else
                {
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, g_pOfA );
                    pPron->pronArray[PRON_A].phon_Len = wcslen( g_pOfA );
                }
                wcscat( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   += wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
        }
        else if ( TempItem.pItemInfo->Type == eNUM_MIXEDFRACTION )
        {
            //--- Plural form
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;

        }
        //--- Special case - preceded by "one"
        else if ( TempItem.ulItemSrcLen == 3 &&
                  wcsnicmp( TempItem.pItemSrcText, L"one", 3 ) == 0 )
        {
            //--- Use singular form - first entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Special case - Number cu. MeasurementAbbrev (e.g. 10 cu. cm, 1 cu cm)
        //--- Special case - Number fl. MeasurementAbbrev (e.g. 10 fl. oz., 10 fl oz)
        else if ( ( TempItem.ulItemSrcLen == 2 &&
                    ( _wcsnicmp( TempItem.pItemSrcText, L"cu", 2 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"sq", 2 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"fl", 2 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 3 &&
                    ( _wcsnicmp( TempItem.pItemSrcText, L"cu.", 3 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"sq.", 3 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"fl.", 3 ) == 0 ) ) )
        {
            if ( TempPos )
            {
                TempItem = ItemList.GetPrev( TempPos );
                //--- If a cardinal number, need to do singular vs. plural logic
                if ( TempItem.pItemInfo->Type == eNUM_CARDINAL )
                {
                    if ( ( TempItem.ulItemSrcLen == 1 &&
                           wcsncmp( TempItem.pItemSrcText, L"1", 1 ) == 0 ) ||
                         ( TempItem.ulItemSrcLen == 2 &&
                           wcsncmp( TempItem.pItemSrcText, L"-1", 2 ) == 0 ) )
                    {
                        //--- Use singular form - first entry
                        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                        pPron->POSchoice                    = pAbbrevInfo->POS1;
                    }
                    else
                    {
                        //--- Use plural form - second entry
                        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                        pPron->POSchoice                    = pAbbrevInfo->POS2;
                    }
                }
                //--- If a decimal number, pick plural
                else if ( TempItem.pItemInfo->Type == eNUM_DECIMAL )
                {
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;
                }
                //--- If an ordinal number or fraction, pick singular
                else if ( TempItem.pItemInfo->Type == eNUM_ORDINAL )
                {
                    //--- Use singular form - first entry
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                    pPron->POSchoice                    = pAbbrevInfo->POS1;
                }
                //--- Fractions and mixed fractions require some more work...
                else if ( TempItem.pItemInfo->Type == eNUM_FRACTION )
                {
                    if (( (TTSNumberItemInfo*) TempItem.pItemInfo )->pFractionalPart->fIsStandard ) 
                    {
						//--- Standard fractions (e.g. 11/20) get the plural form
						wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
						pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
					    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
					    pPron->POSchoice                    = pAbbrevInfo->POS2;
                    }
                    else
                    {
                        //--- Singular form with [of a] or [of an] inserted beforehand
						//--- (this was handled when processing 'cu' or 'sq')
                        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                        pPron->POSchoice                    = pAbbrevInfo->POS1;
                    }
                }
                else if ( TempItem.pItemInfo->Type == eNUM_MIXEDFRACTION )
                {
                    //--- Plural form
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;

                }
                //--- Special case - preceded by "one"
                else if ( TempItem.ulItemSrcLen == 3 &&
                          wcsnicmp( TempItem.pItemSrcText, L"one", 3 ) == 0 )
                {
                    //--- Use singular form - first entry
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                    pPron->POSchoice                    = pAbbrevInfo->POS1;
                }
                //--- Default behavior
                else
                {
                    //--- Use plural form - second entry
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;
                }
            }
        }
        //--- Check for number words - just cover through 99...
        else if ( ( TempItem.ulItemSrcLen == 3 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"two", 3 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"six", 3 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"ten", 3 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 4 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"four", 4 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"five", 4 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"nine", 4 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 5 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"three", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"seven", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eight", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"forty", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"fifty", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"sixty", 5 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 6 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"twenty", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"thirty", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eighty", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"ninety", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eleven", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"twelve", 6 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 7 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"seventy", 7 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"fifteen", 7 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"sixteen", 7 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 8 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"thirteen", 8 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"fourteen", 8 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eighteen", 8 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"nineteen", 8 ) == 0 ) ) )
        {
            //--- Use plural form - second entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;    
        }                    
        //--- Default behavior
        else
        {
            //--- Has alternate when non-number precedes - special case
            if ( pAbbrevInfo->pPron3 )
            {
                //--- Use initial form - third entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron3 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS3;
                pPron->POSchoice                    = pAbbrevInfo->POS3;
            }
            else
            {
                //--- Use plural form - second entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
        }
    }
    //--- Default behavior
    else if ( hr == E_INVALIDARG )
    {
        hr = S_OK;

        //--- Has alternate when non-number precedes - special case
        if ( pAbbrevInfo->pPron3 )
        {
            //--- Use initial form - third entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron3 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS3;
            pPron->POSchoice                    = pAbbrevInfo->POS3;
        }
        else
        {
            //--- Use plural form - second entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* SingleOrPluralAbbreviation */

/***********************************************************************************************
* DoctorDriveAbbreviation *
*-------------------------*
*   Description:
*       At this point, we are already sure that the item is an abbreviation, and just need to
*   determine whether it should be Doctor (Saint) or Drive (Street).
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::DoctorDriveAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                               CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::SingleOrPluralAbbreviation" );
    HRESULT hr = S_OK;
    BOOL fMatch = false;
    BOOL fDoctor = false;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get Item which comes after the Abbreviation
    SPLISTPOS TempPos = ListPos;
    if ( !ListPos )
    {
        //--- Go with Drive - end of buffer cannot be followed by a name...
        fDoctor = false;
        fMatch  = true;
    }
    else
    {
        TTSSentItem TempItem = ItemList.GetNext( TempPos );
        if ( TempItem.eItemPartOfSpeech == MS_EOSItem )
        {
            //--- Go with Drive - end of buffer cannot be followed by a name...
            fDoctor = false;
            fMatch  = true;
        }
        else
        {
            ULONG index = 0;

            //--- Try to match a Name (an uppercase letter followed by lowercase letters)
            if ( TempItem.ulItemSrcLen > 0 &&
                 iswupper( TempItem.pItemSrcText[index] ) )
            {
                index++;
                while ( index < TempItem.ulItemSrcLen &&
                        iswlower( TempItem.pItemSrcText[index] ) )
                {
                    index++;
                }
                //--- Check for possessives - RAID 5823
                if ( index == TempItem.ulItemSrcLen - 2    &&
                     TempItem.pItemSrcText[index+1] == L'\'' &&
                     TempItem.pItemSrcText[index+2] == L's' )
                {
                    index += 2;
                }

                //--- Check for directions - North, South, West, East, Ne, Nw, Se, Sw, N, S, E, W
                if ( index == TempItem.ulItemSrcLen &&
                     wcsncmp( TempItem.pItemSrcText, L"North", 5 ) != 0 &&
                     wcsncmp( TempItem.pItemSrcText, L"South", 5 ) != 0 &&
                     wcsncmp( TempItem.pItemSrcText, L"West", 4 )  != 0 &&
                     wcsncmp( TempItem.pItemSrcText, L"East", 4 )  != 0 &&
                     !( TempItem.ulItemSrcLen == 2 &&
                        ( wcsncmp( TempItem.pItemSrcText, L"Ne", 2 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"Nw", 2 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"Se", 2 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"Sw", 2 ) == 0 ) ) &&
                     !( TempItem.ulItemSrcLen == 1 &&
                        ( wcsncmp( TempItem.pItemSrcText, L"N", 1 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"S", 1 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"E", 1 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"W", 1 ) == 0 ) ) )
                {
                    //--- Check for name previous item
                    TempPos = ListPos;

                    ItemList.GetPrev( TempPos );
                    if ( TempPos )
                    {
                        ItemList.GetPrev( TempPos );
                        if ( TempPos )
                        {
                            TTSSentItem PrevItem = ItemList.GetPrev( TempPos );
                            index = 0;

                            if ( PrevItem.ulItemSrcLen > 0 &&
                                 iswupper( PrevItem.pItemSrcText[index++] ) )
                            {
                                while ( index < PrevItem.ulItemSrcLen &&
                                        islower( PrevItem.pItemSrcText[index] ) )
                                {
                                    index++;
                                }
                                if ( index == PrevItem.ulItemSrcLen )
                                {
                                    //--- Go with Drive - names before and after, e.g. Main St. Washington, D.C.
                                    fDoctor = false;
                                    fMatch  = true;
                                }
                            }
                        }
                    }                                    

                    if ( !fMatch )
                    {
                        //--- Go with Doctor - matched a Name after and not a name before
                        fDoctor = true;
                        fMatch  = true;
                    }
                }
                else if ( index == 1                    &&
                          TempItem.ulItemSrcLen == 2    &&
                          TempItem.pItemSrcText[index] == L'.' )
                {
                    //--- Go with Doctor - matched an initial
                    fDoctor = true;
                    fMatch  = true;
                }
            }
        }
    }

    if ( !fMatch ) 
    {
        //--- Try to get previous item...
        BOOL fSentenceInitial = false;
        TempPos = ListPos;
        if ( TempPos )
        {
            ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                ItemList.GetPrev( TempPos );
                if ( !TempPos )
                {
                    fSentenceInitial = true;
                }
                else
                {
                    TTSSentItem PrevItem = ItemList.GetPrev( TempPos );
                    if ( PrevItem.pItemInfo->Type == eOPEN_PARENTHESIS ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACKET     ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACE       ||
                         PrevItem.pItemInfo->Type == eSINGLE_QUOTE     ||
                         PrevItem.pItemInfo->Type == eDOUBLE_QUOTE )
                    {
                        fSentenceInitial = true;
                    }
                }
            }
        }
        //--- Sentence initial - go with Doctor
        if ( fSentenceInitial )
        {
            fDoctor = true;
            fMatch  = true;
        }
        //--- Default - go with Drive
        else
        {
            fDoctor = false;
            fMatch = true;
        }
    }

    if ( fDoctor )
    {
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
        pPron->POSchoice                    = pAbbrevInfo->POS1;
    }
    else
    {  
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->POSchoice                    = pAbbrevInfo->POS2;
    }


    return hr;
} /* DoctorDriveAbbreviation */

/***********************************************************************************************
* AbbreviationFollowedByDigit *
*-----------------------------*
*   Description:
*       At this point, we are already sure that the item is an abbreviation, and just need to
*   determine which pronunciation to go with.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::AbbreviationFollowedByDigit( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                                   CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::AbbreviationFollowedByDigit" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get Item which comes after the Abbreviation
    SPLISTPOS TempPos = ListPos;
    if ( !ListPos )
    {
        //--- Go with pron 2
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->POSchoice                    = pAbbrevInfo->POS2;
    }
    else
    {
        TTSSentItem TempItem = ItemList.GetNext( TempPos );

        if ( TempItem.ulItemSrcLen > 0 &&
             iswdigit( TempItem.pItemSrcText[0] ) )
        {
            //--- Go with pron 1
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        else
        {
            //--- Go with pron 2
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* AbbreviationFollowedByDigit */

/***********************************************************************************************
* AllCapsAbbreviation *
*---------------------*
*   Description:
*       This functions disambiguates abbreviations without periods which are pronounced
*   differently if they are all capital letters.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::AllCapsAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                           CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::AllCapsAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        for ( ULONG i = 0; i < TempItem.ulItemSrcLen; i++ )
        {
            if ( !iswupper( TempItem.pItemSrcText[i] ) )
            {
                break;
            }
        }
        //--- All Caps - go with first pronunciation
        if ( i == TempItem.ulItemSrcLen )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Not All Caps - go with second pronunciation
        else
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* AllCapsAbbreviation */

/***********************************************************************************************
* CapitalizedAbbreviation *
*-------------------------*
*   Description:
*       This functions disambiguates abbreviations without periods which are pronounced
*   differently if they begin with a capital letter.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::CapitalizedAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                               CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::CapitalizedAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        //--- Capitalized - go with first pronunciation
        if ( iswupper( TempItem.pItemSrcText[0] ) )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Not Capitalized - go with second pronunciation
        else
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* CapitalizedAbbreviation */

/***********************************************************************************************
* SECAbbreviation *
*-----------------*
*   Description:
*       This functions disambiguates SEC, Sec, and sec and so forth...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::SECAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                       CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::SECAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        for ( ULONG i = 0; i < TempItem.ulItemSrcLen; i++ )
        {
            if ( !iswupper( TempItem.pItemSrcText[i] ) )
            {
                break;
            }
        }
        //--- All Caps - go with SEC
        if ( i == TempItem.ulItemSrcLen )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron3 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS3;
            pPron->POSchoice                    = pAbbrevInfo->POS3;
        }
        //--- Not All Caps - do SingleOrPlural disambiguation
        else
        {
            SingleOrPluralAbbreviation( pAbbrevInfo, pPron, ItemList, ListPos );
        }
    }

    return hr;
} /* SECAbbreviation */

/***********************************************************************************************
* DegreeAbbreviation *
*--------------------*
*   Description:
*       This functions disambiguates C, F, and K (Celsius, Fahrenheit, Kelvin)
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::DegreeAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                          CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::DegreeAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item and previous item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem, PrevItem;
    BOOL fLetter = false;
    
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            TempItem = ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                PrevItem = ItemList.GetPrev( TempPos );
                if ( PrevItem.pItemInfo->Type != eNUM_DEGREES )
                {
                    fLetter = true;
                }
            }
            else
            {
                fLetter = true;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( fLetter )
        {
            //--- This word is just the letter C, F, or K - second pron
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
        //--- This word is the degree expansion - Celsius, Fahrenheit, or Kelvin
        else
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
    }

    return hr;
} /* DegreeAbbreviation */

/***********************************************************************************************
* IsInitialIsm *
*--------------*
*   Description:
*       Checks the next token in the text stream to determine if it is an initialism.  Also 
*   tries to determine whether or not the period at the end of the initialism is the end of 
*   the sentence.  
*
*   If match made:
*       Advances m_pNextChar to the appropriate position (either the period at the end of the 
*   abbreviation, or just past that period).  Sets the Item in the ItemList at ItemPos to the
*   abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsInitialism( CItemList &ItemList, SPLISTPOS ItemPos, CSentItemMemory &MemoryManager,
                                    BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IsInitialism" );

    HRESULT hr = S_OK;
    BOOL fMatchedEOS = false;

    //--- Initialism must be at least two characters.
    if ( (long)(m_pEndOfCurrItem - m_pNextChar) < 4 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        const WCHAR *pIterator = NULL;
        ULONG ulCount = 0;
    
        pIterator  = m_pNextChar;

        //--- Iterate through the token, each time checking for an alpha character followed by a period.
        while ( SUCCEEDED(hr) &&
                pIterator <= m_pEndOfCurrItem - 2)
        {
            if ( !iswalpha(*pIterator) ||
                 *(pIterator + 1) != L'.' )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                pIterator += 2;
                ulCount++;
            }
        }

        //--- Need to determine whether the initialism's period is also the end of the sentence.
        if ( SUCCEEDED( hr ) &&
             !(*pfIsEOS) )
        {
            //--- Advance to the beginning of the next token
            const WCHAR *pTempNextChar = m_pEndOfCurrToken, *pTempEndChar = m_pEndChar;
            const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
            hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

            if ( SUCCEEDED( hr ) )
            {

                //--- If we have reached the end of the buffer, consider the abbreviation's period as
                //--- the end of the sentence.
                if ( !pTempNextChar )
                {
                    *pfIsEOS = true;
                    fMatchedEOS = true;
                }
                //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
                //--- the next token is a common first word (which must be capitalized).
                else if ( IsCapital( *pTempNextChar ) )
                {
                    WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                    //--- Try to match a first word.
                    WCHAR temp = (WCHAR) *pTempEndOfItem;
                    *pTempEndOfItem = 0;
                
                    if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                                  sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                    {
                        *pfIsEOS = true;
                        fMatchedEOS = true;
                    }

                    *pTempEndOfItem = temp;
                }
            }
        }

        //--- Now insert the Initialism in the ItemList.
        if ( SUCCEEDED(hr) )
        {
            CSentItem Item;
            Item.pItemSrcText       = m_pNextChar;
            Item.ulItemSrcLen       = (long)(m_pEndOfCurrItem - m_pNextChar);
            Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                      (long)( m_pNextChar - m_pCurrFrag->pTextStart );
            Item.ulNumWords         = ulCount;
            Item.Words = (TTSWord*) MemoryManager.GetMemory( ulCount * sizeof(TTSWord), &hr );
            if ( SUCCEEDED( hr ) )
            {
                SPVSTATE* pNewState = (SPVSTATE*) MemoryManager.GetMemory( sizeof( SPVSTATE ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    //--- Ensure letters are pronounced as nouns...
                    memcpy( pNewState, &m_pCurrFrag->State, sizeof( SPVSTATE ) );
                    pNewState->ePartOfSpeech = SPPS_Noun;

                    ZeroMemory( Item.Words, ulCount * sizeof(TTSWord) );
                    for ( ULONG i = 0; i < ulCount; i++ )
                    {
                        Item.Words[i].pXmlState  = pNewState;
                        Item.Words[i].pWordText  = &Item.pItemSrcText[ 2 * i ];
                        Item.Words[i].ulWordLen  = 1;
                        Item.Words[i].pLemma     = Item.Words[i].pWordText;
                        Item.Words[i].ulLemmaLen = Item.Words[i].ulWordLen;
                    }
                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo->Type = eINITIALISM;
                        ItemList.SetAt( ItemPos, Item );
                    }
                }
            }
        }
    }
    return hr;
} /* IsInitialism */

/***********************************************************************************************
* IsAlphaWord *
*-------------*
*   Description:
*       Checks the next token in the text stream to determine if it is an Alpha Word (all alpha
*   characters, except possibly a single apostrophe). 
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsAlphaWord( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo,
                                   CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsAlphaWord" );
    SPDBG_ASSERT( pStartChar < pEndChar );
    HRESULT hr = S_OK;

    bool fApostropheSeen = false;
    WCHAR *pCurrChar = (WCHAR*) pStartChar;

    while ( SUCCEEDED( hr ) &&
            pCurrChar &&
            pCurrChar < pEndChar )
    {
        if ( iswalpha( *pCurrChar ) )
        {
            pCurrChar++;
        }
        else if ( *pCurrChar == L'\''&&
                  !fApostropheSeen )
        {
            fApostropheSeen = true;
            pCurrChar++;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        //--- Matched Alpha Word
        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eALPHA_WORD;
        }
    }

    return hr;
} /* IsAlphaWord */

/***********************************************************************************************
* AbbreviationModifier *
*----------------------*
*   Description:
*       Fixes pronunciation issues for special case where 'sq' or 'cu' modifies
*		a measurement.
*
*************************************************************** MERESHAW **********************/
HRESULT CStdSentEnum::AbbreviationModifier( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                                  CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::AbbreviationModifier" );
    HRESULT hr = S_OK;

    //--- Get Item which comes before the abbreviation modifier
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        //--- Current Item - if All Caps, go with first pronunciation (need to do this before next 
        //---   stage of processing, since CU and FL's all caps prons take precedence over numeric...)
        TempItem = ItemList.GetPrev( TempPos );
        for ( ULONG i = 0; i < TempItem.ulItemSrcLen; i++ )
        {
            if ( !iswupper( TempItem.pItemSrcText[i] ) )
            {
                break;
            }
        }
        if ( i == TempItem.ulItemSrcLen )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
            return hr;
        }             
    }
    else
    {
        hr = E_INVALIDARG;
    }
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        pPron->pronArray[PRON_A].POScount = 1;
        pPron->pronArray[PRON_B].POScount = 0;
        pPron->pronArray[PRON_B].phon_Len = 0;
        pPron->hasAlt                     = false;
        pPron->altChoice                  = PRON_A;
        //--- Abbreviation table pronunciations are basically just vendor lex prons...
        pPron->pronType                   = eLEXTYPE_PRIVATE1;

        //--- If a cardinal, decimal, or ordinal number, use regular form
        if (( TempItem.pItemInfo->Type == eNUM_CARDINAL ) ||
			( TempItem.pItemInfo->Type == eNUM_DECIMAL ) ||
			( TempItem.pItemInfo->Type == eNUM_ORDINAL ) ||
			( TempItem.pItemInfo->Type == eNUM_MIXEDFRACTION ) ||
			( TempItem.pItemInfo->Type == eDATE_YEAR ) ||
			( TempItem.ulItemSrcLen == 3 &&
                  wcsnicmp( TempItem.pItemSrcText, L"one", 3 ) == 0 ))
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }

        //--- Fractions and mixed fractions require some more work...
        else if ( TempItem.pItemInfo->Type == eNUM_FRACTION )
        {
            if (( (TTSNumberItemInfo*) TempItem.pItemInfo )->pFractionalPart->fIsStandard ) 
            {
                //--- Standard fractions (e.g. 11/20) get the plural form
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
            else
            {
                //--- Singular form with [of a] inserted beforehand ([of an] case need not be
				//--- checked because we're only dealing with 'sq' or 'cu'.

				wcscpy( pPron->pronArray[PRON_A].phon_Str, g_pOfA );
				pPron->pronArray[PRON_A].phon_Len = wcslen( g_pOfA );
                
                wcscat( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   += wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
        }
 
        //--- Default behavior
        else
        {
            //--- Use default form ('sq')
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }
    //--- Default behavior - use first pron
    else if ( hr == E_INVALIDARG )
    {
        hr = S_OK;
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
        pPron->POSchoice                    = pAbbrevInfo->POS1;
    }

    return hr;
} /* AbbreviationModifier */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\alloops.cpp ===
/*******************************************************************************
* AlloOps.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the CAlloOps class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"

#include "ms_entropicengine.h"
#include <spdebug.h>
#include "FeedChain.h"
#include "Frontend.h"
#include "AlloOps.h"




//-----------------------------
// Data.cpp
//-----------------------------
extern const unsigned short  g_Opcode_To_ASCII[];
extern const unsigned long   g_AlloFlags[];


/*****************************************************************************
* CBookmarkList::~CBookmarkList *
*-------------------------------*
*   Description:
*   Destructor for CBookmarkList
*       
********************************************************************** MC ***/
CBookmarkList::~CBookmarkList()
{
    SPDBG_FUNC( "CBookmarkList::~CBookmarkList" );
    BOOKMARK_ITEM*  pItem;

    //----------------------------------------
    //   Remove every item in link list.
    //----------------------------------------
    while( !m_BMList.IsEmpty() )
    {
        pItem = (BOOKMARK_ITEM*)m_BMList.RemoveHead();
        delete pItem;
    }
} /* CBookmarkList::~CBookmarkList */




/*****************************************************************************
* CFEToken::CFEToken *
*------------------------*
*   Description:
*   Initializer for CFEToken
*       
********************************************************************** MC ***/
CFEToken::CFEToken()
{
    SPDBG_FUNC( "CFEToken::CFEToken" );

    user_Volume = DEFAULT_USER_VOL;
    user_Rate = DEFAULT_USER_RATE;
    user_Pitch = DEFAULT_USER_PITCH;
    user_Emph = DEFAULT_USER_EMPH;
    user_Break = 0;
    pBMObj = NULL;

    memset( &tokStr[0], 0, sizeof(WCHAR) * TOKEN_LEN_MAX);
    tokLen = 0;
    memset( &phon_Str[0], 0, sizeof(short) * SP_MAX_PRON_LENGTH);
    phon_Len = 0;
    m_posClass = POS_UNK;
    POScode = MS_Unknown;
    m_TuneBoundaryType = NULL_BOUNDARY;
    m_Accent = K_NOACC;
    m_Boundary = K_NOBND;

	m_TermSil			= 0;
    m_DurScale			= 0.0f;
    m_ProsodyDurScale	= 1.0f;
	m_PitchBaseOffs		= 0.0f;
	m_PitchRangeScale	= 1.0f;

	// The following don't need to be init'd
    m_PronType			= PRON_LTS;
    sentencePosition	= 0;				// Source sentence position for this token
    sentenceLen			= 0; 				// Source sentence length for this token
    srcPosition			= 0;				// Source position for this token
    srcLen				= 0; 				// Source length for this token
    m_Accent_Prom		= 0;                // prominence prosodic control
    m_Boundary_Prom		= 0;                // prominence prosodic control
	m_TermSil			= 0;				// Pad word with silence (in sec)

	//--- Diagnostic
	m_AccentSource		= ACC_NoSource;
	m_BoundarySource	= BND_NoSource;
	m_SilenceSource		= SIL_NoSource;


} /* CFEToken::CFEToken */


/*****************************************************************************
* CFEToken::~CFEToken *
*-----------------------*
*   Description:
*   Destructor for CFEToken
*       
********************************************************************** MC ***/
CFEToken::~CFEToken()
{
    SPDBG_FUNC( "CFEToken::~CFEToken" );

    if( pBMObj != NULL )
    {
        //---------------------------------------
        // Dispose bookmark list
        //---------------------------------------
        delete pBMObj;
    }

} /* CFEToken::~CFEToken */





/*****************************************************************************
* CAlloCell::CAlloCell *
*------------------------*
*   Description:
*   Initializer for CAlloCell
*       
********************************************************************** MC ***/
CAlloCell::CAlloCell()
{
    SPDBG_FUNC( "CAlloCell::CAlloCell" );
    long    i;

    m_allo				= _SIL_;
    m_dur				= 0;
    m_ftDuration		= m_UnitDur = 0;
    m_knots				= KNOTS_PER_PHON;
    m_ctrlFlags			= 0;
    m_user_Rate			= 0;
    m_user_Volume		= DEFAULT_USER_VOL;
    m_user_Pitch		= 0;
    m_user_Emph			= 0;
    m_user_Break		= 0;
    m_Sil_Break			= 0;
    m_Pitch_HI			= 0;
    m_Pitch_LO			= 0;
    m_pBMObj			= NULL;
    m_ToBI_Boundary		= K_NOBND;
    m_ToBI_Accent		= K_NOACC;
	m_TuneBoundaryType	= m_NextTuneBoundaryType = NULL_BOUNDARY;
    m_DurScale			= 1.0;
    m_ProsodyDurScale	= 1.0;
	m_PitchBaseOffs		= 0.0f;
	m_PitchRangeScale	= 1.0f;
    for( i = 0; i < KNOTS_PER_PHON; i++ )
    {
        m_ftTime[i] = 0;
        m_ftPitch[i] = 100;
    }


    m_Accent_Prom	 = 0;                   // prominence prosodic control
    m_Boundary_Prom	 = 0;                 // prominence prosodic control
    m_PitchBufStart	 = 0;
    m_PitchBufEnd	 = 0;
    m_SrcPosition	 = 0;
    m_SrcLen		 = 0;
    m_SentencePosition	 = 0;
    m_SentenceLen		 = 0;

	//--- Diagnostic
	m_AccentSource		= ACC_NoSource;
	m_BoundarySource	= BND_NoSource;
	m_SilenceSource		= SIL_NoSource;
	m_pTextStr			= NULL;

} /* CAlloCell::CAlloCell */


/*****************************************************************************
* CAlloCell::~CAlloCell *
*-----------------------*
*   Description:
*   Destructor for CAlloCell
*       
********************************************************************** MC ***/
CAlloCell::~CAlloCell()
{
    SPDBG_FUNC( "CAlloCell::~CAlloCell" );

    if( m_pBMObj != NULL )
    {
        //---------------------------------------
        // Dispose bookmark list
        //---------------------------------------
        delete m_pBMObj;
    }

    if( m_pTextStr != NULL )
    {
        //---------------------------------------
        // Dispose bookmark list
        //---------------------------------------
        delete m_pTextStr;
    }


} /* CAlloCell::~CAlloCell */

CAlloCell* CAlloCell::operator =( CAlloCell *pNewCell )
{
	if ( pNewCell )
	{
		m_allo						= pNewCell->m_allo;
		m_dur						= pNewCell->m_dur;
		m_ftDuration				= pNewCell->m_ftDuration;
		m_UnitDur					= pNewCell->m_UnitDur;
		m_knots						= pNewCell->m_knots;
		m_ctrlFlags					= pNewCell->m_ctrlFlags;
		m_ToBI_Accent				= pNewCell->m_ToBI_Accent;
		m_Accent_Prom				= pNewCell->m_Accent_Prom;
		m_ToBI_Boundary				= pNewCell->m_ToBI_Boundary;
		m_Boundary_Prom				= pNewCell->m_Boundary_Prom;
		m_PitchBufStart				= pNewCell->m_PitchBufStart;
		m_PitchBufEnd				= pNewCell->m_PitchBufEnd;
		m_user_Volume				= pNewCell->m_user_Volume;
		m_user_Rate					= pNewCell->m_user_Rate;
		m_user_Pitch				= pNewCell->m_user_Pitch;
		m_user_Emph					= pNewCell->m_user_Emph;
		m_user_Break				= pNewCell->m_user_Break;
		m_Sil_Break					= pNewCell->m_Sil_Break;
		m_Pitch_HI					= pNewCell->m_Pitch_HI;
		m_Pitch_LO					= pNewCell->m_Pitch_LO;
		m_SrcPosition				= pNewCell->m_SrcPosition;
		m_SrcLen					= pNewCell->m_SrcLen;
		m_SentencePosition			= pNewCell->m_SentencePosition;
		m_SentenceLen				= pNewCell->m_SentenceLen;
		m_TuneBoundaryType			= pNewCell->m_TuneBoundaryType;
		m_NextTuneBoundaryType		= pNewCell->m_NextTuneBoundaryType;
		m_DurScale					= pNewCell->m_DurScale;
		m_ProsodyDurScale			= pNewCell->m_ProsodyDurScale;
		m_PitchBaseOffs				= pNewCell->m_PitchBaseOffs;
		m_PitchRangeScale			= pNewCell->m_PitchRangeScale;
		m_AccentSource				= pNewCell->m_AccentSource;
		m_BoundarySource			= pNewCell->m_BoundarySource;
		m_SilenceSource				= pNewCell->m_SilenceSource;
        if ( pNewCell->m_pBMObj )
        {
    		m_pBMObj->m_BMList			= pNewCell->m_pBMObj->m_BMList;
        }
		if ( pNewCell->m_pTextStr )
		{
			m_pTextStr = new char[ strlen( pNewCell->m_pTextStr ) + 1 ];
			strcpy( m_pTextStr, pNewCell->m_pTextStr );
		}
		else
		{
			m_pTextStr = NULL;
		}
		memcpy( &pNewCell->m_ftTime, &m_ftTime, KNOTS_PER_PHON * sizeof( float ) );
		memcpy( &pNewCell->m_ftPitch, &m_ftPitch, KNOTS_PER_PHON * sizeof( float ) );
	}
	else
	{
		memset( this, 0, sizeof( this ) );
	}
	return this;
}


/*****************************************************************************
* CAlloList::CAlloList *
*------------------------*
*   Description:
*   Initialize list with 2 silence entries. These will 
*   become the head an tail when real entries are stuffed
*       
********************************************************************** MC ***/
CAlloList::CAlloList()
{
    SPDBG_FUNC( "CAlloList::CAlloList" );
    CAlloCell   *pCell;

    m_cAllos = 0;
	m_ListPos = NULL;
    //------------------------------------
    // Create initial TAIL silence cell
    //------------------------------------
    pCell = new CAlloCell;
    if( pCell )
    {
        m_AlloCellList.AddHead( pCell );
        pCell->m_ctrlFlags |= WORD_START + TERM_BOUND;
        pCell->m_TuneBoundaryType = TAIL_BOUNDARY;
		pCell->m_SilenceSource = SIL_Tail;
        m_cAllos++;
    }
    //------------------------------------
    // Create initial HEAD silence cell
    //------------------------------------
    pCell = new CAlloCell;
    if( pCell )
    {
        m_AlloCellList.AddHead( pCell );
        pCell->m_ctrlFlags |= WORD_START;
		pCell->m_SilenceSource = SIL_Head;
        m_cAllos++;
    }
} /* CAlloList::CAlloList */


                


/*****************************************************************************
* CAlloList::~CAlloList *
*-------------------------*
*   Description:
*   Remove every item in link list.
*       
********************************************************************** MC ***/
CAlloList::~CAlloList()
{
    SPDBG_FUNC( "CAlloList::~CAlloList" );
    CAlloCell   *pCell;

    while( !m_AlloCellList.IsEmpty() )
    {
        pCell = (CAlloCell*)m_AlloCellList.RemoveHead();
        delete pCell;
    }

} /* CAlloList::~CAlloList */





/*****************************************************************************
* CAlloList::GetAllo *
*---------------------*
*   Description:
*   Return pointer of allocell at index
*       
********************************************************************** MC ***/
CAlloCell *CAlloList::GetCell( long index )
{
    SPDBG_FUNC( "CAlloList::GetCell" );

    return (CAlloCell*)m_AlloCellList.GetAt( m_AlloCellList.FindIndex( index ));
} /* CAlloList::GetCell */


/*****************************************************************************
* CAlloList::GetTailCell *
*-------------------------*
*   Description:
*   Return pointer of last allo in link list
*       
********************************************************************** MC ***/
CAlloCell *CAlloList::GetTailCell()
{
    SPDBG_FUNC( "CAlloList::GetTailCell" );

    return (CAlloCell*)m_AlloCellList.GetTail();
} /* CAlloList::GetTailCell */


/*****************************************************************************
* CAlloList::GetTailCell *
*-----------------------*
*   Description:
*   Return allo list size
*       
********************************************************************** MC ***/
long CAlloList::GetCount()
{
    SPDBG_FUNC( "CAlloList::GetCount" );

    return m_AlloCellList.GetCount();
} /* CAlloList::GetCount */





/*****************************************************************************
* PrintPhon *
*-----------*
*   Description:
*   Print 2-char allo name
*       
********************************************************************** MC ***/
void PrintPhon( ALLO_CODE allo, char * /*msgStr*/)
{
    SPDBG_FUNC( "PrintPhon" );

    unsigned short  nChar;
    
    nChar = g_Opcode_To_ASCII[allo];
    if( nChar >> 8 )
    {
        SPDBG_DMSG1( "%c", nChar >> 8 );
    }
    if( nChar && 0xFF )
    {
        SPDBG_DMSG1( "%c", nChar & 0xFF );
    }
} /* PrintPhon */




/*****************************************************************************
* CAlloList::OutAllos *
*--------------------*
*   Description:
*   Dump ALLO_CELL contents
*       
********************************************************************** MC ***/
void CAlloList::OutAllos()
{
    SPDBG_FUNC( "CAlloOps::OutAllos" );
    CAlloCell       *pCurCell;

    long    i, flags, flagsT;
    char    msgStr[400];
    
    for( i = 0; i < m_cAllos; i++ )
    {
        pCurCell = GetCell( i );
        flags = pCurCell->m_ctrlFlags;
        
        if( flags & WORD_START)
        {
            SPDBG_DMSG0( "\n" );
        }
        
        //----------------------------
        // Allo
        //----------------------------
        PrintPhon( pCurCell->m_allo, msgStr );
        
        //----------------------------
        // Duration
        //----------------------------
        SPDBG_DMSG1( "\t%.3f\t", pCurCell->m_ftDuration );
        
        //----------------------------
        // Boundry
        //----------------------------
        if( flags & BOUNDARY_TYPE_FIELD)
        {
            SPDBG_DMSG0( "(" );
            if( flags & WORD_START)
            {
                SPDBG_DMSG0( "-wS" );
            }
            if( flags & TERM_BOUND)
            {
                SPDBG_DMSG0( "-tB" );
            }
            SPDBG_DMSG0( ")\t" );
        }
        
        //----------------------------
        // Syllable type
        //----------------------------
        if( flags & SYLLABLE_TYPE_FIELD)
        {
            SPDBG_DMSG0( "(" );
            if( flags & WORD_END_SYLL)
            {
                SPDBG_DMSG0( "-wE" );
            }
            if( flags & TERM_END_SYLL)
            {
                SPDBG_DMSG0( "-tE" );
            }
            SPDBG_DMSG0( ")\t" );
        }
        
        //----------------------------
        // Syllable order
        //----------------------------
        if( flags & SYLLABLE_ORDER_FIELD)
        {
            SPDBG_DMSG0( "(" );
            
            flagsT = flags & SYLLABLE_ORDER_FIELD;
            if( flagsT == FIRST_SYLLABLE_IN_WORD)
            {
                SPDBG_DMSG0( "-Fs" );
            }
            else if( flagsT == MID_SYLLABLE_IN_WORD)
            {
                SPDBG_DMSG0( "-Ms" );
            }
            else if( flagsT == LAST_SYLLABLE_IN_WORD)
            {
                SPDBG_DMSG0( "-Ls" );
            }
            SPDBG_DMSG0( ")\t" );
        }
        
        //----------------------------
        // Stress
        //----------------------------
        if( flags & PRIMARY_STRESS)
        {
            SPDBG_DMSG0( "-Stress\t" );
        }
        
        //----------------------------
        // Word initial consonant
        //----------------------------
        if( flags & WORD_INITIAL_CONSONANT)
        {
            SPDBG_DMSG0( "-InitialK\t" );
        }
        
        //----------------------------
        // Syllable start
        //----------------------------
        if( flags & SYLLABLE_START)
        {
            SPDBG_DMSG0( "-Syll\t" );
        }
        
        SPDBG_DMSG0( "\n" );
        }
} /* CAlloList::OutAllos */




/*****************************************************************************
* CAlloList::WordToAllo *
*-----------------------*
*   Description:
*   Copy word token to AlloCells
*   Insert allos BEFORE 'pEndCell'
*       
********************************************************************** MC ***/
bool CAlloList::WordToAllo( CFEToken *pPrevTok, CFEToken *pTok, CFEToken *pNextTok, CAlloCell *pEndCell )
{
    SPDBG_FUNC( "CAlloList::WordToAllo" );

    long    i;
    long    startLatch;
    CAlloCell   *pCurCell;
    long    firstVowel, lastVoiced;
    bool    gotAccent, isStressed;
	bool	hasSpeech;
    
    //-----------------------------------------
    // First, find ToBI accent locations
    //-----------------------------------------
    firstVowel  = lastVoiced = (-1);
    gotAccent   = false;
	hasSpeech	= false;
    for( i = 0; i < pTok->phon_Len; i++ )
    {
        isStressed = false;
        if( pTok->phon_Str[i] < _STRESS1_ )
        {
            //----------------------------
            // Potential ToBI accent
            //----------------------------
            if( (!gotAccent) && (g_AlloFlags[pTok->phon_Str[i]] & KVOWELF) )
            {
                if( (i < (pTok->phon_Len -1)) && (pTok->phon_Str[i+1] == _STRESS1_) )
                {
                    //-------------------------------------
                    // Put accent at 1st stressed vowel
                    //-------------------------------------
                    firstVowel = i;
                    gotAccent = true;
                }
                else if( firstVowel < 0 )
                {
                    //-------------------------------------
                    // In case there's no stressed vowel 
                    // in this word, use 1st vowel
                    //-------------------------------------
                    firstVowel = i;
                }
            }
            //----------------------------
            // Potential ToBI boundary
            //----------------------------
            if( g_AlloFlags[pTok->phon_Str[i]] & KVOICEDF )
            {
                lastVoiced = i;
            }
        }
    }
    //-----------------------------------------
    // Now, copy data to allo list
    //-----------------------------------------
    startLatch  = true;
    for( i = 0; i < pTok->phon_Len; i++ )
    {
        if( pTok->phon_Str[i] < _STRESS1_ )
        {
			if( (pTok->phon_Str[i] == _SIL_) && (pTok->m_TuneBoundaryType >= SUB_BOUNDARY_1) )
			{
				//----------------------------------------------------------------
				// Before skipping this, propagate the dur scale gain
				//----------------------------------------------------------------
				if( pTok->m_DurScale == 0 )
				{
					if( pPrevTok )
					{
						pTok->m_DurScale = pPrevTok->m_DurScale;
					}
					else
					{
						pTok->m_DurScale = 1.0;
					}
				}
				continue;
			}
            //------------------------------------
            // Create new cell
            //------------------------------------
            pCurCell = new CAlloCell;
            if( pCurCell )
            {
                m_AlloCellList.InsertBefore( m_AlloCellList.Find(pEndCell), pCurCell);
                m_cAllos++;

                //----------------------------
                // Copy only phons
                //----------------------------
                pCurCell->m_allo = (ALLO_CODE) pTok->phon_Str[i];
                //---------------------------------------------
                // See if this allo will generate speech
                //---------------------------------------------
				if( (pCurCell->m_allo >= _IY_) &&
					(pCurCell->m_allo <= _DX_) &&
					(pCurCell->m_allo != _SIL_) )
				{
					hasSpeech = true;
				}

                //----------------------------
                // Save src position
                //----------------------------
                pCurCell->m_SrcPosition = pTok->srcPosition;
                pCurCell->m_SrcLen = pTok->srcLen;
                pCurCell->m_SentencePosition = pTok->sentencePosition;
                pCurCell->m_SentenceLen = pTok->sentenceLen;

                //----------------------------
                // Flag WORD START?
                //----------------------------
                if( startLatch )
                {
                    pCurCell->m_ctrlFlags |= WORD_START;
                    startLatch = false;
                }

                //----------------------------
                // Is next allo a STRESS?
                //----------------------------
                if( i < (pTok->phon_Len -1) )
                {
                    if( pTok->phon_Str[i+1] == _STRESS1_ )
                    {
                        pCurCell->m_ctrlFlags |= PRIMARY_STRESS;
                    }
					else
					{
						//----------------------------------------------
						// Voice inventory does not have unstressed
						// entries for these diphongs
						//----------------------------------------------
						if( (pCurCell->m_allo == _AW_) ||
							(pCurCell->m_allo == _AY_) ||
							(pCurCell->m_allo == _EY_) ||
							(pCurCell->m_allo == _OY_) )
						{
							pCurCell->m_ctrlFlags |= PRIMARY_STRESS;
						}
					}
                }

				//---------------------------
				// Diagnostic
				//---------------------------
				if( pCurCell->m_allo == _SIL_ )
				{
					pCurCell->m_SilenceSource = pTok->m_SilenceSource;
				}
                //----------------------------
                // Place ToBI accent
                //----------------------------
                if( i == firstVowel )
                {
                    pCurCell->m_ToBI_Accent = pTok->m_Accent;
					//---------------------------
					// Diagnostic
					//---------------------------
					pCurCell->m_AccentSource = pTok->m_AccentSource;
					pCurCell->m_pTextStr = new char[pTok->tokLen+1];
					if( pCurCell->m_pTextStr )
					{
						WideCharToMultiByte (	CP_ACP, 0, 
												pTok->tokStr, -1, 
												pCurCell->m_pTextStr, pTok->tokLen+1, 
												NULL, NULL);
					}
                }
                pCurCell->m_Accent_Prom = pTok->m_Accent_Prom;
                //----------------------------
                // Place ToBI boundary
                //----------------------------
                if( i == lastVoiced )
                {
                    pCurCell->m_ToBI_Boundary = pTok->m_Boundary;
					//---------------------------
					// Diagnostic
					//---------------------------
					pCurCell->m_BoundarySource = pTok->m_BoundarySource;
                }
                pCurCell->m_Boundary_Prom = pTok->m_Boundary_Prom;

                //----------------------------
                // User Controls
                //----------------------------
                pCurCell->m_user_Volume = pTok->user_Volume;
                pCurCell->m_user_Rate = pTok->user_Rate;
                pCurCell->m_user_Pitch = pTok->user_Pitch;
				pCurCell->m_user_Emph = 0;
				if( pTok->user_Emph > 0 )
				{
					if( i == firstVowel )
					{
						pCurCell->m_user_Emph = pTok->user_Emph;
						pCurCell->m_ctrlFlags |= PRIMARY_STRESS;
					}
				}
                pCurCell->m_user_Break = pTok->user_Break;
                pCurCell->m_pBMObj = pTok->pBMObj;
                pTok->pBMObj = NULL;

				//-----------------------------------------------
				// If token's m_DurScale is not defined,
				//  try to use prev token's ratio
				//-----------------------------------------------
				if( pTok->m_DurScale == 0 )
				{
					if( pPrevTok )
					{
						pCurCell->m_DurScale = pPrevTok->m_DurScale;
					}
					else
					{
						pCurCell->m_DurScale = 1.0;
					}
					//-------------------------------------------------------
					// Write back in case next token is also undefined
					//-------------------------------------------------------
					pTok->m_DurScale = pCurCell->m_DurScale;
				}
				else
				{
					pCurCell->m_DurScale = pTok->m_DurScale;
				}
				pCurCell->m_ProsodyDurScale = pTok->m_ProsodyDurScale;

				if( pNextTok )
				{
					pCurCell->m_NextTuneBoundaryType = pNextTok->m_TuneBoundaryType;
				}
				else
				{
					pCurCell->m_NextTuneBoundaryType = NULL_BOUNDARY;
				}
				pCurCell->m_PitchBaseOffs = pTok->m_PitchBaseOffs;
				pCurCell->m_PitchRangeScale = pTok->m_PitchRangeScale;

                //----------------------------------------------
                // Is this a term word?
                //----------------------------------------------
                pCurCell->m_TuneBoundaryType = pTok->m_TuneBoundaryType;
                if( pTok->m_TuneBoundaryType != NULL_BOUNDARY )
                {
                    pCurCell->m_ctrlFlags |= TERM_BOUND + WORD_START;
                }
            }
        }

    }
	//----------------------------------------
	// Insert word pause?
	//----------------------------------------
	if( pTok->m_TermSil > 0 )
	{
        pCurCell = new CAlloCell;
        if( pCurCell )
        {
            m_AlloCellList.InsertBefore( m_AlloCellList.Find(pEndCell), pCurCell);
            m_cAllos++;

            //----------------------------
            // Add silence
            //----------------------------
            pCurCell->m_allo = _SIL_;

            //----------------------------
            // Save src position
            //----------------------------
            pCurCell->m_SrcPosition = pTok->srcPosition;
            pCurCell->m_SrcLen = pTok->srcLen;
            pCurCell->m_SentencePosition = pTok->sentencePosition;
            pCurCell->m_SentenceLen = pTok->sentenceLen;
            //----------------------------
            // User Controls
            //----------------------------
            pCurCell->m_user_Volume = pTok->user_Volume;
            pCurCell->m_user_Rate = pTok->user_Rate;
            pCurCell->m_user_Pitch = pTok->user_Pitch;
            pCurCell->m_user_Emph = pTok->user_Emph;
            pCurCell->m_user_Break = pTok->user_Break;
            pCurCell->m_pBMObj = NULL;
            pCurCell->m_TuneBoundaryType = pTok->m_TuneBoundaryType;
            pCurCell->m_Boundary_Prom = pTok->m_Boundary_Prom;
            pCurCell->m_Accent_Prom = pTok->m_Accent_Prom;
			pCurCell->m_ctrlFlags = 0;
			pCurCell->m_UnitDur = pTok->m_TermSil;
            pCurCell->m_Sil_Break = (unsigned long)(pCurCell->m_UnitDur * 1000);	// sec -> ms
			pCurCell->m_user_Break = 0;
			pCurCell->m_DurScale = pTok->m_DurScale;
			pCurCell->m_ProsodyDurScale = 1.0f;
		}
	}

	return hasSpeech;
} /* CAlloList::WordToAllo */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\alloops.h ===
/******************************************************************************
* AlloOps.h *
*-----------*
*  This is the header file for the following clsses:
*		CAlloCell
*		CAlloList
*		CDuration
*		CSyllableTagger
*		CToneTargets
*		CPitchProsody

  *------------------------------------------------------------------------------
  *  Copyright (C) 1999 Microsoft Corporation		  Date: 03/01/99
  *  All Rights Reserved
  *
*********************************************************************** MC ****/

#ifndef AlloOps_H
#define AlloOps_H

#include "stdafx.h"
#include "commonlx.h"

#include "ms_entropicengine.h"
#include "FeedChain.h"
#include <SPCollec.h>
#include "SpTtsEngDebug.h"

//***************************
// Allophones
//***************************
typedef enum
{	
    _IY_,	_IH_,	_EH_,	_AE_,	_AA_,	_AH_,	_AO_,	_UH_,	_AX_,	_ER_,
    _EY_,	_AY_,	_OY_,	_AW_,	_OW_,	_UW_, 
    _IX_,	_SIL_,	_w_,	_y_,
    _r_,	_l_,	_h_,	_m_,	_n_,	_NG_,	_f_,	_v_,	_TH_,	_DH_,
    _s_,	_z_,	_SH_,	_ZH_,	_p_,	_b_,	_t_,	_d_,	_k_,	_g_,
    _CH_,	_JH_,	_DX_,	 
	_STRESS1_,
    _STRESS2_,
    _EMPHSTRESS_,
    _SYLLABLE_,
} ALLO_CODE;

static const long NUMBER_OF_ALLO = (_SYLLABLE_ + 1);

//-----------------------------------
// For 2-word allo conversion
//-----------------------------------
static const short NO_IPA = 0;



// XXXX XXXX XXXX XXXX XXXX bLis ssoo ttBB

// X = unused
// B = boundary type
// t = syllable type
// o = vowel order
// s = stress type
// i = word initial consonant
// L = syLlable start
// b = break

enum ALLOTAGS
{	
    WORD_START			= (1 << 0),
        TERM_BOUND			= (1 << 1),
        BOUNDARY_TYPE_FIELD = WORD_START | TERM_BOUND,			// mask
        
        WORD_END_SYLL		= (1 << 2),
        TERM_END_SYLL		= (1 << 3),
        SYLLABLE_TYPE_FIELD = WORD_END_SYLL | TERM_END_SYLL,	// mask
        
        FIRST_SYLLABLE_IN_WORD			= (1 << 4),  // in multi-syllable word
        MID_SYLLABLE_IN_WORD			= (2 << 4),
        LAST_SYLLABLE_IN_WORD			= (3 << 4),
        MORE_THAN_ONE_SYLLABLE_IN_WORD	= LAST_SYLLABLE_IN_WORD,  // either bit is set
        ONE_OR_NO_SYLLABLE_IN_WORD		= 0x0000,  // niether bits are set
        SYLLABLE_ORDER_FIELD			= LAST_SYLLABLE_IN_WORD,  // mask
        
        PRIMARY_STRESS		= (1 << 6),
        SECONDARY_STRESS	= (1 << 7),
        EMPHATIC_STRESS 	= (1 << 8),
        IS_STRESSED 		= PRIMARY_STRESS | SECONDARY_STRESS | EMPHATIC_STRESS,
        PRIM_OR_EMPH_STRESS = PRIMARY_STRESS | EMPHATIC_STRESS,
        STRESS_FIELD		= PRIMARY_STRESS | SECONDARY_STRESS | EMPHATIC_STRESS,	// mask
        
        WORD_INITIAL_CONSONANT	= (1 << 9), 		 // up to 1st vowel in word
        STRESSED_INITIAL_CONS	= (IS_STRESSED + WORD_INITIAL_CONSONANT),
        SYLLABLE_START			= (1 << 10),
        
        SIL_BREAK			= (1 << 11),
};


//***************************
// AlloFlags
//***************************
enum ALLOFLAGS
{	
    KVOWELF = (1<<0),
        KCONSONANTF = (1<<1),
        KVOICEDF = (1<<2),
        KVOWEL1F = (1<<3),
        KSONORANTF = (1<<4),
        KSONORANT1F = (1<<5),
        KNASALF = (1<<6),
        KLIQGLIDEF = (1<<7),
        KSONORCONSONF = (1<<8),
        KPLOSIVEF = (1<<9),
        KPLOSFRICF = (1<<10),
        KOBSTF = (1<<11),
        KSTOPF = (1<<12),
        KALVEOLARF = (1<<13),
        KVELAR = (1<<14),
        KLABIALF = (1<<15),
        KDENTALF = (1<<16),
        KPALATALF = (1<<17),
        KYGLIDESTARTF = (1<<18),
        KYGLIDEENDF = (1<<19),
        KGSTOPF = (1<<20),
        KFRONTF = (1<<21),
        KDIPHTHONGF = (1<<22),
        KHASRELEASEF = (1<<23),
        KAFFRICATEF = (1<<24),
        KLIQGLIDE2F = (1<<25),
        KVOCLIQ = (1<<26),
        KFRIC = (1<<27),
        
        KFLAGMASK1 = (KLABIALF+KDENTALF+KPALATALF+KALVEOLARF+KVELAR+KGSTOPF),
        KFLAGMASK2 = (KALVEOLARF-1),
};


#define BOUNDARY_BASE   1000
enum TOBI_BOUNDARY
{
    K_NOBND = 0,
    K_LMINUS = BOUNDARY_BASE,   // fall
    K_HMINUS,                   // none
    K_LMINUSLPERC,
    K_LMINUSHPERC,
    K_HMINUSHPERC,
    K_HMINUSLPERC,
};




enum TUNE_TYPE
{
    NULL_BOUNDARY = 0,  // no boundary NOTE: always put this at the beginning
    PHRASE_BOUNDARY,    // comma
    EXCLAM_BOUNDARY,    // exclamatory utterance terminator
    YN_QUEST_BOUNDARY,     // yes-no question terminator
    WH_QUEST_BOUNDARY,     // yes-no question terminator
    DECLAR_BOUNDARY,    // declarative terminator
    PAREN_L_BOUNDARY,   // left paren
    PAREN_R_BOUNDARY,   // right paren
    QUOTE_L_BOUNDARY,   // left quote
    QUOTE_R_BOUNDARY,   // right quote
	PHONE_BOUNDARY,
	TOD_BOUNDARY,
	ELLIPSIS_BOUNDARY,

    SUB_BOUNDARY_1,     // NOTE: always put these at the end
    SUB_BOUNDARY_2,
    SUB_BOUNDARY_3,
    SUB_BOUNDARY_4,
    SUB_BOUNDARY_5,
    SUB_BOUNDARY_6,
	NUMBER_BOUNDARY,

	TAIL_BOUNDARY,
};


//***************************
// ToBI Constants
//***************************
// !H is removed from consideration in the first pass processing
// !H can possibly be recovered from analysis of the labeling and
// contour at later stages (tilt, prominence, pitch range, downstep)
#define ACCENT_BASE   1
enum TOBI_ACCENT
{
    K_NOACC = 0,
    K_HSTAR = ACCENT_BASE,  // peak                         rise / fall
    K_LSTAR,                // acc syll nucleus valley      early fall
    K_LSTARH,               // late rise
    K_RSTAR,                //
    K_LHSTAR,               // early rise
    K_DHSTAR,               // 
	K_HSTARLSTAR,
};



enum BOUNDARY_SOURCE
{
    BND_NoSource = 0,

	//-- Phrase boundary rules
	BND_PhraseRule1,
	BND_PhraseRule2,
	BND_PhraseRule3,
	BND_PhraseRule4,
	BND_PhraseRule5,
	BND_PhraseRule6,
	BND_PhraseRule7,
	BND_PhraseRule8,
	BND_PhraseRule9,
	BND_PhraseRule10,
	BND_PhraseRule11,
	BND_PhraseRule12,
	BND_PhraseRule13,

	//-- ToBI
	BND_YNQuest,
	BND_WHQuest,
	BND_Period,
	BND_Comma,

	//--Templates
	BND_NumberTemplate,		// Should never get this!
	BND_IntegerQuant,
	BND_Currency_DOLLAR,
	BND_Frac_Num,

	BND_Phone_COUNTRY,
	BND_Phone_AREA,
	BND_Phone_ONE,
	BND_Phone_DIGITS,

	BND_TimeOFDay_HR,
	BND_TimeOFDay_AB,
	BND_Ellipsis,

	BND_ForcedTerm,			// Should never get this!

    BND_IDontKnow,
};

enum ACCENT_SOURCE
{
    ACC_NoSource = 0,

	//-- Phrase boundary rules
	ACC_PhraseRule1,
	ACC_PhraseRule2,
	ACC_PhraseRule3,
	ACC_PhraseRule4,
	ACC_PhraseRule5,
	ACC_PhraseRule6,
	ACC_PhraseRule7,
	ACC_PhraseRule8,
	ACC_PhraseRule9,
	ACC_PhraseRule10,
	ACC_PhraseRule11,
	ACC_PhraseRule12,
	ACC_PhraseRule13,

	//-- ToBI
	ACC_InitialVAux,
	ACC_FunctionSeq,
	ACC_ContentSeq,
	ACC_YNQuest,
	ACC_Period,
	ACC_Comma,

	//--Templates
	ACC_IntegerGroup,
	ACC_NumByNum,
	ACC_Frac_DEN,		// "half", "tenths", etc.
	ACC_Phone_1stArea,	// 1st digit in area code
	ACC_Phone_3rdArea,	// 3rd digit in area code
	ACC_Phone_1st3,		
	ACC_Phone_3rd3,		
	ACC_Phone_1st4,
	ACC_Phone_3rd4,
	ACC_TimeOFDay_HR,
	ACC_TimeOFDay_1stMin,
	ACC_TimeOFDay_M,

	ACC_PhoneBnd_AREA,
	ACC_PhoneBnd_34,
	ACC_PhoneBnd_4,

	ACC_IDontKnow,
};



enum SILENCE_SOURCE
{
    SIL_NoSource = 0,

	SIL_Term,
	SIL_QuoteStart,
	SIL_QuoteEnd,
	SIL_ParenStart,
	SIL_ParenEnd,
	SIL_Emph,
	SIL_SubBound,		// Should never see this (gets removed)
	SIL_XML,

	//-- Prosody templates
	SIL_TimeOfDay_HR,
	SIL_TimeOfDay_AB,

	SIL_Phone_COUNTRY,
	SIL_Phone_AREA,
	SIL_Phone_ONE,
	SIL_Phone_DIGITS,

	SIL_Fractions_NUM,
	SIL_Currency_DOLLAR,
	SIL_Integer_Quant,

	SIL_Head,
	SIL_Tail,
	SIL_Ellipsis,

	SIL_ForcedTerm,			// Should never get this!
};




static const short TOKEN_LEN_MAX	= 20;

class CFEToken
{
public:
    CFEToken();
    ~CFEToken();
    
    WCHAR           tokStr[TOKEN_LEN_MAX];
    long            tokLen;
    PRONSRC 		m_PronType;

    long            phon_Len;
    ALLO_CODE       phon_Str[SP_MAX_PRON_LENGTH];		// Allo string
    ENGPARTOFSPEECH	POScode;
    PROSODY_POS     m_posClass;

    ULONG           srcPosition;					// Source position for this token
    ULONG           srcLen; 						// Source length for this token
    ULONG           sentencePosition;				// Source position for sentence
    ULONG           sentenceLen; 					// Source length for sentence
    ULONG           user_Volume;					// 1 - 101
    long            user_Rate;						// -10 - 10
    long            user_Pitch; 					// -10 - 10
    long            user_Emph;						// 0 or 5
    ULONG           user_Break; 					// ms of silence
    CBookmarkList   *pBMObj;
    TOBI_ACCENT     m_Accent;                        // accent prosodic control
    long            m_Accent_Prom;                   // prominence prosodic control
    TOBI_BOUNDARY   m_Boundary;                        // boundary tone prosodic control
    long            m_Boundary_Prom;                   // prominence prosodic control
    TUNE_TYPE       m_TuneBoundaryType;             // Current token is a boundary
	float			m_TermSil;						// Pad word with silence (in sec)
    float           m_DurScale;						// Duration ratio
	float			m_ProsodyDurScale;
	float			m_PitchBaseOffs;				// Relative baseline pitch offset in octaves
	float			m_PitchRangeScale;				// Pitch range offset scale (0 - 2.0) 

	//--- Diagnostic
	ACCENT_SOURCE		m_AccentSource;		
	BOUNDARY_SOURCE		m_BoundarySource;
	SILENCE_SOURCE		m_SilenceSource;
};
typedef CSPList<CFEToken*,CFEToken*> CFETokenList;



class CAlloCell
{
public:
    CAlloCell();
    ~CAlloCell();

	CAlloCell* operator =( CAlloCell *pNewCell );
    //--------------------------------
    // Member Vars
    //--------------------------------
    ALLO_CODE	m_allo;
    short		m_dur;
    float		m_ftDuration;
    float       m_UnitDur;
    short		m_knots;
    float		m_ftTime[KNOTS_PER_PHON];
    float		m_ftPitch[KNOTS_PER_PHON];
    long		m_ctrlFlags;
    TOBI_ACCENT m_ToBI_Accent;
    long        m_Accent_Prom;                   // prominence prosodic control
    TOBI_BOUNDARY   m_ToBI_Boundary;
    long        m_Boundary_Prom;                 // prominence prosodic control
    long        m_PitchBufStart;
    long        m_PitchBufEnd;
    ULONG		m_user_Volume;
    long		m_user_Rate;
    long		m_user_Pitch;
    long		m_user_Emph;
    ULONG		m_user_Break;
    ULONG       m_Sil_Break;
    float		m_Pitch_HI;
    float		m_Pitch_LO;
    ULONG		m_SrcPosition;
    ULONG		m_SrcLen;
    ULONG       m_SentencePosition;				// Source position for sentence
    ULONG       m_SentenceLen; 					// Source length for sentence
    TUNE_TYPE   m_TuneBoundaryType;
    TUNE_TYPE   m_NextTuneBoundaryType;
    CBookmarkList	*m_pBMObj;
    float       m_DurScale;						// Duration ratio
	float		m_ProsodyDurScale;
	float		m_PitchBaseOffs;				// Relative baseline pitch offset in octaves
	float		m_PitchRangeScale;				// Pitch range offset scale (0 - 2.0) 

	//--- Diagnostic
	ACCENT_SOURCE		m_AccentSource;		
	BOUNDARY_SOURCE		m_BoundarySource;
	SILENCE_SOURCE		m_SilenceSource;
	char				*m_pTextStr;
};





class CAlloList
{
public:
    CAlloList();
    ~CAlloList();
    //--------------------------------
    // Methods
    //--------------------------------
    CAlloCell *GetCell( long index );
    CAlloCell *GetTailCell();
    long GetCount();
    bool WordToAllo( CFEToken *pPrevTok, CFEToken *pTok, CFEToken *pNextTok, CAlloCell *pEndCell );
	CAlloCell *GetHeadCell()
	{
		m_ListPos = m_AlloCellList.GetHeadPosition();
		return m_AlloCellList.GetNext( m_ListPos );
	}
	CAlloCell *GetNextCell()
	{
		if( m_ListPos )
		{
			return m_AlloCellList.GetNext( m_ListPos );
		}
		else
		{
			//-- We're at end of list!
			return NULL;
		}
	}
	//-- For debug only
    void OutAllos();

private:
    //--------------------------------
    // Member Vars
    //--------------------------------
    long		m_cAllos;
	SPLISTPOS	m_ListPos;
    CSPList<CAlloCell*,CAlloCell*> m_AlloCellList;
};



//-----------------------------------
// Speaking Rate parameters
//-----------------------------------
static const float MAX_SIL_DUR = 1.0f; 			// seconds
static const float MIN_ALLO_DUR = 0.011f;		// seconds
static const float MAX_ALLO_DUR = 5.0f;		// seconds


class CDuration
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    void AlloDuration( CAlloList *pAllos, float rateRatio );
    
private:
    void Pause_Insertion( long userDuration, long silBreak );
    void PhraseFinal_Lengthen( long cellCount );
    long Emphatic_Lenghen( long lastStress );
    //--------------------------------
    // Member vars
    //--------------------------------
    float   m_DurHold;
	float	m_TotalDurScale;
	float	m_durationPad;
    
    ALLO_CODE	m_cur_Phon;
    long		m_cur_PhonCtrl;
    long		m_cur_PhonFlags;
    long		m_cur_SyllableType;
    short		m_cur_VowelFlag;
    long		m_cur_Stress;
    ALLO_CODE	m_prev_Phon;
    long		m_prev_PhonCtrl;
    long		m_prev_PhonFlags;
    ALLO_CODE	m_next_Phon;
    long		m_next_PhonCtrl;
    long		m_next_PhonFlags;
    ALLO_CODE	m_next2_Phon;
    long		m_next2_PhonCtrl;
    long		m_next2_PhonFlags;
    TUNE_TYPE   m_NextBoundary, m_CurBoundary;
};






typedef struct
{ 
    ALLO_CODE	allo;
    long		ctrlFlags;
}ALLO_ARRAY;




class CSyllableTagger
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    void TagSyllables( CAlloList *pAllos );
    
private:
    void MarkSyllableOrder( long scanIndex);
    void MarkSyllableBoundry( long scanIndex);
    void MarkSyllableStart();
    short Find_Next_Word_Bound( short index );
    short If_Consonant_Cluster( ALLO_CODE Consonant_1st, ALLO_CODE Consonant_2nd);
	void ListToArray( CAlloList *pAllos );
	void ArrayToList( CAlloList *pAllos );
    
    //--------------------------------
    // Member vars
    //--------------------------------
    ALLO_ARRAY	*m_pAllos;
    long		m_numOfCells;
};


enum { TARG_PER_ALLO_MAX = 2 }; // One for accent and one for boundary



enum TUNE_STYLE
{
    FLAT_TUNE = 0,      // flat
    DESCEND_TUNE,       // go down
    ASCEND_TUNE,        // go up
};

//------------------
// Global Constants
//------------------
static const float PITCH_BUF_RES = (float)0.005;
static const float K_HSTAR_OFFSET = (float)0.5;
static const float K_HDOWNSTEP_COEFF  = (float)0.5;


//------------------
// Macros
//------------------
#define CeilVal(x) ((m_CeilSlope * x) + m_CeilStart)
#define FloorVal(x) ((m_FloorSlope * x) + m_FloorStart)
#define RefVal(x) ((m_RefSlope * x) + m_RefStart)



class CPitchProsody
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    CPitchProsody() { m_pContBuf = NULL; };
    ~CPitchProsody() { if ( m_pContBuf ) delete m_pContBuf; };
    void AlloPitch( CAlloList *pAllos, int baseLine, int pitchRange );
    void GetContour( float**, ULONG* );
    
private:
    float DoPitchControl( long pitchControl, float basePitch );
    void PitchTrack();
    void SetDefaultPitch();
    void GetKnots();
    void NewTarget( long index, float value );

    //--------------------------------
    // Member vars
    //--------------------------------
    CAlloList		*m_pAllos;
    long			m_numOfCells;

    float           m_TotalDur;     // phrase duration in seconds
    TUNE_STYLE      m_Tune_Style;
    float           *m_pContBuf;
    ULONG           m_ulNumPoints;
    float           m_OffsTime;
    TOBI_ACCENT     m_CurAccent;

	//------------------------
	// Diagnostic
	//------------------------
	ACCENT_SOURCE		m_CurAccentSource;		
	BOUNDARY_SOURCE		m_CurBoundarySource;
	char				*m_pCurTextStr;
};



#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\feedchain.h ===
/******************************************************************************
* FeedChain.h *
*-------------*
*  This is the header file for the CFeedChain implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

#ifndef FeedChain_H
#define FeedChain_H

#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef SPCollec_h
#include <SPCollec.h>
#endif



// Maximum posody breakpoints for each phon
typedef enum KNOTSLEN
{
    KNOTS_PER_PHON  = 20
}KNOTSLEN;



//-----------------------------------------------------
// This is the unit data the BE gets fron the FE
//-----------------------------------------------------
typedef struct UNITINFO
{
    ULONG       UnitID;         // Inventory table ID
    float       duration;       // Duration in seconds
    float       amp;			// Abs amplitude
    float       ampRatio;       // Amplitude gain
    ULONG       nKnots;         // Number of prosody breakpoints
    float       pTime[KNOTS_PER_PHON];  // Breakpoint length
    float       pF0[KNOTS_PER_PHON];    // Pitch breakpoint
    float       pAmp[KNOTS_PER_PHON];   // Amplitude gain breakpoint
    ULONG       PhonID;         // Phoneme ID
	ULONG		SenoneID;		// Context offset from PhonID
	USHORT		AlloID;
	USHORT		NextAlloID;
	USHORT		AlloFeatures;	// for viseme
    ULONG	    flags;          // Misc flags
    ULONG       csamplesOut;    // Number of rendered samples
	float		speechRate;

    //-- Event data
    ULONG       srcPosition;    // Position for WORD events
    ULONG       srcLen;         // Length for WORD events
    ULONG       sentencePosition;    // Position for SENTENCE events
    ULONG       sentenceLen;         // Length for SENTENCE events
    void        *pBMObj;        // Ptr to bookmark list

    //-- Control data
    ULONG       user_Volume;    // Output volume level
	bool		hasSpeech;
    
	//-- Debug output
	enum SILENCE_SOURCE		silenceSource;
    CHAR        szUnitName[15];
	long		ctrlFlags;
    /*long        cur_TIME;
    long        decompress_TIME;
    long        prosody_TIME;
    long        stretch_TIME;
    long        lpc_TIME;*/
} UNITINFO;



//-------------------------------------------------
// Since bookmarks can be stacked, we need to 
// save each individually into a list
//-------------------------------------------------
typedef struct 
{
    LPARAM  pBMItem;      // Ptr to text data
} BOOKMARK_ITEM;


class CBookmarkList
{
public:
    //----------------------------------------
    // Needs destructor to dealloc 
    // 'BOOKMARK_ITEM' memory
    //----------------------------------------
    ~CBookmarkList();

    //----------------------------------------
    // Linked list bookmark items
    //----------------------------------------
    CSPList<BOOKMARK_ITEM*, BOOKMARK_ITEM*> m_BMList;
};

//---------------------------------------------------
// Speech states
//---------------------------------------------------
enum SPEECH_STATE
{   
    SPEECH_CONTINUE,
    SPEECH_DONE
};



class CFeedChain
{
public:
    
    virtual HRESULT NextData( void **pData, SPEECH_STATE *pSpeechState ) = 0;
};



#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\makefile.inc ===
SelfRegister :
!if defined(MAKEDLL)
	regsvr32 /s $(O)\$(TARGETNAME).dll
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( spttseng )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( spttseng ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\duration.cpp ===
/******************************************************************************
* Duration.cpp *
*--------------*
*
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 04/28/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

//--- Additional includes
#include "stdafx.h"

#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif



//-----------------------------
// Data.cpp
//-----------------------------
extern const unsigned long    g_AlloFlags[];
extern const float  g_BoundryDurTbl[];
extern const float  g_BoundryStretchTbl[];





/*****************************************************************************
* CDuration::Pause_Insertion *
*----------------------------*
*   Description:
*   Duration Rule #1 - Pause Insertion
*       
********************************************************************** MC ***/
void CDuration::Pause_Insertion( long userDuration, long silBreak )
{
    SPDBG_FUNC( "CDuration::Pause_Insertion" );

    if( userDuration )
    {
        m_DurHold = ((float)userDuration / 1000);
        m_TotalDurScale = 1.0;
    }
    else if( silBreak )
    {
        m_DurHold = ((float)silBreak / 1000);
    }
    else
    {
        if( m_CurBoundary != NULL_BOUNDARY)
        {
            m_DurHold = g_BoundryDurTbl[(long)m_CurBoundary];
			//m_DurHold *= m_TotalDurScale;

			//----------------------------
			// Clip to limits
			//----------------------------
			if( m_DurHold > MAX_SIL_DUR )
			{
				m_DurHold = MAX_SIL_DUR;
			}
			/*else if( m_DurHold < MIN_ALLO_DUR )
			{
				m_DurHold = MIN_ALLO_DUR;
			}*/
        }
    }

} /* CDuration::Pause_Insertion */





/*****************************************************************************
* CDuration::PhraseFinal_Lengthen *
*---------------------------------*
*   Description:
*   Duration Rule #2 - Phrase-final Lengthening
*       
********************************************************************** MC ***/
void CDuration::PhraseFinal_Lengthen( long /*cellCount*/ )
{
    SPDBG_FUNC( "CDuration::PhraseFinal_Lengthen" );
	float		stretchGain;

    if( m_cur_SyllableType & TERM_END_SYLL)
    {
    
    
        if( (m_cur_Stress) && (m_cur_VowelFlag) )
        {
            stretchGain = g_BoundryStretchTbl[(long)m_NextBoundary];
			m_DurHold *= stretchGain;

			//----------------------------
			// Clip to limits
			//----------------------------
			if( m_DurHold > MAX_ALLO_DUR )
			{
				m_DurHold = MAX_ALLO_DUR;
			}
			else if( m_DurHold < MIN_ALLO_DUR )
			{
				m_DurHold = MIN_ALLO_DUR;
			}
        }
    }
} /* CDuration::PhraseFinal_Lengthen */


#define		EMPH_VOWEL_GAIN	1.0f
#define		EMPH_CONS_GAIN	1.25f
#define		EMPH_VOWEL_MIN	0.060f
#define		EMPH_CONS_MIN	0.020f
#define		EMPH_MIN_DUR	0.150f

/*****************************************************************************
* CDuration::Emphatic_Lenghen *
*-----------------------------*
*   Description:
*   Duration Rule #8 - Lengthening for emphasis
*       
********************************************************************** MC ***/
long CDuration::Emphatic_Lenghen( long lastStress )
{
    SPDBG_FUNC( "CDuration::Emphatic_Lenghen" );

    long            eFlag;
	bool			isEmph;

    eFlag = lastStress;
	if( m_cur_Stress & EMPHATIC_STRESS )
	{
		isEmph = true;
	}
	else
	{
		isEmph = false;
	}

    if( (m_cur_PhonCtrl & WORD_INITIAL_CONSONANT) || 
        ( m_cur_VowelFlag && (!isEmph)) )
    {
        eFlag = false;          // start of a new word OR non-emph vowel    
    }
    
    if( isEmph )
    {
        eFlag = true;           // continue lengthening until above condition is met    
    }
    
    if( eFlag )
    {
		

		/*if( m_DurHold < EMPH_MIN_DUR )
		{
			m_durationPad += EMPH_MIN_DUR - m_DurHold;
		}*/

		float		durDiff;
        if( m_cur_VowelFlag)
        {
			durDiff = (m_DurHold * EMPH_VOWEL_GAIN) - m_DurHold;
			if( durDiff <  EMPH_VOWEL_MIN )
			{
				durDiff = EMPH_VOWEL_MIN;
			}
        }
        else
        {
			durDiff = (m_DurHold * EMPH_CONS_GAIN) - m_DurHold;
			if( durDiff <  EMPH_CONS_MIN )
			{
				durDiff = EMPH_CONS_MIN;
			}
        }
		m_durationPad += durDiff;    // lengthen phon for emph    
    }

    return eFlag;
} /* CDuration::Emphatic_Lenghen */





/*****************************************************************************
* CDuration::AlloDuration *
*-------------------------*
*   Description:
*   Calculate durations
*       
********************************************************************** MC ***/
void CDuration::AlloDuration( CAlloList *pAllos, float rateRatio )
{
    SPDBG_FUNC( "CDuration::AlloDuration" );

    
    long        eFlag;
    CAlloCell   *pPrevCell, *pCurCell, *pNextCell, *pNext2Cell;
    long        numOfCells;
    long        userDuration, silBreak;
    
    numOfCells = pAllos->GetCount();

    if( numOfCells > 0 )
    {
        eFlag   = false;
		//------------------------------
		// Fill the pipeline
		//------------------------------
		pPrevCell = pAllos->GetHeadCell();
		pCurCell = pAllos->GetNextCell();
		pNextCell = pAllos->GetNextCell();
		pNext2Cell = pAllos->GetNextCell();

		//------------------------------
		// 1st allo is always SIL
		//------------------------------
        pPrevCell->m_ftDuration = pPrevCell->m_UnitDur = PITCH_BUF_RES;           // initial SIL    
		while( pCurCell )
        {
            //------------------
            // Current  
            //------------------
            m_cur_Phon = pCurCell->m_allo;
            m_cur_PhonCtrl = pCurCell->m_ctrlFlags;
            m_cur_SyllableType = m_cur_PhonCtrl & SYLLABLE_TYPE_FIELD;
            m_cur_Stress = m_cur_PhonCtrl & STRESS_FIELD;
            m_cur_PhonFlags = ::g_AlloFlags[m_cur_Phon];
            userDuration = pCurCell->m_user_Break;
            silBreak = pCurCell->m_Sil_Break;
            if( m_cur_PhonFlags & KVOWELF)
            {
                m_cur_VowelFlag = true;
            }
            else
            {
                m_cur_VowelFlag = false;
            }
            m_CurBoundary = pCurCell->m_TuneBoundaryType;
            m_NextBoundary = pCurCell->m_NextTuneBoundaryType;
            m_TotalDurScale = rateRatio * pCurCell->m_DurScale * pCurCell->m_ProsodyDurScale;
//			m_DurHold = pCurCell->m_UnitDur;
			m_DurHold = 1.f;
			m_durationPad = 0;

			if( pCurCell->m_user_Emph > 0 )
			{
				m_cur_Stress |= EMPHATIC_STRESS;
			}
        
            //------------------
            // Prev  
            //------------------
            m_prev_Phon = pPrevCell->m_allo;
            m_prev_PhonCtrl = pPrevCell->m_ctrlFlags;
            m_prev_PhonFlags = ::g_AlloFlags[m_prev_Phon];
        
            //------------------
            // Next
            //------------------
            if( pNextCell )
            {
                m_next_Phon = pNextCell->m_allo;
                m_next_PhonCtrl = pNextCell->m_ctrlFlags;
            }
            else
            {
                m_next_Phon = _SIL_;
                m_next_PhonCtrl = 0;
            }
            m_next_PhonFlags = ::g_AlloFlags[m_next_Phon];
        
            //------------------
            // 2 phons ahead 
            //------------------
            if( pNext2Cell )
            {
                m_next2_Phon = pNext2Cell->m_allo;
                m_next2_PhonCtrl = pNext2Cell->m_ctrlFlags;
            }
            else
            {
                m_next2_Phon = _SIL_;
                m_next2_PhonCtrl = 0;
            }
            m_next2_PhonFlags = ::g_AlloFlags[m_next2_Phon];

        
            if( m_cur_Phon == _SIL_ )
            {
                //-------------------------------------------
                // #1 - Pause Insertion  
                //-------------------------------------------
                Pause_Insertion( userDuration, silBreak );
            }
            else
            {
                //-------------------------------------------
                // #2 - Phrase-final Lengthening 
                //-------------------------------------------
                PhraseFinal_Lengthen( numOfCells );
        
                //-------------------------------------------
                // #8  Lengthening for emphasis 
                //-------------------------------------------
                eFlag = Emphatic_Lenghen( eFlag );        
   
            }
        
            pCurCell->m_ftDuration = ((m_DurHold + m_durationPad) / m_TotalDurScale);

			//---------------------------------
			// Shift the pipeline once
			//---------------------------------
			pPrevCell	= pCurCell;
			pCurCell	= pNextCell;
			pNextCell	= pNext2Cell;
			pNext2Cell	= pAllos->GetNextCell();
        }
    }
} /* CDuration::AlloDuration */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\disambig.cpp ===
/*******************************************************************************
* Disambig.cpp *
*--------------*
*	Description:
*		This module contains the methods to disambiguate part of speech and
*	select the correct pronounciation from the lexicon.
*-------------------------------------------------------------------------------
*  Created By: EDC										  Date: 07/15/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "commonlx.h"
#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif
#include "spttsengdebug.h"

/*****************************************************************************
* TryPOSConversion *
*------------------*  
*       
*   Description:
*       Checks to see whether the argument PRONRECORD contains the argument
*   ENGPARTOFSPEECH as an option.  If so, sets the PRONRECORD alternate
*   choice and part of speech choice, and returns true.  If not, just returns
*   false without modifying the PRONRECORD at all.
*
***************************************************************** AH *********/
bool TryPOSConversion( PRONRECORD& pPron, ENGPARTOFSPEECH PartOfSpeech )
{

    //--- Check first pronunciation
    for ( ULONG i = 0; i < pPron.pronArray[0].POScount; i++ )
    {
        if ( pPron.pronArray[0].POScode[i] == PartOfSpeech )
        {
            pPron.altChoice = 0;
            pPron.POSchoice = PartOfSpeech;
            return true;
        }
    }

    //--- Check second pronunciation
    if ( pPron.hasAlt )
    {
        for ( ULONG i = 0; i < pPron.pronArray[1].POScount; i++ )
        {
            if ( pPron.pronArray[1].POScode[i] == PartOfSpeech )
            {
                pPron.altChoice = 1;
                pPron.POSchoice = PartOfSpeech;
                return true;
            }
        }
    }

    return false;
} /* TryPOS Conversion */

/*****************************************************************************
* DisambiguatePOS *
*-----------------*  
*       
*   Description:
*       Disambiguate parts of speech by applying patches in order...  This 
*   work is an implementation of Eric Brill's rule-based part of speech
*   tagger - see, for example:
*
*   Brill, Eric. 1992. A simple rule-based part of speech tagger.  
*       In Proceedings of the Third Conference on Applied Natural
*       Language Processing, ACL. Trento, Italy.
*
***************************************************************** AH *********/
void DisambiguatePOS( PRONRECORD *pProns, ULONG cNumOfWords )
{
    SPDBG_FUNC( "DisambiguatePOS" );

    //--- Iterate over the patches, applying each (where applicable) to the
    //--- entire sentence.  For each patch, iterate over each word in the 
    //--- sentence to which the patch could apply (from left to right).
    for ( int i = 0; i < sp_countof( g_POSTaggerPatches ); i++ )
    {
        switch ( g_POSTaggerPatches[i].eTemplateType )
        {
        case PREV1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous POS matches, and
                            //--- the conversion POS is a possibility for this word, convert the
                            //--- POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches, and 
                            //--- the conversion POS is a possibility for this word, convert the
                            //--- POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 2; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the POS two previous matches, and
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 2; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the POS two after matches, and 
                            //--- the conversion POS is a possibility for this word, convert the
                            //--- POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1OR2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous POS matches OR the
                            //--- POS two previous matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j > 1                                                        &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }            
                        }
                    }
                }
            }
            break;
        case NEXT1OR2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches OR the POS
                            //--- two after matches, and the conversion POS is a possibility for this 
                            //--- word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j < cNumOfWords - 2                                          &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1OR2OR3T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous POS matches OR the
                            //--- POS two previous matches OR the POS three previous matches, and 
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j > 1                                                        &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j > 2                                                        &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 3].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }                         
                        }
                    }
                }
            }
            break;
        case NEXT1OR2OR3T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches OR the POS
                            //--- two after matches OR the POS three after matches, and the conversion 
                            //--- POS is a possibility for this word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j < cNumOfWords - 2                                          &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j < cNumOfWords - 3                                          &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 3].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1TNEXT1T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 1; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches, and the
                            //--- previous POS matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS2 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1TNEXT2T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 1; j < cNumOfWords - 2; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the POS two after matches, and the
                            //--- previous POS matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS2 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV2TNEXT1T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 2; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches, and the
                            //--- POS two previous matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS2 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CAP:
            {
                for ( ULONG j = 0; j < cNumOfWords; j++ )
                {
                    if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                    {
                        //--- If the current POS matches, and the word is capitalized, and the
                        //--- conversion POS is a possibility for this word, convert the POS.
                        if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                             iswupper( pProns[j].orthStr[0] ) )
                        {
                            TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                        }
                    }
                }
            }
            break;
        case NOTCAP:
            {
                for ( ULONG j = 0; j < cNumOfWords; j++ )
                {
                    if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                    {
                        //--- If the current POS matches, and the word is not capitalized, and the
                        //--- conversion POS is a possibility for this word, convert the POS.
                        if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                             !iswupper( pProns[j].orthStr[0] ) )
                        {
                            TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                        }
                    }
                }
            }
            break;
        case PREVCAP:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word is capitalized, 
                            //--- and the conversion POS is a possibility for this word, convert the 
                            //--- POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 iswupper( pProns[j - 1].orthStr[0] ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREVNOTCAP:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the word is capitalized, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 !iswupper( pProns[j - 1].orthStr[0] ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next word matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV2W:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 2; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the word two previous matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j - 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT2W:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 2; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the word two after matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j + 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1OR2W:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word OR the word two 
                            //--- previous matches, and the conversion POS is a possibility for this word, 
                            //--- convert the POS.
                            if ( ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) ||
                                 ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j - 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1OR2W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next word matches OR the word two after
                            //--- matches, and the conversion POS is a possibility for this word, convert the 
                            //--- POS.
                            if ( ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) ||
                                 ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j + 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWPREV1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the previous
                            //--- word matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                    &&
                                 _wcsicmp( pProns[j].orthStr,     g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWNEXT1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the next
                            //--- word matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                    &&
                                 _wcsicmp( pProns[j].orthStr,     g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWPREV1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the previous
                            //--- POS matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWNEXT1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the next
                            //--- POS matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRW:
            {
                for ( ULONG j = 0; j < cNumOfWords; j++ )
                {
                    if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                    {
                        //--- If the current POS matches, and the current word matches, and the
                        //--- conversion POS is a possibility for this word, convert the POS.
                        if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                             _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                        {
                            TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS ) ;
                        }
                    }
                }
            }
            break;
        case PREV1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word and POS match, and
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next word and POS match, and
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWPREV1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current words matches, and the
                            //--- previous word and POS match, and the conversion POS is a possibility
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 )     == 0 &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1              &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWNEXT1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current words matches, and the
                            //--- next word and POS match, and the conversion POS is a possibility
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 )     == 0 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1              &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        }
    }
} /* DisambiguatePOS */

/*****************************************************************************
* Pronounce *
*-----------*
*	Description:
*		Get lexicon or letter-to-sound (LTS) pronunciations
*		
********************************************************************** MC ***/
HRESULT CStdSentEnum::Pronounce( PRONRECORD *pPron )
{
    SPDBG_FUNC( "Pronounce" );
    SPWORDPRONUNCIATIONLIST 	SPList;
    HRESULT 	hr = SPERR_NOT_IN_LEX;
    ULONG	cPhonLen;
    DWORD dwFlags = eLEXTYPE_USER | eLEXTYPE_APP | eLEXTYPE_PRIVATE1 | eLEXTYPE_PRIVATE2;
    BOOL  fPOSExists = false;
    
    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );

	
    //--- Special Case - XML Provided Part Of Speech.  Search for exact match first...
    if ( pPron->XMLPartOfSpeech != MS_Unknown )
    {
        //--- Try User Lexicon
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_USER, &SPList );
        if ( SUCCEEDED( hr ) &&
             SPList.pFirstWordPronunciation )
        {
            for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                  pPronunciation = pPronunciation->pNextWordPronunciation )
            {
                if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                {
                    fPOSExists = true;
                    break;
                }
            }
            if ( !fPOSExists )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
            }
        }
        //--- Handle empty pronunciation
        else if ( !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
        //--- Try App Lexicon
        if ( !fPOSExists )
        {
            hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_APP, &SPList );
            if ( SUCCEEDED( hr ) &&
                SPList.pFirstWordPronunciation )
            {
                for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                      pPronunciation = pPronunciation->pNextWordPronunciation )
                {
                    if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                    {
                        fPOSExists = true;
                        break;
                    }
                }
                if ( !fPOSExists )
                {
                    if ( SPList.pvBuffer )
                    {
                        ::CoTaskMemFree( SPList.pvBuffer );
                        ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                    }
                }
            }
            //--- Handle empty pronunciation
            else if ( !SPList.pFirstWordPronunciation )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
                hr = SPERR_NOT_IN_LEX;
            }
        }
        //--- Try Vendor Lexicon
        if ( !fPOSExists )
        {
            hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE1, &SPList );
            if ( SUCCEEDED( hr ) &&
                 SPList.pFirstWordPronunciation )
            {
                for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                      pPronunciation = pPronunciation->pNextWordPronunciation )
                {
                    if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                    {
                        fPOSExists = true;
                        break;
                    }
                }
                if ( !fPOSExists )
                {
                    if ( SPList.pvBuffer )
                    {
                        ::CoTaskMemFree( SPList.pvBuffer );
                        ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                    }
                }
            }
            //--- Handle empty pronunciation
            else if ( !SPList.pFirstWordPronunciation )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
                hr = SPERR_NOT_IN_LEX;
            }
        }
        //--- Try Morph Lexicon
        if ( !fPOSExists )
        {
            hr = m_pMorphLexicon->DoSuffixMorph( pPron->orthStr, pPron->lemmaStr, 1033, dwFlags, &SPList );
            if ( SUCCEEDED( hr ) &&
                 SPList.pFirstWordPronunciation )
            {
                for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                      pPronunciation = pPronunciation->pNextWordPronunciation )
                {
                    if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                    {
                        fPOSExists = true;
                        break;
                    }
                }
                if ( !fPOSExists )
                {
                    //--- Need to do this the last time, to make sure we hit the default code below...
                    //--- RAID 5078
                    hr = SPERR_NOT_IN_LEX;
                    if ( SPList.pvBuffer )
                    {
                        ::CoTaskMemFree( SPList.pvBuffer );
                        ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                    }
                }
            }
            //--- Handle empty pronunciation
            else if ( !SPList.pFirstWordPronunciation )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
                hr = SPERR_NOT_IN_LEX;
            }
        }
    }
        
    //--- Default case - just look up orthography and go with first match.
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_USER, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }            
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_APP, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE1, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_pMorphLexicon->DoSuffixMorph( pPron->orthStr, pPron->lemmaStr, 1033, 
                                             dwFlags, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        if ( m_fHaveNamesLTS &&
             !wcscmp( pPron->CustomLtsToken, L"Names" ) )
        {
            hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE3, &SPList );
        }
        else
        {
            hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE2, &SPList );
        }

        //--- Make all LTS words Nouns...
        for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation; 
              pPronunciation = pPronunciation->pNextWordPronunciation )
        {
            pPronunciation->ePartOfSpeech = SPPS_Noun;
        }
    }

    if (SUCCEEDED(hr))
    {
        //--- WARNING - this assumes pronunciations will only come from one type of lexicon, an assumption
        //---   which was true as of July, 2000
        pPron->pronType = SPList.pFirstWordPronunciation->eLexiconType;

        //------------------------------------------------------------
        // SAPI unrolls pronunciations from their POS.
        // So roll them back into the original collapsed array 
        // of one or two candidates with sorted POS (argh...)
        //------------------------------------------------------------
        SPWORDPRONUNCIATION 	*firstPron, *pCurPron, *pNextPron;
        
        //------------------------------------------
        // Init  pronunciation A
        //------------------------------------------
        pCurPron = firstPron = SPList.pFirstWordPronunciation;
        pPron->pronArray[PRON_A].POScount = 1;
        //----------------------------
        // Get phoneme length
        //----------------------------
        cPhonLen = wcslen( firstPron->szPronunciation ) + 1;	// include delimiter
        //----------------------------
        // Clip phoneme string to max  
        //----------------------------
        if( cPhonLen > SP_MAX_PRON_LENGTH )
        {
            cPhonLen = SP_MAX_PRON_LENGTH;
        }
        //----------------------------
        // Copy unicode phoneme string
        //----------------------------
        memcpy( pPron->pronArray[PRON_A].phon_Str, firstPron->szPronunciation, cPhonLen * sizeof(WCHAR) );
        pPron->pronArray[PRON_A].phon_Len = cPhonLen -1;		// minus delimiter
        pPron->pronArray[PRON_A].POScode[0] = (ENGPARTOFSPEECH)firstPron->ePartOfSpeech; 
        
        //------------------------------------------
        // Init  pronunciation B
        //------------------------------------------
        pPron->pronArray[PRON_B].POScount = 0;
        pPron->pronArray[PRON_B].phon_Len = 0;

        pNextPron = pCurPron->pNextWordPronunciation;
        
        while( pNextPron )
        {
            int 	isDiff;
            
            isDiff = wcscmp( firstPron->szPronunciation, pNextPron->szPronunciation );
            if( isDiff )
            {
                //------------------------------------------------
                // Next pronunciation is different from 1st
                //------------------------------------------------
                if( pPron->pronArray[PRON_B].POScount < POS_MAX )
                {
                    //---------------------------------------
                    // Gather POS B into array
                    //---------------------------------------
                    pPron->pronArray[PRON_B].POScode[pPron->pronArray[PRON_B].POScount] = 
                        (ENGPARTOFSPEECH)pNextPron->ePartOfSpeech;
                    pPron->pronArray[PRON_B].POScount++;
                    if( pPron->pronArray[PRON_B].phon_Len == 0 )
                    {
                        //-----------------------------------------
                        // If there's no B pron yet, make one
                        //-----------------------------------------
                        cPhonLen = wcslen( pNextPron->szPronunciation ) + 1;	// include delimiter
                        //----------------------------
                        // Clip phoneme string to max
                        //----------------------------
                        if( cPhonLen > SP_MAX_PRON_LENGTH )
                        {
                            cPhonLen = SP_MAX_PRON_LENGTH;
                        }
                        //----------------------------
                        // Copy unicode phoneme string
                        //----------------------------
                        memcpy( pPron->pronArray[PRON_B].phon_Str, 
                            pNextPron->szPronunciation, 
                            cPhonLen * sizeof(WCHAR) );
                        pPron->pronArray[PRON_B].phon_Len = cPhonLen -1;		// minus delimiter
                        pPron->hasAlt = true;
                    } 
                }
            }
            else
            {
                //------------------------------------------------
                // Next pronunciation is same as 1st
                //------------------------------------------------
                if( pPron->pronArray[PRON_A].POScount < POS_MAX )
                {
                    //---------------------------------------
                    // Gather POS A into array
                    //---------------------------------------
                    pPron->pronArray[PRON_A].POScode[pPron->pronArray[PRON_A].POScount] = 
                        (ENGPARTOFSPEECH)pNextPron->ePartOfSpeech;
                    pPron->pronArray[PRON_A].POScount++;
                }
            }
            pCurPron = pNextPron;
            pNextPron = pCurPron->pNextWordPronunciation;
        }
    }

    //--- If XML POS provided, set selection now as it won't be touched by the POS Tagger
    if ( pPron->XMLPartOfSpeech != MS_Unknown )
    {
        BOOL fMadeMatch = false;

        //--- Check first pronunciation
        for ( ULONG i = 0; i < pPron->pronArray[0].POScount; i++ )
        {
            if ( pPron->pronArray[0].POScode[i] == pPron->XMLPartOfSpeech )
            {
                pPron->altChoice = 0;
                pPron->POSchoice = pPron->XMLPartOfSpeech;
                fMadeMatch = true;
            }
        }

        //--- Check second pronunciation
        if ( pPron->hasAlt )
        {
            for ( ULONG i = 0; i < pPron->pronArray[1].POScount; i++ )
            {
                if ( pPron->pronArray[1].POScode[i] == pPron->XMLPartOfSpeech )
                {
                    pPron->altChoice = 1;
                    pPron->POSchoice = pPron->XMLPartOfSpeech;
                    fMadeMatch = true;
                }
            }
        }

        //--- If this POS didn't exist for the word, let POS Tagger do its thing
        //--- to determine a pronunciation, and then reassign the POS later...
        if ( !fMadeMatch )
        {
            pPron->XMLPartOfSpeech = MS_Unknown;
            pPron->POSchoice       = pPron->pronArray[PRON_A].POScode[0];
        }
    }
    //--- Set default POS, for later refinement by POS Tagger
    else
    {
        pPron->POSchoice = pPron->pronArray[PRON_A].POScode[0];
        pPron->altChoice = PRON_A;
    }

    if( SPList.pvBuffer )
    {
        ::CoTaskMemFree( SPList.pvBuffer );
    }

    return hr;
} /* Pronounce */

/*****************************************************************************
* CStdSentEnum::DetermineProns *
*------------------------------*
*   Description:
* 	  This method determines POS and looks up the pronounciation
********************************************************************* MC ****/
HRESULT CStdSentEnum::DetermineProns( CItemList& ItemList, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::DetermineProns" );
    HRESULT hr = S_OK;
    ULONG cNumOfProns, cPronIndex;
    PRONRECORD*	  pProns = NULL;

    //--- Count the total number of pronunciations needed
    cNumOfProns = 0;
    SPLISTPOS ListPos = ItemList.GetHeadPosition();
    while( ListPos )
    {
        TTSSentItem& Item = ItemList.GetNext( ListPos );
        for ( ULONG i = 0; i < Item.ulNumWords; i++ )
        {
            if( Item.Words[i].pWordText &&
                ( Item.Words[i].pXmlState->eAction == SPVA_Speak || 
                  Item.Words[i].pXmlState->eAction == SPVA_SpellOut || 
                  Item.Words[i].pXmlState->eAction == SPVA_Pronounce ) )
            {
                ++cNumOfProns;
            }
        }
    }

    if ( cNumOfProns )
    {
        pProns = new PRONRECORD[cNumOfProns];

        if( !pProns )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //--- First, get item pronunciation(s)
            ZeroMemory( pProns, cNumOfProns * sizeof(PRONRECORD) );
            cPronIndex = 0;
            ListPos = ItemList.GetHeadPosition();

            //--- Iterate through ItemList
            while( ListPos && SUCCEEDED( hr ) )
            {
                TTSSentItem& Item = ItemList.GetNext( ListPos );
                //--- Iterate over Words
                for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                {
                    //--- Get pronunciations and parts of speech for spoken items only
                    if ( Item.Words[i].pWordText && 
                         ( Item.Words[i].pXmlState->eAction == SPVA_Speak ||
                           Item.Words[i].pXmlState->eAction == SPVA_SpellOut ||
                           Item.Words[i].pXmlState->eAction == SPVA_Pronounce ) )
                    {
                        SPDBG_ASSERT( cPronIndex < cNumOfProns );
                        ULONG cItemLen = Item.Words[i].ulWordLen;
                        //--- Clip at max text length
                        if( cItemLen > ( SP_MAX_WORD_LENGTH-1 ) )
                        {
                            cItemLen = SP_MAX_WORD_LENGTH - 1;
                        }
                        //--- Copy item text
                        memcpy( pProns[cPronIndex].orthStr, 
                                Item.Words[i].pWordText, 
                                cItemLen * sizeof(WCHAR) );
                        pProns[cPronIndex].orthStr[cItemLen] = 0;
                        //--- Set Part of Speech, if given in XML
                        if ( Item.Words[i].pXmlState->ePartOfSpeech != MS_Unknown )
                        {
                            pProns[cPronIndex].XMLPartOfSpeech = (ENGPARTOFSPEECH)Item.Words[i].pXmlState->ePartOfSpeech;
                        }

                        //--- Copy CustomLtsToken string...
                        wcscpy( pProns[cPronIndex].CustomLtsToken, Item.CustomLtsToken );

                        //--- Do Lex Lookup, if necessary
                        if ( Item.Words[i].pXmlState->pPhoneIds == NULL || 
                             Item.Words[i].pXmlState->ePartOfSpeech == MS_Unknown )
                        {
                            //--- Special Case - Disambiguate Abbreviations
                            if ( Item.pItemInfo->Type == eABBREVIATION ||
                                 Item.pItemInfo->Type == eABBREVIATION_NORMALIZE )
                            {
                                const AbbrevRecord *pAbbrevInfo = 
                                    ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation;
                                if ( pAbbrevInfo->iPronDisambig < 0 )
                                {
                                    //--- Default case - just take the first (and only) pronunciation
                                    pProns[cPronIndex].pronArray[PRON_A].POScount   = 1;
                                    wcscpy( pProns[cPronIndex].pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                                    pProns[cPronIndex].pronArray[PRON_A].phon_Len   = 
                                        wcslen( pProns[cPronIndex].pronArray[PRON_A].phon_Str );
                                    pProns[cPronIndex].pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                                    pProns[cPronIndex].pronArray[PRON_B].POScount   = 0;
                                    pProns[cPronIndex].pronArray[PRON_B].phon_Len   = 0;
                                    pProns[cPronIndex].hasAlt                       = false;
                                    pProns[cPronIndex].altChoice                    = PRON_A;
                                    pProns[cPronIndex].POSchoice                    = pAbbrevInfo->POS1;
                                    //--- Abbreviation table prons are basically just vendor lex prons...
                                    pProns[cPronIndex].pronType                     = eLEXTYPE_PRIVATE1;
                                }
                                else
                                {
                                    hr = ( this->*g_PronDisambigTable[pAbbrevInfo->iPronDisambig] )
                                                ( pAbbrevInfo, &pProns[cPronIndex], ItemList, ListPos ); 
                                }
								pProns[cPronIndex].fUsePron = true;
                            }
                            //--- Default case
                            else
                            {
                                //--- Check disambiguation list
                                const AbbrevRecord* pAbbrevRecord = 
                                    (AbbrevRecord*) bsearch( (void*) pProns[cPronIndex].orthStr, (void*) g_AmbiguousWordTable,
                                                             sp_countof( g_AmbiguousWordTable ), sizeof( AbbrevRecord ),
                                                             CompareStringAndAbbrevRecord );
                                if ( pAbbrevRecord )
                                {
                                    hr = ( this->*g_AmbiguousWordDisambigTable[pAbbrevRecord->iPronDisambig] )
                                                ( pAbbrevRecord, &pProns[cPronIndex], ItemList, ListPos );
                                    pProns[cPronIndex].fUsePron = true;
                                }
                                //--- Do Lex Lookup, if necessary
                                else
                                {
                                    hr = Pronounce( &pProns[cPronIndex] );
                                }
                            }
                        }
                        cPronIndex++;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                //--- Next, disambiguate part-of-speech
                DisambiguatePOS( pProns, cNumOfProns );

                //--- Output debugging information
                TTSDBG_LOGPOSPOSSIBILITIES( pProns, cNumOfProns, STREAM_POSPOSSIBILITIES );

                //--- Finally, copy selected pronunciation to 'ItemList'
                PRONUNIT *selectedUnit;
                cPronIndex = 0;
                ListPos = ItemList.GetHeadPosition();

                while( ListPos && SUCCEEDED(hr) )
                {
                    TTSSentItem& Item = ItemList.GetNext( ListPos );
                    for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                    {
                        //--- Set pronunciation and part-of-speech for spoken items only
                        if( Item.Words[i].pWordText &&
                            ( Item.Words[i].pXmlState->eAction == SPVA_Speak || 
                              Item.Words[i].pXmlState->eAction == SPVA_SpellOut ||
                              Item.Words[i].pXmlState->eAction == SPVA_Pronounce ) )
                        {
                            SPDBG_ASSERT( cPronIndex < cNumOfProns );
                            //--- Use XML specified pronunciation, if given.
                            if ( Item.Words[i].pXmlState->pPhoneIds )
                            {
                                Item.Words[i].pWordPron = Item.Words[i].pXmlState->pPhoneIds;
                            }
                            else
                            {
                                selectedUnit = &pProns[cPronIndex].pronArray[pProns[cPronIndex].altChoice];
                                Item.Words[i].pWordPron =
                                    (SPPHONEID*) MemoryManager.GetMemory( (selectedUnit->phon_Len + 1) * 
                                                                          sizeof(SPPHONEID), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    wcscpy( Item.Words[i].pWordPron, selectedUnit->phon_Str );
                                }
                            }

                            //--- Use XML specified part-of-speech, if given.  This will override the case
                            //--- where the POS didn't exist as an option and the POS Tagger did its thing
                            //--- to find a pronunciation.
                            if ( Item.Words[i].pXmlState->ePartOfSpeech != MS_Unknown )
                            {
                                Item.Words[i].eWordPartOfSpeech = (ENGPARTOFSPEECH)Item.Words[i].pXmlState->ePartOfSpeech;
                            }
                            else
                            {
                                Item.Words[i].eWordPartOfSpeech = pProns[cPronIndex].POSchoice;
                            }

                            //--- Root word
                            if ( pProns[cPronIndex].lemmaStr[0] )
                            {
                                Item.Words[i].ulLemmaLen = wcslen( pProns[cPronIndex].lemmaStr );
                                Item.Words[i].pLemma = 
                                    (WCHAR*) MemoryManager.GetMemory( Item.Words[i].ulLemmaLen * sizeof(WCHAR), &hr );
                                if ( SUCCEEDED( hr ) )
                                {                               
                                    wcsncpy( (WCHAR*) Item.Words[i].pLemma, pProns[cPronIndex].lemmaStr,
                                             Item.Words[i].ulLemmaLen );
                                }
                            }

                            //--- Insert pron in text, if appropriate - RAID #4746
                            if ( pProns[cPronIndex].fUsePron )
                            {
                                ULONG ulNumChars = wcslen( Item.Words[i].pWordPron );
                                Item.Words[i].pWordText = 
                                    (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    ZeroMemory( (WCHAR*) Item.Words[i].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                                    (WCHAR) Item.Words[i].pWordText[0] = L'*';
                                    wcscpy( ( (WCHAR*) Item.Words[i].pWordText + 1 ), Item.Words[i].pWordPron );
                                    (WCHAR) Item.Words[i].pWordText[ ulNumChars + 1 ] = L'*';
									Item.Words[i].ulWordLen = ulNumChars + 2;
                                }
                            }

                            cPronIndex++;
                        }
                    }
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                //--- Check Post POS disambiguation list
                SPLISTPOS ListPos = ItemList.GetHeadPosition();
                while ( ListPos && SUCCEEDED( hr ) )
                {
                    TTSSentItem& Item = ItemList.GetNext( ListPos );
                    if ( Item.pItemInfo->Type == eALPHA_WORD ||
                         Item.pItemInfo->Type == eABBREVIATION ||
                         Item.pItemInfo->Type == eABBREVIATION_NORMALIZE )
                    {
                        WCHAR temp;
                        BOOL fPeriod = false;
                        if ( Item.pItemSrcText[Item.ulItemSrcLen - 1] == L'.' &&
                             Item.ulItemSrcLen > 1 )
                        {
                            temp = Item.pItemSrcText[Item.ulItemSrcLen - 1];
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen - 1 ) = 0;
                            fPeriod = true;
                        }
                        else
                        {
                            temp = Item.pItemSrcText[Item.ulItemSrcLen];
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen ) = 0;
                        }

                        const AbbrevRecord* pAbbrevRecord =
                            (AbbrevRecord*) bsearch( (void*) Item.pItemSrcText, (void*) g_PostLexLookupWordTable,
                                                     sp_countof( g_PostLexLookupWordTable ), sizeof( AbbrevRecord ),
                                                     CompareStringAndAbbrevRecord );
                        if ( pAbbrevRecord )
                        {
                            hr = ( this->*g_PostLexLookupDisambigTable[pAbbrevRecord->iPronDisambig] )
                                        ( pAbbrevRecord, ItemList, ListPos, MemoryManager );
                        }
                
                        if ( fPeriod )
                        {
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen - 1 ) = temp;
                        }
                        else
                        {
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen ) = temp;
                        }
                    }
                }
            }
        }
    }
    
    if (pProns)
    {
        delete [] pProns;
    }

    return hr;
} /* CStdSentEnum::DetermineProns */

/***********************************************************************************************
* MeasurementDisambig *
*---------------------*
*   Description:
*       This overrides initial pronunciations of measurement abbreviations when they are used
*   as modifiers - e.g. "a 7 ft. pole" vs. "the pole was 7 ft. long"
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::MeasurementDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                           SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::MeasurementDisambig" );
    HRESULT hr = S_OK;

    //--- Get previous two items
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                TTSSentItem TempItem = ItemList.GetPrev( TempPos );
                //--- Previous must be a number
                if ( TempItem.pItemInfo->Type == eNUM_CARDINAL )
                {
                    //--- Get next item
                    TempPos = ListPos;
                    TempItem = ItemList.GetNext( TempPos );
                    //--- Next must be a noun or adj
                    if ( TempItem.eItemPartOfSpeech == MS_Noun )
                    {
                        //--- Matched a 7 ft. pole type example - go with singular
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& MeasurementItem = ItemList.GetPrev( TempPos );
                        //--- Singular will always be shorter than plural, so this should never overwrite
                        //---   anything...
                        wcscpy( MeasurementItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( MeasurementItem.Words[0].pWordPron );
                        MeasurementItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) MeasurementItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) MeasurementItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) MeasurementItem.Words[0].pWordText + 1 ), MeasurementItem.Words[0].pWordPron );
                            (WCHAR) MeasurementItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							MeasurementItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                    else if ( TempItem.eItemPartOfSpeech == MS_Adj &&
                              TempPos )
                    {
                        //--- Next must be a noun
                        TempItem = ItemList.GetNext( TempPos );
                        {
                            if ( TempItem.eItemPartOfSpeech == MS_Noun )
                            {
                                //--- Matched a 7 ft. pole type example - go with singular
                                TempPos = ListPos;
                                ItemList.GetPrev( TempPos );
                                TTSSentItem& MeasurementItem = ItemList.GetPrev( TempPos );
                                //--- Singular will always be shorter than plural, so this should never overwrite
                                //---   anything...
                                wcscpy( MeasurementItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );

                                //--- Insert pron into word text - RAID #4746
                                ULONG ulNumChars = wcslen( MeasurementItem.Words[0].pWordPron );
                                MeasurementItem.Words[0].pWordText = 
                                    (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    ZeroMemory( (WCHAR*) MeasurementItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                                    (WCHAR) MeasurementItem.Words[0].pWordText[0] = L'*';
                                    wcscpy( ( (WCHAR*) MeasurementItem.Words[0].pWordText + 1 ), MeasurementItem.Words[0].pWordPron );
                                    (WCHAR) MeasurementItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
									MeasurementItem.Words[0].ulWordLen = ulNumChars + 2;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
} /* MeasurementDisambig */

/***********************************************************************************************
* TheDisambig *
*-------------*
*   Description:
*       This function disambiguates the word the - before a vowel it becomes "thee", before a
*   consonant it is "thuh"...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::TheDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                   SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::TheDisambig" );
    HRESULT hr = S_OK;

    //--- Get next item
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        TTSSentItem NextItem = ItemList.GetNext( TempPos );

        if ( NextItem.Words[0].pWordPron &&
             bsearch( (void*) NextItem.Words[0].pWordPron, (void*) g_Vowels, sp_countof( g_Vowels ), 
                      sizeof( WCHAR ), CompareWCHARAndWCHAR ) )
        {
            //--- Matched a vowel - go with / DH IY 1 /
            TempPos = ListPos;
            ItemList.GetPrev( TempPos );
            TTSSentItem& TheItem = ItemList.GetPrev( TempPos );
            //--- The two pronunciations are exactly the same length, so this should never overwrite
            //---   anything
            wcscpy( TheItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
            TheItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
            //--- Insert pron into word text - RAID #4746
            ULONG ulNumChars = wcslen( TheItem.Words[0].pWordPron );
            TheItem.Words[0].pWordText = 
                (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( (WCHAR*) TheItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                (WCHAR) TheItem.Words[0].pWordText[0] = L'*';
                wcscpy( ( (WCHAR*) TheItem.Words[0].pWordText + 1 ), TheItem.Words[0].pWordPron );
                (WCHAR) TheItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
				TheItem.Words[0].ulWordLen = ulNumChars + 2;
            }
        }
        else
        {
            //--- Didn't match a vowel - go with / DH AX 1 /
            TempPos = ListPos;
            ItemList.GetPrev( TempPos );
            TTSSentItem& TheItem = ItemList.GetPrev( TempPos );
            //--- The two pronunciations are exactly the same length, so this should never overwrite
            //---   anything
            wcscpy( TheItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
            TheItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
            //--- Insert pron into word text - RAID #4746
            ULONG ulNumChars = wcslen( TheItem.Words[0].pWordPron );
            TheItem.Words[0].pWordText = 
                (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( (WCHAR*) TheItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                (WCHAR) TheItem.Words[0].pWordText[0] = L'*';
                wcscpy( ( (WCHAR*) TheItem.Words[0].pWordText + 1 ), TheItem.Words[0].pWordPron );
                (WCHAR) TheItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
				TheItem.Words[0].ulWordLen = ulNumChars + 2;
            }
        }
    }

    return hr;
} /* TheDisambig */

/***********************************************************************************************
* ADisambig *
*-----------*
*   Description:
*       This function disambiguates the word "a" - / EY 1 - Noun / vs. / AX - Det /
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ADisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, CItemList& ItemList, 
                                 SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::ADisambig" );
    HRESULT hr = S_OK;
    BOOL fNoun = false;

    //--- Get Current Item...
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            TTSSentItem CurrentItem = ItemList.GetPrev( TempPos );

            //--- If "a" is part of a multi-word item, use the Noun pronunciation...
            //--- If "a" is not an AlphaWord, use the Noun pronunciation...
            if ( CurrentItem.ulNumWords > 1 ||
                 CurrentItem.pItemInfo->Type != eALPHA_WORD )
            {
                fNoun = true;
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
        }
    }

    if ( !fNoun )
    {
        //--- Get Next Item...
        TempPos = ListPos;
        if ( TempPos )
        {
            TTSSentItem NextItem = ItemList.GetNext( TempPos );

            //--- If "a" is followed by punctuation, use the Noun pronunciation...
            if ( !( NextItem.pItemInfo->Type & eWORDLIST_IS_VALID ) )
            {
                fNoun = true;
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
        }
    }

    //--- Default - use the Determiner pronunciation (but include Noun pronunciation as well,
    //---   so that POS tagger rules will work properly)...
    if ( !fNoun )
    {
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->pronArray[PRON_A].POScount   = 1;
        pPron->POSchoice                    = pAbbrevInfo->POS2;
        wcscpy( pPron->pronArray[PRON_B].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_B].phon_Len   = wcslen( pPron->pronArray[PRON_B].phon_Str );
        pPron->pronArray[PRON_B].POScode[0] = pAbbrevInfo->POS1;
        pPron->pronArray[PRON_B].POScount   = 1;
        pPron->hasAlt = true;
    }

    return hr;
} /* ADisambig */

/***********************************************************************************************
* PolishDisambig *
*----------------*
*   Description:
*       This function disambiguates the word "polish" - [p ow 1 l - ax sh - Noun] vs.
*   [p ow 1 l - ax sh - Adj] vs. [p aa 1 l - ih sh - Verb] vs. [p aa 1 l - ih sh - Noun]
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::PolishDisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, CItemList& ItemList, 
                                      SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::PolishDisambig" );
    HRESULT hr = S_OK;
    BOOL fMatch = false;

    //--- Get Current Item...
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            TTSSentItem CurrentItem = ItemList.GetPrev( TempPos );

            //--- If "Polish" is capitalized and not sentence-initial, and not preceded immediately
            //--- by an open double-quote or parenthesis, use Noun...
            if ( iswupper( CurrentItem.pItemSrcText[0] ) )
            {
                BOOL fSentenceInitial = false;
                if ( !TempPos )
                {
                    fSentenceInitial = true;
                }
                else
                {
                    TTSSentItem PrevItem = ItemList.GetPrev( TempPos );
                    if ( PrevItem.pItemInfo->Type == eOPEN_PARENTHESIS ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACKET     ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACE       ||
                         PrevItem.pItemInfo->Type == eSINGLE_QUOTE     ||
                         PrevItem.pItemInfo->Type == eDOUBLE_QUOTE )
                    {
                        fSentenceInitial = true;
                    }
                }
                if ( fSentenceInitial )
                {
                    fMatch = true;
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;
                }
                else
                {
                    fMatch = true;
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = MS_Noun;
                    pPron->POSchoice                    = MS_Noun;
                }
            }
        }
    }

    //--- Default - use the Verb pronunciation (but include the others as well,
    //---   so that POS tagger rules will work properly)...
    if ( !fMatch )
    {
        //--- Verb, Noun
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->pronArray[PRON_A].POScode[1] = pAbbrevInfo->POS3;
        pPron->pronArray[PRON_A].POScount   = 2;
        //--- Adj
        wcscpy( pPron->pronArray[PRON_B].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_B].phon_Len   = wcslen( pPron->pronArray[PRON_B].phon_Str );
        pPron->pronArray[PRON_B].POScode[0] = pAbbrevInfo->POS1;
        pPron->pronArray[PRON_B].POScount   = 1;
        //--- Set initial choice to Verb...
        pPron->POSchoice                    = pAbbrevInfo->POS2;
        pPron->hasAlt = true;
    }

    return hr;
} /* PolishDisambig */

/***********************************************************************************************
* ReadDisambig *
*--------------*
*   Description:
*       This function disambiguates the word Read - past tense vs. present...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ReadDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                    SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::ReadDisambig" );
    HRESULT hr = S_OK;
    BOOL fMatch = false;

    //--- Get prev item
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                TTSSentItem PrevItem = ItemList.GetPrev( TempPos );

                //--- Check for closest auxiliary
                while ( PrevItem.Words[0].eWordPartOfSpeech != MS_VAux  &&
                        PrevItem.Words[0].eWordPartOfSpeech != MS_Contr &&
                        TempPos )
                {
                    PrevItem = ItemList.GetPrev( TempPos );
                }

                if ( PrevItem.Words[0].eWordPartOfSpeech == MS_VAux )
                {
                    fMatch = true;
                    if ( wcsnicmp( PrevItem.Words[0].pWordText, L"have", 4 )    == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"has", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"had", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"am", 2 )      == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"ain't", 5 )   == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"are", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"aren't", 6 )  == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"be", 2 )      == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"is", 2 )      == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"was", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"were", 4 )    == 0 )
                    {
                        //--- Matched have or haven't (has or hasn't, had or hadn't) - go with "red"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        //--- The two pronunciations are exactly the same length, so this should never overwrite
                        //---   anything
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS2;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                    else
                    {
                        //--- Some other auxiliary - go with "reed"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        //--- The two pronunciations are exactly the same length, so this should never overwrite
                        //---   anything
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                }
                //--- Check for pronoun aux contractions
                else if ( PrevItem.Words[0].eWordPartOfSpeech == MS_Contr )
                {
                    fMatch = true;
                    const WCHAR *pApostrophe = wcsstr( PrevItem.Words[0].pWordText, L"'" );
                    if ( pApostrophe &&
                         wcsnicmp( pApostrophe, L"'ll", 3 ) == 0 )
                    {
                        //--- Matched an 'll form - go with "reed"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                    else
                    {
                        //--- Some other form - go with "red"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS2;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                }
                //--- Check for infinitival form
                else 
                {
                    TempPos = ListPos;
                    ItemList.GetPrev( TempPos );
                    ItemList.GetPrev( TempPos );
                    PrevItem = ItemList.GetPrev( TempPos );

                    if ( PrevItem.Words[0].ulWordLen == 2 &&
                         wcsnicmp( PrevItem.Words[0].pWordText, L"to", 2 ) == 0 )
                    {
                        fMatch = true;

                        //--- Matched infinitival form - go with "reed"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                }
            }
            //--- Sentence initial - go with "reed"
            else
            {
                fMatch = true;

                TempPos = ListPos;
                ItemList.GetPrev( TempPos );
                TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                //--- Insert pron into word text - RAID #4746
                ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                ReadItem.Words[0].pWordText = 
                    (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                    (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                    wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                    (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
					ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                }
            }
        }
    }

    if ( !fMatch )
    {
        TempPos = ListPos;
        ItemList.GetPrev( TempPos );
        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
        //--- Default - go with past tense...
        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS2;

        //--- Insert pron into word text - RAID #4746
        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
        ReadItem.Words[0].pWordText = 
            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
			ReadItem.Words[0].ulWordLen = ulNumChars + 2;
        }
    }

    return hr;
} /* ReadDisambig */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\datenorm.cpp ===
#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

#pragma warning (disable : 4296)

/***********************************************************************************************
* IsNumericCompactDate *
*----------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a Date, and if so, which type.  
*
*   RegExp:
*       {[1-12]{'/' || '-' || '.'}[1-31]{'/' || '-' || '.'}[0-9999]} ||
*       {[1-31]{'/' || '-' || '.'}[1-12]{'/' || '-' || '.'}[0-9999]} ||
*       {[0-9999]{'/' || '-' || '.'}[1-12]{'/' || '-' || '.'}[1-31]}
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumericCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                            CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsNumericCompactDate" );

    HRESULT hr = S_OK;
    
    WCHAR *pFirstChunk = 0, *pSecondChunk = 0, *pThirdChunk = 0, *pLeftOver = 0, *pDelimiter = 0;
    ULONG ulFirst = 0;
    ULONG ulSecond = 0;
    ULONG ulThird = 0;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    bool bThree = false, bTwo = false;
    bool fMonthDayYear = false, fDayMonthYear = false, fYearMonthDay = false;

    //--- Max length of a string matching the regexp is 10 characters 
    if ( ulTokenLen > 10 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Get the preferred order of the compact Date 
        if ( Context != NULL )
        {
            if ( _wcsicmp( Context, L"Date_MDY" ) == 0 )
            {
                fMonthDayYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_DMY" ) == 0 )
            {
                fDayMonthYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_YMD" ) == 0 )
            {
                fYearMonthDay = true;
            }
            else
            {
                if ( m_eShortDateOrder & MONTH_DAY_YEAR )
                {
                    fMonthDayYear = true;
                }
                else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
                {
                    fDayMonthYear = true;
                }
                else
                {
                    fYearMonthDay = true;
                }
            }
        }
        else
        {
            if ( m_eShortDateOrder & MONTH_DAY_YEAR )
            {
                fMonthDayYear = true;
            }
            else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
            {
                fDayMonthYear = true;
            }
            else
            {
                fYearMonthDay = true;
            }
        }

        pFirstChunk = (WCHAR*) m_pNextChar;

        //----------------------------------------------
        // First Try To Get Three Numerical Values
        //----------------------------------------------

        ulFirst = my_wcstoul( pFirstChunk, &pSecondChunk );
        if ( pFirstChunk != pSecondChunk && 
             ( pSecondChunk - pFirstChunk ) <= 4 )
        {
            pDelimiter = pSecondChunk;
            if ( MatchDateDelimiter( &pSecondChunk ) )
            {
                ulSecond = my_wcstoul( pSecondChunk, &pThirdChunk );
                if ( pSecondChunk != pThirdChunk &&
                     ( pThirdChunk - pSecondChunk ) <= 4 )
                {
                    if ( *pThirdChunk == *pDelimiter &&
                         MatchDateDelimiter( &pThirdChunk ) )
                    {
                        ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                        if ( pThirdChunk != pLeftOver                               && 
                             pLeftOver == ( pFirstChunk + ulTokenLen ) &&
                             ( pLeftOver - pThirdChunk ) <= 4 )
                        {
                            //--- Successfully Matched { d+{'/' || '-' || '.'}d+{'/' || '-' || '.'}d+ } 
                            bThree = true;
                        }
                        else 
                        {
                            //--- Digit-String Delimiter Digit-String Delimiter non-digit cannot be a Date,
                            //--- nor can Digit-String Delimiter Digit-String Delimiter Digit-String String 
                            hr = E_INVALIDARG;
                        }
                    }
                    else
                    {
                        if ( pThirdChunk == m_pEndOfCurrItem )
                        {
                            //--- Successfully Matched { d+{'/' || '-' || '.'}d+ } 
                            bTwo = true;
                        }
                        else
                        {
                            //--- Digit-String Delimiter Digit-String non-delimiter cannot be a Date 
                            hr = E_INVALIDARG;
                        }
                    }
                }
            }
            else
            {
                //--- Digit-String followed by non-delimiter cannot be a Date 
                hr = E_INVALIDARG;
            }
        }

        //------------------------------------------------
        // Now Figure Out What To Do With The Values 
        //------------------------------------------------

        //--- Matched a Month, Day, and Year ---//
        if ( SUCCEEDED( hr ) && 
             bThree )
        {
            //--- Try to valiDate values 
            ULONG ulFirstChunkLength  = (ULONG)(pSecondChunk - pFirstChunk  - 1);
            ULONG ulSecondChunkLength = (ULONG)(pThirdChunk  - pSecondChunk - 1);
            ULONG ulThirdChunkLength  = (ULONG)(pLeftOver    - pThirdChunk);

            //--- Preferred order is Month Day Year 
            if (fMonthDayYear)
            {
                //--- Try Month Day Year, then Day Month Year, then Year Month Day 
                if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX ) && 
                     ( ulFirstChunkLength <= 3 )                    &&
                     ( DAYMIN <= ulSecond && ulSecond <= DAYMAX)    && 
                     ( ulSecondChunkLength <= 3 )                   &&
                     ( YEARMIN <= ulThird && ulThird <= YEARMAX)    && 
                     ( ulThirdChunkLength >= 2 ) )
                {
                    NULL;
                }
                else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )        && 
                          ( ulFirstChunkLength <= 3 )                       &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )      && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fMonthDayYear = false;
                    fDayMonthYear = true;
                }
                else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )      && 
                          ( ulFirstChunkLength >= 2 )                       &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( DAYMIN <= ulThird && ulThird <= DAYMAX )        && 
                          ( ulThirdChunkLength <= 3 ) )
                {
                    fMonthDayYear = false;
                    fYearMonthDay = true;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            } 
            //--- Preferred order is Day Month Year 
            else if ( fDayMonthYear )
            {
                //--- Try Day Month Year, then Month Day Year, then Year Month Day 
                if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )         && 
                     ( ulFirstChunkLength <= 3 )                        &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   && 
                     ( ulSecondChunkLength <= 3 )                       &&
                     ( YEARMIN <= ulThird && ulThird <= YEARMAX )       && 
                     ( ulThirdChunkLength >= 2 ) )
                {
                    NULL;
                }
                else if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX )    && 
                          ( ulFirstChunkLength <= 3 )                       &&
                          ( DAYMIN <= ulSecond && ulSecond <= DAYMAX )      && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )      && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fDayMonthYear = false;
                    fMonthDayYear = true;
                }                
                else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )      && 
                          ( ulFirstChunkLength >= 2 )                       &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( DAYMIN <= ulThird && ulThird <= DAYMAX )        && 
                          ( ulThirdChunkLength <= 3 ) )
                {
                    fDayMonthYear = false;
                    fYearMonthDay = true;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            //--- Preferred order is Year Month Day 
            else if (fYearMonthDay)
            {
                //--- Try Year Month Day, then Month Day Year, then Day Month Year 
                if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )      && 
                     ( ulFirstChunkLength >= 2 )                       &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                     ( ulSecondChunkLength <= 3 )                      &&
                     ( DAYMIN <= ulThird && ulThird <= DAYMAX )        && 
                     ( ulThirdChunkLength <= 3 ) )
                {
                    NULL;
                }
                else if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX )    && 
                          ( ulFirstChunkLength <= 3 )                       &&
                          ( DAYMIN <= ulSecond && ulSecond <= DAYMAX )      && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )      && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fYearMonthDay = false;
                    fMonthDayYear = true;
                }                
                else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )         && 
                          ( ulFirstChunkLength <= 3 )                        &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   && 
                          ( ulSecondChunkLength <= 3 )                       &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )       && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fYearMonthDay = false;
                    fDayMonthYear = true;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            //--- Fill out DateItemInfo structure appropriately.
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                    pItemNormInfo->Type = eDATE;
                    if ( fMonthDayYear )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulFirst;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pSecondChunk == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = ulSecondChunkLength;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pSecondChunk + 
                                                                                          ulSecondChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                    (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                            }
                        }
                    }
                    else if ( fDayMonthYear )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pFirstChunk == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = ulFirstChunkLength;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pFirstChunk + 
                                                                                          ulFirstChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                    (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                            }
                        }
                    }
                    else if ( fYearMonthDay )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pThirdChunk == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = ulThirdChunkLength;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pThirdChunk + 
                                                                                          ulThirdChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                    (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pFirstChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulFirstChunkLength;
                            }
                        }
                    }          
                }
            }
        }
        //--- Matched just a Month and Day, or a Month and Year ---//
        else if ( SUCCEEDED( hr ) &&
                  Context         &&
                  bTwo )
        {
            ULONG ulFirstChunkLength  = (ULONG)(pSecondChunk - pFirstChunk  - 1);
            ULONG ulSecondChunkLength = (ULONG)(pThirdChunk  - pSecondChunk);

            if ( _wcsicmp(Context, L"Date_MD") == 0 )
            {
                if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX )     && 
                     ( ulFirstChunkLength <= 2 )                        &&
                     ( DAYMIN <= ulSecond && ulSecond <= DAYMAX )       && 
                     ( ulSecondChunkLength <= 2 ) )
                {
                    //--- Successfully matched a month and day 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulFirst;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( pSecondChunk[0] == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pSecondChunk + 1;
                                ulSecondChunkLength--;
                            }
                            else 
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pSecondChunk;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver = ulSecondChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar  = 
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar + ulSecondChunkLength;
                        }
                    }

                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( _wcsicmp(Context, L"Date_DM") == 0 )
            {
                if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )         && 
                     ( ulFirstChunkLength <= 2 )                        &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   && 
                     ( ulSecondChunkLength <= 2 ) )
                {
                    //--- Successfully matched a month and day 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( m_pNextChar[0] == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pFirstChunk + 1;
                                ulFirstChunkLength--;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pFirstChunk;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver = ulFirstChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar  =
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar + ulFirstChunkLength;
                        }
                    }
                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( _wcsicmp(Context, L"Date_MY") == 0 )
            {
                if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX ) && 
                     ( ulFirstChunkLength <= 2 )                    &&
                     ( YEARMIN <= ulSecond && ulSecond <= YEARMAX ) &&
                     ( ulSecondChunkLength >= 2 ) )
                {
                    //--- Successfully matched a month and year 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex      = ulFirst;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear        = pSecondChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits  = ulSecondChunkLength;
                        }
                    }
                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( _wcsicmp(Context, L"Date_YM") == 0 )
            {
                if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )       && 
                     ( ulFirstChunkLength >= 2 )                        &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   &&
                     ( ulSecondChunkLength <= 2 ) )
                {
                    //--- Successfully matched a month and year 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex      = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear        = pFirstChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits  = ulFirstChunkLength;
                        }
                    }
                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            //--- not a date unless context specifies...
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    
    return hr;
} /* IsNumericCompactDate */

/***********************************************************************************************
* IsMonthStringCompactDate *
*--------------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a Date with a string for the month, and if so, which type.  
*
*   RegExp:
*       {[MonthString]{'/' || '-' || '.'}[1-31]{'/' || '-' || '.'}[0-9999]} ||
*       {[1-31]{'/' || '-' || '.'}[MonthString]{'/' || '-' || '.'}[0-9999]} ||
*       {[0-9999]{'/' || '-' || '.'}[MonthString]{'/' || '-' || '.'}[1-31]}
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsMonthStringCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                                CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "DateNorm.cpp IsMonthStringCompactDate" );

    HRESULT hr = S_OK;
    WCHAR *pFirstChunk = 0, *pSecondChunk = 0, *pThirdChunk = 0, *pLeftOver = 0;
    ULONG ulFirst = 0;
    ULONG ulSecond = 0;
    ULONG ulThird = 0;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    ULONG ulFirstChunkLength = 0, ulSecondChunkLength = 0, ulThirdChunkLength = 0;
    bool fMonthDayYear = false, fDayMonthYear = false, fYearMonthDay = false;

    //--- Max length of a Date matching this regexp is 17 characters 
    if ( ulTokenLen > 17 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Get preferred order of Month, Day, and Year for this user 
        if (Context != NULL)
        {
            if ( _wcsicmp( Context, L"Date_MDY" ) == 0 )
            {
                fMonthDayYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_DMY" ) == 0 )
            {
                fDayMonthYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_YMD" ) == 0 )
            {
                fYearMonthDay = true;
            }
            else
            {
                if ( m_eShortDateOrder & MONTH_DAY_YEAR )
                {
                    fMonthDayYear = true;
                }
                else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
                {
                    fDayMonthYear = true;
                }
                else
                {
                    fYearMonthDay = true;
                }
            }
        }
        else
        {
            if ( m_eShortDateOrder & MONTH_DAY_YEAR )
            {
                fMonthDayYear = true;
            }
            else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
            {
                fDayMonthYear = true;
            }
            else
            {
                fYearMonthDay = true;
            }
        }

        pFirstChunk = (WCHAR*) m_pNextChar;
        pSecondChunk = pFirstChunk;

        //--- Try MonthString-Day-Year format 
        if ( iswalpha( *pFirstChunk ) )
        {
            ulFirst = MatchMonthString( pSecondChunk, ulTokenLen );
            if ( ulFirst )
            {
                ulFirstChunkLength = (ULONG)(pSecondChunk - pFirstChunk);
                if ( MatchDateDelimiter( &pSecondChunk ) )
                {
                    pThirdChunk = pSecondChunk;
                    ulSecond = my_wcstoul( pSecondChunk, &pThirdChunk );
                    if ( pSecondChunk != pThirdChunk &&
                         pThirdChunk - pSecondChunk <= 2 )
                    {
                        ulSecondChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                        if ( MatchDateDelimiter( &pThirdChunk ) )
                        {
                            ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                            if ( pThirdChunk != pLeftOver &&
                                 pLeftOver - pThirdChunk <= 4 )
                            {
                                ulThirdChunkLength = (ULONG)(pLeftOver - pThirdChunk);
                                //--- May have matched a month, day and year - valiDate values 
                                if ( ( DAYMIN <= ulSecond && ulSecond <= DAYMAX ) &&
                                     ( ulSecondChunkLength <= 2 )                 &&               
                                     ( YEARMIN <= ulThird && ulThird <= YEARMAX ) &&
                                     ( ulThirdChunkLength >= 2 ) )
                                {
                                    //--- Successfully matched a month, day and year 
                                    fMonthDayYear = true;
                                    fDayMonthYear = false;
                                    fYearMonthDay = false;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                        else
                        {
                            if ( !Context ||
                                 ( Context &&
                                   _wcsicmp( Context, L"Date_MD" ) == 0 ) )
                            {
                                if ( ( DAYMIN <= ulSecond && ulSecond <= DAYMAX ) &&
                                     ( ulSecondChunkLength <= 2 ) )
                                {
                                    fMonthDayYear = true;
                                    fDayMonthYear = false;
                                    fYearMonthDay = false;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    fYearMonthDay = true;
                                    pFirstChunk   = pSecondChunk;
                                    ulFirstChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                                    ulSecond      = ulFirst;
                                    pThirdChunk   = NULL;
                                }
                            }
                            else if ( Context && 
                                      _wcsicmp( Context, L"Date_MY" ) == 0 )
                            {
                                if ( ( YEARMIN <= ulSecond && ulSecond <= YEARMAX ) &&
                                     ( ulSecondChunkLength <= 4 ) )
                                {
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    fYearMonthDay = true;
                                    pFirstChunk   = pSecondChunk;
                                    ulFirstChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                                    ulSecond      = ulFirst;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                    }
                    else if ( pSecondChunk != pThirdChunk &&
                              pThirdChunk - pSecondChunk <= 4 )
                    {
                        if ( ( YEARMIN <= ulSecond && ulSecond <= YEARMAX ) )
                        {
                            fMonthDayYear = false;
                            fDayMonthYear = false;
                            fYearMonthDay = true;
                            pFirstChunk   = pSecondChunk;
                            ulFirstChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                            ulSecond = ulFirst;
                            pThirdChunk   = NULL;
                        }
                        else
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        //--- Try Day-MonthString-Year and Year-MonthString-Day Formats 
        else if ( isdigit( *pFirstChunk ) )
        {
            ulFirst = my_wcstoul( pFirstChunk, &pSecondChunk );
            if ( pFirstChunk != pSecondChunk &&
                 pSecondChunk - pFirstChunk <= 4 )
            {
                ulFirstChunkLength = (ULONG)(pSecondChunk - pFirstChunk);
                if ( MatchDateDelimiter( &pSecondChunk ) )
                {
                    pThirdChunk = pSecondChunk;
                    ulSecond = MatchMonthString( pThirdChunk, ulTokenLen - ulFirstChunkLength );
                    if ( ulSecond )
                    {
                        ulSecondChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                        if ( MatchDateDelimiter( &pThirdChunk ) )
                        {
                            ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                            if ( pThirdChunk != pLeftOver &&
                                 pLeftOver - pThirdChunk <= 4 )
                            {
                                ulThirdChunkLength = (ULONG)(pLeftOver - pThirdChunk);
                                //--- May have matched a month, day, and year - valiDate values                                 
                                if ( fDayMonthYear || 
                                     fMonthDayYear )
                                {
                                    //--- Preferred format is Month Day Year, or Day Month Year - in either case 
                                    //---     Day Month Year is preferable to Year Month Day 
                                    if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )     && 
                                         ( ulFirstChunkLength <= 2 )                    &&
                                         ( YEARMIN <= ulThird && ulThird <= YEARMAX )   &&
                                         ( ulThirdChunkLength >= 2 ) )
                                    {
                                        //--- Successfully matched a day, month and year 
                                        fDayMonthYear = true;
                                        fMonthDayYear = false;
                                        fYearMonthDay = false;
                                    }
                                    else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )  &&
                                              ( ulFirstChunkLength >= 2 )                   &&
                                              ( DAYMIN <= ulThird && ulThird <= DAYMAX )    &&
                                              ( ulThirdChunkLength <= 2 ) )
                                    {
                                        //--- Successfully matched a year, month and day 
                                        fYearMonthDay = true;
                                        fMonthDayYear = false;
                                        fDayMonthYear = false;
                                    }
                                    else
                                    {
                                        hr = E_INVALIDARG;
                                    }
                                }
                                else // fYearMonthDay
                                {
                                    //--- Preferred format is Year Month Day 
                                    if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )   &&
                                         ( ulFirstChunkLength >= 2 )                    &&
                                         ( DAYMIN <= ulThird && ulThird <= DAYMAX )     &&
                                         ( ulThirdChunkLength <= 2 ) )
                                    {
                                        //--- Successfully matched a year, month, and day
                                        fYearMonthDay = true;
                                        fMonthDayYear = false;
                                        fDayMonthYear = false;
                                    }
                                    else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )    && 
                                              ( ulFirstChunkLength <= 2 )                   &&
                                              ( YEARMIN <= ulThird && ulThird <= YEARMAX )  &&
                                              ( ulThirdChunkLength >= 2 ) )
                                    {
                                        //--- Successfully matched a day, month, and year
                                        fDayMonthYear = true;
                                        fMonthDayYear = false;
                                        fYearMonthDay = false;
                                    }
                                    else
                                    {
                                        hr = E_INVALIDARG;
                                    }
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                        //--- Matched two - either Day-Monthstring or Year-Monthstring
                        else
                        {
                            if ( !Context ||
                                 ( Context &&
                                   _wcsicmp( Context, L"Date_DM" ) == 0 ) )
                            {
                                //--- Preferred format is Month Day Year, or Day Month Year - in either case 
                                //---     Day Month Year is preferable to Year Month Day 
                                if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )     && 
                                     ( ulFirstChunkLength <= 2 ) )
                                {
                                    //--- Successfully matched a day, month and year 
                                    fDayMonthYear = true;
                                    fMonthDayYear = false;
                                    fYearMonthDay = false;
                                    pThirdChunk   = NULL;
                                }
                                else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )  &&
                                          ( ulFirstChunkLength <= 4 ) )
                                {
                                    //--- Successfully matched a year, month and day 
                                    fYearMonthDay = true;
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else if ( Context &&
                                      _wcsicmp( Context, L"Date_YM" ) == 0 )
                            {
                                //--- Preferred format is Year Month Day 
                                if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )   &&
                                     ( ulFirstChunkLength <= 4 ) )
                                {
                                    //--- Successfully matched a year, month, and day
                                    fYearMonthDay = true;
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    pThirdChunk   = NULL;
                                }
                                else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )    && 
                                          ( ulFirstChunkLength <= 2 ) )
                                {
                                    //--- Successfully matched a day, month, and year
                                    fDayMonthYear = true;
                                    fMonthDayYear = false;
                                    fYearMonthDay = false;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Fill out DateItemInfo structure appropriately.
    if ( SUCCEEDED( hr ) )
    {
        pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
            pItemNormInfo->Type = eDATE;
            if ( fMonthDayYear )
            {
                ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulFirst;
                ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                            (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                    if ( ulSecondChunkLength == 2 )
                    {
                        if ( *pSecondChunk != L'0' )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 2;
                        }
                        else
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk + 1;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                        }
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pSecondChunk + 2;
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pSecondChunk;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver  = 1;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar   = pSecondChunk + 1;
                    }
                    if ( pThirdChunk )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear =
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                        }
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = NULL;
                    }
                }
            }
            else if ( fDayMonthYear )
            {
                ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                            (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                    if ( ulFirstChunkLength == 2 )
                    {
                        if ( *pFirstChunk != L'0' )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 2;
                        }
                        else
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk + 1;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                        }
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pFirstChunk + 2;
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pFirstChunk;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver  = 1;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar   = pFirstChunk + 1;
                    }
                    if ( pThirdChunk )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear =
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                        }
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = NULL;
                    }
                }
            }
            else if ( fYearMonthDay )
            {
                ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                if ( SUCCEEDED( hr ) )
                {
                    if ( pThirdChunk )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( ulThirdChunkLength == 2 )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pThirdChunk != L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 2;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pThirdChunk + 2;
                        }
                        else
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pThirdChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver  = 1;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar   = pThirdChunk + 1;
                        }
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = NULL;
                    }
                    ( (TTSDateItemInfo*) pItemNormInfo )->pYear =
                            (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pFirstChunk;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulFirstChunkLength;
                    }
                }
            }
            else
            {
                //--- should never get here.
                hr = E_UNEXPECTED;
            }
        }
    }
              
    return hr;
} /* IsMonthStringCompactDate */

/***********************************************************************************************
* IsLongFormDate_DMDY *
*---------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a long form Date.
*
*   RegExp:
*       [[DayString][,]?]? [MonthString][,]? [Day][,]? [Year]?
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsLongFormDate_DMDY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                           CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsLongFormDate_DMDY" );
    HRESULT hr = S_OK;
    WCHAR *pDayString = NULL, *pMonthString = NULL, *pDay = NULL, *pYear = NULL;
    ULONG ulDayLength = 0, ulYearLength = 0;
    long lDayString = -1, lMonthString = -1, lDay = 0, lYear = 0;
    const WCHAR *pStartChar = m_pNextChar, *pEndOfItem = m_pEndOfCurrItem, *pEndChar = m_pEndChar;
    const WCHAR *pTempEndChar = NULL, *pTempEndOfItem = NULL;
    const SPVTEXTFRAG* pFrag = m_pCurrFrag, *pTempFrag = NULL;
    const SPVSTATE *pDayStringXMLState = NULL, *pMonthStringXMLState = NULL, *pDayXMLState = NULL;
    const SPVSTATE *pYearXMLState = NULL;
    CItemList PostDayStringList, PostMonthStringList, PostDayList;
    BOOL fNoYear = false;

    //--- Try to match Day String
    pDayString   = (WCHAR*) pStartChar;
    lDayString   = MatchDayString( pDayString, (WCHAR*) pEndOfItem );

    //--- Failed to match a Day String
    if ( lDayString == 0 )
    {
        pDayString   = NULL;
    }
    //--- Matched a Day String, but it wasn't by itself or followed by a comma
    else if ( pDayString != pEndOfItem &&
              ( pDayString    != pEndOfItem - 1 ||
                *pEndOfItem != L',' ) )
    {
        hr = E_INVALIDARG;
    }
    //--- Matched a Day String - save XML State and move ahead in text
    else
    {
        pDayString         = (WCHAR*) pStartChar;
        pDayStringXMLState = &pFrag->State;

        pStartChar = pEndOfItem;
        if ( *pStartChar == L',' )
        {
            pStartChar++;
        }
        hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayStringList );
        if ( !pStartChar &&
             SUCCEEDED( hr ) )
        {
            hr = E_INVALIDARG;
        }
        else if ( pStartChar &&
                  SUCCEEDED( hr ) )
        {
            pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
        }
    }

    //--- Try to match Month String
    if ( SUCCEEDED( hr ) )
    {
        pMonthString = (WCHAR*) pStartChar;
        lMonthString = MatchMonthString( pMonthString, (ULONG)(pEndOfItem - pMonthString) );

        //--- Failed to match Month String, or Month String was not by itself...
        if ( !lMonthString ||
             ( pMonthString != pEndOfItem &&
               ( pMonthString  != pEndOfItem - 1 ||
                 *pMonthString != L',' ) ) )
        {
            hr = E_INVALIDARG;
        }
        //--- Matched a Month String - save XML State and move ahead in text
        else
        {
            pMonthString         = (WCHAR*) pStartChar;
            pMonthStringXMLState = &pFrag->State;

            pStartChar = pEndOfItem;
            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostMonthStringList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr = E_INVALIDARG;
            }
            else if ( pStartChar &&
                      SUCCEEDED( hr ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                //--- Strip trailing punctuation, etc. since the next token could be the last one if
                //--- this is just a Monthstring and Day...
                while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                        IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                        IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                        IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                {
                    if ( *(pEndOfItem - 1) != L',' )
                    {
                        fNoYear = true;
                    }
                    pEndOfItem--;
                }
            }
        }
    }

    //--- Try to match Day
    if ( SUCCEEDED( hr ) )
    {
        lDay = my_wcstoul( pStartChar, &pDay );
        //--- Matched a Day - save XML State and move ahead in text
        if ( ( DAYMIN <= lDay && lDay <= DAYMAX ) &&
             pDay - pStartChar <= 2               &&
             ( pDay == pEndOfItem                 || 
              ( pDay == (pEndOfItem - 1) && *pDay == L',' ) ) )
        {
            if ( pDay == pEndOfItem )
            {
                ulDayLength = (ULONG)(pEndOfItem - pStartChar);
            }
            else if ( pDay == pEndOfItem - 1 )
            {
                ulDayLength = (ULONG)((pEndOfItem - 1) - pStartChar);
            }
            pDay         = (WCHAR*) pStartChar;
            pDayXMLState = &pFrag->State;

            if ( !fNoYear )
            {
                //--- Save pointers, in case there is no year present
                pTempEndChar   = pEndChar;
                pTempEndOfItem = pEndOfItem;
                pTempFrag      = pFrag;

                if ( *pEndOfItem == L',' )
                {
                    pStartChar = pEndOfItem + 1;
                }
                else
                {
                    pStartChar = pEndOfItem;
                }
                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayList );
                if ( !pStartChar &&
                     SUCCEEDED( hr ) )
                {
                    fNoYear = true;
                    pYear   = NULL;
                }
                else if ( pStartChar &&
                          ( SUCCEEDED( hr ) ) )
                {
                    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    //--- Strip trailing punctuation, since the next token will be the last one
                    //--- if this is Monthstring, Day, Year
                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                    {
                        pEndOfItem--;
                    }
                }
            }
        }
        //--- Failed to match a day
        else if ( ( YEARMIN <= lDay && lDay <= YEARMAX ) &&
                  pDay - pStartChar <= 4                  &&
                  pDay == pEndOfItem )
        {
            //--- Successfully matched Month String and Year
            pYearXMLState = &pFrag->State;
            ulYearLength  = (ULONG)(pEndOfItem - pStartChar);
            pYear         = (WCHAR*) pStartChar;
            //--- Don't try to match a year again
            fNoYear       = true;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Try to match Year
    if ( SUCCEEDED( hr ) &&
         !fNoYear )
    {
        lYear = my_wcstoul( pStartChar, &pYear );
        //--- Matched a Year
        if ( ( YEARMIN <= lYear && lYear <= YEARMAX ) &&
             pYear - pStartChar <= 4                  &&
             pYear == pEndOfItem )
        {
            //--- Successfully matched Month String, Day, and Year (and possibly Day String)
            pYearXMLState = &pFrag->State;
            ulYearLength  = (ULONG)(pEndOfItem - pStartChar);
            pYear         = (WCHAR*) pStartChar;
        }
        else
        {
            //--- Failed to match Year - replace pointers with previous values
            pEndChar   = pTempEndChar;
            pEndOfItem = pTempEndOfItem;
            pFrag      = pTempFrag;
            pYear      = NULL;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof(TTSWord) );
        Word.eWordPartOfSpeech = MS_Unknown;

        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eDATE_LONGFORM;

            //--- Insert Day String, if present
            if ( pDayString )
            {
                Word.pXmlState  = pDayStringXMLState;
                Word.pWordText  = g_days[lDayString - 1].pStr;
                Word.ulWordLen  = g_days[lDayString - 1].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }

            //--- Insert Post Day String XML States
            while ( !PostDayStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayStringList.RemoveHead() ).Words[0] );
            }

            //--- Insert Month String
            Word.pXmlState  = pMonthStringXMLState;
            Word.pWordText  = g_months[lMonthString - 1].pStr;
            Word.ulWordLen  = g_months[lMonthString - 1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert Post Month String XML State
            while ( !PostMonthStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostMonthStringList.RemoveHead() ).Words[0] );
            }

            SPLISTPOS WordListPos = WordList.GetTailPosition();

            //--- Expand Day
            if ( ulDayLength == 1 )
            {
                NumberGroup Garbage;
                ExpandDigitOrdinal( *pDay, Garbage, WordList );
            }
            else if ( ulDayLength == 2 )
            {
                NumberGroup Garbage;
                ExpandTwoOrdinal( pDay, Garbage, WordList );
            }

            //--- Clean Up Day XML States
            WordList.GetNext( WordListPos );
            while ( WordListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( WordListPos );
                TempWord.pXmlState = pDayXMLState;
            }

            //--- Insert Post Day XML State
            while ( !PostDayList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayList.RemoveHead() ).Words[0] );
            }

            WordListPos = WordList.GetTailPosition();

            //--- Expand Year, if present
            if ( pYear )
            {
                TTSYearItemInfo TempYearInfo;
                TempYearInfo.pYear       = pYear;
                TempYearInfo.ulNumDigits = ulYearLength;
                hr = ExpandYear( &TempYearInfo, WordList );

                if ( SUCCEEDED( hr ) )
                {
                    //--- Clean Up Year XML States
                    WordList.GetNext( WordListPos );
                    while ( WordListPos )
                    {
                        TTSWord& TempWord  = WordList.GetNext( WordListPos );
                        TempWord.pXmlState = pYearXMLState;
                    }
                }
            }
            //--- Advance pointers
            m_pCurrFrag      = pFrag;
            m_pEndChar       = pEndChar;
            m_pEndOfCurrItem = pEndOfItem;
        }
    }

    return hr;
} /* IsLongFormDate_DMDY */

/***********************************************************************************************
* IsLongFormDate_DDMY *
*---------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a long form Date.
*
*   RegExp:
*       [[DayString][,]?]? [Day][,]? [MonthString][,]? [Year]?
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsLongFormDate_DDMY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                           CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsLongFormDate_DDMY" );
    HRESULT hr = S_OK;
    WCHAR *pDayString = NULL, *pMonthString = NULL, *pDay = NULL, *pYear = NULL;
    ULONG ulDayLength = 0, ulYearLength = 0;
    long lDayString = -1, lMonthString = -1, lDay = 0, lYear = 0;
    const WCHAR *pStartChar = m_pNextChar, *pEndOfItem = m_pEndOfCurrItem, *pEndChar = m_pEndChar;
    const WCHAR *pTempEndChar = NULL, *pTempEndOfItem = NULL;
    const SPVTEXTFRAG* pFrag = m_pCurrFrag, *pTempFrag = NULL;
    const SPVSTATE *pDayStringXMLState = NULL, *pMonthStringXMLState = NULL, *pDayXMLState = NULL;
    const SPVSTATE *pYearXMLState = NULL;
    CItemList PostDayStringList, PostMonthStringList, PostDayList;
    BOOL fNoYear = false;

    //--- Try to match Day String
    pDayString   = (WCHAR*) pStartChar;
    lDayString   = MatchDayString( pDayString, (WCHAR*) pEndOfItem );

    //--- Failed to match a Day String
    if ( lDayString == 0 )
    {
        pDayString   = NULL;
    }
    //--- Matched a Day String, but it wasn't by itself or followed by a comma
    else if ( pDayString != pEndOfItem &&
              ( pDayString    != pEndOfItem - 1 ||
                *pEndOfItem != L',' ) )
    {
        hr = E_INVALIDARG;
    }
    //--- Matched a Day String - save XML State and move ahead in text
    else
    {
        pDayString         = (WCHAR*) pStartChar;
        pDayStringXMLState = &pFrag->State;

        pStartChar = pEndOfItem;
        if ( *pStartChar == L',' )
        {
            pStartChar++;
        }
        hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayStringList );
        if ( !pStartChar &&
             SUCCEEDED( hr ) )
        {
            hr = E_INVALIDARG;
        }
        else if ( pStartChar &&
                  SUCCEEDED( hr ) )
        {
            pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
        }
    }

    //--- Try to match Day
    if ( SUCCEEDED( hr ) )
    {
        lDay = my_wcstoul( pStartChar, &pDay );
        //--- Matched a Day - save XML State and move ahead in text
        if ( ( DAYMIN <= lDay && lDay <= DAYMAX ) &&
             pDay - pStartChar <= 2               &&
             ( pDay == pEndOfItem                 || 
              ( pDay == (pEndOfItem - 1) && *pDay == L',' ) ) )
        {
            if ( pDay == pEndOfItem )
            {
                ulDayLength = (ULONG)(pEndOfItem - pStartChar);
            }
            else if ( pDay == pEndOfItem - 1 )
            {
                ulDayLength = (ULONG)((pEndOfItem - 1) - pStartChar);
            }
            pDay         = (WCHAR*) pStartChar;
            pDayXMLState = &pFrag->State;

            if ( *pEndOfItem == L',' )
            {
                pStartChar = pEndOfItem + 1;
            }
            else
            {
                pStartChar = pEndOfItem;
            }

            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr = E_INVALIDARG;
            }
            else if ( pStartChar &&
                      ( SUCCEEDED( hr ) ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                //--- Strip trailing punctuation, since the next token will be the last one
                //--- if this is Monthstring, Day, Year
                while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                        IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                        IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                        IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                {
                    if ( *(pEndOfItem - 1) != L',' )
                    {
                        fNoYear = true;
                    }
                    pEndOfItem--;
                }
            }
        }
        //--- Failed to match a day
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Try to match Month String
    if ( SUCCEEDED( hr ) )
    {
        pMonthString = (WCHAR*) pStartChar;
        lMonthString = MatchMonthString( pMonthString, (ULONG)(pEndOfItem - pMonthString) );

        //--- Failed to match Month String, or Month String was not by itself...
        if ( !lMonthString ||
             ( pMonthString != pEndOfItem &&
               ( pMonthString  != pEndOfItem - 1 ||
                 *pMonthString != L',' ) ) )
        {
            hr = E_INVALIDARG;
        }
        //--- Matched a Month String - save XML State and move ahead in text
        else
        {
            pMonthString         = (WCHAR*) pStartChar;
            pMonthStringXMLState = &pFrag->State;

            if ( !fNoYear )
            {
                //--- Save pointers, in case there is no year present
                pTempEndChar   = pEndChar;
                pTempEndOfItem = pEndOfItem;
                pTempFrag      = pFrag;

                if ( *pEndOfItem == L',' )
                {
                    pStartChar = pEndOfItem + 1;
                }
                else
                {
                    pStartChar = pEndOfItem;
                }

                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostMonthStringList );
                if ( !pStartChar &&
                     SUCCEEDED( hr ) )
                {
                    fNoYear = true;
                    pYear   = NULL;
                }
                else if ( pStartChar &&
                          SUCCEEDED( hr ) )
                {
                    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    //--- Strip trailing punctuation, etc. since the next token could be the last one if
                    //--- this is Day, Monthstring, Year
                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                    {
                        pEndOfItem--;
                    }
                }
            }
        }
    }

    //--- Try to match Year
    if ( SUCCEEDED( hr ) &&
         !fNoYear )
    {
        lYear = my_wcstoul( pStartChar, &pYear );
        //--- Matched a Year
        if ( ( YEARMIN <= lYear && lYear <= YEARMAX ) &&
             pYear - pStartChar <= 4                  &&
             pYear == pEndOfItem )
        {
            //--- Successfully matched Month String, Day, and Year (and possibly Day String)
            pYearXMLState = &pFrag->State;
            ulYearLength  = (ULONG)(pEndOfItem - pStartChar);
            pYear         = (WCHAR*) pStartChar;
        }
        else
        {
            //--- Failed to match Year - replace pointers with previous values
            pEndChar   = pTempEndChar;
            pEndOfItem = pTempEndOfItem;
            pFrag      = pTempFrag;
            pYear      = NULL;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof(TTSWord) );
        Word.eWordPartOfSpeech = MS_Unknown;

        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eDATE_LONGFORM;

            //--- Insert Day String, if present
            if ( pDayString )
            {
                Word.pXmlState  = pDayStringXMLState;
                Word.pWordText  = g_days[lDayString - 1].pStr;
                Word.ulWordLen  = g_days[lDayString - 1].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }

            //--- Insert Post Day String XML States
            while ( !PostDayStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayStringList.RemoveHead() ).Words[0] );
            }

            //--- Insert Month String
            Word.pXmlState  = pMonthStringXMLState;
            Word.pWordText  = g_months[lMonthString - 1].pStr;
            Word.ulWordLen  = g_months[lMonthString - 1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert Post Month String XML State
            while ( !PostMonthStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostMonthStringList.RemoveHead() ).Words[0] );
            }

            SPLISTPOS WordListPos = WordList.GetTailPosition();

            //--- Expand Day
            if ( ulDayLength == 1 )
            {
                NumberGroup Garbage;
                ExpandDigitOrdinal( *pDay, Garbage, WordList );
            }
            else if ( ulDayLength == 2 )
            {
                NumberGroup Garbage;
                ExpandTwoOrdinal( pDay, Garbage, WordList );
            }

            //--- Clean Up Day XML States
            WordList.GetNext( WordListPos );
            while ( WordListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( WordListPos );
                TempWord.pXmlState = pDayXMLState;
            }

            //--- Insert Post Day XML State
            while ( !PostDayList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayList.RemoveHead() ).Words[0] );
            }

            WordListPos = WordList.GetTailPosition();

            //--- Expand Year, if present
            if ( pYear )
            {
                TTSYearItemInfo TempYearInfo;
                TempYearInfo.pYear       = pYear;
                TempYearInfo.ulNumDigits = ulYearLength;
                hr = ExpandYear( &TempYearInfo, WordList );

                if ( SUCCEEDED( hr ) )
                {
                    //--- Clean Up Year XML States
                    WordList.GetNext( WordListPos );
                    while ( WordListPos )
                    {
                        TTSWord& TempWord  = WordList.GetNext( WordListPos );
                        TempWord.pXmlState = pYearXMLState;
                    }
                }
            }
            //--- Advance pointers
            m_pCurrFrag      = pFrag;
            m_pEndChar       = pEndChar;
            m_pEndOfCurrItem = pEndOfItem;
        }
    }

    return hr;
} /* IsLongFormDate_DMDY */

/***********************************************************************************************
* ExpandDate *
*------------*
*   Description:
*       Expands Items previously determined to be of type Date by IsNumericCompactDate, 
*   IsMonthStringCompactDate, or IsTwoValueDate.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandDate( TTSDateItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDate" );
    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Insert DayString, if present.
    if ( pItemInfo->ulDayIndex )
    {
        Word.pWordText  = g_days[pItemInfo->ulDayIndex - 1].pStr;
        Word.ulWordLen  = g_days[pItemInfo->ulDayIndex - 1].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    //--- Insert Month 
    Word.pWordText  = g_months[pItemInfo->ulMonthIndex - 1].pStr;
    Word.ulWordLen  = g_months[pItemInfo->ulMonthIndex - 1].Len;
    Word.pLemma     = Word.pWordText;
    Word.ulLemmaLen = Word.ulWordLen;
    WordList.AddTail( Word );

    //--- Expand Day, if present.
    if ( pItemInfo->pDay )
    {
        if ( pItemInfo->pDay->lLeftOver == 1 )
        {
            NumberGroup Garbage;
            ExpandDigitOrdinal( *pItemInfo->pDay->pStartChar, Garbage, WordList );
        }
        else if ( pItemInfo->pDay->lLeftOver == 2 )
        {
            NumberGroup Garbage;
            ExpandTwoOrdinal( pItemInfo->pDay->pStartChar, Garbage, WordList );
        }
    }

    //--- Expand Year, if present.
    if ( pItemInfo->pYear )
    {
        ExpandYear( pItemInfo->pYear, WordList );
    }
    return hr;
} /* ExpandDate_Standard */

/***********************************************************************************************
* ExpandYear *
*-------------*
*   Description:
*       Expands four digit strings into words in groups of two, and inserts them into Item List 
*   at ListPos.  Thus 1999 come out as "nineteen ninety nine" rather than "one thousand nine
*   hundred ninety nine"...
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandYear( TTSYearItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandYear" );

    // 1000 - 9999
    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    NumberGroup Garbage;

    switch ( pItemInfo->ulNumDigits )
    {
    case 2:

        //--- Expand as "two thousand" if the two digits are both zeroes.
        if ( pItemInfo->pYear[0] == L'0' &&
             pItemInfo->pYear[1] == L'0' )
        {
            //--- Insert "two".
            Word.pWordText  = g_ones[2].pStr;
            Word.ulWordLen  = g_ones[2].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert "thousand".
            Word.pWordText  = g_quantifiers[1].pStr;
            Word.ulWordLen  = g_quantifiers[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        //--- Expand as "oh number" if the first digit is zero.
        else if ( pItemInfo->pYear[0] == L'0' )
        {
            Word.pWordText  = g_O.pStr;
            Word.ulWordLen  = g_O.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            ExpandDigit( pItemInfo->pYear[1], Garbage, WordList );
        }
        //--- Otherwise just expand as a two digit cardinal number
        else
        {
            ExpandTwoDigits( pItemInfo->pYear, Garbage, WordList );
        }
        break;

    case 3:

        //--- Expand as a three digit cardinal number;
        ExpandThreeDigits( pItemInfo->pYear, Garbage, WordList );
        break;

    case 4:

        //--- If of form "[x]00[y]" expand as "x thousand y", or just "x thousand" if y is also zero.
        if ( pItemInfo->pYear[1] == L'0' &&
             pItemInfo->pYear[2] == L'0' &&
             pItemInfo->pYear[0] != L'0' )
        {
            //--- "x" 
            ExpandDigit( pItemInfo->pYear[0], Garbage, WordList );

            //--- "thousand".
            Word.pWordText  = g_quantifiers[1].pStr;
            Word.ulWordLen  = g_quantifiers[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- "y" 
            if ( pItemInfo->pYear[3] != L'0' )
            {
                ExpandDigit( pItemInfo->pYear[3], Garbage, WordList );
            }
        }
        // Otherwise...
        else
        {
            //--- Expand first two digits - e.g. "nineteen"
            ExpandTwoDigits( pItemInfo->pYear, Garbage, WordList );

            //--- Expand last two digits - e.g. "nineteen", "hundred", or "oh nine".
            if ( pItemInfo->pYear[2] != '0' )
            {
                //--- the tens is not zero - e.g. 1919 -> "nineteen nineteen" 
                ExpandTwoDigits( pItemInfo->pYear + 2, Garbage, WordList );
            }
            else if ( pItemInfo->pYear[3] == '0' )
            {
                //--- tens and ones are both zero - expand as "hundred", e.g. 1900 -> "nineteen hundred" 
                Word.pWordText  = g_quantifiers[0].pStr;
                Word.ulWordLen  = g_quantifiers[0].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            else
            {
                //--- just the tens is zero, expand as "oh x" - e.g. 1909 -> "nineteen oh nine", 
                //---   unless both thousands and hundreds were also zero - e.g. 0002 -> "two"
                if ( pItemInfo->pYear[0] != '0' ||
                     pItemInfo->pYear[1] != '0' )
                {
                    Word.pWordText  = g_O.pStr;
                    Word.ulWordLen  = g_O.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                ExpandDigit( pItemInfo->pYear[3], Garbage, WordList );
            }
        }
    }
    return hr;
} /* ExpandYear */

/***********************************************************************************************
* IsDecade *
*----------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a Decade.
*
*   RegExp:
*       { ddd0s || d0s || 'd0s || ddd0's || d0's }
*   
*   Types assigned:
*       Decade
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsDecade( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsDecade" );

    HRESULT hr = S_OK;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);

    if ( ulTokenLen < 3 ||
         ulTokenLen > 6 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        switch ( ulTokenLen )
        {

        case 6:
            if ( m_pNextChar[5] == L's'     &&
                 m_pNextChar[4] == L'\''     &&
                 m_pNextChar[3] == L'0'    &&
                 iswdigit( m_pNextChar[2] ) &&
                 iswdigit( m_pNextChar[1] ) &&
                 iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form ddd0's
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = m_pNextChar;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[2] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        case 5:
            if ( m_pNextChar[4] == L's'     &&
                 m_pNextChar[3] == L'0'     &&
                 iswdigit( m_pNextChar[2] ) &&
                 iswdigit( m_pNextChar[1] ) &&
                 iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form ddd0s
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = m_pNextChar;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[2] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        case 4:
            if ( m_pNextChar[3] == L's'     &&
                 m_pNextChar[2] == L'0'     &&
                 iswdigit( m_pNextChar[1] ) &&
                 m_pNextChar[0] == L'\'' )
            {
                //--- Decade of form 'd0s
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = NULL;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[1] - L'0';
                }
            }
            else if ( m_pNextChar[3] == L's'  &&
                      m_pNextChar[2] == L'\'' &&
                      m_pNextChar[1] == L'0'  &&
                      iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form d0's
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = NULL;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[0] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        case 3:
            if ( m_pNextChar[2] == L's' &&
                 m_pNextChar[1] == L'0' &&
                 iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form d0s
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = NULL;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[0] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        default:
            hr = E_INVALIDARG;
            break;
        }
    }            
    
    return hr;
} /* IsDecade */

/***********************************************************************************************
* ExpandDecade *
*--------------*
*   Description:
*       Expands Items previously determined to be of type Decade by IsDecade.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandDecade( TTSDecadeItemInfo* pItemInfo, CWordList& WordList )
{
    HRESULT hr = S_OK;
    BOOL fDone = false;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Four digit form 
    if ( pItemInfo->pCentury )
    {
        //--- Cover special cases first 

        //--- 00dds 
        if ( pItemInfo->pCentury[0] == '0' &&
             pItemInfo->pCentury[1] == '0' )
        {
            //--- 0000s - expand as "zeroes"
            if ( pItemInfo->ulDecade == 0 )
            {
                Word.pWordText  = g_Zeroes.pStr;
                Word.ulWordLen  = g_Zeroes.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                fDone = true;
            }
            //--- 00d0s 
            else 
            {
                // Just expand the decade part as we normally would
                NULL;
            }
        }
        //--- 0dd0s - expand as "d hundreds" or "d hundred [decade part]"
        else if ( pItemInfo->pCentury[0] == '0' )
        {
            //--- insert first digit
            Word.pWordText  = g_ones[ pItemInfo->pCentury[0] - L'0' ].pStr;
            Word.ulWordLen  = g_ones[ pItemInfo->pCentury[0] - L'0' ].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- 0d00s - expand as "d hundreds" 
            if ( SUCCEEDED( hr ) &&
                 pItemInfo->ulDecade == 0 )
            {
                Word.pWordText  = g_Hundreds.pStr;
                Word.ulWordLen  = g_Hundreds.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                fDone = true;
            }
            //--- 0dd0s - expand as "d hundred [decade part]"
            else if ( SUCCEEDED( hr ) )
            {
                Word.pWordText  = g_hundred.pStr;
                Word.ulWordLen  = g_hundred.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
        }
        //--- d000s, dd00s - expand as "d thousands" or "dd hundreds"
        else if ( pItemInfo->ulDecade == 0 )
        {
            //--- d000s - "d thousands" ( "thousands" will get inserted below )
            if ( pItemInfo->pCentury[1] == '0' )
            {
                Word.pWordText  = g_ones[ pItemInfo->pCentury[0] - L'0' ].pStr;
                Word.ulWordLen  = g_ones[ pItemInfo->pCentury[0] - L'0' ].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            //--- dd00s - "dd hundreds"
            else
            {
                NumberGroup Garbage;
                ExpandTwoDigits( pItemInfo->pCentury, Garbage, WordList );

                Word.pWordText  = g_Hundreds.pStr;
                Word.ulWordLen  = g_Hundreds.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                fDone = true;
            }
        }
        //--- Default case: ddd0s - expand as "dd [decade part]"
        else
        {
            NumberGroup Garbage;
            ExpandTwoDigits( pItemInfo->pCentury, Garbage, WordList );
        }
    }
    //--- Special case - 00s should expand as "two thousands"
    else if ( pItemInfo->ulDecade == 0 )
    {
        Word.pWordText  = g_ones[2].pStr;
        Word.ulWordLen  = g_ones[2].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    //--- Expand decade part, if necessary 
    if ( SUCCEEDED(hr) &&
         !fDone )
    {
        Word.pWordText  = g_Decades[ pItemInfo->ulDecade ].pStr;
        Word.ulWordLen  = g_Decades[ pItemInfo->ulDecade ].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    return hr;
} /* ExpandDecade */

/***********************************************************************************************
* MatchMonthString *
*------------------*
*   Description:
*       This is just a helper function - it returns the integer value of the month found in 
*   its WCHAR string parameter ("January" is 1, "February" 2, etc.) or zero if it finds no match.
*   It also checks three letter abbreviations - "Jan", "Feb", etc.
*   Note: This function does not do parameter validation. Assumed to be done by caller
*   (GetNumber should be called first to get the NumberInfo structure and valiDate parameters).
********************************************************************* AH **********************/
ULONG CStdSentEnum::MatchMonthString( WCHAR*& pMonth, ULONG ulLength )
{
    ULONG ulMonth = 0;

    //--- Check full months strings 
    for ( int i = 0; i < sp_countof(g_months); i++ )
    {
        if ( ulLength >= (ULONG) g_months[i].Len && 
             wcsnicmp( pMonth, g_months[i].pStr, g_months[i].Len ) == 0 )
        {
            ulMonth = i + 1;
            pMonth  = pMonth + g_months[i].Len;
            break;
        }
    }
    //--- Check month abbreviations 
    if ( !ulMonth )
    {
        for ( i = 0; i < sp_countof(g_monthAbbreviations); i++ )
        {
            if ( ulLength >= (ULONG) g_monthAbbreviations[i].Len &&
                 wcsnicmp( pMonth, g_monthAbbreviations[i].pStr, g_monthAbbreviations[i].Len ) == 0 ) 
            {
                if ( i > 8 )
                {
                    ulMonth = i;
                }
                else
                {
                    ulMonth = i + 1;
                }
                pMonth = pMonth + g_monthAbbreviations[i].Len;
                if ( *pMonth == L'.' )
                {
                    pMonth++;
                }
                break;
            }
        }
    }

    return ulMonth;
} /* MatchMonthString */

/***********************************************************************************************
* MatchDayString *
*----------------*
*   Description:
*       This is just a helper function - it returns the integer value of the day found in 
*   its WCHAR string parameter ("Monday" is 0, "Tuesday" 1, etc.) or -1 if it finds no match.
*   It also checks abbreviations - "Mon", "Tue", etc.
*   Note: This function does not do parameter validation. Assumed to be done by caller
********************************************************************* AH **********************/
ULONG CStdSentEnum::MatchDayString( WCHAR*& pDayString, WCHAR* pEndChar )
{
    ULONG ulDay = 0;

    //--- Check full day strings 
    for ( int i = 0; i < sp_countof(g_days); i++ )
    {
        if ( pEndChar - pDayString >= g_days[i].Len && 
             wcsnicmp( pDayString, g_days[i].pStr, g_days[i].Len ) == 0 )
        {
            ulDay = i + 1;
            pDayString = pDayString + g_days[i].Len;
            break;
        }
    }
    //--- Check month abbreviations 
    if ( !ulDay )
    {
        for ( i = 0; i < sp_countof(g_dayAbbreviations); i++ )
        {
            if ( pEndChar - pDayString >= g_dayAbbreviations[i].Len &&
                 wcsncmp( pDayString, g_dayAbbreviations[i].pStr, g_dayAbbreviations[i].Len ) == 0 )
            {
                switch (i)
                {
                //--- Mon, Tues
                case 0:
                case 1:
                    ulDay = i + 1;
                    break;
                //--- Tue, Wed, Thurs
                case 2:
                case 3:
                case 4:
                    ulDay = i;
                    break;
                //--- Thur, Thu
                case 5:
                case 6:
                    ulDay = 4;
                    break;
                //--- Fri, Sat, Sun
                case 7:
                case 8:
                case 9:
                    ulDay = i - 2;
                    break;
                }

                pDayString = pDayString + g_dayAbbreviations[i].Len;
                if ( *pDayString == L'.' )
                {
                    pDayString++;
                }
                break;
            }
        }
    }

    return ulDay;
} /* MatchDayString */

/***********************************************************************************************
* MatchDateDelimiter *
*--------------------*
*   Description:
*       This is just a helper function - it returns true or false based on whether the first
*   character in its parameter string is a valid Date Delimiter.  It also advances its parameter
*   string pointer one position (past the Date Delimiter) and replaces a valid delimiter with
*   a null terminator.
*   Note: This function does not do parameter validation. Assumed to be done by caller
*   (GetNumber should be called first to get the NumberInfo structure and valiDate parameters).
********************************************************************* AH **********************/
bool CStdSentEnum::MatchDateDelimiter( WCHAR** DateString )
{
    bool bIsDelimiter = false;

    if (DateString)
    {
        for (int i = 0; i < sp_countof(g_DateDelimiters); i++)
        {
            if (*DateString[0] == g_DateDelimiters[i])
            {
                bIsDelimiter = true;
                *DateString = *DateString + 1;
                break;
            }
        }
    }

    return bIsDelimiter;
} /* MatchDateDelimiter */

//------------End Of File-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\frontend.h ===
/******************************************************************************
* Frontend.h *
*------------*
*  This is the header file for the CFrontend implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/
#ifndef Frontend_H
#define Frontend_H

#include "FeedChain.h"
#include "AlloOps.h"
#include "ms_entropicengine.h"
#include "sapi.h"
#include "..\truetalk\backend\backend.h"
#ifdef USE_VOICEDATAOBJ
#include "voicedataobj.h"
#endif

struct SentenceData
{
	Phone	    *pPhones;
	ULONG		ulNumPhones;
    float       *pf0;
    ULONG       ulNumf0;
};

struct EntropicPitchInfo
{
    int BasePitch;
    int Range;
};

//static const float DISCRETE_BKPT   = 0.6667f; 
static const float DISCRETE_BKPT   = 0.3333f; 

//-----------------------------------------
// Parse Next Sentence or Previous Sentence
//-----------------------------------------
enum DIRECTION
{
    eNEXT = 0,
    ePREVIOUS = 1,
};

//------------------------------------------------------
// Tag Values
//------------------------------------------------------
enum USER_VOLUME_VALUE
{   
    MIN_USER_VOL = 0,
    MAX_USER_VOL = 100,
    DEFAULT_USER_VOL = MAX_USER_VOL
};

enum USER_PITCH_VALUE
{   
    MIN_USER_PITCH = (-24),
    MAX_USER_PITCH = 24,
    DEFAULT_USER_PITCH = 0       // None
};

enum USER_EMPH_VALUE
{   
    MIN_USER_EMPH = (-10),
    MAX_USER_EMPH = 10,
    SAPI_USER_EMPH = 5,
    DEFAULT_USER_EMPH = 0        // None
};



//------------------------
// ToBI phrasing
//------------------------
typedef struct
{
    PROSODY_POS  posClass;
    long     start;
    long     end;
} TOBI_PHRASE;



class CFrontend: public CFeedChain
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    CFrontend( );
    ~CFrontend( );
    void PrepareSpeech( IEnumSpSentence* pEnumSent, ISpTTSEngineSite* pOutputSite );
#ifdef USE_VOICEDATAOBJ
    HRESULT Init( CVoiceData* pVoiceDataObj, CFeedChain *pSrcObj, MSVOICEINFO* pVoiceInfo,
                  EntropicPitchInfo PitchInfo, bool fNewPhoneSet );
#else
    HRESULT Init( void* pVoiceDataObj, CFeedChain *pSrcObj, void* pVoiceInfo,
                  EntropicPitchInfo PitchInfo, bool fNewPhoneSet );
#endif
    //--------------------------------
    // CFeedChain methods
    //--------------------------------
    virtual HRESULT NextData( void**pData, SPEECH_STATE *pSpeechState ) ;

private:
#ifdef USE_VOICEDATAOBJ
    HRESULT AlloToUnit( CAlloList *pAllos, UNITINFO *pu );
#endif
    HRESULT ParseSentence( DIRECTION eDirection );
    HRESULT TokensToAllo( CFETokenList *pTokList, CAlloList *pAllo );
    HRESULT GetSentenceTokens( DIRECTION eDirection );
    void GetItemControls( const SPVSTATE* pXmlState, CFEToken* pToken );
#ifdef USE_VOICEDATAOBJ
    void DisposeUnits( );
    void RecalcProsody();
#endif
    HRESULT ToBISymbols();
    void DoPhrasing();
    void DeleteTokenList();
#ifdef USE_VOICEDATAOBJ
    HRESULT UnitLookahead ();
	void AlloToUnitPitch( CAlloList *pAllos, UNITINFO *pu );
#endif
    void UnitToAlloDur( CAlloList *pAllos, UNITINFO *pu );
    float CntrlToRatio( long rateControl );
	PROSODY_POS GetPOSClass( ENGPARTOFSPEECH sapiPOS );
	bool StateQuoteProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	bool StartParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	bool EndParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	bool EmphSetup( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	SPLISTPOS InsertSilenceAtTail( CFEToken *pWordTok, TTSSentItem *pSentItem, long msec );
	SPLISTPOS InsertSilenceAfterPos( CFEToken *pWordTok, SPLISTPOS position );
	SPLISTPOS InsertSilenceBeforePos( CFEToken *pWordTok, SPLISTPOS position );
	void DoWordAccent();
	void ExclamEmph();
	void ProsodyTemplates( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	long DoIntegerTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount );
	void DoNumByNumTemplate( SPLISTPOS *pClusterPos, long cWordCount );
	void DoCurrencyTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	void DoPhoneNumberTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	void DoTODTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	long DoFractionTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount );
	CFEToken *InsertPhoneSilenceAtSpace( SPLISTPOS *pClusterPos, 
													BOUNDARY_SOURCE bndSrc, 
													SILENCE_SOURCE	silSrc );
	void InsertPhoneSilenceAtEnd( BOUNDARY_SOURCE bndSrc, 
								  SILENCE_SOURCE	silSrc );
	void CalcSentenceLength();
    
    //--------------------------------
    // Members
    //--------------------------------
#ifdef USE_VOICEDATAOBJ
    UNITINFO*       m_pUnits;
#endif
    ULONG           m_unitCount;
    ULONG           m_CurUnitIndex;
    SPEECH_STATE    m_SpeechState;
    
    CFeedChain      *m_pSrcObj;
    long            m_VoiceWPM;         // Voice defined speaking rate (wpm)
    float            m_RateRatio_API;         // API modulated speaking rate (ratio)
    float            m_CurDurScale;		// control tag (ratio)
    float            m_RateRatio_BKPT;        // Below this, add pauses (ratio)
    float            m_RateRatio_PROSODY;         // API modulated speaking rate (ratio)
    int             m_BasePitch;		// FROM VOICE: Baseline pitch in hz
	int  			m_PitchRange;		// FROM VOICE: Pitch range in hz
	bool			m_HasSpeech;
    
    CFETokenList    m_TokList;
    long            m_cNumOfWords;
    
    CPitchProsody   m_PitchObj;
    IEnumSpSentence    *m_pEnumSent;
    CDuration       m_DurObj;
    CSyllableTagger m_SyllObj;
#ifdef USE_VOICEDATAOBJ
    CVoiceData*   m_pVoiceDataObj;
    float           m_ProsodyGain;
    float           m_SampleRate;
#endif
    CAlloList       *m_pAllos;
	bool			m_fInQuoteProsody;		// Special prosody mode
	bool			m_fInParenProsody;		// Special prosody mode
	float			m_CurPitchOffs;			// Pitch offset in octaves
	float			m_CurPitchRange;		// Pitch range scale (0 - 2.0)
    bool            m_fNewPhoneSet;

	ISpTTSEngineSite *m_pOutputSite;
};



#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\frontend.cpp ===
/*******************************************************************************
* Frontend.cpp *
*--------------*
*   Description:
*       This module is the main implementation file for the CFrontend class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "ms_entropicengine.h"
#include "Frontend.h"
#include "spdebug.h"
#include "FeedChain.h"
#include "AlloOps.h"
#include "sapi.h"

#include "StdSentEnum.h"

static bool IsVowel ( char* ph );

//-----------------------------
// Data.cpp
//-----------------------------
extern  const short   g_IPAToAllo[];
extern const float  g_RateScale[];

inline short GetPhoneF0( float *pF0Contour, float CurrentTime, float Length )
{
    float Total = 0;
    int startIndex = (int) ( CurrentTime / PITCH_BUF_RES + 0.5 );
    int endIndex   = (int) ( ( CurrentTime + Length ) / PITCH_BUF_RES + 0.5 );

    for ( int i = startIndex; i < endIndex; i++ )
    {
        Total += pF0Contour[i];
    }

    Total /= endIndex - startIndex;

    return (short) Total;
}

const char* OldMapPhoneSet (ALLO_CODE code)
{
  static struct tagPhoneMap {
	const char* name;
	ALLO_CODE code;
  } phoneMap [] = {	
		{"iy", _IY_},
		{"ih", _IH_},
		{"eh", _EH_},
		{"ae", _AE_},
		{"aa", _AA_},
		{"ah", _AH_},
		{"ao", _AO_},
		{"uh", _UH_},
		{"ax", _AX_},
		{"axr", _ER_}, // or "er" 
		{"ey", _EY_},
		{"ay", _AY_},
		{"oy", _OY_},
		{"aw", _AW_},
		{"ow", _OW_},
		{"uw", _UW_},
		{"ix", _IX_},
		{"sil", _SIL_},
		{"w", _w_},
		{"y", _y_},
		{"r", _r_},
		{"l", _l_},
		{"hh", _h_},
		{"m", _m_},
		{"n", _n_},
		{"ng", _NG_},
		{"f", _f_},
		{"v", _v_},
		{"th", _TH_},
		{"dh", _DH_},
		{"s", _s_},
		{"z", _z_},
		{"sh", _SH_},
		{"zh", _ZH_},
		{"p", _p_},
		{"b", _b_},
		{"t", _t_},
		{"d", _d_},
		{"k", _k_},
		{"g", _g_},
		{"ch", _CH_},
		{"jh", _JH_},
		{"dx", _DX_},
		{"", _STRESS1_},
		{"", _STRESS2_},
		{"", _EMPHSTRESS_},
		{"", _SYLLABLE_}
	};
  static int nPhonesMap = sizeof (phoneMap) / sizeof(phoneMap[0]);
  int i;  

  for ( i = 0; i < nPhonesMap; i++ ) 
  {
    if (code == phoneMap[i].code) 
    {
        return phoneMap[i].name;
    }
  }
  return "";
}

const char* NewMapPhoneSet (ALLO_CODE code)
{
  static struct tagPhoneMap {
	const char* name;
	ALLO_CODE code;
  } phoneMap [] = {	
		{"iy", _IY_},
		{"ih", _IH_},
		{"eh", _EH_},
		{"ae", _AE_},
		{"aa", _AA_},
		{"ah", _AH_},
		{"ao", _AO_},
		{"uh", _UH_},
		{"ax", _AX_},
		{"er", _ER_}, // or "er" 
		{"ey", _EY_},
		{"ay", _AY_},
		{"oy", _OY_},
		{"aw", _AW_},
		{"ow", _OW_},
		{"uw", _UW_},
		{"ix", _IX_},
		{"sil", _SIL_},
		{"w", _w_},
		{"y", _y_},
		{"r", _r_},
		{"l", _l_},
		{"h", _h_},
		{"m", _m_},
		{"n", _n_},
		{"ng", _NG_},
		{"f", _f_},
		{"v", _v_},
		{"th", _TH_},
		{"dh", _DH_},
		{"s", _s_},
		{"z", _z_},
		{"sh", _SH_},
		{"zh", _ZH_},
		{"p", _p_},
		{"b", _b_},
		{"t", _t_},
		{"d", _d_},
		{"k", _k_},
		{"g", _g_},
		{"ch", _CH_},
		{"jh", _JH_},
		{"dx", _DX_},
		{"", _STRESS1_},
		{"", _STRESS2_},
		{"", _EMPHSTRESS_},
		{"", _SYLLABLE_}
	};
  static int nPhonesMap = sizeof (phoneMap) / sizeof(phoneMap[0]);
  int i;  

  for ( i = 0; i < nPhonesMap; i++ ) 
  {
    if (code == phoneMap[i].code) 
    {
        return phoneMap[i].name;
    }
  }
  return "";
}


/*****************************************************************************
* CFrontend::CFrontend *
*----------------------*
*   Description:
*       
********************************************************************** MC ***/
CFrontend::CFrontend()
{
    SPDBG_FUNC( "CFrontend::CFrontend" );
#ifdef USE_VOICEDATAOBJ
    m_pUnits        = NULL;
#endif
    m_unitCount     = 0;
    m_CurUnitIndex  = 0;
    m_pAllos        = NULL;   
    m_pSrcObj       = NULL;
    m_fNewPhoneSet   = FALSE;
} /* CFrontend::CFrontend */


/*****************************************************************************
* CFrontend::~CFrontend *
*-----------------------*
*   Description:
*       
********************************************************************** MC ***/
CFrontend::~CFrontend()
{
    SPDBG_FUNC( "CFrontend::~CFrontend" );

#ifdef USE_VOICEDATAOBJ
    DisposeUnits();
#endif
    if( m_pAllos )
    {
        delete m_pAllos;
        m_pAllos = NULL;
    }
    DeleteTokenList();
} /* CFrontend::~CFrontend */

/*****************************************************************************
* CFrontend::CntrlToRatio *
*-------------------------*
*   Description:
*   Return rate ratio from control
*       
********************************************************************** MC ***/
float CFrontend::CntrlToRatio( long rateControl )
{
    SPDBG_FUNC( "CFrontend::CntrlToRatio" );
    float   rateRatio;

    if( rateControl < 0 )
    {
        //--------------------------------
        // DECREASE the rate
        //--------------------------------
        if( rateControl < MIN_USER_RATE )
        {
            rateControl = MIN_USER_RATE;        // clip to min
        }
        rateRatio = 1.0f / ::g_RateScale[0 - rateControl];
    }
    else
    {
        //--------------------------------
        // INCREASE the rate
        //--------------------------------
        if( rateControl > MAX_USER_RATE )
        {
            rateControl = MAX_USER_RATE;        // clip to max
        }
        rateRatio = ::g_RateScale[rateControl];
    }

    return rateRatio;
} /* CFrontend::CntrlToRatio */



/*****************************************************************************
* CFrontend::Init *
*-----------------*
*   Description:
*   Init voice dependent variables, call once when object is created+++
*       
********************************************************************** MC ***/
#ifdef USE_VOICEDATAOBJ
HRESULT CFontend::Init( CVoiceData* pVoiceDataObj, CFeedChain *pSrcObj, MSVOICEINFO* pVoiceInfo,
              EntropicPitchInfo PitchInfo, bool fNewPhoneSet )
#else
HRESULT CFrontend::Init( void* pVoiceDataObj, CFeedChain *pSrcObj, void* pVoiceInfo,
              EntropicPitchInfo PitchInfo, bool fNewPhoneSet )
#endif
{
    SPDBG_FUNC( "CFrontend::Init" );
    HRESULT hr = S_OK;
    
    m_pSrcObj   = pSrcObj;
    m_BasePitch = PitchInfo.BasePitch;
#ifdef USE_VOICEDATAOBJ
    m_pVoiceDataObj = pVoiceDataObj;
    m_ProsodyGain = ((float)pVoiceInfo->ProsodyGain) / 100.0f;
    m_SampleRate = (float)pVoiceInfo->SampleRate;
#endif

    // NOTE: move these to voice data?
	// m_VoiceWPM = pVoiceInfo->Rate;
	// m_PitchRange = pVoiceInfo->PitchRange;
    m_VoiceWPM		= 180;
	m_PitchRange	= PitchInfo.Range;

    m_RateRatio_API = m_RateRatio_PROSODY = 1.0f;
    m_fNewPhoneSet = fNewPhoneSet;

    return hr;        
} /* CFrontend::Init */





static ULONG IPA_to_Allo( WCHAR* pSrc, ALLO_CODE* pDest )
{
    ULONG       iIpa, iAllo, i;
    ULONG       gotMatch;           // for debugging

    iIpa = iAllo = 0;
    while( pSrc[iIpa] > 0 )
    {
        gotMatch = false;
        //-----------------------------------------
        // ...then search for single word IPA's
        //-----------------------------------------
        for( i = 0; i < NUMBER_OF_ALLO; i++ )
        {
            if( pSrc[iIpa] == g_IPAToAllo[i] )
            {
                pDest[iAllo] = (ALLO_CODE)i;
                gotMatch = true;
                break;
            }
        }

        if( gotMatch )
        {
            iAllo++;
        }
        /*else
        {
            // Should NEVER get here. Unsupported IPA unicode!
            // Ignore it and go on.
        }*/

        //----------------------------------
        // Clip at max length
        //----------------------------------
        if( iAllo >= (SP_MAX_PRON_LENGTH-1) )
        {
            iAllo = SP_MAX_PRON_LENGTH-1;
            break;
        }
        iIpa++;
    }
    return iAllo;
}




/*****************************************************************************
* CFrontend::AlloToUnit *
*-----------------------*
*   Description:
*   Transform ALLO stream into backend UNIT stream+++
*       
********************************************************************** MC ***/
#ifdef USE_VOICEDATAOBJ
HRESULT CFrontend::AlloToUnit( CAlloList *pAllos, UNITINFO *pu )
{
    SPDBG_FUNC( "CFrontend::AlloToUnit" );
    bool		bFirstPass;
    long		msPhon, attr;
    ULONG       numOfCells;
    CAlloCell   *pCurCell, *pNextCell;
    HRESULT		hr = S_OK;
    
	bFirstPass = true;
    numOfCells = pAllos->GetCount();
	pCurCell = pAllos->GetHeadCell();    
	pNextCell = pAllos->GetNextCell();
    while( pCurCell )
    {
        //--------------------------------------
        // Get next allo ID
        //--------------------------------------
        if( pNextCell )
        {
            pu->NextAlloID = (USHORT)pNextCell->m_allo;
        }
        else
        {
            pu->NextAlloID = _SIL_;
        }

        //--------------------------------------
        // Convert to Whistler phon code
        //--------------------------------------
        attr = 0;
        if( pCurCell->m_ctrlFlags & PRIMARY_STRESS )
        {
            attr |= ALLO_IS_STRESSED;
        }
        hr = m_pVoiceDataObj->AlloToUnit( (short)pCurCell->m_allo, attr, &msPhon );
		if( FAILED(hr) )
		{
			//------------------------
			// allo ID is invalid
			//------------------------
			break;
		}
		else
		{
			pu->PhonID = msPhon;
			pu->AlloID = (USHORT)pCurCell->m_allo;
			pu->flags = 0;
			pu->AlloFeatures = 0;
			pu->ctrlFlags = pCurCell->m_ctrlFlags;
			//--------------------------------------
			// Flag WORD boundary
			//--------------------------------------
			if( pCurCell->m_ctrlFlags & WORD_START )
			{
				pu->flags |= WORD_START_FLAG;
				//----------------------------------------------
				// Remember source word position and length
				//----------------------------------------------
				pu->srcPosition = pCurCell->m_SrcPosition;
				pu->srcLen = pCurCell->m_SrcLen;
			}
        
			//----------------------------------------------------
			// Flag SENTENCE boundary on 1st displayable word
			//----------------------------------------------------
			if( bFirstPass && (pCurCell->m_SentenceLen > 0) )
			{
				bFirstPass = false;
				pu->flags |= SENT_START_FLAG;
				//----------------------------------------------
				// Remember source word position and length
				//----------------------------------------------
				pu->sentencePosition = pCurCell->m_SentencePosition;
				pu->sentenceLen = pCurCell->m_SentenceLen;
			}

			pu->nKnots      = KNOTS_PER_PHON;
			/*for( k = 0; k < pu->nKnots; k++ )
			{
				pu->pTime[k]    = pCurCell->m_ftTime[k] * m_SampleRate;
				pu->pF0[k]      = pCurCell->m_ftPitch[k];
				pu->pAmp[k]     = pu->ampRatio;
			}*/

			//----------------------------
			// Controls and events
			//----------------------------
			pu->user_Volume = pCurCell->m_user_Volume;
			pu->pBMObj = (void*)pCurCell->m_pBMObj;
			pCurCell->m_pBMObj = NULL;
        
			//----------------------------------------
			// Pass features for viseme event
			//----------------------------------------
			if( pCurCell->m_ctrlFlags & PRIMARY_STRESS )
			{
				pu->AlloFeatures |= SPVFEATURE_STRESSED;
			}
			if( pCurCell->m_ctrlFlags & EMPHATIC_STRESS )
			{
				pu->AlloFeatures |= SPVFEATURE_EMPHASIS;
			}

			pu->duration = PITCH_BUF_RES;

			pu->silenceSource = pCurCell->m_SilenceSource;
			pu++;
		}
		pCurCell = pNextCell;
		pNextCell = pAllos->GetNextCell();
	}
	return hr;
} /* CFrontend::AlloToUnit */
#endif




/*****************************************************************************
* CFrontend::PrepareSpeech *
*--------------------------*
*   Description:
*   Prepare frontend for new speech
*       
********************************************************************** MC ***/
void    CFrontend::PrepareSpeech( IEnumSpSentence* pEnumSent, ISpTTSEngineSite *pOutputSite )
{
    SPDBG_FUNC( "CFrontend::PrepareSpeech" );

    m_pEnumSent = pEnumSent;
    m_SpeechState = SPEECH_CONTINUE;
    m_CurUnitIndex = m_unitCount = 0;
	m_HasSpeech = false;
	m_pOutputSite = pOutputSite;
	m_fInQuoteProsody = m_fInParenProsody = false;
	m_CurPitchOffs = 0;
	m_CurPitchRange = 1.0;
} /* CFrontend::PrepareSpeech */








/*****************************************************************************
* IsTokenPunct *
*--------------*
*   Description:
*   Return TRUE if char is , . ! or ?
*       
********************************************************************** MC ***/
bool fIsPunctuation( TTSSentItem Item )
{
    SPDBG_FUNC( "IsTokenPunct" );

    return ( Item.pItemInfo->Type == eCOMMA ||
             Item.pItemInfo->Type == eSEMICOLON ||
             Item.pItemInfo->Type == eCOLON ||
             Item.pItemInfo->Type == ePERIOD ||
             Item.pItemInfo->Type == eQUESTION ||
             Item.pItemInfo->Type == eEXCLAMATION ||
             Item.pItemInfo->Type == eHYPHEN );
} /* fIsPunctuation */




/*****************************************************************************
* CFrontend::ToBISymbols *
*------------------------*
*   Description:
*   Label each word with ToBI prosody notation+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::ToBISymbols()
{
    SPDBG_FUNC( "CFrontend::ToBISymbols" );
    TOBI_PHRASE    *pTPhrase; 
    long			i, cPhrases;
    PROSODY_POS		prevPOS, curPOS;
    bool			possible_YNQ = false;
    long			cTok;
    CFEToken		*pTok, *pPrevTok, *pAuxTok;
	bool			hasEmph = false;
	SPLISTPOS		listPos;


	//----------------------------------
	// Get memory for phrase array
	//----------------------------------
	pAuxTok = NULL;			// To quiet the compiler
    cTok = m_TokList.GetCount();
	if( cTok )
	{
		pTPhrase = new TOBI_PHRASE[cTok];		// worse case: each token is a phrase
		if( pTPhrase )
		{
			//---------------------------------------------
			// Find sub-phrases from POS
			// For now, detect function/content boundaries
			//---------------------------------------------
			hasEmph = false;
			cPhrases	= 0;
			i = 0;
			listPos = m_TokList.GetHeadPosition();
			pTok = m_TokList.GetNext( listPos );
			prevPOS = pTok->m_posClass;
			while( pTok->phon_Str[0] == _SIL_ )
			{
				if( i >= (cTok-1) )
				{
					break;
				}
				i++;
				if( listPos != NULL )
				{
					pTok = m_TokList.GetNext( listPos );
				}
			}
			if( pTok->m_posClass == POS_AUX ) 
			{
				//---------------------------------
				// Could be a yes/no question
				//---------------------------------
				possible_YNQ = true;
				pAuxTok = pTok;
			}       
			pTPhrase[cPhrases].start = i;
			for( ; i < cTok; i++ )
			{
				curPOS = pTok->m_posClass;
				if( (curPOS != prevPOS) && (pTok->phon_Str[0] != _SIL_) )
				{
					pTPhrase[cPhrases].posClass = prevPOS;
					pTPhrase[cPhrases].end = i-1;
					cPhrases++;
					pTPhrase[cPhrases].start = i;
					prevPOS = curPOS;
				}
				if( pTok->user_Emph > 0 )
				{
					hasEmph = true;
				}
				if( listPos != NULL )
				{
					pTok = m_TokList.GetNext( listPos );
				}
			}
			//-------------------------------
			// Complete last phrase
			//-------------------------------
			pTPhrase[cPhrases].posClass = prevPOS;
			pTPhrase[cPhrases].end = i-1;
			cPhrases++;
        
			for( i = 0; i < cPhrases; i++ )
			{
				//-------------------------------------------------------
				// Sequence of function words, place a low tone 
				// on the LAST word in a func sequence,
				// if there are more than 1 words in the sequence.
				//-------------------------------------------------------
				if( ((pTPhrase[i].posClass == POS_FUNC) || (pTPhrase[i].posClass == POS_AUX)) && 
					(pTPhrase[i].end - pTPhrase[i].start) )
				{
					pTok = (CFEToken*)m_TokList.GetAt( m_TokList.FindIndex( pTPhrase[i].end ));
					if( pTok->m_Accent == K_NOACC )
					{
						pTok->m_Accent = K_LSTAR;
						pTok->m_Accent_Prom = 2;
						pTok->m_AccentSource = ACC_FunctionSeq;
					}
				}
            
				//-------------------------------------------------------
				// Sequence of content words, place a high or 
				// rising tone, of random prominence,
				// on the FIRST word in the content sequence
				//-------------------------------------------------------
				else if ( ((pTPhrase[i].posClass == POS_CONTENT) || (pTPhrase[i].posClass == POS_UNK)) )
				{
					pTok = (CFEToken*)m_TokList.GetAt( m_TokList.FindIndex( pTPhrase[i].start ));
					if( pTok->m_Accent == K_NOACC )
					{
						pTok->m_Accent = K_HSTAR;
						pTok->m_Accent_Prom = rand() % 5;
						pTok->m_AccentSource = ACC_ContentSeq;
					}
				}
			}
        
        
			delete pTPhrase;
        
			//-----------------------------------------
			// Now, insert the BOUNDARY tags
			//-----------------------------------------
			listPos = m_TokList.GetHeadPosition();
			pPrevTok = m_TokList.GetNext( listPos );
			for( i = 1; i < cTok; i++ )
			{
				pTok = m_TokList.GetNext( listPos );
				//--------------------------------
				// Place a terminal boundary
				//--------------------------------
				if( pTok->m_TuneBoundaryType != NULL_BOUNDARY )
				{
					switch( pTok->m_TuneBoundaryType )
					{
					case YN_QUEST_BOUNDARY:
						{
							pPrevTok->m_Accent = K_LSTAR;
							pPrevTok->m_Accent_Prom = 10;
							pPrevTok->m_Boundary = K_HMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 10;
							//-- Diagnostic
							if( pPrevTok->m_AccentSource == ACC_NoSource )
							{
								pPrevTok->m_AccentSource = ACC_YNQuest;
							}
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_YNQuest;
							}
							//-------------------------------------------------------
							// Accent an aux verb in initial position (possible ynq)
							//-------------------------------------------------------
							if( possible_YNQ )
							{
								pAuxTok->m_Accent = K_HSTAR;
								pAuxTok->m_Accent_Prom = 5;
								pAuxTok->m_AccentSource = ACC_InitialVAux;
							}
						}
						break;
					case WH_QUEST_BOUNDARY:
					case DECLAR_BOUNDARY:
					case EXCLAM_BOUNDARY:
						{
							if (pPrevTok->m_posClass == POS_CONTENT)
							{
								pPrevTok->m_Accent = K_HSTAR;
								pPrevTok->m_Accent_Prom = 4;
								//-- Diagnostic
								if( pPrevTok->m_AccentSource == ACC_NoSource )
								{
									pPrevTok->m_AccentSource = ACC_Period;
								}
							}
							pPrevTok->m_Boundary = K_LMINUSLPERC;
							pPrevTok->m_Boundary_Prom = 10;
							//--- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_Period;
							}
						}
						break;
					case PHRASE_BOUNDARY:
						{
							if (pPrevTok->m_posClass == POS_CONTENT)
							{
								pPrevTok->m_Accent = K_LHSTAR;
								pPrevTok->m_Accent_Prom = 10;
								//-- Diagnostic
								if( pPrevTok->m_AccentSource == ACC_NoSource )
								{
									pPrevTok->m_AccentSource = ACC_Comma;
								}
							}
							pPrevTok->m_Boundary = K_LMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 5;
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_Comma;
							}
						}
						break;
					case NUMBER_BOUNDARY:
						{
							pPrevTok->m_Boundary = K_LMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 5;
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_NumberTemplate;
							}
						}
						break;
					default:
						{
							// Use comma for all other boundaries
							if (pPrevTok->m_posClass == POS_CONTENT)
							{
								pPrevTok->m_Accent = K_LHSTAR;
								pPrevTok->m_Accent_Prom = 10;
								//-- Diagnostic
								if( pPrevTok->m_AccentSource == ACC_NoSource )
								{
									pPrevTok->m_AccentSource = pTok->m_AccentSource;
								}
							}
							pPrevTok->m_Boundary = K_LMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 5;
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = pTok->m_BoundarySource;
							}
						}
						break;
					}
				}
				pPrevTok = pTok;
			}

			//--------------------------------------------
			// Loop through each word and increase 
			// pitch prominence if EMPHASIZED and
			// decrease prominence for all others
			//--------------------------------------------
			if( hasEmph )
			{
				SPLISTPOS listPos;

				pPrevTok = NULL;
				listPos = m_TokList.GetHeadPosition();
				while( listPos )
				{
					pTok = m_TokList.GetNext( listPos );
					//------------------------------
					// Is this word emphasized?
					//------------------------------
					if( pTok->user_Emph > 0 )
					{
						//------------------------------
						// Add my clever H*+L* tag
						//------------------------------
						pTok->m_Accent = K_HSTARLSTAR;
						pTok->m_Accent_Prom = 10;
						pTok->m_Boundary = K_NOBND;			// Delete any boundary tag here... 
						if( pPrevTok )
						{
							pPrevTok->m_Boundary = K_NOBND;	// ...or before
						}
					}
					else
					{
						//-----------------------------------
						// Is non-emphasized word accented?
						//-----------------------------------
						if( (pTok->m_Accent != K_NOACC) && (pTok->m_Accent_Prom > 5) )
						{
							//------------------------------
							// Then clip its prominence at 5
							//------------------------------
							pTok->m_Accent_Prom = 5;
						}
						//------------------------------
						// Is it a boundary?
						//------------------------------
						/*if( (pTok->m_Boundary != K_NOBND) && (pTok->m_Boundary_Prom > 5) )
						{
							//------------------------------
							// Then clip its prominence at 5
							//------------------------------
							pTok->m_Boundary_Prom = 5;
						}*/
					}
					pPrevTok = pTok;
				}
			}
		}
	}
    return S_OK;
} /* ToBISymbols */


/*****************************************************************************
* CFrontend::TokensToAllo *
*------------------------*
*   Description:
*   Transform TOKENS into ALLOS
*       
********************************************************************** MC ***/
HRESULT CFrontend::TokensToAllo( CFETokenList *pTokList, CAlloList *pAllo )
{
    SPDBG_FUNC( "CFrontend::TokToAllo" );
    CAlloCell   *pLastCell;
    long        i;
    long        cTok;
    CFEToken    *pCurToken, *pNextToken, *pPrevTok;
	SPLISTPOS	listPos;

    
    pLastCell = pAllo->GetTailCell();        // Get end (silence)
    if( pLastCell )
    {
		pPrevTok = NULL;
		listPos = pTokList->GetHeadPosition();
		pCurToken = pTokList->GetNext( listPos );
        cTok = pTokList->GetCount();
        for( i = 0; i < cTok; i++ )
        {
			//----------------------------
			// Get NEXT word
			//----------------------------
			if( i < (cTok -1) )
			{
				pNextToken = pTokList->GetNext( listPos );
			}
			else
			{
				pNextToken = NULL;
			}
			if( pAllo->WordToAllo( pPrevTok, pCurToken, pNextToken, pLastCell ) )
			{
				m_HasSpeech = true;
			}
			//----------------------------
			// Bump the pipeline
			//----------------------------
			pPrevTok	= pCurToken;
			pCurToken	= pNextToken;
        }
    }
            
    return S_OK;
    
} /* CFrontend::TokensToAllo */




/*****************************************************************************
* CFrontend::GetItemControls *
*----------------------------*
*   Description:
*   Set user control values from Sent Enum item.
********************************************************************** MC ***/
void CFrontend::GetItemControls( const SPVSTATE* pXmlState, CFEToken* pToken )
{
    SPDBG_FUNC( "CFrontend::GetItemControls" );

    pToken->user_Volume = pXmlState->Volume;
    pToken->user_Rate  = pXmlState->RateAdj;
    pToken->user_Pitch = pXmlState->PitchAdj.MiddleAdj;
    pToken->user_Emph  = pXmlState->EmphAdj;
    pToken->m_DurScale = CntrlToRatio( pToken->user_Rate );
    if( (pToken->m_DurScale * m_RateRatio_API * m_RateRatio_PROSODY) 
				< DISCRETE_BKPT )
    {
        //-- If the total rate is low enough, insert breaks between words
        pToken->m_TermSil = 0.050f / 
			(pToken->m_DurScale * m_RateRatio_API * m_RateRatio_PROSODY);
        pToken->m_DurScale = DISCRETE_BKPT;
    }
	else
	{
		pToken->m_TermSil = 0;
	}

} /* CFrontend::GetItemControls */




/*****************************************************************************
* CFrontend::GetPOSClass *
*------------------------*
*   Description:
*   Transform SAPI POS code to func/content/aux class.
********************************************************************** MC ***/
PROSODY_POS CFrontend::GetPOSClass( ENGPARTOFSPEECH sapiPOS )
{
    SPDBG_FUNC( "CFrontend::GetPOSClass" );
	PROSODY_POS		posClass;

	posClass = POS_UNK;
	switch( sapiPOS )
	{
	case MS_Noun:
	case MS_Verb:
	case MS_Adj:
	case MS_Adv:
	case MS_Interjection:
		{
			posClass = POS_CONTENT;
			break;
		}
	case MS_VAux:
		{
			posClass = POS_AUX;
			break;
		}
	case MS_Modifier:
	case MS_Function:
	case MS_Interr:
	case MS_Pron:
	case MS_ObjPron:
	case MS_SubjPron:
	case MS_RelPron:
	case MS_Conj:
	case MS_CConj:
	case MS_Det:
	case MS_Contr:
	case MS_Prep:
		{
			posClass = POS_FUNC;
			break;
		}
	}

	return posClass;
} /* CFrontend::GetPOSClass */



#define	QUOTE_HESITATION	100		// Number of msec
#define	PAREN_HESITATION	100		// Number of msec
#define	PAREN_HESITATION_TAIL	100		// Number of msec
#define	EMPH_HESITATION	1		// Number of msec

/*****************************************************************************
* CFrontend::StateQuoteProsody *
*------------------------------*
*   Description:
*       
********************************************************************** MC ***/
bool CFrontend::StateQuoteProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil )
{
    SPDBG_FUNC( "CFrontend::StateQuoteProsody" );
	bool		result = false;

	if( !m_fInParenProsody )
	{
		if( m_fInQuoteProsody )
		{
			//------------------------------
			// Stop quote prosody
			//------------------------------
			m_fInQuoteProsody = false;
			m_CurPitchOffs = 0.0f;
			m_CurPitchRange = 1.0f;
			if( fInsertSil )
			{
				(void)InsertSilenceAtTail( pWordTok, pSentItem, QUOTE_HESITATION );
				pWordTok->m_SilenceSource = SIL_QuoteEnd;
			}
		}
		else
		{
			//------------------------------
			// Begin quote prosody
			//------------------------------
			m_fInQuoteProsody = true;
			m_CurPitchOffs = 0.1f;
			m_CurPitchRange = 1.25f;
			if( fInsertSil )
			{
				(void)InsertSilenceAtTail( pWordTok, pSentItem, QUOTE_HESITATION );
				pWordTok->m_SilenceSource = SIL_QuoteStart;
			}
		}
		result = true;
	}
	return result;
} /* CFrontend::StateQuoteProsody */



/*****************************************************************************
* CFrontend::StartParenProsody *
*------------------------------*
*   Description:
*       
********************************************************************** MC ***/
bool CFrontend::StartParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil )
{
    SPDBG_FUNC( "CFrontend::StartParenProsody" );
	bool		result = false;

	if( (!m_fInParenProsody) && (!m_fInQuoteProsody) )
	{
		m_CurPitchOffs = -0.2f;
		m_CurPitchRange = 0.75f;
		m_fInParenProsody = true;
		m_RateRatio_PROSODY = 1.25f;
		if( fInsertSil )
		{
			(void)InsertSilenceAtTail( pWordTok, pSentItem, PAREN_HESITATION );
			pWordTok->m_SilenceSource = SIL_ParenStart;
		}
		result = true;
	}
	return result;
} /* CFrontend::StartParenProsody */


/*****************************************************************************
* CFrontend::EndParenProsody *
*----------------------------*
*   Description:
*       
********************************************************************** MC ***/
bool CFrontend::EndParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil )
{
    SPDBG_FUNC( "CFrontend::EndParenProsody" );
	bool		result = false;

	if( m_fInParenProsody )
	{
		m_fInParenProsody = false;
		m_CurPitchOffs = 0.0f;
		m_CurPitchRange = 1.0f;
		m_RateRatio_PROSODY = 1.0f;
		if( fInsertSil )
		{
			(void)InsertSilenceAtTail( pWordTok, pSentItem, PAREN_HESITATION_TAIL );
			pWordTok->m_SilenceSource = SIL_ParenStart;
		}
		result = true;
	}
	return result;
} /* CFrontend::EndParenProsody */





/*****************************************************************************
* CFrontend::InsertSilenceAtTail *
*--------------------------------*
*   Description:
*       
********************************************************************** MC ***/
SPLISTPOS CFrontend::InsertSilenceAtTail( CFEToken *pWordTok, TTSSentItem *pSentItem, long msec )
{
    SPDBG_FUNC( "CFrontend::InsertSilenceAtTail" );

	if( msec > 0 )
	{
		pWordTok->user_Break = msec;
	}
	pWordTok->phon_Len    = 1;
	pWordTok->phon_Str[0] = _SIL_;
	pWordTok->srcPosition = pSentItem->ulItemSrcOffset;
	pWordTok->srcLen      = pSentItem->ulItemSrcLen;
	pWordTok->tokStr[0]   = 0;        // There's no orth for Break
	pWordTok->tokLen      = 0;
	pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
	pWordTok->m_PitchRangeScale = m_CurPitchRange;
	pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;
	//----------------------------------
	// Advance to next token
	//----------------------------------
	return m_TokList.AddTail( pWordTok );
} /* CFrontend::InsertSilenceAtTail */



/*****************************************************************************
* CFrontend::InsertSilenceAfterPos  *
*-----------------------------------*
*   Description:
*	Insert silence token AFTER 'position'
*       
********************************************************************** MC ***/
SPLISTPOS CFrontend::InsertSilenceAfterPos( CFEToken *pWordTok, SPLISTPOS position )
{
    SPDBG_FUNC( "CFrontend::InsertSilenceAfterPos" );

	pWordTok->phon_Len		= 1;
	pWordTok->phon_Str[0]	= _SIL_;
	pWordTok->srcPosition	= 0;
	pWordTok->srcLen		= 0;
	pWordTok->tokStr[0]		= '+';      // punctuation
	pWordTok->tokStr[1]		= 0;                   // delimiter
	pWordTok->tokLen		= 1;
	pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
	pWordTok->m_PitchRangeScale = m_CurPitchRange;
	pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;
	pWordTok->m_DurScale	= 0;
	//----------------------------------
	// Advance to next token
	//----------------------------------
	return m_TokList.InsertAfter( position, pWordTok );
} /* CFrontend::InsertSilenceAfterPos */


/*****************************************************************************
* CFrontend::InsertSilenceBeforePos  *
*------------------------------------*
*   Description:
*	Insert silence token BEFORE 'position'
*       
********************************************************************** MC ***/
SPLISTPOS CFrontend::InsertSilenceBeforePos( CFEToken *pWordTok, SPLISTPOS position )
{
    SPDBG_FUNC( "CFrontend::InsertSilenceBeforePos" );

	pWordTok->phon_Len		= 1;
	pWordTok->phon_Str[0]	= _SIL_;
	pWordTok->srcPosition	= 0;
	pWordTok->srcLen		= 0;
	pWordTok->tokStr[0]		= '+';      // punctuation
	pWordTok->tokStr[1]		= 0;                   // delimiter
	pWordTok->tokLen		= 1;
	pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
	pWordTok->m_PitchRangeScale = m_CurPitchRange;
	pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;
	pWordTok->m_DurScale	= 0;
	//----------------------------------
	// Advance to next token
	//----------------------------------
	return m_TokList.InsertBefore( position, pWordTok );
} /* CFrontend::InsertSilenceBeforePos */






#define K_ACCENT_PROM	((rand() % 4) + 4)
#define K_DEACCENT_PROM 5
#define K_ACCENT		K_HSTAR
#define K_DEACCENT		K_NOACC



/*****************************************************************************
* CFrontend::ProsodyTemplates *
*-----------------------------*
*   Description:
*   Call prosody template function for supported item types.
*       
********************************************************************** MC ***/
void CFrontend::ProsodyTemplates( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::ProsodyTemplates" );
	long				cWordCount;
	CFEToken			*pClusterTok;

	switch( pSentItem->pItemInfo->Type )
	{
		//---------------------------------------
		// Numbers
		//---------------------------------------
        case eNUM_ROMAN_NUMERAL:
		case eNUM_ROMAN_NUMERAL_ORDINAL:
            {
                if ( ( (TTSRomanNumeralItemInfo*) pSentItem->pItemInfo )->pNumberInfo->Type != eDATE_YEAR )
                {
                    if ( ((TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo)->pIntegerPart )
                    {
                        DoIntegerTemplate( &clusterPos, 
	    								   (TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo, 
		    							   pSentItem->ulNumWords );
                    }

                    if ( ((TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo)->pDecimalPart )
                    {
                        DoNumByNumTemplate( &clusterPos, 
                                            ((TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo)->pDecimalPart->ulNumDigits );
                    }
                }
            }
        break;

		case eNUM_CARDINAL:
		case eNUM_DECIMAL:
		case eNUM_ORDINAL:
		case eNUM_MIXEDFRACTION:
			{
                if ( ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pIntegerPart )
                {
    				cWordCount = DoIntegerTemplate( &clusterPos, 
	    											(TTSNumberItemInfo*) pSentItem->pItemInfo, 
		    										pSentItem->ulNumWords );
                }

                if( ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pDecimalPart )
                {
					//-----------------------------------------
					// Skip "point" string...
					//-----------------------------------------
					(void) m_TokList.GetNext( clusterPos );
					//-----------------------------------------
					// ...and do single digit prosody
					//-----------------------------------------
				    DoNumByNumTemplate( &clusterPos, 
                                        ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pDecimalPart->ulNumDigits );
                }

                if ( ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pFractionalPart )
                {
					//-----------------------------------------
					// Skip "and" string...
					//-----------------------------------------
					pClusterTok = m_TokList.GetNext( clusterPos );
 					if( pClusterTok->m_Accent == K_NOACC )
					{
						//--------------------------------------
						// Force POS for "and" to noun 
						//  so phrasing rules don't kick in!
						//--------------------------------------
						pClusterTok->m_Accent = K_DEACCENT;
						pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
						pClusterTok->POScode = MS_Noun;
						pClusterTok->m_posClass = POS_CONTENT;
					}
					//-----------------------------------------
					// ...and do fraction prosody
					//-----------------------------------------
    				cWordCount = DoFractionTemplate( &clusterPos, 
	    											(TTSNumberItemInfo*) pSentItem->pItemInfo, 
		    										pSentItem->ulNumWords );
                }
			}
        break;

		//---------------------------------------
		// Fraction
		//---------------------------------------
		case eNUM_FRACTION:
			{
    			cWordCount = DoFractionTemplate( &clusterPos, 
	    										(TTSNumberItemInfo*) pSentItem->pItemInfo, 
		    									pSentItem->ulNumWords );
			}
		break;

		//---------------------------------------
		// Money
		//---------------------------------------
		case eNUM_CURRENCY:
			{
				 DoCurrencyTemplate( clusterPos, pSentItem );
			}
		break;

		//---------------------------------------
		// Phone Numbers
		//---------------------------------------
		case eNUM_PHONENUMBER:
		case eNEWNUM_PHONENUMBER:
			{
				DoPhoneNumberTemplate( clusterPos, pSentItem );
			}
		break;

		//---------------------------------------
		// Time-of-Day
		//---------------------------------------
		case eTIMEOFDAY:
			{
				DoTODTemplate( clusterPos, pSentItem );
			}
		break;

		case eELLIPSIS:
			{
				CFEToken	*pWordTok;

				pWordTok = new CFEToken;
				if( pWordTok )
				{
					clusterPos = InsertSilenceAtTail( pWordTok, pSentItem, 0 );
					//clusterPos = m_TokList.GetTailPosition( );
					//clusterPos = InsertSilenceAfterPos( pWordTok, clusterPos );
					pWordTok->m_SilenceSource = SIL_Ellipsis;
					pWordTok->m_TuneBoundaryType = ELLIPSIS_BOUNDARY;
					pWordTok->m_BoundarySource = BND_Ellipsis;
				}
			}
		break;
	}

} /* CFrontend::ProsodyTemplates */




/*****************************************************************************
* CFrontend::DoTODTemplate *
*--------------------------*
*   Description:
*   Prosody template for time-of-day.
* 
*	TODO: Temp kludge - needs more info in TTSTimeOfDayItemInfo    
********************************************************************** MC ***/
void CFrontend::DoTODTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::DoTODTemplate" );
	TTSTimeOfDayItemInfo	*pTOD;
	CFEToken				*pWordTok;
	CFEToken				*pClusterTok;
	SPLISTPOS				curPos, nextPos, prevPos;


	curPos = nextPos = clusterPos;
	pTOD = (TTSTimeOfDayItemInfo*)&pSentItem->pItemInfo->Type;

	// Can't do 24 hr because there's no way to tell 
	// if it's 1 or 2 digits (18: vs 23:)
	if( !pTOD->fTwentyFourHour )
	{
		//-------------------------------------
		// Get HOUR token
		//-------------------------------------
		pClusterTok = m_TokList.GetNext( nextPos );
		//-------------------------------------
		// Accent hour
		//-------------------------------------
		pClusterTok->m_Accent = K_ACCENT;
		pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
		pClusterTok->m_AccentSource = ACC_TimeOFDay_HR;

		//---------------------------------
		// Insert SILENCE after hour
		//---------------------------------
		pWordTok = new CFEToken;
		if( pWordTok )
		{
			nextPos = InsertSilenceAfterPos( pWordTok, clusterPos );
			pWordTok->m_SilenceSource = SIL_TimeOfDay_HR;
			pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
			pWordTok->m_BoundarySource = BND_TimeOFDay_HR;
			pWordTok = NULL;
			//----------------------------
			// Skip last digit
			//----------------------------
			if( clusterPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
		}
		if( pTOD->fMinutes )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			//-------------------------------------
			// Accent 1st digit for minutes
			//-------------------------------------
			pClusterTok->m_Accent = K_ACCENT;
			pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
			pClusterTok->m_AccentSource = ACC_TimeOFDay_1stMin;
		}

		if( pTOD->fTimeAbbreviation )
		{
			curPos = prevPos = m_TokList.GetTailPosition( );
			pClusterTok = m_TokList.GetPrev( prevPos );
			pWordTok = new CFEToken;
			if( pWordTok )
			{
				prevPos = InsertSilenceBeforePos( pWordTok, prevPos );
				pWordTok->m_SilenceSource = SIL_TimeOfDay_AB;
				pWordTok->m_TuneBoundaryType = TOD_BOUNDARY;
				pWordTok->m_BoundarySource = BND_TimeOFDay_AB;
				pWordTok = NULL;
				//pClusterTok = m_TokList.GetNext( clusterPos );
				//pClusterTok = m_TokList.GetNext( clusterPos );
			}
			//-------------------------------------
			// Accent "M"
			//-------------------------------------
			pClusterTok = m_TokList.GetNext( curPos );
			pClusterTok->m_Accent = K_ACCENT;
			pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
			pClusterTok->m_AccentSource = ACC_TimeOFDay_M;
		}
	}
} /* CFrontend::DoTODTemplate */





CFEToken *CFrontend::InsertPhoneSilenceAtSpace( SPLISTPOS *pClusterPos, 
												BOUNDARY_SOURCE bndSrc, 
												SILENCE_SOURCE	silSrc )
{
	CFEToken		*pWordTok;
	SPLISTPOS		curPos, nextPos;

	curPos = nextPos = *pClusterPos;
	//---------------------------------
	// Insert SILENCE after area code
	//---------------------------------
	pWordTok = new CFEToken;
	if( pWordTok )
	{
		nextPos = InsertSilenceBeforePos( pWordTok, curPos );
		pWordTok->m_SilenceSource = silSrc;
		pWordTok->m_TuneBoundaryType = PHONE_BOUNDARY;
		pWordTok->m_BoundarySource = bndSrc;
		pWordTok->m_AccentSource = ACC_PhoneBnd_AREA;		// @@@@ ???
		pWordTok = NULL;
		//----------------------------
		// Skip last digit
		//----------------------------
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pWordTok = m_TokList.GetNext( nextPos );
		}
	}
	//pWordTok = m_TokList.GetNext( clusterPos );
	//-----------------------------------------
	// Filter and embedded silences
	//-----------------------------------------
	while( (pWordTok->phon_Str[0] == _SIL_) && (nextPos != NULL) )
	{
		curPos = nextPos;
		pWordTok = m_TokList.GetNext( nextPos );
	}
	*pClusterPos = curPos;

	return pWordTok;
}




void CFrontend::InsertPhoneSilenceAtEnd( BOUNDARY_SOURCE bndSrc, 
										 SILENCE_SOURCE	silSrc )
{
	CFEToken		*pWordTok;
	SPLISTPOS		curPos, nextPos;

	curPos = m_TokList.GetTailPosition( );
	//---------------------------------
	// Insert SILENCE after area code
	//---------------------------------
	pWordTok = new CFEToken;
	if( pWordTok )
	{
		nextPos = InsertSilenceAfterPos( pWordTok, curPos );
		pWordTok->m_SilenceSource = silSrc;
		pWordTok->m_TuneBoundaryType = PHONE_BOUNDARY;
		pWordTok->m_BoundarySource = bndSrc;
		pWordTok->m_AccentSource = ACC_PhoneBnd_AREA;		// @@@@ ???
	}
}








/*****************************************************************************
* CFrontend::DoPhoneNumberTemplate *
*----------------------------------*
*   Description:
*   Prosody template for phone numbers.
*       
********************************************************************** MC ***/
void CFrontend::DoPhoneNumberTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::DoPhoneNumberTemplate" );
	TTSPhoneNumberItemInfo	*pFone;
	CFEToken				*pClusterTok;
	long					cWordCount;
	SPLISTPOS				curPos, nextPos;

	curPos = nextPos = clusterPos;
	pFone = (TTSPhoneNumberItemInfo*)&pSentItem->pItemInfo->Type;

	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// COUNTRY CODE
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	if( pFone->pCountryCode )
	{
		//-------------------------------------
		// Skip "country" and...
		//-------------------------------------
		curPos = nextPos;
		pClusterTok = m_TokList.GetNext( nextPos );
		
		//-------------------------------------
		// ...skip "code"
		//-------------------------------------
		curPos = nextPos;
		pClusterTok = m_TokList.GetNext( nextPos );

		cWordCount = DoIntegerTemplate( &nextPos, 
										pFone->pCountryCode, 
										pSentItem->ulNumWords );
		pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_COUNTRY, SIL_Phone_COUNTRY );
	}
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// "One"
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	if( pFone->fOne )
	{
		//-------------------------------------
		// Skip "One"
		//-------------------------------------
		curPos = nextPos;
		pClusterTok = m_TokList.GetNext( nextPos );
		//-------------------------------------
		// and add silence
		//-------------------------------------
		pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_ONE, SIL_Phone_ONE );
		
	}
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// AREA CODE
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	if( pFone->pAreaCode )
	{

		if( (pFone->fIs800) && nextPos )
		{
			//--------------------------
			// Skip digit
			//--------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			//--------------------------
			// Skip "hundred"
			//--------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			if( nextPos )
			{
				pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_AREA, SIL_Phone_AREA );
			}
		}
		else
		{
			//-------------------------------------
			// Skip "area" and...
			//-------------------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			//-------------------------------------
			// ...skip "code"
			//-------------------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );

			DoNumByNumTemplate( &nextPos, pFone->pAreaCode->ulNumDigits );
			if( nextPos )
			{
				pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_AREA, SIL_Phone_AREA );
			}
		}
	}
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// Digits
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	unsigned long		i;

	for( i = 0; i < pFone->ulNumGroups; i++ )
	{
		DoNumByNumTemplate( &nextPos, pFone->ppGroups[i]->ulNumDigits );
		if( nextPos )
		{
			pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_DIGITS, SIL_Phone_DIGITS );
		}
	}
	InsertPhoneSilenceAtEnd( BND_Phone_DIGITS, SIL_Phone_DIGITS );
} /* CFrontend::DoPhoneNumberTemplate */

/*****************************************************************************
* CFrontend::DoCurrencyTemplate *
*-------------------------------*
*   Description:
*   Prosody template for currency.
*       
********************************************************************** MC ***/
void CFrontend::DoCurrencyTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::DoCurrencyTemplate" );
	TTSCurrencyItemInfo		*pMoney;
	CFEToken				*pWordTok;
	CFEToken				*pClusterTok = NULL;
	long					cWordCount;
	SPLISTPOS				curPos, nextPos;

	pMoney = (TTSCurrencyItemInfo*)&pSentItem->pItemInfo->Type;

	curPos = nextPos = clusterPos;
	if( pMoney->pPrimaryNumberPart->Type != eNUM_CARDINAL )
	{
		return;
	}
	cWordCount = DoIntegerTemplate( &nextPos, 
									pMoney->pPrimaryNumberPart, 
									pSentItem->ulNumWords );
	curPos = nextPos;
	if( cWordCount > 1 )
	{
		if( pMoney->fQuantifier )
		{
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
			cWordCount--;
		}
	}
	if( cWordCount > 1 )
	{
		//---------------------------------
		// Insert SILENCE after "dollars"
		//---------------------------------
		pWordTok = new CFEToken;
		if( pWordTok )
		{
			nextPos = InsertSilenceAfterPos( pWordTok, curPos );
			pWordTok->m_SilenceSource = SIL_Currency_DOLLAR;
			pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
			pWordTok->m_BoundarySource = BND_Currency_DOLLAR;
			pWordTok = NULL;
			//----------------------------
			// Skip "dollar(s)"
			//----------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
		}
		if( pMoney->pSecondaryNumberPart != NULL )
		{
			//----------------------------
			// Skip SILENCE
			//----------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
			cWordCount--;
			//----------------------------
			// Skip AND
			//----------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
 				if( pClusterTok->m_Accent == K_NOACC )
				{
					//--------------------------------------
					// Force POS for "and" to noun 
					//  so phrasing rules don't kick in!
					//--------------------------------------
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
					pClusterTok->POScode = MS_Noun;
					pClusterTok->m_posClass = POS_CONTENT;
				}
				pClusterTok = m_TokList.GetNext( nextPos );
			}
			cWordCount--;
			cWordCount = DoIntegerTemplate( &curPos, 
											pMoney->pSecondaryNumberPart, 
											cWordCount );
		}
	}
} /* CFrontend::DoCurrencyTemplate */





/*****************************************************************************
* CFrontend::DoNumByNumTemplate *
*---------------------------------*
*   Description:
*   Prosody template for RIGHT hand side of the decimal point.
*       
********************************************************************** MC ***/
void CFrontend::DoNumByNumTemplate( SPLISTPOS *pClusterPos, long cWordCount )
{
    SPDBG_FUNC( "CFrontend::DoNumByNumTemplate" );
	CFEToken			*pClusterTok;
	SPLISTPOS			curPos, nextPos;

	curPos = nextPos = *pClusterPos;
	while( cWordCount > 1 )
	{
		pClusterTok = NULL;
		//-------------------------------------------------------------
		// Right side of decimal point - add H* to every other word 
		//-------------------------------------------------------------
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
		}
		cWordCount--;

		if( pClusterTok )
		{
			pClusterTok->m_Accent = K_ACCENT;
			pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
			pClusterTok->m_AccentSource = ACC_NumByNum;
		}
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
		}
		cWordCount--;
	}
	if( cWordCount > 0 )
	{
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
		}
		cWordCount--;
	}
	*pClusterPos = nextPos;
} /* CFrontend::DoNumByNumTemplate */






/*****************************************************************************
* CFrontend::DoFractionTemplate *
*------------------------------*
*   Description:
*   Prosody template for RIGHT side of the decimal point.
*       
********************************************************************** MC ***/
long CFrontend::DoFractionTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount )
{
    SPDBG_FUNC( "CFrontend::DoFractionTemplate" );
	CFEToken				*pClusterTok;
	TTSFractionItemInfo	    *pFInfo;
	CFEToken				*pWordTok;

	pFInfo = pNInfo->pFractionalPart;

    //--- Do Numerator...
    if ( pFInfo->pNumerator->pIntegerPart )
    {
    	cWordCount = DoIntegerTemplate( pClusterPos, pFInfo->pNumerator, cWordCount );
    }
    if( pFInfo->pNumerator->pDecimalPart )
    {
		//-----------------------------------------
		// Skip "point" string...
		//-----------------------------------------
		(void) m_TokList.GetNext( *pClusterPos );
		//-----------------------------------------
		// ...and do single digit prosody
		//-----------------------------------------
		DoNumByNumTemplate( pClusterPos, pFInfo->pNumerator->pDecimalPart->ulNumDigits );
    }

    //--- Special case - a non-standard fraction (e.g. 1/4)
	if( !pFInfo->fIsStandard )
	{
		if( !*pClusterPos )
		{
			*pClusterPos = m_TokList.GetTailPosition( );
		}
		else
		{
			pClusterTok = m_TokList.GetPrev( *pClusterPos );
		}
	}

	pWordTok = new CFEToken;
	if( pWordTok )
	{
		*pClusterPos = InsertSilenceBeforePos( pWordTok, *pClusterPos );
		pWordTok->m_SilenceSource = SIL_Fractions_NUM;
		pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
		pWordTok->m_BoundarySource = BND_Frac_Num;
		pWordTok = NULL;
		//----------------------------
		// Skip numerator
		//----------------------------
		if( *pClusterPos != NULL )
		{
			pClusterTok = m_TokList.GetNext( *pClusterPos );
		}
	}

    //--- Do Denominator...
    if ( pFInfo->pDenominator->pIntegerPart )
    {
		//-----------------------------------------
		// Skip "over" string...
		//-----------------------------------------
		pClusterTok = m_TokList.GetNext( *pClusterPos );
 		if( pClusterTok->m_Accent == K_NOACC )
		{
			//--------------------------------------
			// Force POS for "and" to noun 
			//  so phrasing rules don't kick in!
			//--------------------------------------
			pClusterTok->m_Accent = K_DEACCENT;
			pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
			pClusterTok->POScode = MS_Noun;
			pClusterTok->m_posClass = POS_CONTENT;
		}
    	cWordCount = DoIntegerTemplate( pClusterPos, pFInfo->pDenominator, cWordCount );
    }
    if( pFInfo->pDenominator->pDecimalPart )
    {
		//-----------------------------------------
		// Skip "point" string...
		//-----------------------------------------
		(void) m_TokList.GetNext( *pClusterPos );
		//-----------------------------------------
		// ...and do single digit prosody
		//-----------------------------------------
		DoNumByNumTemplate( pClusterPos, pFInfo->pDenominator->pDecimalPart->ulNumDigits );
    }

	return cWordCount;
} /* CFrontend::DoFractionTemplate */




/*****************************************************************************
* CFrontend::DoIntegerTemplate *
*------------------------------*
*   Description:
*   Prosody template for LEFT hand side of the decimal point.
*       
********************************************************************** MC ***/
long CFrontend::DoIntegerTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount )
{
    SPDBG_FUNC( "CFrontend::DoIntegerTemplate" );
	long				i;
	CFEToken			*pClusterTok;
    CFEToken			*pWordTok = NULL;
	SPLISTPOS			curPos, nextPos;

	//------------------------------------------
	// Special currency hack...sorry
	//------------------------------------------
	if( pNInfo->pIntegerPart->fDigitByDigit )
	{
		DoNumByNumTemplate( pClusterPos, pNInfo->pIntegerPart->ulNumDigits );
		return cWordCount - pNInfo->pIntegerPart->ulNumDigits;
	}

	nextPos = curPos = *pClusterPos;
	pClusterTok = m_TokList.GetNext( nextPos );
	pClusterTok->m_Accent = K_DEACCENT;
	pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
	if( pNInfo->fNegative )
	{
		//---------------------------------
		// Skip "NEGATIVE"
		//---------------------------------
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			pClusterTok->m_Accent = K_DEACCENT;
			pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
		}
		cWordCount--;
	}
	for( i = (pNInfo->pIntegerPart->lNumGroups -1); i >= 0; i-- )
	{
		//------------------------------------
		// Accent 1st digit in group
		//------------------------------------
		pClusterTok->m_Accent = K_ACCENT;
		pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
		pClusterTok->m_AccentSource = ACC_IntegerGroup;


		if( pNInfo->pIntegerPart->Groups[i].fHundreds )
		{
			//---------------------------------
			// Skip "X HUNDRED"
			//---------------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
		}
		if( pNInfo->pIntegerPart->Groups[i].fTens )
		{
			//---------------------------------
			// Skip "X-TY"
			//---------------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
		}
		if( pNInfo->pIntegerPart->Groups[i].fOnes )
		{
			//---------------------------------
			// Skip "X"
			//---------------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
		}
		if( pNInfo->pIntegerPart->Groups[i].fQuantifier )
		{
			//---------------------------------
			// Insert SILENCE after quant
			//---------------------------------
			if( pWordTok == NULL )
			{
				pWordTok = new CFEToken;
			}
			if( pWordTok )
			{
				nextPos = InsertSilenceAfterPos( pWordTok, curPos );
				pWordTok->m_SilenceSource = SIL_Integer_Quant;
				pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
				pWordTok->m_BoundarySource = BND_IntegerQuant;
				pWordTok = NULL;
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
				if( nextPos != NULL )
				{
					//------------------------------
					// Skip inserted silence
					//------------------------------
					curPos = nextPos;
					pClusterTok = m_TokList.GetNext( nextPos );
				}
				if( nextPos != NULL )
				{
					//-----------------------------------
					// Skip quantifier string
					//-----------------------------------
					curPos = nextPos;
					pClusterTok = m_TokList.GetNext( nextPos );
				}
				cWordCount--;
			}
		}
	}

	*pClusterPos = curPos;
	return cWordCount;
} /* CFrontend::DoIntegerTemplate */






/*****************************************************************************
* CFrontend::GetSentenceTokens *
*------------------------------*
*   Description:
*   Collect Senence Enum tokens.
*   Copy tokens into 'm_TokList' and token count into 'm_cNumOfWords'
*   S_FALSE return means no more input sentences.+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::GetSentenceTokens( DIRECTION eDirection )
{
    SPDBG_FUNC( "CFrontend::GetSentenceTokens" );
    HRESULT        eHR = S_OK;
    bool			fLastItem = false;
    IEnumSENTITEM  *pItemizer;
    TTSSentItem    sentItem;
    long           tokenIndex;
    CFEToken       *pWordTok;
    bool           lastWasTerm = false;
	bool			lastWasSil = true;
	TUNE_TYPE		defaultTune = PHRASE_BOUNDARY;
	long			cNumOfItems, cCurItem, cCurWord;
	SPLISTPOS		clusterPos, tempPos;

    m_cNumOfWords = 0;
    pWordTok = NULL;
	clusterPos = NULL;

    if ( eDirection == eNEXT )
    {
        eHR = m_pEnumSent->Next( &pItemizer );
    }
    else
    {
        eHR = m_pEnumSent->Previous( &pItemizer );
    }


    if( eHR == S_OK )
    {
        //--------------------------------------------
        // There's still another sentence to speak
        //--------------------------------------------
        tokenIndex = 0;

		CItemList& ItemList = ((CSentItemEnum*)pItemizer)->_GetList(); 
		cNumOfItems = (ItemList.GetCount()) -1;
		cCurItem = 0;
		
        //------------------------------------
        // Collect all sentence tokens
        //------------------------------------
        while( (eHR = pItemizer->Next( &sentItem )) == S_OK )
        {
			clusterPos = NULL;
            cCurWord = sentItem.ulNumWords;
            for ( ULONG i = 0; i < sentItem.ulNumWords; i++ )
            {
				//------------------------------
				// Always have a working token
				//------------------------------
				if( pWordTok == NULL )
				{
					pWordTok = new CFEToken;
				}
				if( pWordTok )
				{

					if( sentItem.pItemInfo->Type & eWORDLIST_IS_VALID )
					{
						//------------------------------------------
						// Get tag values (vol, rate, pitch, etc.)
						//------------------------------------------
						GetItemControls( sentItem.Words[i].pXmlState, pWordTok );

						//------------------------------------------
						// 
						//------------------------------------------
						
						//-------------------------------------
						// Switch on token type
						//-------------------------------------
						switch ( sentItem.Words[i].pXmlState->eAction )
						{
							case SPVA_Speak:
							case SPVA_SpellOut:
							{
								//----------------------------------
								// Speak this token
								//----------------------------------
								pWordTok->tokLen = sentItem.Words[i].ulWordLen;
								if( pWordTok->tokLen > (TOKEN_LEN_MAX -1) )
								{
									//-----------------------------------
									// Clip to max string length
									//-----------------------------------
									pWordTok->tokLen = TOKEN_LEN_MAX -1;
								}
								//--------------------------
								// Copy token string
								// Append C-string delimiter
								//--------------------------
								memcpy( &pWordTok->tokStr[0], &sentItem.Words[i].pWordText[0], 
										pWordTok->tokLen * sizeof(WCHAR) );
								pWordTok->tokStr[pWordTok->tokLen] = 0;        //string delimiter

								pWordTok->phon_Len = IPA_to_Allo( sentItem.Words[i].pWordPron, 
																	pWordTok->phon_Str );
								pWordTok->POScode = sentItem.Words[i].eWordPartOfSpeech;
								pWordTok->m_posClass = GetPOSClass( pWordTok->POScode );
								pWordTok->srcPosition = sentItem.ulItemSrcOffset;
								pWordTok->srcLen = sentItem.ulItemSrcLen;
								pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
								pWordTok->m_PitchRangeScale = m_CurPitchRange;
								pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;

								//----------------------------------
								// Advance to next token
								//----------------------------------
								tempPos = m_TokList.AddTail( pWordTok );
								if( clusterPos == NULL )
								{
									//--------------------------------------
									// Remember where currentitem started
									//--------------------------------------
									clusterPos = tempPos;
								}
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = false;
								lastWasSil = false;
								
								break;
							}

							case SPVA_Silence:
							{
								(void)InsertSilenceAtTail( pWordTok, &sentItem, sentItem.Words[i].pXmlState->SilenceMSecs );
								pWordTok->m_SilenceSource = SIL_XML;
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = false;
								break;
							}

							case SPVA_Pronounce:
							{
								pWordTok->tokStr[0] = 0;        // There's no orth for Pron types
								pWordTok->tokLen = 0;
								pWordTok->phon_Len = IPA_to_Allo( sentItem.Words[i].pXmlState->pPhoneIds, pWordTok->phon_Str );
								pWordTok->POScode = sentItem.Words[i].eWordPartOfSpeech;
								pWordTok->m_posClass = GetPOSClass( pWordTok->POScode );
								pWordTok->srcPosition = sentItem.ulItemSrcOffset;
								pWordTok->srcLen = sentItem.ulItemSrcLen;
								pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
								pWordTok->m_PitchRangeScale = m_CurPitchRange;
								pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;

								//----------------------------------
								// Advance to next token
								//----------------------------------
								tempPos = m_TokList.AddTail( pWordTok );
								if( clusterPos == NULL )
								{
									//--------------------------------------
									// Remember where currentitem started
									//--------------------------------------
									clusterPos = tempPos;
								}
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = false;
								lastWasSil = false;
								break;
							}

							case SPVA_Bookmark:
							{
								BOOKMARK_ITEM   *pMarker;
								//-------------------------------------------------
								// Create bookmark list if it's not already there
								//-------------------------------------------------
								if( pWordTok->pBMObj == NULL )
								{
									pWordTok->pBMObj = new CBookmarkList;
								}
								if( pWordTok->pBMObj )
								{
									//--------------------------------------------------------
									// Allocate memory for bookmark string
									// (add 1 to length for string delimiter)
									//--------------------------------------------------------
									pWordTok->tokLen = sentItem.Words[i].ulWordLen;
									pMarker = new BOOKMARK_ITEM;
									if (pMarker)
									{
										//----------------------------------------
										// We'll need the text ptr and length
										// when this bookmark event gets posted
										//----------------------------------------
										pMarker->pBMItem = (LPARAM)sentItem.pItemSrcText;
										//--- Punch NULL character into end of bookmark string for Event...
										WCHAR* pTemp = (WCHAR*) sentItem.pItemSrcText + sentItem.ulItemSrcLen;
										*pTemp = 0;

										//-----------------------------------
										// Add this bookmark to list
										//-----------------------------------
										pWordTok->pBMObj->m_BMList.AddTail( pMarker );
									}
								}
								break;
							}

							default:
							{
								SPDBG_DMSG1( "Unknown SPVSTATE eAction: %d\n", sentItem.Words[i].pXmlState->eAction );
								break;
							}
						}
					}
					else
					{
						//-----------------------------
						// Maybe token is punctuation
						//-----------------------------
						if ( fIsPunctuation(sentItem) )
						{
							TUNE_TYPE    bType = NULL_BOUNDARY;

							switch ( sentItem.pItemInfo->Type )
							{
								case eCOMMA:
								case eSEMICOLON:
								case eCOLON:
                                case eHYPHEN:
									if( !lastWasSil )
									{
										bType = PHRASE_BOUNDARY;
									}
									break;
								case ePERIOD:
									if( fLastItem )
									{
										bType = DECLAR_BOUNDARY;
									}
									else
									{
										defaultTune = DECLAR_BOUNDARY;
									}
									break;
								case eQUESTION:
									if( fLastItem )
									{
										bType = YN_QUEST_BOUNDARY;
									}
									else
									{
										defaultTune = YN_QUEST_BOUNDARY;
									}
									break;
								case eEXCLAMATION:
									if( fLastItem )
									{
										bType = EXCLAM_BOUNDARY;
									}
									else
									{
										defaultTune = EXCLAM_BOUNDARY;
									}
									break;
							}

							if( (bType != NULL_BOUNDARY) && (tokenIndex > 0) )
							{
								pWordTok->m_TuneBoundaryType = bType;

								pWordTok->phon_Len = 1;
								pWordTok->phon_Str[0] = _SIL_;
								pWordTok->srcPosition = sentItem.ulItemSrcOffset;
								pWordTok->srcLen = sentItem.ulItemSrcLen;
								pWordTok->tokStr[0] = sentItem.pItemSrcText[0]; // punctuation
								pWordTok->tokStr[1] = 0;                       // delimiter
								pWordTok->tokLen = 1;
								pWordTok->m_SilenceSource = SIL_Term;
								pWordTok->m_TermSil = 0;
								//----------------------------------
								// Advance to next token
								//----------------------------------
								tempPos = m_TokList.AddTail( pWordTok );
								if( clusterPos == NULL )
								{
									//--------------------------------------
									// Remember where currentitem started
									//--------------------------------------
									clusterPos = tempPos;
								}
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = true;
								lastWasSil = true;
							}
						}
						else
						{
							switch ( sentItem.pItemInfo->Type )
							{
								//case eSINGLE_QUOTE:
								case eDOUBLE_QUOTE:
									if( StateQuoteProsody( pWordTok, &sentItem, (!fLastItem) & (!lastWasSil) ) )
									{
										if( (!fLastItem) & (!lastWasSil) )
										{
											pWordTok = NULL;         // Get a new ptr next time
											tokenIndex++;
										}
										lastWasTerm = false;
										lastWasSil = true;
									}
									break;

								case eOPEN_PARENTHESIS:
								case eOPEN_BRACKET:
								case eOPEN_BRACE:
									if( StartParenProsody( pWordTok, &sentItem, !fLastItem ) )
									{
										if( !fLastItem )
										{
											pWordTok = NULL;         // Get a new ptr next time
											tokenIndex++;
										}
										lastWasTerm = false;
										lastWasSil = true;
									}
									break;

								case eCLOSE_PARENTHESIS:
								case eCLOSE_BRACKET:
								case eCLOSE_BRACE:
									if( EndParenProsody( pWordTok, &sentItem, !fLastItem ) )
									{
										if( !fLastItem )
										{
											pWordTok = NULL;         // Get a new ptr next time
											tokenIndex++;
										}
										lastWasTerm = false;
										lastWasSil = true;
									}
									break;
							}
						}
					}
				}    
				else
				{
					eHR = E_OUTOFMEMORY;
					break;
				}
				if( --cCurWord == 0 )
				{
					cCurItem++;
				}
				if( cCurItem == cNumOfItems )
				{
					fLastItem = true;
				}
			}
			
			//-------------------------------------
			// Tag special word clusters
			//-------------------------------------
			ProsodyTemplates( clusterPos, &sentItem );
			
		}

        pItemizer->Release();

        //------------------------------------------------------
        // Make sure sentence ends on termination
        //------------------------------------------------------
        if( !lastWasTerm )
        {
            //------------------------
            // Add a comma
            //------------------------
            if( pWordTok == NULL )
            {
                pWordTok = new CFEToken;
            }
            if( pWordTok )
            {
                pWordTok->m_TuneBoundaryType = defaultTune;
				pWordTok->m_BoundarySource = BND_ForcedTerm;
				pWordTok->m_SilenceSource = SIL_Term;
                pWordTok->phon_Len = 1;
                pWordTok->phon_Str[0] = _SIL_;
                pWordTok->srcPosition = sentItem.ulItemSrcOffset;
                pWordTok->srcLen = sentItem.ulItemSrcLen;
                pWordTok->tokStr[0] = '.';      // punctuation
                pWordTok->tokStr[1] = 0;                   // delimiter
                pWordTok->tokLen = 1;
               // pWordTok->m_BoundarySource = bndSource;
                //----------------------------------
                // Advance to next token
                //----------------------------------
				tempPos = m_TokList.AddTail( pWordTok );
				if( clusterPos == NULL )
				{
					//--------------------------------------
					// Remember where current item started
					//--------------------------------------
					clusterPos = tempPos;
				}
                pWordTok = NULL;         // Get a new ptr next time
                tokenIndex++;
            }
            else
            {
                //----------------------------------
                // Bail-out or we'll crash
                //----------------------------------
                eHR = E_OUTOFMEMORY;
            }
        }
        m_cNumOfWords = tokenIndex;
        if( eHR == S_FALSE )
        {
            //----------------------------------
            // Return only errors 
            //----------------------------------
            eHR = S_OK;
        }
    }
	else
	{
		eHR = eHR;		// !!!!
	}

    //-------------------------------
    // Cleanup memory allocation
    //-------------------------------
    if( pWordTok != NULL )
    {
        delete pWordTok;
    }

	//---------------------------------------------------
	// Get sentence position and length for SAPI events
	//---------------------------------------------------
	CalcSentenceLength();

    return eHR;
} /* CFrontend::GetSentenceTokens */





/*****************************************************************************
* CFrontend::CalcSentenceLength *
*-------------------------------*
*   Description:
*   Loop thru token list and sum the source char count.
*       
********************************************************************** MC ***/
void CFrontend::CalcSentenceLength()
{
	long		firstIndex, lastIndex, lastLen;
	bool		firstState;
	SPLISTPOS	listPos;
    CFEToken    *pWordTok, *pFirstTok = NULL;

	//---------------------------------------------
	// Find the 1st and last words in sentence
	//---------------------------------------------
	firstIndex = lastIndex = lastLen = 0;
	firstState = true;
	listPos = m_TokList.GetHeadPosition();
	while( listPos )
	{
		pWordTok = m_TokList.GetNext( listPos );
		//-------------------------------------------
		// Look at at displayable words only
		//-------------------------------------------
		if( pWordTok->srcLen > 0 )
		{
			if( firstState )
			{
				firstState = false;
				firstIndex = pWordTok->srcPosition;
				pFirstTok = pWordTok;
			}
			else
			{
				lastIndex = pWordTok->srcPosition;
				lastLen = pWordTok->srcLen;
			}
		}
	}
	//--------------------------------------------------
	// Calculate sentence length for head list item
	//--------------------------------------------------
	if( pFirstTok )
	{
		pFirstTok->sentencePosition = firstIndex;						// Sentence starts here...
		pFirstTok->sentenceLen = (lastIndex - firstIndex) + lastLen;	// ...and this is the length
	}
}



/*****************************************************************************
* CFrontend::DisposeUnits *
*-------------------------*
*   Description:
*   Delete memory allocated to 'm_pUnits'.
*   Clean-up memory for Bookmarks 
*       
********************************************************************** MC ***/
#ifdef USE_VOICEDATAOBJ
void CFrontend::DisposeUnits( )
{
    SPDBG_FUNC( "CFrontend::DisposeUnits" );
    ULONG   unitIndex;

    if( m_pUnits )
    {
        //-----------------------------------------
        // Clean-up Bookmark memory allocation
        //-----------------------------------------

        for( unitIndex = m_CurUnitIndex; unitIndex < m_unitCount; unitIndex++)
        {
            if( m_pUnits[unitIndex].pBMObj != NULL )
            {
                //---------------------------------------
                // Dispose bookmark list
                //---------------------------------------
                delete m_pUnits[unitIndex].pBMObj;
                m_pUnits[unitIndex].pBMObj = NULL;
            }
        }
        delete m_pUnits;
        m_pUnits = NULL;
    }
} /* CFrontend::DisposeUnits */
#endif


/*****************************************************************************
* CFrontend::ParseNextSentence *
*------------------------------*
*   Description:
*   Fill 'm_pUnits' array with next sentence.
*   If there's no more input text, 
*      return with 'm_SpeechState' set to SPEECH_DONE +++
*       
********************************************************************** MC ***/
HRESULT CFrontend::ParseSentence( DIRECTION eDirection )
{
    SPDBG_FUNC( "CFrontend::ParseNextSentence" );
    HRESULT hr = S_OK;
   
    //-----------------------------------------------------
    // If there's a previous unit array, free its memory
    //-----------------------------------------------------
#ifdef USE_VOICEDATAOBJ
    DisposeUnits();
#endif
    m_CurUnitIndex = 0;
    m_unitCount = 0;
    DeleteTokenList();
#ifdef USE_VOICEDATAOBJ
    m_pUnits = NULL;
#endif
    //-----------------------------------------------------
    // If there's a previous allo array, free its memory
    //-----------------------------------------------------
    if( m_pAllos )
    {
        delete m_pAllos;
        m_pAllos = NULL;
    }
    
    //-----------------------------------------------------
    // Fill token array with next sentence
    // Skip empty sentences.
    // NOTE: includes non-speaking items
    //-----------------------------------------------------
    do
    {
        hr = GetSentenceTokens( eDirection );
    } while( (hr == S_OK) && (m_cNumOfWords == 0) );

    if( hr == S_OK )
    {
        //--------------------------------------------
        // Prepare word emphasis
        //--------------------------------------------
		DoWordAccent();

        //--------------------------------------------
        // Word level prosodic lables
        //--------------------------------------------
        DoPhrasing();
        ToBISymbols();

        //--------------------------------------------
        // Convert tokens to allo list
        //--------------------------------------------
         m_pAllos = new CAlloList;
        if (m_pAllos == NULL)
        {
            //-----------------------
            // Out of memory
            //-----------------------
            hr = E_FAIL;
        }
        if(  SUCCEEDED(hr) )
        {
            //--------------------------------
            // Convert word to allo strteam
            //-------------------------------
            TokensToAllo( &m_TokList, m_pAllos );

            //----------------------------
            // Tag sentence syllables
            //----------------------------
            m_SyllObj.TagSyllables( m_pAllos );

           //--------------------------------------------
            // Dispose token array, no longer needed
            //--------------------------------------------
            DeleteTokenList();

            //--------------------------------------------
			// Create the unit array
			// NOTE: 
            //--------------------------------------------
#ifdef USE_VOICEDATAOBJ
			hr = UnitLookahead ();
			if( hr == S_OK )
			{
				//--------------------------------------------
				// Compute allo durations
				//--------------------------------------------
                UnitToAlloDur( m_pAllos, m_pUnits );
				m_DurObj.AlloDuration( m_pAllos, m_RateRatio_API );
				//--------------------------------------------
				// Modulate allo pitch
				//--------------------------------------------
				m_PitchObj.AlloPitch( m_pAllos, m_BasePitch, m_PitchRange );
			}
#else
				m_DurObj.AlloDuration( m_pAllos, m_RateRatio_API );
				m_PitchObj.AlloPitch( m_pAllos, m_BasePitch, m_PitchRange );
#endif

        }
#ifdef USE_VOICEDATAOBJ
        if( hr == S_OK )
        {
			AlloToUnitPitch( m_pAllos, m_pUnits );
        }
#endif
    }

    if( FAILED(hr) )
    {
        //------------------------------------------
        // Either the input text is dry or we failed.
        // Try to fail gracefully
        //      1 - Clean up memory
        //      2 - End the speech
        //------------------------------------------
        if( m_pAllos )
        {
            delete m_pAllos;
			m_pAllos = 0;
        }
        DeleteTokenList();
#ifdef USE_VOICEDATAOBJ
        DisposeUnits();
#endif
        m_SpeechState = SPEECH_DONE;
    }
    else if( hr == S_FALSE )
    {
        //---------------------------------
        // No more input text
        //---------------------------------
        hr = S_OK;
        m_SpeechState = SPEECH_DONE;
    }


    return hr;
} /* CFrontend::ParseNextSentence */



/*****************************************************************************
* CFrontend::UnitLookahead *
*--------------------------*
*   Description:
*       
********************************************************************** MC ***/
#ifdef USE_VOICEDATAOBJ
HRESULT CFrontend::UnitLookahead ()
{
    SPDBG_FUNC( "CFrontend::UnitLookahead" );
    HRESULT		hr = S_OK;
	UNIT_CVT	*pPhon2Unit = NULL;
	ULONG		i;

    m_unitCount = m_pAllos->GetCount();

    m_pUnits = new UNITINFO[m_unitCount];
    if( m_pUnits )
    {
		pPhon2Unit = new UNIT_CVT[m_unitCount];
		if( pPhon2Unit )
		{
            //--------------------------------------------
            // Convert allo list to unit array
            //--------------------------------------------
            memset( m_pUnits, 0, m_unitCount * sizeof(UNITINFO) );
            hr = AlloToUnit( m_pAllos, m_pUnits );

			if( SUCCEEDED(hr) )
			{
				//--------------------------------------------
				// Initialize UNIT_CVT
				//--------------------------------------------
				for( i = 0; i < m_unitCount; i++ )
				{
					pPhon2Unit[i].PhonID = m_pUnits[i].PhonID;
					pPhon2Unit[i].flags = m_pUnits[i].flags;
				}
				//--------------------------------------------
				// Compute triphone IDs
				//--------------------------------------------
				hr = m_pVoiceDataObj->GetUnitIDs( pPhon2Unit, m_unitCount );

				if( SUCCEEDED(hr) )
				{
					//--------------------------------------------
					// Copy UNIT_CVT to UNITINFO
					//--------------------------------------------
					for( i = 0; i < m_unitCount; i++ )
					{
						m_pUnits[i].UnitID      = pPhon2Unit[i].UnitID;
						m_pUnits[i].SenoneID    = pPhon2Unit[i].SenoneID;
						m_pUnits[i].duration    = pPhon2Unit[i].Dur;
						m_pUnits[i].amp         = pPhon2Unit[i].Amp;
						m_pUnits[i].ampRatio    = pPhon2Unit[i].AmpRatio;
						strcpy( m_pUnits[i].szUnitName, pPhon2Unit[i].szUnitName );
					}
				}
				else
				{
					//-----------------------
					// Can't get unit ID's
					//-----------------------
					delete m_pUnits;
					m_pUnits = NULL;
				}
			}
			else
			{
				//-----------------------
				// Can't convert allos
				//-----------------------
				delete m_pUnits;
				m_pUnits = NULL;
			}
		}
		else
		{
			//-----------------------
			// Out of memory
			//-----------------------
			delete m_pUnits;
			m_pUnits = NULL;
			hr = E_FAIL;
		}
    }
	else
	{
        //-----------------------
        // Out of memory
        //-----------------------
        hr = E_FAIL;
	}

	//------------------------------
	// Cleanup before exit
	//------------------------------
    if( pPhon2Unit )
    {
        delete pPhon2Unit;
    }


	return hr;
} /* CFrontend::UnitLookahead */
#endif

/*****************************************************************************
* CFrontend::UnitToAlloDur *
*--------------------------*
*   Description:
*       
********************************************************************** MC ***/
void    CFrontend::UnitToAlloDur( CAlloList *pAllos, UNITINFO *pu )
{
    SPDBG_FUNC( "CFrontend::UnitToAlloDur" );
    CAlloCell   *pCurCell;
    
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
        pCurCell->m_UnitDur = pu->duration;
        pu++;
		pCurCell = pAllos->GetNextCell();
    }
} /* CFrontend::UnitToAlloDur */



/*****************************************************************************
* CFrontend::AlloToUnitPitch *
*----------------------------*
*   Description:
*       
********************************************************************** MC ***/
#ifdef USE_VOICEDATAOBJ
void    CFrontend::AlloToUnitPitch( CAlloList *pAllos, UNITINFO *pu )
{
    SPDBG_FUNC( "CFrontend::AlloToUnitPitch" );
    ULONG       k;
    CAlloCell   *pCurCell;
    
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
        pu->duration = pCurCell->m_ftDuration;
        for( k = 0; k < pu->nKnots; k++ )
        {
            pu->pTime[k]    = pCurCell->m_ftTime[k] * m_SampleRate;
            pu->pF0[k]      = pCurCell->m_ftPitch[k];
            pu->pAmp[k]     = pu->ampRatio;
        }
        pu++;
		pCurCell = pAllos->GetNextCell();
    }
} /* CFrontend::AlloToUnitPitch */
#endif

/*****************************************************************************
* CAlloList::DeleteTokenList *
*----------------------------*
*   Description:
*   Remove every item in link list.
*       
********************************************************************** MC ***/
void CFrontend::DeleteTokenList()
{
    SPDBG_FUNC( "CFrontend::DeleteTokenList" );
    CFEToken   *pTok;

    while( !m_TokList.IsEmpty() )
    {
        pTok = (CFEToken*)m_TokList.RemoveHead();
        delete pTok;
    }

} /* CFrontend::DeleteTokenList */



/*****************************************************************************
* AdjustQuestTune *
*-----------------*
*   Description:
*   Adjust termination for either YN or WH sentence tune.
*       
********************************************************************** MC ***/
static void AdjustQuestTune( CFEToken *pTok, bool fIsYesNo )
{
    SPDBG_FUNC( "AdjustQuestTune" );
    if ( pTok->m_TuneBoundaryType > NULL_BOUNDARY )
    {
	if( (pTok->m_TuneBoundaryType == YN_QUEST_BOUNDARY) ||
        (pTok->m_TuneBoundaryType == WH_QUEST_BOUNDARY) )
		{
		//------------------------------------
		// Is this a yes/no question phrase
		//------------------------------------
		if( fIsYesNo )
			{
			//------------------------------------------
			// Put out a final yes/no question marker
			//------------------------------------------
			pTok->m_TuneBoundaryType = YN_QUEST_BOUNDARY;
			pTok->m_BoundarySource = BND_YNQuest;
			}
		else 
			{
		
			//------------------------------------------------------------------------
			// Use declarative phrase marker (for WH questions)
			//------------------------------------------------------------------------
			pTok->m_TuneBoundaryType = WH_QUEST_BOUNDARY;
			pTok->m_BoundarySource = BND_WHQuest;
			}
		}
    }
} /* AdjustQuestTune */


typedef enum
{
	p_Interj,
    P_Adv,
	P_Verb,
	P_Adj,
    P_Noun,
	PRIORITY_SIZE,
} CONTENT_PRIORITY;

#define	NO_POSITION	-1


/*****************************************************************************
* CFrontend::ExclamEmph *
*-----------------------*
*   Description:
*   Find a likely word to emph if sentence has exclamation
*       
********************************************************************** MC ***/
void    CFrontend::ExclamEmph()
{
    SPDBG_FUNC( "CFrontend::ExclamEmph" );
    CFEToken        *pCur_Tok;
	SPLISTPOS		listPos, targetPos, curPos, contentPos[PRIORITY_SIZE];
	long			cContent, cWords;
	long			i;

	for(i = 0; i < PRIORITY_SIZE; i++ )
	{
		contentPos[i] = (SPLISTPOS)NO_POSITION;
	}

	listPos = m_TokList.GetTailPosition();
	pCur_Tok = m_TokList.GetNext( listPos );

	//---------------------------------------------------
	// First, check last token fors an exclamation
	//---------------------------------------------------
	if( pCur_Tok->m_TuneBoundaryType == EXCLAM_BOUNDARY )
	{
		//-----------------------------------------------------
		// Then, see if there's only one content word
		// in the sentence
		//-----------------------------------------------------
		cContent = cWords = 0;
		listPos = m_TokList.GetHeadPosition();
		while( listPos )
		{
			curPos = listPos;
			pCur_Tok = m_TokList.GetNext( listPos );
			if( pCur_Tok->m_posClass == POS_CONTENT )
			{
				cContent++;
				cWords++;
				if( cContent == 1)
				{
					targetPos = curPos;
				}
				//--------------------------------------------------------
				// Fill the famous Azara Content Prominence Hierarchy (ACPH)
				//--------------------------------------------------------
				if( (pCur_Tok->POScode == MS_Noun) && (contentPos[P_Noun] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Noun] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Verb) && (contentPos[P_Verb] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Verb] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Adj) && (contentPos[P_Adj] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Adj] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Adv) && (contentPos[P_Adv] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Adv] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Interjection) && (contentPos[p_Interj] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[p_Interj] = curPos;
				}
			}
			else if( pCur_Tok->m_posClass == POS_FUNC )
			{
				cWords++;
				if( cWords == 1)
				{
					targetPos = curPos;
				}
			}
		}

		//--------------------------------------------
		// If there's only one word or content word
		// then EMPHASIZE it
		//--------------------------------------------
		if( (cContent == 1) || (cWords == 1) )
		{
			pCur_Tok = m_TokList.GetNext( targetPos );
			pCur_Tok->user_Emph = 1;
		}
		else if( cContent > 1 )
		{
			for(i = 0; i < PRIORITY_SIZE; i++ )
			{
				if( contentPos[i] != (SPLISTPOS)NO_POSITION )
				{
					targetPos = contentPos[i];
					break;
				}
			}
			pCur_Tok = m_TokList.GetNext( targetPos );
			pCur_Tok->user_Emph = 1;
		}
	}
} //ExclamEmph



/*****************************************************************************
* CFrontend::DoWordAccent *
*-------------------------*
*   Description:
*   Prepare word for emphasis
*       
********************************************************************** MC ***/
void    CFrontend::DoWordAccent()
{
    SPDBG_FUNC( "CFrontend::DoWordAccent" );
    long            cNumOfWords;
    long            iCurWord;
    CFEToken        *pCur_Tok, *pNext_Tok, *pPrev_Tok, *pTempTok;
	SPLISTPOS		listPos;
    TUNE_TYPE       cur_Bnd, prev_Bnd;

    //-----------------------------
    // Initilize locals
    //-----------------------------
	cNumOfWords = m_TokList.GetCount();
	if( cNumOfWords > 0 )
	{
		ExclamEmph();
		prev_Bnd = PHRASE_BOUNDARY;			// Assume start of sentence
		//-------------------------------------
		// Fill the token pipeline
		//-------------------------------------
		listPos = m_TokList.GetHeadPosition();

		//-- Previous
		pPrev_Tok = NULL;

		//-- Current
		pCur_Tok = m_TokList.GetNext( listPos );

		//-- Next
		if( listPos )
		{
			pNext_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext_Tok = NULL;
		}

		//-----------------------------------
		// Step through entire word array
		//  (skip last)
		//-----------------------------------
		for( iCurWord = 0; iCurWord < (cNumOfWords -1); iCurWord++ )
		{
			cur_Bnd = pCur_Tok->m_TuneBoundaryType;
			if( pCur_Tok->user_Emph > 0 )
			{
				//-----------------------------------
				// Current word is emphasized
				//-----------------------------------
				if( prev_Bnd == NULL_BOUNDARY ) 
				{
					pTempTok = new CFEToken;
					if( pTempTok )
					{
						pTempTok->user_Break	  = EMPH_HESITATION;
						pTempTok->m_TuneBoundaryType = NULL_BOUNDARY;
						pTempTok->phon_Len = 1;
						pTempTok->phon_Str[0] = _SIL_;
						pTempTok->srcPosition = pCur_Tok->srcPosition;
						pTempTok->srcLen = pCur_Tok->srcLen;
						pTempTok->tokStr[0] = 0;        // There's no orth for Break
						pTempTok->tokLen = 0;
						pTempTok->m_TermSil = 0;
						pTempTok->m_SilenceSource = SIL_Emph;
						pTempTok->m_DurScale	= 0;
						if( pPrev_Tok )
						{
							//pTempTok->m_DurScale = pPrev_Tok->m_DurScale;
							pTempTok->m_ProsodyDurScale = pPrev_Tok->m_ProsodyDurScale;
							pTempTok->user_Volume = pPrev_Tok->user_Volume;
						}
						else
						{
							//pTempTok->m_DurScale = 1.0f;
							pTempTok->m_ProsodyDurScale = 1.0f;
						}

						m_TokList.InsertBefore( m_TokList.FindIndex( iCurWord ), pTempTok );
						pCur_Tok = pTempTok;
						m_cNumOfWords++;
						cNumOfWords++;
						iCurWord++;
					}
				}
			}
			//------------------------------
			// Shift the token pipeline
			//------------------------------
			prev_Bnd	= cur_Bnd;
			pPrev_Tok	= pCur_Tok;
			pCur_Tok	= pNext_Tok;
			if( listPos )
			{
				pNext_Tok = m_TokList.GetNext( listPos );
			}
			else
			{	
				pNext_Tok = NULL;
			}

		}
	}
} /* CFrontend::DoWordAccent */



/*****************************************************************************
* CFrontend::DoPhrasing *
*-----------------------*
*   Description:
*   Insert sub-phrase boundaries into word token array
*       
********************************************************************** MC ***/
void    CFrontend::DoPhrasing()
{
    SPDBG_FUNC( "CFrontend::DoPhrasing" );
    long            iCurWord;
    CFEToken        *pCur_Tok, *pNext_Tok, *pNext2_Tok, *pNext3_Tok, *pTempTok, *pPrev_Tok;
    ENGPARTOFSPEECH  cur_POS, next_POS, next2_POS, next3_POS, prev_POS;
    bool            fNext_IsPunct, fNext2_IsPunct, fNext3_IsPunct;
    bool            fIsYesNo, fMaybeWH, fHasDet, fInitial_Adv, fIsShortSent, fIsAlphaWH;
    TUNE_TYPE       cur_Bnd, prev_Punct;
    long            punctDistance;
    long            cNumOfWords;
	SPLISTPOS		listPos;
    BOUNDARY_SOURCE   bndNum;
    ACCENT_SOURCE	  accNum;
   
    //-----------------------------
    // Initialize locals
    //-----------------------------
	cNumOfWords = m_TokList.GetCount();
	if( cNumOfWords > 0 )
	{
		cur_Bnd			= NULL_BOUNDARY;
		prev_POS		= MS_Unknown;
		prev_Punct		= PHRASE_BOUNDARY;			// Assume start of sentence
		punctDistance	= 0;						// To quiet the compiler...
		fIsYesNo		= fMaybeWH = fHasDet = fIsAlphaWH = false;    // To quiet the compiler...
		fMaybeWH		= false;
		fInitial_Adv	= false;
		if (cNumOfWords <= 9) 
		{
			fIsShortSent = true;
		}
		else
		{
			fIsShortSent = false;
		}
    
		//-------------------------------------
		// Fill the token pipeline
		//-------------------------------------
		listPos = m_TokList.GetHeadPosition();
		//-- Previous
		pPrev_Tok = NULL;
		//-- Current
		pCur_Tok = m_TokList.GetNext( listPos );
		//-- Next
		if( listPos )
		{
			pNext_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext_Tok = NULL;
		}
		//-- Next 2
		if( listPos )
		{
			pNext2_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext2_Tok = NULL;
		}
		//-- Next 3
		if( listPos )
		{
			pNext3_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext3_Tok = NULL;
		}

		//-----------------------------------
		// Step through entire word array
		//  (skip last)
		//-----------------------------------
		for( iCurWord = 0; iCurWord < (cNumOfWords -1); iCurWord++ )
		{
			bndNum = BND_NoSource;
			accNum = ACC_NoSource;

			if( (prev_Punct > NULL_BOUNDARY) && (prev_Punct < SUB_BOUNDARY_1) )
			{
				punctDistance = 1;
				fIsYesNo = true;
				fMaybeWH = false;
				fHasDet = false;
				fIsAlphaWH = false;
			}
			else
			{
				punctDistance++;
			}
			//------------------------------------
			// Process new word
			//------------------------------------
			cur_POS = pCur_Tok->POScode;
			cur_Bnd = NULL_BOUNDARY;
			//------------------------------------
			// Don't depend on POS to detect 
			// "WH" question
			//------------------------------------
			if( ((pCur_Tok->tokStr[0] == 'W') || (pCur_Tok->tokStr[0] == 'w')) &&
				((pCur_Tok->tokStr[1] == 'H') || (pCur_Tok->tokStr[1] == 'h')) )
			{
				fIsAlphaWH = true;
			}
			else
			{
				fIsAlphaWH = false;
			}
        
			//------------------------------------
			// Look ahead to NEXT word
			//------------------------------------
			next_POS = pNext_Tok->POScode;
			if( pNext_Tok->m_TuneBoundaryType != NULL_BOUNDARY )
			{
				fNext_IsPunct = true;
			}
			else
			{
				fNext_IsPunct = false;
			}
        
			//------------------------------------
			// Look ahead 2 positions
			//------------------------------------
			if( pNext2_Tok )
			{
				next2_POS = pNext2_Tok->POScode;
				if( pNext2_Tok->m_TuneBoundaryType != NULL_BOUNDARY )
				{
					fNext2_IsPunct = true;
				}
				else
				{
					fNext2_IsPunct = false;
				}
			}
			else
			{
				next2_POS = MS_Unknown;
				fNext2_IsPunct = false;
			}
        
			//------------------------------------
			// Look ahead 3 positions
			//------------------------------------
			if( pNext3_Tok )
			{
				next3_POS = pNext3_Tok->POScode;
				if( pNext3_Tok->m_TuneBoundaryType != NULL_BOUNDARY )
				{
					fNext3_IsPunct = true;
				}
				else
				{
					fNext3_IsPunct = false;
				}
			}
			else
			{
				next3_POS = MS_Unknown;
				fNext3_IsPunct = false;
			}
        
			//------------------------------------------------------------------------
			// Is phrase a yes/no question?
			//------------------------------------------------------------------------
			if( punctDistance == 1 )
			{
				if( (cur_POS == MS_Interr) || (fIsAlphaWH) )
				{
					//---------------------------------
					// It's a "WH" question
					//---------------------------------
					fIsYesNo = false;
				}
				else if( (cur_POS == MS_Prep) || (cur_POS == MS_Conj) || (cur_POS == MS_CConj) )
				{
					fMaybeWH = true;
				}
			}
			else if( (punctDistance == 2) && (fMaybeWH) && 
					 ((cur_POS == MS_Interr) || (cur_POS == MS_RelPron) || (fIsAlphaWH)) )
			{
				fIsYesNo = false;
			}

			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
			// SUB_BOUNDARY_1: Insert boundary after sentence-initial adverb
			//
			// Reluctantly __the cat sat on the mat.
			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
			if( fInitial_Adv )
			{
				cur_Bnd = SUB_BOUNDARY_1;
				fInitial_Adv = false;
				bndNum = BND_PhraseRule1;
				accNum = ACC_PhraseRule1;
			}
			else
			{

				if( (punctDistance == 1) && 
					(cur_POS == MS_Adv) && (next_POS == MS_Det) )
				// include
				//LEX_SUBJPRON // he
				//LEX_DPRON  // this
				//LEX_IPRON  // everybody
				//NOT LEX_PPRON  // myself 
				{
					fInitial_Adv = true;
				}
				else 
				{
					fInitial_Adv = false;
				}

				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before coordinating conjunctions
				// The cat sat on the mat __and cleaned his fur.
				//
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				if( (cur_POS == MS_CConj) &&
					(fHasDet == false) &&
					(punctDistance > 3) &&
					(next2_POS != MS_Conj) )
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule2;
					accNum = ACC_PhraseRule2;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before adverb
				// The cat sat on the mat __reluctantly.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if(    (cur_POS == MS_Adv) && 
					(punctDistance > 4) && 
					(next_POS != MS_Adj) )
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule3;
					accNum = ACC_PhraseRule3;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary after object pronoun
				// The cat sat with me__ on the mat.
				//
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (prev_POS == MS_ObjPron) && (punctDistance > 2))
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule4;
					accNum = ACC_PhraseRule4;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before subject pronoun or contraction
				// The cat sat on the mat _I see.
				// The cat sat on the mat _I'm sure.
				//
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ((cur_POS == MS_SubjPron) || (cur_POS == MS_Contr) ) && 
					(punctDistance > 3) && (prev_POS != MS_RelPron) && (prev_POS != MS_Conj))
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule5;
					accNum = ACC_PhraseRule5;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before interr
				// The cat sat on the mat _how odd.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (cur_POS == MS_Interr) && (punctDistance > 4)  )
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule6;
					accNum = ACC_PhraseRule6;
				}
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after subject noun phrase followed by aux verb 
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary before vaux after noun phrase
				// The gray cat __should sit on the mat.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (punctDistance > 2) && 
					( ((prev_POS == MS_Noun) || (prev_POS == MS_Verb)) && (prev_POS != MS_VAux) ) && 
					(cur_POS == MS_VAux)
					)
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule7;
					accNum = ACC_PhraseRule7;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after MS_Interr
				// The gray cat __should sit on the mat.
				// SEE ABOVE???
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				/*else if( (prev_POS == MS_Noun) && ((next_POS != MS_RelPron) && 
					(next_POS != MS_VAux) && (next_POS != MS_RVAux) && 
					(next2_POS != MS_VAux) && (next2_POS != MS_RVAux)) && 
					(punctDistance > 4) && 
					((cur_POS == MS_VAux) || (cur_POS == MS_RVAux)))
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule8;
					accNum = ACC_PhraseRule8;
				}*/
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after MS_Interr
				// The cat sat on the mat _how odd.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (prev_POS == MS_Noun) && (next_POS != MS_RelPron) && 
					(next_POS != MS_Conj) &&  
					(next_POS != MS_CConj) && (punctDistance > 3)  && (cur_POS == MS_Verb))
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule9;
					accNum = ACC_PhraseRule9;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after MS_Interr
				// The cat sat on the mat _how odd.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				/*else if( (prev_POS == MS_Noun) && (cur_POS != MS_RelPron) && 
					(cur_POS != MS_RVAux) && (cur_POS != MS_CConj) && 
					(cur_POS != MS_Conj) && (punctDistance > 2) && 
					((punctDistance > 2) || (fIsShortSent)) && (cur_POS == MS_Verb))
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule10;
					accNum = ACC_PhraseRule10;
				}
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_4:Insert boundary before conjunction
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ((cur_POS == MS_Conj) && (punctDistance > 3) && 
					(fNext_IsPunct == false) && 
					(prev_POS != MS_Conj) && (prev_POS != MS_CConj) &&
					(fNext2_IsPunct == false)) ||
                
					( (prev_POS == MS_VPart) && (cur_POS != MS_Prep) && 
					(cur_POS != MS_Det) && 
					(punctDistance > 2) && 
					((cur_POS == MS_Noun) || (cur_POS == MS_Noun) || (cur_POS == MS_Adj))) ||
                
					( (cur_POS == MS_Interr) && (punctDistance > 2) && 
					(cur_POS == MS_SubjPron)) )
				{
					cur_Bnd = SUB_BOUNDARY_4;
					bndNum = BND_PhraseRule11;
					accNum = ACC_PhraseRule11;
				}
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_5:Insert boundary before relative pronoun
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ( (cur_POS == MS_RelPron) && (punctDistance >= 3)  && 
					(prev_POS != MS_Prep) && (next3_POS != MS_VAux) && 
					(next3_POS != MS_RVAux)  && 
					( (prev_POS == MS_Noun) || (prev_POS == MS_Verb) ) ) ||
                
					( (cur_POS == MS_Quant) && (punctDistance > 5) && 
					(prev_POS != MS_Adj) && (prev_POS != MS_Det) && 
					(prev_POS != MS_VAux) && (prev_POS != MS_RVAux) && 
					(prev_POS != MS_Det) && (next2_POS != MS_CConj) && 
					(fNext_IsPunct == false)))
				{
					cur_Bnd = SUB_BOUNDARY_5;
					bndNum = BND_PhraseRule12;
					accNum = ACC_PhraseRule12;
				}*/
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_6:Silverman87-style, content/function tone group boundaries. 
				// Does trivial sentence-final function word look-ahead check.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ( (prev_POS == MS_Noun) || (prev_POS == MS_Verb) || (prev_POS == MS_Adj) || (prev_POS == MS_Adv)) 
					&& ((cur_POS != MS_Noun) && (cur_POS != MS_Verb) && (cur_POS != MS_Adj) && (cur_POS != MS_Adv))
					&& (fNext_IsPunct == false)) 
				{
					cur_Bnd = SUB_BOUNDARY_6;
					bndNum = BND_PhraseRule13;
					accNum = ACC_PhraseRule13;
				}
			}
			//------------------------------------------------------------------------
			// If phrasing was found, save it
			//------------------------------------------------------------------------
			if( (cur_Bnd != NULL_BOUNDARY) && (iCurWord > 0) &&
				//!(fNext_IsPunct) && 
				!(prev_Punct) &&
				(pCur_Tok->m_TuneBoundaryType == NULL_BOUNDARY) )
			{
				//pCur_Tok->m_TuneBoundaryType = cur_Bnd;
				pTempTok = new CFEToken;
				if( pTempTok )
				{
					pTempTok->m_TuneBoundaryType = cur_Bnd;
					pTempTok->phon_Len = 1;
					pTempTok->phon_Str[0] = _SIL_;
					pTempTok->srcPosition = pCur_Tok->srcPosition;
					pTempTok->srcLen = pCur_Tok->srcLen;
					pTempTok->tokStr[0] = '+';				// punctuation
					pTempTok->tokStr[1] = 0;                // delimiter
					pTempTok->tokLen = 1;
					pTempTok->m_TermSil = 0;
					pTempTok->m_DurScale	= 0;
					if( pPrev_Tok )
					{
						pPrev_Tok->m_AccentSource = accNum;
						pPrev_Tok->m_BoundarySource = bndNum;
						pPrev_Tok->m_Accent = K_LHSTAR;
					}
					pTempTok->m_SilenceSource = SIL_SubBound;
					if( pPrev_Tok )
					{
						//pTempTok->m_DurScale = pPrev_Tok->m_DurScale;
						pTempTok->m_ProsodyDurScale = pPrev_Tok->m_ProsodyDurScale;
						pTempTok->user_Volume = pPrev_Tok->user_Volume;
					}
					else
					{
						//pTempTok->m_DurScale = 1.0f;
						pTempTok->m_ProsodyDurScale = 1.0f;
					}

					m_TokList.InsertBefore( m_TokList.FindIndex( iCurWord ), pTempTok );
					pCur_Tok = pTempTok;
					m_cNumOfWords++;
					cNumOfWords++;
					iCurWord++;
				}
			}
			//-------------------------------
			// Process sentence punctuation
			//-------------------------------
			 AdjustQuestTune( pCur_Tok, fIsYesNo );
       
			//-------------------------------
			// Prepare for next word
			//-------------------------------
			prev_Punct = pCur_Tok->m_TuneBoundaryType;
			prev_POS = cur_POS;
			pPrev_Tok = pCur_Tok;

			//------------------------------
			// Shift the token pipeline
			//------------------------------
			pCur_Tok	= pNext_Tok;
			pNext_Tok	= pNext2_Tok;
			pNext2_Tok	= pNext3_Tok;
			if( listPos )
			{
				pNext3_Tok = m_TokList.GetNext( listPos );
			}
			else
			{	
				pNext3_Tok = NULL;
			}

			//------------------------------------------------------------------------
			// Keep track of when determiners encountered to help in deciding 
			// when to allow a strong 'and' boundary (SUB_BOUNDARY_2)
			//------------------------------------------------------------------------
			if( punctDistance > 2) 
			{
				fHasDet = false;
			}
			if( cur_POS == MS_Det )
			{
				fHasDet = true;
			}
		}
		//-------------------------------------
		// Process final sentence punctuation
		//-------------------------------------
		pCur_Tok = (CFEToken*)m_TokList.GetTail();
		AdjustQuestTune( pCur_Tok, fIsYesNo );
	}


} /* CFrontend::DoPhrasing */



/*****************************************************************************
* CFrontend::RecalcProsody *
*--------------------------*
*   Description:
*   In response to a real-time rate change, recalculate duration and pitch
*       
********************************************************************** MC ***/
#ifdef USE_VOICEDATAOBJ
void CFrontend::RecalcProsody()
{
    SPDBG_FUNC( "CFrontend::RecalcProsody" );
    UNITINFO*   pu;
    CAlloCell*  pCurCell;
    ULONG		k;

    //--------------------------------------------
    // Compute new allo durations
    //--------------------------------------------
	/*pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        //pCurCell->m_DurScale = 1.0;
		pCurCell = m_pAllos->GetNextCell();
    }*/
    m_DurObj.AlloDuration( m_pAllos, m_RateRatio_API );

    //--------------------------------------------
    // Modulate allo pitch
    //--------------------------------------------
    m_PitchObj.AlloPitch( m_pAllos, m_BasePitch, m_PitchRange );

    pu = m_pUnits;
	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        pu->duration = pCurCell->m_ftDuration;
        for( k = 0; k < pu->nKnots; k++ )

        {
            pu->pTime[k]    = pCurCell->m_ftTime[k] * m_SampleRate;
            pu->pF0[k]      = pCurCell->m_ftPitch[k];
            pu->pAmp[k]     = pu->ampRatio;
        }
        pu++;
		pCurCell = m_pAllos->GetNextCell();
    }
} /* CFrontend::RecalcProsody */
#endif

/*****************************************************************************
* CFrontend::NextData *
*---------------------*
*   Description:
*   This gets called from the backend when UNIT stream is dry.
*   Parse TOKENS to ALLOS to UNITS
*       
********************************************************************** MC ***/
HRESULT CFrontend::NextData( void **pData, SPEECH_STATE *pSpeechState )
{
    SPDBG_FUNC( "CFrontend::NextData" );
    bool    haveNewRate = false;
    HRESULT hr = S_OK;

    //-----------------------------------
    // First, check and see if SAPI has an action
    //-----------------------------------
	// Check for rate change
	long baseRateRatio;
	if( m_pOutputSite->GetActions() & SPVES_RATE )
	{
		hr = m_pOutputSite->GetRate( &baseRateRatio );
		if ( SUCCEEDED( hr ) )
		{
			if( baseRateRatio > SPMAX_VOLUME )
			{
				//--- Clip rate to engine maximum
				baseRateRatio = MAX_USER_RATE;
			}
			else if ( baseRateRatio < MIN_USER_RATE )
			{
				//--- Clip rate to engine minimum
				baseRateRatio = MIN_USER_RATE;
			}
			m_RateRatio_API = CntrlToRatio( baseRateRatio );
			haveNewRate = true;
		}
	}

    //---------------------------------------------
    // Async stop?
    //---------------------------------------------
    if( SUCCEEDED( hr ) && ( m_pOutputSite->GetActions() & SPVES_ABORT ) )
    {
        m_SpeechState = SPEECH_DONE;
    }

    //---------------------------------------------
    // Async skip?
    //---------------------------------------------
    if( SUCCEEDED( hr ) && ( m_pOutputSite->GetActions() & SPVES_SKIP ) )
    {
		SPVSKIPTYPE SkipType;
		long SkipCount = 0;

		hr = m_pOutputSite->GetSkipInfo( &SkipType, &SkipCount );

		if ( SUCCEEDED( hr ) && SkipType == SPVST_SENTENCE )
		{
			IEnumSENTITEM *pGarbage;
			//--- Skip Forwards
			if ( SkipCount > 0 )
			{
				long OriginalSkipCount = SkipCount;
				while ( SkipCount > 1 && 
						( hr = m_pEnumSent->Next( &pGarbage ) ) == S_OK )
				{
					SkipCount--;
					pGarbage->Release();
				}
				if ( hr == S_OK )
				{
					hr = ParseSentence( eNEXT );
					if ( SUCCEEDED( hr ) )
					{
						SkipCount--;
					}
				}
				else if ( hr == S_FALSE )
				{
					m_SpeechState = SPEECH_DONE;
				}
				SkipCount = OriginalSkipCount - SkipCount;
			}
			//--- Skip Backwards
			else if ( SkipCount < 0 )
			{
				long OriginalSkipCount = SkipCount;
				while ( SkipCount < -1 &&
						( hr = m_pEnumSent->Previous( &pGarbage ) ) == S_OK )
				{
					SkipCount++;
					pGarbage->Release();
				}
				if ( hr == S_OK )
				{
					hr = ParseSentence( ePREVIOUS );
                    // This case is different from the forward skip, needs to test that
                    // Parse sentence found something to parse!
					if ( SUCCEEDED( hr ) && m_SpeechState != SPEECH_DONE)
					{
						SkipCount++;
					}
				}
				else if ( hr == S_FALSE )
				{
					m_SpeechState = SPEECH_DONE;
				}
				SkipCount = OriginalSkipCount - SkipCount;
			}
			//--- Skip to beginning of this sentence
			else
			{
				m_CurUnitIndex = 0;
			}
			hr = m_pOutputSite->CompleteSkip( SkipCount );
		}
    }

    //---------------------------------------------
    // Make sure we're still speaking
    //---------------------------------------------
    if( SUCCEEDED( hr ) && m_SpeechState != SPEECH_DONE )
    {
		/*****
        if( m_CurUnitIndex >= m_unitCount)
        {
            //-----------------------------------
            // Get next sentence from Normalizer
            //-----------------------------------
            hr = ParseSentence( eNEXT );
			//m_SpeechState = SPEECH_DONE;
        }
        else if( haveNewRate )
        {
            //-----------------------------------
            // Recalculate prosody to new rate
            //-----------------------------------
            RecalcProsody();
        }

		if( SUCCEEDED(hr) )
		{
			if( m_SpeechState != SPEECH_DONE )
			{
				//-----------------------------------
				// Get next phon
				//-----------------------------------
				m_pUnits[m_CurUnitIndex].hasSpeech = m_HasSpeech;
				*pData =( void*)&m_pUnits[m_CurUnitIndex];
				m_CurUnitIndex++;
			}
		}
		*****/

        hr = ParseSentence( eNEXT );
        if ( SUCCEEDED( hr ) && m_SpeechState == SPEECH_CONTINUE )
        {
		    SentenceData *pSentData = new SentenceData;
            pSentData->pPhones      = new Phone[ m_pAllos->GetCount() ];
            ZeroMemory( pSentData->pPhones, m_pAllos->GetCount() * sizeof( Phone ) );
            pSentData->ulNumPhones  = m_pAllos->GetCount();

            m_PitchObj.GetContour( &pSentData->pf0, &pSentData->ulNumf0 );

            float RunTime = 0.0;
            float InitialSil = 0.0;
            bool fInitialSil = true;
            char  ph[512];
            typedef const char *(*MapPhoneSetFunc) (ALLO_CODE);
            MapPhoneSetFunc  MapPhoneSet;

            if (m_fNewPhoneSet)
            {
                MapPhoneSet = NewMapPhoneSet;
            }
            else
            {
                MapPhoneSet = OldMapPhoneSet;
            }
            for ( int i = 0; i < m_pAllos->GetCount(); i++ )
            {
                CAlloCell *pCurCell = m_pAllos->GetCell( i );
                strcpy ( ph, MapPhoneSet( pCurCell->m_allo ) );
                //--- adding stress info for vowels
//                if ( ( pCurCell->m_ctrlFlags & PRIMARY_STRESS ) && IsVowel ( ph ) )
//                {
//                    strcat( ph, "s");
//                }

                strcpy( pSentData->pPhones[i].phone, ph  );
                //--- Skip initial SIL
                if ( fInitialSil && 
                     stricmp( pSentData->pPhones[i].phone, "sil" ) == 0 )
                {
                    InitialSil                += pCurCell->m_ftDuration;
                    pSentData->pPhones[i].f0  = 0;
                    pSentData->pPhones[i].end = InitialSil;
                    continue;
                }
                //--- Skip final SIL
                else if ( i == m_pAllos->GetCount() - 1 &&
                          stricmp( pSentData->pPhones[i].phone, "sil" ) == 0 )
                {
                    pSentData->pPhones[i].end = RunTime + InitialSil;
                    break;
                }
                else
                {
                    fInitialSil = false;
                pSentData->pPhones[i].f0 = 
                    GetPhoneF0( pSentData->pf0, RunTime, pCurCell->m_ftDuration );
                RunTime += pCurCell->m_ftDuration;
                    pSentData->pPhones[i].end = RunTime + InitialSil;
                }
            }
		    *pData = (void*) pSentData;
        }
    }
    //-------------------------------------------
    // Let client know if text input is dry
    //-------------------------------------------
    *pSpeechState = m_SpeechState;

    return hr;
} /* CFrontend::NextData */

/*****************************************************************************
*  IsVowel *
*----------*
*       
*********************************************************************** WD ***/
bool IsVowel ( char* ph )
{
    if ( ph )
    {
        if ( ph[0] == 'a' || ph[0] == 'e' || ph[0] == 'i' || ph[0] == 'o' || 
             ph[0] == 'u' )
        {
            return true;
        }
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\mainnorm.cpp ===
/*******************************************************************************
* MainNorm.cpp *
*--------------*
*	Description:
*		
*-------------------------------------------------------------------------------
*  Created By: AH										  Date: 01/18/2000
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

/*****************************************************************************
* CStdSentEnum::Normalize *
*-------------------------*
*  
********************************************************************** AH ***/
HRESULT CStdSentEnum::Normalize( CItemList& ItemList, SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::Normalize" );
    HRESULT hr = S_OK;
    TTSItemInfo* pItemNormInfo = NULL;
    CWordList WordList;
    const SPVTEXTFRAG* pTempFrag = m_pCurrFrag;
    TTSSentItem& TempItem = ItemList.GetAt( ListPos );
    if ( TempItem.pItemInfo )
    {
        pItemNormInfo = TempItem.pItemInfo;
    }

    //--- Match the normalization category of the current token.
    if ( m_pCurrFrag->State.eAction == SPVA_Speak )
    {
        if ( !pItemNormInfo                         || 
             ( pItemNormInfo->Type != eABBREVIATION &&
               pItemNormInfo->Type != eINITIALISM ) )
        {
            hr = MatchCategory( pItemNormInfo, MemoryManager, WordList );
        }
    }
    //--- Action must be SPVA_SpellOut - assign eSPELLOUT as category
    else
    {
        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eSPELLOUT;
        }
    }

    if (SUCCEEDED(hr))
    {
        switch ( pItemNormInfo->Type )
        {

        //--- Alpha Word - just insert into the Item List.
        case eALPHA_WORD:
            {
                CSentItem Item;
                Item.pItemSrcText       = m_pNextChar;
                Item.ulItemSrcLen       = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                Item.ulItemSrcOffset    = pTempFrag->ulTextSrcOffset +
                                          (ULONG)( m_pNextChar - pTempFrag->pTextStart );
                Item.ulNumWords         = 1;
                Item.Words              = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( Item.Words, sizeof(TTSWord) );
                    Item.Words[0].pXmlState         = &pTempFrag->State;
                    Item.Words[0].pWordText         = m_pNextChar;
                    Item.Words[0].ulWordLen         = Item.ulItemSrcLen;
                    Item.Words[0].pLemma            = Item.Words[0].pWordText;
                    Item.Words[0].ulLemmaLen        = Item.Words[0].ulWordLen;
                    Item.Words[0].eWordPartOfSpeech = MS_Unknown;
                    Item.eItemPartOfSpeech          = MS_Unknown;
                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo*), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo->Type = eALPHA_WORD;
                        ItemList.SetAt( ListPos, Item );
                    }
                }
            }
            break;

        case eABBREVIATION:
        case eABBREVIATION_NORMALIZE:
        case eINITIALISM:
            break;

        //--- Multi-token categories have already been expanded into WordList, now just accumulate
        //---   words, and insert back into the Item List.
        case eNEWNUM_PHONENUMBER:
            //--- Special case - remove parentheses (of area code), if present in the item list
            {
                SPLISTPOS TempPos = ListPos;
                CSentItem Item = ItemList.GetPrev( TempPos );
                if ( TempPos )
                {
                    SPLISTPOS RemovePos = TempPos;
                    Item = ItemList.GetPrev( TempPos );
                    if ( Item.pItemInfo->Type == eOPEN_PARENTHESIS &&
                         ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode )
                    {
                        ItemList.RemoveAt( RemovePos );
                        m_pNextChar--;
                    }
                }
            }
        case eNUM_CURRENCY:
        case eNUM_CURRENCYRANGE:
        case eTIMEOFDAY:
        case eDATE_LONGFORM:
        case eSTATE_AND_ZIPCODE:
        case eTIME_RANGE:
            {
                //--- Set Item data, and add to ItemList.
                if ( SUCCEEDED( hr ) )
                {
                    CSentItem Item;
                    Item.pItemSrcText       = m_pNextChar;
                    Item.ulItemSrcLen       = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                    Item.ulItemSrcOffset    = pTempFrag->ulTextSrcOffset +
                                              (ULONG)( m_pNextChar - pTempFrag->pTextStart );
                    hr = SetWordList( Item, WordList, MemoryManager );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo = pItemNormInfo;
                        ItemList.SetAt( ListPos, Item );
                    }
                }
            }
            break;

        //--- Expand the single token, according to its normalization category.
        default:
            hr = ExpandCategory( pItemNormInfo, ItemList, ListPos, MemoryManager );
            break;
        }
    }

    return hr;
} /* Normalize */

/*****************************************************************************
* CStdSentEnum::MatchCategory *
*-----------------------------*
*  
********************************************************************** AH ***/
HRESULT CStdSentEnum::MatchCategory( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager,
                                     CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::MatchCategory" );
    SPDBG_ASSERT( m_pNextChar );

    HRESULT hr = E_INVALIDARG;

    //--- Context has been specified
    if ( m_pCurrFrag->State.Context.pCategory )
    {
        if ( wcsicmp( m_pCurrFrag->State.Context.pCategory, L"ADDRESS" ) == 0 )
        {
            hr = IsZipCode( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
        }
        else if ( wcsnicmp( m_pCurrFrag->State.Context.pCategory, L"DATE", 4 ) == 0 )
        {
            hr = IsNumericCompactDate( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            if ( hr == E_INVALIDARG )
            {
                hr = IsMonthStringCompactDate( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            }
        }
        else if ( wcsnicmp( m_pCurrFrag->State.Context.pCategory, L"TIME", 4 ) == 0 )
        {
            hr = IsTime( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
        }
        else if ( wcsnicmp( m_pCurrFrag->State.Context.pCategory, L"NUM", 3 ) == 0 )
        {
            hr = IsNumberCategory( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            if ( hr == E_INVALIDARG )
            {
                hr = IsRomanNumeral( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            }
        }
        else if ( wcsicmp( m_pCurrFrag->State.Context.pCategory, L"PHONE_NUMBER" ) == 0 )
        {
            hr = IsPhoneNumber( pItemNormInfo, L"PHONE_NUMBER", MemoryManager, WordList );
        }
    }
    //--- Default Context
    if ( hr == E_INVALIDARG )
    {
        //--- Do ALPHA Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsAlphaWord( m_pNextChar, m_pEndOfCurrItem, pItemNormInfo, MemoryManager );
            //--- Check ALPHA Exceptions
            if ( SUCCEEDED( hr ) )
            {
				hr = E_INVALIDARG;
                if ( hr == E_INVALIDARG )
                {
                    hr = IsLongFormDate_DMDY( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = IsLongFormDate_DDMY( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = IsStateAndZipcode( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = IsCurrency( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = S_OK;
                }
            }
        }
        //--- Do Multi-Token Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsLongFormDate_DMDY( pItemNormInfo, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsLongFormDate_DDMY( pItemNormInfo, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsCurrency( pItemNormInfo, MemoryManager, WordList );
        }
        //--- Do TIME Normalization check
        if ( hr == E_INVALIDARG )
        {
            hr = IsTimeRange( pItemNormInfo, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsTimeOfDay( pItemNormInfo, MemoryManager, WordList );
        }
        //--- Do NUMBER Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsPhoneNumber( pItemNormInfo, NULL, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsNumberCategory( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsNumberRange( pItemNormInfo, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsCurrencyRange( pItemNormInfo, MemoryManager, WordList );
        }
        //--- Do DATE Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsNumericCompactDate( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsMonthStringCompactDate( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsDecade( pItemNormInfo, MemoryManager );
        }
        //--- Do TIME Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsTime( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsHyphenatedString( m_pNextChar, m_pEndOfCurrItem, pItemNormInfo, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsSuffix( m_pNextChar, m_pEndOfCurrItem, pItemNormInfo, MemoryManager );
        }
    }

    if ( hr == E_INVALIDARG &&
         !pItemNormInfo )
    {
        hr = S_OK;
        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eUNMATCHED;
        }
    }
    else if ( hr == E_INVALIDARG &&
              pItemNormInfo )
    {
        hr = S_OK;
    }

    return hr;
} /* MatchCategory */

/*****************************************************************************
* CStdSentEnum::ExpandCategory *
*------------------------------*
*  Expands previously matched items in the Item List into their normalized
* forms.
********************************************************************** AH ***/
HRESULT CStdSentEnum::ExpandCategory( TTSItemInfo*& pItemNormInfo, CItemList& ItemList, SPLISTPOS ListPos, 
                                      CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandCategory" );

    HRESULT hr = S_OK;
    CSentItem Item;
    CWordList WordList;
    
    Item.pItemSrcText = m_pNextChar;
    Item.ulItemSrcLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    Item.ulItemSrcOffset = m_pCurrFrag->ulTextSrcOffset +
                           (ULONG)( m_pNextChar - m_pCurrFrag->pTextStart );
    
    switch ( pItemNormInfo->Type )
    {

    case eNUM_ROMAN_NUMERAL:
        switch ( ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo->Type )
        {
        case eDATE_YEAR:
            hr = ExpandYear( (TTSYearItemInfo*) ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo, 
                             WordList );
            break;
        default:
            hr = ExpandNumber( (TTSNumberItemInfo*) ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo, 
                               WordList );
            break;
        }
        break;

    case eNUM_CARDINAL:
    case eNUM_ORDINAL:
    case eNUM_DECIMAL:
    case eNUM_FRACTION:
    case eNUM_MIXEDFRACTION:
        hr = ExpandNumber( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_PERCENT:
        hr = ExpandPercent( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_DEGREES:
        hr = ExpandDegrees( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_SQUARED:
        hr = ExpandSquare( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_CUBED:
        hr = ExpandCube( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_ZIPCODE:
        hr = ExpandZipCode( (TTSZipCodeItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_RANGE:
        hr = ExpandNumberRange( (TTSNumberRangeItemInfo*) pItemNormInfo, WordList );
        break;

    case eDATE:
        hr = ExpandDate( (TTSDateItemInfo*) pItemNormInfo, WordList );
        break;

    case eDATE_YEAR:
        hr = ExpandYear( (TTSYearItemInfo*) pItemNormInfo, WordList );
        break;

    case eDECADE:
        hr = ExpandDecade( (TTSDecadeItemInfo*) pItemNormInfo, WordList );
        break;

    case eTIME:
        hr = ExpandTime( (TTSTimeItemInfo*) pItemNormInfo, WordList );
        break;

    case eHYPHENATED_STRING:
        hr = ExpandHyphenatedString( (TTSHyphenatedStringInfo*) pItemNormInfo, WordList );
        break;

    case eSUFFIX:
        hr = ExpandSuffix( (TTSSuffixItemInfo*) pItemNormInfo, WordList );
        break;

    case eSPELLOUT:
        hr = SpellOutString( WordList );
        break;

    case eUNMATCHED:
    default:
        hr = ExpandUnrecognizedString( WordList, MemoryManager );
        break;

    }

    //--- Set Item data, and add to ItemList.
    if ( SUCCEEDED( hr ) )
    {
        hr = SetWordList( Item, WordList, MemoryManager );
        if ( SUCCEEDED( hr ) )
        {
            Item.pItemInfo = pItemNormInfo;
            ItemList.SetAt( ListPos, Item );
        }
    }

    return hr;
} /* ExpandCategory */

/*****************************************************************************
* CStdSentEnum::DoUnicodeToAsciiMap *
*-----------------------------------*
*   Description:
*       Maps incoming strings to known values.
********************************************************************* AH ****/
HRESULT CStdSentEnum::DoUnicodeToAsciiMap( const WCHAR *pUnicodeString, ULONG ulUnicodeStringLength,
                                           WCHAR *pConvertedString )
{
    SPDBG_FUNC( "CSpVoice::DoUnicodeToAsciiMap" );
    HRESULT hr = S_OK;
    unsigned char *pBuffer = NULL;
    WCHAR *pWideCharBuffer = NULL;

    if ( pUnicodeString )
    {
        //--- Make copy of pUnicodeString 
        pWideCharBuffer = new WCHAR[ulUnicodeStringLength+1];
        if ( !pWideCharBuffer )
        {
            hr = E_OUTOFMEMORY;
        }
        if ( SUCCEEDED( hr ) )
        {
            wcsncpy( pWideCharBuffer, pUnicodeString, ulUnicodeStringLength );
            pWideCharBuffer[ulUnicodeStringLength] = 0;

            pBuffer = new unsigned char[ulUnicodeStringLength+1];
            if ( !pBuffer || !pWideCharBuffer )
            {
                hr = E_OUTOFMEMORY;
            }
            if ( SUCCEEDED(hr) )
            {
                pBuffer[ulUnicodeStringLength] = 0;
                if ( ulUnicodeStringLength > 0 ) 
                {
                    //--- Map WCHARs to ANSI chars 
                    if ( !WideCharToMultiByte( 1252, NULL, pWideCharBuffer, ulUnicodeStringLength, (char*) pBuffer, 
                                               ulUnicodeStringLength, &g_pFlagCharacter, NULL ) )
                    {
                        hr = E_UNEXPECTED;
                    }
                    //--- Use internal table to map ANSI to ASCII 
                    for (ULONG i = 0; i < ulUnicodeStringLength && SUCCEEDED(hr); i++)
                    {
                        pBuffer[i] = g_AnsiToAscii[pBuffer[i]];
                    }
                    //--- Map back to WCHARs 
                    for ( i = 0; i < ulUnicodeStringLength && SUCCEEDED(hr); i++ )
                    {
                        pConvertedString[i] = pBuffer[i];
                    }
                }
            }
        }
    }
    else
    {
        pConvertedString = NULL;
    }
    
    if (pBuffer)
    {
        delete [] pBuffer;
    }
    if (pWideCharBuffer)
    {
        delete [] pWideCharBuffer;
    }

    return hr;
} /* CStdSentEnum::DoUnicodeToAsciiMap */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\morph.cpp ===
/*******************************************************************************
* morph.cpp *
*-----------*
*   Description:
*       This is the implementation of the CSMorph class, which attempts to find
*   pronunciations for morphologcical variants (which are not in the lexicon) of
*   root words (which are in the lexicon).
*-------------------------------------------------------------------------------
*  Created By: AH, based partly on code by MC                     Date: 08/16/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

// Additional includes...
#include "stdafx.h"
#include "morph.h"
#include "spttsengdebug.h"

/*****************************************************************************
* CSMorph::CSMorph *
*------------------*
*	Description:    Constructor - just sets the Master Lexicon pointer...
*		
********************************************************************** AH ***/
CSMorph::CSMorph( ISpLexicon *pMasterLex, HRESULT *phr ) 
{
    SPDBG_FUNC( "CSMorph::CSMorph" );
    SPDBG_ASSERT( phr != NULL );

    m_pMasterLex = pMasterLex;

    // Initialize the SuffixInfoTable - obtain lock to make sure this only happens once...
    g_SuffixInfoTableCritSec.Lock();
    if (!SuffixInfoTableInitialized)
    {
        CComPtr<ISpPhoneConverter> pPhoneConv;
        *phr = SpCreatePhoneConverter(1033, NULL, NULL, &pPhoneConv);

        for (int i = 0; i < sp_countof(g_SuffixInfoTable); i++)
        {
            *phr = pPhoneConv->PhoneToId(g_SuffixInfoTable[i].SuffixString, g_SuffixInfoTable[i].SuffixString);
            if ( FAILED( *phr ) )
            {
                break;
            }
        }

        if (SUCCEEDED(*phr))
        {
            *phr = pPhoneConv->PhoneToId(g_phonS, g_phonS);
            if (SUCCEEDED(*phr))
            {
                *phr = pPhoneConv->PhoneToId(g_phonZ, g_phonZ);
                if (SUCCEEDED(*phr))
                {
                    *phr = pPhoneConv->PhoneToId(g_phonAXz, g_phonAXz);
                    if (SUCCEEDED(*phr))
                    {
                        *phr = pPhoneConv->PhoneToId(g_phonT, g_phonT);
                        if (SUCCEEDED(*phr))
                        {
                            *phr = pPhoneConv->PhoneToId(g_phonD, g_phonD);
                            if (SUCCEEDED(*phr))
                            {
                                *phr = pPhoneConv->PhoneToId(g_phonAXd, g_phonAXd);
                                if (SUCCEEDED(*phr))
                                {
                                    *phr = pPhoneConv->PhoneToId(g_phonAXl, g_phonAXl);
                                    if ( SUCCEEDED( *phr ) )
                                    {
                                        *phr = pPhoneConv->PhoneToId(g_phonIY, g_phonIY);
                                        if ( SUCCEEDED( *phr ) )
                                        {
                                            *phr = pPhoneConv->PhoneToId(g_phonL, g_phonL);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (SUCCEEDED(*phr))
    {
        SuffixInfoTableInitialized = true;
    }
    g_SuffixInfoTableCritSec.Unlock();

} /* CSMorph::CSMorph */


/*****************************************************************************
* CSMorph::DoSuffixMorph *
*------------------------*
*	Description:    This is the only interface function of CSMorph - it 
*       takes the same arguments as a GetPronunciations() call, and does
*       basically the same thing.  
*		
********************************************************************** AH ***/
HRESULT CSMorph::DoSuffixMorph( const WCHAR *pwWord, WCHAR *pwRoot, LANGID LangID, DWORD dwFlags,
                                SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    SPDBG_FUNC( "CSMorph::DoSuffixMorph" );
    HRESULT hr = S_OK;
    SUFFIX_TYPE suffixCode;
    WCHAR TargWord[SP_MAX_WORD_LENGTH] = {0};
    long RootLen = 0;
    CSuffixList SuffixList;
    bool    bGotMorph, bNotDone, bLTS;

    if ( !pwWord || !pWordPronunciationList )
    {
        hr = E_POINTER;
    }

    else if ( SP_IS_BAD_WRITE_PTR( pwRoot )                        ||
              SPIsBadLexWord(pwWord)                               || 
              SPIsBadWordPronunciationList(pWordPronunciationList) || 
              LangID != 1033)
    {
        hr = E_INVALIDARG;
    }
    
    if (SUCCEEDED(hr)) 
    {        
        // INITIALIZE locals...
        suffixCode = NO_MATCH;
        bGotMorph = false;
        bNotDone = true;
        bLTS = false;

        wcscpy( TargWord, pwWord );           // Copy orth string...
        _wcsupr( TargWord );                  // ...and convert to uppercase
        RootLen = wcslen( TargWord );
        
        // Keep trying to match another suffix until a root word is matched in the lexicon, or
        // until some error condition is reached - no more suffix matches, etc.
        while ( !bGotMorph && bNotDone )
        {
            // Try to match a suffix...
            suffixCode = MatchSuffix( TargWord, &RootLen );
            // ...add it to the suffix list...
            if (suffixCode != NO_MATCH)
            {
                SuffixList.AddHead(&g_SuffixInfoTable[suffixCode]);
            }
            
            // ...and then behave appropriately.
            switch (suffixCode)
            {

                //------------------------------------------------------------
                // S - two special cases for +s suffix...
                //------------------------------------------------------------
            case S_SUFFIX:
                
                //--- Don't strip an S if it is preceded by another S...
                if ( TargWord[RootLen-1] == L'S' )
                {
                    bNotDone = false;
                    RootLen++;
                    SuffixList.RemoveHead();
                    if (!SuffixList.IsEmpty() && (dwFlags & eLEXTYPE_PRIVATE2))
                    {
                        hr = LTSLookup(pwWord, RootLen, pWordPronunciationList);
                        if (SUCCEEDED(hr))
                        {
                            bLTS = true;
                            bGotMorph = true;
                        }
                    }
                    else 
                    {
                        hr = SPERR_NOT_IN_LEX;
                    }
                    break; 
                }

                hr = LexLookup(TargWord, RootLen, dwFlags, pWordPronunciationList);
                if ( SUCCEEDED(hr) ) 
                {
                    bGotMorph = true;
                } 
                else if ( hr != SPERR_NOT_IN_LEX ) 
                {
                    bNotDone = false;
                }
                else if ( TargWord[RootLen - 1] == L'E' )
                {
                    hr = CheckYtoIEMutation(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if (SUCCEEDED(hr))
                    {
                        bGotMorph = true;
                    }
                    else if (hr != SPERR_NOT_IN_LEX)
                    {
                        bNotDone = false;
                    }
                    else
                    {
                        hr = LexLookup(TargWord, RootLen - 1, dwFlags, pWordPronunciationList);
                        if (SUCCEEDED(hr))
                        {
                            bGotMorph = true;
                        }
                        else if (hr != SPERR_NOT_IN_LEX)
                        {
                            bNotDone = false;
                        }
                    }
                }
                break;

                //------------------------------------------------------------
                // ICALLY_SUFFIX - special case, RAID #3201
                //------------------------------------------------------------
            case ICALLY_SUFFIX:
                hr = LexLookup( TargWord, RootLen + 2, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    bGotMorph = true;
                }
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                }
                else
                {
                    RootLen += 2;
                }
                break;

                //-------------------------------------------------------------
                // ILY_SUFFIX - special case, RAID #6571
                //-------------------------------------------------------------
            case ILY_SUFFIX:
                hr = CheckForMissingY( TargWord, RootLen, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    RootLen++;
                    bGotMorph = true;
                }
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                }
                break;

                //------------------------------------------------------------
                // ICISM_SUFFIX, ICIZE_SUFFIX - special case, RAID #6492
                //------------------------------------------------------------
            case ICISM_SUFFIX:
            case ICIZE_SUFFIX:
                hr = LexLookup( TargWord, RootLen + 2, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    bGotMorph = true;
                    for ( SPWORDPRONUNCIATION* pIterator = pWordPronunciationList->pFirstWordPronunciation;
                          pIterator; pIterator = pIterator->pNextWordPronunciation )
                    {
                        pIterator->szPronunciation[ wcslen( pIterator->szPronunciation ) - 1 ] = g_phonS[0];
                    }
                }
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                }
                else
                {
                    RootLen += 2;
                }
                break;

                //------------------------------------------------------------
                // NO_MATCH
                //------------------------------------------------------------
            case NO_MATCH:

                bNotDone = false;
                if (!SuffixList.IsEmpty() && (dwFlags & eLEXTYPE_PRIVATE2))
                {
                    hr = LTSLookup(pwWord, RootLen, pWordPronunciationList);
                    if (SUCCEEDED(hr))
                    {
                        bLTS = true;
                        bGotMorph = true;
                    }
                }
                else 
                {
                    hr = SPERR_NOT_IN_LEX;
                }
                break; 

                //----------------------------------------------------------------
                // ABLY - special case (for probably, etc.) RAID #3168
                //----------------------------------------------------------------
            case ABLY_SUFFIX:
                hr = CheckAbleMutation( TargWord, RootLen, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    for ( SPWORDPRONUNCIATION *pIterator = pWordPronunciationList->pFirstWordPronunciation;
                          pIterator; pIterator = pIterator->pNextWordPronunciation )
                    {
                        if ( wcslen( pIterator->szPronunciation ) > 2 &&
                             wcscmp( ( pIterator->szPronunciation + 
                                       ( wcslen( pIterator->szPronunciation ) - 2 ) ),
                                     g_phonAXl ) == 0 )
                        {
                            wcscpy( ( pIterator->szPronunciation +
                                      ( wcslen( pIterator->szPronunciation ) - 2 ) ),
                                    g_phonL );
                        }
                    }
                    SuffixList.RemoveHead();
                    SuffixList.AddHead( &g_SuffixInfoTable[Y_SUFFIX] );
                    bGotMorph = true;
                    break;
                }   
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                    break;
                }
                //--- else no break - just continue on to default behavior...

                //------------------------------------------------------------
                // ALL OTHER SUFFIXES
                //------------------------------------------------------------
                
            default:

                // If applicable, try looking up the root with an added e first - this prevents things like
                // "taping" coming out as "tapping" rather than "tape +ing"
                // FIX BUG #2301, #3649 - ONLY Try with added e if the root does not end in o, e, w, or y
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) && 
                     (g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckForMissingE) &&
                     TargWord[RootLen-1] != L'O' &&
                     ( TargWord[RootLen-1] != L'E' || suffixCode == ED_SUFFIX ) &&
                     TargWord[RootLen-1] != L'W' &&
                     TargWord[RootLen-1] != L'Y' )
                {
                    hr = CheckForMissingE(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        RootLen++;
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                // Try looking up the root...
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) )
                {
                    hr = LexLookup(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                // If previous lookups failed, try looking up the root with a 'y' in place of the final 'i'...
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) && 
                     (g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckYtoIMutation) )
                {
                    hr = CheckYtoIMutation(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                // If previous lookups failed, try looking up the root with an undoubled ending...
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) && 
                     (g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckDoubledMutation) )
                {
                    hr = CheckDoubledMutation(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        RootLen--;
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                //--- If previous lookups failed, try looking up the root with an added 'l'
                if ( ( SUCCEEDED( hr ) || hr == SPERR_NOT_IN_LEX ) &&
                     ( g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckForMissingL ) )
                {
                    hr = CheckForMissingL( TargWord, RootLen, dwFlags, pWordPronunciationList );
                    if ( SUCCEEDED( hr ) )
                    {
                        RootLen++;
                        bGotMorph = true;
                        break;
                    }
                    else if ( hr != SPERR_NOT_IN_LEX )
                    {
                        bNotDone = false;
                        break;
                    }
                }

                break;

            } // switch (SuffixCode)
        } // while ( !bGotMorph && bNotDone )
        if ( SUCCEEDED(hr) && bGotMorph ) 
        {
            if (!SuffixList.IsEmpty())
            {
                //--- Copy found root word into out parameter, pwRoot
                wcsncpy( pwRoot, TargWord, RootLen );
                //--- Log info to debug file
                TTSDBG_LOGMORPHOLOGY( pwRoot, SuffixList, STREAM_MORPHOLOGY );
                if (bLTS)
                {
                    hr = AccumulateSuffixes_LTS( &SuffixList, pWordPronunciationList );
                }
                else
                {
                    hr = AccumulateSuffixes( &SuffixList, pWordPronunciationList );
                }
            }
        }
    }

    return hr;
} /* CSMorph::DoSuffixMorph */


/*****************************************************************************
* CSMorph::MatchSuffix *
*----------------------*
*	Description:    This function attempts to match a suffix in TargWord.
*		
********************************************************************** AH ***/
SUFFIX_TYPE CSMorph::MatchSuffix( WCHAR *TargWord, long *RootLen )
{
    SPDBG_FUNC( "CSMorph::MatchSuffix" );
    SUFFIX_TYPE suffixCode = NO_MATCH;
    long RootEnd = *RootLen - 1;
    const WCHAR *pTempSuffix = NULL;

    for (int i = 0; i < sp_countof(g_SuffixTable); i++) 
    {
        pTempSuffix = g_SuffixTable[i].Orth;
        while ( (TargWord[RootEnd] == *pTempSuffix) && (RootEnd > 1) && (suffixCode == NO_MATCH) )
        {
            RootEnd--;
            pTempSuffix++;
            if ( *pTempSuffix == '\0' )
            {
                suffixCode = g_SuffixTable[i].Type;
            }
        }
        if (suffixCode != NO_MATCH)
        {
            *RootLen = RootEnd + 1;
            break;
        }
        else
        {
            RootEnd = *RootLen - 1;
        }
    }

    return suffixCode;
} /* CSMorph::MatchSuffix */


/*****************************************************************************
* CSMorph::LexLookup *
*--------------------*
*	Description:    Try to look up the hypothesized root in the lexicon.
*		
********************************************************************** MC ***/
HRESULT CSMorph::LexLookup( const WCHAR *pOrth, long length, DWORD dwFlags, 
                            SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    SPDBG_FUNC( "CSMorph::LexLookup" );
    WCHAR  targRoot[SP_MAX_WORD_LENGTH];
    memset (targRoot, 0, SP_MAX_WORD_LENGTH * sizeof(WCHAR));
    HRESULT hr = SPERR_NOT_IN_LEX;
    
    //---------------------------------
    // Copy root candidate only...
    //---------------------------------
    for( long i = 0; i < length; i++ )
    {
        targRoot[i] = pOrth[i];
    }
    targRoot[i] = 0;    // Delimiter
    
    //---------------------------------
    // ...and look it up
    //---------------------------------
    if (dwFlags & eLEXTYPE_USER)
    {
        hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_USER, pWordPronunciationList );
    }
    if ((hr == SPERR_NOT_IN_LEX) && (dwFlags & eLEXTYPE_APP))
    {
        hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_APP, pWordPronunciationList );
    }
    if ((hr == SPERR_NOT_IN_LEX) && (dwFlags & eLEXTYPE_PRIVATE1))
    {
        hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_PRIVATE1, pWordPronunciationList );
    }

    return hr;
} /* CSMorph::LexLookup */


/*****************************************************************************
* CSMorph::LTSLookup *
*--------------------*
*	Description:    Try to get a pronunciation for the hypothesized root from 
*       the LTS lexicon...
*		
********************************************************************** AH ***/
HRESULT CSMorph::LTSLookup( const WCHAR *pOrth, long length, 
                            SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    SPDBG_FUNC( "CSMorph::LTSLookup" );
    WCHAR targRoot[SP_MAX_WORD_LENGTH];
    memset(targRoot, 0, SP_MAX_WORD_LENGTH * sizeof(WCHAR));
    HRESULT hr = S_OK;

    //-------------------------------
    // Copy root candidate only...
    //-------------------------------
    for ( long i = 0; i < length; i++ )
    {
        targRoot[i] = pOrth[i];
    }
    targRoot[i] = 0;

    //-------------------------------
    // ...and look it up
    //-------------------------------
    hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_PRIVATE2, pWordPronunciationList );

    return hr;
} /* CSMorph::LTSLookup */


/*****************************************************************************
* CSMorph::AccumulateSuffixes *
*-----------------------------*
*	Description:    Append pronunciations of all the suffixes to the
*       retrieved pronunciation of the root word.
*   
*   First attempt a very strict derivation, where each suffix appended has
*   a "To" part of speech which matches the part of speech of the current
*   state of the entire word.  Ex:
*
*       govern (Verb) + ment (Verb -> Noun) + s (Noun -> Noun) -> governments (Noun)
*
*   If this fails, just accumulate all the pronunciations, and use all of
*   the "To" parts of speech of the last suffix.  Ex:
*
*       cat (Noun) + ing (Verb -> Verb, Verb -> Adj, Verb -> Noun) -> catting (Verb, Adj, Noun)
*		
********************************************************************** AH ***/
HRESULT CSMorph::AccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList ) 
{
    /********** Local Variable Declarations **********/
    SPWORDPRONUNCIATIONLIST *pTempWordPronunciationList;
    SPWORDPRONUNCIATION *pWordPronIterator = NULL, *pTempWordPronunciation = NULL;
    SPLISTPOS ListPos;
    SUFFIXPRON_INFO *SuffixPronInfo;
    ENGPARTOFSPEECH ActivePos[NUM_POS] = {MS_Unknown}, FinalPos[NUM_POS] = {MS_Unknown};
    WCHAR pBuffer[SP_MAX_PRON_LENGTH], pSuffixString[10];
    DWORD dwTotalSize = 0, dwNumActivePos = 0, dwNumFinalPos = 0;
    HRESULT hr = S_OK;
    bool bPOSMatch = false, bDerivedAWord = false;

    /********** Allocate enough space for the modified pronunciations **********/
    dwTotalSize = sizeof(SPWORDPRONUNCIATIONLIST) + 
        (NUM_POS * (sizeof(SPWORDPRONUNCIATION) + (SP_MAX_PRON_LENGTH * sizeof(WCHAR))));
    pTempWordPronunciationList = new SPWORDPRONUNCIATIONLIST;
    if ( !pTempWordPronunciationList )
    {
        hr = E_OUTOFMEMORY;
    }
    if ( SUCCEEDED( hr ) )
    {
        memset(pTempWordPronunciationList, 0, sizeof(SPWORDPRONUNCIATIONLIST));
        hr = ReallocSPWORDPRONList( pTempWordPronunciationList, dwTotalSize );
    }

    /************************************
     *  First Attempt Strict Derivation *
     ************************************/

    /********** Set Initial Values of prounciation list iterators **********/
    if (SUCCEEDED(hr))
    {
        pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
        pTempWordPronunciation = pTempWordPronunciationList->pFirstWordPronunciation;
    }

    /********** Iterate over pWordPronunciationList **********/
    while (SUCCEEDED(hr) && pWordPronIterator)
    {
        // Store the pronunciation in a buffer...
        wcscpy(pBuffer, pWordPronIterator->szPronunciation);

        // Initialize variables which are local to the next loop...
        bPOSMatch = true;
        ListPos = pSuffixList->GetHeadPosition();

        ActivePos[0] = (ENGPARTOFSPEECH)pWordPronIterator->ePartOfSpeech;
        dwNumActivePos = 1;

        /********** Iterate over the SuffixList **********/
        while ( SUCCEEDED(hr) && ListPos && bPOSMatch ) 
        {
            // Initialize variables which are local to the next loop...
            bPOSMatch = false;
            SuffixPronInfo = pSuffixList->GetNext( ListPos );
            wcscpy(pSuffixString, SuffixPronInfo->SuffixString);
            ENGPARTOFSPEECH NextActivePos[NUM_POS] = {MS_Unknown};
            DWORD dwNumNextActivePos = 0;
            
            /********** Iterate over the active parts of speech **********/
            for (DWORD j = 0; j < dwNumActivePos; j++)
            {
                /********** Iterate over the possible conversions of each suffix **********/
                for (short i = 0; i < SuffixPronInfo->NumConversions; i++)
                {
                    /********** Check POS compatability **********/
                    if (SuffixPronInfo->Conversions[i].FromPos == ActivePos[j])
                    {
                        if (!SearchPosSet(SuffixPronInfo->Conversions[i].ToPos, NextActivePos, dwNumNextActivePos))
                        {
                            NextActivePos[dwNumNextActivePos] = SuffixPronInfo->Conversions[i].ToPos;
                            dwNumNextActivePos++;

                            /********** One time only - concatenate pronunciation, and change POSMatch flag to true **********/
                            if (dwNumNextActivePos == 1)
                            {
                                bPOSMatch = true;

                                // Append suffix to the rest of the pronunciation...
                                // Special Cases...
                                if (pSuffixString[0] == g_phonS[0] && pSuffixString[1] == '\0')
                                {
                                    hr = Phon_SorZ( pBuffer, wcslen(pBuffer) - 1 );
                                }
                                else if (pSuffixString[0] == g_phonD[0] && pSuffixString[1] == '\0')
                                {
                                    hr = Phon_DorED( pBuffer, wcslen(pBuffer) - 1 );
                                }
                                // Default Case...
                                else
                                {
                                    if ( SuffixPronInfo == g_SuffixInfoTable + ICISM_SUFFIX ||
                                         SuffixPronInfo == g_SuffixInfoTable + ICIZE_SUFFIX )
                                    {
                                        pBuffer[ wcslen( pBuffer ) - 1 ] = g_phonS[0];
                                    }

                                    // Make sure we don't write past the end of the buffer...
                                    if ( wcslen(pBuffer) + wcslen(pSuffixString) <= SP_MAX_PRON_LENGTH )
                                    {
                                        wcscat(pBuffer, pSuffixString);
                                    }
                                    else
                                    {
                                        hr = E_FAIL;
                                    }
                                }
                            }
                        }
                    }
                } // for (short i = 0; i < SuffixPronInfo->NumConversions; i++)
            } // for (DWORD j = 0; j < dwNumActivePos; j++)

            /********** Update ActivePos values **********/
            for (DWORD i = 0; i < dwNumNextActivePos; i++)
            {
                ActivePos[i] = NextActivePos[i];
            }
            dwNumActivePos = dwNumNextActivePos;

        } // while ( SUCCEEDED(hr) && ListPos && bPOSMatch )

        /********** Check to see if any derivations have succeeded **********/
        if ( SUCCEEDED(hr) && bPOSMatch )
        {
            for (DWORD i = 0; i < dwNumActivePos; i++)
            {
                if (!SearchPosSet(ActivePos[i], FinalPos, dwNumFinalPos))
                {
                    // We have succeeded in deriving a word - add it to the temporary word pron list...
                    FinalPos[dwNumFinalPos] = ActivePos[i];
                    dwNumFinalPos++;
                    if ( bDerivedAWord )
                    {
                        // This is not the first successful pronunciation match - need to advance the iterator...
                        pTempWordPronunciation->pNextWordPronunciation = CreateNextPronunciation (pTempWordPronunciation);
                        pTempWordPronunciation = pTempWordPronunciation->pNextWordPronunciation;
                    }
                    bDerivedAWord = true;
                    pTempWordPronunciation->eLexiconType = (SPLEXICONTYPE)(pWordPronIterator->eLexiconType | eLEXTYPE_PRIVATE3);
                    pTempWordPronunciation->ePartOfSpeech = (SPPARTOFSPEECH) ActivePos[i];
                    pTempWordPronunciation->LangID = pWordPronIterator->LangID;
                    wcscpy(pTempWordPronunciation->szPronunciation, pBuffer);
                    pTempWordPronunciation->pNextWordPronunciation = NULL;
                }
            }
        }

        // Advance SPWORDPRONUNCIATIONLIST iterator...
        if (SUCCEEDED(hr))
        {
            pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
        }

    } // while (SUCCEEDED(hr) && pWordPronIterator)


    /****************************************
     * Did we succeed in deriving anything? *
     ****************************************/

    /**********************************************************
     * If so, copy it into pWordPronunciationList and return. *
     **********************************************************/
    if ( SUCCEEDED(hr) && bDerivedAWord )
    {
        // Copy successful words into pWordPronunciationList for eventual return to DoSuffixMorph() caller...
        hr = ReallocSPWORDPRONList(pWordPronunciationList, pTempWordPronunciationList->ulSize);
        if (SUCCEEDED(hr))
        {
            pWordPronIterator = pTempWordPronunciationList->pFirstWordPronunciation;
            pTempWordPronunciation = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
            while (SUCCEEDED(hr) && pWordPronIterator)
            {
                pTempWordPronunciation->eLexiconType = (SPLEXICONTYPE)(pWordPronIterator->eLexiconType);
                pTempWordPronunciation->ePartOfSpeech = pWordPronIterator->ePartOfSpeech;
                pTempWordPronunciation->LangID = pWordPronIterator->LangID;
                wcscpy(pTempWordPronunciation->szPronunciation, pWordPronIterator->szPronunciation);
                pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
                if (pWordPronIterator)
                {
                    pTempWordPronunciation->pNextWordPronunciation = CreateNextPronunciation (pTempWordPronunciation);
                    pTempWordPronunciation = pTempWordPronunciation->pNextWordPronunciation;
                }
                else
                {
                    pTempWordPronunciation->pNextWordPronunciation = NULL;
                }
            }
        }
    }
    /***************************************
     * If not, just do default derivation. *
     ***************************************/
    else if ( SUCCEEDED(hr) )
    {
        hr = DefaultAccumulateSuffixes( pSuffixList, pWordPronunciationList );
    }
    ::CoTaskMemFree(pTempWordPronunciationList->pvBuffer);
    delete pTempWordPronunciationList;

    return hr;
} /* CSMorph::AccumulateSuffixes */


/*****************************************************************************
* CSMorph::AccumulateSuffixes_LTS *
*---------------------------------*
*	Description:    Append pronunciations of all the suffixes to the
*       retrieved pronunciation of the root word.
*		
********************************************************************** AH ***/
HRESULT CSMorph::AccumulateSuffixes_LTS( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList ) 
{
    HRESULT hr = S_OK;
    SPWORDPRONUNCIATION *pTempWordPronunciation = NULL, *pOriginalWordPronunciation = NULL;
    DWORD dwTotalSize = 0, dwNumPos = 0;
    SUFFIXPRON_INFO *SuffixPronInfo;
    ENGPARTOFSPEECH PartsOfSpeech[NUM_POS] = {MS_Unknown};
    WCHAR pBuffer[SP_MAX_PRON_LENGTH];
    SPLEXICONTYPE OriginalLexType;
    LANGID OriginalLangID;
    WORD OriginalReservedField;

    /*** Get the original pronunciation ***/
    pOriginalWordPronunciation = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
    OriginalLexType = pOriginalWordPronunciation->eLexiconType;
    OriginalLangID  = pOriginalWordPronunciation->LangID;
    OriginalReservedField = pOriginalWordPronunciation->wReserved;

    /*** Get First Suffix ***/
    SuffixPronInfo = pSuffixList->RemoveHead();

    /*** Copy the pronunciation of the root ***/
    wcscpy( pBuffer, pOriginalWordPronunciation->szPronunciation );

    /*** Append the pronunciation of the first suffix ***/
    if ( SuffixPronInfo->SuffixString[0] == g_phonS[0] && 
         SuffixPronInfo->SuffixString[1] == 0 )
    {
        hr = Phon_SorZ( pBuffer, wcslen(pBuffer) - 1 );
    }
    else if ( SuffixPronInfo->SuffixString[0] == g_phonD[0] &&
              SuffixPronInfo->SuffixString[1] == 0 )
    {
        hr = Phon_DorED( pBuffer, wcslen(pBuffer) - 1 );
    }
    else if ( wcslen(pBuffer) + wcslen(SuffixPronInfo->SuffixString) <= SP_MAX_PRON_LENGTH )
    {
        if ( SuffixPronInfo == g_SuffixInfoTable + ICISM_SUFFIX ||
             SuffixPronInfo == g_SuffixInfoTable + ICIZE_SUFFIX )
        {
            pBuffer[ wcslen( pBuffer ) - 1 ] = g_phonS[0];
        }

        wcscat( pBuffer, SuffixPronInfo->SuffixString );
    }
    else
    {
        wcsncat( pBuffer, SuffixPronInfo->SuffixString,
                 SP_MAX_PRON_LENGTH - ( wcslen(pBuffer) + wcslen(SuffixPronInfo->SuffixString ) ) );
    }

    if ( SUCCEEDED( hr ) )
    {
        /*** Allocate enough space for all of the pronunciations ***/
        dwTotalSize = sizeof(SPWORDPRONUNCIATIONLIST) + 
                      ( NUM_POS * ( sizeof(SPWORDPRONUNCIATION) + (SP_MAX_PRON_LENGTH * sizeof(WCHAR) ) ) );
        hr = ReallocSPWORDPRONList( pWordPronunciationList, dwTotalSize );
    }

    if ( SUCCEEDED( hr ) )
    {
        /*** Build list of parts of speech ***/
        for ( int i = 0; i < SuffixPronInfo->NumConversions; i++ )
        {
            if ( !SearchPosSet( SuffixPronInfo->Conversions[i].ToPos, PartsOfSpeech, dwNumPos ) )
            {
                PartsOfSpeech[dwNumPos] = SuffixPronInfo->Conversions[i].ToPos;
                dwNumPos++;
            }
        }

        pTempWordPronunciation = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;

        /*** Build TempWordPronunciationList to send to AccumulateSuffixes ***/
        for ( i = 0; i < (int) dwNumPos; i++ )
        {
            if ( i > 0 )
            {
                pTempWordPronunciation->pNextWordPronunciation = CreateNextPronunciation (pTempWordPronunciation);
                pTempWordPronunciation = pTempWordPronunciation->pNextWordPronunciation;
            }
            pTempWordPronunciation->eLexiconType           = (SPLEXICONTYPE)(OriginalLexType | eLEXTYPE_PRIVATE3);
            pTempWordPronunciation->LangID                 = OriginalLangID;
            pTempWordPronunciation->wReserved              = OriginalReservedField;
            pTempWordPronunciation->ePartOfSpeech          = (SPPARTOFSPEECH)PartsOfSpeech[i];
            pTempWordPronunciation->pNextWordPronunciation = NULL;
            wcscpy(pTempWordPronunciation->szPronunciation, pBuffer);
        }
    }

    if ( SUCCEEDED( hr ) &&
         !pSuffixList->IsEmpty() )
    {
        /*** Pass accumulated list to AccumulateSuffixes ***/
        hr = AccumulateSuffixes( pSuffixList, pWordPronunciationList );
    }

    return hr;
} /* CSMorph::AccumulateSuffixes_LTS */

/*****************************************************************************
* CSMorph::DefaultAccumulateSuffixes *
*------------------------------------*
*	Description:    Append pronunciations of all the suffixes to the
*       retrieved pronunciation of the root word.
*   
*   Just accumulate all the pronunciations, and use all of
*   the "To" parts of speech of the last suffix.  Ex:
*
*       cat (Noun) + ing (Verb -> Verb, Verb -> Adj, Verb -> Noun) -> catting (Verb, Adj, Noun)
*		
********************************************************************** AH ***/
HRESULT CSMorph::DefaultAccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    HRESULT hr = S_OK;
    ENGPARTOFSPEECH PartsOfSpeech[NUM_POS] = { MS_Unknown };
    SPWORDPRONUNCIATION *pWordPronIterator = NULL;
    WCHAR pBuffer[SP_MAX_PRON_LENGTH];
    SUFFIXPRON_INFO *SuffixPronInfo = NULL;
    SPLISTPOS ListPos;
    DWORD dwTotalSize = 0;
    int NumPOS = 0;
    SPLEXICONTYPE OriginalLexType;
    LANGID OriginalLangID;
    WORD OriginalReservedField;

    /*** Initialize pBuffer and OriginalXXX variables ***/
    ZeroMemory( pBuffer, sizeof( pBuffer ) );
    OriginalLexType = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->eLexiconType;
    OriginalLangID  = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->LangID;
    OriginalReservedField = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->wReserved;

    /****************************************************************
     *** Get Desired Pronunciation of result, and Parts of Speech ***
     ****************************************************************/

    //--- Get pronunciation of root word
    wcscpy( pBuffer, ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->szPronunciation );

    //--- Loop through suffix list, appending pronunciations of suffixes to that of the root.
    ListPos = pSuffixList->GetHeadPosition();

    //--- List should never be empty at this point
    SPDBG_ASSERT( ListPos );
    while ( ListPos )
    {
        SuffixPronInfo = pSuffixList->GetNext( ListPos );
        if ( wcslen(pBuffer) + wcslen(SuffixPronInfo->SuffixString) < SP_MAX_PRON_LENGTH )
        {
            wcscat( pBuffer, SuffixPronInfo->SuffixString );
        }
    }
    
    //--- Get the "to" parts of speech of the last suffix
    for ( int i = 0; i < SuffixPronInfo->NumConversions; i++ )
    {
        PartsOfSpeech[i] = SuffixPronInfo->Conversions[i].ToPos;
    }
    NumPOS = i;

    /***********************************************************************************
     * Now put derived words into pWordPronunciationList for return from DoSuffixMorph *
     ***********************************************************************************/

    //--- First make sure there is enough room
    dwTotalSize = ( sizeof(SPWORDPRONUNCIATIONLIST) ) +
                  ( NumPOS * ( (wcslen(pBuffer) * sizeof(WCHAR)) + sizeof(SPWORDPRONUNCIATION) ) );                      
    hr = ReallocSPWORDPRONList( pWordPronunciationList, dwTotalSize );

    if ( SUCCEEDED( hr ) )
    {
        //--- Now add pronunciation once for each part of speech
        pWordPronIterator = pWordPronunciationList->pFirstWordPronunciation;
        for ( i = 0; i < NumPOS; i++ )
        {
            pWordPronIterator->eLexiconType  = (SPLEXICONTYPE) ( OriginalLexType |  eLEXTYPE_PRIVATE3 );
            pWordPronIterator->LangID        = OriginalLangID;
            pWordPronIterator->wReserved     = OriginalReservedField;
            pWordPronIterator->ePartOfSpeech = (SPPARTOFSPEECH)PartsOfSpeech[i];
            wcscpy( pWordPronIterator->szPronunciation, pBuffer );
            if ( i < NumPOS - 1 )
            {
                pWordPronIterator->pNextWordPronunciation = 
                    (SPWORDPRONUNCIATION*)(((BYTE*)pWordPronIterator) + sizeof(SPWORDPRONUNCIATION) + 
                                           (wcslen(pWordPronIterator->szPronunciation) * sizeof(WCHAR)));
                pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
            }
            else
            {
                pWordPronIterator->pNextWordPronunciation = NULL;
            }
        }
    }

    return hr;
}

/*****************************************************************************
* CSMorph::CheckForMissingE *
*---------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'e' 
*       e.g. make -> making
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckForMissingE( WCHAR *pOrth, long length, DWORD dwFlags, 
                                 SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    WCHAR   charSave;
    
    charSave = pOrth[length];			// save orig before we...
    pOrth[length] = L'E'; 				// ...end root with E
    hr = LexLookup( pOrth, length+1, dwFlags, pWordPronunciationList );
    if ( FAILED(hr) )
    {
        pOrth[length] = charSave;		// restore original char   
    }
    else if ( length > 0 &&
              pOrth[length - 1] == L'L' )
    {
        //--- Check for juggle -> juggler schwa deletion
        SPWORDPRONUNCIATION *pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
        while ( pWordPronIterator )
        {
            if ( wcslen( pWordPronIterator->szPronunciation ) >= 2 )
            {
                WCHAR *pLastTwoPhonemes = pWordPronIterator->szPronunciation + 
                    ( wcslen( pWordPronIterator->szPronunciation ) - 2 );
                if ( wcscmp( pLastTwoPhonemes, g_phonAXl ) == 0 )
                {
                    //--- Orthography ends in -le and pronunciation ends in -AXl, delete AX...
                    pLastTwoPhonemes[0] = pLastTwoPhonemes[1];
                    pLastTwoPhonemes[1] = 0;
                }
                pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
            }
        }
    }
    return hr;
} /* CSMorph::CheckForMissingE */

/*****************************************************************************
* CSMorph::CheckForMissingY *
*---------------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'y' 
*       e.g. happy -> happily
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckForMissingY( WCHAR *pOrth, long length, DWORD dwFlags, 
                                   SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    WCHAR   charSave;
    
    charSave = pOrth[length];			// save orig before we...
    pOrth[length] = L'Y'; 				// ...end root with E
    hr = LexLookup( pOrth, length+1, dwFlags, pWordPronunciationList );
    if ( FAILED(hr) )
    {
        pOrth[length] = charSave;		// restore original char   
    }
    else 
    {
        //--- Delete IY at end of pronunciations ( e.g. happy + ily -> [ H AE 1 P (IY) ] + [ AX L IY ] )
        for ( SPWORDPRONUNCIATION *pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation; 
              pWordPronIterator; pWordPronIterator = pWordPronIterator->pNextWordPronunciation )
        {
            if ( pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] == g_phonIY[0] )
            {
                pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] = 0;
            }
        }
    }
    return hr;
} /* CSMorph::CheckForMissingY */

/*****************************************************************************
* CSMorph::CheckForMissingL *
*---------------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'l' 
*       e.g. chill -> chilly
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckForMissingL( WCHAR *pOrth, long length, DWORD dwFlags, 
                                   SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    WCHAR   charSave;
    
    charSave = pOrth[length];			// save orig before we...
    pOrth[length] = L'L'; 				// ...end root with E
    hr = LexLookup( pOrth, length+1, dwFlags, pWordPronunciationList );
    if ( FAILED(hr) )
    {
        pOrth[length] = charSave;		// restore original char   
    }
    else 
    {
        //--- Delete l at end of pronunciations ( e.g. chill +ly -> [ ch ih 1 (l) ] + [ l iy ] )
        for ( SPWORDPRONUNCIATION *pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation; 
              pWordPronIterator; pWordPronIterator = pWordPronIterator->pNextWordPronunciation )
        {
            if ( pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] == g_phonL[0] )
            {
                pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] = 0;
            }
        }
    }
    return hr;
} /* CSMorph::CheckForMissingL */

/*****************************************************************************
* CSMorph::CheckYtoIMutation *
*---------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'y' to
*       an 'i'
*       e.g. steady + est -> steadiest
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckYtoIMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                    SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    
    if ( pOrth[length - 1] == L'I' )
    {
        pOrth[length - 1] = L'Y'; 				// end root with Y
        hr = LexLookup( pOrth, length, dwFlags, pWordPronunciationList );
        if ( FAILED(hr) )
        {
            pOrth[length - 1] = L'I';		    // restore I 
        }
    } 
    else 
    {
        hr = SPERR_NOT_IN_LEX;
    }
    return hr;
} /* CSMorph::CheckYtoIMutation */


/*****************************************************************************
* CSMorph::CheckDoubledMutation *
*----------------------*
*	Description:    Check Lexicon to see if the root word has a doubled 
*       consonant.
*       e.g. run + ing -> running
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckDoubledMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                       SPWORDPRONUNCIATIONLIST *pWordPronunciationList)
{
    HRESULT hr = S_OK;

    switch ( pOrth[length - 1] )
    {
        // Filter the vowels, which never double...
    case L'A':
    case L'E':
    case L'I':
    case L'O':
    case L'U':
    case L'Y':
        // Filter consonants which never double, or are doubled in roots...
    case L'F':
    case L'H':
    case L'K':
    case L'S':
    case L'W':
    case L'Z':
        hr = SPERR_NOT_IN_LEX;
        break;

    default:
		if(pOrth[length-1] == pOrth[length-2]) {
	        hr = LexLookup( pOrth, length - 1, dwFlags, pWordPronunciationList );
		    break;
		}
		else {
			hr = SPERR_NOT_IN_LEX;
			break;
		}
    }
    return hr;
} /* CSMorph::CheckDoubledMutation */

/*****************************************************************************
* CSMorph::CheckYtoIEMutation *
*---------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'y' to
*       an 'ie'
*       e.g. company + s -> companies
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckYtoIEMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                    SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    
    if ( pOrth[length - 1] == L'E' && pOrth[length-2] == L'I' )
    {
        pOrth[length - 2] = L'Y'; 				// end root with Y
        hr = LexLookup( pOrth, length - 1, dwFlags, pWordPronunciationList );
        if ( FAILED(hr) )
        {
            pOrth[length - 2] = L'I';		    // restore I 
        }
    } 
    else 
    {
        hr = SPERR_NOT_IN_LEX;
    }
    return hr;
} /* CSMorph::CheckYtoIMutation */

/*****************************************************************************
* CSMorph::CheckAbleMutation *
*----------------------------*
*	Description:    Check Lexicon for special -able -> -ably cases (e.g.
*       probable -> probably )
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckAbleMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                    SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    
    //--- Look up word ending in -able
    pOrth[length+3] = L'E';
    hr = LexLookup( pOrth, length + 4, dwFlags, pWordPronunciationList );
    if ( FAILED( hr ) )
    {
        //--- restore "y"
        pOrth[length+3] = L'Y';
    }
    return hr;
} /* CSMorph::CheckAbleMutation */

/*****************************************************************************
* CSMorph::Phon_SorZ *
*--------------------*
*	Description:    Figure out what phoneme the S suffix should be - s, z, or 
*                   IXz
*		
********************************************************************** AH ***/
HRESULT CSMorph::Phon_SorZ( WCHAR *pPronunciation, long length )
{
    HRESULT hr = S_OK;

    if ( SUCCEEDED(hr) && pPronunciation[length] < sp_countof(g_PhonTable) ) 
    {
        if ( ((PHONTYPE)g_PhonTable[pPronunciation[length]] & ePALATALF) || 
             (pPronunciation[length] == g_phonS[0])           || 
             (pPronunciation[length] == g_phonZ[0]) )
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonAXz) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonAXz);
            }
        } 
        else if( ((PHONTYPE)g_PhonTable[pPronunciation[length]] & eCONSONANTF) && 
                 !((PHONTYPE)g_PhonTable[pPronunciation[length]] & eVOICEDF) )
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonZ) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonS);
            }
        }
        else
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonS) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonZ);
            }
        }
    }
    else 
    {
        hr = E_FAIL;
    }

    return hr;
} /* CSMorph::Phon_SorZ */

/*****************************************************************************
* CSMorph::Phon_DorED *
*---------------------*
*	Description:    Figure out what phoneme the D suffix should be - d, t,
*                   or AXd
*		
********************************************************************** AH ***/
HRESULT CSMorph::Phon_DorED( WCHAR *pPronunciation, long length )
{
    HRESULT hr = S_OK;

    if ( SUCCEEDED(hr) && pPronunciation[length] < sp_countof(g_PhonTable) ) 
    {
        if ( (pPronunciation[length] == g_phonT[0]) || (pPronunciation[length] == g_phonD[0]) )
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonAXd) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonAXd);
            }
        } 
        else if ((PHONTYPE)g_PhonTable[pPronunciation[length]] & eVOICEDF)
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonD) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonD);
            }
        }
        else 
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonT) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonT);
            }
        }
    }
    else 
    {
        hr = E_FAIL;
    }

    return hr;
} /* CSMorph::Phon_DorED */

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\miscdata.cpp ===
/******************************************************************************
* MiscData.cpp *
*--------------*
*  This file stores the const data used in various non-normalization front-end
*  code
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 05/02/2000
*  All Rights Reserved
*
****************************************************************** AARONHAL ***/

#include "stdafx.h"
#include"stdsentenum.h"

//--- Variable used to make sure initialization of pronunciations only happens once!
BOOL g_fAbbrevTablesInitialized = false;

//--- Helper function used to delete dynamically allocated memory (for the abbreviation
//    table) at DLL exit time...
void CleanupAbbrevTables( void ) 
{
    if ( g_fAbbrevTablesInitialized )
    {
        for ( ULONG i = 0; i < sp_countof( g_AbbreviationTable ); i++ )
        {
            if ( g_AbbreviationTable[i].pPron1 )
            {
                delete [] g_AbbreviationTable[i].pPron1;
            }
            if ( g_AbbreviationTable[i].pPron2 )
            {
                delete [] g_AbbreviationTable[i].pPron2;
            }
            if ( g_AbbreviationTable[i].pPron3 )
            {
                delete [] g_AbbreviationTable[i].pPron3;
            }
        }
        for ( i = 0; i < sp_countof( g_AmbiguousWordTable ); i++ )
        {
            if ( g_AmbiguousWordTable[i].pPron1 )
            {
                delete [] g_AmbiguousWordTable[i].pPron1;
            }
            if ( g_AmbiguousWordTable[i].pPron2 )
            {
                delete [] g_AmbiguousWordTable[i].pPron2;
            }
            if ( g_AmbiguousWordTable[i].pPron3 )
            {
                delete [] g_AmbiguousWordTable[i].pPron3;
            }
        }
        for ( i = 0; i < sp_countof( g_PostLexLookupWordTable ); i++ )
        {
            if ( g_PostLexLookupWordTable[i].pPron1 )
            {
                delete [] g_PostLexLookupWordTable[i].pPron1;
            }
            if ( g_PostLexLookupWordTable[i].pPron2 )
            {
                delete [] g_PostLexLookupWordTable[i].pPron2;
            }
            if ( g_PostLexLookupWordTable[i].pPron3 )
            {
                delete [] g_PostLexLookupWordTable[i].pPron3;
            }
        }
        if ( g_pOfA )
        {
            delete [] g_pOfA;
        }
        if ( g_pOfAn )
        {
            delete [] g_pOfAn;
        }
    }
}

const BrillPatch g_POSTaggerPatches [] =
{
    { MS_Adj, MS_Noun, CAP, MS_Unknown, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1T, MS_Adj, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, CAP, MS_Unknown, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Conj, MS_Adv, NEXT2T, MS_Conj, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, NEXT1T, MS_Verb, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1TNEXT1T, MS_Noun, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV2T, MS_Prep, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_SubjPron, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Pron, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Adv, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, NEXT1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1TNEXT1T, MS_Verb, MS_Adj, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1TNEXT1T, MS_Noun, MS_Verb, NULL, NULL },
    { MS_Noun, MS_Adj, NEXT1T, MS_Adj, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, NEXT1T, MS_CConj, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Adv, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Adj, NULL, NULL },
    { MS_Adv, MS_Prep, PREV1TNEXT1T, MS_Noun, MS_Prep, NULL, NULL },
    { MS_Adv, MS_Prep, PREV1TNEXT2T, MS_Verb, MS_Noun, NULL, NULL },
    { MS_Adj, MS_Adv, NEXT1T, MS_Adv, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, NEXT1T, MS_ObjPron, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Adj, PREV1TNEXT1T, MS_Prep, MS_Noun, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Interr, MS_Prep, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1TNEXT1T, MS_Adv, MS_Adj, NULL, NULL },
    { MS_Prep, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Conj, NEXT1T, MS_SubjPron, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Adj, MS_Prep, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT2T, MS_Interr, MS_Noun, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1TNEXT1T, MS_Unknown, MS_Verb, NULL, NULL },
    { MS_Adj, MS_Verb, PREV1TNEXT1T, MS_Verb, MS_Adj, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1TNEXT1T, MS_Unknown, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Prep, PREV1TNEXT2T, MS_Prep, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, PREV2TNEXT1T, MS_Verb, MS_Adj, NULL, NULL },
    { MS_Adv, MS_Prep, NEXT1T, MS_Noun, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1TNEXT1T, MS_Conj, MS_Verb, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Prep, MS_Prep, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Pron, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Noun, MS_Verb, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Noun, NEXT1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, NEXT1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Unknown, MS_Prep, NULL, NULL },
    { MS_Verb, MS_Noun, PREV2TNEXT1T, MS_Unknown, MS_Verb, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_SubjPron, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Adv, NULL, NULL },
    { MS_Adv, MS_Adj, PREV1TNEXT1T, MS_Conj, MS_Noun, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1TNEXT1T, MS_Prep, MS_Adj, NULL, NULL },
    { MS_Adv, MS_Prep, NEXT1T, MS_Verb, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Adj, NEXT1T, MS_Adj, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Conj, NEXT1T, MS_Pron, MS_Unknown, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Adv, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV2TNEXT1T, MS_CConj, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Pron, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Adj, PREV2TNEXT1T, MS_Prep, MS_Noun, NULL, NULL },
    { MS_Noun, MS_Adj, PREV1TNEXT1T, MS_Adv, MS_Noun, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1TNEXT1T, MS_Adv, MS_Adj, NULL, NULL },
    //--- Inserted by hand - convert "A" from Det to Noun after Det...
    { MS_Det, MS_Noun, CURRWPREV1T, MS_Det, MS_Unknown, L"a", NULL },
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
AbbrevRecord g_AbbreviationTable[] =
{
    { L"a",     L"EY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"amp",   L"AE 1 M P", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"app",   L"AE 1 P", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"apr",   L"EY 1 - P R AX L", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"apt",   L"ax - p aa 1 r t - m ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"assoc", L"ax - s ow 2 - s iy - ey 1 - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"asst",  L"ax - s ih 1 s - t ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"aug",   L"ao 1 - g ax s t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ave",   L"ae 1 v - ax - n uw 2", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"b",     L"B IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"bldg",  L"b ih 1 l - d ih ng", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"blvd",  L"b uh 1 l - ax - v aa 2 r d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"bu",    L"b uh 1 sh - ax l", MS_Noun, L"b uh 1 sh - ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Initial - never EOS
    { L"c",     L"s eh 1 l - s iy - ax s", MS_Noun, L"s iy 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"cal",   L"k ae 1 l - ax - r iy", MS_Noun, L"k ae 1 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    { L"cals",  L"k ae 1 l - ax - r iy Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ch",    L"ch ae 1 p - t er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"cl",    L"s eh 1 n - t ax - l iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"cm",    L"s eh 1 n - t ax - m iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"cms",   L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"cntr",  L"s eh 1 n - t er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"co",    L"k ah 1 m - p ax - n iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"cont",  L"k ax n - t ih 1 n - y uw D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"corp",  L"k ao 2 r - p ax - r ey 1 - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"ct",    L"k ao 1 r t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"ctr",   L"s eh 1 n - t er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
	//--- IfEOSNotAbbreviation
    { L"cu",    L"k y uw 1 - b ih k", MS_Noun, L"k y uw 1 - b ih k", MS_Noun, NULL, MS_Unknown, 1, 4 },
    //--- Initial - never EOS
    { L"d",     L"D IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"db",    L"d eh 1 s - ax - b ax l", MS_Noun, L"d eh 1 s - ax - b ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"dec",   L"d ih - s eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"deg",   L"d ih - g r iy 1", MS_Noun, L"d ih - g r iy 1 z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"dept",  L"d ih - p aa 1 r t - m ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"dist",  L"d ih 1 s - t r ax k t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"doc",   L"D AA 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"doz",   L"d ah 1 z - ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- DoctorDriveAbbreviation
    { L"dr",    L"d aa 1 k - t er", MS_Noun, L"D R AY 1 V", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- Initial - never EOS
    { L"e",     L"IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"ed",    L"eh 2 jh - ax - k ey 1 - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"esq",   L"eh 1 s - k w ay 2 r", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"est",   L"ax - s t ae 1 b - l ax sh T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"etc",   L"EH T & s eh 1 t - er - ax", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"ex",    L"ih g - z ae 1 m - p ax l", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"ext",   L"ih k - s t eh 1 n - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"f",     L"f ae 1 r - ax n - h ay 2 t", MS_Noun, L"eh 1 f", MS_Noun, NULL, MS_Unknown, 0, 3 },
    { L"feb",   L"f eh 1 b - r uw - eh 2 r - iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"fig",   L"f ih 1 g - y er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- IfEOSNotAbbreviation
    { L"figs",  L"f ih 1 g - y er Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- IfEOSNotAbbreviation
    { L"fl",    L"f l uw 1 - ih d", MS_Noun, L"f l uw 1 - ih d", MS_Noun, NULL, MS_Unknown, 1, 4 },
    { L"fn",    L"f uh 1 t - n ow 2 t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"freq",  L"f r iy 1 - k w ax n - s iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"fri",   L"f r ay 1 - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"ft",    L"F UH 1 T", MS_Noun, L"F IY 1 T", MS_Noun, L"F AO 1 R T", MS_Noun, 0, 0 },
    { L"fwd",   L"f ao 1 r - w er d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"g",     L"G R AE 1 M", MS_Noun, L"G R AE 1 M Z", MS_Noun, L"JH IY 1", MS_Noun, 1, 0 },
    //--- SingleOrPluralAbbreviation
    { L"gal",   L"g ae 1 l - ax n", MS_Noun, L"g ae 1 l - ax n Z", MS_Noun, L"G AE 1 L", MS_Noun, 0, 0 },
    //--- TITLE - never EOS
    { L"gen",   L"jh eh 1 n - er - ax l", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"gov",   L"g ah 1 v - er - n ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- Initial - never EOS
    { L"h",     L"EY 1 CH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"hr",    L"AW 1 ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"hrs",   L"AW 1 ER Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ht",    L"H AY 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"hwy",   L"h ay 1 w ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"hz",    L"H ER 1 T S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"i",     L"AY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"in",    L"IH 1 N CH", MS_Noun, L"IH 1 N CH AX Z", MS_Noun, L"IH 1 N", MS_Prep, 1, 0 },
    { L"inc",   L"ih n - k ao 1 r - p ax - r ey 2 - t AX D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"incl",  L"ih n - k l uw 1 - d AX D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"intl",  L"ih 2 n - t er - n ae 1 sh - ax - n ax l", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSAndLowercaseNotAbbreviation
    { L"is",    L"ay 1 - l ax n d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 2, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"j",     L"JH UW 1 L", MS_Noun, L"JH UW 1 L Z", MS_Noun, L"JH EY 1", MS_Noun, 1, 0 },
    //--- IfEOSNotAbbreviation
    { L"jan",   L"jh ae 1 n - y uw - eh 2 r - iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"jr",    L"jh uw 1 n - y er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"jul",   L"jh uh - l ay 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"jun",   L"JH UW 1 N", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"k",     L"k eh 1 l - v ax n", MS_Noun, L"k ey 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"kb",    L"k ih 1 l - ax - b ay 2 t", MS_Noun, L"k ih 1 l - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kcal",  L"k ih 1 l - ax - k ae 2 l - ax - r iy", MS_Noun, L"k ih 1 l - ax - k ae 2 l - ax - r iy Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kg",    L"k ih 1 l - ax - g r ae 2 m", MS_Noun, L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"kgs",   L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"khz",   L"k ih 1 l - ax - h er 2 t s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"kj",    L"k ih 1 l - ax - jh uw 2 l", MS_Noun, L"k ih 1 l - ax - jh uw 2 l z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"km",    L"k ih - l aa 1 m - ih - t er", MS_Noun, L"k ih - l aa 1 m - ih - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kw",    L"k ih 1 l - ax - w aa 2 t", MS_Noun, L"k ih 1 l - ax - w aa 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"l",     L"l iy 1 - t er", MS_Noun, L"l iy 1 - t er Z", MS_Noun, L"EH 1 L", MS_Noun, 1, 0 },
    //--- SingleOrPluralAbbreviation
    { L"lb",    L"P AW 1 N D", MS_Noun, L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"lbs",   L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"lg",    L"L AA 1 R JH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ln",    L"l ey 1 n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Title - never EOS
    { L"lt",    L"l uw - t eh 1 n - ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"ltd",   L"l ih 1 m - ih - t AX D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"m",     L"M IY 1 T ER", MS_Noun, L"M IY 1 T ER Z", MS_Noun, L"EH 1 M", MS_Noun, 1, 0 },
    //--- IfEOSNotAbbreviation???
    { L"mar",   L"M AA 1 R CH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"mb",    L"m eh 1 g - ax - b ay 2 t", MS_Noun, L"m eh 1 g - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mfg",   L"m ae 2 n - y ax - f ae 1 k - ch er - IH NG", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"mg",    L"m ih 1 l - ax - g r ae 2 m", MS_Noun, L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mgr",   L"m ae 1 n - ih - jh ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mgs",   L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mhz",   L"m eh 1 g - ax - h er 2 t s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"mi",    L"M AY 1 L", MS_Noun, L"M AY 1 L Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mic",   L"M AY 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"min",   L"m ih 1 n - ax t", MS_Noun, L"m ih 1 n - ax t S", MS_Noun, L"m ih 1 n - ax - m ax m", MS_Noun, 0, 0 },
    { L"misc",  L"m ih 2 s - ax - l ey 1 - n iy - ax s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"ml",    L"m ih 1 l - ax - l iy 2 - t er", MS_Noun, L"m ih 1 l - ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mm",    L"m ih 1 l - ax - m iy 2 - t er", MS_Noun, L"m ih 1 l - ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mon",   L"m ah 1 n - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- TITLE - never EOS
    { L"mr",    L"M IH 1 S - T ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- TITLE - never EOS
    { L"mrs",   L"M IH 1 S - AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"ms",    L"M IH 1 Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"msec",  L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"msecs", L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mt",    L"M AW 1 N T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mtn",   L"m aw 1 n - t ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"n",     L"EH 1 N", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"no",    L"N UH 1 M - B ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"nov",   L"n ow - v eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"o",     L"OW 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"oct",   L"aa k - t ow 1 - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"op",    L"OW 1 - P AX S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"oz",    L"AW 1 N S", MS_Noun, L"AW 1 N - S AX Z", MS_Noun, L"AA 1 Z", MS_Noun, 0, 0 },
    { L"ozs",   L"AW 1 N - S AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- AbbreviationFollowedByDigit
    { L"p",     L"P EY 1 JH", MS_Noun, L"P IY 1", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- IfEOSNotAbbreviation
    { L"pg",    L"P EY 1 JH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"pgs",   L"P EY 1 - JH AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pkg",   L"p ae 1 k - ih jh", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pkwy",  L"p aa 1 r k - w ey 2", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pl",    L"P L EY 1 S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pp",    L"P EY 1 - JH AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- TITLE - never EOS
    { L"pres",  L"p r eh 1 z - ax - d ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- TITLE - never EOS
    { L"prof",  L"p r ax - f eh 1 - s ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"pt",    L"P OY 1 N T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"q",     L"K Y UW 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"qt",    L"k w ao 1 r t", MS_Noun, L"k w ao 1 r t Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Initial - never EOS
    { L"r",     L"AA 1 R", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"rd",    L"r ow 1 d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rec",   L"R EH 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rep",   L"r eh 2 p - r ih - z eh 1 n - t ax - t ih v", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rt",    L"R UW 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rte",    L"R UW 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"s",     L"EH 1 S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSAndLowercaseNotAbbreviation
    { L"sat",   L"s ae 1 t - er - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 2, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"sec",   L"s eh 1 k - ax n d", MS_Noun, L"s eh 1 k - ax n d z", MS_Noun, NULL, MS_Unknown, 1, 0 },
    //--- TITLE - never EOS
    { L"sen",   L"s eh 1 n - ax - t ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"sep",   L"s eh p - t eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"sept",  L"s eh p - t eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"sm",    L"S M AO 1 L", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 }, 
    { L"sq",    L"S K W EH 1 R", MS_Noun, L"S K W EH 1 R", MS_Noun, NULL, MS_Unknown, 0, 4 },
    //--- IfEOSNotAbbreviation
    { L"sr",    L"s iy 1 n - y er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- DoctorDriveAbbreviation
    { L"st",    L"S EY 1 N T", MS_Noun, L"S T R IY 1 T", MS_Noun, NULL, MS_Unknown, 0, 1 },
    { L"ste",   L"s w iy 1 t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"sun",   L"s ah 1 n - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- Initial - never EOS
    { L"t",     L"T IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"tbsp",  L"t ey 1 - b ax l - s p uw 2 n", MS_Noun, L"t ey 1 - b ax l - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"tech",  L"T EH 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"thu",   L"th er 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"thur",  L"th er 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"thurs", L"th er 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"tsp",   L"t iy 1 - s p uw 2 n", MS_Noun, L"t iy 1 - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"tue",   L"t uw 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"tues",  L"t uw 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"u",     L"Y UW 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"univ",  L"y uw 2 - n ax - v er 1 - s ih - t iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"v",     L"V IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"ver",   L"v er 1 - zh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"vers",  L"v er 1 - zh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"vol",   L"v aa 1 l - y uw m", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"vs",    L"v er 1 - s ax s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"w",     L"d ah 1 b - ax l - y uw", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSAndLowercaseNotAbbreviation
    { L"wed",   L"w eh 1 n z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 2, -1 },
    { L"wk",    L"W IY 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"wt",    L"W EY 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"wy",    L"W EY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"x",     L"EH 1 K S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- Initial - never EOS
    { L"y",     L"W AY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"yd",    L"Y AA 1 R D", MS_Noun, L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"yds",   L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"yr",    L"Y IY 1 R", MS_Noun, L"Y IY 1 R Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Initial - never EOS
    { L"z",     L"Z IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
AbbrevRecord g_AmbiguousWordTable[] =
{
    //--- ADisambig
    { L"a",     L"EY 1", MS_Noun, L"AX", MS_Det, NULL, MS_Unknown, 0, 8 },
    //--- AllCapsAbbreviation
    { L"al",    L"EY 1 & EH 1 L", MS_Noun, L"AE 1 L", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"apr",   L"ey 1 & p iy 1 & aa 1 r", MS_Noun, L"ey 1 - p r ax l", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"as",    L"EY 1 & EH 1 S", MS_Noun, L"AE 1 Z", MS_Conj, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"bu",    L"b uh 1 sh - ax l", MS_Noun, L"b uh 1 sh - ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- DegreeAbbreviation
    { L"c",     L"s eh 1 l - s iy - ax s", MS_Noun, L"s iy 1", MS_Noun, NULL, MS_Unknown, 0, 6 },
    //--- SingleOrPluralAbbreviation
    { L"cal",   L"k ae 1 l - ax - r iy", MS_Noun, L"k ae 1 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"cl",    L"s eh 1 n - t ax - l iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"cm",    L"s eh 1 n - t ax - m iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"co",    L"S IY 1 & OW 1", MS_Noun, L"k ah 1 m - p ax - n iy", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"ct",    L"s iy 1 & t iy 1", MS_Noun, L"k ao 1 r t", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- MeasurementModifier
    { L"cu",    L"S IY 1 & Y UW 1", MS_Noun, L"k y uw 1 - b ih k", MS_Noun, NULL, MS_Unknown, 0, 7 },
    //--- SingleOrPluralAbbreviation
    { L"db",    L"d eh 1 s - ax - b ax l", MS_Noun, L"d eh 1 s - ax - b ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"deg",   L"d ih - g r iy 1", MS_Noun, L"d ih - g r iy 1 z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- DoctorDriveAbbreviation
    { L"dr",    L"d aa 1 k - t er", MS_Noun, L"D R AY 1 V", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- DegreeAbbreviation
    { L"f",     L"f ae 1 r - ax n - h ay 2 t", MS_Noun, L"eh 1 f", MS_Noun, NULL, MS_Unknown, 0, 6 },
    //--- AbbreviationFollowedByDigit
    { L"fig",   L"f ih 1 g - y er", MS_Noun, L"F IH 1 G", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- AbbreviationFollowedByDigit
    { L"figs",  L"f ih 1 g - y er Z", MS_Noun, L"F IH 1 G Z", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementModifier
    { L"fl",    L"eh 1 f & eh 1 l", MS_Noun, L"f l uw 1 - ih d", MS_Noun, NULL, MS_Unknown, 0, 7 },
    //--- SingleOrPluralAbbreviation
    { L"ft",    L"F UH 1 T", MS_Noun, L"F IY 1 T", MS_Noun, L"F AO 1 R T", MS_Noun, 0, 0 },
    //--- G, Gram, Grams
    { L"g",     L"G R AE 1 M", MS_Noun, L"G R AE 1 M Z", MS_Noun, L"JH IY 1", MS_Noun, 0, 5 },
    //--- DoctorDriveAbbreviation
    { L"gov",   L"g ah 1 v - er - n ER", MS_Noun, L"G AH 1 V", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- AllCapsAbbreviation
    { L"hi",    L"EY 1 CH & AY 1", MS_Noun, L"H AY 1", MS_Interjection, NULL, MS_Unknown, 0, 3 },
    //--- HR hour hours
    { L"hr",    L"AW 1 ER", MS_Noun, L"AW 1 ER Z", MS_Noun, L"EY 1 CH AA 1 R", MS_Noun, 0, 5 },
    //--- J, Joule, Joules
    { L"j",     L"JH UW 1 L", MS_Noun, L"JH UW 1 L Z", MS_Noun, L"JH EY 1", MS_Noun, 0, 5 },
    //--- DegreeAbbreviation
    { L"k",     L"k eh 1 l - v ax n", MS_Noun, L"k ey 1", MS_Noun, NULL, MS_Unknown, 0, 6 },
    //--- SingleOrPluralAbbreviation
    { L"kb",    L"k ih 1 l - ax - b ay 2 t", MS_Noun, L"k ih 1 l - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kcal",  L"k ih 1 l - ax - k ae 2 l - ax - r iy", MS_Noun, L"k ih 1 l - ax - k ae 2 l - ax - r iy Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kg",    L"k ih 1 l - ax - g r ae 2 m", MS_Noun, L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kj",    L"k ih 1 l - ax - jh uw 2 l", MS_Noun, L"k ih 1 l - ax - jh uw 2 l z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"km",    L"k ih - l aa 1 m - ih - t er", MS_Noun, L"k ih - l aa 1 m - ih - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kw",    L"k ih 1 l - ax - w aa 2 t", MS_Noun, L"k ih 1 l - ax - w aa 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- L, Liter, Liters
    { L"l",     L"l iy 1 - t er", MS_Noun, L"l iy 1 - t er Z", MS_Noun, L"EH 1 L", MS_Noun, 0, 5 },
    //--- AllCapsAbbreviation
    { L"la",    L"EH 1 L & EY 1", MS_Noun, L"L AH 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"lb",    L"P AW 1 N D", MS_Noun, L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"lts",   L"eh 1 l & t iy 1 & eh 1 s", MS_Noun, L"l uw t eh 1 n ax n t s", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- M, Meter, Meters
    { L"m",     L"M IY 1 - T ER", MS_Noun, L"M IY 1 - T ER Z", MS_Noun, L"EH 1 M", MS_Noun, 0, 5 },
    //--- AllCapsAbbreviation
    { L"ma",    L"EH 1 M & AA 1", MS_Noun, L"M AA 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- March Mar
    { L"mar",   L"M AA 1 R CH", MS_Noun, L"M AA 1 R", MS_Verb, NULL, MS_Unknown, 0, 4 },
    //--- SingleOrPluralAbbreviation
    { L"mb",    L"m eh 1 g - ax - b ay 2 t", MS_Noun, L"m eh 1 g - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"me",    L"EH 1 M & IY 1", MS_Noun, L"M IY 1", MS_ObjPron, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"mg",    L"m ih 1 l - ax - g r ae 2 m", MS_Noun, L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mi",    L"M AY 1 L", MS_Noun, L"M AY 1 L Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"min",   L"m ih 1 n - ax t", MS_Noun, L"m ih 1 n - ax t S", MS_Noun, L"m ih 1 n - ax - m ax m", MS_Noun, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"ml",    L"m ih 1 l - ax - l iy 2 - t er", MS_Noun, L"m ih 1 l - ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mm",    L"m ih 1 l - ax - m iy 2 - t er", MS_Noun, L"m ih 1 l - ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mpg", L"m ay 1 l & p er 1 & g ae 1 l ax n", MS_Noun, L"m ay 1 l z & p er 1 & g ae 1 l ax n", MS_Noun, L"eh 1 m & p iy 1 & jh iy 1", MS_Noun, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mph",   L"m ay 1 l & p er 1 & aw 1 er", MS_Noun, L"m ay 1 l z & p er 1 & aw 1 er", MS_Noun, L"eh 1 m & p iy 1 & ey 1 ch", MS_Noun, 0, 0 },
    //--- MS millisecond milliseconds
    { L"ms",    L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, L"eh 1 m & eh 1 s", MS_Noun, 0, 5 },
    //--- SingleOrPluralAbbreviation
    { L"msec",  L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"mt",    L"EH 1 M & T IY 1", MS_Noun, L"M AW 1 N T", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"oh",    L"OW 1 & EY 1 CH", MS_Noun, L"OW 1", MS_Interjection, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"or",    L"OW 1 & AA 1 R", MS_Noun, L"AO 1 R", MS_CConj, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"oz",    L"AW 1 N S", MS_Noun, L"AW 1 N S AX Z", MS_Noun, L"AA 1 Z", MS_Noun, 0, 0 },
    //--- AbbreviationFollowedByDigit
    { L"p",     L"P EY 1 JH", MS_Noun, L"P IY 1", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- AllCapsAbbreviation
    { L"pa",    L"P IY 1 & EY 1", MS_Noun, L"P AA 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"pg",    L"P IY 1 & JH IY 1", MS_Noun, L"P EY 1 JH", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"po",    L"p iy 1 & ow 1", MS_Noun, L"p ow 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- PolishDisambig
    { L"polish", L"p ow 1 l - ax sh", MS_Adj, L"p aa 1 l - ih sh", MS_Verb, L"p aa 1 l - ih sh", MS_Noun, 0, 9 },
    //--- SingleOrPluralAbbreviation
    { L"qt",    L"K W AO 1 R T", MS_Noun, L"K W AO 1 R T Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Saturday Sat
    { L"sat",   L"s ae 1 t - er - d ey", MS_Noun, L"S AE 1 T", MS_Verb, NULL, MS_Unknown, 0, 4 },
    //--- SEC Second Seconds
    { L"sec",   L"s eh 1 k - ax n d", MS_Noun, L"s eh 1 k - ax n d Z", MS_Noun, L"EH 1 S & IY 1 & S IY 1", MS_Noun, 0, 5 },
    //--- MeasurementModifier
    { L"sq",    L"S K W EH 1 R", MS_Noun, L"S K W EH 1 R", MS_Noun, NULL, MS_Unknown, 0, 7 },
	//--- AllCapsAbbreviation
    { L"sr",    L"EH 1 S & AA 1 R", MS_Noun, L"s iy 1 n - y er", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- DoctorDriveAbbreviation
    { L"st",    L"S EY 1 N T", MS_Noun, L"S T R IY 1 T", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- SingleOrPluralAbbreviation
    { L"tbsp",  L"t ey 1 - b ax l - s p uw 2 n", MS_Noun, L"t ey 1 - b ax l - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"tsp",   L"t iy 1 - s p uw 2 n", MS_Noun, L"t iy 1 - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"us",    L"Y UW 1 & EH 1 S", MS_Noun, L"AH 1 S", MS_ObjPron, NULL, MS_Unknown, 0, 3 },
    //--- Wednesday Wed
    { L"wed",   L"w eh 1 n z - d ey", MS_Noun, L"W EH 1 D", MS_Verb, NULL, MS_Unknown, 0, 4 },
    //--- AllCapsAbbreviation
    { L"wy",    L"d ah 1 b - ax l - y uw & W AY 1", MS_Noun, L"W EY 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"yd",    L"Y AA 1 R D", MS_Noun, L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"yr",    L"Y IY 1 R", MS_Noun, L"Y IY 1 R Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
AbbrevRecord g_PostLexLookupWordTable[] =
{
    //--- MeasurementDisambig
    { L"bu",    L"b uh 1 sh - ax l", MS_Noun, L"b uh 1 sh - ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"cal",   L"k ae 1 l - ax - r iy", MS_Noun, L"k ae 1 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"cl",    L"s eh 1 n - t ax - l iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"cm",    L"s eh 1 n - t ax - m iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"db",    L"d eh 1 s - ax - b ax l", MS_Noun, L"d eh 1 s - ax - b ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"deg",   L"d ih - g r iy 1", MS_Noun, L"d ih - g r iy 1 z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"ft",    L"F UH 1 T", MS_Noun, L"F IY 1 T", MS_Noun, L"F AO 1 R T", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"g",     L"G R AE 1 M", MS_Noun, L"G R AE 1 M Z", MS_Noun, L"JH IY 1", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"gal",   L"g ae 1 l - ax n", MS_Noun, L"g ae 1 l - ax n Z", MS_Noun, L"G AE 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"hr",    L"AW 1 ER", MS_Noun, L"AW 1 ER Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"in",    L"IH 1 N CH", MS_Noun, L"IH 1 N CH AX Z", MS_Noun, L"IH 1 N", MS_Prep, 0, 0 },
    //--- MeasurementDisambig
    { L"j",     L"JH UW 1 L", MS_Noun, L"JH UW 1 L Z", MS_Noun, L"JH EY 1", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"kb",    L"k ih 1 l - ax - b ay 2 t", MS_Noun, L"k ih 1 l - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"kcal",  L"k ih 1 l - ax - k ae 2 l - ax - r iy", MS_Noun, L"k ih 1 l - ax - k ae 2 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"kg",    L"k ih 1 l - ax - g r ae 2 m", MS_Noun, L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"kj",    L"k ih 1 l - ax - jh uw 2 l", MS_Noun, L"k ih 1 l - ax - jh uw 2 l z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"km",    L"k ih - l aa 1 m - ih - t er", MS_Noun, L"k ih - l aa 1 m - ih - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"kw",    L"k ih 1 l - ax - w aa 2 t", MS_Noun, L"k ih 1 l - ax - w aa 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"l",     L"l iy 1 - t er", MS_Noun, L"l iy 1 - t er Z", MS_Noun, L"EH 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"lb",    L"P AW 1 N D", MS_Noun, L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"m",     L"M IY 1 - T ER", MS_Noun, L"M IY 1 - T ER Z", MS_Noun, L"EH 1 M", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"mb",    L"m eh 1 g - ax - b ay 2 t", MS_Noun, L"m eh 1 g - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mg",    L"m ih 1 l - ax - g r ae 2 m", MS_Noun, L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mi",    L"M AY 1 L", MS_Noun, L"M AY 1 L Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"min",   L"m ih 1 n - ax t", MS_Noun, L"m ih 1 n - ax t S", MS_Noun, L"m ih 1 n - ax - m ax m", MS_Noun, 0, 0 },
    //--- ReadDisambig
    { L"misread", L"m ih s - r iy 1 d", MS_Verb, L"m ih s - r eh 1 d", MS_Verb, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementDisambig
    { L"ml",    L"m ih 1 l - ax - l iy 2 - t er", MS_Noun, L"m ih 1 l - ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mm",    L"m ih 1 l - ax - m iy 2 - t er", MS_Noun, L"m ih 1 l - ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mpg", L"m ay 1 l & p er 1 & g ae 1 l ax n", MS_Noun, L"m ay 1 l z & p er 1 & g ae 1 l ax n", MS_Noun, L"eh 1 m & p iy 1 & jh iy 1", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"mph",   L"m ay 1 l & p er 1 & aw 1 er", MS_Noun, L"m ay 1 l z & p er 1 & aw 1 er", MS_Noun, L"eh 1 m & p iy 1 & ey 1 ch", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"msec",  L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"oz",    L"AW 1 N S", MS_Noun, L"AW 1 N S AX Z", MS_Noun, L"AA 1 Z", MS_Noun, 0, 0 },
    //--- ReadDisambig
    { L"proofread", L"p r uw 1 f - r iy 2 d", MS_Verb, L"p r uw 1 f - r eh 2 d", MS_Verb, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementDisambig
    { L"qt",    L"K W AO 1 R T", MS_Noun, L"K W AO 1 R T Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- ReadDisambig
    { L"read",  L"R IY 1 D", MS_Verb, L"R EH 1 D", MS_Verb, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementDisambig
    { L"sec",   L"S EH 1 k - ax n d", MS_Noun, L"s eh 1 k - ax n d z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"tbsp",  L"t ey 1 - b ax l - s p uw 2 n", MS_Noun, L"t ey 1 - b ax l - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- TheDisambig
    { L"the",   L"DH IY 2", MS_Det, L"DH AX 2", MS_Det, NULL, MS_Unknown, 0, 1 },
    //--- MeasurementDisambig
    { L"tsp",   L"t iy 1 - s p uw 2 n", MS_Noun, L"t iy 1 - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"yd",    L"Y AA 1 R D", MS_Noun, L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"yr",    L"Y IY 1 R", MS_Noun, L"Y IY 1 R Z", MS_Noun, NULL, MS_Unknown, 0, 0 },

};

WCHAR *g_pOfA = L"ah 2 v & ax 2 &";
WCHAR *g_pOfAn = L"ah 2 v & ax 2 n &";

const SentBreakDisambigFunc g_SentBreakDisambigTable[] = 
{
    CStdSentEnum::IsAbbreviationEOS,
    CStdSentEnum::IfEOSNotAbbreviation,
    CStdSentEnum::IfEOSAndLowercaseNotAbbreviation,
};

const PronDisambigFunc g_PronDisambigTable[] = 
{
    CStdSentEnum::SingleOrPluralAbbreviation,
    CStdSentEnum::DoctorDriveAbbreviation,
    CStdSentEnum::AbbreviationFollowedByDigit,
    CStdSentEnum::DegreeAbbreviation,
    CStdSentEnum::AbbreviationModifier,
};

const PronDisambigFunc g_AmbiguousWordDisambigTable[] =
{
    CStdSentEnum::SingleOrPluralAbbreviation,
    CStdSentEnum::DoctorDriveAbbreviation,
    CStdSentEnum::AbbreviationFollowedByDigit,
    CStdSentEnum::AllCapsAbbreviation,
    CStdSentEnum::CapitalizedAbbreviation,
    CStdSentEnum::SECAbbreviation,
    CStdSentEnum::DegreeAbbreviation,
	CStdSentEnum::AbbreviationModifier,
    CStdSentEnum::ADisambig,
    CStdSentEnum::PolishDisambig,
};

const PostLexLookupDisambigFunc g_PostLexLookupDisambigTable[] =
{
    CStdSentEnum::MeasurementDisambig,
    CStdSentEnum::TheDisambig,
    CStdSentEnum::ReadDisambig,
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
// This is an alphabetized list of all non-proper-noun words which
// appear within the list of the 200 most frequent first words
// in sentences in both the Brown and WSJ corpora.
const SPLSTR g_FirstWords[] =
{
DEF_SPLSTR( "A" ),
DEF_SPLSTR( "About" ),
DEF_SPLSTR( "According" ),
DEF_SPLSTR( "After" ),
DEF_SPLSTR( "Again" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "All" ),
DEF_SPLSTR( "Also" ),
DEF_SPLSTR( "Although" ),
DEF_SPLSTR( "Among" ),
DEF_SPLSTR( "An" ),
DEF_SPLSTR( "And" ),
DEF_SPLSTR( "Another" ),
DEF_SPLSTR( "Any" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Anyway" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Are" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "As" ),
DEF_SPLSTR( "At" ),
DEF_SPLSTR( "Back" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Because" ),
DEF_SPLSTR( "Before" ),
DEF_SPLSTR( "Besides" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Both" ),
DEF_SPLSTR( "But" ),
DEF_SPLSTR( "By" ),
DEF_SPLSTR( "Can" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Consequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Dear" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Despite" ),
DEF_SPLSTR( "Did" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Do" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Does" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Don't" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "During" ),
DEF_SPLSTR( "Each" ),
DEF_SPLSTR( "Early" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Even" ),
DEF_SPLSTR( "Every" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Finally" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "First" ),
DEF_SPLSTR( "Following" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "For" ),
DEF_SPLSTR( "Four" ),
DEF_SPLSTR( "From" ),
DEF_SPLSTR( "Further" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Furthermore" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Generally" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Given" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Go" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Great" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Had" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Have" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Having" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "He" ),
DEF_SPLSTR( "Her" ),
DEF_SPLSTR( "Here" ),
DEF_SPLSTR( "His" ),
DEF_SPLSTR( "How" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "However" ),
DEF_SPLSTR( "I" ),
DEF_SPLSTR( "If" ),
DEF_SPLSTR( "In" ),
DEF_SPLSTR( "Indeed" ),
DEF_SPLSTR( "Initially" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Instead" ),
DEF_SPLSTR( "Is" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "It" ),
DEF_SPLSTR( "Its" ),
DEF_SPLSTR( "Just" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Last" ),
DEF_SPLSTR( "Later" ),
DEF_SPLSTR( "Let" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Like" ),
DEF_SPLSTR( "Many" ),
DEF_SPLSTR( "Maybe" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Meanwhile" ),
DEF_SPLSTR( "More" ),
DEF_SPLSTR( "Moreover" ),
DEF_SPLSTR( "Most" ),
DEF_SPLSTR( "Much" ),
DEF_SPLSTR( "My" ),    // Added to fix bug #385
DEF_SPLSTR( "Neither" ),
DEF_SPLSTR( "Never" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nevertheless" ),
DEF_SPLSTR( "New" ),
DEF_SPLSTR( "Next" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "No" ),
DEF_SPLSTR( "None" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nonetheless" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nor" ),
DEF_SPLSTR( "Not" ),
DEF_SPLSTR( "Nothing" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Now" ),
DEF_SPLSTR( "Of" ),
DEF_SPLSTR( "On" ),
DEF_SPLSTR( "Once" ),
DEF_SPLSTR( "One" ),
DEF_SPLSTR( "Only" ),
DEF_SPLSTR( "Or" ),
DEF_SPLSTR( "Other" ),
DEF_SPLSTR( "Others" ),
DEF_SPLSTR( "Our" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Over" ),
DEF_SPLSTR( "People" ),
DEF_SPLSTR( "Perhaps" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Please" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Previous" ),                             // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Recent" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Right" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Second" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "See" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Several" ),
DEF_SPLSTR( "She" ),
DEF_SPLSTR( "Shortly" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Similarly" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Since" ),
DEF_SPLSTR( "So" ),
DEF_SPLSTR( "Some" ),
DEF_SPLSTR( "Sometimes" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Soon" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Still" ),
DEF_SPLSTR( "Subsequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Such" ),
DEF_SPLSTR( "Take" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "That" ),
DEF_SPLSTR( "The" ),
DEF_SPLSTR( "Their" ),
DEF_SPLSTR( "Then" ),
DEF_SPLSTR( "There" ),
DEF_SPLSTR( "Thereafter" ),                           // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Therefore" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "These" ),
DEF_SPLSTR( "They" ),
DEF_SPLSTR( "This" ),
DEF_SPLSTR( "Those" ),
DEF_SPLSTR( "Though" ),
DEF_SPLSTR( "Three" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Through" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Thus" ),
DEF_SPLSTR( "To" ),
DEF_SPLSTR( "Today" ),
DEF_SPLSTR( "Two" ),
DEF_SPLSTR( "Under" ),
DEF_SPLSTR( "Unlike" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Until" ),
DEF_SPLSTR( "Upon" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "We" ),
DEF_SPLSTR( "Well" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "What" ),
DEF_SPLSTR( "When" ),
DEF_SPLSTR( "Where" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Whether" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Which" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "While" ),
DEF_SPLSTR( "Who" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Why" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Will" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "With" ),
DEF_SPLSTR( "Within" ),
DEF_SPLSTR( "Without" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yes" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yet" ),
DEF_SPLSTR( "You" ),
DEF_SPLSTR( "Your" ),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\miscnorm.cpp ===
/***********************************************************************************************
* MiscNorm.cpp *
*--------------*
*  Description:
*   These are miscallaneous functions used in normalization.
*-----------------------------------------------------------------------------------------------
*  Created by AH                                                                August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

/*****************************************************************************
* IsStateAndZipcode *
*-------------------*
*       This function checks to see if the next two tokens are a state
*   abbreviation and zipcode.
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::IsStateAndZipcode( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                         CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsStateAndZipcode" );
    HRESULT hr = S_OK;

    const StateStruct *pState = NULL;
    const WCHAR temp = *m_pEndOfCurrItem;
    *( (WCHAR*) m_pEndOfCurrItem ) = 0;

    //--- Try to match a state abbreviation
    pState = (StateStruct*) bsearch( (void*) m_pNextChar, (void*) g_StateAbbreviations, sp_countof( g_StateAbbreviations),
                                     sizeof( StateStruct ), CompareStringAndStateStruct );

    if ( pState )
    {
        *( (WCHAR*) m_pEndOfCurrItem ) = temp;

        const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfCurrItem = m_pEndOfCurrItem;
        const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;
        CItemList PostStateList;
        TTSItemInfo *pZipCodeInfo;
        
        m_pNextChar = m_pEndOfCurrItem;
        if ( *m_pNextChar == L',' || 
             *m_pNextChar == L';' )
        {
            m_pNextChar++;
        }

        hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostStateList );

        if ( !m_pNextChar &&
             SUCCEEDED( hr ) )
        {
            hr = E_INVALIDARG;
        }
        else if ( SUCCEEDED( hr ) )
        {
            m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
            while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) )  != eUNMATCHED ||
                    IsGroupEnding( *(m_pEndOfCurrItem - 1) )      != eUNMATCHED ||
                    IsQuotationMark( *(m_pEndOfCurrItem - 1) )    != eUNMATCHED ||
                    IsEOSItem( *(m_pEndOfCurrItem - 1) )          != eUNMATCHED )
            {
                m_pEndOfCurrItem--;
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = IsZipCode( pZipCodeInfo, L"ZIPCODE", MemoryManager );
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo = 
                    (TTSStateAndZipCodeItemInfo*) MemoryManager.GetMemory( sizeof( TTSStateAndZipCodeItemInfo ), 
                                                                           &hr );
                if ( SUCCEEDED( hr ) )
                {
                    pItemNormInfo->Type = eSTATE_AND_ZIPCODE;
                    ( (TTSStateAndZipCodeItemInfo*) pItemNormInfo )->pZipCode = (TTSZipCodeItemInfo*) pZipCodeInfo;

                    TTSWord Word;
                    ZeroMemory( &Word, sizeof( TTSWord ) );

                    //--- Some states have multi-word names 
                    const WCHAR *pNextPointer = NULL, *pPrevPointer = NULL;
                    ULONG ulLength = 0;

                    pNextPointer = pState->FullName.pStr;
                    do {
                        pPrevPointer = pNextPointer;
                        pNextPointer = wcschr(pPrevPointer, L' ');
                        if (pNextPointer)
                        {
                            ulLength = (ULONG)(pNextPointer - pPrevPointer);
                            pNextPointer++;
                        }
                        else
                        {
                            ulLength = wcslen(pPrevPointer);
                        }
                        Word.pXmlState          = &pTempFrag->State;
                        Word.pWordText          = pPrevPointer;
                        Word.ulWordLen          = ulLength;
                        Word.pLemma             = pPrevPointer;
                        Word.ulLemmaLen         = ulLength;
                        Word.eWordPartOfSpeech  = MS_Unknown;
                        WordList.AddTail( Word );

                    } while ( pNextPointer );
                    
                    while( !PostStateList.IsEmpty() )
                    {
                        WordList.AddTail( ( PostStateList.RemoveHead() ).Words[0] );
                    }

                    hr = ExpandZipCode( (TTSZipCodeItemInfo*) pZipCodeInfo, WordList );
                }
            }
            else
            {
                m_pNextChar      = pTempNextChar;
                m_pEndOfCurrItem = pTempEndOfCurrItem;
                m_pEndChar       = pTempEndChar;
                m_pCurrFrag      = pTempFrag;
                hr = E_INVALIDARG;
            }
        }
        m_pNextChar = pTempNextChar;
    }
    else
    {
        *( (WCHAR*) m_pEndOfCurrItem ) = temp;
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsStateAndZipcode */

/*****************************************************************************
* IsHyphenatedString *
*--------------------*
*       This function checks to see if the next token is a hyphenated string
*   consisting of two alpha words or numbers, or one of these and another
*   hyphenated string.
********************************************************************* AH ****/
HRESULT CStdSentEnum::IsHyphenatedString( const WCHAR* pStartChar, const WCHAR* pEndChar, 
                                          TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsHyphenatedString" );
    HRESULT hr = S_OK;
    TTSItemInfo *pFirstChunkInfo = NULL, *pSecondChunkInfo = NULL;

    const WCHAR* pHyphen = NULL, *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    for ( pHyphen = pStartChar; pHyphen < pEndChar; pHyphen++ )
    {
        if ( *pHyphen == L'-' )
        {
            break;
        }
    }

    if ( *pHyphen == L'-'       && 
         pHyphen > pStartChar   &&
         pHyphen < pEndChar - 1 )
    {        
        hr = IsAlphaWord( pStartChar, pHyphen, pFirstChunkInfo, MemoryManager );
        if ( hr == E_INVALIDARG )
        {
            m_pNextChar      = pStartChar;
            m_pEndOfCurrItem = pHyphen;
            hr = IsNumberCategory( pFirstChunkInfo, L"NUMBER", MemoryManager );
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = IsAlphaWord( pHyphen + 1, pEndChar, pSecondChunkInfo, MemoryManager );
            if ( hr == E_INVALIDARG )
            {
                m_pNextChar      = pHyphen + 1;
                m_pEndOfCurrItem = pEndChar;
                hr = IsNumberCategory( pSecondChunkInfo, L"NUMBER", MemoryManager );
            }
            if ( hr == E_INVALIDARG )
            {
                hr = IsHyphenatedString( pHyphen + 1, pEndChar, pSecondChunkInfo, MemoryManager );
            }
            if ( hr == E_INVALIDARG )
            {
                if ( pFirstChunkInfo->Type != eALPHA_WORD )
                {
                    delete ( (TTSNumberItemInfo*) pFirstChunkInfo )->pWordList;
                }
            }
        }
        m_pNextChar      = pTempNextChar;
        m_pEndOfCurrItem = pTempEndOfItem;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        pItemNormInfo = (TTSHyphenatedStringInfo*) MemoryManager.GetMemory( sizeof(TTSHyphenatedStringInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eHYPHENATED_STRING;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pFirstChunkInfo  = pFirstChunkInfo;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pSecondChunkInfo = pSecondChunkInfo;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pFirstChunk      = pStartChar;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pSecondChunk     = pHyphen + 1;
        }
    }

    return hr;
} /* IsHyphenatedString */

/*****************************************************************************
* ExpandHyphenatedString *
*------------------------*
*       This function expands hyphenated strings.
********************************************************************* AH ****/
HRESULT CStdSentEnum::ExpandHyphenatedString( TTSHyphenatedStringInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandHyphenatedString" );
    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( pItemInfo->pFirstChunkInfo->Type == eALPHA_WORD )
    {
        Word.pWordText  = pItemInfo->pFirstChunk;
        Word.ulWordLen  = (ULONG)(pItemInfo->pSecondChunk - pItemInfo->pFirstChunk - 1);
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }
    else
    {
        hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pFirstChunkInfo, WordList );
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( pItemInfo->pSecondChunkInfo->Type == eALPHA_WORD )
        {
            Word.pWordText  = pItemInfo->pSecondChunk;
            Word.ulWordLen  = (ULONG)(m_pEndOfCurrItem - pItemInfo->pSecondChunk);
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else if ( pItemInfo->pSecondChunkInfo->Type == eHYPHENATED_STRING )
        {
            hr = ExpandHyphenatedString( (TTSHyphenatedStringInfo*) pItemInfo->pSecondChunkInfo, WordList );
        }
        else
        {
            hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pSecondChunkInfo, WordList );
        }
    }

    return hr;
} /* ExpandHyphenatedString */

/*****************************************************************************
* IsSuffix *
*----------*
*       This function checks to see if the next token is a suffix string 
*   consisting of a hyphen followed by alpha characters.
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::IsSuffix( const WCHAR* pStartChar, const WCHAR* pEndChar, 
                                TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsSuffix" );
    HRESULT hr = S_OK;

    if ( *pStartChar == L'-' )
    {
        const WCHAR *pIterator = pStartChar + 1;
        while ( pIterator < pEndChar &&
                iswalpha( *pIterator ) )
        {
            pIterator++;
        }

        if ( pIterator == pEndChar &&
             pIterator != ( pStartChar + 1 ) )
        {
            pItemNormInfo = (TTSSuffixItemInfo*) MemoryManager.GetMemory( sizeof( TTSSuffixItemInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo->Type = eSUFFIX;
                ( (TTSSuffixItemInfo*) pItemNormInfo )->pFirstChar = pStartChar + 1;
                ( (TTSSuffixItemInfo*) pItemNormInfo )->ulNumChars = (ULONG)( ( pEndChar - pStartChar ) - 1 );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsSuffix */

/*****************************************************************************
* ExpandSuffix *
*--------------*
*       This function expands strings determined to by suffixes by IsSuffix
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::ExpandSuffix( TTSSuffixItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandSuffix" );
    HRESULT hr = S_OK;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    for ( ULONG i = 0; i < pItemInfo->ulNumChars; i++ )
    {
        Word.pWordText  = g_ANSICharacterProns[ pItemInfo->pFirstChar[i] ].pStr;
        Word.ulWordLen  = g_ANSICharacterProns[ pItemInfo->pFirstChar[i] ].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    return hr;
} /* ExpandSuffix */

/*****************************************************************************
* ExpandPunctuation *
*-------------------*
*       This function expands punctuation marks into words - e.g. '.' becomes
*   "period".  It actually just uses the same table that 
*   ExpandUnrecognizedString uses to look up string versions of characters.
********************************************************************* AH ****/
void CStdSentEnum::ExpandPunctuation( CWordList& WordList, WCHAR wc )
{
    const WCHAR *pPrevPointer = NULL, *pNextPointer = NULL;
    ULONG ulLength = 0;
    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    switch ( wc )
    {
    //--- Periods normally are pronounced as "dot", rather than "period".
    case L'.':
        Word.pWordText  = g_periodString.pStr;
        Word.ulWordLen  = g_periodString.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        break;

    default:
        //--- Some characters have multi-word names 
        pNextPointer = g_ANSICharacterProns[wc].pStr;
        do {
            pPrevPointer = pNextPointer;
            pNextPointer = wcschr(pPrevPointer, L' ');
            if (pNextPointer)
            {
                ulLength = (ULONG)(pNextPointer - pPrevPointer);
                pNextPointer++;
            }
            else
            {
                ulLength = wcslen(pPrevPointer);
            }
            Word.pXmlState          = &m_pCurrFrag->State;
            Word.pWordText          = pPrevPointer;
            Word.ulWordLen          = ulLength;
            Word.pLemma             = pPrevPointer;
            Word.ulLemmaLen         = ulLength;
            Word.eWordPartOfSpeech  = MS_Unknown;
            WordList.AddTail( Word );

        } while ( pNextPointer );

        break;
    }

} /* ExpandPunctuation */

/*****************************************************************************
* ExpandUnrecognizedString *
*--------------------------*
*       This function is where text ends up if it needs to be normalized, 
*   and wasn't recognized as anything (e.g. a number or a date).  Contiguous 
*   alpha characters are grouped together for lookup, contiguous digits are
*   expanded as numbers, and all other characters are expanded by name (e.g.
*   '(' -> "left parenthesis").
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::ExpandUnrecognizedString( CWordList& WordList, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandUnrecognizedString" );
    HRESULT hr = S_OK;

    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );

    const WCHAR *pCurr = m_pNextChar, *pPrev, *pEnd = m_pEndOfCurrItem;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const WCHAR *pPrevPointer = NULL, *pNextPointer = NULL;
    WCHAR Temp = 0;
    ULONG ulTempCount = 0;
    ULONG ulLength;
    bool bDone = false;

    while (pCurr < pEnd && SUCCEEDED(hr) && !bDone)
    {
        pPrev = pCurr;

        //--- Special Case: alpha characters 
        if (iswalpha(*pCurr))
        {
            ulTempCount = 0;
            do {
                pCurr++;
            } while (pCurr < pEnd && iswalpha(*pCurr));

            Word.pXmlState          = &m_pCurrFrag->State;
            Word.pWordText          = pPrev;
            Word.ulWordLen          = (ULONG)(pCurr - pPrev);
            Word.pLemma             = Word.pWordText;
            Word.ulLemmaLen         = Word.ulWordLen;
            Word.eWordPartOfSpeech  = MS_Unknown;
            WordList.AddTail( Word );
        }
        //--- Special Case: digits 
        else if (isdigit(*pCurr))
        {
            ulTempCount = 0;
            do {
                pCurr++;
            } while (pCurr < pEnd && isdigit(*pCurr));

            TTSItemInfo* pGarbage;
            m_pNextChar      = pPrev;
            m_pEndOfCurrItem = pCurr;

            hr = IsNumber( pGarbage, L"NUMBER", MemoryManager, false );
            if ( SUCCEEDED( hr ) )
            {
                hr = ExpandNumber( (TTSNumberItemInfo*) pGarbage, WordList );
            }

            m_pNextChar      = pTempNextChar;
            m_pEndOfCurrItem = pTempEndOfItem;
        }
        //--- Default Case 
        else if (0 <= *pCurr && *pCurr <= sp_countof(g_ANSICharacterProns) &&
                    g_ANSICharacterProns[*pCurr].Len != 0)
        {
            if ( ulTempCount == 0 )
            {
                Temp = *pCurr;
                ulTempCount++;
            }
            else if ( Temp == *pCurr )
            {
                ulTempCount++;
            }
            else
            {
                Temp = *pCurr;
                ulTempCount = 1;
            }
             
            if ( ulTempCount < 4 )
            {
                //--- Some characters have multi-word names 
                pNextPointer = g_ANSICharacterProns[*pCurr].pStr;
                do {
                    pPrevPointer = pNextPointer;
                    pNextPointer = wcschr(pPrevPointer, L' ');
                    if (pNextPointer)
                    {
                        ulLength = (ULONG )(pNextPointer - pPrevPointer);
                        pNextPointer++;
                    }
                    else
                    {
                        ulLength = wcslen(pPrevPointer);
                    }
                    Word.pXmlState          = &m_pCurrFrag->State;
                    Word.pWordText          = pPrevPointer;
                    Word.ulWordLen          = ulLength;
                    Word.pLemma             = pPrevPointer;
                    Word.ulLemmaLen         = ulLength;
                    Word.eWordPartOfSpeech  = MS_Unknown;
                    WordList.AddTail( Word );

                } while (SUCCEEDED(hr) && pNextPointer);
            }

            pCurr++;
        }
        else // Character is not expandable
        {
            pCurr++;
        }
    }

    return hr;
} /* ExpandUnrecognizedString */

/*****************************************************************************
* SpellOutString *
*----------------*
*       This function expands strings surrounded by the <SPElL> XML tag.  
*   It uses the same table to look up character expansions as 
*   ExpandUnrecognizedString, but ALL characters are expanded by name.
********************************************************************* AH ****/
HRESULT CStdSentEnum::SpellOutString( CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::SpellOutString" );
    HRESULT hr = S_OK;

    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );

    const WCHAR *pCurr = m_pNextChar, *pPrev, *pEnd = m_pEndOfCurrItem;
    const WCHAR *pPrevPointer = NULL, *pNextPointer = NULL;
    ULONG ulLength;
    bool bDone = false;

    while (pCurr < pEnd && SUCCEEDED(hr) && !bDone)
    {
        pPrev = pCurr;

        if ( 0 <= *pCurr                                && 
             *pCurr <= sp_countof(g_ANSICharacterProns) &&
             g_ANSICharacterProns[*pCurr].Len != 0 )
        {

            //--- Some characters have multi-word names 
            pNextPointer = g_ANSICharacterProns[*pCurr].pStr;
            do {
                pPrevPointer = pNextPointer;
                pNextPointer = wcschr(pPrevPointer, L' ');
                if (pNextPointer)
                {
                    ulLength = (ULONG)(pNextPointer - pPrevPointer);
                    pNextPointer++;
                }
                else
                {
                    ulLength = wcslen(pPrevPointer);
                }
                Word.pXmlState          = &m_pCurrFrag->State;
                Word.pWordText          = pPrevPointer;
                Word.ulWordLen          = ulLength;
                Word.pLemma             = pPrevPointer;
                Word.ulLemmaLen         = ulLength;
                Word.eWordPartOfSpeech  = MS_Unknown;
                WordList.AddTail( Word );

            } while (SUCCEEDED(hr) && pNextPointer);

            pCurr++;
        }
        else // Character is not expandable
        {
            pCurr++;
        }
    }

    return hr;
} /* SpellOutString */

//-----------End Of File-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\morph.h ===
/*******************************************************************************
* morph.h *
*---------*
*   Description:
*       This is the header file for the CSMorph implementation.  This class 
*   attempts to find pronunciations for morphological variants (which do not
*   occur in the lexicon) of root words (which do occur in the lexicon).  
*-------------------------------------------------------------------------------
*  Created By: AH                            Date: 08/16/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/
#ifndef Morph_h
#define Morph_h

#include "ms_entropicengine.h"

// Additional includes...
#include "stdafx.h"
#include "commonlx.h"

//== CONSTANTS ================================================================

#define MAX_POSCONVERSIONS 4
#define NUM_POS 5


/*** SUFFIX_TYPE **************************************************************
* This enumeration contains values for all of the suffixes which can be matched
* and accounted for by the CSMorph class.
*/
static const enum SUFFIX_TYPE
{
    S_SUFFIX = 0,
    ED_SUFFIX,
    ING_SUFFIX,
    APOSTROPHES_SUFFIX,
    APOSTROPHE_SUFFIX,
    ER_SUFFIX,
    EST_SUFFIX,
    OR_SUFFIX,
    MENT_SUFFIX,
    AGE_SUFFIX,
    LESS_SUFFIX,
    Y_SUFFIX,
    EDLY_SUFFIX,
    LY_SUFFIX,
    ABLE_SUFFIX,
    NESS_SUFFIX,
    ISM_SUFFIX,
    IZE_SUFFIX,
    IZ_SUFFIX,
    HOOD_SUFFIX,
    FUL_SUFFIX,
    LIKE_SUFFIX,
    WISE_SUFFIX,
    ISH_SUFFIX,
    ABLY_SUFFIX,
    SHIP_SUFFIX,
    ICALLY_SUFFIX,
    SOME_SUFFIX,
    ILY_SUFFIX,
    ICISM_SUFFIX,
    ICIZE_SUFFIX,
    NO_MATCH = -1,
};


/* SUFFIX_INFO, g_SuffixTable[] ***********************************************
* This table is used to map the orthographic forms of suffixes to their suffix
* types.  Each suffix is stored in reverse order for easier comparison with 
* the ends of strings...
*/
struct SUFFIX_INFO 
{
    WCHAR       Orth[10];
    SUFFIX_TYPE Type;
};

static const SUFFIX_INFO g_SuffixTable[] = 
{ 
    { L"RE",        ER_SUFFIX },
    { L"TSE",       EST_SUFFIX },
    { L"GNI",       ING_SUFFIX },
    { L"ELBA",      ABLE_SUFFIX },
    { L"ELBI",      ABLE_SUFFIX },
    { L"YLDE",      EDLY_SUFFIX },
    { L"YLBA",      ABLY_SUFFIX },
    { L"YLBI",      ABLY_SUFFIX },
    { L"YLLACI",    ICALLY_SUFFIX },
    { L"YLI",       ILY_SUFFIX },
    { L"YL",        LY_SUFFIX },
    { L"Y",         Y_SUFFIX },
    { L"TNEM",      MENT_SUFFIX },
    { L"RO",        OR_SUFFIX },
    { L"SSEN",      NESS_SUFFIX },
    { L"SSEL",      LESS_SUFFIX },
    { L"EZICI",     ICIZE_SUFFIX },
    { L"EZI",       IZE_SUFFIX },
    { L"ZI",        IZ_SUFFIX },
    { L"MSICI",     ICISM_SUFFIX },
    { L"MSI",       ISM_SUFFIX },
    { L"DE",        ED_SUFFIX },
    { L"S'",        APOSTROPHES_SUFFIX },
    { L"S",         S_SUFFIX },
    { L"'",         APOSTROPHE_SUFFIX },
    { L"EGA",       AGE_SUFFIX },
    { L"DOOH",      HOOD_SUFFIX },
    { L"LUF",       FUL_SUFFIX },
    { L"EKIL",      LIKE_SUFFIX },
    { L"ESIW",      WISE_SUFFIX },
    { L"HSI",       ISH_SUFFIX },
    { L"PIHS",      SHIP_SUFFIX },
    { L"EMOS",      SOME_SUFFIX },
};


/*** PHONTYPE *****************************************************************
* This enumeration creates flags which can be used to determine the relevant
* features of each phone.
*/
static const enum PHONTYPE
{	
    eCONSONANTF = (1<<0),
    eVOICEDF = (1<<1),
    ePALATALF = (1<<2),
};


/*** g_PhonTable[], g_PhonS, g_PhonZ *******************************************
* This table is used to map the internal values of phones to their types, which 
* are just clusters of features relevant to the necessary phonological rules.
* g_PhonS, g_PhonZ, g_PhonD, g_PhonT are just used to make the code a bit more
* readable.
*/
static const long g_PhonTable[] = 
{
    eCONSONANTF,                        // Default value - 0 is not a valid phone
    eCONSONANTF,                        // 1 is a syllable boundary - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 2 is an exclamation point - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 3 is a word boundary - treated as a consonant
    eCONSONANTF,                        // 4 is a comma - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 5 is a period - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 6 is a question mark - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 7 is a silence - shouldn't ever occur at the end of a word
    eVOICEDF,                           // 8 is primary stress - treat as a vowel since it should always be attached to a vowel nucleus
    eVOICEDF,                           // 9 is secondatry stress - see primary stress
    eVOICEDF,                           // 10 -> AA
    eVOICEDF,                           // 11 -> AE
    eVOICEDF,                           // 12 -> AH
    eVOICEDF,                           // 13 -> AO
    eVOICEDF,                           // 14 -> AW
    eVOICEDF,                           // 15 -> AX
    eVOICEDF,                           // 16 -> AY
    eCONSONANTF + eVOICEDF,             // 17 -> b
    eCONSONANTF + ePALATALF,            // 18 -> CH
    eCONSONANTF + eVOICEDF,             // 19 -> d
    eCONSONANTF + eVOICEDF,             // 20 -> DH
    eVOICEDF,                           // 21 -> EH
    eVOICEDF,                           // 22 -> ER
    eVOICEDF,                           // 23 -> EY
    eCONSONANTF,                        // 24 -> f
    eCONSONANTF + eVOICEDF,             // 25 -> g
    eCONSONANTF,                        // 26 -> h
    eVOICEDF,                           // 27 -> IH
    eVOICEDF,                           // 28 -> IY
    eCONSONANTF + eVOICEDF + ePALATALF, // 29 -> JH
    eCONSONANTF,                        // 30 -> k
    eCONSONANTF + eVOICEDF,             // 31 -> l
    eCONSONANTF + eVOICEDF,             // 32 -> m
    eCONSONANTF + eVOICEDF,             // 33 -> n
    eCONSONANTF + eVOICEDF,             // 34 -> NG
    eVOICEDF,                           // 35 -> OW
    eVOICEDF,                           // 36 -> OY
    eCONSONANTF,                        // 37 -> p
    eCONSONANTF + eVOICEDF,             // 38 -> r
    eCONSONANTF,                        // 39 -> s
    eCONSONANTF + ePALATALF,            // 40 -> SH
    eCONSONANTF,                        // 41 -> t
    eCONSONANTF,                        // 42 -> TH
    eVOICEDF,                           // 43 -> UH
    eVOICEDF,                           // 44 -> UW
    eCONSONANTF + eVOICEDF,             // 45 -> v
    eCONSONANTF + eVOICEDF,             // 46 -> w
    eCONSONANTF + eVOICEDF,             // 47 -> y
    eCONSONANTF + eVOICEDF,             // 48 -> z
    eCONSONANTF + eVOICEDF + ePALATALF, // 49 -> ZH
};

static WCHAR g_phonAXl[] = L" AX l";
static WCHAR g_phonAXz[] = L" AX z";
static WCHAR g_phonS[] = L" s";
static WCHAR g_phonZ[] = L" z";
static WCHAR g_phonD[] = L" d";
static WCHAR g_phonAXd[] = L" AX d";
static WCHAR g_phonT[] = L" t";
static WCHAR g_phonIY[] = L" IY";
static WCHAR g_phonL[] = L" l";

/*** struct POS_CONVERT *******************************************************
* This struct stores the From and To parts of speech for a suffix...
*/
struct POS_CONVERT
{
    ENGPARTOFSPEECH FromPos;
    ENGPARTOFSPEECH ToPos;
};

/*** MorphSpecialCaseFlags ****************************************************
* This enum allows DoSuffixMorph to be nearly completely table driven.  Each
* suffix has a MorphSpecialCaseFlags entry in the SuffixInfoTable which tells
* DoSuffixMorph which special case functions (check for missing E, etc.) need
* to be called if the initial lex lookup fails.
*/
typedef enum MorphSpecialCaseFlags
{
    eCheckForMissingE       = 1L << 0,
    eCheckYtoIMutation      = 1L << 1,
    eCheckDoubledMutation   = 1L << 2,
    eCheckForMissingY       = 1L << 3,
    eCheckForMissingL       = 1L << 4,
} MorphSpecialCaseFlags;

/*** struct SUFFIXPRON_INFO ***************************************************
* This struct stores the pronunciation of a suffix, as well as the POS 
* categories it takes as input and output.
*/
struct SUFFIXPRON_INFO 
{
    WCHAR SuffixString[SP_MAX_PRON_LENGTH];
    POS_CONVERT Conversions[MAX_POSCONVERSIONS];
    short NumConversions;
    DWORD dwMorphSpecialCaseFlags;
};

/*** bool SuffixInfoTableInitialized *******************************************
* This bool just lets threads know whether they are the first to use the 
* following table, and thus whether they need to initialize it or not.
*/
static bool SuffixInfoTableInitialized = false;

/*** SUFFIXPRON_INFO g_SuffixInfoTable *****************************************
* This table drives the DoSuffixMorph function, by storing the pronunciation, 
* conversions, number of conversions, and special case flags for each suffix...
*/
static SUFFIXPRON_INFO g_SuffixInfoTable [] =
{
/********************************************************************************************************/
/*    Pronunciation     *  Conversions  *   NumConversions * Special Case Flags      *   SuffixType      */
/********************************************************************************************************/
    { L" s",            { {MS_Verb,   MS_Verb}, 
                          {MS_Noun,   MS_Noun}  },    2,  0 },                          // S_SUFFIX
    { L" d",            { {MS_Verb,   MS_Verb}, 
                          {MS_Verb,   MS_Adj}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ED_SUFFIX
    { L" IH NG",        { {MS_Verb,   MS_Verb}, 
                          {MS_Verb,   MS_Adj},
                          {MS_Verb,   MS_Noun}  },    3,  eCheckForMissingE +
                                                          eCheckDoubledMutation   },    // ING_SUFFIX
    { L" s",            { {MS_Noun,   MS_Noun}  },    1,  0 },                          // APOSTROPHES_SUFFIX
    { L" s",            { {MS_Noun,   MS_Noun}  },    1,  0 },                          // APOSTROPHE_SUFFIX
    { L" ER",           { {MS_Adj,    MS_Adj}, 
                          {MS_Adv,    MS_Adv}, 
                          {MS_Adj,    MS_Adv}, 
                          {MS_Verb,   MS_Noun}  },    4,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ER_SUFFIX
    { L" AX s t",       { {MS_Adj,    MS_Adj}, 
                          {MS_Adv,    MS_Adv},
                          {MS_Adj,    MS_Adv}   },    3,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // EST_SUFFIX
    { L" ER",           { {MS_Verb,   MS_Noun}  },    1,  eCheckForMissingE +
                                                          eCheckDoubledMutation },      // OR_SUFFIX
    { L" m AX n t",     { {MS_Verb,   MS_Noun}  },    1,  eCheckYtoIMutation },         // MENT_SUFFIX
    { L" IH JH",        { {MS_Verb,   MS_Noun}  },    1,  eCheckForMissingE + 
                                                          eCheckDoubledMutation   },    // AGE_SUFFIX
    { L" l IH s",       { {MS_Noun,   MS_Adj}   },    1,  eCheckYtoIMutation      },    // LESS_SUFFIX
    { L" IY",           { {MS_Noun,   MS_Adj},
                          {MS_Adj,    MS_Adv}   },    2,  eCheckForMissingE +
                                                          eCheckDoubledMutation   },    // Y_SUFFIX
    { L" AX d l IY",    { {MS_Verb,   MS_Adj},
                          {MS_Verb,   MS_Adv}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // EDLY_SUFFIX
    { L" l IY",         { {MS_Noun,   MS_Adj},
                          {MS_Adj,    MS_Adv}   },    2,  eCheckForMissingL },          // LY_XUFFIX
    { L" AX - b AX l",  { {MS_Verb,   MS_Adj},
                          {MS_Noun,   MS_Adj}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ABLE_SUFFIX
    { L" n IH s",       { {MS_Adj,    MS_Noun}  },    1,  eCheckYtoIMutation      },    // NESS_SUFFIX
    { L" IH z AX m",    { {MS_Adj,    MS_Noun},
                          {MS_Noun,   MS_Noun}  },    2,  eCheckForMissingE       },    // ISM_SUFFIX
    { L" AY z",         { {MS_Noun,   MS_Verb}, 
                          {MS_Adj,    MS_Verb}  },    2,  eCheckForMissingE       },    // IZE_SUFFIX
    { L" AY z",         { {MS_Noun,   MS_Verb},
                          {MS_Adj,    MS_Verb}  },    2,  eCheckForMissingE       },    // IZ_SUFFIX
    { L" h UH d",       { {MS_Noun,   MS_Noun}  },    1,  0 },                          // HOOD_SUFFIX
    { L" f AX l",       { {MS_Noun,   MS_Adj},
                          {MS_Verb,   MS_Adj}   },    2,  0 } ,                         // FUL_SUFFIX
    { L" l AY k",       { {MS_Noun,   MS_Adj}   },    1,  0 },                          // LIKE_SUFFIX
    { L" w AY z",       { {MS_Noun,   MS_Adj}   },    1,  eCheckYtoIMutation },                        // WISE_SUFFIX
    { L" IH SH",        { {MS_Noun,   MS_Adj}   },    1,  eCheckForMissingE +
                                                          eCheckDoubledMutation   },    // ISH_SUFFIX
    { L" AX - b l IY",  { {MS_Verb,   MS_Adv},
                          {MS_Noun,   MS_Adv}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ABLY_SUFFIX
    { L" SH IH 2 p",    { {MS_Noun,   MS_Noun}  },    1,  0 },                          // SHIP_SUFFIX
    { L" L IY",         { {MS_Adj,    MS_Adv}   },    1,  0 },                          // ICALLY_SUFFIX
    { L" S AX M",       { {MS_Noun,   MS_Adj}   },    1,  eCheckYtoIMutation      },    // SOME_SUFFIX
    { L" AX L IY",      { {MS_Noun,   MS_Adv}   },    1,  eCheckDoubledMutation +
                                                          eCheckForMissingY       },    // ILY_SUFFIX
    { L" IH z AX m",    { {MS_Adj,    MS_Noun},
                          {MS_Noun,   MS_Noun}  },    2,  eCheckForMissingE       },    // ICISM_SUFFIX
    { L" AY z",         { {MS_Noun,   MS_Verb}, 
                          {MS_Adj,    MS_Verb}  },    2,  eCheckForMissingE       },    // ICIZE_SUFFIX
};

/*** CSuffixList **************************************************************
* This typedef just makes the code a little easier to read.  A CSuffixList is
* used to keep track of each of the suffixes which has been stripped from a
* word, so that their pronunciations can be concatenated with that of the root.
*/
typedef CSPList<SUFFIXPRON_INFO*, SUFFIXPRON_INFO*> CSuffixList;

/*** CComAutoCriticalSection g_SuffixInfoTableCritSec *************************
* This critical section is used to make sure the SuffixInfoTable only gets
* initialized once.
*/
static CComAutoCriticalSection g_SuffixInfoTableCritSec;

/*** CSMorph ******************************************************************
* This is the definition of the CSMorph class.
*/
class CSMorph
{
public:

    /*=== PUBLIC METHODS =====*/
    CSMorph( ISpLexicon *pMasterLex=0, HRESULT *hr=0 );

    /*=== INTERFACE METHOD =====*/
    HRESULT DoSuffixMorph( const WCHAR *pwWord, WCHAR *pwRoot, LANGID LangID, DWORD dwFlags,
                           SPWORDPRONUNCIATIONLIST *pWordPronunciationList );

private:


    /*=== PRIVATE METHODS =====*/
    SUFFIX_TYPE MatchSuffix( WCHAR *TargWord, long *RootLen );
    HRESULT LexLookup( const WCHAR *pOrth, long length, DWORD dwFlags, 
                       SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT LTSLookup( const WCHAR *pOrth, long length,
                       SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT AccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT AccumulateSuffixes_LTS( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT DefaultAccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList );

    HRESULT CheckForMissingE( WCHAR *pOrth, long length, DWORD dwFlags,
                              SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckForMissingY( WCHAR *pOrth, long length, DWORD dwFlags,
                              SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT CheckForMissingL( WCHAR *pOrth, long length, DWORD dwFlags,
                              SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT CheckYtoIMutation( WCHAR *pOrth, long length, DWORD dwFlags, 
                               SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckDoubledMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                  SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckYtoIEMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckAbleMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                               SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT Phon_SorZ( WCHAR *pPronunciation, long length );
    HRESULT Phon_DorED( WCHAR *pPronunciation, long length ); 

    /*=== MEMBER DATA =====*/

    // Pointer to the Master Lexicon...
    ISpLexicon  *m_pMasterLex;
};

inline BOOL SearchPosSet( ENGPARTOFSPEECH Pos, const ENGPARTOFSPEECH *Set, ULONG Count )
{
    for( ULONG i = 0; i < Count; ++i )
    {
        if( Pos == Set[i] )
        {
            return true;
        }
    }
    return false;
}

#endif //--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\ms_entropicengine.cpp ===
// MS_EntropicEngine.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MS_EntropicEngineps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MS_EntropicEngine.h"

#include "MS_EntropicEngine_i.c"

#include "TTSEngine.h"
#ifdef USE_VOICEDATAOBJ
#include "voicedataobj.h"
#endif
#include "spttsengui.h"

CSpUnicodeSupport g_Unicode;
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY( CLSID_MSE_TTSEngine, MSE_TTSEngine    )
    OBJECT_ENTRY( CLSID_SpTtsEngUI,    SpTtsEngUI    )
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MS_ENTROPICENGINELib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        CleanupAbbrevTables();
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\sentitemmemory.h ===
/******************************************************************************
* SentItemMemory.h *
*------------------*
*  This file defines and implements the CSentItemMemory class.  This class was
*  written to simplify memory management in the sentence enumerator.  The 
*  const SPVSTATE member of the SPVSENTITEM struct needs to be modified in the
*  sentence enumerator, both during normalization and during lexicon lookup.  
*  It was thus desireable to be able to free all of the memory which was 
*  dynamically created in the sentence enumerator at once, without having to,
*  for example, figure out which pronunciations were const (specified in the 
*  XML state) and which were dynamically created.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 12/6/99
*  All Rights Reserved
*
*********************************************************************** AKH ***/

struct MemoryChunk
{
    BYTE* pMemory;
    MemoryChunk* pNext;
};

class CSentItemMemory
{
public:

    CSentItemMemory( )
    {
        m_pHead = NULL;
        m_pCurr = NULL;
    }
    
    ~CSentItemMemory()
    {
        MemoryChunk *pIterator = m_pHead, *pTemp = 0;
        while (pIterator)
        {
            pTemp = pIterator->pNext;
            delete [] pIterator->pMemory;
            delete pIterator;
            pIterator = pTemp;
        }
    }

    void* GetMemory( ULONG ulBytes, HRESULT *hr )
    {
        void *Memory = 0;
        if (!m_pHead)
        {
            m_pHead = new MemoryChunk;
            if (m_pHead)
            {
                m_pHead->pNext = NULL;
                m_pHead->pMemory = new BYTE[ulBytes];
                if (m_pHead->pMemory)
                {
                    m_pCurr = m_pHead;
                    Memory = (void*) m_pHead->pMemory;
                }
                else
                {
                    *hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                *hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            m_pCurr->pNext = new MemoryChunk;
            if (m_pCurr->pNext)
            {
                m_pCurr = m_pCurr->pNext;
                m_pCurr->pNext = NULL;
                m_pCurr->pMemory = new BYTE[ulBytes];
                if (m_pCurr->pMemory)
                {
                    Memory = (void*) m_pCurr->pMemory;
                }
                else
                {
                    *hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                *hr = E_OUTOFMEMORY;
            }
        }
        return Memory;            
    }


private:

    MemoryChunk* m_pHead;
    MemoryChunk* m_pCurr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\normdata.cpp ===
/******************************************************************************
* NormData.cpp *
*--------------*
*  This file stores the const data used in normalization
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 05/02/2000
*  All Rights Reserved
*
****************************************************************** AARONHAL ***/

#include "stdafx.h"
#include "stdsentenum.h"

//--- Constants used to map incoming ANSI characters to Ascii ones...
const char g_pFlagCharacter = 0x00;
const unsigned char g_AnsiToAscii[] = 
{
    /*** Control characters - map to whitespace ***/
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20,
    /*** ASCII displayables ***/
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,
    /*** Control character ***/
    0x20,
    /*** Euro symbol ***/
    0x80,
    /*** Control character ***/
    0x20,
    /*** Extended ASCII values ***/
    0x27,     // low single quote - map to single quote
    0x20,     // f-like character - map to space
    0x22,     // low double quote - map to double quote
    0x2C,     // elipsis - map to comma
    0x20,     // cross - map to space
    0x20,     // double cross - map to space
    0x5E,     // caret like accent - map to caret
    0x89,     // strange percent like sign
    0x53,     // S-hat - map to S
    0x27,     // left angle bracket like thing - map to single quote
    0x20,     // weird OE character - map to space
    0x20,     // control characters - map to space
    0x20,
    0x20,
    0x20,
    0x27,     // left single quote - map to single quote
    0x27,     // right single quote - map to single quote
    0x22,     // left double quote - map to double quote
    0x22,     // right double quote - map to double quote
    0x20,     // bullet - map to space
    0x2D,     // long hyphen - map to hyphen
    0x2D,     // even longer hyphen - map to hyphen
    0x7E,     // tilde-like thing - map to tilde
    0x99,     // TM
    0x73,     // s-hat - map to s
    0x27,     // right angle bracket like thing - map to single quote
    0x20,     // weird oe like character - map to space
    0x20,     // control character - map to space
    0x20,     // control character - map to space
    0x59,     // Y with umlaut like accent - map to Y
    0x20,     // space? - map to space
    0x20,     // upside-down exclamation point - map to space
    0xA2,     // cents symbol
    0xA3,     // pounds symbol
    0x20,     // generic currency symbol - map to space
    0xA5,     // yen symbol
    0x7C,     // broken bar - map to bar
    0x20,     // strange symbol - map to space 
    0x20,     // umlaut - map to space
    0xA9,     // copyright symbol
    0x20,     // strange a character - map to space
    0x22,     // strange <<-like character - map to double quote
    0x20,     // strange line-like character - map to space
    0x2D,     // hyphen-like character - map to hyphen
    0xAE,     // registered symbol
    0x20,     // high line - map to space
    0xB0,     // degree sign
    0xB1,     // plus-minus sign
    0xB2,     // superscript 2
    0xB3,     // superscript 3
    0xB4,     // single prime
    0x20,     // greek character - map to space
    0x20,     // paragraph symbol - map to space
    0x20,     // mid-height dot - map to space
    0x20,     // cedilla - map to space
    0xB9,     // superscript one
    0x20,     // circle with line - map to space
    0x22,     // strange >>-like character - map to double quote
    0xBC,     // vulgar 1/4
    0xBD,     // vulgar 1/2
    0xBE,     // vulgar 3/4
    0x20,     // upside-down question mark - map to space
    0x41,     // Accented uppercase As - map to A
    0x41,
    0x41,
    0x41,
    0x41,
    0x41,
    0x41,
    0x43,     // C with cedilla - map to C
    0x45,     // Accented uppercase Es - map to E
    0x45,
    0x45,
    0x45,
    0x49,     // Accented uppercase Is - map to I
    0x49,
    0x49,
    0x49,
    0x20,     // strange character - map to space
    0x4E,     // Accented uppercase N - map to N
    0x4F,     // Accented uppercase Os - map to O
    0x4F,
    0x4F,
    0x4F,
    0x4F,
    0x20,     // strange character - map to space
    0x4F,     // another O? - map to O
    0x55,     // Accented uppercase Us - map to U
    0x55,
    0x55,
    0x55,
    0x59,     // Accented uppercase Y - map to Y
    0x20,     // strange character - map to space
    0xDF,     // Beta
    0x61,     // Accented lowercase as - map to a
    0x61,
    0x61,
    0x61,
    0x61,
    0x61,
    0x61,
    0x63,     // c with cedilla - map to c
    0x65,     // Accented lowercase es - map to e
    0x65,
    0x65,
    0x65,
    0x69,    // Accented lowercase is - map to i
    0x69,
    0x69,
    0x69,
    0x75,    // eth - map to t
    0x6E,    // Accented lowercase n - map to n
    0x6F,    // Accented lowercase os - map to o
    0x6F,
    0x6F,
    0x6F,
    0x6F,
    0xF7,     // division symbol
    0x6F,     // another o? - map to o
    0x76,    // Accented lowercase us - map to u
    0x76,
    0x76,
    0x76,
    0x79,     // accented lowercase y - map to y
    0x20,     // strange character - map to space
    0x79,     // accented lowercase y - map to y
};

//--- Constants used by number normalization
const SPLSTR g_O            = DEF_SPLSTR( "o" );
const SPLSTR g_negative     = DEF_SPLSTR( "negative" );
const SPLSTR g_decimalpoint = DEF_SPLSTR( "point" );
const SPLSTR g_a            = DEF_SPLSTR( "a" );
const SPLSTR g_of           = DEF_SPLSTR( "of" );
const SPLSTR g_percent      = DEF_SPLSTR( "percent" );
const SPLSTR g_degree       = DEF_SPLSTR( "degree" );
const SPLSTR g_degrees      = DEF_SPLSTR( "degrees" );
const SPLSTR g_squared      = DEF_SPLSTR( "squared" );
const SPLSTR g_cubed        = DEF_SPLSTR( "cubed" );
const SPLSTR g_to           = DEF_SPLSTR( "to" );
const SPLSTR g_dash         = DEF_SPLSTR( "dash" );

const SPLSTR g_ones[] = 
{   
    DEF_SPLSTR( "zero"  ), 
    DEF_SPLSTR( "one"   ),
    DEF_SPLSTR( "two"   ), 
    DEF_SPLSTR( "three" ), 
    DEF_SPLSTR( "four"  ), 
    DEF_SPLSTR( "five"  ), 
    DEF_SPLSTR( "six"   ), 
    DEF_SPLSTR( "seven" ), 
    DEF_SPLSTR( "eight" ), 
    DEF_SPLSTR( "nine"  )
};

const SPLSTR g_tens[]  = 
{
    DEF_SPLSTR( "zero"    ),
    DEF_SPLSTR( "ten"     ), 
    DEF_SPLSTR( "twenty"  ), 
    DEF_SPLSTR( "thirty"  ), 
    DEF_SPLSTR( "forty"   ), 
    DEF_SPLSTR( "fifty"   ), 
    DEF_SPLSTR( "sixty"   ), 
    DEF_SPLSTR( "seventy" ), 
    DEF_SPLSTR( "eighty"  ), 
    DEF_SPLSTR( "ninety"  )
};

const SPLSTR g_teens[]  = 
{
    DEF_SPLSTR( "ten"       ), 
    DEF_SPLSTR( "eleven"    ), 
    DEF_SPLSTR( "twelve"    ), 
    DEF_SPLSTR( "thirteen"  ), 
    DEF_SPLSTR( "fourteen"  ), 
    DEF_SPLSTR( "fifteen"   ), 
    DEF_SPLSTR( "sixteen"   ), 
    DEF_SPLSTR( "seventeen" ), 
    DEF_SPLSTR( "eighteen"  ), 
    DEF_SPLSTR( "nineteen"  )
};

const SPLSTR g_onesOrdinal[]  = 
{
    DEF_SPLSTR( "zeroth"  ), 
    DEF_SPLSTR( "first"   ), 
    DEF_SPLSTR( "second"  ), 
    DEF_SPLSTR( "third"   ), 
    DEF_SPLSTR( "fourth"  ), 
    DEF_SPLSTR( "fifth"   ), 
    DEF_SPLSTR( "sixth"   ), 
    DEF_SPLSTR( "seventh" ), 
    DEF_SPLSTR( "eighth"  ), 
    DEF_SPLSTR( "ninth"   )
}; 

const SPLSTR g_tensOrdinal[]  = 
{
    DEF_SPLSTR( ""           ), 
    DEF_SPLSTR( "tenth"      ), 
    DEF_SPLSTR( "twentieth"  ), 
    DEF_SPLSTR( "thirtieth"  ), 
    DEF_SPLSTR( "fortieth"   ), 
    DEF_SPLSTR( "fiftieth"   ), 
    DEF_SPLSTR( "sixtieth"   ), 
    DEF_SPLSTR( "seventieth" ), 
    DEF_SPLSTR( "eightieth"  ), 
    DEF_SPLSTR( "ninetieth"  )
}; 

const SPLSTR g_teensOrdinal[]  =
{
    DEF_SPLSTR( "tenth"       ), 
    DEF_SPLSTR( "eleventh"    ), 
    DEF_SPLSTR( "twelfth"     ), 
    DEF_SPLSTR( "thirteenth"  ), 
    DEF_SPLSTR( "fourteenth"  ), 
    DEF_SPLSTR( "fifteenth"   ), 
    DEF_SPLSTR( "sixteenth"   ), 
    DEF_SPLSTR( "seventeenth" ),
    DEF_SPLSTR( "eighteenth"  ), 
    DEF_SPLSTR( "nineteenth"  )
};

const SPLSTR g_quantifiers[]  =
{
    DEF_SPLSTR( "hundred"  ), 
    DEF_SPLSTR( "thousand" ), 
    DEF_SPLSTR( "million"  ), 
    DEF_SPLSTR( "billion"  ), 
    DEF_SPLSTR( "trillion" ),
    DEF_SPLSTR( "quadrillion" )
};

const SPLSTR g_quantifiersOrdinal[]  =
{
    DEF_SPLSTR( "hundredth"  ), 
    DEF_SPLSTR( "thousandth" ), 
    DEF_SPLSTR( "millionth"  ), 
    DEF_SPLSTR( "billionth"  ), 
    DEF_SPLSTR( "trillionth" ),
    DEF_SPLSTR( "quadrillionth" )
};

//--- Constants used by currency normalization

WCHAR g_Euro[2] = { 0x0080, 0x0000 };

const CurrencySign g_CurrencySigns[] =
{
    { DEF_SPLSTR( "$" ),        DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "pounds" ),         DEF_SPLSTR( "pence" )       },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "yen" ),            DEF_SPLSTR( "sen" )         },
    { DEF_SPLSTR( "EUR" ),      DEF_SPLSTR( "euros" ),          DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "US$" ),      DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { { &g_Euro[0], 1 },        DEF_SPLSTR( "euros" ),          DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "euros" ),          DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "DM" ),       DEF_SPLSTR( "deutschemarks" ),  DEF_SPLSTR( "pfennigs" )    },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "cents" ),          DEF_SPLSTR( "" )            },
    { DEF_SPLSTR( "USD" ),      DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "dol." ),     DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "schil." ),   DEF_SPLSTR( "schillings" ),     DEF_SPLSTR( "" )            },
    { DEF_SPLSTR( "dol" ),      DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "schil" ),    DEF_SPLSTR( "schillings" ),     DEF_SPLSTR( "" )            }
};

const SPLSTR g_SingularPrimaryCurrencySigns[] =
{   
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "pound" ),
    DEF_SPLSTR( "yen" ),
    DEF_SPLSTR( "euro" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "euro" ),
    DEF_SPLSTR( "euro" ),
    DEF_SPLSTR( "deutschemark" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "schilling" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "schilling" )
};

const SPLSTR g_SingularSecondaryCurrencySigns[] =
{
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "penny" ),
    DEF_SPLSTR( "sen" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "pfennig" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "" ),
};

//--- Constants used by date normalization

const WCHAR g_DateDelimiters[] = { '/', '-', '.' };

const SPLSTR g_months[]  =
{
    DEF_SPLSTR( "January"   ), 
    DEF_SPLSTR( "February"  ), 
    DEF_SPLSTR( "March"     ), 
    DEF_SPLSTR( "April"     ), 
    DEF_SPLSTR( "May"       ),
    DEF_SPLSTR( "June"      ),
    DEF_SPLSTR( "July"      ),
    DEF_SPLSTR( "August"    ),
    DEF_SPLSTR( "September" ),
    DEF_SPLSTR( "October"   ),
    DEF_SPLSTR( "November"  ),
    DEF_SPLSTR( "December"  )
};

const SPLSTR g_monthAbbreviations[] =
{
    DEF_SPLSTR( "jan" ),
    DEF_SPLSTR( "feb" ),
    DEF_SPLSTR( "mar" ),
    DEF_SPLSTR( "apr" ),
    DEF_SPLSTR( "may" ),
    DEF_SPLSTR( "jun" ),
    DEF_SPLSTR( "jul" ),
    DEF_SPLSTR( "aug" ),
    DEF_SPLSTR( "sept" ),
    DEF_SPLSTR( "sep" ),
    DEF_SPLSTR( "oct" ),
    DEF_SPLSTR( "nov" ),
    DEF_SPLSTR( "dec" )
};

const SPLSTR g_days[]    =
{
    DEF_SPLSTR( "Monday"    ),
    DEF_SPLSTR( "Tuesday"   ),
    DEF_SPLSTR( "Wednesday" ),
    DEF_SPLSTR( "Thursday"  ),
    DEF_SPLSTR( "Friday"    ),
    DEF_SPLSTR( "Saturday"  ),
    DEF_SPLSTR( "Sunday"    )
};

const SPLSTR g_dayAbbreviations[] =
{
    DEF_SPLSTR( "Mon"   ),
    DEF_SPLSTR( "Tues"   ),
    DEF_SPLSTR( "Tue"  ),
    DEF_SPLSTR( "Wed"   ),
    DEF_SPLSTR( "Thurs"  ),
    DEF_SPLSTR( "Thur" ),
    DEF_SPLSTR( "Thu" ),
    DEF_SPLSTR( "Fri"   ),
    DEF_SPLSTR( "Sat"   ),
    DEF_SPLSTR( "Sun"   ),
};

//--- Constants used by phone number normalization

const SPLSTR g_Area     = DEF_SPLSTR( "area" );
const SPLSTR g_Country  = DEF_SPLSTR( "country" );
const SPLSTR g_Code     = DEF_SPLSTR( "code" );

//--- Constants used by fraction normalization

const SPLSTR g_Half         = DEF_SPLSTR( "half" );
const SPLSTR g_Tenths       = DEF_SPLSTR( "tenths" );
const SPLSTR g_Hundredths   = DEF_SPLSTR( "hundredths" );
const SPLSTR g_Sixteenths   = DEF_SPLSTR( "sixteenths" );
const SPLSTR g_Over         = DEF_SPLSTR( "over" );

const SPLSTR g_PluralDenominators[]  = 
{
    DEF_SPLSTR( "" ), 
    DEF_SPLSTR( "" ), 
    DEF_SPLSTR( "halves"   ), 
    DEF_SPLSTR( "thirds"   ), 
    DEF_SPLSTR( "fourths"  ), 
    DEF_SPLSTR( "fifths"   ), 
    DEF_SPLSTR( "sixths"   ), 
    DEF_SPLSTR( "sevenths" ), 
    DEF_SPLSTR( "eighths"  ), 
    DEF_SPLSTR( "ninths"   )
}; 

//--- Constants used by time normalization

const SPLSTR g_A        = DEF_SPLSTR( "a" );
const SPLSTR g_M        = DEF_SPLSTR( "m" );
const SPLSTR g_P        = DEF_SPLSTR( "p" );
const SPLSTR g_OClock   = DEF_SPLSTR( "o'clock" );
const SPLSTR g_hundred  = DEF_SPLSTR( "hundred" );
const SPLSTR g_hours    = DEF_SPLSTR( "hours" );
const SPLSTR g_hour     = DEF_SPLSTR( "hour" );
const SPLSTR g_minutes  = DEF_SPLSTR( "minutes" );
const SPLSTR g_minute   = DEF_SPLSTR( "minute" );
const SPLSTR g_seconds  = DEF_SPLSTR( "seconds" );
const SPLSTR g_second   = DEF_SPLSTR( "second" );

//--- Default normalization table

const SPLSTR g_ANSICharacterProns[] =
{
    DEF_SPLSTR( "" ),   // NULL
    DEF_SPLSTR( "" ),   // Start of heading
    DEF_SPLSTR( "" ),   // Start of text
    DEF_SPLSTR( "" ),   // Break/End of text
    DEF_SPLSTR( "" ),   // End of transmission
    DEF_SPLSTR( "" ),   // Enquiry
    DEF_SPLSTR( "" ),   // Positive acknowledgement
    DEF_SPLSTR( "" ),   // Bell
    DEF_SPLSTR( "" ),   // Backspace
    DEF_SPLSTR( "" ),   // Horizontal tab
    DEF_SPLSTR( "" ),   // Line feed
    DEF_SPLSTR( "" ),   // Vertical tab
    DEF_SPLSTR( "" ),   // Form feed
    DEF_SPLSTR( "" ),   // Carriage return
    DEF_SPLSTR( "" ),   // Shift out
    DEF_SPLSTR( "" ),   // Shift in/XON (resume output)
    DEF_SPLSTR( "" ),   // Data link escape
    DEF_SPLSTR( "" ),   // Device control character 1
    DEF_SPLSTR( "" ),   // Device control character 2
    DEF_SPLSTR( "" ),   // Device control character 3
    DEF_SPLSTR( "" ),   // Device control character 4
    DEF_SPLSTR( "" ),   // Negative acknowledgement
    DEF_SPLSTR( "" ),   // Synchronous idle
    DEF_SPLSTR( "" ),   // End of transmission block
    DEF_SPLSTR( "" ),   // Cancel
    DEF_SPLSTR( "" ),   // End of medium
    DEF_SPLSTR( "" ),   // substitute/end of file
    DEF_SPLSTR( "" ),   // Escape
    DEF_SPLSTR( "" ),   // File separator
    DEF_SPLSTR( "" ),   // Group separator
    DEF_SPLSTR( "" ),   // Record separator
    DEF_SPLSTR( "" ),   // Unit separator
    DEF_SPLSTR( "" ),   // Space
    DEF_SPLSTR( "exclamation point" ),   
    DEF_SPLSTR( "double quote" ),
    DEF_SPLSTR( "number sign" ),
    DEF_SPLSTR( "dollars" ),
    DEF_SPLSTR( "percent" ),
    DEF_SPLSTR( "and" ),
    DEF_SPLSTR( "single quote" ),
    DEF_SPLSTR( "left parenthesis" ),
    DEF_SPLSTR( "right parenthesis" ),
    DEF_SPLSTR( "asterisk" ),
    DEF_SPLSTR( "plus" ),
    DEF_SPLSTR( "comma" ),
    DEF_SPLSTR( "hyphen" ),             
    DEF_SPLSTR( "dot" ),          
    DEF_SPLSTR( "slash" ),              
    DEF_SPLSTR( "zero" ),
    DEF_SPLSTR( "one" ),
    DEF_SPLSTR( "two" ),
    DEF_SPLSTR( "three" ),
    DEF_SPLSTR( "four" ),
    DEF_SPLSTR( "five" ),
    DEF_SPLSTR( "six" ),
    DEF_SPLSTR( "seven" ),
    DEF_SPLSTR( "eight" ),
    DEF_SPLSTR( "nine" ),
    DEF_SPLSTR( "colon" ),
    DEF_SPLSTR( "semicolon" ),
    DEF_SPLSTR( "less than" ),
    DEF_SPLSTR( "equals" ),
    DEF_SPLSTR( "greater than" ),
    DEF_SPLSTR( "question mark" ),
    DEF_SPLSTR( "at" ),
    DEF_SPLSTR( "a" ),
    DEF_SPLSTR( "b" ),
    DEF_SPLSTR( "c" ),
    DEF_SPLSTR( "d" ),
    DEF_SPLSTR( "e" ),
    DEF_SPLSTR( "f" ),
    DEF_SPLSTR( "g" ),
    DEF_SPLSTR( "h" ),
    DEF_SPLSTR( "i" ),
    DEF_SPLSTR( "j" ),
    DEF_SPLSTR( "k" ),
    DEF_SPLSTR( "l" ),
    DEF_SPLSTR( "m" ),
    DEF_SPLSTR( "n" ),
    DEF_SPLSTR( "o" ),
    DEF_SPLSTR( "p" ),
    DEF_SPLSTR( "q" ),
    DEF_SPLSTR( "r" ),
    DEF_SPLSTR( "s" ),
    DEF_SPLSTR( "t" ),
    DEF_SPLSTR( "u" ),
    DEF_SPLSTR( "v" ),
    DEF_SPLSTR( "w" ),
    DEF_SPLSTR( "x" ),
    DEF_SPLSTR( "y" ),
    DEF_SPLSTR( "z" ),
    DEF_SPLSTR( "left square bracket" ),
    DEF_SPLSTR( "backslash" ),
    DEF_SPLSTR( "right square bracket" ),
    DEF_SPLSTR( "circumflex accent" ),
    DEF_SPLSTR( "underscore" ),
    DEF_SPLSTR( "grave accent" ),
    DEF_SPLSTR( "a" ),
    DEF_SPLSTR( "b" ),
    DEF_SPLSTR( "c" ),
    DEF_SPLSTR( "d" ),
    DEF_SPLSTR( "e" ),
    DEF_SPLSTR( "f" ),
    DEF_SPLSTR( "g" ),
    DEF_SPLSTR( "h" ),
    DEF_SPLSTR( "i" ),
    DEF_SPLSTR( "j" ),
    DEF_SPLSTR( "k" ),
    DEF_SPLSTR( "l" ),
    DEF_SPLSTR( "m" ),
    DEF_SPLSTR( "n" ),
    DEF_SPLSTR( "o" ),
    DEF_SPLSTR( "p" ),
    DEF_SPLSTR( "q" ),
    DEF_SPLSTR( "r" ),
    DEF_SPLSTR( "s" ),
    DEF_SPLSTR( "t" ),
    DEF_SPLSTR( "u" ),
    DEF_SPLSTR( "v" ),
    DEF_SPLSTR( "w" ),
    DEF_SPLSTR( "x" ),
    DEF_SPLSTR( "y" ),
    DEF_SPLSTR( "z" ),
    DEF_SPLSTR( "left curly bracket" ),
    DEF_SPLSTR( "vertical line" ),
    DEF_SPLSTR( "right curly bracket" ),
    DEF_SPLSTR( "tilde" ),
    DEF_SPLSTR( "" ),                       // DELETE
    DEF_SPLSTR( "euros" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to comma
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to caret
    DEF_SPLSTR( "per thousand" ),
    DEF_SPLSTR( "" ),                       // maps to S
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // Control characters - map to space
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to hyphen
    DEF_SPLSTR( "" ),                       // maps to hyphen
    DEF_SPLSTR( "" ),                       // maps to tilde
    DEF_SPLSTR( "trademark" ),
    DEF_SPLSTR( "" ),                       // maps to s
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to Y
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "cents" ),
    DEF_SPLSTR( "pounds" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "yen" ),
    DEF_SPLSTR( "" ),                       // maps to |
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "copyright" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to hyphen
    DEF_SPLSTR( "registered trademark" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "degrees" ),
    DEF_SPLSTR( "plus minus" ),
    DEF_SPLSTR( "superscript two" ),
    DEF_SPLSTR( "superscript three" ),
    DEF_SPLSTR( "prime" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "times" ),                  // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "superscript one" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "one fourth" ),
    DEF_SPLSTR( "one half" ),
    DEF_SPLSTR( "three fourths" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to C
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to N
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to Y
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "beta" ),
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to c
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to t
    DEF_SPLSTR( "" ),                       // maps to n
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "divided by" ),
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to y
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to y
};

//--- Constants used in decade normalization

const SPLSTR g_Decades[] =
{
    DEF_SPLSTR( "thousands" ),   // this will be handled as a special case - "two thousands"
    DEF_SPLSTR( "tens"      ),
    DEF_SPLSTR( "twenties"  ),
    DEF_SPLSTR( "thirties"  ),
    DEF_SPLSTR( "forties"   ),
    DEF_SPLSTR( "fifties"   ),
    DEF_SPLSTR( "sixties"   ),
    DEF_SPLSTR( "seventies" ),
    DEF_SPLSTR( "eighties"  ),
    DEF_SPLSTR( "nineties"  ),
};

const SPLSTR g_Zeroes = DEF_SPLSTR( "zeroes" );
const SPLSTR g_Hundreds = DEF_SPLSTR( "hundreds" );

//--- Miscellaneous constants

const StateStruct g_StateAbbreviations[] =
{
    { DEF_SPLSTR( "AA" ), DEF_SPLSTR( "Armed Forces" ) },
    { DEF_SPLSTR( "AE" ), DEF_SPLSTR( "Armed Forces" ) },
    { DEF_SPLSTR( "AK" ), DEF_SPLSTR( "Alaska" ) },
    { DEF_SPLSTR( "AL" ), DEF_SPLSTR( "Alabama" )  },
    { DEF_SPLSTR( "AP" ), DEF_SPLSTR( "Armed Forces" ) },
    { DEF_SPLSTR( "AR" ), DEF_SPLSTR( "Arkansas" ) },
    { DEF_SPLSTR( "AS" ), DEF_SPLSTR( "American Samoa" ) },
    { DEF_SPLSTR( "AZ" ), DEF_SPLSTR( "Arizona" )  },
    { DEF_SPLSTR( "CA" ), DEF_SPLSTR( "California" ) },
    { DEF_SPLSTR( "CO" ), DEF_SPLSTR( "Colorado" ) },
    { DEF_SPLSTR( "CT" ), DEF_SPLSTR( "Connecticut" ) },
    { DEF_SPLSTR( "DC" ), DEF_SPLSTR( "D C" ) },
    { DEF_SPLSTR( "DE" ), DEF_SPLSTR( "Deleware" ) },
    { DEF_SPLSTR( "FL" ), DEF_SPLSTR( "Florida" ) },
    { DEF_SPLSTR( "FM" ), DEF_SPLSTR( "Federated States Of Micronesia" ) },
    { DEF_SPLSTR( "GA" ), DEF_SPLSTR( "Georgia" ) },
    { DEF_SPLSTR( "GU" ), DEF_SPLSTR( "Guam" ) },
    { DEF_SPLSTR( "HI" ), DEF_SPLSTR( "Hawaii" ) },
    { DEF_SPLSTR( "IA" ), DEF_SPLSTR( "Iowa" ) },
    { DEF_SPLSTR( "ID" ), DEF_SPLSTR( "Idaho" ) },
    { DEF_SPLSTR( "IL" ), DEF_SPLSTR( "Illinois" ) },
    { DEF_SPLSTR( "IN" ), DEF_SPLSTR( "Indiana" ) },
    { DEF_SPLSTR( "KS" ), DEF_SPLSTR( "Kansas" ) },
    { DEF_SPLSTR( "KY" ), DEF_SPLSTR( "Kentucky" ) },
    { DEF_SPLSTR( "LA" ), DEF_SPLSTR( "Louisiana" ) },
    { DEF_SPLSTR( "MA" ), DEF_SPLSTR( "Massachusetts" ) },
    { DEF_SPLSTR( "MD" ), DEF_SPLSTR( "Maryland" ) },
    { DEF_SPLSTR( "ME" ), DEF_SPLSTR( "Maine" ) },
    { DEF_SPLSTR( "MH" ), DEF_SPLSTR( "Marshall Islands" ) },
    { DEF_SPLSTR( "MI" ), DEF_SPLSTR( "Michigan" ) },
    { DEF_SPLSTR( "MN" ), DEF_SPLSTR( "Minnesota" ) },
    { DEF_SPLSTR( "MO" ), DEF_SPLSTR( "Missouri" ) },
    { DEF_SPLSTR( "MP" ), DEF_SPLSTR( "Northern Mariana Islands" ) },
    { DEF_SPLSTR( "MS" ), DEF_SPLSTR( "Mississippi" ) },
    { DEF_SPLSTR( "MT" ), DEF_SPLSTR( "Montana" ) },
    { DEF_SPLSTR( "NC" ), DEF_SPLSTR( "North Carolina" ) },
    { DEF_SPLSTR( "ND" ), DEF_SPLSTR( "North Dakota" ) },
    { DEF_SPLSTR( "NE" ), DEF_SPLSTR( "Nebraska" ) },
    { DEF_SPLSTR( "NH" ), DEF_SPLSTR( "New Hampshire" ) },
    { DEF_SPLSTR( "NJ" ), DEF_SPLSTR( "New Jersey" ) },
    { DEF_SPLSTR( "NM" ), DEF_SPLSTR( "New Mexico" ) },
    { DEF_SPLSTR( "NV" ), DEF_SPLSTR( "Nevada" ) },
    { DEF_SPLSTR( "NY" ), DEF_SPLSTR( "New York" ) },
    { DEF_SPLSTR( "OH" ), DEF_SPLSTR( "Ohio" ) },
    { DEF_SPLSTR( "OK" ), DEF_SPLSTR( "Oklahoma" ) },
    { DEF_SPLSTR( "OR" ), DEF_SPLSTR( "Oregon" ) },
    { DEF_SPLSTR( "PA" ), DEF_SPLSTR( "Pennsylvania" ) },
    { DEF_SPLSTR( "PR" ), DEF_SPLSTR( "Puerto Rico" ) },
    { DEF_SPLSTR( "PW" ), DEF_SPLSTR( "Palau" ) },
    { DEF_SPLSTR( "RI" ), DEF_SPLSTR( "Rhode Island" ) },
    { DEF_SPLSTR( "SC" ), DEF_SPLSTR( "South Carolina" ) },
    { DEF_SPLSTR( "SD" ), DEF_SPLSTR( "South Dakota" ) },
    { DEF_SPLSTR( "TN" ), DEF_SPLSTR( "Tennessee" ) },
    { DEF_SPLSTR( "TX" ), DEF_SPLSTR( "Texas" ) },
    { DEF_SPLSTR( "UT" ), DEF_SPLSTR( "Utah" ) },
    { DEF_SPLSTR( "VA" ), DEF_SPLSTR( "Virginia" ) },
    { DEF_SPLSTR( "VI" ), DEF_SPLSTR( "Virgin Islands" ) },
    { DEF_SPLSTR( "VT" ), DEF_SPLSTR( "Vermont" ) },
    { DEF_SPLSTR( "WA" ), DEF_SPLSTR( "Washington" ) },
    { DEF_SPLSTR( "WI" ), DEF_SPLSTR( "Wisconsin" ) },
    { DEF_SPLSTR( "WV" ), DEF_SPLSTR( "West Virginia" ) },
    { DEF_SPLSTR( "WY" ), DEF_SPLSTR( "Wyoming" ) },
};

const SPVSTATE g_DefaultXMLState = 
{
    SPVA_Speak,     // SPVACTIONS
    0,              // LangID
    0,              // wReserved
    0,              // EmphAdj
    0,              // RateAdj
    100,            // Volume
    { 0, 0 },       // PitchAdj
    0,              // SilenceMSecs
    0,              // pPhoneIds
    SPPS_Unknown,   // POS
    { 0, 0, 0 }     // Context
};

const SPLSTR g_And = DEF_SPLSTR( "and" );

extern const SPLSTR g_comma = DEF_SPLSTR( "," );
extern const SPLSTR g_period = DEF_SPLSTR( "." );
extern const SPLSTR g_periodString = DEF_SPLSTR( "period" );
extern const SPLSTR g_slash = DEF_SPLSTR( "or" );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\normdata.h ===
/******************************************************************************
* NormData.h *
*------------*
*   This file contains lists of data used in the normalization process.
*------------------------------------------------------------------------------
*   Copyright (C) 1999 Microsoft Corporation         Date: 08/11/99
*   All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef NormData_h
#define NormData_h

//  Abbrev.txt -- list of common abbreviations.  Words following the
//  abbreviations in this list will not start a sentence unless they are in
//  the list of common first words (frstwrds.txt)
//  The code handles all abbreviations containing single upper-case characters
//  followed by a period, such as A.A. and B.F.A., so they don't need to be
//  in the list.
//  Some abbreviations are confusable with actual words.  Where this may occur
//  regularly (with no., for example) a special case may need to be added in
//  the sentence separator code.
static const SPLSTR g_CommonAbbrev[] =
{
// L"A.A." ),
// L"A.A.S." ),
// L"A.B." ),
// L"A.B.A." ),
// L"A.C.T." ),
// L"A.D." ),
// L"A.F." ),         // "A.F. of L." ),
// L"A.G." ),
// L"A.H." ),
// L"A.M." ),
// L"A.P." ),
// L"A.R." ),
// L"A.S." ),
// L"A.S.P.C.A." ),
// L"A.S.S.R." ),
// L"A.U." ),
// L"A.U.C." ),
// L"A.h." ),
DEF_SPLSTR( "Adj." ),
DEF_SPLSTR( "Adjt." ),
DEF_SPLSTR( "Afg." ),
DEF_SPLSTR( "Afr." ),
DEF_SPLSTR( "Ala." ),
DEF_SPLSTR( "Alas." ),
DEF_SPLSTR( "Alb." ),
DEF_SPLSTR( "Ald." ),
DEF_SPLSTR( "Alg." ),
DEF_SPLSTR( "Alta." ),
DEF_SPLSTR( "Am." ),
DEF_SPLSTR( "Amer." ),
DEF_SPLSTR( "And." ),         // Andorra
DEF_SPLSTR( "Ang." ),
DEF_SPLSTR( "Angl." ),
DEF_SPLSTR( "Ant." ),
DEF_SPLSTR( "Apoc." ),
DEF_SPLSTR( "Apr." ),
DEF_SPLSTR( "Ar." ),
DEF_SPLSTR( "Arch." ),
DEF_SPLSTR( "Archbp." ),
DEF_SPLSTR( "Arg." ),
DEF_SPLSTR( "Ariz." ),
DEF_SPLSTR( "Ark." ),
DEF_SPLSTR( "Arm." ),
DEF_SPLSTR( "As." ),
DEF_SPLSTR( "Atl." ),
DEF_SPLSTR( "Att." ),
// "Att. Gen." ),
// "Atty." ),         // already in titles.txt
// "Atty. Gen." ),
DEF_SPLSTR( "Aug." ),
DEF_SPLSTR( "Aus." ),
DEF_SPLSTR( "Aust." ),
DEF_SPLSTR( "Austl." ),
DEF_SPLSTR( "Av." ),
DEF_SPLSTR( "Ave." ),                                 // PaulCa 4/15/99 (Bug 108)
// "B.A." ),
// "B.A.E." ),
DEF_SPLSTR( "B.A.Ed." ),
// "B.A.M." ),
// "B.A.S." ),
DEF_SPLSTR( "B.A.Sc." ),
// "B.A.T." ),
DEF_SPLSTR( "B.Ae.E." ),
DEF_SPLSTR( "B.Arch." ),
// "B.B.A." ),
// "B.C." ),
// "B.C.B.G." ),
// "B.C.E." ),
// "B.C.L." ),
DEF_SPLSTR( "B.Ch.E." ),
// "B.D." ),
// "B.D.S." ),
// "B.E." ),
DEF_SPLSTR( "B.Ed." ),
DEF_SPLSTR( "B.Eng." ),
DEF_SPLSTR( "B.Eng.Sci." ),
DEF_SPLSTR( "B.Engr." ),
// "B.F.A." ),
// "B.J." ),
// "B.L." ),
// "B.L.A." ),
// "B.L.S." ),
DEF_SPLSTR( "B.Lit." ),
DEF_SPLSTR( "B.Litt." ),
// "B.M." ),
// "B.M.E." ),
// "B.M.S." ),
DEF_SPLSTR( "B.Mus." ),
// "B.O.D." ),
// "B.P." ),
// "B.P.E." ),
DEF_SPLSTR( "B.Pd." ),
DEF_SPLSTR( "B.Ph." ),
DEF_SPLSTR( "B.Phil." ),
DEF_SPLSTR( "B.R.E." ),
// "B.S." ),
// "B.S.A." ),
// "B.S.A.A." ),
DEF_SPLSTR( "B.S.Arch." ),
DEF_SPLSTR( "B.S.Ch." ),
// "B.S.E.E." ),
DEF_SPLSTR( "B.S.Ec." ),
DEF_SPLSTR( "B.S.Ed." ),
// "B.S.F.S." ),
DEF_SPLSTR( "B.S.For." ),
// "B.S.N." ),
DEF_SPLSTR( "B.Sc." ),
// "B.T." ),
DEF_SPLSTR( "B.Th." ),
// "B.V.D." ),
// "B.V.M." ),
// "B.W.I." ),
DEF_SPLSTR( "Bab." ),
DEF_SPLSTR( "Bap." ),
DEF_SPLSTR( "Bapt." ),
DEF_SPLSTR( "Belg." ),
DEF_SPLSTR( "Benj." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Bhn." ),
DEF_SPLSTR( "Bhu." ),
DEF_SPLSTR( "Bib." ),
DEF_SPLSTR( "Bibl." ),
// "Bn." ),       // already in titles.txt
DEF_SPLSTR( "Bol." ),
DEF_SPLSTR( "Br." ),
DEF_SPLSTR( "Braz." ),
DEF_SPLSTR( "Brig." ),
DEF_SPLSTR( "Brit." ),
// "Bt." ),       // already in titles.txt
// "Btss." ),     // already in titles.txt
DEF_SPLSTR( "Bulg." ),
DEF_SPLSTR( "Bur." ),
// "C. of C." ),
// "C. of E." ),
// "C. of S." ),
// "C.A." ),
// "C.A.F." ),
// "C.A.G.S." ),
// "C.B.D." ),
// "C.C.A." ),
// "C.D." ),
// "C.E." ),
// "C.G." ),      // already in titles.txt
// "C.J." ),
// "C.L." ),
// "C.O." ),
// "C.P." ),
// "C.R." ),
// "C.S.A." ),
// "C.S.T." ),
// "C.V." ),
// "C.Z." ),
DEF_SPLSTR( "Calif." ),
DEF_SPLSTR( "Can." ),
DEF_SPLSTR( "Cant." ),
// "Capt." ),     // already in titles.txt
DEF_SPLSTR( "Card." ),
// "Cdr." ),      // already in titles.txt
DEF_SPLSTR( "Ch." ),
DEF_SPLSTR( "Ch.E." ),
DEF_SPLSTR( "Chas." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Chmn." ),
DEF_SPLSTR( "Chr." ),
DEF_SPLSTR( "Chron." ),
DEF_SPLSTR( "Cmd." ),
DEF_SPLSTR( "Cmdr." ),
DEF_SPLSTR( "Co." ),
// "Col." ),      // already in titles.txt
DEF_SPLSTR( "Colo." ),
// "Com." ),      // already in titles.txt
// "Comdr." ),    // already in titles.txt
DEF_SPLSTR( "Comdt." ),
DEF_SPLSTR( "Comm." ),
DEF_SPLSTR( "Comr." ),
DEF_SPLSTR( "Con." ),
DEF_SPLSTR( "Cong." ),
DEF_SPLSTR( "Conn." ),
DEF_SPLSTR( "Cons." ),
DEF_SPLSTR( "Const." ),
DEF_SPLSTR( "Conv." ),
DEF_SPLSTR( "Cop." ),
DEF_SPLSTR( "Copt." ),
DEF_SPLSTR( "Cor." ),
// "Cpl." ),      // already in titles.txt
// "Cpt." ),      // already in titles.txt
// "Ct." ),       // already in titles.txt
// "D.A." ),
// "D.B.A." ),
// "D.B.E." ),
DEF_SPLSTR( "D.Bib." ),
// "D.C." ),
// "D.C.L." ),
// "D.D." ),
// "D.D.S." ),
DEF_SPLSTR( "D.Ed." ),
// "D.F." ),      // already in titles.txt
// "D.F.A." ),
// "D.H." ),
// "D.H.L." ),
// "D.J." ),
// "D.L.S." ),
DEF_SPLSTR( "D.Lit." ),
DEF_SPLSTR( "D.Litt." ),                              // PaulCa 4/15/99 (Bug 108)
// "D.M.A." ),
// "D.M.D." ),
// "D.M.L." ),
// "D.O." ),
// "D.O.M." ),
// "D.P." ),
DEF_SPLSTR( "D.Ph." ),
DEF_SPLSTR( "D.Phil." ),
// "D.S." ),
DEF_SPLSTR( "D.Sc." ),                                // PaulCa 4/15/99 (Bug 108)
// "D.T." ),
// "D.V." ),
// "D.V.M." ),
DEF_SPLSTR( "Da." ),
DEF_SPLSTR( "Danl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Dec." ),
DEF_SPLSTR( "Del." ),
DEF_SPLSTR( "Dem." ),
DEF_SPLSTR( "Den." ),
DEF_SPLSTR( "Deut." ),
DEF_SPLSTR( "Dist." ),        // "Dist. Atty." ),
DEF_SPLSTR( "Div." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Divs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Dom." ),
DEF_SPLSTR( "Dor." ),
// "Dr." ),       // already in titles.txt
// "Drs." ),      // already in titles.txt
DEF_SPLSTR( "Dt." ),
// "Du." ),       // already in titles.txt
// "E.D." ),
// "E.E." ),
// "E.M." ),
// "E.Q." ),
// "E.T." ),
DEF_SPLSTR( "Ec." ),
DEF_SPLSTR( "Eccles." ),
DEF_SPLSTR( "Ecua." ),
DEF_SPLSTR( "Ed.M." ),
DEF_SPLSTR( "Edw." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Eng." ),
DEF_SPLSTR( "Engl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Ens." ),
DEF_SPLSTR( "Ep." ),
DEF_SPLSTR( "Eph." ),
DEF_SPLSTR( "Epis." ),
DEF_SPLSTR( "Episc." ),
DEF_SPLSTR( "Epist." ),
DEF_SPLSTR( "Esk." ),
// "Esq." ),      // already in titles.txt
DEF_SPLSTR( "Est." ),
DEF_SPLSTR( "Esth." ),
DEF_SPLSTR( "Eth." ),
DEF_SPLSTR( "Eur." ),
DEF_SPLSTR( "Ex." ),
// "Exc." ),      // already in titles.txt
DEF_SPLSTR( "Exch." ),
DEF_SPLSTR( "Exod." ),
DEF_SPLSTR( "Ezek." ),
// "F.A." ),
// "F.B." ),
// "F.D." ),
// "F.E.T." ),
// "F.F.A." ),
// "F.M." ),
// "F.O." ),
// "F.R.G." ),
DEF_SPLSTR( "Far." ),
DEF_SPLSTR( "Feb." ),
DEF_SPLSTR( "Fin." ),
DEF_SPLSTR( "Fla." ),
DEF_SPLSTR( "Flem." ),
// "Fr." ),       // already in titles.txt
DEF_SPLSTR( "Fri." ),
DEF_SPLSTR( "Fris." ),
// "Frl." ),      // already in titles.txt
DEF_SPLSTR( "Frs." ),
DEF_SPLSTR( "Ft." ),
// "G.A." ),
// "G.B." ),
// "G.C.B." ),
// "G.D." ),
// "G.D.R." ),
// "G.I." ),
// "G.M." ),
// "G.P." ),
// "G.T.C." ),
// "G.m.a.t." ),
DEF_SPLSTR( "Ga." ),
DEF_SPLSTR( "Gal." ),
// "Gen." ),      // already in titles.txt
DEF_SPLSTR( "Geo." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Ger." ),
DEF_SPLSTR( "Gib." ),
DEF_SPLSTR( "Gk." ),
DEF_SPLSTR( "Gn." ),
DEF_SPLSTR( "Goth." ),
// "Gov." ),      // already in titles.txt
DEF_SPLSTR( "Gr." ),
// "Gr. Brit." ),
DEF_SPLSTR( "Gt." ),          // "Gt. Brit."
DEF_SPLSTR( "Guat." ),
DEF_SPLSTR( "Guin." ),
// "H. Rept." ),
// "H. Res." ),
// "H.C." ),
// "H.C.F." ),
// "H.E." ),       // already in titles.txt
// "H.H." ),       // already in titles.txt
// "H.I." ),
// "H.I.H." ),    // already in titles.txt
// "H.I.M." ),    // already in titles.txt
// "H.L." ),
// "H.M." ),      // already in titles.txt
// "H.R." ),
// "H.R.E." ),
// "H.R.H." ),    // already in titles.txt
// "H.S.H." ),    // already in titles.txt
// "H.S.T." ),
// "H.V." ),
DEF_SPLSTR( "HH.D." ),
DEF_SPLSTR( "Hab." ),
DEF_SPLSTR( "Hag." ),
DEF_SPLSTR( "Heb." ),
DEF_SPLSTR( "Hebr." ),
DEF_SPLSTR( "Hind." ),
DEF_SPLSTR( "Hitt." ),
// "Hon." ),      // already in titles.txt
DEF_SPLSTR( "Hond." ),
DEF_SPLSTR( "Hos." ),
// "Hr." ),       // already in titles.txt
DEF_SPLSTR( "Hts." ),
DEF_SPLSTR( "Hung." ),
// "I.D." ),
// "I.N.R.I." ),
// "I.P.A." ),
// "I.R.A." ),
DEF_SPLSTR( "Ia." ),
DEF_SPLSTR( "Ice." ),
DEF_SPLSTR( "Icel." ),
DEF_SPLSTR( "Id." ),
DEF_SPLSTR( "Ill." ),
DEF_SPLSTR( "Ind." ),
DEF_SPLSTR( "Inf." ),
DEF_SPLSTR( "Inst." ),
DEF_SPLSTR( "Ion." ),
DEF_SPLSTR( "Ir." ),
DEF_SPLSTR( "Ire." ),
DEF_SPLSTR( "Is." ),
DEF_SPLSTR( "Isl." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Isr." ),
DEF_SPLSTR( "It." ),
DEF_SPLSTR( "Ital." ),
// "J.A." ),
// "J.A.G." ),
// "J.C.D." ),
// "J.C.S." ),
// "J.D." ),
// "J.P." ),
// "J.S.D." ),
DEF_SPLSTR( "Jam." ),
DEF_SPLSTR( "Jan." ),
DEF_SPLSTR( "Jas." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Jav." ),
DEF_SPLSTR( "Jb." ),
DEF_SPLSTR( "Jdt." ),
DEF_SPLSTR( "Jer." ),
DEF_SPLSTR( "Jg." ),
DEF_SPLSTR( "Jl." ),
DEF_SPLSTR( "Jm." ),
DEF_SPLSTR( "Jn." ),
DEF_SPLSTR( "Jos." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Jr." ),
DEF_SPLSTR( "Judg." ),
DEF_SPLSTR( "Jul." ),
DEF_SPLSTR( "Jun." ),
// "K.C." ),
// "K.G." ),
// "K.G.B." ),
DEF_SPLSTR( "Kan." ),
DEF_SPLSTR( "Kans." ),
DEF_SPLSTR( "Knt." ),
DEF_SPLSTR( "Kor." ),
DEF_SPLSTR( "Ky." ),
// "L.A." ),
// "L.C." ),
// "L.Cpl." ),    // already in titles.txt
// "L.I." ),
// "L.S." ),
DEF_SPLSTR( "LL.B." ),
DEF_SPLSTR( "LL.D." ),
DEF_SPLSTR( "LL.M." ),
DEF_SPLSTR( "La." ),
DEF_SPLSTR( "Lab." ),
DEF_SPLSTR( "Lam." ),
DEF_SPLSTR( "Lat." ),
// "Ld." ),       // already in titles.txt
DEF_SPLSTR( "Leb." ),
DEF_SPLSTR( "Lev." ),
DEF_SPLSTR( "Levit." ),
DEF_SPLSTR( "Lib." ),
DEF_SPLSTR( "Liech." ),
DEF_SPLSTR( "Lit.B." ),
DEF_SPLSTR( "Lit.D." ),
DEF_SPLSTR( "Lith." ),
DEF_SPLSTR( "Litt.B." ),
DEF_SPLSTR( "Litt.D." ),
// "Lt." ),       // already in titles.txt
// "Lt. Col." ),
// "Lt. Comdr." ),
// "Lt. Gen." ),
// "Lt. Gov." ),
DEF_SPLSTR( "Ltd." ),
DEF_SPLSTR( "Lux." ),
// "M. o. T." ),
// "M.A." ),
// "M.A.B.E." ),
// "M.A.E." ),
DEF_SPLSTR( "M.A.Ed." ),
// "M.A.L.S." ),
// "M.A.T." ),
DEF_SPLSTR( "M.Agr." ),
// "M.B.A." ),
// "M.C." ),
// "M.C.L." ),
// "M.D." ),
// "M.D.S." ),
DEF_SPLSTR( "M.Div." ),
// "M.E." ),
DEF_SPLSTR( "M.Ed." ),
// "M.F.A." ),
// "M.F.H." ),
// "M.H.L." ),
// "M.L.S." ),
// "M.M." ),      // already in titles.txt
// "M.P.A." ),
// "M.P.E." ),
// "M.R.E." ),
// "M.S." ),
// "M.S. in L.S." ),
// "M.S.N." ),
// "M.S.T." ),
// "M.S.T.S." ),
// "M.S.W." ),
DEF_SPLSTR( "M.Sc." ),
// "M.Sgt." ),    // already in titles.txt
// "M.T." ),
DEF_SPLSTR( "MM." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "MS." ),
DEF_SPLSTR( "MSS." ),
DEF_SPLSTR( "Macc." ),
DEF_SPLSTR( "Maced." ),
DEF_SPLSTR( "Mad." ),
DEF_SPLSTR( "Madag." ),
// "Maj." ),      // already in titles.txt
// "Maj. Gen." ),
DEF_SPLSTR( "Mal." ),
DEF_SPLSTR( "Man." ),
DEF_SPLSTR( "Mar." ),
DEF_SPLSTR( "Mart." ),
DEF_SPLSTR( "Mass." ),
DEF_SPLSTR( "Md." ),
// "Mdm." ),      // already in titles.txt
DEF_SPLSTR( "Me." ),
// "Med. Gr." ),
// "Med. Lat." ),
DEF_SPLSTR( "Medit." ),
// "Messrs." ),   // already in titles.txt
DEF_SPLSTR( "Mex." ),
// "Mgr." ),      // already in titles.txt
DEF_SPLSTR( "Mich." ),
DEF_SPLSTR( "Midn." ),
DEF_SPLSTR( "Minn." ),
DEF_SPLSTR( "Miss." ),
// "Mlle." ),     // already in titles.txt
// "Mlles." ),    // already in titles.txt
// "Mme." ),      // already in titles.txt
// "Mmes." ),     // already in titles.txt
DEF_SPLSTR( "Mo." ),
DEF_SPLSTR( "Mon." ),
DEF_SPLSTR( "Mont." ),
DEF_SPLSTR( "Mor." ),
DEF_SPLSTR( "Moz." ),
// "Mr." ),       // already in titles.txt
// "Mrs." ),      // already in titles.txt
// "Ms." ),       // already in titles.txt
DEF_SPLSTR( "Mses." ),
// "Msgr." ),     // already in titles.txt
DEF_SPLSTR( "Mss." ),
DEF_SPLSTR( "Mt." ),
DEF_SPLSTR( "Mtn." ),
DEF_SPLSTR( "Mts." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Mus.B." ),
DEF_SPLSTR( "Mus.D." ),
DEF_SPLSTR( "Mus.Dr." ),
DEF_SPLSTR( "Mus.M." ),
// "N.A." ),
// "N.B." ),
// "N.C." ),
// "N.D." ),
DEF_SPLSTR( "N.Dak." ),
// "N.E." ),
// "N.E.P." ),
// "N.F." ),
// "N.H." ),
DEF_SPLSTR( "N.Ire." ),
// "N.J." ),
// "N.M." ),
DEF_SPLSTR( "N.Mex." ),
// "N.P." ),
// "N.S." ),
// "N.S.P.C.A." ),
// "N.T." ),
// "N.W.T." ),
// "N.Y." ),
// "N.Y.C." ),
// "N.Z." ),
DEF_SPLSTR( "Na." ),
DEF_SPLSTR( "Nb." ),
DEF_SPLSTR( "Ne." ),
DEF_SPLSTR( "Neb." ),
DEF_SPLSTR( "Nebr." ),
DEF_SPLSTR( "Neh." ),
DEF_SPLSTR( "Nep." ),
DEF_SPLSTR( "Neth." ),
DEF_SPLSTR( "Nev." ),
// "New Test." ),
DEF_SPLSTR( "Newf." ),
DEF_SPLSTR( "Nfld." ),
DEF_SPLSTR( "Nic." ),
DEF_SPLSTR( "Nig." ),
DEF_SPLSTR( "Nor." ),
DEF_SPLSTR( "Norw." ),
DEF_SPLSTR( "Nos." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Nov." ),
DEF_SPLSTR( "Num." ),
// "O.B.E." ),
// "O.C." ),
// "O.D." ),
// "O.F.M." ),
// "O.K." ),
// "O.M." ),
// "O.N." ),
// "O.O.D." ),
// "O.P." ),
// "O.R." ),
// "O.S." ),
// "O.T." ),
DEF_SPLSTR( "OM." ),
DEF_SPLSTR( "Ob." ),
DEF_SPLSTR( "Obad." ),
DEF_SPLSTR( "Obs." ),
DEF_SPLSTR( "Oc." ),
DEF_SPLSTR( "Oct." ),
DEF_SPLSTR( "Okla." ),
DEF_SPLSTR( "Ont." ),
DEF_SPLSTR( "Op." ),
DEF_SPLSTR( "Ore." ),
DEF_SPLSTR( "Oxon." ),                                // PaulCa 4/15/99 (Bug 108)
// "P. S." ),
// "P.A." ),
// "P.B." ),
// "P.C." ),
// "P.D." ),
// "P.E." ),
// "P.E.I." ),
// "P.G." ),
// "P.M." ),
// "P.M.G." ),
// "P.P.S." ),
// "P.Q." ),
// "P.R." ),
// "P.S." ),
// "P.T." ),
// "P.W.A." ),
// "PFC." ),      // already in titles.txt
DEF_SPLSTR( "PP." ),
DEF_SPLSTR( "Pa." ),
DEF_SPLSTR( "Pac." ),
DEF_SPLSTR( "Pacif." ),
DEF_SPLSTR( "Pak." ),
DEF_SPLSTR( "Pal." ),
DEF_SPLSTR( "Par." ),
DEF_SPLSTR( "Parl." ),
DEF_SPLSTR( "Pd.B." ),
DEF_SPLSTR( "Pd.D." ),
DEF_SPLSTR( "Pd.M." ),
DEF_SPLSTR( "Penn." ),
DEF_SPLSTR( "Penna." ),
DEF_SPLSTR( "Pers." ),
DEF_SPLSTR( "Pet." ),
DEF_SPLSTR( "Pg." ),
DEF_SPLSTR( "Ph.B." ),
DEF_SPLSTR( "Ph.C." ),
DEF_SPLSTR( "Ph.D." ),
DEF_SPLSTR( "Ph.G." ),
DEF_SPLSTR( "Ph.M." ),
DEF_SPLSTR( "Phar.B." ),
DEF_SPLSTR( "Phar.D." ),
DEF_SPLSTR( "Phar.M." ),
DEF_SPLSTR( "Phil." ),
// "Phil. I." ),
// "Phil. Is." ),
DEF_SPLSTR( "Philem." ),
DEF_SPLSTR( "Pl." ),
DEF_SPLSTR( "Pol." ),
// "Pr." ),       // already in titles.txt
// "Pres." ),     // already in titles.txt
DEF_SPLSTR( "Presb." ),
DEF_SPLSTR( "Presby." ),
// "Prof." ),     // already in titles.txt
// "Profs." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Pros." ),        // "Pros. Atty."
DEF_SPLSTR( "Prot." ),
DEF_SPLSTR( "Prov." ),
DEF_SPLSTR( "Pvt." ),
// "Q. C." ),
// "Q.B." ),
// "Q.C." ),
// "Q.E.D." ),
// "Q.E.F." ),
// "Q.M." ),
DEF_SPLSTR( "Que." ),
// "R. A. F." ),
// "R. C." ),
// "R.A." ),      // already in titles.txt
// "R.A.M." ),
DEF_SPLSTR( "R.C.Ch." ),
// "R.C.P." ),
// "R.C.S." ),
// "R.E." ),
// "R.I." ),
// "R.I.P." ),
// "R.M.S." ),
// "R.P." ),
// "R.Q." ),
// "R.R." ),      // already in titles.txt
// "R.S." ),
// "R.S.F.S.R." ),
// "R.S.V.P." ),
// "R.V." ),
// "R.W." ),      // already in titles.txt
DEF_SPLSTR( "Ra." ),
DEF_SPLSTR( "Rd." ),
DEF_SPLSTR( "Re." ),
// "Rep." ),      // already in titles.txt
DEF_SPLSTR( "Rept." ),
DEF_SPLSTR( "Repub." ),
DEF_SPLSTR( "Res." ),
// "Rev." ),      // already in titles.txt
// "Rev. Ver." ),
DEF_SPLSTR( "Rm." ),
DEF_SPLSTR( "Rom." ),
DEF_SPLSTR( "Rt." ),
// "Rt. Hon." ),
// "Rt. Rev." ),
DEF_SPLSTR( "Rus." ),
DEF_SPLSTR( "Rv." ),
// "S. of Sol." ),
// "S.A." ),
DEF_SPLSTR( "S.Afr." ),
// "S.B." ),
// "S.C." ),
// "S.D." ),
DEF_SPLSTR( "S.Dak." ),
// "S.F.S.R." ),
// "S.G." ),
// "S.J." ),
// "S.J.D." ),
// "S.M." ),
// "S.M.Sgt." ),  // already in titles.txt
// "S.P.Q.R." ),
// "S.S." ),
// "S.S.R." ),
// "S.Sgt." ),    // already in titles.txt
DEF_SPLSTR( "Sab." ),
DEF_SPLSTR( "Sask." ),
DEF_SPLSTR( "Sat." ),
DEF_SPLSTR( "Sax." ),
DEF_SPLSTR( "Sc." ),
DEF_SPLSTR( "Sc.B." ),
DEF_SPLSTR( "Sc.D." ),
DEF_SPLSTR( "Scand." ),
DEF_SPLSTR( "Schil." ),       // Added 1/12/2000 by AaronHal to match currency abbreviations
DEF_SPLSTR( "Script." ),
DEF_SPLSTR( "Sec." ),
DEF_SPLSTR( "Sem." ),
// "Sen." ),      // already in titles.txt
DEF_SPLSTR( "Sept." ),
// "Sgt." ),      // already in titles.txt
// "Sgt.Maj." ),  // already in titles.txt
DEF_SPLSTR( "Sib." ),
DEF_SPLSTR( "Sic." ),
DEF_SPLSTR( "Sig." ),
DEF_SPLSTR( "Skr." ),
DEF_SPLSTR( "Skt." ),
DEF_SPLSTR( "Slav." ),
// "So." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Soc." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Sol." ),
DEF_SPLSTR( "Som." ),
DEF_SPLSTR( "Sp." ),
DEF_SPLSTR( "Span." ),
// "Sr." ),   // already in titles.txt
// "Sra." ),  // already in titles.txt
// "Srta." ), // already in titles.txt
// "St." ),   // already in titles.txt
// "St. Ex." ),
DEF_SPLSTR( "Ste." ),
DEF_SPLSTR( "Str." ),
DEF_SPLSTR( "Suff." ),
DEF_SPLSTR( "Sun." ),
DEF_SPLSTR( "Sup.Ct." ),
DEF_SPLSTR( "Sw." ),
DEF_SPLSTR( "Swaz." ),
DEF_SPLSTR( "Swe." ),
DEF_SPLSTR( "Swed." ),
DEF_SPLSTR( "Switz." ),
DEF_SPLSTR( "Syr." ),
// "T.B." ),
// "T.D." ),
// "T.F." ),
// "T.M." ),
// "T.S." ),
// "T.Sgt." ),// already in titles.txt
// "T.U." ),
DEF_SPLSTR( "Tanz." ),
DEF_SPLSTR( "Tas." ),
DEF_SPLSTR( "Tenn." ),
//"Test." ), Removed by AaronHal 2/4/2000 (Raid#2154)
DEF_SPLSTR( "Teut." ),
DEF_SPLSTR( "Tex." ),
DEF_SPLSTR( "Th." ),
DEF_SPLSTR( "Th.B." ),
DEF_SPLSTR( "Th.D." ),
DEF_SPLSTR( "Th.M." ),
DEF_SPLSTR( "Theo." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Thos." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Thur." ),
DEF_SPLSTR( "Thurs." ),
DEF_SPLSTR( "Tit." ),
DEF_SPLSTR( "Tu." ),
DEF_SPLSTR( "Tues." ),
DEF_SPLSTR( "Tun." ),
DEF_SPLSTR( "Tur." ),
// "U.A.E." ),
// "U.A.R." ),
// "U.K." ),
// "U.N." ),
// "U.S." ),
// "U.S.A." ),
// "U.S.C." ),
// "U.S.C.A." ),
// "U.S.M." ),
// "U.S.P." ),
// "U.S.S." ),
// "U.S.S.R." ),
DEF_SPLSTR( "Uni." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Univ." ),
DEF_SPLSTR( "Urug." ),
DEF_SPLSTR( "Ut." ),
// "V.A." ),  // already in titles.txt
// "V.Adm." ),// already in titles.txt
// "V.C." ),
// "V.F." ),
// "V.G." ),
// "V.I." ),
// "V.M.D." ),
// "V.P." ),
// "V.S." ),
DEF_SPLSTR( "Va." ),
DEF_SPLSTR( "Vat." ),
// "Ven." ),  // already in titles.txt
DEF_SPLSTR( "Venez." ),
DEF_SPLSTR( "Ver." ),
DEF_SPLSTR( "Viet." ),
// "Vis." ),  // already in titles.txt
// "Visct." ),// already in titles.txt
DEF_SPLSTR( "Vt." ),
DEF_SPLSTR( "Vul." ),
DEF_SPLSTR( "Vulg." ),
// "W.B." ),
// "W.C." ),
// "W.I." ),
DEF_SPLSTR( "W.Va." ),
// "W.W.I" ),                             // PaulCa 4/15/99 (Bug 108)
// "W.W.II" ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Wash." ),
DEF_SPLSTR( "Wed." ),
DEF_SPLSTR( "Wis." ),
DEF_SPLSTR( "Wm." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Wyo." ),
// "Y.T." ),
DEF_SPLSTR( "Yug." ),
DEF_SPLSTR( "Yugo." ),
DEF_SPLSTR( "a.b." ),
DEF_SPLSTR( "a.c." ),
DEF_SPLSTR( "a.d." ),
DEF_SPLSTR( "a.d.c." ),
DEF_SPLSTR( "a.i." ),
DEF_SPLSTR( "a.k.a." ),
DEF_SPLSTR( "a.l.s." ),
DEF_SPLSTR( "a.m." ),
DEF_SPLSTR( "a.p." ),
DEF_SPLSTR( "a.s.a.p." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "a.u." ),
DEF_SPLSTR( "a.v." ),
DEF_SPLSTR( "a.w." ),
DEF_SPLSTR( "ab." ),
DEF_SPLSTR( "abb." ),
DEF_SPLSTR( "abbr." ),
DEF_SPLSTR( "abbrs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "abl." ),
DEF_SPLSTR( "abp." ),
DEF_SPLSTR( "abr." ),
DEF_SPLSTR( "abs." ),
DEF_SPLSTR( "abt." ),
DEF_SPLSTR( "ac." ),
DEF_SPLSTR( "acad." ),
DEF_SPLSTR( "acc." ),
DEF_SPLSTR( "acct." ),
DEF_SPLSTR( "accts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "acet." ),
DEF_SPLSTR( "ack." ),
DEF_SPLSTR( "acpt." ),
DEF_SPLSTR( "actg." ),
DEF_SPLSTR( "ad loc." ),
DEF_SPLSTR( "addl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "addn." ),
DEF_SPLSTR( "addnl." ),
DEF_SPLSTR( "adj." ),
DEF_SPLSTR( "adjs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "adjt." ),
DEF_SPLSTR( "adm." ),
// "admin." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "adv." ),
DEF_SPLSTR( "advs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "advt." ),
DEF_SPLSTR( "agcy." ),
DEF_SPLSTR( "agri." ),
DEF_SPLSTR( "agric." ),
DEF_SPLSTR( "agt." ),
DEF_SPLSTR( "al." ),
DEF_SPLSTR( "alc." ),
DEF_SPLSTR( "alg." ),
DEF_SPLSTR( "alky." ),
DEF_SPLSTR( "alt." ),
DEF_SPLSTR( "amt." ),
DEF_SPLSTR( "amts." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "an." ),
DEF_SPLSTR( "anat." ),
DEF_SPLSTR( "anc." ),
DEF_SPLSTR( "and." ),         // andante
DEF_SPLSTR( "anhydr." ),
DEF_SPLSTR( "anim." ),
DEF_SPLSTR( "ann." ),
DEF_SPLSTR( "anon." ),
DEF_SPLSTR( "ans." ),
DEF_SPLSTR( "anthrop." ),
DEF_SPLSTR( "antiq." ),
DEF_SPLSTR( "aor." ),
DEF_SPLSTR( "ap." ),
DEF_SPLSTR( "app." ),
DEF_SPLSTR( "appl." ),
DEF_SPLSTR( "approx." ),
DEF_SPLSTR( "appt." ),
DEF_SPLSTR( "apptd." ),
DEF_SPLSTR( "apt." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "apts." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "aq." ),
DEF_SPLSTR( "ar." ),
DEF_SPLSTR( "archit." ),
DEF_SPLSTR( "archt." ),
DEF_SPLSTR( "arg." ),
DEF_SPLSTR( "arr." ),
// "art." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "arty." ),
DEF_SPLSTR( "asg." ),
DEF_SPLSTR( "asgd." ),
DEF_SPLSTR( "asgmt." ),
DEF_SPLSTR( "assn." ),
DEF_SPLSTR( "assns." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "assoc." ),
DEF_SPLSTR( "assocs." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "asst." ),
DEF_SPLSTR( "asstd." ),
DEF_SPLSTR( "assts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "assy." ),
DEF_SPLSTR( "astrol." ),
DEF_SPLSTR( "astron." ),
//"at." ),                                  // at. no.; special case no longer handled
DEF_SPLSTR( "athl." ),
DEF_SPLSTR( "atm." ),
DEF_SPLSTR( "atmos." ),
DEF_SPLSTR( "att." ),
DEF_SPLSTR( "attn." ),
DEF_SPLSTR( "attrib." ),
DEF_SPLSTR( "atty." ),
DEF_SPLSTR( "attys." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "aud." ),
DEF_SPLSTR( "aug." ),
DEF_SPLSTR( "auth." ),
DEF_SPLSTR( "aux." ),
// "aux. v." ),
DEF_SPLSTR( "av." ),
DEF_SPLSTR( "avdp." ),
DEF_SPLSTR( "ave." ),
DEF_SPLSTR( "avg." ),
DEF_SPLSTR( "avn." ),
DEF_SPLSTR( "az." ),
DEF_SPLSTR( "b.c." ),
DEF_SPLSTR( "b.c.e." ),
DEF_SPLSTR( "b.f." ),
DEF_SPLSTR( "b.i.d." ),
DEF_SPLSTR( "b.m." ),
DEF_SPLSTR( "b.p." ),
DEF_SPLSTR( "b.y." ),
DEF_SPLSTR( "bact." ),
DEF_SPLSTR( "bal." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "bbl." ),
DEF_SPLSTR( "bd." ),
// "bd. ft." ),
DEF_SPLSTR( "bdle." ),
DEF_SPLSTR( "bdrm." ),
DEF_SPLSTR( "bds." ),
DEF_SPLSTR( "bef." ),
DEF_SPLSTR( "bg." ),
DEF_SPLSTR( "bhd." ),
DEF_SPLSTR( "bibl." ),
DEF_SPLSTR( "bibliog." ),
DEF_SPLSTR( "biog." ),
DEF_SPLSTR( "biol." ),
DEF_SPLSTR( "bk." ),
DEF_SPLSTR( "bkg." ),
DEF_SPLSTR( "bkgd." ),
DEF_SPLSTR( "bklr." ),
DEF_SPLSTR( "bkpg." ),
DEF_SPLSTR( "bkpt." ),
DEF_SPLSTR( "bks." ),
DEF_SPLSTR( "bl." ),
DEF_SPLSTR( "bld." ),
DEF_SPLSTR( "bldg." ),
DEF_SPLSTR( "bldr." ),
DEF_SPLSTR( "blk." ),
DEF_SPLSTR( "blvd." ),
DEF_SPLSTR( "bm." ),
DEF_SPLSTR( "bn." ),
DEF_SPLSTR( "bor." ),
DEF_SPLSTR( "bot." ),
DEF_SPLSTR( "boul." ),
DEF_SPLSTR( "bp." ),
DEF_SPLSTR( "br." ),
DEF_SPLSTR( "brev." ),
DEF_SPLSTR( "bro." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "bros." ),
DEF_SPLSTR( "bsh." ),
DEF_SPLSTR( "bsk." ),
DEF_SPLSTR( "btry." ),
DEF_SPLSTR( "bu." ),
DEF_SPLSTR( "bul." ),
DEF_SPLSTR( "bur." ),
DEF_SPLSTR( "bvt." ),
DEF_SPLSTR( "bx." ),
DEF_SPLSTR( "c.a." ),
DEF_SPLSTR( "c.c." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.c.s." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.d." ),
DEF_SPLSTR( "c.f." ),
DEF_SPLSTR( "c.f.i." ),
DEF_SPLSTR( "c.g." ),
DEF_SPLSTR( "c.h." ),
DEF_SPLSTR( "c.i.f." ),
DEF_SPLSTR( "c.l." ),
DEF_SPLSTR( "c.m." ),
DEF_SPLSTR( "c.o." ),
DEF_SPLSTR( "c.o.d." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.o.s." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.v." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.w.o." ),
DEF_SPLSTR( "ca." ),      // circa
DEF_SPLSTR( "cal." ),
DEF_SPLSTR( "calc." ),
DEF_SPLSTR( "canc." ),
// "cap." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cath." ),
DEF_SPLSTR( "caus." ),
DEF_SPLSTR( "cav." ),
DEF_SPLSTR( "cc." ),
DEF_SPLSTR( "cckw." ),
DEF_SPLSTR( "ccw." ),
DEF_SPLSTR( "cen." ),
DEF_SPLSTR( "cert." ),
DEF_SPLSTR( "certif." ),
DEF_SPLSTR( "certifs." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cet." ),   // "cet. par."
DEF_SPLSTR( "cf." ), // Moved from titles.txt 8/18/99 - edc
DEF_SPLSTR( "ch." ),
DEF_SPLSTR( "chan." ),
DEF_SPLSTR( "chap." ),  // chapter
// "chaps." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "char." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "chars." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "chem." ),
DEF_SPLSTR( "chg." ),
DEF_SPLSTR( "chl." ),
DEF_SPLSTR( "chm." ),
DEF_SPLSTR( "chron." ),
DEF_SPLSTR( "chronol." ),
DEF_SPLSTR( "cie." ),
DEF_SPLSTR( "cir." ),
DEF_SPLSTR( "circ." ),
DEF_SPLSTR( "circum." ),
DEF_SPLSTR( "cit." ),
DEF_SPLSTR( "civ." ),
DEF_SPLSTR( "ck." ),
DEF_SPLSTR( "cl." ),
DEF_SPLSTR( "cld." ),
DEF_SPLSTR( "clk." ),
DEF_SPLSTR( "clm." ),
DEF_SPLSTR( "cm." ),
DEF_SPLSTR( "cmd." ),
DEF_SPLSTR( "cmdg." ),
DEF_SPLSTR( "cml." ),
DEF_SPLSTR( "co." ),
DEF_SPLSTR( "col." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "coll." ),
DEF_SPLSTR( "collat." ),
DEF_SPLSTR( "colloq." ),
DEF_SPLSTR( "cols." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "com." ),
DEF_SPLSTR( "comd." ),
DEF_SPLSTR( "comdg." ),
DEF_SPLSTR( "coml." ),
DEF_SPLSTR( "comm." ),
DEF_SPLSTR( "comp." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "compar." ),
DEF_SPLSTR( "compd." ),
DEF_SPLSTR( "compt." ),
DEF_SPLSTR( "conc." ),
DEF_SPLSTR( "cond." ),
DEF_SPLSTR( "conf." ),
DEF_SPLSTR( "confed." ),
DEF_SPLSTR( "cong." ),
DEF_SPLSTR( "conj." ),
DEF_SPLSTR( "conjs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cons." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "consol." ),
DEF_SPLSTR( "const." ),
DEF_SPLSTR( "constr." ),
DEF_SPLSTR( "cont." ),
DEF_SPLSTR( "contd." ),
DEF_SPLSTR( "contemp." ),
DEF_SPLSTR( "contr." ),
DEF_SPLSTR( "contrib." ),
DEF_SPLSTR( "conv." ),
DEF_SPLSTR( "coop." ),
DEF_SPLSTR( "cop." ),
DEF_SPLSTR( "cor." ),
DEF_SPLSTR( "corol." ),
DEF_SPLSTR( "corp." ),
// "corps." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "corr." ),
DEF_SPLSTR( "correl." ),
DEF_SPLSTR( "cos." ),
DEF_SPLSTR( "cp." ),
DEF_SPLSTR( "cpd." ),
DEF_SPLSTR( "cr." ),
DEF_SPLSTR( "crim." ),
DEF_SPLSTR( "crit." ),
DEF_SPLSTR( "cs." ),
DEF_SPLSTR( "csk." ),
DEF_SPLSTR( "ct." ),
DEF_SPLSTR( "ctf." ),
DEF_SPLSTR( "ctg." ),
DEF_SPLSTR( "ctge." ),
DEF_SPLSTR( "ctn." ),
DEF_SPLSTR( "ctr." ),
DEF_SPLSTR( "cu." ),
DEF_SPLSTR( "cum." ),
// "cur." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cv." ),
DEF_SPLSTR( "cvt." ),
DEF_SPLSTR( "cw." ),
DEF_SPLSTR( "cwt." ),
DEF_SPLSTR( "d.b.a." ),
DEF_SPLSTR( "d.b.h." ),
DEF_SPLSTR( "d.s." ),
DEF_SPLSTR( "d.s.p." ),
DEF_SPLSTR( "d.t." ),
DEF_SPLSTR( "dat." ),
DEF_SPLSTR( "dbl." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dble." ),
DEF_SPLSTR( "dd." ),
DEF_SPLSTR( "deb." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dec." ),
DEF_SPLSTR( "decd." ),
DEF_SPLSTR( "decl." ),
DEF_SPLSTR( "def." ),
DEF_SPLSTR( "deg." ),
DEF_SPLSTR( "del." ),
DEF_SPLSTR( "dely." ),
DEF_SPLSTR( "dem." ),
DEF_SPLSTR( "denom." ),
DEF_SPLSTR( "dep." ),
DEF_SPLSTR( "dept." ),
DEF_SPLSTR( "depts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "der." ),
DEF_SPLSTR( "deriv." ),
DEF_SPLSTR( "det." ),
DEF_SPLSTR( "dev." ),
DEF_SPLSTR( "dft." ),
DEF_SPLSTR( "dia." ),
DEF_SPLSTR( "diag." ),
DEF_SPLSTR( "diam." ),
DEF_SPLSTR( "dict." ),
DEF_SPLSTR( "dif." ),
DEF_SPLSTR( "diff." ),
DEF_SPLSTR( "dil." ),
DEF_SPLSTR( "dimin." ),
DEF_SPLSTR( "dipl." ),
DEF_SPLSTR( "dir." ),
DEF_SPLSTR( "dirs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dis." ),
// "disc." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "disp." ),
DEF_SPLSTR( "diss." ),
DEF_SPLSTR( "dissd." ),
DEF_SPLSTR( "dist." ),
DEF_SPLSTR( "distr." ),
DEF_SPLSTR( "div." ),
DEF_SPLSTR( "dk." ),
DEF_SPLSTR( "dlr." ),
DEF_SPLSTR( "dm." ),
DEF_SPLSTR( "dn." ),
DEF_SPLSTR( "doc." ),
DEF_SPLSTR( "dol." ),
DEF_SPLSTR( "dom." ),
DEF_SPLSTR( "doz." ),
DEF_SPLSTR( "dpt." ),
DEF_SPLSTR( "dr." ),
DEF_SPLSTR( "dup." ),
DEF_SPLSTR( "dupl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dupls." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dups." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dwt." ),
DEF_SPLSTR( "dy." ),
DEF_SPLSTR( "dz." ),
DEF_SPLSTR( "e.e." ),
DEF_SPLSTR( "e.g." ), // Moved from titles.txt - edc 8/18/99
DEF_SPLSTR( "e.o." ),
DEF_SPLSTR( "e.o.m." ),
DEF_SPLSTR( "e.p.t." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "e.s.p." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "e.t.a." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "e.t.d." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ea." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "eccl." ),
DEF_SPLSTR( "eccles." ),
DEF_SPLSTR( "ecol." ),
DEF_SPLSTR( "ed." ),
DEF_SPLSTR( "eds." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "educ." ),
DEF_SPLSTR( "eff." ),
DEF_SPLSTR( "el." ),
DEF_SPLSTR( "elec." ),
DEF_SPLSTR( "elem." ),
DEF_SPLSTR( "elev." ),
DEF_SPLSTR( "emer." ),
DEF_SPLSTR( "emp." ),
DEF_SPLSTR( "enc." ),
DEF_SPLSTR( "encl." ),
DEF_SPLSTR( "ency." ),
DEF_SPLSTR( "encyc." ),
DEF_SPLSTR( "encycl." ),
DEF_SPLSTR( "eng." ),
DEF_SPLSTR( "engr." ),
DEF_SPLSTR( "enl." ),
DEF_SPLSTR( "entom." ),
DEF_SPLSTR( "eq." ),
DEF_SPLSTR( "eqn." ),
DEF_SPLSTR( "eqns." ),
DEF_SPLSTR( "equip." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "equiv." ),
DEF_SPLSTR( "esp." ),
DEF_SPLSTR( "esq." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "est." ),
// "et al." ),
// "et seq." ),
// "et ux." ),
DEF_SPLSTR( "etc." ),
DEF_SPLSTR( "etym." ),
DEF_SPLSTR( "evan." ),
DEF_SPLSTR( "evang." ),
DEF_SPLSTR( "evap." ),
DEF_SPLSTR( "evg." ),
DEF_SPLSTR( "ex." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "exc." ),
DEF_SPLSTR( "exch." ),
DEF_SPLSTR( "excl." ),
// "exec." ),                             // PaulCa 4/15/99 (Bug 108)
// "execs." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "exp." ),
DEF_SPLSTR( "expt." ),
DEF_SPLSTR( "exptl." ),
DEF_SPLSTR( "exr." ),
DEF_SPLSTR( "exrx." ),
DEF_SPLSTR( "ext." ),
DEF_SPLSTR( "f.a." ),
DEF_SPLSTR( "f.a.a." ),
DEF_SPLSTR( "f.a.s." ),
DEF_SPLSTR( "f.c." ),
DEF_SPLSTR( "f.h.b." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "f.o.b." ),
DEF_SPLSTR( "f.r." ),
DEF_SPLSTR( "f.v." ),
DEF_SPLSTR( "fac." ),
DEF_SPLSTR( "fam." ),
DEF_SPLSTR( "fasc." ),
DEF_SPLSTR( "fcap." ),
DEF_SPLSTR( "fcp." ),
DEF_SPLSTR( "fcy." ),
DEF_SPLSTR( "fec." ),
// "fed." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "fem." ),
DEF_SPLSTR( "ff." ),
DEF_SPLSTR( "fgt." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "fict." ),
DEF_SPLSTR( "fig." ),                                 // special case
DEF_SPLSTR( "figs." ),                                // special case
DEF_SPLSTR( "fl." ),
DEF_SPLSTR( "fld." ),
DEF_SPLSTR( "fm." ),
DEF_SPLSTR( "fn." ),
DEF_SPLSTR( "fol." ),
DEF_SPLSTR( "fp." ),
DEF_SPLSTR( "fr." ),
DEF_SPLSTR( "freq." ),
DEF_SPLSTR( "frt." ),
DEF_SPLSTR( "ft." ),
DEF_SPLSTR( "fth." ),
DEF_SPLSTR( "furn." ),
DEF_SPLSTR( "fut." ),
DEF_SPLSTR( "fwd." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "g.m.b.h." ),
DEF_SPLSTR( "g.p.d." ),
DEF_SPLSTR( "g.p.m." ),
DEF_SPLSTR( "g.p.s." ),
DEF_SPLSTR( "ga." ),
// "gal." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "galv." ),
DEF_SPLSTR( "gaz." ),
DEF_SPLSTR( "gd." ),
DEF_SPLSTR( "gds." ),
DEF_SPLSTR( "gen." ),
DEF_SPLSTR( "genit." ),
DEF_SPLSTR( "genl." ),
DEF_SPLSTR( "geog." ),
DEF_SPLSTR( "geol." ),
DEF_SPLSTR( "geom." ),
DEF_SPLSTR( "ger." ),
DEF_SPLSTR( "gl." ),
DEF_SPLSTR( "gld." ),
DEF_SPLSTR( "gm." ),
DEF_SPLSTR( "gnd." ),
DEF_SPLSTR( "gov." ),
DEF_SPLSTR( "govt." ),
DEF_SPLSTR( "gr." ),
// "gr. wt." ),
DEF_SPLSTR( "gro." ),
DEF_SPLSTR( "gt." ),
DEF_SPLSTR( "gtd." ),
DEF_SPLSTR( "gtt." ),
DEF_SPLSTR( "guar." ),
DEF_SPLSTR( "gyn." ),
DEF_SPLSTR( "gynecol." ),
DEF_SPLSTR( "h.c." ),
DEF_SPLSTR( "h.q." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "h.r." ),
DEF_SPLSTR( "hab." ),     // "hab. corp." ),
DEF_SPLSTR( "hd." ),
DEF_SPLSTR( "hdbk." ),
DEF_SPLSTR( "hdkf." ),
DEF_SPLSTR( "hdlg." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hdqrs." ),
DEF_SPLSTR( "hdwe." ),
DEF_SPLSTR( "hf." ),
DEF_SPLSTR( "hgb." ),
DEF_SPLSTR( "hgt." ),
DEF_SPLSTR( "hgwy." ),
DEF_SPLSTR( "hist." ),
DEF_SPLSTR( "hld." ),
DEF_SPLSTR( "hm." ),
DEF_SPLSTR( "ho." ),
// "hon." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hor." ),
DEF_SPLSTR( "horol." ),
DEF_SPLSTR( "hort." ),
DEF_SPLSTR( "hosp." ),
DEF_SPLSTR( "hp." ),      // horsepower
DEF_SPLSTR( "hr." ),
DEF_SPLSTR( "ht." ),                                  // PaulCa 4/15/99 (Bug 108)
// "http." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hwy." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hyd." ),
DEF_SPLSTR( "hypoth." ),
DEF_SPLSTR( "i.a." ),
DEF_SPLSTR( "i.d." ),
DEF_SPLSTR( "i.e." ),  // Moved from titles.txt - edc 8/18/99
DEF_SPLSTR( "i.q." ),
DEF_SPLSTR( "i.w." ),
DEF_SPLSTR( "ib." ),
DEF_SPLSTR( "ibid." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ichth." ),
DEF_SPLSTR( "ign." ),
DEF_SPLSTR( "illus." ),
DEF_SPLSTR( "imit." ),
DEF_SPLSTR( "immun." ),
DEF_SPLSTR( "in." ),      // inch
DEF_SPLSTR( "inbd." ),
DEF_SPLSTR( "inc." ),
DEF_SPLSTR( "incl." ),
DEF_SPLSTR( "incog." ),
DEF_SPLSTR( "incr." ),
DEF_SPLSTR( "ind." ),
DEF_SPLSTR( "indef." ),
DEF_SPLSTR( "indic." ),
DEF_SPLSTR( "indn." ),
DEF_SPLSTR( "indus." ),
DEF_SPLSTR( "inf." ),
DEF_SPLSTR( "infin." ),
DEF_SPLSTR( "infl." ),
DEF_SPLSTR( "infs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "inj." ),
DEF_SPLSTR( "inq." ),
DEF_SPLSTR( "ins." ),
DEF_SPLSTR( "insol." ),
DEF_SPLSTR( "insp." ),
DEF_SPLSTR( "inst." ),
DEF_SPLSTR( "instr." ),
// "int'l." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "int." ),
DEF_SPLSTR( "inter." ),
DEF_SPLSTR( "interj." ),
DEF_SPLSTR( "interp." ),
DEF_SPLSTR( "interrog." ),
DEF_SPLSTR( "intl." ),
DEF_SPLSTR( "intr." ),
// "intro." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "inv." ),
DEF_SPLSTR( "irid." ),
DEF_SPLSTR( "irreg." ),
DEF_SPLSTR( "isl." ),
DEF_SPLSTR( "isth." ),
DEF_SPLSTR( "ital." ),
DEF_SPLSTR( "jct." ),
DEF_SPLSTR( "jnr." ),
DEF_SPLSTR( "jnt." ),
DEF_SPLSTR( "jour." ),
DEF_SPLSTR( "jr." ),
DEF_SPLSTR( "jt." ),
DEF_SPLSTR( "jun." ),
DEF_SPLSTR( "junc." ),
DEF_SPLSTR( "juv." ),
DEF_SPLSTR( "jwlr." ),
DEF_SPLSTR( "kc." ),
DEF_SPLSTR( "km." ),
DEF_SPLSTR( "kmh." ),
DEF_SPLSTR( "kn." ),
DEF_SPLSTR( "kr." ),
DEF_SPLSTR( "kt." ),
DEF_SPLSTR( "l." ),      // liter
DEF_SPLSTR( "l.c." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "l.c.d." ),
DEF_SPLSTR( "l.c.m." ),
DEF_SPLSTR( "l.t." ),
DEF_SPLSTR( "lang." ),
DEF_SPLSTR( "langs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "lat." ),
DEF_SPLSTR( "lav." ),
DEF_SPLSTR( "lb." ),
DEF_SPLSTR( "lbs." ),
DEF_SPLSTR( "ld." ),
DEF_SPLSTR( "ldg." ),
DEF_SPLSTR( "lea." ),
DEF_SPLSTR( "lect." ),
DEF_SPLSTR( "lectr." ),
DEF_SPLSTR( "legis." ),
DEF_SPLSTR( "lg." ),
DEF_SPLSTR( "lge." ),
DEF_SPLSTR( "li." ),
DEF_SPLSTR( "lieut." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "lim." ),
DEF_SPLSTR( "lin." ),
DEF_SPLSTR( "ling." ),
DEF_SPLSTR( "liq." ),
// "lit." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "lith." ),
DEF_SPLSTR( "litho." ),
DEF_SPLSTR( "lithog." ),
DEF_SPLSTR( "ll." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "loc." ),
// "loc. cit." ),
// "long." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "loq." ),
DEF_SPLSTR( "lt." ),
DEF_SPLSTR( "ltd." ),
DEF_SPLSTR( "ltda." ),
DEF_SPLSTR( "lv." ),
DEF_SPLSTR( "lyr." ),
DEF_SPLSTR( "m.d." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "m.f." ),
DEF_SPLSTR( "m.m." ),
DEF_SPLSTR( "m.o." ),
DEF_SPLSTR( "m.o.m." ),
DEF_SPLSTR( "m.p.g." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "m.p.h." ),
DEF_SPLSTR( "m.s.l." ),
DEF_SPLSTR( "m.t." ),
DEF_SPLSTR( "m.y." ),
DEF_SPLSTR( "mach." ),
DEF_SPLSTR( "mag." ),
DEF_SPLSTR( "manuf." ),
DEF_SPLSTR( "manufac." ),
DEF_SPLSTR( "marg." ),
DEF_SPLSTR( "masc." ),
// "max." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mc." ),
DEF_SPLSTR( "mdse." ),
DEF_SPLSTR( "meas." ),
DEF_SPLSTR( "mech." ),
DEF_SPLSTR( "med." ),
DEF_SPLSTR( "mer." ),
DEF_SPLSTR( "metall." ),
DEF_SPLSTR( "metaph." ),
DEF_SPLSTR( "mfd." ),
DEF_SPLSTR( "mfg." ),
DEF_SPLSTR( "mfr." ),
DEF_SPLSTR( "mfrs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mg." ),     // milligram
DEF_SPLSTR( "mgmt." ),
DEF_SPLSTR( "mgr." ),
DEF_SPLSTR( "mgrs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mgt." ),
DEF_SPLSTR( "mhz." ),
DEF_SPLSTR( "mi." ),
DEF_SPLSTR( "mid." ),
DEF_SPLSTR( "min." ),
DEF_SPLSTR( "misc." ),
DEF_SPLSTR( "mk." ),
DEF_SPLSTR( "mkt." ),
DEF_SPLSTR( "mktg." ),
DEF_SPLSTR( "ml." ),  // milliliter
DEF_SPLSTR( "mm." ),
DEF_SPLSTR( "mngr." ),
DEF_SPLSTR( "mo." ),
DEF_SPLSTR( "mol." ),
DEF_SPLSTR( "mon." ),
DEF_SPLSTR( "morph." ),
DEF_SPLSTR( "mos." ),
DEF_SPLSTR( "mph." ),
DEF_SPLSTR( "msec." ),
DEF_SPLSTR( "msg." ),
DEF_SPLSTR( "mt." ),
DEF_SPLSTR( "mtg." ),
DEF_SPLSTR( "mtge." ),
DEF_SPLSTR( "mtgs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mtn." ),
DEF_SPLSTR( "mts." ),
DEF_SPLSTR( "mus." ),
DEF_SPLSTR( "mxd." ),
DEF_SPLSTR( "myc." ),
DEF_SPLSTR( "mycol." ),
DEF_SPLSTR( "mythol." ),
DEF_SPLSTR( "n.b." ),
DEF_SPLSTR( "n.d." ),
DEF_SPLSTR( "n.e.s." ),
DEF_SPLSTR( "n.l." ),
DEF_SPLSTR( "n.m." ),
DEF_SPLSTR( "n.o.p." ),
DEF_SPLSTR( "n.o.s." ),
DEF_SPLSTR( "n.s." ),
DEF_SPLSTR( "n.s.f." ),
DEF_SPLSTR( "n.t.p." ),
DEF_SPLSTR( "n.wt." ),
DEF_SPLSTR( "nat." ),
DEF_SPLSTR( "natl." ),
DEF_SPLSTR( "naut." ),
DEF_SPLSTR( "nav." ),
DEF_SPLSTR( "ne." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "neg." ),
DEF_SPLSTR( "neur." ),
DEF_SPLSTR( "neurol." ),
DEF_SPLSTR( "neut." ),
DEF_SPLSTR( "no." ),                                  // special case handled in the code
DEF_SPLSTR( "nol." ),     // "nol. pros." ),
DEF_SPLSTR( "nom." ),
DEF_SPLSTR( "nos." ),
DEF_SPLSTR( "nt." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "nt.wt." ),
DEF_SPLSTR( "num." ),
DEF_SPLSTR( "numis." ),
DEF_SPLSTR( "nw." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "o.c." ),
DEF_SPLSTR( "o.d." ),
DEF_SPLSTR( "o.k." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "o.n.o." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "o.s." ),
DEF_SPLSTR( "o.t." ),
DEF_SPLSTR( "ob." ),
DEF_SPLSTR( "obj." ),
DEF_SPLSTR( "obl." ),
DEF_SPLSTR( "obs." ),
DEF_SPLSTR( "obstet." ),
DEF_SPLSTR( "oc." ),
DEF_SPLSTR( "occ." ),
DEF_SPLSTR( "occas." ),
DEF_SPLSTR( "oct." ),
DEF_SPLSTR( "op." ),
// L"op. cit." ),
DEF_SPLSTR( "opp." ),
DEF_SPLSTR( "opt." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "orch." ),
DEF_SPLSTR( "ord." ),
DEF_SPLSTR( "ordn." ),
DEF_SPLSTR( "org." ),
DEF_SPLSTR( "orig." ),
DEF_SPLSTR( "ornith." ),
DEF_SPLSTR( "orth." ),
DEF_SPLSTR( "otol." ),
DEF_SPLSTR( "oz" ),
DEF_SPLSTR( "oz." ),
DEF_SPLSTR( "p.a." ),
DEF_SPLSTR( "p.c." ),
DEF_SPLSTR( "p.d." ),
DEF_SPLSTR( "p.m." ),
DEF_SPLSTR( "p.n." ),
DEF_SPLSTR( "p.o." ),
DEF_SPLSTR( "p.o.e." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "p.p." ),
DEF_SPLSTR( "p.p.a." ),
DEF_SPLSTR( "p.q." ),
DEF_SPLSTR( "p.r." ),
DEF_SPLSTR( "p.r.n." ),
DEF_SPLSTR( "p.s." ),   // A bogus abbreviation for Post Scriptum. Also covers "P.S." and "P.s."
DEF_SPLSTR( "p.t." ),
DEF_SPLSTR( "p.t.o." ),
DEF_SPLSTR( "pam." ),
DEF_SPLSTR( "par." ),   // "cet. par."
DEF_SPLSTR( "paren." ),
DEF_SPLSTR( "parl." ),
// L"pat." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "patd." ),
// L"pats." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "payt." ),
DEF_SPLSTR( "pct." ),
DEF_SPLSTR( "pd." ),
DEF_SPLSTR( "per." ),
DEF_SPLSTR( "perp." ),
DEF_SPLSTR( "pers." ),
DEF_SPLSTR( "petr." ),
DEF_SPLSTR( "petrog." ),
DEF_SPLSTR( "pf." ),
DEF_SPLSTR( "pfd." ),
DEF_SPLSTR( "pfg." ),
DEF_SPLSTR( "pg." ),
DEF_SPLSTR( "ph." ),
DEF_SPLSTR( "phar." ),
DEF_SPLSTR( "pharm." ),
DEF_SPLSTR( "phil." ),
DEF_SPLSTR( "philos." ),
DEF_SPLSTR( "phon." ),
DEF_SPLSTR( "photog." ),
DEF_SPLSTR( "photom." ),
DEF_SPLSTR( "phr." ),
DEF_SPLSTR( "phren." ),
DEF_SPLSTR( "phys." ),
// L"phys. ed." ),
DEF_SPLSTR( "physiol." ),
DEF_SPLSTR( "pinx." ),
DEF_SPLSTR( "pizz." ),
DEF_SPLSTR( "pk." ),
DEF_SPLSTR( "pkg." ),
DEF_SPLSTR( "pkgs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pkt." ),
DEF_SPLSTR( "pl." ),
DEF_SPLSTR( "plf." ),
DEF_SPLSTR( "pln." ),
DEF_SPLSTR( "pls." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "plu." ),
DEF_SPLSTR( "pm." ),
DEF_SPLSTR( "pmk." ),
DEF_SPLSTR( "pmt." ),
DEF_SPLSTR( "pmts." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pneum." ),
DEF_SPLSTR( "pol." ),
DEF_SPLSTR( "polit." ),
DEF_SPLSTR( "por." ),
DEF_SPLSTR( "pos." ),
DEF_SPLSTR( "poss." ),
DEF_SPLSTR( "pp." ),
DEF_SPLSTR( "ppd." ),
DEF_SPLSTR( "pph." ),
DEF_SPLSTR( "ppt." ),
DEF_SPLSTR( "pptn." ),
DEF_SPLSTR( "pr." ),
DEF_SPLSTR( "prec." ),
DEF_SPLSTR( "pred." ),
DEF_SPLSTR( "pref." ),
DEF_SPLSTR( "prem." ),
// L"prep." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "prepd." ),
DEF_SPLSTR( "prepn." ),
DEF_SPLSTR( "preps." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pres." ),
DEF_SPLSTR( "pret." ),
DEF_SPLSTR( "prev." ),
DEF_SPLSTR( "prf." ),
DEF_SPLSTR( "prin." ),
DEF_SPLSTR( "priv." ),
DEF_SPLSTR( "prob." ),
DEF_SPLSTR( "probs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "proc." ),
// L"prod." ),                             // PaulCa 4/15/99 (Bug 108)
// L"prods." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "prof." ),
DEF_SPLSTR( "pron." ),
DEF_SPLSTR( "propr." ),
DEF_SPLSTR( "pros." ),
DEF_SPLSTR( "protec." ),
DEF_SPLSTR( "prov." ),
DEF_SPLSTR( "prox." ),
DEF_SPLSTR( "ps." ),  // A bogus abbreviation for Post Scriptum. Also covers "PS." and "Ps."
DEF_SPLSTR( "psec." ),
DEF_SPLSTR( "pseud." ),
DEF_SPLSTR( "psf." ),
DEF_SPLSTR( "pstg." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "psych." ),
DEF_SPLSTR( "psychol." ),
DEF_SPLSTR( "pt." ),
DEF_SPLSTR( "pta." ),
DEF_SPLSTR( "ptg." ),
DEF_SPLSTR( "pty." ),
// L"pub." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "publ." ),
// L"pubs." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pwr." ),
DEF_SPLSTR( "pwt." ),
DEF_SPLSTR( "pxt." ),
DEF_SPLSTR( "pyro." ),
// L"q. t." ),
DEF_SPLSTR( "q.b." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "q.i.d." ),
DEF_SPLSTR( "q.p." ),
DEF_SPLSTR( "q.s." ),
DEF_SPLSTR( "q.t." ),
DEF_SPLSTR( "q.v." ),
DEF_SPLSTR( "ql." ),
DEF_SPLSTR( "qlty." ),
DEF_SPLSTR( "qn." ),
DEF_SPLSTR( "qq." ),
DEF_SPLSTR( "qq.v." ),
DEF_SPLSTR( "qr." ),
DEF_SPLSTR( "qrs." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "qt." ),
DEF_SPLSTR( "qto." ),
DEF_SPLSTR( "qtr." ),   //
DEF_SPLSTR( "qtrs." ),  // Noah 2.0, bug #70: the first two qtrs. of CY 95
DEF_SPLSTR( "qty." ),
DEF_SPLSTR( "qu." ),
DEF_SPLSTR( "qual." ),
DEF_SPLSTR( "quant." ),
DEF_SPLSTR( "quar." ),
DEF_SPLSTR( "ques." ),
DEF_SPLSTR( "quot." ),
DEF_SPLSTR( "r.h." ),
DEF_SPLSTR( "r.i.p." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "r.n." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "r.o.t.c." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rad." ),
DEF_SPLSTR( "rcpt." ),
DEF_SPLSTR( "rct." ),
DEF_SPLSTR( "rd." ),
DEF_SPLSTR( "rec." ),
// L"rec. sec." ),
DEF_SPLSTR( "recd." ),
DEF_SPLSTR( "recip." ),
DEF_SPLSTR( "recs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rect." ),
// L"red." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ref." ),
DEF_SPLSTR( "refl." ),
// L"refs." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "reg." ),
DEF_SPLSTR( "regd." ),
DEF_SPLSTR( "regt." ),
DEF_SPLSTR( "rel." ),
DEF_SPLSTR( "rem." ),
DEF_SPLSTR( "rep." ),
DEF_SPLSTR( "repl." ),
// L"reps." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rept." ),
DEF_SPLSTR( "req." ),
DEF_SPLSTR( "reqd." ),
DEF_SPLSTR( "res." ),
DEF_SPLSTR( "resp." ),
DEF_SPLSTR( "ret." ),
DEF_SPLSTR( "rev." ),
DEF_SPLSTR( "rf." ),
DEF_SPLSTR( "rhbdr." ),
DEF_SPLSTR( "rheo." ),
DEF_SPLSTR( "rhet." ),
DEF_SPLSTR( "rhomb." ),
DEF_SPLSTR( "rit." ),
DEF_SPLSTR( "riv." ),
DEF_SPLSTR( "rm." ),
DEF_SPLSTR( "rms." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rnd." ),
DEF_SPLSTR( "ro." ),
DEF_SPLSTR( "rom." ),
DEF_SPLSTR( "rpt." ),
DEF_SPLSTR( "rt." ),
DEF_SPLSTR( "rte." ),
DEF_SPLSTR( "rtes." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rul." ),
DEF_SPLSTR( "rwy." ),
DEF_SPLSTR( "ry." ),
DEF_SPLSTR( "s.a." ),
DEF_SPLSTR( "s.ap." ),
DEF_SPLSTR( "s.b." ),
DEF_SPLSTR( "s.d." ),
DEF_SPLSTR( "s.l." ),
DEF_SPLSTR( "s.l.a.n." ),
DEF_SPLSTR( "s.n." ),
DEF_SPLSTR( "s.o." ),
DEF_SPLSTR( "s.p." ),
DEF_SPLSTR( "s.p.a." ),
DEF_SPLSTR( "s.p.s." ),
DEF_SPLSTR( "s.t." ),
DEF_SPLSTR( "s.w.a.t." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "sanit." ),
DEF_SPLSTR( "satd." ),
DEF_SPLSTR( "sb." ),
DEF_SPLSTR( "sc." ),
DEF_SPLSTR( "sch." ),
DEF_SPLSTR( "sci." ),
DEF_SPLSTR( "scr." ),
DEF_SPLSTR( "sculp." ),
DEF_SPLSTR( "sd." ),
DEF_SPLSTR( "se." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "sec." ),
DEF_SPLSTR( "sect." ),                                // special case
DEF_SPLSTR( "secy." ),
DEF_SPLSTR( "sed." ),
DEF_SPLSTR( "sel." ),
DEF_SPLSTR( "sem." ),
DEF_SPLSTR( "sen." ),
DEF_SPLSTR( "sep." ),
DEF_SPLSTR( "sepd." ),
DEF_SPLSTR( "seq." ),
DEF_SPLSTR( "seqq." ),
DEF_SPLSTR( "ser." ),
DEF_SPLSTR( "serv." ),
DEF_SPLSTR( "sess." ),
DEF_SPLSTR( "sf." ),
DEF_SPLSTR( "sfz." ),
DEF_SPLSTR( "sgd." ),
DEF_SPLSTR( "sh." ),
DEF_SPLSTR( "shpt." ),
DEF_SPLSTR( "shpts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "shr." ),
DEF_SPLSTR( "sht." ),
DEF_SPLSTR( "sig." ),
// L"sing." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "sk." ),
DEF_SPLSTR( "sl." ),
DEF_SPLSTR( "sld." ),
DEF_SPLSTR( "sm." ),
DEF_SPLSTR( "soc." ),
DEF_SPLSTR( "sol." ),
DEF_SPLSTR( "soln." ),
DEF_SPLSTR( "soph." ),
DEF_SPLSTR( "sou." ),
DEF_SPLSTR( "sp." ),
DEF_SPLSTR( "spec." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "specif." ),
DEF_SPLSTR( "spp." ),
DEF_SPLSTR( "spr." ),
DEF_SPLSTR( "spt." ),
DEF_SPLSTR( "sq." ),
DEF_SPLSTR( "sr." ),
DEF_SPLSTR( "ss." ),
DEF_SPLSTR( "ssp." ),
DEF_SPLSTR( "st." ),
DEF_SPLSTR( "sta." ),
DEF_SPLSTR( "stacc." ),
DEF_SPLSTR( "stat." ),
DEF_SPLSTR( "stbd." ),
DEF_SPLSTR( "std." ),
DEF_SPLSTR( "sten." ),
DEF_SPLSTR( "stenog." ),
DEF_SPLSTR( "ster." ),
DEF_SPLSTR( "stg." ),
DEF_SPLSTR( "stge." ),
DEF_SPLSTR( "stip." ),
DEF_SPLSTR( "stk." ),
DEF_SPLSTR( "stmt." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "stmts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "str." ),
// L"sub." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "subj." ),
DEF_SPLSTR( "subjs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "subs." ),
DEF_SPLSTR( "subsp." ),
DEF_SPLSTR( "subst." ),
DEF_SPLSTR( "suf." ),
DEF_SPLSTR( "suff." ),
DEF_SPLSTR( "supp." ),
DEF_SPLSTR( "suppl." ),
DEF_SPLSTR( "supr." ),
DEF_SPLSTR( "supt." ),
DEF_SPLSTR( "supvr." ),
DEF_SPLSTR( "sur." ),
DEF_SPLSTR( "surg." ),
DEF_SPLSTR( "surr." ),
DEF_SPLSTR( "svgs." ),
DEF_SPLSTR( "sw." ),
DEF_SPLSTR( "syl." ),
DEF_SPLSTR( "syll." ),
DEF_SPLSTR( "sym." ),
DEF_SPLSTR( "syn." ),
DEF_SPLSTR( "synd." ),
DEF_SPLSTR( "syst." ),
DEF_SPLSTR( "t.b." ),
DEF_SPLSTR( "t.g." ),
DEF_SPLSTR( "t.i.d." ),
DEF_SPLSTR( "t.l." ),
DEF_SPLSTR( "t.l.o." ),
DEF_SPLSTR( "t.m." ),
DEF_SPLSTR( "t.o." ),
DEF_SPLSTR( "t.p." ),
DEF_SPLSTR( "tab." ),
DEF_SPLSTR( "tbs." ),
DEF_SPLSTR( "tbsp." ),
DEF_SPLSTR( "tchr." ),
DEF_SPLSTR( "tec." ),
DEF_SPLSTR( "tech." ),
DEF_SPLSTR( "technol." ),
DEF_SPLSTR( "tel." ),
DEF_SPLSTR( "teleg." ),
// L"temp." ),                             // PaulCa 4/15/99 (Bug 108)
// L"temps." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ter." ),
DEF_SPLSTR( "terr." ),
DEF_SPLSTR( "tfr." ),
DEF_SPLSTR( "tgt." ),
DEF_SPLSTR( "theat." ),
DEF_SPLSTR( "theol." ),
DEF_SPLSTR( "therap." ),
DEF_SPLSTR( "therm." ),
DEF_SPLSTR( "tinct." ),
DEF_SPLSTR( "tk." ),
DEF_SPLSTR( "tkt." ),
DEF_SPLSTR( "tlr." ),
DEF_SPLSTR( "tn." ),
DEF_SPLSTR( "tng." ),
DEF_SPLSTR( "tnpk." ),
DEF_SPLSTR( "topog." ),
DEF_SPLSTR( "tp." ),
DEF_SPLSTR( "tpk." ),
DEF_SPLSTR( "tr." ),
DEF_SPLSTR( "trans." ),
DEF_SPLSTR( "transf." ),
DEF_SPLSTR( "transl." ),
DEF_SPLSTR( "transp." ),
DEF_SPLSTR( "trav." ),
DEF_SPLSTR( "treas." ),
DEF_SPLSTR( "trib." ),
DEF_SPLSTR( "trigon." ),
DEF_SPLSTR( "tripl." ),
DEF_SPLSTR( "trop." ),
DEF_SPLSTR( "trp." ),
DEF_SPLSTR( "tsp." ),
DEF_SPLSTR( "twp." ),
DEF_SPLSTR( "typ." ),
DEF_SPLSTR( "u.c." ),
DEF_SPLSTR( "u.p.s." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "u.s." ),
DEF_SPLSTR( "u.s.a." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ult." ),
DEF_SPLSTR( "unan." ),
DEF_SPLSTR( "unb." ),
DEF_SPLSTR( "unbd." ),
DEF_SPLSTR( "univ." ),
DEF_SPLSTR( "unp." ),
DEF_SPLSTR( "uns." ),
DEF_SPLSTR( "urol." ),
DEF_SPLSTR( "usu." ),
DEF_SPLSTR( "util." ),
DEF_SPLSTR( "ux." ),
DEF_SPLSTR( "v.d." ),
DEF_SPLSTR( "v.i." ),
DEF_SPLSTR( "v.s." ),
DEF_SPLSTR( "v.v." ),
DEF_SPLSTR( "vac." ),
DEF_SPLSTR( "val." ),
DEF_SPLSTR( "var." ),
DEF_SPLSTR( "vars." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "vb." ),
DEF_SPLSTR( "vbs." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "veg." ),
DEF_SPLSTR( "vel." ),
DEF_SPLSTR( "ver." ),
DEF_SPLSTR( "vert." ),
DEF_SPLSTR( "veter." ),
DEF_SPLSTR( "vic." ),
DEF_SPLSTR( "vil." ),
DEF_SPLSTR( "vis." ),
DEF_SPLSTR( "viz." ),
DEF_SPLSTR( "vo." ),
DEF_SPLSTR( "voc." ),
DEF_SPLSTR( "vocab." ),
DEF_SPLSTR( "vol." ),
DEF_SPLSTR( "vols." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "vou." ),
DEF_SPLSTR( "vs." ), // Moved from titles.txt - edc 8/18/99
DEF_SPLSTR( "vss." ),
DEF_SPLSTR( "vulg." ),
DEF_SPLSTR( "vv." ),
DEF_SPLSTR( "w.b." ),
DEF_SPLSTR( "w.f." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "w.g." ),
DEF_SPLSTR( "w.i." ),
DEF_SPLSTR( "w.l." ),
DEF_SPLSTR( "w.o.c." ),
DEF_SPLSTR( "w.p.m." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "wd." ),
DEF_SPLSTR( "wh." ),
DEF_SPLSTR( "whf." ),
DEF_SPLSTR( "whs." ),
DEF_SPLSTR( "whsle." ),
DEF_SPLSTR( "wid." ),
DEF_SPLSTR( "wk." ),
DEF_SPLSTR( "wkly." ),
DEF_SPLSTR( "wm." ),
DEF_SPLSTR( "wmk." ),
DEF_SPLSTR( "wpn." ),
DEF_SPLSTR( "wrnt." ),
DEF_SPLSTR( "wt." ),
DEF_SPLSTR( "x-div." ),
DEF_SPLSTR( "x-int." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "yd." ),
DEF_SPLSTR( "yel." ),
DEF_SPLSTR( "yeo." ),
DEF_SPLSTR( "yr." ),
DEF_SPLSTR( "yrs." ),
DEF_SPLSTR( "zool." ),
};

// This is an alphabetized list of all non-proper-noun words which
// appear within the list of the 200 most frequent first words
// in sentences in both the Brown and WSJ corpora.
static const SPLSTR g_FirstWords[] =
{
DEF_SPLSTR( "A" ),
DEF_SPLSTR( "About" ),
DEF_SPLSTR( "According" ),
DEF_SPLSTR( "After" ),
DEF_SPLSTR( "Again" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "All" ),
DEF_SPLSTR( "Also" ),
DEF_SPLSTR( "Although" ),
//L"American" ),                             // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Among" ),
DEF_SPLSTR( "An" ),
DEF_SPLSTR( "And" ),
DEF_SPLSTR( "Another" ),
DEF_SPLSTR( "Any" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Anyway" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Are" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "As" ),
DEF_SPLSTR( "At" ),
DEF_SPLSTR( "Back" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Because" ),
DEF_SPLSTR( "Before" ),
DEF_SPLSTR( "Besides" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Both" ),
DEF_SPLSTR( "But" ),
DEF_SPLSTR( "By" ),
DEF_SPLSTR( "Can" ),                                  // PaulCa added 4/14/99 (Bug 107)
//L"Click" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Consequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Dear" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Despite" ),
DEF_SPLSTR( "Did" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Do" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Does" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Don't" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "During" ),
DEF_SPLSTR( "Each" ),
DEF_SPLSTR( "Early" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Even" ),
DEF_SPLSTR( "Every" ),                                // PaulCa added 4/14/99 (Bug 107)
//L"Executive" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Finally" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "First" ),
DEF_SPLSTR( "Following" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "For" ),
//L"Founded" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Four" ),
DEF_SPLSTR( "From" ),
DEF_SPLSTR( "Further" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Furthermore" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Generally" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Given" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Go" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Great" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Had" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Have" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Having" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "He" ),
DEF_SPLSTR( "Her" ),
DEF_SPLSTR( "Here" ),
DEF_SPLSTR( "His" ),
DEF_SPLSTR( "How" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "However" ),
DEF_SPLSTR( "I" ),
DEF_SPLSTR( "If" ),
DEF_SPLSTR( "In" ),
DEF_SPLSTR( "Indeed" ),
//L"Industrial" ),                           // PaulCa added 4/14/99 (Bug 107)
//L"Information" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Initially" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Instead" ),
DEF_SPLSTR( "Is" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "It" ),
DEF_SPLSTR( "Its" ),
DEF_SPLSTR( "Just" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"King" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Last" ),
DEF_SPLSTR( "Later" ),
DEF_SPLSTR( "Let" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Like" ),
//L"Little" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Many" ),
DEF_SPLSTR( "Maybe" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Meanwhile" ),
DEF_SPLSTR( "More" ),
DEF_SPLSTR( "Moreover" ),
DEF_SPLSTR( "Most" ),
DEF_SPLSTR( "Much" ),
DEF_SPLSTR( "My" ),    // Added to fix bug #385
DEF_SPLSTR( "Neither" ),
DEF_SPLSTR( "Never" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nevertheless" ),
DEF_SPLSTR( "New" ),
DEF_SPLSTR( "Next" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "No" ),
DEF_SPLSTR( "None" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nonetheless" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nor" ),
DEF_SPLSTR( "Not" ),
DEF_SPLSTR( "Nothing" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Now" ),
DEF_SPLSTR( "Of" ),
DEF_SPLSTR( "On" ),
DEF_SPLSTR( "Once" ),
DEF_SPLSTR( "One" ),
DEF_SPLSTR( "Only" ),
DEF_SPLSTR( "Or" ),
DEF_SPLSTR( "Other" ),
DEF_SPLSTR( "Others" ),
DEF_SPLSTR( "Our" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Over" ),
DEF_SPLSTR( "People" ),
DEF_SPLSTR( "Perhaps" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Please" ),                               // PaulCa added 4/14/99 (Bug 107)
//L"President" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Previous" ),                             // PaulCa added 4/14/99 (Bug 107)
//L"Public" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Recent" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Right" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Second" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "See" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Several" ),
DEF_SPLSTR( "She" ),
DEF_SPLSTR( "Shortly" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Similarly" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Since" ),
DEF_SPLSTR( "So" ),
DEF_SPLSTR( "Some" ),
DEF_SPLSTR( "Sometimes" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Soon" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"Special" ),                              // PaulCa added 4/14/99 (Bug 107)
//L"State" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Still" ),
DEF_SPLSTR( "Subsequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Such" ),
DEF_SPLSTR( "Take" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "That" ),
DEF_SPLSTR( "The" ),
DEF_SPLSTR( "Their" ),
DEF_SPLSTR( "Then" ),
DEF_SPLSTR( "There" ),
DEF_SPLSTR( "Thereafter" ),                           // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Therefore" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "These" ),
DEF_SPLSTR( "They" ),
DEF_SPLSTR( "This" ),
DEF_SPLSTR( "Those" ),
DEF_SPLSTR( "Though" ),
DEF_SPLSTR( "Three" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Through" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Thus" ),
DEF_SPLSTR( "To" ),
DEF_SPLSTR( "Today" ),
DEF_SPLSTR( "Two" ),
DEF_SPLSTR( "Under" ),
//L"United" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Unlike" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Until" ),
DEF_SPLSTR( "Upon" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"Water" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "We" ),
DEF_SPLSTR( "Well" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"West" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "What" ),
DEF_SPLSTR( "When" ),
DEF_SPLSTR( "Where" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Whether" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Which" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "While" ),
//L"White" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Who" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Why" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Will" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "With" ),
DEF_SPLSTR( "Within" ),
DEF_SPLSTR( "Without" ),                              // PaulCa added 4/14/99 (Bug 107)
//L"Women" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yes" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yet" ),
DEF_SPLSTR( "You" ),
DEF_SPLSTR( "Your" ),
};

// When the following abbreviations are followed by an uppercase word, 
// it is unlikely that the uppercase word starts a new sentence.
// 
static const SPLSTR g_Titles[] =
{
DEF_SPLSTR( "Adm." ),
DEF_SPLSTR( "Atty." ),
DEF_SPLSTR( "Bn." ),
DEF_SPLSTR( "Bt." ),
DEF_SPLSTR( "Btss." ),
DEF_SPLSTR( "C.G." ),
DEF_SPLSTR( "Capt." ),
DEF_SPLSTR( "Cdr." ),
DEF_SPLSTR( "Cf." ),  // See "cf." below
DEF_SPLSTR( "Chi." ), // Mr.(?) in India
DEF_SPLSTR( "Col." ),
DEF_SPLSTR( "Com." ),
DEF_SPLSTR( "Comdr." ),
DEF_SPLSTR( "Cpl." ),
DEF_SPLSTR( "Cpt." ),
DEF_SPLSTR( "Ct." ),
DEF_SPLSTR( "D.F." ),
DEF_SPLSTR( "Dr." ),
DEF_SPLSTR( "Drs." ),
DEF_SPLSTR( "Du." ),
DEF_SPLSTR( "E.g." ), // See "e.g." below
DEF_SPLSTR( "Esq." ),
DEF_SPLSTR( "Exc." ),
DEF_SPLSTR( "Fr." ),
DEF_SPLSTR( "Frl." ),
DEF_SPLSTR( "Gen." ),
DEF_SPLSTR( "Gov." ),
DEF_SPLSTR( "H.E." ),
DEF_SPLSTR( "H.H." ),
DEF_SPLSTR( "H.I.H." ),
DEF_SPLSTR( "H.I.M." ),
DEF_SPLSTR( "H.M." ),
DEF_SPLSTR( "H.R.H." ),
DEF_SPLSTR( "H.S.H." ),
DEF_SPLSTR( "Hon." ),
DEF_SPLSTR( "Hr." ),
DEF_SPLSTR( "I.e." ), // See "i.e." below
DEF_SPLSTR( "Km." ),  // Mr. or Ms. (?) in India
DEF_SPLSTR( "L.Cpl." ),
DEF_SPLSTR( "Ld." ),
DEF_SPLSTR( "Lt." ),
DEF_SPLSTR( "M.M." ),
DEF_SPLSTR( "M.Sgt." ),
DEF_SPLSTR( "Maj." ),
DEF_SPLSTR( "Mdm." ),
DEF_SPLSTR( "Messrs." ),
DEF_SPLSTR( "Mgr." ),
DEF_SPLSTR( "Mgrs." ),
DEF_SPLSTR( "Mlle." ),
DEF_SPLSTR( "Mlles." ),
DEF_SPLSTR( "Mme." ),
DEF_SPLSTR( "Mmes." ),
DEF_SPLSTR( "Mr." ),
DEF_SPLSTR( "Mrs." ),
DEF_SPLSTR( "Ms." ),
DEF_SPLSTR( "Msgr." ),
DEF_SPLSTR( "PFC." ),  // Private First Class // Sometimes used with a period
DEF_SPLSTR( "Pfc." ),
DEF_SPLSTR( "Pr." ),
DEF_SPLSTR( "Pres." ),
DEF_SPLSTR( "Prof." ),
DEF_SPLSTR( "R.A." ),
DEF_SPLSTR( "R.R." ),
DEF_SPLSTR( "R.W." ),
DEF_SPLSTR( "Rep." ),
DEF_SPLSTR( "Reps." ),
DEF_SPLSTR( "Rev." ),
DEF_SPLSTR( "S.M.Sgt." ),
DEF_SPLSTR( "S.Sgt." ),
DEF_SPLSTR( "Sen." ),
DEF_SPLSTR( "Sens." ),
DEF_SPLSTR( "Sgt." ),
DEF_SPLSTR( "Sgt.Maj." ),
DEF_SPLSTR( "Smt." ),     // Mr. or Ms. (?) in India
DEF_SPLSTR( "Sow." ),     // Mrs. or Ms. (?) in India
DEF_SPLSTR( "Sr." ),
DEF_SPLSTR( "Sra." ),
DEF_SPLSTR( "Srta." ),
DEF_SPLSTR( "St." ),
DEF_SPLSTR( "Supt." ),
DEF_SPLSTR( "T.Sgt." ),
DEF_SPLSTR( "V.A." ),
DEF_SPLSTR( "V.Adm." ),
DEF_SPLSTR( "Ven." ),
DEF_SPLSTR( "Vis." ),
DEF_SPLSTR( "Visct." ),
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\perfmon.cpp ===
// TODO: Move this to utility library.

#include "stdafx.h"
#include "perfmon.h"
#include <stdlib.h>
#include <stdio.h>
#include <spdebug.h>

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);


DWORD CPerfCounterManager::Init(char * mapname, __int32 cCountersPerObject, __int32 cObjectsMax)
{
    if (m_pbSharedMem)
        ERROR_SUCCESS;    // already inited.

    m_cCountersPerObject = cCountersPerObject;
    m_cObjectsMax = cObjectsMax;
    m_cbPerCounterBlock = sizeof(PERF_COUNTER_BLOCK) + m_cCountersPerObject * sizeof(ULONG);
    m_cbPerInstance = sizeof(PerfInstanceHeader) + m_cCountersPerObject * sizeof(ULONG);

    // open/create shared memory used by the application to pass performance values
    DWORD  MemStatus;

    SetLastError (ERROR_SUCCESS);   // just to clear it out
    m_hSharedMem = CreateFileMapping(
                                     (HANDLE)0xFFFFFFFF,                 // to create a temp file
                                     NULL,                               // no security
                                     PAGE_READWRITE,                     // to allow read & write access
                                     0,                                  // file size (high dword)
                                     cObjectsMax * m_cbPerInstance,      // file size (low dword)
                                     mapname);                           // object name

    // return error if unsuccessful
    if (m_hSharedMem == NULL)
        return GetLastError();

    MemStatus = GetLastError();    // to see if this is the first opening

    m_pbSharedMem = (unsigned __int8 *) MapViewOfFile(
                                            m_hSharedMem,     // shared mem handle
                                            FILE_MAP_WRITE,   // access desired
                                            0,                // starting offset
                                            0,
                                            0);               // map the entire object
    if (m_pbSharedMem == NULL)
        return GetLastError();

    if (MemStatus != ERROR_ALREADY_EXISTS)
    {
        // New file.  Clear it out.
        // BUGBUG: Should really protect this with mutex, I guess.
        memset (m_pbSharedMem, 0, m_cObjectsMax * m_cbPerInstance);
    }

    return ERROR_SUCCESS;
}


DWORD CPerfCounterManager::Open(LPWSTR lpDeviceNames, char * appname, PerfObject * ppo, PerfCounter * apc)
{
    SPDBG_ASSERT(m_pbSharedMem);   // Caller should have already called Init()

    HKEY     hKeyDriverPerf;
    DWORD    dwFirstCounter;
    DWORD    dwFirstHelp;
    char     ach[256];
    LONG     status;
    DWORD    size;
    DWORD    type;

    sprintf(ach, "SYSTEM\\CurrentControlSet\\Services\\%s\\Performance", appname);

    status = RegOpenKeyEx (
                           HKEY_LOCAL_MACHINE,
                           ach,
                           0L,
                           KEY_ALL_ACCESS,
                           &hKeyDriverPerf);
    if (status != ERROR_SUCCESS)
        return status;

    size = sizeof (DWORD);
    status = RegQueryValueEx(
                             hKeyDriverPerf,
                             "First Counter",
                             0L,
                             &type,
                             (LPBYTE)&dwFirstCounter,
                             &size);
    if (status != ERROR_SUCCESS)
        return status;

    size = sizeof (DWORD);
    status = RegQueryValueEx(
                             hKeyDriverPerf,
                             "First Help",
                             0L,
                             &type,
                             (LPBYTE)&dwFirstHelp,
                             &size);

    if (status != ERROR_SUCCESS)
        return status;

    PERF_OBJECT_TYPE        pot;
    PERF_COUNTER_DEFINITION pcd;

    pot.TotalByteLength = 0;  // Filled in later by Collect()
    pot.DefinitionLength = sizeof(pot) + m_cCountersPerObject * sizeof(pcd);
    pot.HeaderLength = sizeof(pot);
    pot.ObjectNameTitleIndex = ppo->ObjectNameTitleIndex + dwFirstCounter;
    pot.ObjectNameTitle = NULL;
    pot.ObjectHelpTitleIndex = ppo->ObjectNameTitleIndex + dwFirstHelp;     // For now assume name/help same
    pot.ObjectHelpTitle = NULL;
    pot.DetailLevel = ppo->DetailLevel;
    pot.NumCounters = m_cCountersPerObject;
    pot.DefaultCounter = ppo->DefaultCounter;
    pot.NumInstances = -1;        // Filled in later by Collect()
    pot.CodePage = 0;             // Instance names are in Unicode (they don't exist, yet)
    pot.PerfTime = ppo->PerfTime;
    pot.PerfFreq = ppo->PerfFreq;

    if (!m_accumHeader.Accumulate(&pot, sizeof(pot)))
        return ERROR_OUTOFMEMORY;

    pcd.ByteLength = sizeof(pcd);
    pcd.CounterNameTitle = NULL;
    pcd.CounterHelpTitle = NULL;
    pcd.CounterSize = sizeof(DWORD);

    for (unsigned __int32 i = 0; i < m_cCountersPerObject; ++i)
    {
        SPDBG_ASSERT(apc[i].CounterNameTitleIndex == i * 2 + 2);

        pcd.CounterNameTitleIndex = apc[i].CounterNameTitleIndex + dwFirstCounter;
        pcd.CounterHelpTitleIndex = apc[i].CounterNameTitleIndex + dwFirstHelp;    // For now assume same as name.
        pcd.DefaultScale = apc[i].DefaultScale;
        pcd.DetailLevel = apc[i].DetailLevel;
        pcd.CounterType = apc[i].CounterType;
        pcd.CounterOffset = sizeof(PERF_COUNTER_BLOCK) + i * sizeof(DWORD);

        if (!m_accumHeader.Accumulate(&pcd, sizeof(pcd)))
            return ERROR_OUTOFMEMORY;
    }

    // BUGBUG Check Last Counter in registry to make sure lodctr's been run on the most recent file.

    m_ppot = (PERF_OBJECT_TYPE *) m_accumHeader.Buffer();

    return ERROR_SUCCESS;
}


DWORD CPerfCounterManager::Collect(LPWSTR lpwszValue, LPVOID *lppData, LPDWORD lpcbBytes, LPDWORD lpcObjectTypes)
{
    ULONG       SpaceNeeded;
    DWORD       dwQueryType;
    unsigned __int8 *     pbOutput;
    int         cInstances = 0;

    // before doing anything else, see if Open went OK
    if (m_pbSharedMem == NULL || m_ppot == NULL) {
        *lpcbBytes = (DWORD) 0;
        *lpcObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    dwQueryType = GetQueryType(lpwszValue);

    if (dwQueryType == QUERY_FOREIGN) {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbBytes = (DWORD) 0;
        *lpcObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS) {
        if ( !(IsNumberInUnicodeList(m_ppot->ObjectNameTitleIndex, lpwszValue))) {
            // request received for data object not provided by this routine
            *lpcbBytes = (DWORD) 0;
            *lpcObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pbOutput = (unsigned __int8 *) *lppData;
    SpaceNeeded = m_accumHeader.Size();

    if (*lpcbBytes < SpaceNeeded) {
ErrorMoreData:
        // not enough room so return nothing.
        *lpcbBytes = (DWORD) 0;
        *lpcObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    // copy the object & counter definition information
    memmove(pbOutput, m_accumHeader.Buffer(), m_accumHeader.Size());
    pbOutput += m_accumHeader.Size();

    // Run through the shared memory and accumulate counters for active object instances.
    for (unsigned __int32 i = 0; i < m_cObjectsMax; ++i)
    {
        PerfInstanceHeader * ppih = (PerfInstanceHeader *) (m_pbSharedMem + i * m_cbPerInstance);

        // Active instances have non-zero ByteLength.
        if (ppih->fInUse)
        {
            if (GetProcessVersion(ppih->dwPID) == 0)
            {
                // This means the owning process of this instance has died.
                FreeInstance(i);
                continue;
            }

            PERF_INSTANCE_DEFINITION   pid;

            SpaceNeeded += sizeof(pid) + 4 + m_cbPerCounterBlock;
            if (*lpcbBytes < SpaceNeeded)
                goto ErrorMoreData;

            // Build object instance block for this instance.
            pid.ByteLength = sizeof(pid) + 4;
            pid.ParentObjectTitleIndex = 0;
            pid.ParentObjectInstance = 0;
            pid.UniqueID = i + 1;
            pid.NameOffset = sizeof(pid);
            pid.NameLength = 4;

            memcpy(pbOutput, &pid, sizeof(pid));
            pbOutput += sizeof(pid);

            // Null terminate instance name.
            // TODO: Should use wsprintf or something for number.
            *pbOutput++ = '0' + i;
            *pbOutput++ = 0;
            *pbOutput++ = 0;
            *pbOutput++ = 0;

            PERF_COUNTER_BLOCK pcb;
            pcb.ByteLength = m_cbPerCounterBlock;

            memcpy(pbOutput, &pcb, sizeof(PERF_COUNTER_BLOCK));
            pbOutput += sizeof(PERF_COUNTER_BLOCK);

            memcpy(pbOutput, (BYTE *) ppih + sizeof(PerfInstanceHeader), m_cCountersPerObject * sizeof(ULONG));
            pbOutput += m_cCountersPerObject * sizeof(ULONG);

            // setup for the next instance
            ++cInstances;
        }
    }

    if (cInstances == 0)
    {
        // always return an "instance sized" buffer after the definition blocks
        // to prevent perfmon from reading bogus data. This is strictly a hack
        // to accomodate how PERFMON handles the "0" instance case.
        //  By doing this, perfmon won't choke when there are no instances
        //  and the counter object & counters will be displayed in the
        //  list boxes, even though no instances will be listed.

        SpaceNeeded += sizeof(PERF_INSTANCE_DEFINITION) + m_cbPerCounterBlock;
        if (*lpcbBytes < SpaceNeeded)
            goto ErrorMoreData;

        memset(pbOutput, 0, sizeof(PERF_INSTANCE_DEFINITION) + m_cbPerCounterBlock);
        pbOutput += sizeof(PERF_INSTANCE_DEFINITION) + m_cbPerCounterBlock;
    }

    // Fill in lengths in output buffer.
    PERF_OBJECT_TYPE * ppot = (PERF_OBJECT_TYPE *) *lppData;
    ppot->NumInstances = cInstances;
    ppot->TotalByteLength = SpaceNeeded;

    // update arguments for return
    SPDBG_ASSERT(pbOutput == (unsigned __int8 *) *lppData + SpaceNeeded);
    *lppData = pbOutput;
    *lpcObjectTypes = 1;
    *lpcbBytes = SpaceNeeded;

    return ERROR_SUCCESS;
}


DWORD CPerfCounterManager::Close()
{
    return ERROR_SUCCESS;
}


CPerfCounterManager::~CPerfCounterManager()
{
    if (m_pbSharedMem)
    {
        UnmapViewOfFile(m_pbSharedMem);
    }
    
    if (m_hSharedMem)
    {
        CloseHandle(m_hSharedMem);
    }
}


CPerfCounterManager::AllocInstance()
{
    // BUGBUG: Oughta be a mutex or something here...
    for (unsigned __int32 i = 0; i < m_cObjectsMax; ++i)
    {
        PerfInstanceHeader * ppih = (PerfInstanceHeader *) (m_pbSharedMem + i * m_cbPerInstance);

        if (!ppih->fInUse)
        {
            memset((unsigned __int8 *) ppih + sizeof(*ppih), 0, m_cCountersPerObject * sizeof(DWORD));
            ppih->dwPID = GetCurrentProcessId();
            ppih->fInUse = true;
            return i;
        }
    }

    // TODO: Attempt to grow file, remove compile-time limit.

    return -1;
}


void
CPerfCounterManager::FreeInstance(__int32 iInstance)
{
    PerfInstanceHeader * ppih = (PerfInstanceHeader *) (m_pbSharedMem + iInstance * m_cbPerInstance);

    // Active instances have non-zero ByteLength.
    SPDBG_ASSERT(ppih->fInUse);

    ppih->fInUse = false;
}


void
CPerfCounterObject::IncrementCounter(PERFC perfc)
{
    if (m_ppcm)
    {
        // For now, use the symbol offset from the perfsym.h file as the perfc type.
        // Since those grow by twos, we need to divide to get index into array.
        ++ * (DWORD *) (m_ppcm->m_pbSharedMem + m_iInstance * m_ppcm->m_cbPerInstance + sizeof(PerfInstanceHeader) + ((perfc / 2) - 1) * sizeof(DWORD));
    }
}


void
CPerfCounterObject::SetCounter(PERFC perfc, __int32 value)
{
    if (m_ppcm)
    {
        * (DWORD *) (m_ppcm->m_pbSharedMem + m_iInstance * m_ppcm->m_cbPerInstance + sizeof(PerfInstanceHeader) + ((perfc / 2) - 1) * sizeof(DWORD)) = value;
    }
}


bool
CPerfCounterObject::Init(CPerfCounterManager * ppcm)
{
    SPDBG_ASSERT(m_ppcm == NULL);

    if ((m_iInstance = ppcm->AllocInstance()) >= 0)
    {
        m_ppcm = ppcm;
        return true;
    }

    return false;
}


CPerfCounterObject::~CPerfCounterObject()
{
    if (m_ppcm)
        m_ppcm->FreeInstance(m_iInstance);
}



// Grody utility fns from SDk sample.
WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
                           (c == d) ? DELIMITER : \
                           (c == 0) ? DELIMITER : \
                           (c < (WCHAR)'0') ? INVALID : \
                           (c > (WCHAR)'9') ? INVALID : \
                           DIGIT)

DWORD
GetQueryType (
              IN LPWSTR lpValue
              )
/*++

 GetQueryType

     returns the type of query described in the lpValue string so that
     the appropriate processing method may be used

 Arguments

     IN lpValue
         string passed to PerfRegQuery Value for processing

 Return Value

     QUERY_GLOBAL
         if lpValue == 0 (null pointer)
         lpValue == pointer to Null string
         lpValue == pointer to "Global" string

     QUERY_FOREIGN
         if lpValue == pointer to "Foriegn" string

     QUERY_COSTLY
         if lpValue == pointer to "Costly" string

     QUERY_ITEMS
         otherwise
 --*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
                       IN DWORD   dwNumber,
                       IN LPWSTR  lpwszUnicodeList
                       )
/*++

 IsNumberInUnicodeList

 Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

 Return Value:

    TRUE:
        dwNumber was found in the list of unicode number strings

    FALSE:
        dwNumber was not found in the list.
 --*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
        case DIGIT:
            // if this is the first digit after a delimiter, then
            // set flags to start computing the new number
            if (bNewItem) {
                bNewItem = FALSE;
                bValidNumber = TRUE;
            }
            if (bValidNumber) {
                dwThisNumber *= 10;
                dwThisNumber += (*pwcThisChar - (WCHAR)'0');
            }
            break;

        case DELIMITER:
            // a delimter is either the delimiter character or the
            // end of the string ('\0') if when the delimiter has been
            // reached a valid number was found, then compare it to the
            // number from the argument list. if this is the end of the
            // string and no match was found, then return.
            //
            if (bValidNumber) {
                if (dwThisNumber == dwNumber) return TRUE;
                bValidNumber = FALSE;
            }
            if (*pwcThisChar == 0) {
                return FALSE;
            } else {
                bNewItem = TRUE;
                dwThisNumber = 0;
            }
            break;

        case INVALID:
            // if an invalid character was encountered, ignore all
            // characters up to the next delimiter and then start fresh.
            // the invalid number is not compared.
            bValidNumber = FALSE;
            break;

        default:
            break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



// CAccumulator

bool CAccumulator::Accumulate(void * pb, DWORD cb)
{
   if (m_cbCur + cb > m_cbAlloc)
   {
      // Fairly random heuristic growth pattern.
      DWORD   cbAllocNew = (m_cbCur + cb + 16) * 5 / 4;
      BYTE *  pbNew = (BYTE *) realloc(m_pb, cbAllocNew);
      if (pbNew == NULL)
         return false;
      m_pb = pbNew;
      m_cbAlloc = cbAllocNew;
   }

   if (pb)
      memcpy(m_pb + m_cbCur, (BYTE *) pb, cb);
   m_cbCur += cb;

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\perfmon.h ===
// TODO: Move this to utility library.

#pragma once

#include <windows.h>
#include <winperf.h>
#include <malloc.h>

// For now, use the symbol offset from the perfsym.h file to identify a particular counter.
typedef __int32 PERFC;

class CAccumulator
{
public:
   CAccumulator()    { m_pb = NULL; m_cbAlloc = m_cbCur = 0; }
   ~CAccumulator()   { free(m_pb); }

   bool     Accumulate(void * pb, DWORD cb);
   BYTE *   Buffer() { return m_pb; }
   DWORD    Size()   { return m_cbCur; }
   BYTE *   Detach() { BYTE * pbT = m_pb; m_pb = NULL; m_cbAlloc = m_cbCur = 0; return pbT; }

private:
   DWORD    m_cbAlloc;
   DWORD    m_cbCur;
   BYTE *   m_pb;
};

struct PerfObject
{
   DWORD          ObjectNameTitleIndex;
   DWORD          DetailLevel;            // Do we care?
   DWORD          DefaultCounter;
   LARGE_INTEGER  PerfTime;
   LARGE_INTEGER  PerfFreq;
};


struct PerfCounter
{
   DWORD          CounterNameTitleIndex;     // Relative to start of this app's block; Offset into global database will be added later
   DWORD          DefaultScale;
   DWORD          DetailLevel;            // Do we care?
   DWORD          CounterType;
};


struct PerfInstanceHeader
{
   bool           fInUse;               // TRUE if active instance
   DWORD          dwPID;                // Process ID of owning process
};

class CPerfCounterManager
{
   friend class CPerfCounterObject;

public:
   CPerfCounterManager()   { m_hSharedMem = NULL; m_pbSharedMem = NULL; m_ppot = NULL; }
   ~CPerfCounterManager();
   DWORD    Init(char * mapname, __int32 cCountersPerObject, __int32 cObjectsMax);

   // These functions used only by the performance DLL.
   DWORD    Open(LPWSTR lpDeviceNames, char * appname, PerfObject * ppo, PerfCounter * apc);
   DWORD    Collect(LPWSTR lpwszValue, LPVOID *lppData, LPDWORD lpcbBytes, LPDWORD lpcObjectTypes);
   DWORD    Close();

   // These functions used only by the application, indirectly via CPerfCounterObject.
   __int32    AllocInstance();
   void     FreeInstance(__int32 iInstance);

private:
   HANDLE               m_hSharedMem;
   unsigned __int8 *              m_pbSharedMem;
   unsigned __int32               m_cCountersPerObject;
   unsigned __int32               m_cObjectsMax;
   unsigned __int32               m_cbPerCounterBlock;
   unsigned __int32               m_cbPerInstance;

   CAccumulator         m_accumHeader;
   PERF_OBJECT_TYPE *   m_ppot;
};

// An instance of a particular performance object.
class CPerfCounterObject
{
public:
   CPerfCounterObject()    { m_ppcm = NULL; }
   ~CPerfCounterObject();
   bool  Init(CPerfCounterManager *);

   void  IncrementCounter(PERFC perfc);
   void  SetCounter(PERFC perfc, __int32 value);

private:
   CPerfCounterManager *   m_ppcm;
   int                     m_iInstance;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\pitchprosody.cpp ===
/******************************************************************************
* PitchProsody.cpp *
*--------------------*
*
*  This is an implementation of the PitchProsody class.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 04/28/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

//--- Additional includes
#include "stdafx.h"

#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif


//-----------------------------
// Data.cpp
//-----------------------------
extern const float   g_PitchScale[];



//--------------------------------
// Interpolation direction
//--------------------------------
enum INTERP_DIR
{
    GOING_UP,
    GOING_DOWN,
};


#define M_PI		3.14159265358979323846
#define	MAX_ORDER		4096


class CFIRFilter 
{
public:
	//-------------------------------------------------
	// Methods
	//-------------------------------------------------
	void	Make_Filter( float freq1, long order, float srate );
	void	DoFilter (float *src, float *dst, long len);

	void	Design_Lowpass (float freq);
	//-------------------------------------------------
	// Member Variables
	//-------------------------------------------------
	float			m_Coeff[MAX_ORDER];
	float			m_SRate;
	long			m_Order;
	long			m_HalfOrder;
};




//-----------------------------------------------
// Design a low pass filter 
//-----------------------------------------------
void	CFIRFilter::Design_Lowpass (float freq)
{
	float		half_Filt[MAX_ORDER];
	double		w;
	long		i;
	
	
	//----------------------------------------------------------
	// generate one half of coefficients from sinc() function
	//----------------------------------------------------------
	w = 2.0 * M_PI * freq;
	half_Filt[0] = (float)(w / M_PI);
	for (i = 1; i <= m_HalfOrder; i++)
	{
		half_Filt[i] = (float)(sin(i * w) / (i * M_PI));
	}
	
	//----------------------------------------------------------
	// window with (half-)hamming window 
	//----------------------------------------------------------
	for (i = 0; i <= m_HalfOrder; i++)
	{
		half_Filt[i] *= (float)(0.54 + 0.46 * cos(i * M_PI / m_HalfOrder));
	}
	
	//----------------------------------------------------------
	// copy as symmetric filter
	//----------------------------------------------------------
	for (i = 0; i < m_Order; i++)
	{
		m_Coeff[i] = half_Filt[abs(m_HalfOrder - i)];
	}
	
}




//-----------------------------------------------
// Do the filtering
//-----------------------------------------------
void	CFIRFilter::DoFilter (float *src, float *dst, long len)
{
#define     kWakeSamples    1000;
	long			i,j;
	float			*sp;
	float			sum;
	long			lenAdj;
	
	lenAdj = len - m_Order;
	if (lenAdj >= 0)
	{
		for (i = 0; i < m_HalfOrder; i++) 
		{
			*dst++ = src[0];
		}
		
		for (i = 0; i < lenAdj; i++) 
		{
			sum = (float)0.0;
			sp = src + i;
			for (j = 0; j < m_Order; j++)
			{
				sum += ((float)*sp++) * m_Coeff[j];
			}
			*dst++ = sum;

		}
		
		for (i = 0; i < m_HalfOrder; i++) 
		{
			*dst++ = src[len-1];
		}
	}
}







void	CFIRFilter::Make_Filter( float freq1, long order, float srate )
{
	m_SRate		= srate;
	m_Order		= order;
	m_HalfOrder	= m_Order / 2;

	Design_Lowpass (freq1 / m_SRate);
}





/*****************************************************************************
* HzToOct *
*---------*
*   Description:
*   Convert liner freq ro exp pitch
*   0.69314718 is log of 2 
*   1.021975 is offset for middle C
*       
********************************************************************** MC ***/
float HzToOct( float cps)
{
    SPDBG_FUNC( "HzToOct" );

    return (float)(log(cps / 1.021975) / 0.69314718);
    
} /* HzToOct */

/*****************************************************************************
* OctToHz *
*---------*
*   Description:
*       Convert from exp pitch to linear freq
********************************************************************** MC ***/
float OctToHz( float oct)
{
    SPDBG_FUNC( "OctToHz" );

    return (float)(pow(2, oct) * 1.021975);
} /* OctToHz */



/*****************************************************************************
* CPitchProsody::DoPitchControl *
*-------------------------------*
*   Description:
*   Scale speech pitch to user control
*       
********************************************************************** MC ***/
float CPitchProsody::DoPitchControl( long pitchControl, float basePitch )
{
    SPDBG_FUNC( "CPitchProsody::DoPitchControl" );
    float   newPitch;

    if( pitchControl < 0 )
    {
        //--------------------------------
        // DECREASE the pitch
        //--------------------------------
        if( pitchControl < MIN_USER_PITCH )
        {
            pitchControl = MIN_USER_PITCH;        // clip to min
        }
        newPitch = (float)basePitch / g_PitchScale[0 - pitchControl];
    }
    else
    {
        //--------------------------------
        // INCREASE the pitch
        //--------------------------------
        if( pitchControl > MAX_USER_PITCH )
        {
            pitchControl = MAX_USER_PITCH;        // clip to max
        }
        newPitch = (float)basePitch * g_PitchScale[pitchControl];
    }
    return newPitch;
} /* CPitchProsody::DoPitchControl */





/*****************************************************************************
* CPitchProsody::SetDefaultPitch *
*--------------------------------*
*   Description:
*   Init pitch knots to monotone in case there's a failure in this object.
*       
********************************************************************** MC ***/
void CPitchProsody::SetDefaultPitch()
{
    SPDBG_FUNC( "CPitchProsody::SetDefaultPitch" );
    CAlloCell   *pCurCell;

	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        float       relTime, timeK;
        float       normalPitch;
        long        knot;

        normalPitch = pCurCell->m_Pitch_LO + ((pCurCell->m_Pitch_HI - pCurCell->m_Pitch_LO) / 2);
        timeK = pCurCell->m_ftDuration / KNOTS_PER_PHON;
        relTime = 0;
        for( knot = 0; knot < KNOTS_PER_PHON; knot++ )
        {
            pCurCell->m_ftPitch[knot] = normalPitch;
            pCurCell->m_ftTime[knot] = relTime;
            relTime += timeK;
        }
		pCurCell = m_pAllos->GetNextCell();
    }
} /* CPitchProsody::SetDefaultPitch */


/*****************************************************************************
* CPitchProsody::AlloPitch *
*--------------------------*
*   Description:
*   Tag pitch highlights
*       
********************************************************************** MC ***/
void CPitchProsody::AlloPitch( CAlloList *pAllos, int baseLine, int pitchRange )
{
    SPDBG_FUNC( "CAlloOps::AlloPitch" );
    CAlloCell   *pCurCell;
    bool        skipInitialSil;
    long        quantTotal, index;
    
    m_pAllos = pAllos;
    m_numOfCells = m_pAllos->GetCount();
    m_Tune_Style = DESCEND_TUNE;        // NOTE: maybe set from rules
    m_TotalDur = 0;
    quantTotal = 0;
    m_OffsTime = 0;
    skipInitialSil = true;


   //------------------------------
    // Calculate total duration
    // (exclude surrounding silence)
    //------------------------------
	index = 0;
	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        if( (skipInitialSil) && (pCurCell->m_allo == _SIL_) )
        {
            //---------------------------------
            // Skip leading silence
            //---------------------------------
            m_OffsTime += pCurCell->m_ftDuration;
        }
        else if( (index == (m_numOfCells -1)) && (pCurCell->m_allo == _SIL_) )
        {
            //---------------------------------
            // Skip term silence
            //---------------------------------
            break;
        }
        else
        {
            pCurCell->m_PitchBufStart = quantTotal;
            m_TotalDur += pCurCell->m_ftDuration;
            quantTotal = (long)(m_TotalDur / PITCH_BUF_RES + 0.5);
            pCurCell->m_PitchBufEnd = quantTotal;
            skipInitialSil = false;
        }
		index++;
		pCurCell = pAllos->GetNextCell();
    }

    //------------------------------
    // Init pitch range
    //------------------------------
	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        float   hzVal;

        //---------------------------------------
        // Scale to possible pitch control
        //---------------------------------------	
        hzVal = DoPitchControl( pCurCell->m_user_Pitch, (float)baseLine );
        pCurCell->m_Pitch_HI = hzVal + ( pitchRange / 2 );
        pCurCell->m_Pitch_LO = hzVal - ( pitchRange / 2 );

		pCurCell = pAllos->GetNextCell();
    }

    //--------------------------------------------
    // In case we fail somewhere, set values to 
    // a known valid state (monotone).
    //--------------------------------------------
    SetDefaultPitch();

    if( m_TotalDur > 0 )
    {
        //--------------------------------------------
        // Generate pitch targets
        //--------------------------------------------
        PitchTrack();
    }

    pCurCell = m_pAllos->GetHeadCell();
    while ( pCurCell )
    {
        for ( int i = pCurCell->m_PitchBufStart; i < pCurCell->m_PitchBufEnd; i++ )
        {
            if ( 0.0 < m_pContBuf[i] && m_pContBuf[i] < 1.0 )
            {
                m_pContBuf[i] = pCurCell->m_Pitch_LO + 
                                ( m_pContBuf[i] * ( pCurCell->m_Pitch_HI - pCurCell->m_Pitch_LO ) );
            }
        }
        pCurCell = m_pAllos->GetNextCell();
    }


} /* CPitchProsody::AlloPitch */











/*****************************************************************************
* LineInterpContour  *
*--------------------*
*   Description:
*   Does linear interpolation over the pitch contour
*       
********************************************************************** MC ***/
void	LineInterpContour( long cNumOfPoints, float *pPoints )
{
    SPDBG_FUNC( "LineInterpContour" );
    long endAnch,startAnch, i;
    float bPoint1, ePoint1;
    
    
    //----------------------------------------------------
    // Scan forward from beginning to find 1st non-zero enrty
    // Use it as the START point.
    //----------------------------------------------------
    for( startAnch = 0; startAnch < cNumOfPoints; startAnch++ )
    {
        if( pPoints[startAnch] != 0 )
        {
            break;
        }
    }
    bPoint1 = pPoints[startAnch];
    
    
    //----------------------------------------------------
    // Scan back from end to find 1st non-zero enrty
    // Use it as the END point.
    //----------------------------------------------------
    for( endAnch = cNumOfPoints-1; endAnch >= 0; endAnch-- )
    {
        if( pPoints[endAnch] != 0 )
        {
            break;
        }
    }
    ePoint1 = pPoints[endAnch];
    
    
    long firstp = 0;
    long lastp = 0;
    
    while( firstp < cNumOfPoints )
    {
        //-------------------------------------------
        // Find beginning and end of current section
        //-------------------------------------------
        while( pPoints[firstp] != 0 )
        {
            if( ++firstp >= cNumOfPoints-1 ) 
            {
                break;
            }
        }
		if( firstp >= cNumOfPoints-1 )
		{
			//--------------------------------------
			// There's nothing to interpolate!
			//--------------------------------------
			break;
		}


        lastp = firstp+1;
        while( pPoints[lastp] == 0 )
        {
            if( ++lastp >= cNumOfPoints ) 
            {
				lastp = cNumOfPoints;
                break;
            }
        }
        lastp--;

        if( lastp >= firstp )
        {
            if( (lastp >= cNumOfPoints) || (firstp >= cNumOfPoints) ) 
            {
                break;
            }
            //-------------------------------------------
            // Do the interpolate
            //-------------------------------------------
            float bPoint,ePoint;
            if( firstp == 0 ) 
            {
                bPoint = bPoint1;
            }
            else 
            {
                bPoint = pPoints[firstp - 1];
            }
            
            if( lastp == cNumOfPoints-1 ) 
            {
                ePoint = ePoint1;
            }
            else 
            {
                ePoint = pPoints[lastp + 1];
            }
            
            float pointSpread = ePoint - bPoint;
            float timeSpread = (float) ((lastp - firstp)+2);
            float inc = pointSpread / timeSpread;
            float theBase = bPoint;
            for( i = firstp; i <= lastp; i++ )
            {
                theBase += inc;
                pPoints[i] = theBase;
            }
        }
        else 
        {
            pPoints[firstp] = pPoints[lastp+1];
        }
        firstp = lastp+1;
    }
} /* LineInterpContour */








/*****************************************************************************
* Interpolate2  *
*---------------*
*   Description:
*    Do a 2nd order interpolation, a little nicer than just linear
*       
********************************************************************** MC ***/
void Interpolate2( INTERP_DIR direction, float *m_theFitPoints, long theStart, long len, float theAmp, float theBase)
{
    SPDBG_FUNC( "Interpolate2" );
	long    midPoint = len / 2;
    long    i;

	theAmp -= theBase;

	for( i = theStart; i < theStart + len;i++ )
	{
		if (direction == GOING_UP)
		{
			if( i < theStart + midPoint )
			{
				m_theFitPoints[i] = theBase +
				(2 * theAmp) * ((((float)i - (float)theStart) / (float)len) * 
													(((float)i - (float)theStart) / (float)len));
			}
			else
			{
				m_theFitPoints[i] = (theBase + theAmp) - 
				((2 * theAmp) * ((1 - ((float)i - (float)theStart) / (float)len) * 
										(1 - ((float)i - (float)theStart) / (float)len)));
			}
		}
		else if( direction == GOING_DOWN ) 
		{

			if( i < theStart + midPoint )
			{
				m_theFitPoints[i] = theBase +
				theAmp - (2 * theAmp) * ((((float)i - (float)theStart) / (float)len) * 
													(((float)i - (float)theStart) / (float)len));
			}
			else
			{
				m_theFitPoints[i] = theBase + 
				(2 * theAmp) * ((1 - ((float)i - (float)theStart) / (float)len) * 
										(1 - ((float)i - (float)theStart) / (float)len));
			}
		} 
	}
} /* Interpolate2 */




/*****************************************************************************
* SecondOrderInterp  *
*--------------------*
*   Description:
*   Does 2nd order interpolation over the pitch contour
*       
********************************************************************** MC ***/
void SecondOrderInterp( long cNumOfPoints, float *pPoints )
{
    SPDBG_FUNC( "SecondOrderInterp" );
	long    endAnch,startAnch;
	float   bPoint1, ePoint1;


    //----------------------------------------------------
    // Scan forward from beginning to find 1st non-zero enrty
    // Use it as the START point.
    //----------------------------------------------------
    for( startAnch = 0; startAnch < cNumOfPoints; startAnch++ )
    {
        if( pPoints[startAnch] != 0 )
        {
            break;
        }
    }
    bPoint1 = pPoints[startAnch];
    
    
    //----------------------------------------------------
    // Scan back from end to find 1st non-zero enrty
    // Use it as the END point.
    //----------------------------------------------------
    for( endAnch = cNumOfPoints-1; endAnch >= 0; endAnch-- )
    {
        if( pPoints[endAnch] != 0 )
        {
            break;
        }
    }
    ePoint1 = pPoints[endAnch];


    long    firstp = 0;
	long    lastp = 0;

	while( firstp < cNumOfPoints-1 )
	{

        //------------------------------------------------
		// Find beginning and end of current section
        //------------------------------------------------
		while( pPoints[firstp] != 0 )
		{
			if( ++firstp >= cNumOfPoints-1 ) 
            {
                break;
            }
		}
		if( firstp >= cNumOfPoints-1 )
		{
			//--------------------------------------
			// There's nothing to interpolate!
			//--------------------------------------
			break;
		}

		lastp = firstp + 1;
		while( pPoints[lastp] == 0 )
		{
			if( ++lastp >= cNumOfPoints ) 
            {
				lastp = cNumOfPoints;
                break;
            }
		}
		lastp--;

		if( lastp >= firstp )
		{
			if( (lastp >= cNumOfPoints) || (firstp >= cNumOfPoints) ) 
            {
                break;
            }

            //--------------------------------
			// Do the interpolate
            //--------------------------------
			float   bPoint, ePoint;

			if( firstp == 0 ) 
            {
                bPoint = bPoint1;
            }
			else 
            {
                bPoint = pPoints[firstp - 1];
            }

            long    theIndex = lastp + 1;

			if( lastp == cNumOfPoints-1 ) 
            {
                ePoint = ePoint1;
            }
			else 
            {
                ePoint = pPoints[theIndex];
            }

            //--------------------------------
            // call the 2nd order routine
            //--------------------------------
            if( ePoint - bPoint > 0 )
            {
                Interpolate2( GOING_UP, pPoints, firstp, (lastp - firstp) + 1, ePoint, bPoint );
            }
            else
            {
                Interpolate2( GOING_DOWN, pPoints, firstp, (lastp - firstp) + 1, bPoint, ePoint );
            }

		}
		else 
        {
            pPoints[firstp] = pPoints[lastp+1];
        }

		firstp = lastp+1;
	}

	//---------------------------------
	// FIR Filter
	//---------------------------------
	/*CFIRFilter		filterObj;
	float			*pOrig;


    pOrig = new float[cNumOfPoints];
	memcpy( pOrig, pPoints, cNumOfPoints * sizeof(float));
	if( pOrig )
	{
		filterObj.Make_Filter(	5,		// Freq	
								10,		// order
								100		// SR 
								);
		filterObj.DoFilter( pOrig, pPoints, cNumOfPoints);
        delete pOrig;
	}*/

	//---------------------------------
	// IIR Filter
	//---------------------------------
#define kPointDelay		1

	float		filter_Out1, filter_In_Gain, filter_FB_Gain;
	float		lastPoint;
	long		i;

	//--------------------------------------------------
	// Skip filter if audio len less than delay
	//--------------------------------------------------
	if( cNumOfPoints > kPointDelay )
	{
		filter_In_Gain = 0.10f;
		filter_FB_Gain = 1.0f - filter_In_Gain;
		filter_Out1 = pPoints[0];
		for( i = 0; i < cNumOfPoints; i++ )
		{
			filter_Out1 = 	(filter_In_Gain * pPoints[i]) + (filter_FB_Gain * filter_Out1);
			pPoints[i] = filter_Out1;
		}
		for( i = kPointDelay; i < cNumOfPoints; i++ )
		{
			pPoints[i-kPointDelay] = pPoints[i];
		}
		i = (cNumOfPoints - kPointDelay) -1;
		lastPoint = pPoints[i++];
		for( ; i < cNumOfPoints; i++ )
		{
			pPoints[i] = lastPoint;
		}
	}
} /* SecondOrderInterp */

/*****************************************************************************
* CPitchProsody::NewTarget  *
*---------------------------*
*   Description:
*   Insert pitch target into 'm_pContBuf'
*       
********************************************************************** MC ***/
void CPitchProsody::NewTarget( long index, float value )
{
    SPDBG_FUNC( "CPitchProsody::NewTarget" );

    m_pContBuf[index] = value;

    //--- Debug Macro - add pitch to target list for later debugging output
    TTSDBG_ADDPITCHTARGET( m_OffsTime + (PITCH_BUF_RES * index), value, m_CurAccent );

} /* CPitchProsody::NewTarget */


/*****************************************************************************
* CPitchProsody::GetKnots *
*-------------------------*
*   Description:
*   Assign pitch knots based on entries in a contour buffer.
*       
********************************************************************** MC ***/
void CPitchProsody::GetKnots ()
{
    SPDBG_FUNC( "CPitchProsody::GetKnots" );
    CAlloCell   *pCurCell;
    float       distK, scale;
    float       pitchRange;
    long        knot, loc, index;
    bool        skipInitialSil;

    skipInitialSil = true;
	pCurCell = m_pAllos->GetHeadCell();
	index = 0;
    while( pCurCell )
    {
		if( index >= m_numOfCells-1 )
		{
			//-----------------------
			// Skip last allo
			//-----------------------
			break;
		}
        if( (!skipInitialSil) || (pCurCell->m_allo != _SIL_) )
        {
            pitchRange = pCurCell->m_Pitch_HI - pCurCell->m_Pitch_LO;
            distK = 1.0f / KNOTS_PER_PHON;
            scale = 0;
            for( knot = 0; knot < KNOTS_PER_PHON; knot++ )
            {
                loc = pCurCell->m_PitchBufStart + (long)((pCurCell->m_PitchBufEnd - pCurCell->m_PitchBufStart) * scale);
                pCurCell->m_ftPitch[knot] =  pCurCell->m_Pitch_LO + (m_pContBuf[loc] * pitchRange);
                pCurCell->m_ftTime[knot] = scale * pCurCell->m_ftDuration;
                scale += distK;
            }
            skipInitialSil = false;
        }
		pCurCell = m_pAllos->GetNextCell();
		index++;
    }
} /* CPitchProsody::GetKnots */


/*****************************************************************************
* CPitchProsody::PitchTrack  *
*----------------------------*
*   Description:
*   Tag pitch highlights
*       
********************************************************************** MC ***/
void CPitchProsody::PitchTrack()
{
    SPDBG_FUNC( "CPitchProsody::PitchTrack" );
    long        i;
    CAlloCell   *pCurCell, *pNextCell;
    bool        initialWord;      // 1st word in phrase
    long        wordCntDwn;
    float       curProm;          // Current accent prominence
    long        cNumOfPoints;
    float       *pRefBuf, *pCeilBuf, *pFloorBuf;
    float       lastProm;
    long        loc;
    float       value;

    pRefBuf = pCeilBuf = pFloorBuf = NULL;
    cNumOfPoints = (long)(m_TotalDur / PITCH_BUF_RES + 0.5);
    pRefBuf = new float[cNumOfPoints];
    pCeilBuf = new float[cNumOfPoints];
    pFloorBuf = new float[cNumOfPoints];
    if ( m_pContBuf )
    {
        delete m_pContBuf;
        m_pContBuf = NULL;
    }
    m_pContBuf = new float[cNumOfPoints];
    m_ulNumPoints = cNumOfPoints;

    if( pRefBuf && pCeilBuf && pFloorBuf && m_pContBuf)
    {
        //--------------------------------------------
        // Initialize buffers to zero
        //--------------------------------------------
        for (i = 0; i < cNumOfPoints; i++)
        {
            pCeilBuf[i] = 0;
            pFloorBuf[i] = 0.00001f;
            pRefBuf[i] = 0;
            m_pContBuf[i] = 0;
        }

        //--------------------------------------------
        // Linear CEILING slope
        //--------------------------------------------
        if( m_Tune_Style == DESCEND_TUNE )
        {
            pCeilBuf[0] = 1.0;
            pCeilBuf[cNumOfPoints-1] = 0.70f;
            ::LineInterpContour( cNumOfPoints, pCeilBuf );
        }
        else if  (m_Tune_Style == ASCEND_TUNE)
        {
            pCeilBuf[0] = 0.9f;
            pCeilBuf[cNumOfPoints-1] = 1.0f;
            ::LineInterpContour( cNumOfPoints, pCeilBuf );
        }
        else if  (m_Tune_Style == FLAT_TUNE)
        {
           pCeilBuf[0] = 1.0f;
           pCeilBuf[cNumOfPoints-1] = 1.0f;
           ::LineInterpContour( cNumOfPoints, pCeilBuf );
        }

        //--------------------------------------------
        // Linear REFERENCE slope
        //--------------------------------------------
        pRefBuf[0] = (float) (pFloorBuf[0] + (pCeilBuf[0] - pFloorBuf[0]) * 0.33f);
        pRefBuf[cNumOfPoints-1] = (float) (pFloorBuf[0] + (pCeilBuf[cNumOfPoints-1] - pFloorBuf[cNumOfPoints-1]) * 0.33f);
        ::LineInterpContour( cNumOfPoints,pRefBuf );

        //--------------------------------------------
        // Final contour buffer
        //--------------------------------------------
        m_pContBuf[0] = pRefBuf[0];
        m_pContBuf[cNumOfPoints-1] = 0.0001f;		// Something very small


        long    iPrevBegin, iPrevEnd, iCurBegin; 
        long    iCurEnd, iNextBegin, iNextEnd;
		float	cCurLen;
        long	iCellindex;

        initialWord = true;
		iCellindex = 0;
		pCurCell = m_pAllos->GetHeadCell();
        while( pCurCell->m_allo == _SIL_ )
        {
            //---------------------------------
            // Skip leading silence
            //---------------------------------
            pCurCell = m_pAllos->GetNextCell();
			iCellindex++;
        }
        wordCntDwn  = 1;                // Skip 1st word
        lastProm = 0;
        iPrevBegin = iPrevEnd = 0;

		pNextCell = m_pAllos->GetNextCell();
        while( pCurCell )
        {
			if( iCellindex >= m_numOfCells-1 )
			{
				//-----------------------
				// Skip last allo
				//-----------------------
				break;
			}
            //-----------------------------------
            // Get CURRENT allo
            //-----------------------------------
            iCurBegin = pCurCell->m_PitchBufStart;
            iCurEnd = pCurCell->m_PitchBufEnd;
			cCurLen = (float)(iCurEnd - iCurBegin);
            curProm = pCurCell->m_Accent_Prom * (float)0.1;

            //-----------------------------------
            // Get NEXT allo
            //-----------------------------------
            iNextBegin = pNextCell->m_PitchBufStart;
            iNextEnd = pNextCell->m_PitchBufEnd;

            m_CurAccent = pCurCell->m_ToBI_Accent;
			//---------------------
			// Diagnostic
			//---------------------
            m_CurAccentSource = pCurCell->m_AccentSource;
            m_CurBoundarySource = pCurCell->m_BoundarySource;
            m_pCurTextStr = pCurCell->m_pTextStr;

            switch( pCurCell->m_ToBI_Accent )
            {
                case K_RSTAR:
                    break;

                case K_HSTAR:
                    {
                        if( !initialWord )        // We never add a 'leg' to a phrase-initial word
                        {
                            //----------------------------------------------
                            // Add a L leg to start to previous allo
                            //----------------------------------------------
                            if( iPrevBegin )
                            {
								loc = (long) ((iCurBegin + (cCurLen * 0.1f)));
						        value = ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);    // H*
                                value = pRefBuf[loc] + (value * 0.25f);    // L+H*
                                NewTarget( iPrevBegin, value );
                                //NewTarget( loc, value );
                            }
                        }
                        //----------------------------------------------
                        // Now plug in the H target
						//
						// If we're at a boundary, insert H at 
						// allo mid-point else insert at allo start
                        //----------------------------------------------
				        if( pCurCell->m_ToBI_Boundary != K_NOBND )
                        {
                            //---------------------------
                            // Insert H* at allo start 
                            //---------------------------
                            loc = (long) iCurBegin;
                        }
                        else 
                        {
                            //---------------------------
                            // Insert H* at allo mid-point 
                            //---------------------------
					        loc = (long) (iCurBegin + (cCurLen * K_HSTAR_OFFSET));
                        }
                        value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);    // H*
                        NewTarget( loc, value );
                    }
                    break;

            case K_LSTAR:
                {
					//------------------------------------
					// Insert L* at mid-point
					//------------------------------------
                    loc = (long) (iCurBegin + (cCurLen * 0.3f));
                    value = pRefBuf[loc] - ((pRefBuf[loc] - pFloorBuf[loc]) * curProm);   // L*
                    NewTarget( loc, value );
                }
                break;

            case K_LSTARH:
                {
					//----------------------------------------------
					// Insert L* at current start
					//----------------------------------------------
                    value = pRefBuf[iCurBegin] - ((pRefBuf[iCurBegin] - pFloorBuf[iCurBegin]) * curProm);   // L*+H
                    NewTarget( iCurBegin, value );
                    if( iNextBegin )
                    {
						//----------------------------------------------
						// Insert H at next end
						// set prom gain?
						//----------------------------------------------
                        value = pRefBuf[iNextEnd] - ((pRefBuf[iNextEnd] - pFloorBuf[iNextEnd])  * (curProm /* * .3 */ ));
                        NewTarget( iNextEnd, value );
                    }
                    lastProm = 0;
                }
                break;

            case K_LHSTAR:
                {
                    loc = (long) (iCurBegin + (cCurLen * 0.3f));
                    if( iPrevBegin )
                    {
						//----------------------------------------------
						// Insert L at previous start
						//----------------------------------------------
                        value = (pRefBuf[iPrevBegin] - ((pRefBuf[iPrevBegin] - pFloorBuf[iPrevBegin]) * (curProm * 0.3f)));    // L+H*
                        NewTarget( iPrevBegin, value );
                    }
					//----------------------------------------------
					// Insert H* at current mid-point
					//----------------------------------------------
                    value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);         // H*
                    NewTarget( loc, value );
                    lastProm = curProm;
                }
                break;

            case K_HSTARLSTAR:
                {
                    //value = pRefBuf[iCurBegin] + ((pCeilBuf[iCurBegin] - pRefBuf[iCurBegin]) * curProm);         // H*
                    value = pRefBuf[0] + ((pCeilBuf[0] - pRefBuf[0]) * curProm);         // H*
                    NewTarget( iCurBegin, value );

                    loc = (long) (iCurBegin + (cCurLen * 0.75f));
                    value = pRefBuf[loc] - ((pRefBuf[loc] - pFloorBuf[loc]) * curProm);   // L*
                    NewTarget( loc, value );
                    lastProm = curProm;
                }
                break;
            case K_DHSTAR:
                {
                    loc = (long) ( iCurBegin + (cCurLen * 0.0f) );
                    if( lastProm )
                    {
                        lastProm *= K_HDOWNSTEP_COEFF;
                        value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * lastProm);   // !H*
                        NewTarget( loc, value );
                    }
                    //-----------------------------------------
                    // no previous H*, treat !H* like an H*
                    //-----------------------------------------
                    else 
                    {
                        value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);      // H*
                        NewTarget( loc, value );
                        lastProm = curProm;
                    }
                }
                break;

            default:        // Unknown accent specfied
                break;
            }

            //-------------------------------------------------------------
            // if there's a boundary, fill in pitch value(s)
            // assume the boundary is set to correct (voiced) final phone
            //-------------------------------------------------------------
            curProm = pCurCell->m_Boundary_Prom * (float)0.1;
            m_CurAccent =(TOBI_ACCENT) pCurCell->m_ToBI_Boundary;
			//---------------------
			// Diagnostic
			//---------------------
            m_CurAccentSource = pCurCell->m_AccentSource;
            m_CurBoundarySource = pCurCell->m_BoundarySource;
            m_pCurTextStr = pCurCell->m_pTextStr;
            switch( pCurCell->m_ToBI_Boundary )
            {
                case K_LMINUS:
                    {
                        value = pRefBuf[iCurEnd] - ((pRefBuf[iCurEnd] - pFloorBuf[iCurEnd]) * curProm);			// L-
                        NewTarget( iCurEnd, value );
                    }
                    break;

                case K_HMINUS:
                    {
                        value = pRefBuf[iCurEnd] + ((pCeilBuf[iCurEnd] - pRefBuf[iCurEnd]) * curProm);			// H-
                        NewTarget( iCurEnd, value );
                    }
                    break;

                //case K_LPERC:
                //case K_HPERC:

                case K_LMINUSLPERC:
                    {
                        value = pFloorBuf[iCurEnd];
                        //NewTarget( iCurEnd, value );
                        NewTarget( iCurBegin, value );
                    }
                    break;

                case K_HMINUSHPERC:
                    {
                        value = pCeilBuf[iCurEnd];
                        NewTarget( iCurEnd, value );
                    }
                    break;

                case K_LMINUSHPERC:																// L-H%
                    {
                        //---------------------------------------
                        // comma continuation rise
                        //---------------------------------------
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						// L starts at middle of previous phon
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        loc = iPrevBegin + (iPrevEnd - iPrevBegin) / 2;
                        value = pRefBuf[loc] - ((pRefBuf[loc] - pFloorBuf[loc]) * curProm);         // L-
                        NewTarget( loc, value );
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						// H at end of current phon
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        value = pRefBuf[iCurEnd] + ((pCeilBuf[iCurEnd] - pRefBuf[iCurEnd]) * curProm);          // H%
                        NewTarget( iCurEnd, value );
                    }
                    break;

                case K_HMINUSLPERC:
                    {
                        //---------------------------------------
                        // accent extension followed by sharp drop
                        //---------------------------------------
                        value = pRefBuf[iCurBegin] + ((pCeilBuf[iCurBegin] - pRefBuf[iCurBegin]) * curProm);          // H-
                        NewTarget( iCurBegin, value );
                        value = pFloorBuf[iCurEnd];													// L%
                        //loc = iCurBegin + ((iCurEnd - iCurBegin) * 0.1f);
                        NewTarget( iCurEnd, value );
                    }
                    break;

                default:
                    break;
            }
            //----------------------------
            // Unflag initial word
            //----------------------------
            if( (initialWord) && (pCurCell->m_ctrlFlags & WORD_START) )
            {
                wordCntDwn--;
                if( wordCntDwn < 0 )
                {
                    initialWord = false;
                }
            }

            //----------------------------
            // Setup for next allo
            //----------------------------
            iPrevBegin = iCurBegin;
            iPrevEnd = iCurEnd;

			pCurCell	= pNextCell;
			pNextCell	= m_pAllos->GetNextCell();
			iCellindex++;
        }

        //--- Debug Macro - Log pitch data to stream
        TTSDBG_LOGTOBI;

        ::SecondOrderInterp( cNumOfPoints, m_pContBuf );
        GetKnots();
    }

    if( pRefBuf )
    {
        delete pRefBuf;
    }
    if( pCeilBuf )
    {
        delete pCeilBuf;
    }
    if( pFloorBuf )
    {
        delete pFloorBuf;
    }

} /* CPitchProsody::PitchTrack */

void CPitchProsody::GetContour( float** ppf0, ULONG *ulNumf0 )
{
	*ppf0 = new float[ m_ulNumPoints ];
    float *Array = *ppf0;
    for ( ULONG i = 0; i < m_ulNumPoints; i++ )
    {
        Array[i] = m_pContBuf[i];
    }
	*ulNumf0 = m_ulNumPoints;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by MS_EntropicEngine.rc
//
#define IDS_PROJNAME                    100
#define IDR_MSE_TTSENGINE               101
#define IDR_MSVOICEDATA                 102
#define IDR_SPTTSENGUI                  103
#define IDD_TTS_ADV                     201
#define IDC_COMMA_PERIOD                201
#define IDC_PERIOD_COMMA                202
#define IDC_MDY                         203
#define IDC_DMY                         204
#define IDC_YMD                         205
#define IDRESTORE                       254

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\spttsengdebug.h ===
/*******************************************************************************
* SpTtsEngDebug.h *
*-----------------*
*   Description:
*       This header file contains debug output services for the TTS Engine
*-------------------------------------------------------------------------------
*  Copyright (C) 1998-2000 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
********************************************************************* AKH ******/

#ifndef spttsengdebug_h
#define spttsengdebug_h

#include "stdsentenum.h"
#include "feedchain.h"

//--- This enumeration is used to index the array of IStreams used to write stuff to the debug file
typedef enum
{
    STREAM_WAVE = 0,
    STREAM_EPOCH,
    STREAM_UNIT,
    STREAM_WAVEINFO,
    STREAM_TOBI,
    STREAM_SENTENCEBREAKS,
    STREAM_NORMALIZEDTEXT,
    STREAM_LEXLOOKUP,
    STREAM_POSPOSSIBILITIES,
    STREAM_MORPHOLOGY,
    STREAM_LASTTYPE
} STREAM_TYPE;

#ifdef _DEBUG

//--- This struct is used to log units...
#pragma pack (1)
typedef struct 
{
    char        name[8];
    long        phonID;
    long        unitID;
    long        cSamples;
	float		time;
    long        cEpochs;
    long        knots;
    long        flags;
	long		ctrlFlags;
    float       pTime[KNOTS_PER_PHON];
    float       pF0[KNOTS_PER_PHON];
    float       pAmp[KNOTS_PER_PHON];
	enum SILENCE_SOURCE		silenceSource;
} UNIT_STREAM;
#pragma pack ()

//--- This struct is just used as a helper to initialize the PRONRECORD to all zeroes
struct DebugPronRecord : PRONRECORD
{
public:
    DebugPronRecord() { ZeroMemory( (void*) this, sizeof( DebugPronRecord ) ); }
    operator =( PRONRECORD InRecord )
    {
        memcpy( this, &InRecord, sizeof( PRONRECORD ) );
    }
};

//--- This struct is used to replace the SPVCONTEXT struct for outputting to the debug streams -
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugContext
{
    WCHAR Category[32];
    WCHAR Before[32];
    WCHAR After[32];
public:
    DebugContext() { ZeroMemory( (void*) this, sizeof( DebugContext ) ); }
    operator =( SPVCONTEXT InContext )
    {
        if ( InContext.pCategory )
        {
            wcsncpy( Category, InContext.pCategory, 
                     wcslen(InContext.pCategory) > 31 ? 31 : wcslen(InContext.pCategory) );
        }
        if ( InContext.pBefore )
        {
            wcsncpy( Before, InContext.pBefore,
                     wcslen(InContext.pBefore) > 31 ? 31 : wcslen(InContext.pBefore) );
        }
        if ( InContext.pAfter )
        {
            wcsncpy( After, InContext.pAfter,
                     wcslen(InContext.pAfter) > 31 ? 31 : wcslen(InContext.pAfter) );
        }
    }
};

//--- This struct is used to replace the SPVSTATE struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugState
{
    SPVACTIONS      eAction;
    LANGID          LangID;
    WORD            wReserved;
    long            EmphAdj;
    long            RateAdj;
    ULONG           Volume;
    SPVPITCH        PitchAdj;
    ULONG           SilenceMSecs;
    SPPHONEID       PhoneIds[64];
    ENGPARTOFSPEECH  ePartOfSpeech;
    DebugContext    Context;
public:
    DebugState() { ZeroMemory( (void*) this, sizeof( DebugState ) ); }
    operator =( SPVSTATE InState )
    {
        eAction         = InState.eAction;
        LangID          = InState.LangID;
        wReserved       = InState.wReserved;
        EmphAdj         = InState.EmphAdj;
        RateAdj         = InState.RateAdj;
        Volume          = InState.Volume;
        PitchAdj        = InState.PitchAdj;
        SilenceMSecs    = InState.SilenceMSecs;
        ePartOfSpeech   = (ENGPARTOFSPEECH)InState.ePartOfSpeech;
        Context         = InState.Context;
        if ( InState.pPhoneIds )
        {
            wcsncpy( PhoneIds, InState.pPhoneIds,
                     wcslen(InState.pPhoneIds) > 63 ? 63 : wcslen(InState.pPhoneIds) );
        }
    }
};

//--- This struct is used to replace the TTSWord struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugWord
{
    DebugState      XmlState;
    WCHAR           WordText[32];
    ULONG           ulWordLen;
    WCHAR           LemmaText[32];
    ULONG           ulLemmaLen;
    SPPHONEID       WordPron[64];
    ENGPARTOFSPEECH  eWordPartOfSpeech;
public:
    DebugWord() { ZeroMemory( (void*) this, sizeof( DebugWord ) ); }
    operator =( TTSWord InWord )
    {
        XmlState = *(InWord.pXmlState);
        if ( InWord.pWordText )
        {
            wcsncpy( WordText, InWord.pWordText, InWord.ulWordLen > 31 ? 31 : InWord.ulWordLen );
        }
        ulWordLen = InWord.ulWordLen;
        if ( InWord.pLemma )
        {
            wcsncpy( LemmaText, InWord.pLemma, InWord.ulLemmaLen > 31 ? 31 : InWord.ulLemmaLen );
        }
        ulLemmaLen = InWord.ulLemmaLen;
        if ( InWord.pWordPron )
        {
            wcsncpy( WordPron, InWord.pWordPron,
                wcslen( InWord.pWordPron ) > 63 ? 63 : wcslen( InWord.pWordPron ) );
        }
        eWordPartOfSpeech = InWord.eWordPartOfSpeech;
    }
};

struct DebugItemInfo
{
    TTSItemType Type;
public:
    DebugItemInfo() { ZeroMemory( (void*) this, sizeof( DebugItemInfo ) ); }
    operator =( TTSItemInfo InItemInfo )
    {
        Type = InItemInfo.Type;
    }
};

//--- This struct is used to replace the TTSSentItem struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugSentItem
{
    WCHAR           ItemSrcText[32];
    ULONG           ulItemSrcLen;
    ULONG           ulItemSrcOffset;
    DebugWord       Words[32];
    ULONG           ulNumWords;
    ENGPARTOFSPEECH  eItemPartOfSpeech;
    DebugItemInfo   ItemInfo;
public:
    DebugSentItem() { ZeroMemory( (void*) this, sizeof( DebugSentItem ) ); }
    operator =( TTSSentItem InItem )
    {
        if ( InItem.pItemSrcText )
        {
            wcsncpy( ItemSrcText, InItem.pItemSrcText, InItem.ulItemSrcLen > 31 ? 31 : InItem.ulItemSrcLen );
        }
        ulItemSrcLen        = InItem.ulItemSrcLen;
        ulItemSrcOffset     = InItem.ulItemSrcOffset;
        for ( ULONG i = 0; i < InItem.ulNumWords && i < 32; i++ )
        {
            Words[i] = InItem.Words[i];
        }
        ulNumWords          = InItem.ulNumWords;
        eItemPartOfSpeech   = InItem.eItemPartOfSpeech;
        if ( InItem.pItemInfo )
        {
            ItemInfo            = *(InItem.pItemInfo);
        }
    }
};

//--- This enumeration should correspond to the previous one, and is used to name the array of IStreams
//---   used to write stuff to the debug file
static const SPLSTR StreamTypeStrings[] =
{
    DEF_SPLSTR( "Wave"           ),
    DEF_SPLSTR( "Epoch"          ),
    DEF_SPLSTR( "Unit"           ),
    DEF_SPLSTR( "WaveInfo"       ),
    DEF_SPLSTR( "ToBI"           ),
    DEF_SPLSTR( "SentenceBreaks" ),
    DEF_SPLSTR( "NormalizedText" ),
    DEF_SPLSTR( "LexLookup"      ),
    DEF_SPLSTR( "PosPossibilities" ),
    DEF_SPLSTR( "Morphology" ),
};

//--- This const is just the storage mode with which the debug file and its associated streams are opened
static const DWORD STORAGE_MODE = ( STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE );


#define TEXT_LEN_MAX	20
//--- This struct is used to keep track of pitch information for outputting to the debug streams
struct PITCH_TARGET
{
    float   time;
    float   level;
    enum TOBI_ACCENT accent;

	//--- Diagnostic
	enum ACCENT_SOURCE		accentSource;		
	enum BOUNDARY_SOURCE	boundarySource;
	char					textStr[TEXT_LEN_MAX];
};

//--- This class implements most of the functionality required for TTS Debugging Support
class CTTSDebug
{
public:

    //=== Interface Functions ===//

    //--- Constructor - just sets all member variables to NULL
    CTTSDebug() 
    {
        m_pDebugFile = NULL;
        for ( int i = 0; i < STREAM_LASTTYPE; i++ )
        {
            m_pDebugStreams[i] = NULL;
        }
        m_fInitialized = false;
    }

    //--- Destructor - just closes the file
    ~CTTSDebug()
    {
        CloseDebugFile();
    }

    //--- OpenDebugFile - opens a file (path is obtained from the Key DebugFile in the voices registry
    //---   entry) and associated streams...
    void OpenDebugFile( WCHAR *pFileName )
    {
        HRESULT hr = S_OK;
        hr = StgCreateDocfile( pFileName, STORAGE_MODE, 0, &m_pDebugFile );
        if ( SUCCEEDED( hr ) )
        {
            for ( int i = 0; SUCCEEDED( hr ) && i < STREAM_LASTTYPE; i++ )
            {
                hr = m_pDebugFile->CreateStream( StreamTypeStrings[i].pStr, STORAGE_MODE, 0, 0, &m_pDebugStreams[i] );
            }
        }
        if ( FAILED( hr ) )
        {
            CloseDebugFile();
        }
        else
        {
            m_fInitialized = true;
        }
    }

    //--- CloseDebugFile - just closes the file and streams opened by OpenDebugFile
    void    CloseDebugFile( void )
    {
        if ( m_pDebugFile )
        {
            for ( int i = 0; i < STREAM_LASTTYPE; i++ )
            {
                if ( m_pDebugStreams[i] )
                {
                    m_pDebugStreams[i]->Release();
                    m_pDebugStreams[i] = NULL;
                }
            }
            m_pDebugFile->Release();
            m_pDebugFile = NULL;
            m_fInitialized = false;
        }
    }

    //--- AppendToStream - writes data to the Stream specified by Type
    void    AppendToStream( STREAM_TYPE Type, void *pData, ULONG cBytes )
    {
        HRESULT hr = S_OK;
        hr = m_pDebugStreams[Type]->Write( pData, cBytes, NULL );
    }




    //--- AddPitchToList - keeps track of pitch targets which will later be output to a debug stream
    void    AddPitchToList( float time, 
							float level, 
							TOBI_ACCENT accent,
							ACCENT_SOURCE		accentSource,
							BOUNDARY_SOURCE	boundarySource,
							char *pTextStr)
    {
        PITCH_TARGET        *pNewPitch, *pNextPitch;
        SPLISTPOS           curPosition, nextPosition;

        pNewPitch = new PITCH_TARGET;
        if( pNewPitch )
        {
            pNewPitch->time = time;
            pNewPitch->level = level;
            pNewPitch->accent = accent;
			if( pTextStr )
			{
				strcpy( pNewPitch->textStr, pTextStr );
			}
			else
			{
				// No string
				pNewPitch->textStr[0] = 0;
			}
			pNewPitch->accentSource = accentSource;
			pNewPitch->boundarySource = boundarySource;

           if( PitchTargetList.IsEmpty() )
            {
                PitchTargetList.AddHead( pNewPitch );
            }
            else
            {
                nextPosition = PitchTargetList.GetHeadPosition();
                while( nextPosition )
                {
                    curPosition = nextPosition;
                    pNextPitch = (PITCH_TARGET*)PitchTargetList.GetNext( nextPosition );
                    if( time < pNextPitch->time )
                    {
                        PitchTargetList.InsertBefore( curPosition, pNewPitch );
                        break;
                    }
                    if( nextPosition == NULL )
                    {
                        PitchTargetList.AddTail( pNewPitch );
                        break;
                    }
                }
            }
        }
    }

    //--- DeletePitchList - Cleans up pitch target list after it has been output to a debug stream
    void DeletePitchList()
    {
        PITCH_TARGET *pTarget;
        while ( !PitchTargetList.IsEmpty() )
        {
            pTarget = (PITCH_TARGET*)PitchTargetList.RemoveHead();
            delete pTarget;
        }
    }

    //--- IsInitialized - Just returns true or false based on whether OpenDebugFile has been called
    //---   and has succeeded...
    bool    IsInitialized() { return m_fInitialized; }

    //=== Member Variables ===//

private:
    IStorage    *m_pDebugFile;
    IStream     *m_pDebugStreams[STREAM_LASTTYPE];
    bool        m_fInitialized;
public:
    CSPList<PITCH_TARGET*,PITCH_TARGET*> PitchTargetList;
};

inline CTTSDebug *pTTSDebug()
{
    static CTTSDebug debug;
    return &debug;
}


#define TTSDBG_OPENFILE                                                                     \
    do                                                                                      \
    {                                                                                       \
        CSpDynamicString dstrTemp;                                                          \
        if ( SUCCEEDED( m_cpToken->GetStringValue( L"DebugFile", &dstrTemp) ) )             \
        {                                                                                   \
            pTTSDebug()->OpenDebugFile( dstrTemp );                                         \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_CLOSEFILE                                                                    \
    pTTSDebug()->CloseDebugFile()

#define TTSDBG_LOGITEMLIST( ItemList, Stream )                                              \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            SPLISTPOS ListPos = ItemList.GetHeadPosition();                                 \
            DebugSentItem Item;                                                             \
            pTTSDebug()->AppendToStream( Stream, (void*) &Item, sizeof( Item ) );           \
            while ( ListPos )                                                               \
            {                                                                               \
                ZeroMemory( &Item, sizeof( Item ) );                                        \
                Item = ItemList.GetNext( ListPos );                                         \
                pTTSDebug()->AppendToStream( Stream, (void*) &Item, sizeof( Item ) );       \
            }                                                                               \
            pItemEnum->Reset();                                                             \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_LOGPOSPOSSIBILITIES( pProns, ulNumWords, Stream )                            \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            ULONG ulIndex = 0;                                                              \
            DebugPronRecord dbgRecord;                                                      \
            pTTSDebug()->AppendToStream( Stream, (void*) &dbgRecord,                        \
                                         sizeof( DebugPronRecord ) );                       \
            while ( ulIndex < ulNumWords )                                                  \
            {                                                                               \
                dbgRecord = pProns[ulIndex];                                                \
                pTTSDebug()->AppendToStream( Stream, (void*) &dbgRecord,                    \
                                             sizeof( DebugPronRecord ) );                   \
                ulIndex++;                                                                  \
            }                                                                               \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_LOGMORPHOLOGY( pwRoot, SuffixList, Stream )                                  \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            pTTSDebug()->AppendToStream( Stream, (void*) pwRoot,                            \
                                         SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );            \
            SPLISTPOS ListPos = SuffixList.GetHeadPosition();                               \
            SUFFIXPRON_INFO* pSuffixPron;                                                   \
            while ( ListPos )                                                               \
            {                                                                               \
                pSuffixPron = SuffixList.GetNext( ListPos );                                \
                pTTSDebug()->AppendToStream( Stream, (void*) pSuffixPron->SuffixString,     \
                                             SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );        \
            }                                                                               \
            WCHAR Delimiter[SP_MAX_WORD_LENGTH];                                            \
            ZeroMemory( Delimiter, SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );                  \
            pTTSDebug()->AppendToStream( Stream, (void*) Delimiter,                         \
                                         SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );            \
        }                                                                                   \
    }                                                                                       \
    while (0)
                                             

#define TTSDBG_LOGWAVE                                                                      \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            if ( m_SpeechState == SPEECH_CONTINUE )                                         \
            {                                                                               \
                pTTSDebug()->AppendToStream( STREAM_WAVE, (void*)m_pSpeechBuf,              \
                                             m_cOutSamples_Frame * m_BytesPerSample );      \
            }                                                                               \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_ADDPITCHTARGET( time, level, accent)                                         \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            pTTSDebug()->AddPitchToList( time, level, accent, m_CurAccentSource, m_CurBoundarySource, m_pCurTextStr );                              \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_LOGTOBI                                                                      \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            SPLISTPOS       curPosition;                                                    \
            PITCH_TARGET    *pPitch;                                                        \
            curPosition = pTTSDebug()->PitchTargetList.GetHeadPosition();                   \
            while( curPosition )                                                            \
            {                                                                               \
                pPitch = (PITCH_TARGET*)pTTSDebug()->PitchTargetList.GetNext(curPosition);  \
                pTTSDebug()->AppendToStream( STREAM_TOBI, (void*)pPitch,                    \
                                             sizeof(PITCH_TARGET) );                        \
            }                                                                               \
            pTTSDebug()->DeletePitchList();                                                 \
        }                                                                                   \
    }                                                                                       \
    while (0)





#define TTSDBG_LOGSILEPOCH																		\
    do																							\
    {             																				\
        float	fEpoch;																			\
																								\
        if( pTTSDebug()->IsInitialized() )														\
        {																						\
			if( m_silMode )																		\
			{																					\
				fEpoch = (float)m_durationTarget;												\
				pTTSDebug()->AppendToStream( STREAM_EPOCH, (void*)&fEpoch, sizeof(float) );		\
			}                                                                                   \
		}																						\
    }																							\
    while (0)





#define TTSDBG_LOGEPOCHS																		\
    do																							\
    {             																				\
        if( pTTSDebug()->IsInitialized() )														\
        {																						\
			float	fEpoch;																		\
																								\
			if( OutSize > 1 )																	\
			{																					\
				fEpoch = (float)OutSize;														\
				pTTSDebug()->AppendToStream( STREAM_EPOCH, (void*)&fEpoch, sizeof(float) );		\
			}																					\
		}																						\
    }																							\
    while (0)



#define TTSDBG_LOGUNITS                                                                     \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            UNIT_STREAM         us;                                                         \
                                                                                            \
            us.phonID   = pCurUnit->PhonID;                                                 \
            us.unitID   = pCurUnit->UnitID;                                                 \
            us.flags    = pCurUnit->flags;                                                  \
			us.ctrlFlags	= pCurUnit->ctrlFlags;                                          \
            us.cEpochs  = 1;                                                                \
            us.cSamples = m_durationTarget;                                                 \
            us.time     = (float)m_cOutSamples_Total / m_SampleRate;                        \
            us.knots    = KNOTS_PER_PHON;                                                   \
            for( i = 0; i < KNOTS_PER_PHON; i++ )                                           \
            {                                                                               \
                us.pTime[i] = pCurUnit->pTime[i];                                           \
                us.pF0[i]   = pCurUnit->pF0[i];                                             \
                us.pAmp[i]  = pCurUnit->pAmp[i];                                            \
            }                                                                               \
            strcpy( us.name, pCurUnit->szUnitName );										\
			us.silenceSource = pCurUnit->silenceSource;                                     \
            pTTSDebug()->AppendToStream( STREAM_UNIT, (void*)&us, sizeof(UNIT_STREAM) );    \
        }                                                                                   \
    }                                                                                       \
    while (0)

#else // _DEBUG

#define TTSDBG_OPENFILE
#define TTSDBG_CLOSEFILE
#define TTSDBG_LOGITEMLIST(ItemList, Stream)
#define TTSDBG_LOGWAVE
#define TTSDBG_ADDPITCHTARGET(time, level, accent)
#define TTSDBG_LOGTOBI
#define TTSDBG_LOGEPOCHS
#define TTSDBG_LOGSILEPOCH
#define TTSDBG_LOGUNITS
#define TTSDBG_LOGPOSPOSSIBILITIES( pProns, ulNumWords, Stream )
#define TTSDBG_LOGMORPHOLOGY( pwRoot, SuffixList, Stream )

#endif // _DEBUG
#endif // spttsengdebug_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\numnorm.cpp ===
/***********************************************************************************************
* NumNorm.cpp *
*-------------*
*  Description:
*   These functions normalize ordinary ordinal and cardinal numbers
*-----------------------------------------------------------------------------------------------
*  Created by AH                                                                August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

/***********************************************************************************************
* IsNumberCategory *
*------------------*
*   Description:
*       Checks the next token in the text stream to determine if it is a number category -
*   percents, degrees, squared and cubed numbers, and plain old numbers get matched here.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumberCategory( TTSItemInfo*& pItemNormInfo, const WCHAR* Context,
                                        CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

    TTSItemInfo *pNumberInfo = NULL;
    hr = IsNumber( pNumberInfo, Context, MemoryManager );
    if ( SUCCEEDED( hr )                 &&
         pNumberInfo->Type != eDATE_YEAR &&
         ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar == m_pEndOfCurrItem - 1 )
    {
        if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'%' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_PERCENT;
        }
        else if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_DEGREES;
        }
        else if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_SQUARED;
        }
        else if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_CUBED;
        }
        else
        {
            hr = E_INVALIDARG;
            delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
        }
    }
    else if ( SUCCEEDED( hr ) &&
              ( pNumberInfo->Type == eDATE_YEAR ||
                ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar == m_pEndOfCurrItem ) )
    {
        pItemNormInfo = pNumberInfo;
    }
    else if ( SUCCEEDED( hr ) )
    {
        hr = E_INVALIDARG;

        if ( pNumberInfo->Type != eDATE_YEAR )
        {
            delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
        }

        m_pNextChar      = pTempNextChar;
        m_pEndChar       = pTempEndChar;
        m_pEndOfCurrItem = pTempEndOfItem;
        m_pCurrFrag      = pTempFrag;
    }

    return hr;
} /* IsNumberCategory */

/***********************************************************************************************
* IsNumber *
*----------*
*   Description:
*       Checks the next token in the text stream to determine if it is a number.
*
*   RegExp:
*       [-]? { d+ || d(1-3)[,ddd]+ } { { .d+ } || { "st" || "nd" || "rd" || "th" } }?
*   It is actually a bit more complicated than this - for instance, the ordinal
*   strings may only follow certain digits (1st, 2nd, 3rd, 4-0th)...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                CSentItemMemory& MemoryManager, BOOL fMultiItem )
{
    SPDBG_FUNC( "CStdSentEnum::IsNumber" );

    HRESULT hr = S_OK;

    bool fNegative = false;
    TTSIntegerItemInfo*     pIntegerInfo        = NULL;
    TTSDigitsItemInfo*      pDecimalInfo        = NULL;
    TTSFractionItemInfo* pFractionInfo       = NULL;
    const SPVSTATE *pIntegerState = &m_pCurrFrag->State;
    CItemList PostIntegerList;
    ULONG ulOffset = 0, ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    WCHAR wcDecimalPoint;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

    if ( ulTokenLen )
    {
        //--- Set Separator and Decimal Point character preferences for this call
        if ( m_eSeparatorAndDecimal == COMMA_PERIOD )
        {
            wcDecimalPoint  = L'.';
        }
        else
        {
            wcDecimalPoint  = L',';
        }

        //--- Try to match the negative sign - [-]?
        if ( m_pNextChar[ulOffset] == L'-' )
        {
            fNegative = true;
            ulOffset++;
        }
    
        //--- Try to match the integral part
        hr = IsInteger( m_pNextChar + ulOffset, pIntegerInfo, MemoryManager );

        //--- Adjust ulOffset and hr...
        if ( SUCCEEDED( hr ) )
        {
            ulOffset += (ULONG)(pIntegerInfo->pEndChar - pIntegerInfo->pStartChar);
        }
        else if ( hr == E_INVALIDARG )
        {
            hr = S_OK;
            pIntegerInfo = NULL;
        }

        //--- Try to match a decimal part
        if ( ulOffset < ulTokenLen &&
             m_pNextChar[ulOffset] == wcDecimalPoint )
        {
            hr = IsDigitString( m_pNextChar + ulOffset + 1, pDecimalInfo, MemoryManager );
            if ( SUCCEEDED( hr ) )
            {
                ulOffset += pDecimalInfo->ulNumDigits + 1;

                //--- Check for special case - decimal number numerator...
                if ( ulOffset < ulTokenLen &&
                     m_pNextChar[ulOffset] == L'/' )
                {
                    pIntegerInfo = NULL;
                    pDecimalInfo = NULL;
                    fNegative ? ulOffset = 1 : ulOffset = 0;
                    hr = IsFraction( m_pNextChar + ulOffset, pFractionInfo, MemoryManager );
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( pFractionInfo->pVulgar )
                        {
                            ulOffset++;
                        }
                        else
                        {
                            ulOffset += (ULONG)(pFractionInfo->pDenominator->pEndChar - pFractionInfo->pNumerator->pStartChar);
                        }
                    }
                    else if ( hr == E_INVALIDARG )
                    {
                        hr = S_OK;
                    }
                }
            }
            else if ( hr == E_INVALIDARG )
            {
                hr = S_OK;
                pDecimalInfo = NULL;
            }
        }
        //--- Try to match an ordinal string
        else if ( pIntegerInfo          &&
                  ulOffset < ulTokenLen &&
                  isalpha( m_pNextChar[ulOffset] ) )
        {
            switch ( toupper( m_pNextChar[ulOffset] ) )
            {
            case 'S':
                //--- Must be of the form "...1st" but not "...11st" 
                if ( toupper( m_pNextChar[ulOffset+1] ) == L'T'  && 
                     m_pNextChar[ulOffset-1] == L'1'             &&
                     (ulOffset + 2) == ulTokenLen                &&
                     m_pNextChar[ulOffset-2] != L'1' )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            case 'N':
                //--- Must be of the form "...2nd" but not "...12nd" 
                if ( (ulOffset + 2) == ulTokenLen                &&
                     toupper(m_pNextChar[ulOffset+1]) == L'D'    &&
                     m_pNextChar[ulOffset-1] == L'2'             &&                
                     m_pNextChar[ulOffset-2] != L'1' )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            case 'R':
                //--- Must be of the form "...3rd" but not "...13rd" 
                if ( (ulOffset + 2) == ulTokenLen                &&
                     toupper(m_pNextChar[ulOffset+1]) == L'D'    &&
                     m_pNextChar[ulOffset-1] == L'3'             &&
                     m_pNextChar[ulOffset-2] != L'1' )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            case 'T':
                //--- Must be of the form "...[4-9]th" or "...[11-19]th" or "...[0]th" 
                if ( (ulOffset + 2) == ulTokenLen                 &&
                     toupper(m_pNextChar[ulOffset+1]) == L'H'     &&                
                     ( ( m_pNextChar[ulOffset-1] <= L'9' && m_pNextChar[ulOffset-1] >= L'4') ||
                       ( m_pNextChar[ulOffset-1] == L'0')                                    ||
                       ( m_pNextChar[ulOffset-2] == L'1') ) )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            default:
                // Some invalid non-digit character found at the end of the string
                break;
            }
        }
        //--- Try to match a fraction
        else
        {
            //--- Try to match an attached fraction
            if ( ulOffset < ulTokenLen )
            {
                if ( m_pNextChar[ulOffset] == L'-' )
                {
                    ulOffset++;
                }
                hr = IsFraction( m_pNextChar + ulOffset, pFractionInfo, MemoryManager );
                if ( SUCCEEDED( hr ) )
                {
                    if ( pFractionInfo->pVulgar )
                    {
                        ulOffset++;
                    }
                    else
                    {
                        ulOffset += (ULONG)(pFractionInfo->pDenominator->pEndChar - pFractionInfo->pNumerator->pStartChar);
                    }
                }
                else if ( hr == E_INVALIDARG )
                {
                    hr = S_OK;
                }
            }
            //--- Try to match an unattached fraction
            else if ( fMultiItem )
            {
                pIntegerState = &m_pCurrFrag->State;

                //--- Advance in text
                m_pNextChar = m_pEndOfCurrItem;
                hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, 
                                            true, &PostIntegerList );
                if ( !m_pNextChar &&
                     SUCCEEDED( hr ) )
                {
                    m_pNextChar = pTempNextChar;
                    m_pEndChar  = pTempEndChar;
                    m_pCurrFrag = pTempFrag;
                }
                else if ( m_pNextChar &&
                          SUCCEEDED( hr ) )
                {
                    m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                    while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) )  != eUNMATCHED ||
                            IsGroupEnding( *(m_pEndOfCurrItem - 1) )      != eUNMATCHED ||
                            IsQuotationMark( *(m_pEndOfCurrItem - 1) )    != eUNMATCHED ||
                            IsEOSItem( *(m_pEndOfCurrItem - 1) )          != eUNMATCHED )
                    {
                        m_pEndOfCurrItem--;
                    }
                
                    hr = IsFraction( m_pNextChar, pFractionInfo, MemoryManager );

                    if ( FAILED( hr ) )
                    {
                        m_pNextChar      = pTempNextChar;
                        m_pEndChar       = pTempEndChar;
                        m_pEndOfCurrItem = pTempEndOfItem;
                        m_pCurrFrag      = pTempFrag;
                        if ( hr == E_INVALIDARG )
                        {
                            hr = S_OK;
                        }
                    }
                    else
                    {
                        ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                        if ( pFractionInfo->pVulgar )
                        {
                            ulOffset = 1;
                        }
                        else
                        {
                            ulOffset = (ULONG)(pFractionInfo->pDenominator->pEndChar - 
                                               pFractionInfo->pNumerator->pStartChar);
                        }                            
                    }
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    //--- If we haven't processed the whole item yet, and it isn't part of a larger item --
    //---   e.g. a percent, a degrees number, or a square or cube -- then fail to match it 
    //---   as a number...
    if ( ulOffset != ulTokenLen &&
         !( ulTokenLen == ulOffset + 1 &&
            ( m_pNextChar[ulOffset] == L'%' ||
              m_pNextChar[ulOffset] == L'' ||
              m_pNextChar[ulOffset] == L'' ||
              m_pNextChar[ulOffset] == L'' ) ) )           
    {
        m_pNextChar         = pTempNextChar;
        m_pEndOfCurrItem    = pTempEndOfItem;
		m_pEndChar          = pTempEndChar;
		m_pCurrFrag         = pTempFrag;
		hr                  = E_INVALIDARG;
    }


    //--- Fill out pItemNormInfo...
    if ( SUCCEEDED( hr ) &&
         ( pIntegerInfo ||
           pDecimalInfo ||
           pFractionInfo ) )
    {
        //--- Reset m_pNextChar to handle the Mixed Fraction case...
        m_pNextChar = pTempNextChar;

        if ( pIntegerInfo                                           && 
             pIntegerInfo->pEndChar - pIntegerInfo->pStartChar == 4 &&
             !pIntegerInfo->fSeparators                             &&
             !pIntegerInfo->fOrdinal                                &&
             !pDecimalInfo                                          &&
             !pFractionInfo                                         &&
             !fNegative                                             &&
             ulOffset == ulTokenLen                                 &&
             ( !Context ||
               _wcsnicmp( Context, L"NUMBER", 6 ) != 0 ) )
        {
            pItemNormInfo = (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof( TTSYearItemInfo ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo->Type = eDATE_YEAR;
                ( (TTSYearItemInfo*) pItemNormInfo )->pYear = m_pNextChar;
                ( (TTSYearItemInfo*) pItemNormInfo )->ulNumDigits = 4;
            }
        }
        else
        {
            pItemNormInfo = (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( pItemNormInfo, sizeof( TTSNumberItemInfo ) );
                if ( pDecimalInfo )
                {
                    pItemNormInfo->Type = eNUM_DECIMAL;
                    if ( pIntegerInfo )
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pIntegerInfo->pEndChar +
                                                                           pDecimalInfo->ulNumDigits + 1;
                    }
                    else
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = m_pNextChar + pDecimalInfo->ulNumDigits + 1;
                        if ( fNegative )
                        {
                            ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar++;
                        }
                    }
                }
                else if ( pFractionInfo )
                {
                    if ( pFractionInfo->pVulgar )
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pFractionInfo->pVulgar + 1;
                    }
                    else
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar =
                                                            pFractionInfo->pDenominator->pEndChar;
                    }
                    if ( pIntegerInfo )
                    {
                        pItemNormInfo->Type = eNUM_MIXEDFRACTION;
                    }
                    else
                    {
                        pItemNormInfo->Type = eNUM_FRACTION;
                    }
                }
                else if ( pIntegerInfo )
                {
                    if ( pIntegerInfo->fOrdinal )
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pIntegerInfo->pEndChar + 2;
                        pItemNormInfo->Type = eNUM_ORDINAL;
                    }
                    else
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pIntegerInfo->pEndChar;
                        pItemNormInfo->Type = eNUM_CARDINAL;
                    }                    
                }               
            }

            if ( SUCCEEDED( hr ) )
            {
                ( (TTSNumberItemInfo*) pItemNormInfo )->fNegative        = fNegative;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pIntegerPart     = pIntegerInfo;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pDecimalPart     = pDecimalInfo;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pFractionalPart  = pFractionInfo;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pStartChar       = m_pNextChar;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList        = new CWordList;
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    //--- Expand Number into WordList
    if ( SUCCEEDED( hr ) &&
         pItemNormInfo->Type != eDATE_YEAR )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );
        Word.pXmlState          = pIntegerState;
        Word.eWordPartOfSpeech  = MS_Unknown;

        //--- Insert "negative"
        if ( fNegative )
        {
            Word.pWordText  = g_negative.pStr;
            Word.ulWordLen  = g_negative.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( Word );
        }

        //--- Expand Integral Part
        if ( pIntegerInfo )
        {
            ExpandInteger( pIntegerInfo, Context, *( (TTSNumberItemInfo*) pItemNormInfo )->pWordList );
        }

        //--- Expand Decimal Part
        if ( pDecimalInfo )
        {
            //--- Insert "point"
            Word.pWordText  = g_decimalpoint.pStr;
            Word.ulWordLen  = g_decimalpoint.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( Word );

            ExpandDigits( pDecimalInfo, *( (TTSNumberItemInfo*) pItemNormInfo )->pWordList );
        }

        //--- Expand Fractional Part
        if ( pFractionInfo )
        {
            //--- Insert Post-Integer Non-Spoken XML States, if any
            while ( !PostIntegerList.IsEmpty() )
            {
                ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( ( PostIntegerList.RemoveHead() ).Words[0] );
            }

            //--- Insert "and", if also an integer part
            if ( pIntegerInfo )
            {
                Word.pXmlState  = &m_pCurrFrag->State;
                Word.pWordText  = g_And.pStr;
                Word.ulWordLen  = g_And.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( Word );
            }

            hr = ExpandFraction( pFractionInfo, *( (TTSNumberItemInfo*) pItemNormInfo )->pWordList );
        }
    }

    return hr;
} /* IsNumber */

/***********************************************************************************************
* ExpandNumber *
*--------------*
*   Description:
*       Expands Items previously determined to be of type NUM_CARDINAL, NUM_DECIMAL, or 
*   NUM_ORDINAL by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandNumber( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "NumNorm ExpandNumber" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    return hr;
} /* ExpandNumber */

/***********************************************************************************************
* ExpandPercent *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_PERCENT by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandPercent( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandPercent" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    Word.pWordText          = g_percent.pStr;
    Word.ulWordLen          = g_percent.Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    WordList.AddTail( Word );

    return hr;
} /* ExpandPercent */

/***********************************************************************************************
* ExpandDegree *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_DEGREES by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandDegrees( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDegrees" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( !pItemInfo->pDecimalPart       &&
         !pItemInfo->pFractionalPart    &&
         pItemInfo->pIntegerPart        &&
         pItemInfo->pIntegerPart->pEndChar - pItemInfo->pIntegerPart->pStartChar == 1 &&
         pItemInfo->pIntegerPart->pStartChar[0] == L'1' )
    {
        Word.pWordText  = g_degree.pStr;
        Word.ulWordLen  = g_degree.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
    }
    else if ( !pItemInfo->pIntegerPart   &&
              pItemInfo->pFractionalPart &&
              !pItemInfo->pFractionalPart->fIsStandard )
    {
        Word.pWordText  = g_of.pStr;
        Word.ulWordLen  = g_of.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );

        Word.pWordText  = g_a.pStr;
        Word.ulWordLen  = g_a.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );

        Word.pWordText  = g_degree.pStr;
        Word.ulWordLen  = g_degree.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
    }
    else
    {
        Word.pWordText  = g_degrees.pStr;
        Word.ulWordLen  = g_degrees.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
    }

    WordList.AddTail( Word );

    return hr;
} /* ExpandDegrees */

/***********************************************************************************************
* ExpandSquare *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_SQUARED by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandSquare( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandSquare" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    Word.pWordText          = g_squared.pStr;
    Word.ulWordLen          = g_squared.Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    WordList.AddTail( Word );

    return hr;
} /* ExpandSquare */

/***********************************************************************************************
* ExpandCube *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_CUBED by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandCube( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandCube" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    Word.pWordText          = g_cubed.pStr;
    Word.ulWordLen          = g_cubed.Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    WordList.AddTail( Word );

    return hr;
} /* ExpandCube */

/***********************************************************************************************
* IsInteger *
*-----------*
*   Description:
*       Helper for IsNumber which matches the integer part...
*
*   RegExp:
*       { d+ || d(1-3)[,ddd]+ }
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsInteger( const WCHAR* pStartChar, TTSIntegerItemInfo*& pIntegerInfo, 
                                 CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    ULONG ulOffset = 0, ulCount = 0, ulTokenLen = (ULONG)(m_pEndOfCurrItem - pStartChar);
    BOOL fSeparators = false, fDone = false;
    WCHAR wcSeparator, wcDecimalPoint;

    if ( m_eSeparatorAndDecimal == COMMA_PERIOD )
    {
        wcSeparator  = L',';
        wcDecimalPoint = L'.';
    }
    else
    {
        wcSeparator  = L'.';
        wcDecimalPoint = L',';
    }

    //--- Check for first digit 
    if ( !isdigit(pStartChar[ulOffset]) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ulCount++;
        ulOffset++;
    }

    //--- Check for separators
    ULONG i = ulOffset + 3;
    while ( SUCCEEDED( hr ) && 
            ulOffset < i    && 
            ulOffset < ulTokenLen )
    {
        if ( pStartChar[ulOffset] == wcSeparator )
        {
            //--- Found a separator 
            fSeparators = true;
            break;
        }
        else if ( !isdigit( pStartChar[ulOffset] ) &&
                  ( pStartChar[ulOffset] == wcDecimalPoint  ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'-'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    toupper( pStartChar[ulOffset] ) == L'S' ||
                    toupper( pStartChar[ulOffset] ) == L'N' ||
                    toupper( pStartChar[ulOffset] ) == L'R' ||
                    toupper( pStartChar[ulOffset] ) == L'T' ) )
        {
            fDone = true;
            break;
        }
        else if ( isdigit( pStartChar[ulOffset] ) )
        {
            //--- Just another digit 
            ulCount++;
            ulOffset++;
        }
        else
        {
            hr = E_INVALIDARG;
            break;
        }
    }

    if ( SUCCEEDED( hr ) && 
         !fDone          && 
         ulOffset < ulTokenLen )
    {
        if ( !fSeparators )
        {
            //--- No separators.  Pattern must be {d+} if this is indeed a number, so just count digits. 
            while ( isdigit( pStartChar[ulOffset] ) && 
                    ulOffset < ulTokenLen )
            {
                ulCount++;
                ulOffset++;
            }
            if ( ulOffset != ulTokenLen &&
                 !( pStartChar[ulOffset] == wcDecimalPoint  ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'-'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    toupper( pStartChar[ulOffset] ) == L'S' ||
                    toupper( pStartChar[ulOffset] ) == L'N' ||
                    toupper( pStartChar[ulOffset] ) == L'R' ||
                    toupper( pStartChar[ulOffset] ) == L'T' ) )
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            //--- Separators.  Pattern must be { d(1-3)[,ddd]+ }, so make sure the separators match up 
            while ( SUCCEEDED( hr )                     && 
                    pStartChar[ulOffset] == wcSeparator && 
                    ( ulOffset + 3 ) < ulTokenLen)
            {
                ulOffset++;
                for ( i = ulOffset + 3; SUCCEEDED( hr ) && ulOffset < i; ulOffset++ )
                {
                    if ( isdigit( pStartChar[ulOffset] ) )
                    {
                        ulCount++;
                    }
                    else // Some non-digit character found - abort!
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            if ( ulOffset != ulTokenLen && 
                 !( pStartChar[ulOffset] == wcDecimalPoint  ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'-'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    toupper( pStartChar[ulOffset] ) == L'S' ||
                    toupper( pStartChar[ulOffset] ) == L'N' ||
                    toupper( pStartChar[ulOffset] ) == L'R' ||
                    toupper( pStartChar[ulOffset] ) == L'T' ) )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        pIntegerInfo = (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo ), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pIntegerInfo, sizeof( TTSIntegerItemInfo ) );
            pIntegerInfo->fSeparators = fSeparators;
            pIntegerInfo->lLeftOver   = ulCount % 3;
            pIntegerInfo->lNumGroups  = ( ulCount - 1 ) / 3;
            pIntegerInfo->pStartChar  = pStartChar;
            pIntegerInfo->pEndChar    = pStartChar + ulOffset;
        }
    }

    return hr;
} /* IsInteger */

/***********************************************************************************************
* ExpandInteger *
*---------------*
*   Description:
*       
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandInteger( TTSIntegerItemInfo* pItemInfo, const WCHAR* Context, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandInteger" );

    //--- Local variable declarations and initialization
    BOOL bFinished = false;
    const WCHAR *pStartChar = pItemInfo->pStartChar, *pEndChar = pItemInfo->pEndChar;
    ULONG ulOffset = 0, ulTokenLen = (ULONG)(pEndChar - pStartChar), ulTemp = (ULONG)(pItemInfo->lNumGroups + 1);

    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Out of range integer, or integer beginning with one or more zeroes...
    if ( pStartChar[0] == L'0'                          || 
         ( Context &&
           _wcsicmp( Context, L"NUMBER_DIGIT" ) == 0 )   ||
         pItemInfo->lNumGroups >= sp_countof(g_quantifiers) )
    {
        pItemInfo->fDigitByDigit = true;
        pItemInfo->ulNumDigits   = 0;

        for ( ULONG i = 0; i < ulTokenLen; i++ )
        {
            if ( isdigit( pStartChar[i] ) )
            {
                ExpandDigit( pStartChar[i], pItemInfo->Groups[0], WordList );
                pItemInfo->ulNumDigits++;
            }
        }
    }
    //--- Expanding a number < 1000 
    else if ( pItemInfo->lNumGroups == 0 )
    {
        // 0th through 999th...
        if ( pItemInfo->fOrdinal )
        {
            switch ( pItemInfo->lLeftOver )
            {
            case 1:
                // 0th through 9th...
                ExpandDigitOrdinal( pStartChar[ulOffset], pItemInfo->Groups[0], WordList );
                break;
            case 2:
                // 10th through 99th...
                ExpandTwoOrdinal( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                break;
            case 0:
                // 100th through 999th...
                ExpandThreeOrdinal( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                break;
            case -1:
                ulTemp = 0;
                pItemInfo->lLeftOver = 0;
                break;
            }
        }
        // 0 through 999...
        else
        {
            switch ( pItemInfo->lLeftOver )
            {
            case 1:
                // 0 through 9...
                ExpandDigit( pStartChar[ulOffset], pItemInfo->Groups[0], WordList );
                ulOffset += 1;
                break;
            case 2:
                // 10 through 99...
                ExpandTwoDigits( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                ulOffset += 2;
                break;
            case 0:
                // 100 through 999...
                ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                ulOffset += 3;
                break;
            case -1:
                ulTemp = 0;
                pItemInfo->lLeftOver = 0;
                break;
            }
        }
    } 
    else
    {
        //--- 1000 through highest number covered, e.g. 1,234,567 

        //--- Expand first grouping, e.g. 1 million 
        //--- Expand digit group 
        switch ( pItemInfo->lLeftOver )
        {
        case 1:
            ExpandDigit( pStartChar[ulOffset], pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 1;
            break;
        case 2:
            ExpandTwoDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 2;
            break;
        case 0:
            ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
            break;
        } 
        //--- Special Case: rare ordinal cases - e.g. 1,000,000th 
        if ( pItemInfo->fOrdinal    &&
             Zeroes(pStartChar + ulOffset) )
        {
            //--- Insert ordinal quantifier 
            pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
            Word.pWordText  = g_quantifiersOrdinal[pItemInfo->lNumGroups].pStr;
            Word.ulWordLen  = g_quantifiersOrdinal[pItemInfo->lNumGroups--].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            bFinished = true;
        }
        //--- Default Case 
        else
        {
            //--- Insert quantifier
            pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
            Word.pWordText  = g_quantifiers[pItemInfo->lNumGroups].pStr;
            Word.ulWordLen  = g_quantifiers[pItemInfo->lNumGroups--].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }

        //--- Expand rest of groupings which need to be followed by a quantifier 
        while ( pItemInfo->lNumGroups > 0 && 
                !bFinished )
        {
            if ( pItemInfo->fSeparators )
            {
                ulOffset++;
            }
            //--- Expand digit group 
            ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
            //--- Special case: rare ordinal cases, e.g. 1,234,000th 
            if ( pItemInfo->fOrdinal    && 
                 Zeroes( pStartChar + ulOffset ) )
            {
                //--- Insert ordinal quantifier 
                pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
                Word.pWordText  = g_quantifiersOrdinal[pItemInfo->lNumGroups].pStr;
                Word.ulWordLen  = g_quantifiersOrdinal[pItemInfo->lNumGroups--].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                bFinished = true;
            }
            //--- Default Case 
            else if ( !ThreeZeroes( pStartChar + ulOffset - 3 ) )
            {
                //--- Insert quantifier
                pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
                Word.pWordText  = g_quantifiers[pItemInfo->lNumGroups].pStr;
                Word.ulWordLen  = g_quantifiers[pItemInfo->lNumGroups--].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            //--- Special Case: this grouping is all zeroes, e.g. 1,000,567 
            else
            {
                pItemInfo->lNumGroups--;
            }
        }

        //--- Expand final grouping, which requires no quantifier 
        if ( pItemInfo->fSeparators  && 
             !bFinished )
        {
            ulOffset++;
        }

        if ( pItemInfo->fOrdinal    &&
             !bFinished )
        {
            ExpandThreeOrdinal( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
        }
        else if ( !bFinished )
        {
            ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
        }
    }
    pItemInfo->lNumGroups = (long) ulTemp;
} /* ExpandInteger */

/***********************************************************************************************
* IsDigitString *
*---------------*
*   Description:
*       Helper for IsNumber, IsPhoneNumber, etc. which matches a digit string...
*
*   RegExp:
*       d+
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsDigitString( const WCHAR* pStartChar, TTSDigitsItemInfo*& pDigitsInfo,
                                     CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    ULONG ulOffset = 0;

    while ( pStartChar + ulOffset < m_pEndOfCurrItem &&
            isdigit( pStartChar[ulOffset] ) )
    {
        ulOffset++;
    }

    if ( ulOffset )
    {
        pDigitsInfo = (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof( TTSDigitsItemInfo ), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pDigitsInfo, sizeof( pDigitsInfo ) );
            pDigitsInfo->pFirstDigit = pStartChar;
            pDigitsInfo->ulNumDigits = ulOffset;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsDigitString */

/***********************************************************************************************
* ExpandDigits *
*--------------*
*   Description:
*       Expands a string of digits, digit by digit.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandDigits( TTSDigitsItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDigits" );
    
    for ( ULONG i = 0; i < pItemInfo->ulNumDigits; i++ )
    {
        NumberGroup Garbage;
        ExpandDigit( pItemInfo->pFirstDigit[i], Garbage, WordList );
    }
} /* ExpandDigits */

/***********************************************************************************************
* IsFraction *
*------------*
*   Description:
*       Helper for IsNumber which matches a fraction...
*
*   RegExp:
*       { NUM_CARDINAL || NUM_DECIMAL } / { NUM_CARDINAL || NUM_DECIMAL }
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsFraction( const WCHAR* pStartChar, TTSFractionItemInfo*& pFractionInfo, 
                                  CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsFraction" );

    HRESULT hr = S_OK;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - pStartChar);

    if ( ulTokenLen )
    {
        //--- Check for Vulgar Fraction
        if ( pStartChar[0] == L'' ||
             pStartChar[0] == L'' ||
             pStartChar[0] == L'' )
        {
            pFractionInfo = (TTSFractionItemInfo*) MemoryManager.GetMemory( sizeof( TTSFractionItemInfo ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( pFractionInfo, sizeof( TTSFractionItemInfo ) );
                pFractionInfo->pVulgar      = pStartChar;
                pFractionInfo->pNumerator   = 
                    (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pFractionInfo->pNumerator, sizeof( TTSNumberItemInfo ) );
                    pFractionInfo->pDenominator = 
                        (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pFractionInfo->pDenominator, sizeof( TTSNumberItemInfo ) );
                        pFractionInfo->pNumerator->pIntegerPart =
                            (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( pFractionInfo->pNumerator->pIntegerPart, sizeof( TTSIntegerItemInfo ) );
                            pFractionInfo->pDenominator->pIntegerPart =
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo ), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( pFractionInfo->pDenominator->pIntegerPart, sizeof( TTSIntegerItemInfo ) );
                                pFractionInfo->fIsStandard                                  = false;
                                pFractionInfo->pNumerator->pIntegerPart->lLeftOver          = 1;
                                pFractionInfo->pNumerator->pIntegerPart->lNumGroups         = 1;
                                pFractionInfo->pNumerator->pIntegerPart->Groups[0].fOnes    = true;
                                pFractionInfo->pDenominator->pIntegerPart->lLeftOver        = 1;
                                pFractionInfo->pDenominator->pIntegerPart->lNumGroups       = 1;
                                pFractionInfo->pDenominator->pIntegerPart->Groups[0].fOnes  = true;
                            }
                        }
                    }
                }
            }
        }
        //--- Check for multi-character fraction
        else
        {
            TTSItemInfo *pNumeratorInfo = NULL, *pDenominatorInfo = NULL;
            const WCHAR* pTempNextChar = m_pNextChar, *pTempEndOfCurrItem = m_pEndOfCurrItem;
            m_pNextChar = pStartChar;
            m_pEndOfCurrItem = wcschr( pStartChar, L'/' );
            if ( !m_pEndOfCurrItem ||
                 m_pEndOfCurrItem >= pTempEndOfCurrItem )
            {
                hr = E_INVALIDARG;
            }

            //--- Try to get numerator
            if ( SUCCEEDED( hr ) )
            {
                hr = IsNumber( pNumeratorInfo, L"NUMBER", MemoryManager, false );
            }
            if ( SUCCEEDED( hr ) &&
                 pNumeratorInfo->Type != eNUM_MIXEDFRACTION &&
                 pNumeratorInfo->Type != eNUM_FRACTION      &&
                 pNumeratorInfo->Type != eNUM_ORDINAL )
            {
                if ( ( (TTSNumberItemInfo*) pNumeratorInfo )->pIntegerPart )
                {
                    m_pNextChar += ( (TTSNumberItemInfo*) pNumeratorInfo )->pIntegerPart->pEndChar -
                                   ( (TTSNumberItemInfo*) pNumeratorInfo )->pIntegerPart->pStartChar;
                }
                if ( ( (TTSNumberItemInfo*) pNumeratorInfo )->pDecimalPart )
                {
                    m_pNextChar += ( (TTSNumberItemInfo*) pNumeratorInfo )->pDecimalPart->ulNumDigits + 1;
                }
            }
            else if ( SUCCEEDED( hr ) )
            {
                delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
                hr = E_INVALIDARG;
            }
            m_pEndOfCurrItem = pTempEndOfCurrItem;

            //--- Try to get denominator
            if ( SUCCEEDED( hr ) &&
                 m_pNextChar[0] == L'/' )
            {
                m_pNextChar++;
                hr = IsNumber( pDenominatorInfo, L"NUMBER", MemoryManager, false );
                if ( SUCCEEDED( hr ) &&
                     pDenominatorInfo->Type != eNUM_MIXEDFRACTION &&
                     pDenominatorInfo->Type != eNUM_FRACTION      &&
                     pDenominatorInfo->Type != eNUM_ORDINAL )
                {
                    pFractionInfo = 
                        ( TTSFractionItemInfo*) MemoryManager.GetMemory( sizeof( TTSFractionItemInfo ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pFractionInfo, sizeof( TTSFractionItemInfo ) );
                        pFractionInfo->pNumerator   = (TTSNumberItemInfo*) pNumeratorInfo;
                        pFractionInfo->pDenominator = (TTSNumberItemInfo*) pDenominatorInfo;
                        pFractionInfo->pVulgar      = NULL;
                        pFractionInfo->fIsStandard  = false;
                    }
                }
                else if ( SUCCEEDED( hr ) )
                {
                    delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
                    delete ( (TTSNumberItemInfo*) pDenominatorInfo )->pWordList;
                    hr = E_INVALIDARG;
                }
                else
                {
                    delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
                }
            }
            else if ( SUCCEEDED( hr ) )
            {
                hr = E_INVALIDARG;
                delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
            }

            m_pNextChar = pTempNextChar;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsFraction */

/***********************************************************************************************
* ExpandFraction *
*----------------*
*   Description:
*       Expands Items previously determined to be of type NUM_FRACTION by IsFraction.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandFraction( TTSFractionItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandFraction" );

    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Special case - vulgar fractions ( , ,  )
    if ( pItemInfo->pVulgar )
    {
        if ( pItemInfo->pVulgar[0] == L'' )
        {
            Word.pWordText  = g_ones[1].pStr;
            Word.ulWordLen  = g_ones[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            Word.pWordText  = g_onesOrdinal[4].pStr;
            Word.ulWordLen  = g_onesOrdinal[4].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else if ( pItemInfo->pVulgar[0] == L'' )
        {
            Word.pWordText  = g_ones[1].pStr;
            Word.ulWordLen  = g_ones[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            Word.pWordText  = g_Half.pStr;
            Word.ulWordLen  = g_Half.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else
        {
            Word.pWordText  = g_ones[3].pStr;
            Word.ulWordLen  = g_ones[3].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            Word.pWordText  = g_PluralDenominators[4].pStr;
            Word.ulWordLen  = g_PluralDenominators[4].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
    }
    else
    {
        //--- Insert Numerator WordList
        WordList.AddTail( pItemInfo->pNumerator->pWordList );

        delete pItemInfo->pNumerator->pWordList;

        //--- Expand denominator ---//

        //--- If no decimal part, must check for special cases ( x/2 - x/9, x/10, x/100 )
        if ( !pItemInfo->pDenominator->pDecimalPart &&
             !pItemInfo->pNumerator->pDecimalPart   &&
             !pItemInfo->pDenominator->fNegative )
        {
            //--- Check for special cases - halves through ninths 
            if ( ( pItemInfo->pDenominator->pEndChar - 
                   pItemInfo->pDenominator->pStartChar ) == 1 &&
                 pItemInfo->pDenominator->pStartChar[0] != L'1' )
            { 
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    if ( pItemInfo->pDenominator->pStartChar[0] == L'2' )
                    {
                        Word.pWordText  = g_Half.pStr;
                        Word.ulWordLen  = g_Half.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );
                    }
                    else
                    {
                        ExpandDigitOrdinal( pItemInfo->pDenominator->pStartChar[0], 
                                            pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                    }
                }
                //--- Insert plural form of denominator 
                else 
                {
                    ULONG index     = pItemInfo->pDenominator->pStartChar[0] - L'0';
                    Word.pWordText  = g_PluralDenominators[index].pStr;
                    Word.ulWordLen  = g_PluralDenominators[index].Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            //--- Check for special case - tenths 
            else if ( ( pItemInfo->pDenominator->pEndChar -
                       pItemInfo->pDenominator->pStartChar ) == 2 &&
                      wcsncmp( pItemInfo->pDenominator->pStartChar, L"10", 2 ) == 0 )
            {
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    ExpandTwoOrdinal( pItemInfo->pDenominator->pStartChar, 
                                      pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                }
                //--- Insert plural form denominator 
                else
                {
                    Word.pWordText  = g_Tenths.pStr;
                    Word.ulWordLen  = g_Tenths.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            //--- Check for special case - sixteenths
            else if ( ( pItemInfo->pDenominator->pEndChar -
                       pItemInfo->pDenominator->pStartChar ) == 2 &&
                      wcsncmp( pItemInfo->pDenominator->pStartChar, L"16", 2 ) == 0 )
            {
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    ExpandTwoOrdinal( pItemInfo->pDenominator->pStartChar, 
                                      pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                }
                //--- Insert plural form denominator 
                else
                {
                    Word.pWordText  = g_Sixteenths.pStr;
                    Word.ulWordLen  = g_Sixteenths.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            //--- Check for special case - hundredths 
            else if ( ( pItemInfo->pDenominator->pEndChar - 
                        pItemInfo->pDenominator->pStartChar ) == 3 &&
                      wcsncmp( pItemInfo->pDenominator->pStartChar, L"100", 3 ) == 0 )
            {
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    ExpandThreeOrdinal( pItemInfo->pDenominator->pStartChar,
                                        pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                }
                //--- Insert plural form of denominator 
                else
                {
                    Word.pWordText  = g_Hundredths.pStr;
                    Word.ulWordLen  = g_Hundredths.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            else
            {
                pItemInfo->fIsStandard = true;
            }
        }
        else
        {
            pItemInfo->fIsStandard = true;
        }

        //--- Default case - Numerator "over" Denominator 
        if ( pItemInfo->fIsStandard )
        {
            //--- Insert "over" 
            Word.pWordText  = g_Over.pStr;
            Word.ulWordLen  = g_Over.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert denominator WordList
            WordList.AddTail( pItemInfo->pDenominator->pWordList );
        }

        delete pItemInfo->pDenominator->pWordList;
    }
    return hr;
} /* ExpandFraction */

/***********************************************************************************************
* ExpandDigit *
*-------------*
*   Description:
*       Expands single digits into words, and inserts them into WordList
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandDigit( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDigit" );
    SPDBG_ASSERT( isdigit(Number) );

    // 0-9
    ULONG Index = Number - L'0';
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.pWordText          = g_ones[Index].pStr;
    Word.ulWordLen          = g_ones[Index].Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    Word.eWordPartOfSpeech  = MS_Unknown;
    WordList.AddTail( Word );
    NormGroupInfo.fOnes = true;
} /* ExpandDigit */

/***********************************************************************************************
* ExpandTwo *
*-----------*
*   Description:
*       Expands two digit strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandTwoDigits( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandTwoDigits" );
    SPDBG_ASSERT( NumberString              &&
                  wcslen(NumberString) >= 2 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1]) ); 

    // 10-99
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';
    ULONG IndexTwo = NumberString[1] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 1 )
    {
        // 20-99, or 00-09
        if (IndexOne != 0)
        {
            Word.pWordText  = g_tens[IndexOne].pStr;
            Word.ulWordLen  = g_tens[IndexOne].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            NormGroupInfo.fTens = true;
        }
        if ( IndexTwo != 0 )
        {
            ExpandDigit( NumberString[1], NormGroupInfo, WordList );
            NormGroupInfo.fOnes = true;
        }
    } 
    else 
    {
        // 10-19
        Word.pWordText  = g_teens[IndexTwo].pStr;
        Word.ulWordLen  = g_teens[IndexTwo].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        NormGroupInfo.fOnes = true;
    }
} /* ExpandTwo */

/***********************************************************************************************
* ExpandThree *
*-------------*
*   Description:
*       Expands three digit strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandThreeDigits( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandThreeDigits" );
    SPDBG_ASSERT( NumberString              && 
                  wcslen(NumberString) >= 3 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1])  && 
                  isdigit(NumberString[2]) ); 

    // 100-999
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 0 )
    {
        // Take care of hundreds...
        ExpandDigit( NumberString[0], NormGroupInfo, WordList );
        Word.pWordText  = g_quantifiers[0].pStr;
        Word.ulWordLen  = g_quantifiers[0].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        NormGroupInfo.fHundreds = true;
        NormGroupInfo.fOnes = false;
    }
    
    // Take care of tens and ones...
    ExpandTwoDigits( NumberString + 1, NormGroupInfo, WordList );

} /* ExpandThree */

/***********************************************************************************************
* ExpandDigitOrdinal *
*--------------------*
*   Description:
*       Expands single digit ordinal strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandDigitOrdinal( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDigitOrdinal" );
    SPDBG_ASSERT( isdigit(Number) );

    // 0-9
    ULONG Index = Number - L'0';
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.pWordText          = g_onesOrdinal[Index].pStr;
    Word.ulWordLen          = g_onesOrdinal[Index].Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    Word.eWordPartOfSpeech  = MS_Unknown;
    WordList.AddTail( Word );
    NormGroupInfo.fOnes = true;
} /* ExpandDigitOrdinal */

/***********************************************************************************************
* ExpandTwoOrdinal *
*------------------*
*   Description:
*       Expands two digit ordinal strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandTwoOrdinal( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandTwoOrdinal" );
    SPDBG_ASSERT( NumberString              &&
                  wcslen(NumberString) >= 2 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1]) ); 

    // 10-99
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';
    ULONG IndexTwo = NumberString[1] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 1 )
    {
        // 20-99, or 00-09
        if (IndexOne != 0)
        {
            if ( IndexTwo != 0 )
            {
                Word.pWordText  = g_tens[IndexOne].pStr;
                Word.ulWordLen  = g_tens[IndexOne].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                NormGroupInfo.fTens = true;
                ExpandDigitOrdinal( NumberString[1], NormGroupInfo, WordList );
                NormGroupInfo.fOnes = true;
            }
            else
            {
                Word.pWordText  = g_tensOrdinal[IndexOne].pStr;
                Word.ulWordLen  = g_tensOrdinal[IndexOne].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
        }
        else
        {
            ExpandDigitOrdinal( NumberString[1], NormGroupInfo, WordList );
        }
    } 
    else 
    {
        // 10-19
        Word.pWordText  = g_teensOrdinal[IndexTwo].pStr;
        Word.ulWordLen  = g_teensOrdinal[IndexTwo].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        NormGroupInfo.fOnes = true;
    }
} /* ExpandTwoOrdinal */

/***********************************************************************************************
* ExpandThreeOrdinal *
*--------------------*
*   Description:
*       Expands three digit ordinal strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandThreeOrdinal( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandThreeDigits" );
    SPDBG_ASSERT( NumberString              && 
                  wcslen(NumberString) >= 3 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1])  && 
                  isdigit(NumberString[2]) ); 

    // 100-999
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 0 )
    {
        ExpandDigit( NumberString[0], NormGroupInfo, WordList );
        //--- Special case - x hundredth
        if ( Zeroes( NumberString + 1 ) )
        {
            Word.pWordText  = g_quantifiersOrdinal[0].pStr;
            Word.ulWordLen  = g_quantifiersOrdinal[0].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            NormGroupInfo.fHundreds = true;
            NormGroupInfo.fOnes = false;
        }
        //--- Default case - x hundred yth
        else
        {
            Word.pWordText  = g_quantifiers[0].pStr;
            Word.ulWordLen  = g_quantifiers[0].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            ExpandTwoOrdinal( NumberString + 1, NormGroupInfo, WordList );
            NormGroupInfo.fHundreds = true;
        }
    }
    //--- Special case - no hundreds
    else
    {
        ExpandTwoOrdinal( NumberString + 1, NormGroupInfo, WordList );
    }
} /* ExpandThreeOrdinal */

/***********************************************************************************************
* MatchQuantifier *
*-----------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a numerical quantifier.
********************************************************************* AH **********************/
int MatchQuantifier( const WCHAR*& pStartChar, const WCHAR*& pEndChar )
{
    int Index = -1;

    for (int i = 0; i < sp_countof(g_quantifiers); i++)
    {
        if ( pEndChar - pStartChar >= g_quantifiers[i].Len &&
             wcsnicmp( pStartChar, g_quantifiers[i].pStr, g_quantifiers[i].Len ) == 0 )
        {
            pStartChar += g_quantifiers[i].Len;
            Index = i;
            break;
        }
    }

    return Index;
} /* MatchQuantifier */

/***********************************************************************************************
* IsCurrency *
*------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a currency.  
*
*   RegExp:
*       { [CurrencySign] { d+ || d(1-3)[,ddd]+ } { [.]d+ }? } { [whitespace] [quantifier] }? ||
*       { { d+ || d(1-3)[,ddd]+ } { [.]d+ }? { [whitespace] [quantifier] }? [whitespace]? [CurrencySign] }
*
*   Types assigned:
*       NUM_CURRENCY
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsCurrency( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                  CWordList& WordList )
{
    SPDBG_FUNC( "NumNorm IsCurrency" );

    HRESULT hr = S_OK;

    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem, *pTempEndChar = m_pEndChar;
    const SPVTEXTFRAG* pTempFrag = m_pCurrFrag;

    const SPVSTATE *pNumberXMLState = NULL, *pSymbolXMLState = NULL, *pQuantifierXMLState = NULL;
    CItemList PostNumberList, PostSymbolList;
    int iSymbolIndex = -1, iQuantIndex = -1;    
    TTSItemInfo* pNumberInfo = NULL;
    BOOL fDone = false, fNegative = false;
    WCHAR wcDecimalPoint = ( m_eSeparatorAndDecimal == COMMA_PERIOD ? L'.' : L',' );

    //--- Try to match [CurrencySign] [Number] [Quantifier]
    NORM_POSITION ePosition = UNATTACHED;
    if ( m_pNextChar[0] == L'-' )
    {
        fNegative = true;
        m_pNextChar++;
    }
    iSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );
    if ( iSymbolIndex >= 0 &&
         ePosition == PRECEDING )
    {
        pSymbolXMLState = &m_pCurrFrag->State;

        //--- Skip any whitespace in between the currency sign and the number...
        hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostSymbolList );
    
        if ( !m_pNextChar )
        {
            hr = E_INVALIDARG;
        }

        if ( SUCCEEDED( hr ) )
        {
            m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
            while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                    IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                    IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                    IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
            {
                fDone = true;
                m_pEndOfCurrItem--;
            }
        }

        //--- Try to match a number string 
        if ( SUCCEEDED( hr ) )
        {
            hr = IsNumberCategory( pNumberInfo, L"NUMBER", MemoryManager );
            if ( SUCCEEDED( hr ) )
            {
                if ( pNumberInfo->Type != eNUM_CARDINAL &&
                     pNumberInfo->Type != eNUM_DECIMAL  &&
                     pNumberInfo->Type != eNUM_FRACTION &&
                     pNumberInfo->Type != eNUM_MIXEDFRACTION )
                {
                    hr = E_INVALIDARG;
                }
                else
                {
                    pNumberXMLState = &m_pCurrFrag->State;
                }
            }

            //--- Skip any whitespace in between the number and the quantifier...
            if ( !fDone &&
                 SUCCEEDED( hr ) )
            {
                const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar;
                const WCHAR *pTempEndOfItem = m_pEndOfCurrItem;
                const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

                m_pNextChar = m_pEndOfCurrItem;
                hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostNumberList );

                if ( m_pNextChar &&
                     SUCCEEDED( hr ) )
                {
                    m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                    while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
                    {
                        m_pEndOfCurrItem--;
                    }

                    //--- Try to match a quantifier
                    iQuantIndex = MatchQuantifier( m_pNextChar, m_pEndOfCurrItem );
                    if ( iQuantIndex >= 0 )
                    {
                        pQuantifierXMLState = &m_pCurrFrag->State;
                    }
                    else
                    {
                        m_pNextChar      = pTempNextChar;
                        m_pEndChar       = pTempEndChar;
                        m_pEndOfCurrItem = pTempEndOfItem;
                        m_pCurrFrag      = pTempFrag;
                    }
                }
                else
                {
                    m_pNextChar      = pTempNextChar;
                    m_pEndChar       = pTempEndChar;
                    m_pEndOfCurrItem = pTempEndOfItem;
                    m_pCurrFrag      = pTempFrag;
                }
            }
        }
    }
    //--- Try to match [Number] [CurrencySign] [Quantifier]
    else 
    {
        //--- Try to match a number string
        hr = IsNumberCategory( pNumberInfo, L"NUMBER", MemoryManager );
        if ( SUCCEEDED( hr ) )
        {
            if ( pNumberInfo->Type != eNUM_CARDINAL &&
                 pNumberInfo->Type != eNUM_DECIMAL  &&
                 pNumberInfo->Type != eNUM_FRACTION &&
                 pNumberInfo->Type != eNUM_MIXEDFRACTION )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                pNumberXMLState = &m_pCurrFrag->State;
            }
        }

        //--- Skip any whitespace and XML markup between the number and the currency sign
        if ( SUCCEEDED( hr ) )
        {
            m_pNextChar = m_pEndOfCurrItem;
            hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostNumberList );

            if ( !m_pNextChar )
            {
                hr = E_INVALIDARG;
            }

            if ( SUCCEEDED( hr ) )
            {
                m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                        IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                        IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                        IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
                {
                    m_pEndOfCurrItem--;
                    fDone = true;
                }
            }
        }

        //--- Try to match a Currency Sign
        if ( SUCCEEDED( hr ) )
        {
            iSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );
            if ( iSymbolIndex >= 0 )
            {
                pSymbolXMLState = &m_pCurrFrag->State;
            }

            //--- Skip any whitespace in between the currency sign and the quantifier
            if ( !fDone &&
                 iSymbolIndex >= 0 )
            {
                const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar;
                const WCHAR *pTempEndOfItem = m_pEndOfCurrItem;
                const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

                hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostSymbolList );

                if ( !m_pNextChar )
                {
                    m_pNextChar      = pTempNextChar;
                    m_pEndChar       = pTempEndChar;
                    m_pEndOfCurrItem = pTempEndOfItem;
                    m_pCurrFrag      = pTempFrag;
                    fDone = true;
                }

                if ( !fDone &&
                     SUCCEEDED( hr ) )
                {
                    m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                    while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
                    {
                        fDone = true;
                        m_pEndOfCurrItem--;
                    }

                    //--- Try to match quantifier
                    iQuantIndex = MatchQuantifier( m_pNextChar, m_pEndOfCurrItem );
                    if ( iQuantIndex >= 0 )
                    {
                        pQuantifierXMLState = &m_pCurrFrag->State;
                    }
                    else
                    {
                        m_pNextChar      = pTempNextChar;
                        m_pEndChar       = pTempEndChar;
                        m_pEndOfCurrItem = pTempEndOfItem;
                        m_pCurrFrag      = pTempFrag;
                    }
                }
            }
            else if ( iSymbolIndex < 0 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    //--- Successfully matched a currency!  Now expand it and fill out pItemNormInfo.
    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof(TTSWord) );
        Word.eWordPartOfSpeech = MS_Unknown;

        pItemNormInfo = (TTSCurrencyItemInfo*) MemoryManager.GetMemory( sizeof(TTSCurrencyItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            //--- Fill in known parts of pItemNormInfo
            ZeroMemory( pItemNormInfo, sizeof(TTSCurrencyItemInfo) );
            pItemNormInfo->Type = eNUM_CURRENCY;
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->fQuantifier           = iQuantIndex >= 0 ? true : false;
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart    = (TTSNumberItemInfo*) pNumberInfo;
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->lNumPostNumberStates  = PostNumberList.GetCount();
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->lNumPostSymbolStates  = PostSymbolList.GetCount();

            //--- Need to determine whether this currency will have a primary and secondary part
            //---   (e.g. "ten dollars and fifty cents") or just a primary part (e.g. "ten point
            //---   five zero cents", "one hundred dollars").

            //--- First check whether the number is a cardinal, there is a quantifier present, or the
            //---   currency unit has no secondary (e.g. cents).  In any of these cases, we need do no
            //---   further checking.
            if ( pNumberInfo->Type == eNUM_DECIMAL &&
                 iQuantIndex       == -1                &&
                 g_CurrencySigns[iSymbolIndex].SecondaryUnit.Len > 0 )
            {
                WCHAR *pDecimalPoint = wcschr( ( (TTSNumberItemInfo*) pNumberInfo )->pStartChar, wcDecimalPoint );
                SPDBG_ASSERT( pDecimalPoint );

                if ( pDecimalPoint &&
                     ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar - pDecimalPoint == 3 )
                {
                    //--- We do have a secondary part!  Fix up PrimaryNumberPart appropriately,
                    //---   and fill in pSecondaryNumberPart.
                    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
                    const WCHAR *pTemp = ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar;
                    m_pNextChar      = ( (TTSNumberItemInfo*) pNumberInfo )->pStartChar;
                    m_pEndOfCurrItem = pDecimalPoint;
                    delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
                    
                    //--- m_pNextChar == m_pEndOfCurrItem when integer part is empty and non-negative, e.g. $.50
                    //---   Other case is empty and negative, e.g. $-.50
                    if ( m_pNextChar != m_pEndOfCurrItem &&
                         !( *m_pNextChar == L'-' &&
                             m_pNextChar == m_pEndOfCurrItem - 1 ) )
                    {
                        hr = IsNumber( pNumberInfo, L"NUMBER", MemoryManager, false );
                    }
                    else
                    {
                        pNumberInfo = (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( pNumberInfo, sizeof( TTSNumberItemInfo ) );
                            if ( *m_pNextChar == L'-' )
                            {
                                ( (TTSNumberItemInfo*) pNumberInfo )->fNegative = true;
                            }
                            else
                            {
                                ( (TTSNumberItemInfo*) pNumberInfo )->fNegative = false;
                            }
                            ( (TTSNumberItemInfo*) pNumberInfo )->pStartChar = NULL;
                            ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar   = NULL;
                            ( (TTSNumberItemInfo*) pNumberInfo )->pIntegerPart =
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ( (TTSNumberItemInfo*) pNumberInfo )->pIntegerPart->fDigitByDigit = true;
                                ( (TTSNumberItemInfo*) pNumberInfo )->pIntegerPart->ulNumDigits   = 1;
                                ( (TTSNumberItemInfo*) pNumberInfo )->pWordList = new CWordList;

                                if ( ( (TTSNumberItemInfo*) pNumberInfo )->fNegative )
                                {
                                    Word.pXmlState  = pNumberXMLState;
                                    Word.pWordText  = g_negative.pStr;
                                    Word.ulWordLen  = g_negative.Len;
                                    Word.pLemma     = Word.pWordText;
                                    Word.ulLemmaLen = Word.ulWordLen;
                                    ( (TTSNumberItemInfo*) pNumberInfo )->pWordList->AddTail( Word );
                                }

                                Word.pWordText  = g_ones[0].pStr;
                                Word.ulWordLen  = g_ones[0].Len;
                                Word.pLemma     = Word.pWordText;
                                Word.ulLemmaLen = Word.ulWordLen;
                                ( (TTSNumberItemInfo*) pNumberInfo )->pWordList->AddTail( Word );
                            }
                        }
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart = 
                                                                        (TTSNumberItemInfo*) pNumberInfo;
                        m_pNextChar      = m_pEndOfCurrItem + 1;
                        m_pEndOfCurrItem = pTemp;
                        
                        //--- If zeroes, don't pronounce them...
                        if ( m_pNextChar[0] != L'0' )
                        {
                            hr = IsNumber( pNumberInfo, L"NUMBER", MemoryManager, false );
                            if ( SUCCEEDED( hr ) )
                            {
                                ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart = 
                                                                        (TTSNumberItemInfo*) pNumberInfo;
                            }
                        }
                        else if ( m_pNextChar[1] != L'0' )
                        {
                            m_pNextChar++;
                            hr = IsNumber( pNumberInfo, L"NUMBER", MemoryManager, false );
                            if ( SUCCEEDED( hr ) )
                            {
                                ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart =
                                                                        (TTSNumberItemInfo*) pNumberInfo;
                            }
                        }
                    }
                    m_pNextChar      = pTempNextChar;
                    m_pEndOfCurrItem = pTempEndOfItem;
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                //--- Expand Primary number part
                if ( fNegative )
                {
                    ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->fNegative = true;
                    Word.pXmlState          = pNumberXMLState;
                    Word.eWordPartOfSpeech  = MS_Unknown;
                    Word.pWordText          = g_negative.pStr;
                    Word.ulWordLen          = g_negative.Len;
                    Word.pLemma             = Word.pWordText;
                    Word.ulLemmaLen         = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
                hr = ExpandNumber( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart, WordList );
            }

            //--- Clean up Number XML States
            SPLISTPOS WordListPos;
            if ( SUCCEEDED( hr ) )
            {
                WordListPos = WordList.GetHeadPosition();
                while ( WordListPos )
                {
                    TTSWord& TempWord = WordList.GetNext( WordListPos );
                    TempWord.pXmlState = pNumberXMLState;
                }
            
                //--- Insert PostNumber XML States
                while ( !PostNumberList.IsEmpty() )
                {
                    WordList.AddTail( ( PostNumberList.RemoveHead() ).Words[0] );
                }

                //--- If a quantifier is present, expand it
                if ( iQuantIndex >= 0 )
                { 
                    Word.pXmlState  = pQuantifierXMLState;
                    Word.pWordText  = g_quantifiers[iQuantIndex].pStr;
                    Word.ulWordLen  = g_quantifiers[iQuantIndex].Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                BOOL fFraction = false;
                //--- If a fractional unit with no quantifier, insert "of a"
                if ( iQuantIndex < 0                                          &&
                     !( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart &&
                     !( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pIntegerPart    &&
                     ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pFractionalPart  &&
                     !( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pFractionalPart->fIsStandard )
                {
                    fFraction = true;
                    Word.pXmlState  = pNumberXMLState;
                    Word.eWordPartOfSpeech = MS_Unknown;
                    Word.pWordText  = g_of.pStr;
                    Word.ulWordLen  = g_of.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );

                    Word.pWordText  = g_a.pStr;
                    Word.ulWordLen  = g_a.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                //--- Insert Main Currency Unit
                //--- Plural if not a fraction and either a quantifier is present or the integral part is not one.
                if ( !fFraction &&
                     ( iQuantIndex >= 0 ||
                       ( ( ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pEndChar -
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar != 1 ) ||
                           ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar[0] != L'1' ) &&
                         ( ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pEndChar -
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar != 2 ) ||
                           ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar[0] != L'-' ||
                           ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar[1] != L'1' ) ) ) )
                {                     
                    Word.pXmlState  = pSymbolXMLState;
                    Word.pWordText  = g_CurrencySigns[iSymbolIndex].MainUnit.pStr;
                    Word.ulWordLen  = g_CurrencySigns[iSymbolIndex].MainUnit.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
                //--- ONLY "one" or "negative one" should precede this...
                else
                {
                    Word.pXmlState  = pSymbolXMLState;
                    Word.pWordText  = g_SingularPrimaryCurrencySigns[iSymbolIndex].pStr;
                    Word.ulWordLen  = g_SingularPrimaryCurrencySigns[iSymbolIndex].Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                //--- Insert Post Symbol XML States
                while ( !PostSymbolList.IsEmpty() )
                {
                    WordList.AddTail( ( PostSymbolList.RemoveHead() ).Words[0] );
                }

                //--- Insert Secondary number part
                if ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart )
                {
                    Word.pXmlState  = pNumberXMLState;
                    Word.pWordText  = g_And.pStr;
                    Word.ulWordLen  = g_And.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );

                    WordListPos = WordList.GetTailPosition();
                
                    hr = ExpandNumber( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart, WordList );

                    //--- Clean up number XML State
                    if ( SUCCEEDED( hr ) )
                    {
                        while ( WordListPos )
                        {
                            TTSWord& TempWord  = WordList.GetNext( WordListPos );
                            TempWord.pXmlState = pNumberXMLState;
                        }
                    }

                    //--- Insert secondary currency unit
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart->pEndChar -
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart->pStartChar == 1 &&
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart->pStartChar[0] == L'1' )
                        {
                            Word.pXmlState  = pSymbolXMLState;
                            Word.pWordText  = g_SingularSecondaryCurrencySigns[iSymbolIndex].pStr;
                            Word.ulWordLen  = g_SingularSecondaryCurrencySigns[iSymbolIndex].Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                        else
                        {
                            Word.pXmlState  = pSymbolXMLState;
                            Word.pWordText  = g_CurrencySigns[iSymbolIndex].SecondaryUnit.pStr;
                            Word.ulWordLen  = g_CurrencySigns[iSymbolIndex].SecondaryUnit.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                    }
                }

                if ( SUCCEEDED( hr ) )
                {
                    m_pNextChar = pTempNextChar;
                }
            }
        }
    }
    else
    {
        if ( pNumberInfo )
        {
            delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
        }
        m_pNextChar      = pTempNextChar;
        m_pEndChar       = pTempEndChar;
        m_pEndOfCurrItem = pTempEndOfItem;
        m_pCurrFrag      = pTempFrag;
    }

    return hr;
} /* IsCurrency */


/***********************************************************************************************
* IsRomanNumeral *
*----------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a fraction.  
*
*   RegExp:
*       [M](0-3) { [CM] || [CD] || { [D]?[C](0-3) } } { [XC] || [XL] || { [L]?[X](0-3) } }
*           { [IX] || [IV] || { [V]?[I](0-3) }}
*
*   Types assigned:
*       NUM_ROMAN_NUMERAL
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsRomanNumeral( TTSItemInfo*& pItemNormInfo, const WCHAR* Context,
                                      CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "NumNorm IsRomanNumeral" );

    HRESULT hr = S_OK;
    ULONG ulValue = 0, ulIndex = 0, ulMaxOfThree = 0, ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);

    //--- Match Thousands - M(0-3) 
    while ( ulIndex < ulTokenLen         && 
            towupper( m_pNextChar[ulIndex] ) == L'M' && 
            ulMaxOfThree < 3 )
    {
        ulValue += 1000;
        ulMaxOfThree++;
        ulIndex++;
    }
    if ( ulMaxOfThree > 3 )
    {
        hr = E_INVALIDARG;
    }

    //--- Match Hundreds - { [CM] || [CD] || { [D]?[C](0-3) } } 
    if ( SUCCEEDED( hr ) )
    {
        ulMaxOfThree = 0;
        //--- Matched C first 
        if ( ulIndex < ulTokenLen &&
             towupper( m_pNextChar[ulIndex] ) == L'C' )
        {
            ulValue += 100;
            ulMaxOfThree++;
            ulIndex++;
            //--- Special Case - CM = 900 
            if ( ulIndex < ulTokenLen &&
                 towupper( m_pNextChar[ulIndex] ) == L'M' )
            {
                ulValue += 800;
                ulIndex++;
            }
            //--- Special Case - CD = 400 
            else if ( ulIndex < ulTokenLen &&
                      towupper( m_pNextChar[ulIndex] ) == L'D' )
            {
                ulValue += 300;
                ulIndex++;
            }
            //--- Default Case 
            else 
            {
                while ( ulIndex < ulTokenLen &&
                        towupper( m_pNextChar[ulIndex] ) == L'C' &&
                        ulMaxOfThree < 3 )
                {
                    ulValue += 100;
                    ulMaxOfThree++;
                    ulIndex++;
                }
                if ( ulMaxOfThree > 3 )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
        //--- Matched D First 
        else if ( ulIndex < ulTokenLen &&
                  towupper( m_pNextChar[ulIndex] ) == L'D' )
        {
            ulValue += 500;
            ulIndex++;
            ulMaxOfThree = 0;
            //--- Match C's 
            while ( ulIndex < ulTokenLen &&
                    towupper( m_pNextChar[ulIndex] ) == L'C' &&
                    ulMaxOfThree < 3 )
            {
                ulValue += 100;
                ulIndex++;
                ulMaxOfThree++;
            }
            if ( ulMaxOfThree > 3 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    //--- Match Tens - { [XC] || [XL] || { [L]?[X](0-3) } } 
    if ( SUCCEEDED( hr ) )
    {
        ulMaxOfThree = 0;
        //--- Matched X First 
        if ( ulIndex < ulTokenLen &&
             towupper( m_pNextChar[ulIndex] ) == L'X' )
        {
            ulValue += 10;
            ulMaxOfThree++;
            ulIndex++;
            //--- Special Case - XC = 90 
            if ( ulIndex < ulTokenLen &&
                 towupper( m_pNextChar[ulIndex] ) == L'C' )
            {
                ulValue += 80;
                ulIndex++;
            }
            //--- Special Case - XL = 40 
            else if ( ulIndex < ulTokenLen &&
                      towupper( m_pNextChar[ulIndex] ) == 'L' )
            {
                ulValue += 30;
                ulIndex++;
            }
            //--- Default Case 
            else
            {
                while ( ulIndex < ulTokenLen &&
                        towupper( m_pNextChar[ulIndex] ) == L'X' &&
                        ulMaxOfThree < 3 )
                {
                    ulValue += 10;
                    ulMaxOfThree ++;
                    ulIndex++;
                }
                if ( ulMaxOfThree > 3 )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
        //--- Matched L First 
        else if ( ulIndex < ulTokenLen &&
                  towupper( m_pNextChar[ulIndex] ) == L'L' )
        {
            ulValue += 50;
            ulIndex++;
            //--- Match X's 
            while ( ulIndex < ulTokenLen &&
                    towupper( m_pNextChar[ulIndex] ) == L'X' &&
                    ulMaxOfThree < 3 )
            {
                ulValue += 10;
                ulMaxOfThree++;
                ulIndex++;
            }
            if ( ulMaxOfThree > 3 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    //--- Match Ones - { [IX] || [IV] || { [V]?[I](0-3) } } 
    if ( SUCCEEDED( hr ) )
    {
        ulMaxOfThree = 0;
        //--- Matched I First 
        if ( ulIndex < ulTokenLen &&
             towupper( m_pNextChar[ulIndex] ) == L'I' )
        {
            ulValue += 1;
            ulMaxOfThree++;
            ulIndex++;
            //--- Special Case - IX = 9 
            if ( ulIndex < ulTokenLen &&
                 towupper( m_pNextChar[ulIndex] ) == L'X' )
            {
                ulValue += 8;
                ulIndex++;
            }
            //--- Special Case - IV = 4 
            else if ( ulIndex < ulTokenLen &&
                      towupper( m_pNextChar[ulIndex] ) == L'V' )
            {
                ulValue += 3;
                ulIndex++;
            }
            //--- Default Case 
            else
            {
                while ( ulIndex < ulTokenLen &&
                        towupper( m_pNextChar[ulIndex] ) == L'I' &&
                        ulMaxOfThree < 3 )
                {
                    ulValue += 1;
                    ulMaxOfThree++;
                    ulIndex++;
                }
                if ( ulMaxOfThree > 3 )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
        //--- Matched V First 
        else if ( ulIndex < ulTokenLen &&
                  towupper( m_pNextChar[ulIndex] ) == L'V' )
        {
            ulValue += 5;
            ulIndex++;
            //--- Match I's 
            while ( ulIndex < ulTokenLen &&
                    towupper( m_pNextChar[ulIndex] ) == L'I' &&
                    ulMaxOfThree < 3 )
            {
                ulValue += 1;
                ulMaxOfThree++;
                ulIndex++;
            }
            if ( ulMaxOfThree > 3 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    if ( ulIndex != ulTokenLen )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Successfully matched a roman numeral! 

        WCHAR *tempNumberString;
        //--- Max value of ulValue is 3999, so the resultant string cannot be more than
        //---     four characters long (plus one for the comma, just in case) 
        tempNumberString = (WCHAR*) MemoryManager.GetMemory( 6 * sizeof(WCHAR), &hr );
        if ( SUCCEEDED( hr ) )
        {
            TTSItemInfo *pNumberInfo = NULL;
            _ltow( (long) ulValue, tempNumberString, 10 );

            const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
            
            m_pNextChar      = tempNumberString;
            m_pEndOfCurrItem = tempNumberString + wcslen( tempNumberString );

            hr = IsNumber( pNumberInfo, Context, MemoryManager, false );

            m_pNextChar      = pTempNextChar;
            m_pEndOfCurrItem = pTempEndOfItem;

            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo = 
                    (TTSRomanNumeralItemInfo*) MemoryManager.GetMemory( sizeof( TTSRomanNumeralItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo = pNumberInfo;
                }
                pItemNormInfo->Type = eNUM_ROMAN_NUMERAL;
            }
        }
    }
    
    return hr;
} /* IsRomanNumeral */

/***********************************************************************************************
* IsPhoneNumber *
*---------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a phone number.  
*
*   RegExp:
*       { ddd-dddd } || { ddd-ddd-dddd }     
*
*   Types assigned:
*       NUM_PHONENUMBER
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsPhoneNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager, 
                                     CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsPhoneNumber" );

    HRESULT hr = S_OK;
    const WCHAR *pCountryCode = NULL, *pAreaCode = NULL, *pGroups[4] = { NULL, NULL, NULL, NULL };
    const WCHAR *pStartChar = m_pNextChar, *pEndChar = m_pEndChar, *pEndOfItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pFrag = m_pCurrFrag;
    BOOL fMatchedLeftParen = false, fMatchedOne = false;
    ULONG ulCountryCodeLen = 0, ulAreaCodeLen = 0, ulNumGroups = 0, ulGroupLen[4] = { 0, 0, 0, 0 };
    CItemList PostCountryCodeList, PostOneList, PostAreaCodeList, PostGroupLists[4];
    const SPVSTATE *pCountryCodeState = NULL, *pOneState = NULL, *pAreaCodeState = NULL;
    const SPVSTATE *pGroupStates[4] = { NULL, NULL, NULL, NULL };
    const WCHAR *pDelimiter = NULL;

    const WCHAR *pTempEndChar = NULL;
    const SPVTEXTFRAG *pTempFrag = NULL;
    
    ULONG i = 0;

    //--- Try to match Country Code
    if ( pStartChar[0] == L'+' )
    {
        pStartChar++;
        i = 0;

        //--- Try to match d(1-3)
        while ( pEndOfItem > pStartChar + i &&
                iswdigit( pStartChar[i] ) &&
                i < 3 )
        {
            i++;
        }

        pCountryCode      = pStartChar;
        pCountryCodeState = &pFrag->State;
        ulCountryCodeLen  = i;

        //--- Try to match delimiter
        if ( i >= 1                      &&
             pEndOfItem > pStartChar + i &&
             MatchPhoneNumberDelimiter( pStartChar[i] ) )
        {
            pDelimiter = pStartChar + i;
            pStartChar += i + 1;
        }
        //--- Try to advance in text - whitespace counts as a delimiter...
        else if ( i >= 1 &&
                  pEndOfItem == pStartChar + i )
        {
            pStartChar += i;
            pCountryCodeState = &pFrag->State;

            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                        &PostCountryCodeList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr       = E_INVALIDARG;
            }
            else if ( SUCCEEDED( hr ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Try to match a "1"
    if ( SUCCEEDED( hr )        &&
         !pCountryCode          &&
         pStartChar[0] == L'1'  &&
         !iswdigit( pStartChar[1] ) )
    {
        pOneState   = &pFrag->State;
        fMatchedOne = true;
        pStartChar++;

        if ( pEndOfItem > pStartChar &&
             MatchPhoneNumberDelimiter( pStartChar[0] ) )
        {
            //--- If we've already hit a delimiter, make sure all others agree
            if ( pDelimiter )
            {
                if ( *pDelimiter != pStartChar[0] )
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                pDelimiter = pStartChar;
            }
            pStartChar++;
        }
        //--- Try to advance in text - whitespace counts as a delimiter...
        else if ( !pDelimiter &&
                  pEndOfItem == pStartChar )
        {
            pOneState = &pFrag->State;

            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                        &PostOneList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr       = E_INVALIDARG;
            }
            else if ( SUCCEEDED( hr ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }    

    //--- Try to match Area Code
    if ( SUCCEEDED( hr ) &&
         pStartChar < pEndOfItem )
    {
        i = 0;

        //--- Try to match a left parenthesis
        if ( ( pCountryCode ||
               fMatchedOne )    &&
             pStartChar[0] == L'(' )
        {
            pStartChar++;
            fMatchedLeftParen = true;
        }
        else if ( !pCountryCode                      &&
                  !fMatchedOne                       &&
                  pStartChar > pFrag->pTextStart &&
                  *( pStartChar - 1 ) == L'(' )
        {
            fMatchedLeftParen = true;
        }
        
        if ( fMatchedLeftParen )
        {
            //--- Try to match ddd?
            while ( pEndOfItem > pStartChar + i &&
                    iswdigit( pStartChar[i] ) &&
                    i < 3 )
            {
                i++;
            }

            pAreaCodeState  = &pFrag->State;
            pAreaCode       = pStartChar;
            ulAreaCodeLen   = i;

            if ( i < 2 )
            {
                //--- Failed to match at least two digits
                hr = E_INVALIDARG;
            }
            else
            {
                if ( pStartChar[i] != L')' )
                {
                    //--- Matched left parenthesis without corresponding right parenthesis
                    hr = E_INVALIDARG;
                }
                else if ( ( !( pCountryCode || fMatchedOne ) &&
                            pEndOfItem > pStartChar + i ) ||
                          ( ( pCountryCode || fMatchedOne )  &&
                            pEndOfItem > pStartChar + i + 1 ) )
                {
                    i++;
                    //--- Delimiter is optional with parentheses
                    if ( MatchPhoneNumberDelimiter( pStartChar[i] ) )
                    {
                        //--- If we've already hit a delimiter, make sure all others agree
                        if ( pDelimiter )
                        {
                            if ( *pDelimiter != pStartChar[i] )
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                        else
                        {
                            pDelimiter = pStartChar + i;
                        }
                        i++;
                    }
                    pStartChar += i;
                }
                //--- Try to advance in text - whitespace counts as a delimiter...
                else if ( !pDelimiter )
                {
                    pStartChar += i + 1;
                    pAreaCodeState = &pFrag->State;

                    hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                                &PostAreaCodeList );
                    if ( !pStartChar &&
                         SUCCEEDED( hr ) )
                    {
                        hr       = E_INVALIDARG;
                    }
                    else if ( SUCCEEDED( hr ) )
                    {
                        pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
        }
    }

    //--- Try to match main number part
    if ( SUCCEEDED( hr ) &&
         pStartChar < pEndOfItem )
    {
        //--- Try to match some groups of digits
        for ( int j = 0; SUCCEEDED( hr ) && j < 4; j++ )
        {
            i = 0;

            //--- Try to match a digit string
            while ( pEndOfItem > pStartChar + i &&
                    iswdigit( pStartChar[i] ) &&
                    i < 4 )
            {
                i++;
            }

            //--- Try to match a delimiter
            if ( i >= 2 )
            {
                pGroupStates[j] = &pFrag->State;
                ulGroupLen[j]   = i;
                pGroups[j]      = pStartChar;
                pStartChar     += i;

                if ( pEndOfItem > pStartChar + 1 &&
                     MatchPhoneNumberDelimiter( pStartChar[0] ) )
                {
                    //--- If we've already hit a delimiter, make sure all others agree
                    if ( pDelimiter )
                    {
                        if ( *pDelimiter != pStartChar[0] )
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    //--- Only allow a new delimiter to be matched on the first main number group...
                    //---   e.g. "+45 35 32 90.89" should not all match...
                    else if ( j == 0 )
                    {
                        pDelimiter = pStartChar;
                    }
                    else
                    {
                        pEndChar = pTempEndChar;
                        pFrag    = pTempFrag;
                        ulNumGroups = j;
                        break;
                    }
                    pStartChar++;
                }
                //--- Try to advance in text - whitespace counts as a delimiter...
                else if ( !pDelimiter &&
                          pEndOfItem == pStartChar )
                {
                    pGroupStates[j] = &pFrag->State;

                    pTempEndChar = pEndChar;
                    pTempFrag    = pFrag;

                    hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                                &PostGroupLists[j] );
                    if ( !pStartChar &&
                         SUCCEEDED( hr ) )
                    {
                        pEndChar = pTempEndChar;
                        pFrag    = pTempFrag;
                        ulNumGroups = j + 1;
                        break;
                    }
                    else if ( SUCCEEDED( hr ) )
                    {
                        pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    }
                }
                else if ( pEndOfItem == pStartChar + 1 )
                {
                    if ( IsGroupEnding( *pStartChar )       != eUNMATCHED  ||
                         IsQuotationMark( *pStartChar )     != eUNMATCHED  ||
                         IsMiscPunctuation( *pStartChar )   != eUNMATCHED  ||
                         IsEOSItem( *pStartChar )           != eUNMATCHED )
                    {
                        pEndOfItem--;
                        ulNumGroups = j + 1;
                        break;
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    while ( pEndOfItem != pStartChar )
                    {
                        if ( IsGroupEnding( *pEndOfItem )       != eUNMATCHED  ||
                             IsQuotationMark( *pEndOfItem )     != eUNMATCHED  ||
                             IsMiscPunctuation( *pEndOfItem )   != eUNMATCHED  ||
                             IsEOSItem( *pEndOfItem )           != eUNMATCHED )
                        {
                            pEndOfItem--;
                        }
                        else
                        {
                            break;
                        }
                    }
                    if ( pEndOfItem == pStartChar )
                    {
                        ulNumGroups = j + 1;
                        break;
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        break;
                    }
                }
            }
            //--- Matched something like 206.709.8286.1 - definitely bad
            else if ( pDelimiter )
            {
                hr = E_INVALIDARG;
            }
            //--- Matched somethinge like 206 709 8286 1 - could be OK
            else
            {
                if ( pTempEndChar )
                {
                    pEndChar = pTempEndChar;
                    pFrag    = pTempFrag;
                }
                ulNumGroups = j;
                break;
            }
        }
        //--- Didn't hit either break statement
        if ( !ulNumGroups )
        {
            ulNumGroups = j;
        }
    }

    //--- Check for appropriate formats
    if ( SUCCEEDED( hr ) )
    {
        //--- Check for [1<sep>]?(ddd?)<sep>?ddd<sep>dddd? OR ddd<sep>dddd?
        if ( !pCountryCode      &&
             ulNumGroups == 2   &&
             ulGroupLen[0] == 3 &&
             ulGroupLen[1] >= 3 &&
             !( fMatchedOne && !pAreaCode ) )         
        {
            if ( ( !Context ||
                   _wcsicmp( Context, L"phone_number" ) != 0 ) &&
                 !pCountryCode &&
                 !pAreaCode    &&
                 !fMatchedOne  &&
                 ( pDelimiter ? (*pDelimiter == L'.') : 0 ) )
            {
                hr = E_INVALIDARG;
            }
        }
        //--- Check for [1<sep>]?ddd?<sep>ddd<sep>dddd?
        else if ( !pCountryCode             &&
                  !pAreaCode                &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] == 3        &&
                  ulGroupLen[2] >= 3 )
        {
            pAreaCode           = pGroups[0];
            ulAreaCodeLen       = ulGroupLen[0];
            pAreaCodeState      = pGroupStates[0];
            PostAreaCodeList.AddTail( &PostGroupLists[0] );
            pGroups[0]          = pGroups[1];
            ulGroupLen[0]       = ulGroupLen[1];
            pGroupStates[0]     = pGroupStates[1];
            PostGroupLists[0].RemoveAll();
            PostGroupLists[0].AddTail( &PostGroupLists[1] );
            pGroups[1]          = pGroups[2];
            ulGroupLen[1]       = ulGroupLen[2];
            pGroupStates[1]     = pGroupStates[2];
            PostGroupLists[1].RemoveAll();
            PostGroupLists[2].RemoveAll();
            ulNumGroups--;
        }
        //--- Check for (ddd?)<sep>?ddd?<sep>dd<sep>ddd?d?
        else if ( !pCountryCode             &&
                  !fMatchedOne              &&
                  pAreaCode                 &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] == 2        &&
                  ulGroupLen[2] >= 2 )
        {
            NULL;
        }
        //--- Check for +dd?d?<sep>ddd?<sep>ddd?<sep>ddd?d?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  !pAreaCode                &&
                  ulNumGroups == 4          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ( ulGroupLen[1] == 2 ||
                    ulGroupLen[1] == 3 )    &&
                  ulGroupLen[2] >= 2        &&
                  ulGroupLen[3] >= 2 )
        {
            pAreaCode           = pGroups[0];
            ulAreaCodeLen       = ulGroupLen[0];
            pAreaCodeState      = pGroupStates[0];
            PostAreaCodeList.AddTail( &PostGroupLists[0] );
            pGroups[0]          = pGroups[1];
            ulGroupLen[0]       = ulGroupLen[1];
            pGroupStates[0]     = pGroupStates[1];
            PostGroupLists[0].RemoveAll();
            PostGroupLists[0].AddTail( &PostGroupLists[1] );
            pGroups[1]          = pGroups[2];
            ulGroupLen[1]       = ulGroupLen[2];
            pGroupStates[1]     = pGroupStates[2];
            PostGroupLists[1].RemoveAll();
            PostGroupLists[1].AddTail( &PostGroupLists[2] );
            pGroups[2]          = pGroups[3];
            ulGroupLen[2]       = ulGroupLen[3];
            pGroupStates[2]     = pGroupStates[3];
            PostGroupLists[2].RemoveAll();
            PostGroupLists[3].RemoveAll();
            ulNumGroups--;
        }
        //--- Check for +dd?d?<sep>ddd?<sep>ddd?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  !pAreaCode                &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ( ulGroupLen[1] == 2 ||
                    ulGroupLen[1] == 3 )    &&
                  ulGroupLen[2] >= 2 )
        {
            pAreaCode           = pGroups[0];
            ulAreaCodeLen       = ulGroupLen[0];
            pAreaCodeState      = pGroupStates[0];
            PostAreaCodeList.AddTail( &PostGroupLists[0] );
            pGroups[0]          = pGroups[1];
            ulGroupLen[0]       = ulGroupLen[1];
            pGroupStates[0]     = pGroupStates[1];
            PostGroupLists[0].RemoveAll();
            PostGroupLists[0].AddTail( &PostGroupLists[1] );
            pGroups[1]          = pGroups[2];
            ulGroupLen[1]       = ulGroupLen[2];
            pGroupStates[1]     = pGroupStates[2];
            PostGroupLists[1].RemoveAll();
            PostGroupLists[2].RemoveAll();
            ulNumGroups--;
        }
        //--- Check for +dd?d?<sep>(ddd?)<sep>?ddd?<sep>ddd?d?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  pAreaCode                 &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] >= 2        &&
                  ulGroupLen[2] >= 2 )
        {
            NULL;
        }
        //--- Check for +dd?d?<sep>(ddd?)<sep>?ddd?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  pAreaCode                 &&
                  ulNumGroups == 2          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] >= 2 )
        {
            NULL;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Fill in pItemNormInfo
    if ( SUCCEEDED(hr) )
    {
        m_pEndOfCurrItem = pGroups[ulNumGroups-1] + ulGroupLen[ulNumGroups-1];
        m_pEndChar  = pEndChar;
        m_pCurrFrag = pFrag;

        pItemNormInfo = (TTSPhoneNumberItemInfo*) MemoryManager.GetMemory( sizeof(TTSPhoneNumberItemInfo),
                                                                                   &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pItemNormInfo, sizeof(TTSPhoneNumberItemInfo) );
            pItemNormInfo->Type = eNEWNUM_PHONENUMBER;

            //--- Fill in fOne
            if ( fMatchedOne )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->fOne = true;
            }

            //--- Fill in Country Code...
            if ( pCountryCode )
            {
                TTSItemInfo* pCountryCodeInfo;
                const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
                m_pNextChar      = pCountryCode;
                m_pEndOfCurrItem = pCountryCode + ulCountryCodeLen;

                hr = IsNumber( pCountryCodeInfo, L"NUMBER", MemoryManager, false );
                if ( SUCCEEDED( hr ) )
                {
                    ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pCountryCode = (TTSNumberItemInfo*) pCountryCodeInfo;
                }

                m_pNextChar      = pTempNextChar;
                m_pEndOfCurrItem = pTempEndOfItem;
            }

            //--- Fill in Area Code...
            if ( SUCCEEDED( hr ) &&
                 pAreaCode )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode = 
                    (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof( TTSDigitsItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode->ulNumDigits = ulAreaCodeLen;
                    ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode->pFirstDigit = pAreaCode;
                }
            }

            //--- Fill in Main Number...
            if ( SUCCEEDED( hr ) )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ulNumGroups = ulNumGroups;
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups = 
                    (TTSDigitsItemInfo**) MemoryManager.GetMemory( ulNumGroups * sizeof(TTSDigitsItemInfo*), &hr );

                for ( ULONG j = 0; SUCCEEDED( hr ) && j < ulNumGroups; j++ )
                {
                     ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j] = 
                        (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof( TTSDigitsItemInfo ), &hr );
                     if ( SUCCEEDED( hr ) )
                     {
                         ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j]->ulNumDigits = ulGroupLen[j];
                         ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j]->pFirstDigit = pGroups[j];
                     }
                }
            }
        }
    }

    //--- Expand Phone Number
    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );
        Word.eWordPartOfSpeech = MS_Unknown;
        SPLISTPOS ListPos;

        if ( pCountryCode )
        {
            //--- Insert "country"
            Word.pXmlState  = pCountryCodeState;
            Word.pWordText  = g_Country.pStr;
            Word.ulWordLen  = g_Country.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert "code" 
            Word.pWordText  = g_Code.pStr;
            Word.ulWordLen  = g_Code.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            ListPos = WordList.GetTailPosition();

            //--- Expand Country Code
            ExpandNumber( ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pCountryCode, WordList );

            //--- Clean up digits XML states...
            WordList.GetNext( ListPos );
            while ( ListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( ListPos );
                TempWord.pXmlState = pCountryCodeState;
            }

            //--- Insert Post Symbol XML States
            while ( !PostCountryCodeList.IsEmpty() )
            {
                WordList.AddTail( ( PostCountryCodeList.RemoveHead() ).Words[0] );
            }
        }

        if ( fMatchedOne )
        {
            //--- Insert "one"
            Word.pXmlState  = pOneState;
            Word.pWordText  = g_ones[1].pStr;
            Word.ulWordLen  = g_ones[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert PostOne XML States
            while ( !PostOneList.IsEmpty() )
            {
                WordList.AddTail( ( PostOneList.RemoveHead() ).Words[0] );
            }
        }

        if ( pAreaCode )
        {
            //--- Expand digits - 800 and 900 get expanded as one number, otherwise digit by digit 
            if ( ( pAreaCode[0] == L'8' ||
                   pAreaCode[0] == L'9' ) &&
                 pAreaCode[1] == L'0'     &&
                 pAreaCode[2] == L'0' )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->fIs800 = true;
                NumberGroup Garbage;

                ListPos = WordList.GetTailPosition();

                ExpandThreeDigits( pAreaCode, Garbage, WordList ); 

                //--- Clean up digits XML states...
                //--- List was possibly empty prior to inserting "eight hundred" or "nine hundred"...
                if ( !ListPos )
                {
                    ListPos = WordList.GetHeadPosition();
                }
                WordList.GetNext( ListPos );
                while ( ListPos )
                {
                    TTSWord& TempWord  = WordList.GetNext( ListPos );
                    TempWord.pXmlState = pAreaCodeState;
                }
            }
            else
            {
                //--- Insert "area"
                Word.pXmlState  = pAreaCodeState;
                Word.pWordText  = g_Area.pStr;
                Word.ulWordLen  = g_Area.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
        
                //--- Insert "code" 
                Word.pWordText  = g_Code.pStr;
                Word.ulWordLen  = g_Code.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );

                ListPos = WordList.GetTailPosition();

                ExpandDigits( ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode, WordList );

                //--- Clean up digits XML states...
                WordList.GetNext( ListPos );
                while ( ListPos )
                {
                    TTSWord& TempWord  = WordList.GetNext( ListPos );
                    TempWord.pXmlState = pAreaCodeState;
                }
            }
            //--- Insert PostAreaCode XML States
            while ( !PostAreaCodeList.IsEmpty() )
            {
                WordList.AddTail( ( PostAreaCodeList.RemoveHead() ).Words[0] );
            }
        }

        for ( ULONG j = 0; j < ulNumGroups; j++ )
        {
            ListPos = WordList.GetTailPosition();

            ExpandDigits( ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j], WordList );

            //--- Clean up digits XML states...
            //--- List was possibly empty prior to inserting "eight hundred" or "nine hundred"...
            if ( !ListPos )
            {
                ListPos = WordList.GetHeadPosition();
            }
            WordList.GetNext( ListPos );
            while ( ListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( ListPos );
                TempWord.pXmlState = pGroupStates[j];
            }

            //--- Insert Post Group XML States
            while ( !PostGroupLists[j].IsEmpty() )
            {
                WordList.AddTail( ( PostGroupLists[j].RemoveHead() ).Words[0] );
            }
        }
    }

    return hr;
} /* IsPhoneNumber */

/***********************************************************************************************
* IsZipCode *
*-----------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a zipcode.  
*
*   RegExp:
*       ddddd{-dddd}?   
*
*   Types assigned:
*       NUM_ZIPCODE
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsZipCode( TTSItemInfo*& pItemNormInfo, const WCHAR* Context,
                                 CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsZipCode" );

    HRESULT hr = S_OK;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    BOOL fLastFour = false;

    //--- length must be 5 or 10 
    if ( ulTokenLen != 5 && 
         ulTokenLen != 10 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- match 5 digits 
        for ( ULONG i = 0; i < 5; i++ )
        {
            if ( !iswdigit( m_pNextChar[i] ) )
            {
                hr = E_INVALIDARG;
                break;
            }
        }
        if ( SUCCEEDED(hr) && 
             i < ulTokenLen )
        {
            //--- match dash 
            if ( m_pNextChar[i] != L'-' )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                //--- match 4 digits 
                for ( i = 0; i < 4; i++ )
                {
                    if ( !iswdigit( m_pNextChar[i] ) )
                    {
                        hr = E_INVALIDARG;
                        break;
                    }
                }
                fLastFour = true;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        pItemNormInfo = (TTSZipCodeItemInfo*) MemoryManager.GetMemory( sizeof(TTSZipCodeItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pItemNormInfo, sizeof(TTSZipCodeItemInfo) );
            pItemNormInfo->Type = eNUM_ZIPCODE;
            ( (TTSZipCodeItemInfo*) pItemNormInfo )->pFirstFive = 
                (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof(TTSDigitsItemInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {   
                ( (TTSZipCodeItemInfo*) pItemNormInfo )->pFirstFive->ulNumDigits = 5;
                ( (TTSZipCodeItemInfo*) pItemNormInfo )->pFirstFive->pFirstDigit = m_pNextChar;
                if ( fLastFour )
                {
                    ( (TTSZipCodeItemInfo*) pItemNormInfo )->pLastFour = 
                        (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof(TTSDigitsItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ( (TTSZipCodeItemInfo*) pItemNormInfo )->pLastFour->ulNumDigits = 4;
                        ( (TTSZipCodeItemInfo*) pItemNormInfo )->pLastFour->pFirstDigit = m_pNextChar + 6;
                    }
                }
            }
        }
    }

    return hr;
} /* IsZipCode */

/***********************************************************************************************
* ExpandZipCode *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_ZIPCODE by IsZipCode.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandZipCode( TTSZipCodeItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandZipCode" );

    HRESULT hr = S_OK;

    ExpandDigits( pItemInfo->pFirstFive, WordList );
    
    if ( pItemInfo->pLastFour )
    {
        //--- Insert "dash"
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );
        Word.pXmlState          = &m_pCurrFrag->State;
        Word.eWordPartOfSpeech  = MS_Unknown;
        Word.pWordText          = g_dash.pStr;
        Word.ulWordLen          = g_dash.Len;
        Word.pLemma             = Word.pWordText;
        Word.ulLemmaLen         = Word.ulWordLen;
        WordList.AddTail( Word );

        ExpandDigits( pItemInfo->pLastFour, WordList );
    }

    return hr;
} /* ExpandZipCode */

/***********************************************************************************************
* IsNumberRange *
*---------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a number range.
*
*   RegExp:
*       [Number]-[Number]  
*
*   Types assigned:
*       NUM_RANGE
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumberRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsNumberRange" );

    HRESULT hr = S_OK;
    TTSItemInfo *pFirstNumberInfo = NULL, *pSecondNumberInfo = NULL;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const WCHAR *pHyphen = NULL;

    for ( pHyphen = m_pNextChar; pHyphen < m_pEndOfCurrItem; pHyphen++ )
    {
        if ( *pHyphen == L'-' )
        {
            break;
        }
    }

    if ( *pHyphen == L'-' &&
         pHyphen > m_pNextChar &&
         pHyphen < m_pEndOfCurrItem - 1 )
    {
        m_pEndOfCurrItem = pHyphen;
        hr = IsNumber( pFirstNumberInfo, NULL, MemoryManager );

        if ( SUCCEEDED( hr ) )
        {
            m_pNextChar      = pHyphen + 1;
            m_pEndOfCurrItem = pTempEndOfItem;
            hr = IsNumberCategory( pSecondNumberInfo, NULL, MemoryManager );					

			if ( SUCCEEDED( hr ) )
            {
                //--- Matched a number range!
                pItemNormInfo = 
                    (TTSNumberRangeItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberRangeItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    pItemNormInfo->Type = eNUM_RANGE;
                    ( (TTSNumberRangeItemInfo*) pItemNormInfo )->pFirstNumberInfo  = pFirstNumberInfo;
                    ( (TTSNumberRangeItemInfo*) pItemNormInfo )->pSecondNumberInfo = pSecondNumberInfo;
                }
            }
            else if ( pFirstNumberInfo->Type != eDATE_YEAR )
            {   
                delete ( (TTSNumberItemInfo*) pFirstNumberInfo )->pWordList;
            }
        }
        m_pNextChar      = pTempNextChar;
        m_pEndOfCurrItem = pTempEndOfItem;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsNumberRange */

/***********************************************************************************************
* ExpandNumberRange *
*-------------------*
*   Description:
*       Expands Items previously determined to be of type NUM_RANGE by IsNumberRange.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandNumberRange( TTSNumberRangeItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandNumberRange" );

    HRESULT hr = S_OK;

    //--- Expand first number (or year)...
    switch( pItemInfo->pFirstNumberInfo->Type )
    {
    case eDATE_YEAR:
        hr = ExpandYear( (TTSYearItemInfo*) pItemInfo->pFirstNumberInfo, WordList );
        break;
    default:
        hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pFirstNumberInfo, WordList );
        break;
    }

    //--- Insert "to"
    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );

        Word.pXmlState          = &m_pCurrFrag->State;
        Word.eWordPartOfSpeech  = MS_Unknown;
        Word.pWordText          = g_to.pStr;
        Word.ulWordLen          = g_to.Len;
        Word.pLemma             = Word.pWordText;
        Word.ulLemmaLen         = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    //--- Expand second number (or year)...
    if ( SUCCEEDED( hr ) )
    {
        switch( pItemInfo->pSecondNumberInfo->Type )
        {
        case eDATE_YEAR:
            hr = ExpandYear( (TTSYearItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
            break;
		case eNUM_PERCENT:
			hr = ExpandPercent( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;			
		case eNUM_DEGREES:
			hr = ExpandDegrees( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;
		case eNUM_SQUARED:
			hr = ExpandSquare( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;
	    case eNUM_CUBED:
		    hr = ExpandCube( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;
        default:
             hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
            break;
        }
    }

    return hr;
} /* ExpandNumberRange */


/***********************************************************************************************
* IsCurrencyRange *
*-------------------*
*   Description:
*       Expands Items determined to be of type CURRENCY_RANGE
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsCurrencyRange( TTSItemInfo*& pItemInfo, CSentItemMemory& MemoryManager, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsCurrencyRange" );

    HRESULT hr = S_OK;
    TTSItemInfo *pFirstNumberInfo = NULL, *pSecondNumberInfo = NULL;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem, *pTempEndChar = m_pEndChar;
    const WCHAR *pHyphen = NULL;	
	CWordList TempWordList;
	NORM_POSITION ePosition = UNATTACHED;  //for currency sign checking
	int iSymbolIndex, iTempSymbolIndex = -1;
	WCHAR *tempNumberString;

	iSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );	
	
	if(iSymbolIndex < 0)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		for ( pHyphen = m_pNextChar; pHyphen < m_pEndOfCurrItem; pHyphen++ )
		{
			if ( *pHyphen == L'-' )
			{
				break;
			}
		}

		if ( !( *pHyphen == L'-' &&
			    pHyphen > m_pNextChar &&
			    pHyphen < m_pEndOfCurrItem - 1 ) )
		{
			hr = E_INVALIDARG;
		}
		else
		{			
			*( (WCHAR*)pHyphen) = L' ';  // Token must break at hyphen, or IsCurrency() will not work
			m_pNextChar      = pTempNextChar;
			m_pEndOfCurrItem = pHyphen;			
			NORM_POSITION temp = UNATTACHED;
			iTempSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, temp );
			if( iTempSymbolIndex >= 0 && iSymbolIndex != iTempSymbolIndex ) 
			{
				hr = E_INVALIDARG;
			}
			else   //--- Get both NumberInfos
			{
				hr = IsNumber( pFirstNumberInfo, L"NUMBER", MemoryManager, false );
				if( SUCCEEDED ( hr ) )
				{
					m_pNextChar = pHyphen + 1;
					m_pEndOfCurrItem = pTempEndOfItem;
					iTempSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, temp );
					hr = IsNumber( pSecondNumberInfo, L"NUMBER", MemoryManager, false );
				}
			}
			if( SUCCEEDED ( hr ) ) 
			{
			    //--- If both currency values are cardinal numbers, then the first number can be
			    //--- expanded without saying its currency ("$10-12" -> "ten to twelve dollars")
				if( pFirstNumberInfo->Type == eNUM_CARDINAL && pSecondNumberInfo->Type == eNUM_CARDINAL )
				{   
					ExpandNumber( (TTSNumberItemInfo*) pFirstNumberInfo, TempWordList );
				}
				else  // one or both values are non-cardinal numbers, so we must 
				{     // expand the first value as a full currency.
					m_pNextChar      = pTempNextChar;
					m_pEndOfCurrItem = pHyphen;

					if( ePosition == FOLLOWING ) 
					{
						if( iTempSymbolIndex < 0 )  // No symbol on first number item - need to fill a buffer
                        {						    // with currency symbol and value to pass to IsCurrency().
							ULONG ulNumChars = (long)(m_pEndOfCurrItem - m_pNextChar + g_CurrencySigns[iSymbolIndex].Sign.Len + 1);
							tempNumberString = (WCHAR*) MemoryManager.GetMemory( (ulNumChars) * sizeof(WCHAR), &hr );
							if ( SUCCEEDED( hr ) )
							{	
								ZeroMemory( tempNumberString, ( ulNumChars ) * sizeof( WCHAR ) );
								wcsncpy( tempNumberString, m_pNextChar, m_pEndOfCurrItem - m_pNextChar );
								wcscat( tempNumberString, g_CurrencySigns[iSymbolIndex].Sign.pStr );						
								m_pNextChar      = tempNumberString;
								m_pEndOfCurrItem = tempNumberString + wcslen( tempNumberString );
								m_pEndChar = m_pEndOfCurrItem;
							}                
						}
						else if( iTempSymbolIndex != iSymbolIndex )	// mismatched symbols
						{
							hr = E_INVALIDARG;
						}
					}
					if ( SUCCEEDED ( hr ) ) 
					{
						hr = IsCurrency( pFirstNumberInfo, MemoryManager, TempWordList );
						m_pEndChar = pTempEndChar;
					}
				}
			}

			if ( SUCCEEDED ( hr ) ) 
			{						
				TTSWord Word;
				ZeroMemory( &Word, sizeof( TTSWord ) );

				Word.pXmlState          = &m_pCurrFrag->State;
				Word.eWordPartOfSpeech  = MS_Unknown;
				Word.pWordText          = g_to.pStr;
				Word.ulWordLen          = g_to.Len;
				Word.pLemma             = Word.pWordText;
				Word.ulLemmaLen         = Word.ulWordLen;
				TempWordList.AddTail( Word );
		
				m_pNextChar = pHyphen + 1;
				m_pEndOfCurrItem = pTempEndOfItem;
					
				if( ePosition == PRECEDING ) 
				{
					iTempSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );
					if( iTempSymbolIndex < 0 )  // No symbol on second number item
					{    // create temporary string from first currency sign and second number item
						ULONG ulNumChars = (long)(m_pEndOfCurrItem - m_pNextChar + g_CurrencySigns[iSymbolIndex].Sign.Len + 1);
						tempNumberString = (WCHAR*) MemoryManager.GetMemory( (ulNumChars) * sizeof(WCHAR), &hr );
						if ( SUCCEEDED( hr ) )
						{
							ZeroMemory( tempNumberString, ( ulNumChars ) * sizeof( WCHAR ) );
							wcsncpy( tempNumberString, g_CurrencySigns[iSymbolIndex].Sign.pStr, g_CurrencySigns[iSymbolIndex].Sign.Len );
							wcsncpy( tempNumberString+g_CurrencySigns[iSymbolIndex].Sign.Len, m_pNextChar, m_pEndOfCurrItem - m_pNextChar );
							m_pNextChar      = tempNumberString;
							m_pEndOfCurrItem = tempNumberString + wcslen( tempNumberString );
							m_pEndChar = m_pEndOfCurrItem;
						}                
					}
					else if( iTempSymbolIndex == iSymbolIndex )	// matched leading symbol on second number item
					{
						m_pNextChar = pHyphen + 1;
						m_pEndOfCurrItem = pTempEndOfItem;
					}
					else	// mismatched symbol
					{
						hr = E_INVALIDARG;
					}
				}
					
				if( SUCCEEDED(hr) ) 
				{
					hr = IsCurrency( pSecondNumberInfo, MemoryManager, TempWordList );						
					if ( SUCCEEDED( hr ) )
					{							
						//--- Matched a currency range!
						pItemInfo = 
							(TTSNumberRangeItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberRangeItemInfo ), &hr );
						if ( SUCCEEDED( hr ) )
						{
							pItemInfo->Type = eNUM_CURRENCYRANGE;
							( (TTSNumberRangeItemInfo*) pItemInfo )->pFirstNumberInfo  = pFirstNumberInfo;
							( (TTSNumberRangeItemInfo*) pItemInfo )->pSecondNumberInfo = pSecondNumberInfo;
			                //--- Copy temp word list to real word list if everything has succeeded...
							WordList.AddTail( &TempWordList );
						}
					}
				}
			}	
			*( (WCHAR*)pHyphen) = L'-';
		}
	}
	//Reset member variables regardless of failure or success
    m_pNextChar      = pTempNextChar;
    m_pEndOfCurrItem = pTempEndOfItem;
	m_pEndChar = pTempEndChar;
	
    return hr;
} /* IsCurrencyRange */

/***********************************************************************************************
* MatchCurrencySign *
*-------------------*
*   Description:
*       Helper function which tries to match a currency sign at the beginning of a string.
********************************************************************* AH **********************/
int MatchCurrencySign( const WCHAR*& pStartChar, const WCHAR*& pEndChar, NORM_POSITION& ePosition )
{
    int Index = -1;

    for (int i = 0; i < sp_countof(g_CurrencySigns); i++)
    {
        if ( pEndChar - pStartChar >= g_CurrencySigns[i].Sign.Len && 
             wcsnicmp( pStartChar, g_CurrencySigns[i].Sign.pStr, g_CurrencySigns[i].Sign.Len ) == 0 )
        {
            Index = i;
            pStartChar += g_CurrencySigns[i].Sign.Len;
            ePosition = PRECEDING;
            break;
        }
    }

    if ( Index == -1 )
    {
        for ( int i = 0; i < sp_countof(g_CurrencySigns); i++ )
        {
            if ( pEndChar - pStartChar >= g_CurrencySigns[i].Sign.Len &&
                 wcsnicmp( pEndChar - g_CurrencySigns[i].Sign.Len, g_CurrencySigns[i].Sign.pStr, g_CurrencySigns[i].Sign.Len ) == 0 )
            {
                Index = i;
                pEndChar -= g_CurrencySigns[i].Sign.Len;
                ePosition = FOLLOWING;
                break;
            }
        }
    }

    return Index;
} /* MatchCurrencySign */      

/***********************************************************************************************
* Zeroes *
*--------*
*   Description:
*       A helper function which simply determines if a number string contains only zeroes...
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
bool CStdSentEnum::Zeroes(const WCHAR *NumberString)
{
    bool bAllZeroes = true;
    for (ULONG i = 0; i < wcslen(NumberString); i++)
    {
        if (NumberString[i] != '0' && isdigit(NumberString[i]) )
        {
            bAllZeroes = false;
            break;
        }
        else if ( !isdigit( NumberString[i] ) && NumberString[i] != ',' )
        {
            break;
        }
    }
    return bAllZeroes;
} /* Zeroes */

/***********************************************************************************************
* ThreeZeroes *
*-------------*
*   Description:
*       A helper function which simply determines if a number string contains three zeroes...
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
bool CStdSentEnum::ThreeZeroes(const WCHAR *NumberString)
{
    bool bThreeZeroes = true;
    for (ULONG i = 0; i < 3; i++)
    {
        if (NumberString[i] != '0' && isdigit(NumberString[i]))
        {
            bThreeZeroes = false;
            break;
        }
    }
    return bThreeZeroes;
} /* ThreeZeroes */

//-----------End Of File-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\spttsengui.h ===
// spttsengui.h : Declaration of SpTtsEngUI

#ifndef __SPTTSENGUI_H_
#define __SPTTSENGUI_H_

#include "ms_entropicengine.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// SpTtsEngUI
class ATL_NO_VTABLE SpTtsEngUI : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<SpTtsEngUI, &CLSID_SpTtsEngUI>,
    public ISpTokenUI
{
public:
	SpTtsEngUI()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SPTTSENGUI)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(SpTtsEngUI)
   	COM_INTERFACE_ENTRY(ISpTokenUI)
END_COM_MAP()

// IMsasrUI
public:
    //-- ISpTokenUI -----------------------------------------------------------
    STDMETHODIMP IsUISupported(
                    const WCHAR * pszTypeOfUI,
                    void * pvExtraData,
                    ULONG cbExtraData,
                    IUnknown * punkObject,
                    BOOL *pfSupported);
    STDMETHODIMP DisplayUI(
                    HWND hwndParent,
                    const WCHAR * pszTitle,
                    const WCHAR * pszTypeOfUI,
                    void * pvExtraData,
                    ULONG cbExtraData,                   
                    ISpObjectToken * pToken,
                    IUnknown * punkObject);
};

#endif //__SPTTSENGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\spttsengui.cpp ===
// spttsengui.cpp : Implementation of SpTtsEngUI

#include "stdafx.h"
#include "spttsengui.h"
#include "ttspropertiesdialog.h"
#include "spddkhlp.h"

/****************************************************************************
* SpTtsEngUI::IsUISupported *
*-------------------------*
*   Description:  Determines if the supplied standard UI component is 
*       supported by the engine.  
*
*   Returns:
*       *pfSupported - set to TRUE if the specified standard UI component 
*                      is supported.
*       E_INVALIDARG - If one of the supplied arguments is invalid.
*
********************************************************************* AH ***/
STDMETHODIMP SpTtsEngUI::IsUISupported( const WCHAR * pszTypeOfUI, 
                                        void *        /* pvExtraData */,
                                        ULONG         /* cbExtraData */,
                                        IUnknown *    /* punkObject  */, 
                                        BOOL *        pfSupported )
{
    SPDBG_FUNC("SpTtsEngUI::IsUISupported");

    // Validate the params
    if ( pfSupported == NULL                ||
         SP_IS_BAD_WRITE_PTR( pfSupported ) )
    {
        return E_INVALIDARG;
    }

    *pfSupported = FALSE;

    // Test to see if the UI is supported
    if ( wcscmp( pszTypeOfUI, SPDUI_EngineProperties ) == 0 )
    {
        *pfSupported = TRUE;
    }

    return S_OK;
} /* IsUISupported */  
  
/****************************************************************************
* SpTtsEngUI::DisplayUI *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* AH ***/
STDMETHODIMP SpTtsEngUI::DisplayUI( HWND             hwndParent, 
                                    const WCHAR *    pszTitle, 
                                    const WCHAR *    pszTypeOfUI, 
                                    void *           /* pvExtraData */,
                                    ULONG            /* cbExtraData */,
                                    ISpObjectToken * pToken, 
                                    IUnknown *       /* punkObject */)
{
    SPDBG_FUNC("SpTtsEngUI::DisplayUI");

    // Validate the params
    if ( !IsWindow( hwndParent )            ||
         SP_IS_BAD_READ_PTR( pszTitle )     ||
         SP_IS_BAD_INTERFACE_PTR( pToken ) )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    // Display the UI
    if ( SUCCEEDED( hr ) )
    {
        if ( wcscmp( pszTypeOfUI, SPDUI_EngineProperties ) == 0)
        {
            CTTSPropertiesDialog dlg( _Module.GetModuleInstance(), hwndParent );
            hr = dlg.Run();                  
        }
    }

    return hr;
} /* DisplayUI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\syllabletagger.cpp ===
/******************************************************************************
* SyllableTagger.cpp *
*--------------------*
*
*  This is an implementation of the CSyllableTagger class.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 04/28/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

//--- Additional includes
#include "stdafx.h"

#ifndef SPDebug_h
    #include <spdebug.h>
#endif
 
#ifndef AlloOps_H
    #include "AlloOps.h"
#endif

//-----------------------------
// Data.cpp
//-----------------------------
extern const unsigned long    g_AlloFlags[];

/*****************************************************************************
* CSyllableTagger::If_Consonant_Cluster *
*---------------------------------------*
*   Description:
*   Return TRUE if consoants can be clustered.
*       
********************************************************************** MC ***/
short CSyllableTagger::If_Consonant_Cluster( ALLO_CODE Consonant_1st, ALLO_CODE Consonant_2nd)
{
    SPDBG_FUNC( "CSyllableTagger::If_Consonant_Cluster" );
    short ret;
    
    ret = false;

    switch( Consonant_1st)
    {
        //---------------------------
        // f -> r,l
        //---------------------------
        case _f_:
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_:
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // v -> r,l
        //---------------------------
        case _v_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_: 
                {
                    ret = true;
                }
                break;
            }
        }
        break;

        //---------------------------
        // TH -> r,w
        //---------------------------
        case _TH_:
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _w_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // s -> w,l,p,t,k,m,n,f
        //---------------------------
        case _s_: 
        {
            switch( Consonant_2nd)
            {
                case _w_:
                case _l_:
                case _p_:
                case _t_:
                case _k_:
                case _m_:
                case _n_:
                case _f_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // SH -> w,l,p,t,r,m,n
        //---------------------------
        case _SH_: 
        {
            switch( Consonant_2nd)
            {
                case _w_:
                case _l_:
                case _p_:
                case _t_:
                case _r_:
                case _m_:
                case _n_: 
                {
                    ret = true;
                }
                break;
            }
        }
        break;

        //---------------------------
        // p -> r,l
        //---------------------------
        case _p_:
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // b -> r,l
        //---------------------------
        case _b_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // t -> r,w
        //---------------------------
        case _t_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _w_:
                {
                    ret = true;
                }
            }
        }
        break;

        //---------------------------
        // d -> r,w
        //---------------------------
        case _d_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _w_: 
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // k -> r,l,w
        //---------------------------
        case _k_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_:
                case _w_:
                {
                    ret = true; 
                }
                break;
            }
        }
        break;

        //---------------------------
        // g -> r,l,w
        //---------------------------
        case _g_: 
        {
            switch( Consonant_2nd)
            {
                case _r_:
                case _l_:
                case _w_: 
                {
                    ret = true; 
                }
            break;
            }
        }
        break;
    }
    return ret;
} /* CSyllableTagger::If_Consonant_Cluster */





/*****************************************************************************
* CSyllableTagger::Find_Next_Word_Bound *
*---------------------------------------*
*   Description:
*   Return allo index for next word boundary
*       
********************************************************************** MC ***/
short CSyllableTagger::Find_Next_Word_Bound( short index )
{
    SPDBG_FUNC( "CSyllableTagger::Find_Next_Word_Bound" );
    ALLO_ARRAY   *pCurAllo;
    
    long   i;
    
    for( i = index+1; i < m_numOfCells; i++ )
    {
        pCurAllo = &m_pAllos[i];
        if( pCurAllo->ctrlFlags & (BOUNDARY_TYPE_FIELD | WORD_START) )
        {
            break;
        }
    }
    return (short)i;
} /* CSyllableTagger::Find_Next_Word_Bound */


/*****************************************************************************
* CSyllableTagger::MarkSyllableStart *
*------------------------------------*
*   Description:
*   Mark SYLLABLE_START positions
*  
********************************************************************** MC ***/
void CSyllableTagger::MarkSyllableStart()
{
    SPDBG_FUNC( "CSyllableTagger::MarkSyllableStart" );
    short       index;
    long        cur_Ctrl;
    long        cur_AlloFlags;
    short       dist, syllable_index;
    ALLO_CODE       phon_1st, phon_2nd;
    long        syllOrder;
    ALLO_ARRAY   *pCurAllo;
    
    syllable_index = 0;
    for( index = 0; index < m_numOfCells; )
    {
        pCurAllo = &m_pAllos[index];
        //-------------------------------
        // Skip SIL
        //-------------------------------
        while( pCurAllo->allo == _SIL_)
        {
            syllable_index++;
            index++;
            if( index >= m_numOfCells)
            {
                break;
            }
            pCurAllo = &m_pAllos[index];
        }
        if( index < m_numOfCells)
        {
            pCurAllo = &m_pAllos[index];
            cur_Ctrl = pCurAllo->ctrlFlags;
            cur_AlloFlags = ::g_AlloFlags[pCurAllo->allo];
            if( cur_AlloFlags & KVOWELF)
            {
                pCurAllo = &m_pAllos[syllable_index];
                pCurAllo->ctrlFlags |= SYLLABLE_START;
                syllOrder = cur_Ctrl & SYLLABLE_ORDER_FIELD;
                if( (syllOrder == ONE_OR_NO_SYLLABLE_IN_WORD) 
                    || (syllOrder == LAST_SYLLABLE_IN_WORD) )
                {
                    index = Find_Next_Word_Bound( index );
                    syllable_index = index;
                }
                else
                {
                    //----------------------------------------------
                    // It's either the 1st or mid vowel in word. 
                    // Scan forward for consonants.  
                    //----------------------------------------------
                    dist = (-1 );
                    do
                    {
                        index++;
                        pCurAllo = &m_pAllos[index];
                        cur_AlloFlags = g_AlloFlags[pCurAllo->allo];
                        dist++;         // count number of consonants   
                    }
                    while( !(cur_AlloFlags & KVOWELF) );
                
                    if( dist == 0)
                    {
                        syllable_index = index;
                    }
                
                    else if( dist == 1)
                    {
                        index--;        // start next syllable on consonant 
                        syllable_index = index;
                    }
                
                    else if( dist == 2)
                    {
                        pCurAllo = &m_pAllos[index-1];
                        phon_2nd = pCurAllo->allo;
                        pCurAllo = &m_pAllos[index-2];
                        phon_1st = pCurAllo->allo;
                        if( If_Consonant_Cluster( phon_1st, phon_2nd) )
                        {
                            index -= 2;     // start next syllable on cluster
                        }
                        else
                        {
                            index--;        // start next syllable on 2nd consonant 
                        }
                        syllable_index = index;
                    }
                
                    else if( dist == 3)
                    {
                        pCurAllo = &m_pAllos[index-1];
                        phon_2nd = pCurAllo->allo;
                        pCurAllo = &m_pAllos[index-2];
                        phon_1st = pCurAllo->allo;
                        if( If_Consonant_Cluster( phon_1st, phon_2nd) )
                        {
                         pCurAllo = &m_pAllos[index-3];
                           if( pCurAllo->allo == _s_)
                            {
                                index -= 3;     // start next syllable on s-cluster 
                            }
                            else
                            {
                                index -= 2;     // start next syllable on cluster 
                            }
                        }
                        else
                        {
                            index--;            // start next syllable on 3rd consonant 
                        }
                        syllable_index = index;
                    }
                    else
                    {
                        pCurAllo = &m_pAllos[index-dist];
                        phon_2nd = pCurAllo->allo;
                        pCurAllo = &m_pAllos[index-dist+1];
                        phon_1st = pCurAllo->allo;
                        if( If_Consonant_Cluster( phon_1st, phon_2nd) )
                        {
                            index = (short)(index - (dist - 2));   // start next syllable after cluster
                        }
                        else
                        {
                            index = (short)(index - (dist >> 1));  // start next syllable somewhere 
                                                    // in the middle  
                        }
                        syllable_index = index;
                    }
                }
            }
            else
            {
                index++;
            }
        
        }
    }
    return;
} /* CSyllableTagger::MarkSyllableStart */




/*****************************************************************************
* CSyllableTagger::MarkSyllableBoundry *
*--------------------------------------*
*   Description:
*   Mark phons in last syllable before boundry with boundry type flag  
*       
********************************************************************** MC ***/
void CSyllableTagger::MarkSyllableBoundry( long scanIndex)
{
    SPDBG_FUNC( "CSyllableTagger::MarkSyllableBoundry" );

    long   index;
    ALLO_CODE   cur_Allo;
    long    cur_AlloFlags;
    long    cur_Bound;
    long    boundType;
    ALLO_ARRAY   *pCurAllo;
    
    for( index = scanIndex+1; index < m_numOfCells; index++)
    {
        pCurAllo = &m_pAllos[index];
        cur_Allo = pCurAllo->allo;
        cur_AlloFlags = g_AlloFlags[cur_Allo];
        cur_Bound = pCurAllo->ctrlFlags & BOUNDARY_TYPE_FIELD;
        if( cur_Bound)
        {
            boundType = 0;
            
            if( cur_Bound & TERM_BOUND )
            {
                boundType |= (TERM_END_SYLL + WORD_END_SYLL );
            }
            if( cur_Bound & WORD_START )
            {
                boundType |= WORD_END_SYLL;
            }
            
            pCurAllo = &m_pAllos[scanIndex];
            pCurAllo->ctrlFlags |= boundType;
        }
        
        if( cur_AlloFlags & KVOWELF)
        {
            break;
        }
    }
} /* CSyllableTagger::MarkSyllableBoundry */



/*****************************************************************************
* CSyllableTagger::MarkSyllableOrder *
*------------------------------------*
*   Description:
*   Tag syllable ordering
*       
********************************************************************** MC ***/
void CSyllableTagger::MarkSyllableOrder( long scanIndex )
{
    SPDBG_FUNC( "CSyllableTagger::MarkSyllableOrder" );
    long       index;
    ALLO_CODE   cur_Allo;
    long        cur_Bound;
    long        cur_AlloFlags;
    long        order;
    long        cur_SyllableType;
    ALLO_ARRAY   *pCurAllo;
    
    //------------------------------------------------------------------------------
    // Scan backwards in PhonBuf_1 till word boundry and look for any other vowels. 
    // Set 'order' to LAST_SYLLABLE_IN_WORD if there are any.  
    //------------------------------------------------------------------------------
    order = 0;
    for( index = scanIndex-1; index > 0; index-- )
    {
        pCurAllo = &m_pAllos[index];
        cur_Allo = pCurAllo->allo;
        cur_AlloFlags = g_AlloFlags[cur_Allo];
        cur_SyllableType = pCurAllo->ctrlFlags & SYLLABLE_TYPE_FIELD;
        if( cur_SyllableType >= WORD_END_SYLL )
        {
            break;
        }
        
        if( cur_AlloFlags & KVOWELF )
        {
            order = LAST_SYLLABLE_IN_WORD;  // there's at least one proceeding vowel    
            break;
        }
    }
    
    //----------------------------------------------------------------------------------
    // Scan forward in PhonBuf_1 till word boundry and look for any other vowels 
    // If there's a fwd vowel but no bkwd vowel:  'order' = FIRST_SYLLABLE_IN_WORD 
    // If there's a fwd vowel and a bkwd vowel:  'order' = MID_SYLLABLE_IN_WORD 
    // If there's no fwd vowel but a bkwd vowel:  'order' = LAST_SYLLABLE_IN_WORD 
    // If there's no fwd vowel and no bkwd vowel:  'order' = 0  
    //----------------------------------------------------------------------------------
    for( index = scanIndex+1; index < m_numOfCells; index++ )
    {
        pCurAllo = &m_pAllos[index];
        cur_Allo = pCurAllo->allo;
        cur_AlloFlags = g_AlloFlags[cur_Allo];
        cur_Bound = pCurAllo->ctrlFlags & BOUNDARY_TYPE_FIELD;
        if( cur_Bound)
        {
            pCurAllo = &m_pAllos[scanIndex];
            pCurAllo->ctrlFlags |= order;
            break;
        }
        if( cur_AlloFlags & KVOWELF)
        {
            if( order == LAST_SYLLABLE_IN_WORD)
            {
                order = MID_SYLLABLE_IN_WORD;
            }
            else if( order == 0)
            {
                order = FIRST_SYLLABLE_IN_WORD;
            }
        }
    }
} /* CSyllableTagger::MarkSyllableOrder */







/*****************************************************************************
* CSyllableTagger::ListToArray *
*------------------------------*
*   Description:
*   Copy list to array
*       
********************************************************************** MC ***/
void CSyllableTagger::ListToArray( CAlloList *pAllos )
{
   SPDBG_FUNC( "CSyllableTagger::ListToArray" );
   CAlloCell   *pCurCell;
	long		cAllo;

	cAllo = 0;
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
		if( cAllo >= m_numOfCells )
		{
			break;
		}
		m_pAllos[cAllo].allo = pCurCell->m_allo;
		m_pAllos[cAllo].ctrlFlags = pCurCell->m_ctrlFlags;
		pCurCell = pAllos->GetNextCell();
		cAllo++;
    }
} /* CSyllableTagger::ListToArray */


/*****************************************************************************
* CSyllableTagger::ArrayToList *
*------------------------------*
*   Description:
*   Copy array values back into list
*       
********************************************************************** MC ***/
void CSyllableTagger::ArrayToList( CAlloList *pAllos )
{
    SPDBG_FUNC( "CSyllableTagger::ArrayToList" );
    CAlloCell   *pCurCell;
	long		cAllo;

	cAllo = 0;
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
		if( cAllo >= m_numOfCells )
		{
			break;
		}
		pCurCell->m_allo = m_pAllos[cAllo].allo;
		pCurCell->m_ctrlFlags = m_pAllos[cAllo].ctrlFlags;
		pCurCell = pAllos->GetNextCell();
		cAllo++;
    }
} /* CSyllableTagger::ArrayToList */


/*****************************************************************************
* CSyllableTagger::TagSyllables *
*---------------------------------*
*   Description:
*   Tag syllable boundaries
*       
********************************************************************** MC ***/
void CSyllableTagger::TagSyllables( CAlloList *pAllos )
{
    SPDBG_FUNC( "CSyllableTagger::TagSyllables" );
    ALLO_ARRAY   *pCurAllo;
    ALLO_CODE   cur_Allo;
    long    cur_Ctrl;
    long    scanIndex;
    long    cur_AlloFlags; 
    
	// Get allo count
	//------------------------------
    m_numOfCells = pAllos->GetCount();
	if( m_numOfCells > 0 )
	{
		m_pAllos = new ALLO_ARRAY[m_numOfCells];
		if( m_pAllos )
		{
			ListToArray( pAllos );
			for( scanIndex = 0; scanIndex < m_numOfCells; scanIndex++ )
			{
				pCurAllo = &m_pAllos[scanIndex];
				cur_Allo = pCurAllo->allo;
				cur_AlloFlags = g_AlloFlags[cur_Allo];
				cur_Ctrl = pCurAllo->ctrlFlags;
        
				if( cur_AlloFlags & KVOWELF)
				{
					//--------------------------
					// Phon is a VOWEL
					//--------------------------
					MarkSyllableOrder( scanIndex );
				}
				else
				{
					//--------------------------
					// Phon is a CONSONANT
					// move stress??
					//--------------------------
				}
        
				MarkSyllableBoundry( scanIndex );
			}
    
			MarkSyllableStart();
			ArrayToList( pAllos );
			delete m_pAllos;
		}
	}
} /* CSyllableTagger::TagSyllables */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__338F1415_C40E_478D_AF8E_AC21CF4D0E0C__INCLUDED_)
#define AFX_STDAFX_H__338F1415_C40E_478D_AF8E_AC21CF4D0E0C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <math.h>
#include <tchar.h>

#include <SPDDKHlp.h>
#include <SPCollec.h>
#include <spunicode.h>
//
//  String handling and conversion classes
//
/*** SPLSTR
*   This structure is for managing strings with known lengths
*/
struct SPLSTR
{
    WCHAR*  pStr;
    int     Len;
};
#define DEF_SPLSTR( s ) { L##s , sp_countof( s ) - 1 }

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__338F1415_C40E_478D_AF8E_AC21CF4D0E0C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\timenorm.cpp ===
/***********************************************************************************************
* TimeNorm.cpp *
*-------------*
*  Description:
*   These functions normalize times of day and time measurements.
*-----------------------------------------------------------------------------------------------
*  Created by AH                                                                August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

#pragma warning (disable : 4296)

/***********************************************************************************************
* IsTimeOfDay *
*-------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a time of day.
* 
*   RegExp:
*       [01-09,1-12][:][00-09,10-59][TimeAbbreviation]?
*
*   Types assigned:
*       TIMEOFDAY
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsTimeOfDay( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager,
                                   CWordList& WordList, BOOL fMultiItem )
{
    SPDBG_FUNC( "CStdSentEnum::IsTimeOfDay" );

    HRESULT hr = S_OK;
    const WCHAR *pStartChar = m_pNextChar, *pEndOfItem = m_pEndOfCurrItem, *pEndChar = m_pEndChar;
    const SPVTEXTFRAG* pFrag = m_pCurrFrag;
    const SPVSTATE *pTimeXMLState = &pFrag->State, *pAbbreviationXMLState = NULL;
    CItemList PreAbbreviationList;
    BOOL fAdvancePointers = false;
    WCHAR *pHours = NULL, *pMinutes = NULL, *pAbbreviation = NULL;
    ULONG ulHours = 0, ulMinutes = 0;
    TIMEABBREVIATION TimeAbbreviation = UNDEFINED;
    TTSItemType ItemType = eUNMATCHED;

    //--- Max length of a string matching this regexp is 9 character 
    if ( pEndOfItem - pStartChar > 9 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        pHours = (WCHAR*) pStartChar;
        
        //--- Try to match a number for the hour of day - [01-09,1-12] 
        ulHours = my_wcstoul( pHours, &pMinutes );
        if ( pHours != pMinutes && 
             pMinutes - pHours <= 2 )
        {
            //--- Try to match the colon - [:] 
            if ( *pMinutes == ':' )
            {
                pMinutes++;
                //--- Try to match a number for the minutes - [00-09,10-59] 
                ulMinutes = my_wcstoul( pMinutes, &pAbbreviation );
                if ( pMinutes != pAbbreviation &&
                     pAbbreviation - pMinutes == 2 )
                {
                    //--- Verify that this is the end of the string 
                    if ( pAbbreviation == pEndOfItem )
                    {
                        //--- May have gotten hours and minutes - validate values 
                        if ( HOURMIN   <= ulHours   && ulHours   <= HOURMAX     &&
                             MINUTEMIN <= ulMinutes && ulMinutes <= MINUTEMAX )
                        {
                            //--- A successful match has been made, but peek ahead in text for Time Abbreviation
                            if ( fMultiItem )
                            {
                                pStartChar = pEndOfItem;
                                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, 
                                                            true, &PreAbbreviationList );
                                if ( pStartChar &&
                                     SUCCEEDED( hr ) )
                                {
								    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );

                                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                                            ( ( ItemType = IsEOSItem( *(pEndOfItem - 1) ) ) != eUNMATCHED &&
                                              ( ItemType != ePERIOD ||
                                                ( _wcsnicmp( pStartChar, L"am.", 3 ) == 0 &&
                                                  pStartChar + 3 == pEndOfItem ) ||
                                                ( _wcsnicmp( pStartChar, L"pm.", 3 ) == 0 &&
                                                  pStartChar + 3 == pEndOfItem ) ) ) )
                                    {
                                        pEndOfItem--;
                                    }
                                    pAbbreviation = (WCHAR*) pStartChar;

                                    if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                                           pAbbreviation + 2 == pEndOfItem )           ||
                                         ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                                           pAbbreviation + 4 == pEndOfItem ) )
                                    {
                                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                                        TimeAbbreviation        = AM;
                                        pAbbreviationXMLState   = &pFrag->State;
                                        fAdvancePointers        = true;
                                    }
                                    else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                                                pAbbreviation + 2 == pEndOfItem )           ||
                                              ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                                                pAbbreviation + 4 == pEndOfItem ) )
                                    {
                                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                                        TimeAbbreviation        = PM;
                                        pAbbreviationXMLState   = &pFrag->State;
                                        fAdvancePointers        = true;
                                    }
                                }
                            }
                        }
                        else // hours or minutes were out of range
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    //--- Check to see if the rest of the string is a time abbreviation - [TimeAbbreviation] 
                    else if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                                pAbbreviation + 2 == pEndOfItem ) ||
                              ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                                pAbbreviation + 4 == pEndOfItem ) )
						{
							//--- May have gotten hours and minutes and time abbreviation - validate values 
							if ( HOURMIN   <= ulHours   && ulHours   <= HOURMAX     &&
								MINUTEMIN <= ulMinutes && ulMinutes <= MINUTEMAX )
							{
								//--- A successful match has been made 
								TimeAbbreviation        = AM;
								pAbbreviationXMLState   = &pFrag->State;
							}
							else // hours or minutes were out of range
							{
								hr = E_INVALIDARG;
							}
						}
					//--- Check to see if the rest of the string is a time abbreviation - [TimeAbbreviation] 
					else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                                pAbbreviation + 2 == pEndOfItem ) ||
                              ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                                pAbbreviation + 4 == pEndOfItem ) )
					{
						//--- May have gotten hours and minutes and time abbreviation - validate values 
						if ( HOURMIN   <= ulHours   && ulHours   <= HOURMAX     &&
							MINUTEMIN <= ulMinutes && ulMinutes <= MINUTEMAX )
						{
							//--- A successful match has been made 
							pAbbreviationXMLState   = &pFrag->State;
							TimeAbbreviation        = PM;
						}
						else // hours or minutes were out of range
						{
							hr = E_INVALIDARG;
						}
					}
					else // string ended in invalid characters
					{
						hr = E_INVALIDARG;
					}
				} // failed to match a valid minutes string
                else
                {
                    hr = E_INVALIDARG;
                }
            } // failed to match the colon, could be just hours and a time abbreviation
            else if ( pMinutes < m_pEndOfCurrItem )
            {
                pAbbreviation = pMinutes;
                pMinutes      = NULL;                
                				
				
                //--- Check for TimeAbbreviation - [TimeAbbreviation] 
                if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                       pAbbreviation + 2 == pEndOfItem ) ||
                     ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                       pAbbreviation + 4 == pEndOfItem ) )
                {
                    //--- A successful match has been made - Hour AM 
                    pAbbreviationXMLState   = &pFrag->State;
                    TimeAbbreviation        = AM;
                }
                else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                            pAbbreviation + 2 == pEndOfItem ) ||
                          ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                            pAbbreviation + 4 == pEndOfItem ) )
                {
                    //--- A successful match has been made - Hour PM 
                    pAbbreviationXMLState   = &pFrag->State;
                    TimeAbbreviation        = PM;
                }
                else // failed to match a valid time abbreviation
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( fMultiItem )
            {
                //--- Set pMinutes to NULL, so we know later that we've got no minutes string...
                pMinutes      = NULL;                

                //--- Peek ahead in text for a time abbreviation
                pStartChar = pEndOfItem;
                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, 
                                            true, &PreAbbreviationList );
                if ( !pStartChar &&
                     SUCCEEDED( hr ) )
                {
                    hr = E_INVALIDARG;
                }
                else if ( pStartChar &&
                          SUCCEEDED( hr ) )
                {
                    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );

                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                            ( ( ItemType = IsEOSItem( *(pEndOfItem - 1) ) ) != eUNMATCHED &&
                              ItemType != ePERIOD ) )
                    {
                        pEndOfItem--;
                    }
                    pAbbreviation = (WCHAR*) pStartChar;

                    if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                           pAbbreviation + 2 == pEndOfItem )           ||
                         ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                           pAbbreviation + 4 == pEndOfItem ) )
                    {
                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                        TimeAbbreviation        = AM;
                        pAbbreviationXMLState   = &pFrag->State;
                        fAdvancePointers        = true;
                    }
                    else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                                pAbbreviation + 2 == pEndOfItem )           ||
                              ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                                pAbbreviation + 4 == pEndOfItem ) )
                    {
                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                        TimeAbbreviation        = PM;
                        pAbbreviationXMLState   = &pFrag->State;
                        fAdvancePointers        = true;
                    }
                    //--- Failed to match a valid Time Abbreviation
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        } // failed to match a valid hours string
        else
        {
            hr = E_INVALIDARG;
        }

        //--- Successfully matched a Time Of Day!  Now expand it and fill out pItemNormInfo
        if ( SUCCEEDED( hr ) )
        {
            NumberGroup Garbage;
            TTSWord Word;
            ZeroMemory( &Word, sizeof(TTSWord) );
            Word.eWordPartOfSpeech = MS_Unknown;

            pItemNormInfo = (TTSTimeOfDayItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeOfDayItemInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                //--- Fill out known parts of pItemNormInfo
                ZeroMemory( pItemNormInfo, sizeof(TTSTimeOfDayItemInfo) );
                pItemNormInfo->Type                                          = eTIMEOFDAY;
                ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fMinutes          = pMinutes ? true : false;
                ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fTimeAbbreviation = TimeAbbreviation != UNDEFINED ? true : false;
                ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fTwentyFourHour   = false;
                
                //--- Expand the hours
                if ( !iswdigit( pHours[1] ) )
                {
                    ExpandDigit( pHours[0], Garbage, WordList );
                }
                else
                {
                    ExpandTwoDigits( pHours, Garbage, WordList );
                }

                //--- Expand the minutes
                if ( pMinutes )
                {
                    //--- Special case: A bare o'clock - 1:00, 2:00, etc. 
                    if ( wcsncmp( pMinutes, L"00", 2 ) == 0 )
                    {
                        WCHAR *pGarbage;
                        ULONG ulHours = my_wcstoul( pHours, &pGarbage );
                        //--- Under twelve is followed by "o'clock" 
                        if ( ulHours <= 12 )
                        {
                            Word.pWordText  = g_OClock.pStr;
                            Word.ulWordLen  = g_OClock.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                        //--- Over twelve is followed by "hundred hours" 
                        else
                        {
                            ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fTwentyFourHour = true;

                            Word.pWordText  = g_hundred.pStr;
                            Word.ulWordLen  = g_hundred.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );

                            Word.pWordText  = g_hours.pStr;
                            Word.ulWordLen  = g_hours.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                    }
                    //--- Special Case: Minutes less than 10 - 1:05, 2:06, etc. 
                    else if ( pMinutes[0] == L'0' )
                    {
                        Word.pWordText  = g_O.pStr;
                        Word.ulWordLen  = g_O.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );

                        ExpandDigit( pMinutes[1], Garbage, WordList );
                    }
                    //--- Default Case 
                    else 
                    {
                        ExpandTwoDigits( pMinutes, Garbage, WordList );
                    }
                }

                //--- Clean up Time XML State
                SPLISTPOS WordListPos = WordList.GetHeadPosition();
                while ( WordListPos )
                {
                    TTSWord& TempWord  = WordList.GetNext( WordListPos );
                    TempWord.pXmlState = pTimeXMLState;
                }

                //--- Insert Pre-Abbreviation XML States
                while ( !PreAbbreviationList.IsEmpty() )
                {
                    WordList.AddTail( ( PreAbbreviationList.RemoveHead() ).Words[0] );
                }

                //--- Expand the Time Abbreviation
                //--- AM 
                if ( TimeAbbreviation == AM )
                {
                    //--- Ensure the letters are pronounced as nouns...
                    SPVSTATE* pNewState = (SPVSTATE*) MemoryManager.GetMemory( sizeof( SPVSTATE ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        memcpy( pNewState, pAbbreviationXMLState, sizeof( SPVSTATE ) );
                        pNewState->ePartOfSpeech = SPPS_Noun;

                        Word.pXmlState  = pNewState;
                        Word.pWordText  = g_A.pStr;
                        Word.ulWordLen  = g_A.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );

                        Word.pWordText  = g_M.pStr;
                        Word.ulWordLen  = g_M.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );
                    }
                }
                //--- PM 
                else if ( TimeAbbreviation == PM )
                {
                    //--- Ensure the letters are pronounced as nouns...
                    SPVSTATE* pNewState = (SPVSTATE*) MemoryManager.GetMemory( sizeof( SPVSTATE ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        memcpy( pNewState, pAbbreviationXMLState, sizeof( SPVSTATE ) );
                        pNewState->ePartOfSpeech = SPPS_Noun;

                        Word.pXmlState  = pAbbreviationXMLState;
                        Word.pWordText  = g_P.pStr;
                        Word.ulWordLen  = g_P.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );

                        Word.pWordText  = g_M.pStr;
                        Word.ulWordLen  = g_M.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );
                    }
                }

                //--- Update pointers, if necessary
                if ( fAdvancePointers )
                {
                    m_pCurrFrag      = pFrag;
                    m_pEndChar       = pEndChar;
                    m_pEndOfCurrItem = pEndOfItem;
                }
            }
        }
    }
    return hr;
} /* IsTimeOfDay */

/***********************************************************************************************
* IsTime *
*--------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a time.
* 
*   RegExp:
*       { d+ || d(1-3)[,ddd]+ }[:][00-09,10-59]{ [:][00-09,10-59] }?
*
*   Types assigned:
*       TIME_HRMIN, TIME_MINSEC, TIME_HRMINSEC
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsTime( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "TimeNorm IsTime" );

    HRESULT hr = S_OK;
    WCHAR *pFirstChunk = NULL, *pSecondChunk = NULL, *pThirdChunk = NULL, *pLeftOver = NULL;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    ULONG ulSecond = 0, ulThird = 0;
    TTSItemInfo *pFirstChunkInfo = NULL;
    BOOL fNegative = false;

    pFirstChunk = (WCHAR*) m_pNextChar;
    
    //--- Try to match a number for the hours/minutes - { d+ } 
    if ( *pFirstChunk == L'-' )
    {
        pFirstChunk++;
        fNegative = true;
    }
    while ( *pFirstChunk == L'0' )
    {
        pFirstChunk++;
    }
    if ( *pFirstChunk == L':' )
    {
        pFirstChunk--;
    }
    pSecondChunk = wcschr( pFirstChunk, L':' );

    if ( pSecondChunk &&
         pFirstChunk  < pSecondChunk &&
         pSecondChunk < m_pEndOfCurrItem - 1 )
    {
        m_pNextChar      = pFirstChunk;
        m_pEndOfCurrItem = pSecondChunk;

        hr = IsNumberCategory( pFirstChunkInfo, L"NUMBER", MemoryManager );

        m_pNextChar      = pTempNextChar;
        m_pEndOfCurrItem = pTempEndOfItem;

        if ( SUCCEEDED( hr ) &&
             ( pFirstChunkInfo->Type == eNUM_DECIMAL ||
               pFirstChunkInfo->Type == eNUM_CARDINAL ) )
        {
            if ( fNegative )
            {
                ( (TTSNumberItemInfo*) pFirstChunkInfo )->fNegative = true;
                TTSWord Word;
                ZeroMemory( &Word, sizeof( TTSWord ) );
                Word.eWordPartOfSpeech  = MS_Unknown;
                Word.pXmlState          = &m_pCurrFrag->State;
                Word.pWordText          = g_negative.pStr;
                Word.ulWordLen          = g_negative.Len;
                Word.pLemma             = Word.pWordText;
                Word.ulLemmaLen         = Word.ulWordLen;
                ( (TTSNumberItemInfo*) pFirstChunkInfo )->pWordList->AddHead( Word );
            }

            pSecondChunk++;
            //--- Try to match a number for the minutes/seconds - [00-09,10-59] 
            ulSecond = my_wcstoul( pSecondChunk, &pThirdChunk );
            if ( pSecondChunk != pThirdChunk &&
                 pThirdChunk - pSecondChunk == 2 )
            {
                //--- Verify that this is the end of the string 
                if ( pThirdChunk == m_pEndOfCurrItem )
                {
                    //--- May have gotten hours and minutes or minutes and seconds - validate values 
                    if ( MINUTEMIN <= ulSecond && ulSecond <= MINUTEMAX )
                    {
                        //--- A successful match has been made 
                        //--- Default behavior here is to assume minutes and seconds 
                        if ( Context == NULL ||
                             _wcsicmp( Context, L"TIME_MS" ) == 0 )
                        {
                            //--- Successfully matched minutes and seconds.
                            pItemNormInfo = (TTSTimeItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeItemInfo),
                                                                                        &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( pItemNormInfo, sizeof(TTSTimeItemInfo) );
                                pItemNormInfo->Type = eTIME;

                                ( (TTSTimeItemInfo*) pItemNormInfo )->pMinutes = 
                                                                        (TTSNumberItemInfo*) pFirstChunkInfo;
                                if ( *pSecondChunk != L'0' )
                                {
                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pSecondChunk;
                                }
                                else
                                {
                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pSecondChunk + 1;
                                }
                            }
                        }
                        //--- If context overrides, values represent hours and minutes 
                        else if ( _wcsicmp( Context, L"TIME_HM" ) == 0 )
                        {
                            //--- Successfully matched hours and pMinutes->
                            pItemNormInfo = (TTSTimeItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeItemInfo),
                                                                                        &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( pItemNormInfo, sizeof(TTSTimeItemInfo) );
                                pItemNormInfo->Type = eTIME;
                                ( (TTSTimeItemInfo*) pItemNormInfo )->pHours = 
                                                                    (TTSNumberItemInfo*) pFirstChunkInfo;

                                TTSItemInfo* pMinutesInfo;

                                //--- Don't want "zero zero..." behavior of numbers - strip off beginning zeroes
                                if ( *pSecondChunk == L'0' )
                                {
                                    pSecondChunk++;
                                }

                                m_pNextChar      = pSecondChunk;
                                m_pEndOfCurrItem = pThirdChunk;

                                hr = IsNumber( pMinutesInfo, L"NUMBER", MemoryManager );

                                m_pNextChar      = pTempNextChar;
                                m_pEndOfCurrItem = pTempEndOfItem;

                                if ( SUCCEEDED( hr ) )
                                {
                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pMinutes = (TTSNumberItemInfo*) pMinutesInfo;
                                }
                            }
                        }
                        else
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    else // minutes or seconds were out of range
                    {
                        hr = E_INVALIDARG;
                    }
                }
                //--- Check for seconds - TIME_HRMINS 
                else
                {
                    //--- Try to match the colon 
                    if ( *pThirdChunk == L':' )
                    {
                        pThirdChunk++;
                        //--- Try to match a number for the seconds - [00-09,10-59] 
                        ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                        if ( pThirdChunk != pLeftOver &&
                             pLeftOver - pThirdChunk == 2 )
                        {
                            //--- Verify that this is the end of the string 
                            if ( pLeftOver == m_pEndOfCurrItem )
                            {
                                //--- May have gotten hours minutes and seconds - validate values 
                                if ( MINUTEMIN <= ulSecond && ulSecond <= MINUTEMAX &&
                                     SECONDMIN <= ulThird  && ulThird  <= SECONDMAX )
                                {
                                    //--- Successfully matched hours, minutes, and seconds.
                                    pItemNormInfo = (TTSTimeItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeItemInfo),
                                                                                                &hr );
                                    if ( SUCCEEDED( hr ) )
                                    {
                                        ZeroMemory( pItemNormInfo, sizeof(TTSTimeItemInfo) );
                                        pItemNormInfo->Type = eTIME;
                                        ( (TTSTimeItemInfo*) pItemNormInfo )->pHours = 
                                                                            (TTSNumberItemInfo*) pFirstChunkInfo;

                                        if ( SUCCEEDED( hr ) )
                                        {
                                            TTSItemInfo* pMinutesInfo;

                                            //--- Don't want "zero zero..." behavior of numbers - strip off beginning zeroes
                                            if ( ulSecond != 0 )
                                            {
                                                pSecondChunk += ( ( pThirdChunk - 1 ) - pSecondChunk ) - 
                                                                (ULONG)( log10( ulSecond ) + 1 );
                                            }
                                            else
                                            {
                                                pSecondChunk = pThirdChunk - 2;
                                            }

                                            m_pNextChar      = pSecondChunk;
                                            m_pEndOfCurrItem = pThirdChunk - 1;

                                            hr = IsNumber( pMinutesInfo, L"NUMBER", MemoryManager );

                                            m_pNextChar      = pTempNextChar;
                                            m_pEndOfCurrItem = pTempEndOfItem;

                                            if ( SUCCEEDED( hr ) )
                                            {
                                                ( (TTSTimeItemInfo*) pItemNormInfo )->pMinutes = 
                                                                            (TTSNumberItemInfo*) pMinutesInfo;
                                                if ( *pThirdChunk != L'0' )
                                                {
                                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pThirdChunk;
                                                }
                                                else
                                                {
                                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pThirdChunk + 1;
                                                }
                                            }
                                        }
                                    }
                                }
                                else // minutes or seconds were out of range
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else // extra junk at end of string
                            {
                                hr = E_INVALIDARG;
                            }
                        } 
                        else // extra junk at end of string
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    else // failed to match a colon
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            else // failed to match a second number
            {
                hr = E_INVALIDARG;
            }
        }
        else // failed to match a colon
        {
            hr = E_INVALIDARG;
        }
    }
    else // failed to match a first number
    {
        hr = E_INVALIDARG;
    }

    if ( FAILED( hr ) )
    {
        if ( pFirstChunkInfo )
        {
            delete ( (TTSNumberItemInfo*) pFirstChunkInfo )->pWordList;
        }
    }

    return hr;
} /* IsTime */

/***********************************************************************************************
* ExpandTime *
*------------*
*   Description:
*       Expands Items previously determined to be of type TIME_HRMINSEC by IsTime.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandTime( TTSTimeItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandTime" );

    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //-------------------
    // Expand the hours
    //-------------------

    if ( pItemInfo->pHours )
    {
        //--- Expand Number 
        hr = ExpandNumber( pItemInfo->pHours, WordList );

        //--- Insert "hour" or "hours"
        if ( SUCCEEDED( hr ) )
        {
            if ( pItemInfo->pHours->pEndChar - pItemInfo->pHours->pStartChar == 1 &&
                 pItemInfo->pHours->pStartChar[0] == L'1' )
            {
                Word.pWordText  = g_hour.pStr;
                Word.ulWordLen  = g_hour.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            else
            {
                Word.pWordText  = g_hours.pStr;
                Word.ulWordLen  = g_hours.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }

        }

        //--- Insert "and"
        if ( SUCCEEDED( hr )                 &&
             pItemInfo->pMinutes->pStartChar  &&
             !pItemInfo->pSeconds )
        {
            Word.pWordText  = g_And.pStr;
            Word.ulWordLen  = g_And.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }            
    }
    
    //---------------------
    // Expand the minutes
    //---------------------

    if ( SUCCEEDED( hr ) &&
         pItemInfo->pMinutes )
    {
        //--- Expand Number 
        hr = ExpandNumber( pItemInfo->pMinutes, WordList );

        //--- Insert "minutes" 
        if ( SUCCEEDED( hr ) )
        {
            if ( pItemInfo->pMinutes->pEndChar - pItemInfo->pMinutes->pStartChar == 1 &&
                 pItemInfo->pMinutes->pStartChar[0] == L'1' )
            {
                Word.pWordText  = g_minute.pStr;
                Word.ulWordLen  = g_minute.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            else
            {
                Word.pWordText  = g_minutes.pStr;
                Word.ulWordLen  = g_minutes.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
        }

        //--- Insert "and"
        if ( SUCCEEDED( hr ) &&
             pItemInfo->pSeconds )
        {
            Word.pWordText  = g_And.pStr;
            Word.ulWordLen  = g_And.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
    }

    //---------------------
    // Expand the seconds
    //---------------------

    if ( SUCCEEDED( hr ) &&
         pItemInfo->pSeconds )
    {
        //--- Expand Number
        NumberGroup Garbage;
        if ( iswdigit( pItemInfo->pSeconds[1] ) )
        {
            ExpandTwoDigits( pItemInfo->pSeconds, Garbage, WordList );
        }
        else
        {
            ExpandDigit( pItemInfo->pSeconds[0], Garbage, WordList );
        }

        //--- Insert "seconds" 
        if ( pItemInfo->pSeconds[0] == L'1' &&
             !iswdigit( pItemInfo->pSeconds[1] ) )
        {
            Word.pWordText  = g_second.pStr;
            Word.ulWordLen  = g_second.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else
        {
            Word.pWordText  = g_seconds.pStr;
            Word.ulWordLen  = g_seconds.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
    }

    return hr;
} /* ExpandTime */

/***********************************************************************************************
* IsTimeRange *
*-------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a time range.
*
*   RegExp:
*       [TimeOfDay]-[TimeOfDay]  
*
*   Types assigned:
*       TIME_RANGE
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsTimeRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager,
                                   CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsTimeRange" );

    HRESULT hr = S_OK;
	CWordList TempWordList;
    TTSItemInfo *pFirstTimeInfo = NULL, *pSecondTimeInfo = NULL;
    const WCHAR *pHyphen = NULL;
    CItemList PreAbbreviationList;  // Needed for SkipWhitespace function calls
    BOOL fMultiItem = false;
									
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfCurrItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

    for ( pHyphen = m_pNextChar; pHyphen < m_pEndOfCurrItem; pHyphen++ )
    {
        if ( *pHyphen == L'-' )
        {
            break;
        }
    }

	//--- Might be whitespace and time suffix before hyphen
	if( pHyphen == m_pEndOfCurrItem ) 
	{
		hr = SkipWhiteSpaceAndTags( pHyphen, m_pEndChar, m_pCurrFrag, MemoryManager, 
									true, &PreAbbreviationList );
        if ( pHyphen && SUCCEEDED( hr ) )
        {
            if ( ( _wcsnicmp( pHyphen, L"am", 2 )   == 0 &&
                   pHyphen[2] == L'-' )           ||
				 ( _wcsnicmp( pHyphen, L"pm", 2 )   == 0 &&
                   pHyphen[2] == L'-' ) )
            {
				pHyphen += 2;
                *( (WCHAR*) pHyphen ) = ' ';
                fMultiItem = true;
			}
            else if ( ( _wcsnicmp( pHyphen, L"a.m.", 4 ) == 0 &&
                        pHyphen[4] == L'-' )          ||
                      ( _wcsnicmp( pHyphen, L"p.m.", 4 ) == 0 &&
                        pHyphen[4] == L'-' ) )
            {
				pHyphen +=4;
                *( (WCHAR*) pHyphen ) = ' ';
                fMultiItem = true;
            }
			else 
			{
				hr = E_INVALIDARG;
			}
		}
		else 
        {
			hr = E_INVALIDARG;
		}		
	}

	if ( SUCCEEDED( hr ) ) 
	{
		//--- Position m_pEndOfCurrItem so it is at the end of the first token, or at the hyphen,
		//--- whichever comes first (this is necessary for IsTimeOfDay to work).        
		if( ( m_pNextChar < pHyphen ) && ( pHyphen < m_pEndOfCurrItem ) ) 
		{
			m_pEndOfCurrItem = pHyphen;
		}

        //--- Check for time of day
        hr = IsTimeOfDay( pFirstTimeInfo, MemoryManager, TempWordList, fMultiItem );

        //--- Check for just a number (hour)
		if ( hr == E_INVALIDARG && ( pHyphen <= m_pNextChar + 2 ) )
		{
            WCHAR *pTemp = NULL;
			int ulHours = my_wcstoul( m_pNextChar, &pTemp );

            if ( pTemp == pHyphen   &&
                 HOURMIN <= ulHours && 
                 ulHours <= HOURMAX )
			{		
				NumberGroup Garbage;
				if ( pTemp - m_pNextChar == 1 )
                {
                    ExpandDigit( m_pNextChar[0], Garbage, TempWordList );
                }
                else
                {
                    ExpandTwoDigits( m_pNextChar, Garbage, TempWordList );
                }
				hr = S_OK;
			}
		}

        if ( SUCCEEDED( hr ) )
        {
            //--- Insert "to"
            TTSWord Word;
            ZeroMemory( &Word, sizeof( TTSWord ) );

            Word.pXmlState          = &m_pCurrFrag->State;
            Word.eWordPartOfSpeech  = MS_Unknown;
            Word.pWordText          = g_to.pStr;
            Word.ulWordLen          = g_to.Len;
            Word.pLemma             = Word.pWordText;
            Word.ulLemmaLen         = Word.ulWordLen;
            TempWordList.AddTail( Word );

            m_pNextChar      = pHyphen + 1;
			m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );

			//---Move m_pEndOfCurrItem back from any punctuation. ("4:30-5:30.")
			while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                    IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                    IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                    IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
			{
				m_pEndOfCurrItem--;
			}

            hr = IsTimeOfDay( pSecondTimeInfo, MemoryManager, TempWordList );

            if ( SUCCEEDED( hr ) )
            {
                //--- Matched a time range!
                m_pNextChar      = pTempNextChar;
                m_pEndChar       = pTempEndChar;

                pItemNormInfo = 
                    (TTSTimeRangeItemInfo*) MemoryManager.GetMemory( sizeof( TTSTimeRangeItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    pItemNormInfo->Type = eTIME_RANGE;
                    ( (TTSTimeRangeItemInfo*) pItemNormInfo )->pFirstTimeInfo = 
                                                                        (TTSTimeOfDayItemInfo*) pFirstTimeInfo;
                    ( (TTSTimeRangeItemInfo*) pItemNormInfo )->pSecondTimeInfo =
                                                                        (TTSTimeOfDayItemInfo*) pSecondTimeInfo;
                    //--- Copy temp word list to real word list if everything has succeeded...
					WordList.AddTail( &TempWordList );
                }
            }
        }
    }

	if ( !SUCCEEDED( hr ) ) 
    {	
        m_pNextChar = pTempNextChar;
        m_pEndChar  = pTempEndChar;
        m_pEndOfCurrItem = pTempEndOfCurrItem;
        m_pCurrFrag = pTempFrag;
        if ( fMultiItem )
        {
            *( (WCHAR*) pHyphen ) = L'-';
        }
    }

    return hr;
} /* IsTimeRange */
//-----------End Of File-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\stdsentenum.cpp ===
/*******************************************************************************
* StdSentEnum.cpp *
*-----------------*
*   Description:
*       This module is the main implementation file for the CStdSentEnum class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 03/19/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif
#include "spttsengdebug.h"
#include "SpAutoObjectLock.h"

//--- Locals 
CComAutoCriticalSection CStdSentEnum::m_AbbrevTableCritSec;

//=== CStdSentEnum ============================================================
//

/*****************************************************************************
* CStdSentEnum::InitPron *
*------------------------*
*   Description:
*       Inits pron tables
********************************************************************* AH ***/
HRESULT CStdSentEnum::InitPron( WCHAR** OriginalPron )
{
    HRESULT hr = S_OK;
    WCHAR *NewPron = NULL;

    NewPron = new WCHAR[ wcslen( *OriginalPron ) ];
    hr = m_cpPhonemeConverter->PhoneToId( *OriginalPron, NewPron );
    if ( SUCCEEDED( hr ) )
    {
        *OriginalPron = NewPron;
    }

    return hr;
} /* InitPron */

/*****************************************************************************
* CStdSentEnum::FinalConstruct *
*------------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CStdSentEnum::FinalConstruct()
{
    SPDBG_FUNC( "CStdSentEnum::FinalConstruct" );
    HRESULT hr = S_OK;
    m_dwSpeakFlags  = 0;
    m_pTextFragList = NULL;
    m_pMorphLexicon = NULL;
    m_fHaveNamesLTS = false;
    m_eSeparatorAndDecimal = COMMA_PERIOD;
    m_eShortDateOrder      = MONTH_DAY_YEAR;
    /*** Create phone converter ***/
    if ( SUCCEEDED( hr ) )
    {
        hr = SpCreatePhoneConverter( 1033, NULL, NULL, &m_cpPhonemeConverter );
        m_AbbrevTableCritSec.Lock();
        if ( !g_fAbbrevTablesInitialized )
        {
            for ( ULONG i = 0; SUCCEEDED( hr ) && i < sp_countof( g_AbbreviationTable ); i++ )
            {
                if ( g_AbbreviationTable[i].pPron1 )
                {
                    hr = InitPron( &g_AbbreviationTable[i].pPron1 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AbbreviationTable[i].pPron2 )
                {
                    hr = InitPron( &g_AbbreviationTable[i].pPron2 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AbbreviationTable[i].pPron3 )
                {
                    hr = InitPron( &g_AbbreviationTable[i].pPron3 );
                }
            }
            for ( i = 0; SUCCEEDED( hr ) && i < sp_countof( g_AmbiguousWordTable ); i++ )
            {
                if ( g_AmbiguousWordTable[i].pPron1 )
                {
                    hr = InitPron( &g_AmbiguousWordTable[i].pPron1 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AmbiguousWordTable[i].pPron2 )
                {
                    hr = InitPron( &g_AmbiguousWordTable[i].pPron2 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AmbiguousWordTable[i].pPron3 )
                {
                    hr = InitPron( &g_AmbiguousWordTable[i].pPron3 );
                }
            }
            for ( i = 0; SUCCEEDED( hr ) && i < sp_countof( g_PostLexLookupWordTable ); i++ )
            {
                if ( g_PostLexLookupWordTable[i].pPron1 )
                {
                    hr = InitPron( &g_PostLexLookupWordTable[i].pPron1 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_PostLexLookupWordTable[i].pPron2 )
                {
                    hr = InitPron( &g_PostLexLookupWordTable[i].pPron2 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_PostLexLookupWordTable[i].pPron3 )
                {
                    hr = InitPron( &g_PostLexLookupWordTable[i].pPron3 );
                }
            }
            if ( SUCCEEDED( hr ) )
            {
                hr = InitPron( &g_pOfA );
                if ( SUCCEEDED( hr ) )
                {
                    hr = InitPron( &g_pOfAn );
                }
            }
        }
        if ( SUCCEEDED( hr ) )
        {
            g_fAbbrevTablesInitialized = true;
        }
        m_AbbrevTableCritSec.Unlock();
    }

    return hr;
} /* CStdSentEnum::FinalConstruct */

/*****************************************************************************
* CStdSentEnum::FinalRelease *
*----------------------------*
*   Description:
*       Destructor
********************************************************************* EDC ***/
void CStdSentEnum::FinalRelease()
{
    SPDBG_FUNC( "CStdSentEnum::FinalRelease" );

    if ( m_pMorphLexicon )
    {
        delete m_pMorphLexicon;
    }
    
} /* CStdSentEnum::FinalRelease */

/*****************************************************************************
* CStdSentEnum::SetFragList *
*---------------------------*
*   The text fragment list passed in is guaranteed to be valid for the lifetime
*   of this object. Each time this method is called, the sentence enumerator
*   should reset its state.
********************************************************************* EDC ***/
STDMETHODIMP CStdSentEnum::
    SetFragList( const SPVTEXTFRAG* pTextFragList, DWORD dwSpeakFlags )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::SetFragList" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_READ_PTR( pTextFragList ) || 
        ( dwSpeakFlags & SPF_UNUSED_FLAGS ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_dwSpeakFlags   = dwSpeakFlags;
        m_pTextFragList  = pTextFragList;

        //--- grab normalization preferences from the registry
        if ( SUCCEEDED( hr ) )
        {
            CComPtr<ISpObjectToken> cpToken;
            CSpDynamicString dstrTokenKeyName;
            hr = StringFromCLSID( CLSID_MSE_TTSEngine, &dstrTokenKeyName );
            if ( SUCCEEDED( hr ) )
            {
                hr = SpCreateNewToken( L"HKEY_CURRENT_USER\\Software\\Microsoft\\Speech\\Voices", dstrTokenKeyName,
                                       &cpToken );
            }
            if ( SUCCEEDED( hr ) )
            {
                DWORD dwTemp;
                if ( SUCCEEDED( cpToken->GetDWORD( L"SeparatorAndDecimal", &dwTemp ) ) )
                {
                    m_eSeparatorAndDecimal = (SEPARATOR_AND_DECIMAL) dwTemp;
                }
                if ( SUCCEEDED( cpToken->GetDWORD( L"ShortDateOrder", &dwTemp ) ) )
                {
                    m_eShortDateOrder = (SHORT_DATE_ORDER) dwTemp;
                }
            }
        }

        //--- Reset state
        Reset();
    }

    return hr;
} /* CStdSentEnum::SetFragList */

/*****************************************************************************
* CStdSentEnum::Next *
*--------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CStdSentEnum::Next( IEnumSENTITEM **ppSentItemEnum )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::Next" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SPIsBadWritePtr( ppSentItemEnum, sizeof( IEnumSENTITEM* ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- If this is NULL then the enum needs to be reset
        if( m_pCurrFrag )
        {
            SentencePointer NewSentencePointer;
            NewSentencePointer.pSentenceFrag = m_pCurrFrag;
            NewSentencePointer.pSentenceStart = m_pNextChar;

            hr = GetNextSentence( ppSentItemEnum );
            if( hr == S_OK ) 
            {
                //--- Update Sentence Pointer List
                hr = m_SentenceStack.Push( NewSentencePointer );
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
} /* CStdSentEnum::Next */

/*****************************************************************************
* CStdSentEnum::Previous *
*--------------------*
*
********************************************************************* AH ****/
STDMETHODIMP CStdSentEnum::Previous( IEnumSENTITEM **ppSentItemEnum )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::Previous" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SPIsBadWritePtr( ppSentItemEnum, sizeof( IEnumSENTITEM* ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Don't care if m_pCurrFrag is NULL, as long as we have enough on the SentenceStack
        //---   to skip backwards...
        if( m_SentenceStack.GetCount() >= 2 )
        {
            //--- Get the previous Sentence from the Sentence List, and then remove the Current Sentence
            SentencePointer &PreviousSentence = m_SentenceStack.Pop();
            PreviousSentence = m_SentenceStack.Pop();

            //--- Reset the current frag and the current text pointer position
            m_pCurrFrag = PreviousSentence.pSentenceFrag;
            m_pNextChar = PreviousSentence.pSentenceStart;
            m_pEndChar  = m_pCurrFrag->pTextStart + m_pCurrFrag->ulTextLen;

            hr = GetNextSentence( ppSentItemEnum );
            if( hr == S_OK ) 
            {
                //--- Update Sentence Pointer List
                hr = m_SentenceStack.Push( PreviousSentence );
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
} /* CStdSentEnum::Previous */

/*****************************************************************************
* SkipWhiteSpaceAndTags *
*-----------------------*
*   Skips m_pNextChar ahead to the next non-whitespace character (skipping
*   ahead in the frag list, if necessary) or sets it to NULL if it hits the 
*   end of the frag list text...
********************************************************************* AH ****/
HRESULT CStdSentEnum::SkipWhiteSpaceAndTags( const WCHAR*& pStartChar, const WCHAR*& pEndChar, 
                                             const SPVTEXTFRAG*& pCurrFrag, CSentItemMemory& MemoryManager, 
                                             BOOL fAddToItemList, CItemList* pItemList )
{
    SPDBG_ASSERT( pStartChar <= pEndChar );
    HRESULT hr = S_OK;

    while ( pStartChar &&
            ( IsSpace( *pStartChar ) ||
              pStartChar == pEndChar ) )
    {
        //--- Skip whitespace
        while ( pStartChar < pEndChar &&
                IsSpace( *pStartChar ) ) 
        {
            ++pStartChar;
        }
        //--- Skip to next spoken frag, if necessary
        if ( pStartChar == pEndChar )
        {
            pCurrFrag = pCurrFrag->pNext;
            while ( pCurrFrag &&
                    pCurrFrag->State.eAction != SPVA_Speak &&
                    pCurrFrag->State.eAction != SPVA_SpellOut )
            {
                pStartChar = (WCHAR*) pCurrFrag->pTextStart;
                pEndChar   = (WCHAR*) pStartChar + pCurrFrag->ulTextLen;
                //--- Add non-spoken fragments, if fAddToItemList is true.
                if ( fAddToItemList )
                {
                    //-- Check for names lexicon XML tag...
                    if( !m_fNameItem                && 
                        m_pCurrFrag->ulTextLen == 6 &&
                        !_wcsnicmp( L"<NAME>", m_pCurrFrag->pTextStart, m_pCurrFrag->ulTextLen ) )
                    {
                        m_fNameItem = true;
                    }				
                    else if( m_fNameItem                 &&
                             m_pCurrFrag->ulTextLen == 7 &&
                             !_wcsnicmp( L"</NAME>", m_pCurrFrag->pTextStart, m_pCurrFrag->ulTextLen ) )
                    {
                        m_fNameItem = false;
                    }

                    CSentItem Item;
                    Item.pItemSrcText    = pCurrFrag->pTextStart;
                    Item.ulItemSrcLen    = pCurrFrag->ulTextLen;
                    Item.ulItemSrcOffset = pCurrFrag->ulTextSrcOffset;
                    Item.ulNumWords      = 1;
                    Item.Words           = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( Item.Words, sizeof(TTSWord) );
                        Item.Words[0].pXmlState         = &pCurrFrag->State;
                        Item.Words[0].eWordPartOfSpeech = MS_Unknown;
                        Item.eItemPartOfSpeech          = MS_Unknown;
                        Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            Item.pItemInfo->Type = eWORDLIST_IS_VALID;
                            pItemList->AddTail( Item );
                        }
                    }
                }
                pCurrFrag = pCurrFrag->pNext;
            }
            if ( !pCurrFrag )
            {
                pStartChar = NULL;
                pEndChar   = NULL;
            }
            else
            {
                pStartChar  = (WCHAR*) pCurrFrag->pTextStart;
                pEndChar    = (WCHAR*) pStartChar + pCurrFrag->ulTextLen;
            }
        }
    }
    return hr;
} /* SkipWhiteSpaceAndTags */

/*****************************************************************************
* FindTokenEnd *
*--------------*
*   Returns the position of the first whitespace character after pStartChar,
*   or pEndChar, or the character after SP_MAX_WORD_LENGTH, whichever comes first.
********************************************************************* AH ****/
const WCHAR* CStdSentEnum::FindTokenEnd( const WCHAR* pStartChar, const WCHAR* pEndChar )
{
    SPDBG_ASSERT( pStartChar < pEndChar );
    ULONG ulNumChars = 1;
    const WCHAR *pPos = pStartChar;

    while ( pPos              &&
            pPos < pEndChar   &&
            !IsSpace( *pPos ) &&
            ulNumChars < SP_MAX_WORD_LENGTH )
    {
        pPos++;
        ulNumChars++;
    }

    return pPos;
} /* FindTokenEnd */

/*****************************************************************************
* CStdSentEnum::AddNextSentItem *
*-------------------------------*
*   Locates the next sentence item in the stream and adds it to the list.
*   Returns true if the last item added is the end of the sentence.  
********************************************************************* AH ****/
HRESULT CStdSentEnum::AddNextSentItem( CItemList& ItemList, CSentItemMemory& MemoryManager, BOOL* pfIsEOS )
{
    SPDBG_ASSERT( m_pNextChar && pfIsEOS );
    HRESULT hr = S_OK;
    BOOL fHitPauseItem = false;
    CSentItem Item;
    ULONG ulTrailItems = 0;
    TTSItemType ItemType = eUNMATCHED;
    *pfIsEOS = false;

    //--- Skip initial whitespace characters and XML markup (by skipping ahead in the frag list).
    hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &ItemList );

    //--- This will happen when we hit the end of the frag list
    if ( !m_pNextChar )
    {
        return S_OK;
    }

    //--- Find end of the next token (next whitespace character, hyphen, or m_pEndChar).
    m_pEndOfCurrToken = FindTokenEnd( m_pNextChar, m_pEndChar );

    //--- Get Primary Insert Position
    SPLISTPOS ItemPos = ItemList.AddTail( Item );

    //--- Try looking up this token in the User Lexicon...
    WCHAR Temp = *( (WCHAR*) m_pEndOfCurrToken );
    *( (WCHAR*) m_pEndOfCurrToken ) = 0;
    SPWORDPRONUNCIATIONLIST SPList;
    ZeroMemory( &SPList, sizeof( SPWORDPRONUNCIATIONLIST ) );

    hr = m_cpAggregateLexicon->GetPronunciations( m_pNextChar, 1033, eLEXTYPE_USER, &SPList );
    if( SPList.pvBuffer )
    {
        ::CoTaskMemFree( SPList.pvBuffer );
    }
    
    *( (WCHAR*) m_pEndOfCurrToken ) = Temp;

    if ( SUCCEEDED( hr ) )
    {
        Item.eItemPartOfSpeech = MS_Unknown;
        Item.pItemSrcText      = m_pNextChar;
        Item.ulItemSrcLen      = (ULONG) ( m_pEndOfCurrToken - m_pNextChar );
        Item.ulItemSrcOffset   = m_pCurrFrag->ulTextSrcOffset +
                                 (ULONG)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords        = 1;
        Item.Words              = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState         = &m_pCurrFrag->State;
            Item.Words[0].pWordText         = m_pNextChar;
            Item.Words[0].ulWordLen         = Item.ulItemSrcLen;
            Item.Words[0].pLemma            = Item.Words[0].pWordText;
            Item.Words[0].ulLemmaLen        = Item.Words[0].ulWordLen;
            Item.Words[0].eWordPartOfSpeech = MS_Unknown;
            Item.eItemPartOfSpeech          = MS_Unknown;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo*), &hr );
            if ( SUCCEEDED( hr ) )
            {
                Item.pItemInfo->Type = eALPHA_WORD;
                ItemList.SetAt( ItemPos, Item );
            }
        }
        m_pNextChar = m_pEndOfCurrToken;
    }
    //--- Not in the user lex - itemize, normalize, etc.
    else if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = S_OK;

        //--- convert text from Unicode to Ascii
        hr = DoUnicodeToAsciiMap( m_pNextChar, (ULONG)( m_pEndOfCurrToken - m_pNextChar ), (WCHAR*)m_pNextChar );

        if ( SUCCEEDED( hr ) )
        {
            //--- Find end of the next token (next whitespace character, hyphen, or m_pEndChar) 
            //---   AGAIN, since the mapping may have introduced new whitespace characters...
            m_pEndOfCurrToken = FindTokenEnd( m_pNextChar, m_pEndChar );

            //--- Insert lead items (group beginnings, quotation marks)
            while ( m_pNextChar < m_pEndOfCurrToken &&
                    ( ( ItemType = IsGroupBeginning( *m_pNextChar ) )    != eUNMATCHED ||
                      ( ItemType = IsQuotationMark( *m_pNextChar ) )     != eUNMATCHED ) )
            {
                CSentItem LeadItem;
                LeadItem.pItemSrcText       = m_pNextChar;
                LeadItem.ulItemSrcLen       = 1;
                LeadItem.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                              (ULONG)(( m_pNextChar - m_pCurrFrag->pTextStart ));
                LeadItem.ulNumWords         = 1;
                LeadItem.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( LeadItem.Words, sizeof(TTSWord) );
                    LeadItem.Words[0].pXmlState         = &m_pCurrFrag->State;
                    LeadItem.Words[0].eWordPartOfSpeech = ConvertItemTypeToPartOfSp( ItemType );
                    LeadItem.eItemPartOfSpeech          = ConvertItemTypeToPartOfSp( ItemType );
                    LeadItem.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        LeadItem.pItemInfo->Type = ItemType;
                        if ( m_dwSpeakFlags & SPF_NLP_SPEAK_PUNC ||
                             m_pCurrFrag->State.eAction == SPVA_SpellOut )
                        {
                            CWordList TempWordList;
                            ExpandPunctuation( TempWordList, *m_pNextChar );
                            hr = SetWordList( LeadItem, TempWordList, MemoryManager );
                            LeadItem.pItemInfo->Type = eUNMATCHED;
                        }
                        ItemList.InsertBefore( ItemPos, LeadItem );
                        m_pNextChar++;
                    }
                }
                ItemType = eUNMATCHED;
            }

            //--- Insert trail items (group endings, quotation marks, misc. punctuation, EOS Items)
            m_pEndOfCurrItem = m_pEndOfCurrToken;
            BOOL fAddTrailItem = true;
            BOOL fAbbreviation = false;
            while ( (m_pEndOfCurrItem - 1) >= m_pNextChar &&
                    fAddTrailItem )
            {
                fAddTrailItem = false;
                fAbbreviation = false;

                //--- Check group endings, quotation marks, misc. punctuation.
                if ( ( ItemType = IsGroupEnding( *(m_pEndOfCurrItem - 1) ) )       != eUNMATCHED ||
                     ( ItemType = IsQuotationMark( *(m_pEndOfCurrItem - 1) ) )     != eUNMATCHED ||
                     ( ItemType = IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) )   != eUNMATCHED )
                {
                    fAddTrailItem = true;
                    if ( ItemType == eCOMMA ||
                         ItemType == eCOLON ||
                         ItemType == eSEMICOLON )
                    {
                        fHitPauseItem = true;
                    }
                }
                //--- Check EOS Items, except periods preceded by alpha characters
                else if ( ( ItemType = IsEOSItem( *(m_pEndOfCurrItem - 1) ) ) != eUNMATCHED &&
                          ! ( ItemType == ePERIOD                     &&
                              ( m_pEndOfCurrItem - 2 >= m_pNextChar ) &&
                              ( iswalpha( *(m_pEndOfCurrItem - 2) ) ) ) )
                {
                    //--- Check for ellipses
                    if ( ItemType == ePERIOD )
                    {
                        if ( m_pEndOfCurrItem == m_pEndOfCurrToken                              &&
                             ( m_pEndOfCurrItem - 2 >= m_pNextChar )                            &&
                             ( ( ItemType = IsEOSItem( *(m_pEndOfCurrItem - 2) ) ) == ePERIOD ) &&
                             ( m_pEndOfCurrItem - 3 == m_pNextChar )                            &&
                             ( ( ItemType = IsEOSItem( *(m_pEndOfCurrItem - 3) ) ) == ePERIOD ) )
                        {
                            fAddTrailItem = true;
                            ItemType      = eELLIPSIS;
                        }
                        else
                        {
                            ItemType      = ePERIOD;
                            fAddTrailItem = true;
                            *pfIsEOS      = true;
                        }
                    }
                    else
                    {
                        fAddTrailItem   = true;
                        *pfIsEOS        = true;
                    }
                }
                //--- Period preceded by alpha character - determine whether it is EOS.
                else if ( ItemType == ePERIOD )
                {
                    //--- Is it an Initialism ( e.g. "e.g." )?  If so, only EOS if the next
                    //---   word is in the common first words list...
                    hr = IsInitialism( ItemList, ItemPos, MemoryManager, pfIsEOS );
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( *pfIsEOS )
                        {
                            //--- Did we see a pause item earlier?  In that case, we should NOT listen to this 
                            //--- IsEOS decision from IsInitialism...
                            if ( fHitPauseItem )
                            {
                                *pfIsEOS = false;
                            }
                            else
                            {
                                fAddTrailItem = true;
                                fAbbreviation = true;
                            }
                        }
                    }
                    else if ( hr == E_INVALIDARG )
                    {
                        const WCHAR temp = (WCHAR) *( m_pEndOfCurrItem - 1 );
                        *( (WCHAR*) ( m_pEndOfCurrItem - 1 ) ) = 0;

                        const AbbrevRecord* pAbbrevRecord =
                            (AbbrevRecord*) bsearch( (void*) m_pNextChar, (void*) g_AbbreviationTable,
                                                     sp_countof( g_AbbreviationTable ), sizeof( AbbrevRecord ),
                                                     CompareStringAndAbbrevRecord );

                        *( (WCHAR*) ( m_pEndOfCurrItem - 1 ) ) = temp;

                        if ( pAbbrevRecord )
                        {
                            //--- Matched an abbreviation
                            if ( pAbbrevRecord->iSentBreakDisambig < 0 )
                            {
                                //--- Abbreviation will never end a sentence - just insert into ItemList
                                *pfIsEOS        = false;
                                hr              = S_OK;

                                Item.pItemSrcText       = m_pNextChar;
                                Item.ulItemSrcLen       = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                                Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                                          (ULONG)( m_pNextChar - m_pCurrFrag->pTextStart );
                                Item.ulNumWords         = 1;
                                Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof( TTSWord ), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    ZeroMemory( Item.Words, sizeof( TTSWord ) );
                                    Item.Words[0].pXmlState  = &m_pCurrFrag->State;
                                    Item.Words[0].pWordText  = Item.pItemSrcText;
                                    Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
                                    Item.Words[0].pLemma     = Item.pItemSrcText;
                                    Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
                                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
                                    if ( SUCCEEDED( hr ) )
                                    {
                                        if ( NeedsToBeNormalized( pAbbrevRecord ) )
                                        {
                                            Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                                        }
                                        else
                                        {
                                            Item.pItemInfo->Type = eABBREVIATION;
                                        }
                                        ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbrevRecord;
                                        ItemList.SetAt( ItemPos, Item );
                                    }
                                }
                            }
                            else
                            {
                                //--- Need to do some disambiguation to determine whether,
                                //---   a) this is indeed an abbreviation (e.g. "Ed.")
                                //---   b) the period doubles as EOS
                                hr = ( this->*g_SentBreakDisambigTable[pAbbrevRecord->iSentBreakDisambig] ) 
                                                ( pAbbrevRecord, ItemList, ItemPos, MemoryManager, pfIsEOS );
                                if ( SUCCEEDED( hr ) )
                                {
                                    if ( *pfIsEOS )
                                    {
                                        if ( fHitPauseItem )
                                        {
                                            *pfIsEOS = false;
                                        }
                                        else
                                        {
                                            fAddTrailItem = true;
                                            fAbbreviation = true;
                                        }
                                    }
                                }
                            }
                        }

                        if ( hr == E_INVALIDARG )
                        {
                            //--- Just check for periods internal to the item - this catches stuff like
                            //---   10:30p.m.
                            for ( const WCHAR* pIterator = m_pNextChar; pIterator < m_pEndOfCurrItem - 1; pIterator++ )
                            {
                                if ( *pIterator == L'.' )
                                {
                                    *pfIsEOS = false;
                                    break;
                                }
                            }
                            //--- If all previous checks have failed, it is EOS.
                            if ( pIterator == ( m_pEndOfCurrItem - 1 ) &&
                                 !fHitPauseItem )
                            {
                                hr              = S_OK;
                                fAddTrailItem   = true;
                                *pfIsEOS        = true;
                            }
                            else if ( hr == E_INVALIDARG )
                            {
                                hr = S_OK;
                            }
                        }
                    }
                }

                //--- Add trail item.
                if ( fAddTrailItem )
                {
                    ulTrailItems++;
                    CSentItem TrailItem;
                    if ( ItemType == eELLIPSIS )
                    {
                        TrailItem.pItemSrcText      = m_pEndOfCurrItem - 3;
                        TrailItem.ulItemSrcLen      = 3;
                        TrailItem.ulItemSrcOffset   = m_pCurrFrag->ulTextSrcOffset +
                                                      (ULONG)( m_pEndOfCurrItem - m_pCurrFrag->pTextStart - 3 );
                    }
                    else
                    {
                        TrailItem.pItemSrcText       = m_pEndOfCurrItem - 1;
                        TrailItem.ulItemSrcLen       = 1;
                        TrailItem.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                                       (ULONG)( m_pEndOfCurrItem - m_pCurrFrag->pTextStart - 1 );
                    }
                    TrailItem.ulNumWords         = 1;
                    TrailItem.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( TrailItem.Words, sizeof(TTSWord) );
                        TrailItem.Words[0].pXmlState         = &m_pCurrFrag->State;
                        TrailItem.Words[0].eWordPartOfSpeech = ConvertItemTypeToPartOfSp( ItemType );
                        TrailItem.eItemPartOfSpeech          = ConvertItemTypeToPartOfSp( ItemType );
                        TrailItem.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            TrailItem.pItemInfo->Type = ItemType;
                            if ( m_dwSpeakFlags & SPF_NLP_SPEAK_PUNC ||
                                 ( m_pCurrFrag->State.eAction == SPVA_SpellOut &&
                                   !fAbbreviation ) )
                            {
                                CWordList TempWordList;
                                ExpandPunctuation( TempWordList, *(m_pEndOfCurrItem - 1) );
                                hr = SetWordList( TrailItem, TempWordList, MemoryManager );
                                TrailItem.pItemInfo->Type = eUNMATCHED;
                            }
                            ItemList.InsertAfter( ItemPos, TrailItem );
                            if ( !fAbbreviation )
                            {
                                if ( ItemType == eELLIPSIS )
                                {
                                    m_pEndOfCurrItem -= 3;
                                    ulTrailItems = 3;
                                }
                                else
                                {
                                    m_pEndOfCurrItem--;
                                }
                            }
                        }
                    }
                    ItemType = eUNMATCHED;
                    if ( fAbbreviation )
                    {
                        break;
                    }
                }
            }

            //--- Do Main Item Insertion
            if ( SUCCEEDED( hr ) &&
                 m_pNextChar == m_pEndOfCurrItem )
            {
                ItemList.RemoveAt( ItemPos );
            }
            else if ( SUCCEEDED( hr ) )
            {
                hr = Normalize( ItemList, ItemPos, MemoryManager );
            }

            if( m_fNameItem )
            {
                wcscpy( ItemList.GetAt( ItemPos ).CustomLtsToken, L"Names" );
            }

            //--- Advance m_pNextChar to m_pEndOfCurrItem + once for each trail item matched.
            if ( SUCCEEDED( hr ) )
            {
                if ( !fAbbreviation &&
                     m_pEndOfCurrItem + ulTrailItems != m_pEndOfCurrToken )
                {
                    //--- Multi-token item matched in Normalize()... Remove all previously matched trail items,
                    //--- as they were matched as part of the larger item...
                    m_pNextChar = m_pEndOfCurrItem;
                    Item = ItemList.GetNext( ItemPos );
                    while ( ItemPos )
                    {
                        SPLISTPOS RemovePos = ItemPos;
                        Item = ItemList.GetNext( ItemPos );
                        ItemList.RemoveAt( RemovePos );
                    }                 
                }
                else
                {
                    m_pNextChar = m_pEndOfCurrToken;
                }
            }
        }
    }

    return hr;
} /* CStdSentEnum::AddNextSentItem */

/*****************************************************************************
* CStdSentEnum::GetNextSentence *
*-------------------------------*
*   This method is used to create a sentence item enumerator and populate it
*   with items. If the SPF_NLP_PASSTHROUGH flag is set, each item is the block
*   of text between XML states. If the SPF_NLP_PASSTHROUGH flag is not set, each
*   item is an individual word that is looked up in the current lexicon(s).
********************************************************************* EDC ***/
HRESULT CStdSentEnum::GetNextSentence( IEnumSENTITEM** ppItemEnum )
{
    HRESULT hr = S_OK;
    ULONG ulNumItems = 0;
    const SPVTEXTFRAG* pPrevFrag = m_pCurrFrag;

    //--- Is there any work to do
    if( m_pCurrFrag == NULL ) return S_FALSE;

    //--- Create sentence enum
    CComObject<CSentItemEnum> *pItemEnum;
    hr = CComObject<CSentItemEnum>::CreateInstance( &pItemEnum );

    if( SUCCEEDED( hr ) )
    {
        pItemEnum->AddRef();
        pItemEnum->_SetOwner( GetControllingUnknown() );
        *ppItemEnum = pItemEnum;
    }

    if( SUCCEEDED( hr ) )
    {
        BOOL fSentDone = false;
        BOOL fGoToNextFrag = false;
        CItemList& ItemList = pItemEnum->_GetList();
        CSentItemMemory& MemoryManager = pItemEnum->_GetMemoryManager();

        while( SUCCEEDED(hr) && m_pCurrFrag && !fSentDone && ulNumItems < 50 )
        {
            ulNumItems++;
            if( m_pCurrFrag->State.eAction == SPVA_Speak ||
                m_pCurrFrag->State.eAction == SPVA_SpellOut )
            {
                hr = AddNextSentItem( ItemList, MemoryManager, &fSentDone );

                //--- Advance fragment?
                if( SUCCEEDED( hr ) && 
                    m_pNextChar     &&
                    m_pEndChar      &&
                    m_pNextChar >= m_pEndChar )
                {
                    fGoToNextFrag = true;
                }
            }
            else
            {
                //-- Check for lexicon
                if( !m_fNameItem                && 
                    m_pCurrFrag->ulTextLen == 6 &&
                    !_wcsnicmp( L"<NAME>", m_pCurrFrag->pTextStart, m_pCurrFrag->ulTextLen ) )
                {
                    m_fNameItem = true;
                }				
                else if( m_fNameItem                 && 
                         m_pCurrFrag->ulTextLen == 7 &&
                         !_wcsnicmp( L"</NAME>", m_pCurrFrag->pTextStart, m_pCurrFrag->ulTextLen ) )
                {
                    m_fNameItem = false;
                }

                //--- Add non spoken fragments
                CSentItem Item;
                Item.pItemSrcText    = m_pCurrFrag->pTextStart;
                Item.ulItemSrcLen    = m_pCurrFrag->ulTextLen;
                Item.ulItemSrcOffset = m_pCurrFrag->ulTextSrcOffset;
                Item.ulNumWords      = 1;
                Item.Words           = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( Item.Words, sizeof(TTSWord) );
                    Item.Words[0].pXmlState         = &m_pCurrFrag->State;
                    Item.Words[0].eWordPartOfSpeech = MS_Unknown;
                    Item.eItemPartOfSpeech          = MS_Unknown;
                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo->Type = eWORDLIST_IS_VALID;
                        ItemList.AddTail( Item );
                    }
                }
                fGoToNextFrag = true;
            }

            if( SUCCEEDED( hr ) && 
                fGoToNextFrag )
            {
                fGoToNextFrag = false;
                pPrevFrag = m_pCurrFrag;
                m_pCurrFrag = m_pCurrFrag->pNext;
                if( m_pCurrFrag )
                {
                    m_pNextChar = m_pCurrFrag->pTextStart;
                    m_pEndChar  = m_pNextChar + m_pCurrFrag->ulTextLen;
                }
                else
                {
                    m_pNextChar = NULL;
                    m_pEndChar  = NULL;
                }
            }
        } // end while

        //--- If no period has been added, add one now - this will happen if the text 
        //--- is ONLY XML markup...
        if ( SUCCEEDED(hr) && !fSentDone )
        {
            CSentItem EOSItem;
            EOSItem.pItemSrcText    = g_period.pStr;
            EOSItem.ulItemSrcLen    = g_period.Len;
            EOSItem.ulItemSrcOffset = pPrevFrag->ulTextSrcOffset + pPrevFrag->ulTextLen;
            EOSItem.ulNumWords      = 1;
            EOSItem.Words           = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( EOSItem.Words, sizeof(TTSWord) );
                EOSItem.Words[0].pXmlState          = &g_DefaultXMLState;
                EOSItem.Words[0].eWordPartOfSpeech  = MS_EOSItem;
                EOSItem.eItemPartOfSpeech           = MS_EOSItem;
                EOSItem.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    EOSItem.pItemInfo->Type = ePERIOD;
                    ItemList.AddTail( EOSItem );
                }
            }
        }

        //--- Output debugging information, if sentence breaks are desired
        TTSDBG_LOGITEMLIST( pItemEnum->_GetList(), STREAM_SENTENCEBREAKS );

        if( SUCCEEDED( hr ) )
        {
            hr = DetermineProns( pItemEnum->_GetList(), pItemEnum->_GetMemoryManager() );
        }

        pItemEnum->Reset();

        //--- Output debugging information, if POS or Pronunciations are desired
        TTSDBG_LOGITEMLIST( pItemEnum->_GetList(), STREAM_LEXLOOKUP );

    }
    return hr;
} /* CStdSentEnum::GetNextSentence */

/*****************************************************************************
* CStdSentEnum::Reset *
*---------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CStdSentEnum::Reset( void )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::Reset" );
    HRESULT hr = S_OK;
    m_pCurrFrag = m_pTextFragList;
    m_pNextChar = m_pCurrFrag->pTextStart;
    m_pEndChar  = m_pNextChar + m_pCurrFrag->ulTextLen;
    m_SentenceStack.Reset();
    m_fNameItem = false;
    return hr;
} /* CStdSentEnum::Reset */

/*****************************************************************************
* CStdSentEnum::InitAggregateLexicon *
*------------------------------------*
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::InitAggregateLexicon( void )
{
    return m_cpAggregateLexicon.CoCreateInstance(CLSID_SpLexicon);
}

/*****************************************************************************
* CStdSentEnum::AddLexiconToAggregate *
*-------------------------------------*
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::AddLexiconToAggregate( ISpLexicon *pAddLexicon, DWORD dwFlags )
{
    return m_cpAggregateLexicon->AddLexicon( pAddLexicon, dwFlags );
}

/*****************************************************************************
* CStdSentEnum::InitMorphLexicon *
*--------------------------------*
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::InitMorphLexicon( void )
{
    HRESULT hr = S_OK;
    
    m_pMorphLexicon = new CSMorph( m_cpAggregateLexicon, &hr );

    return hr;
}

void CStdSentEnum::fNamesLTS( bool fHaveNamesLTS )
{
    m_fHaveNamesLTS = fHaveNamesLTS;
}

//
//=== CSentItemEnum =========================================================
//

/*****************************************************************************
* CSentItemEnum::Next *
*---------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CSentItemEnum::
    Next( TTSSentItem *pItemEnum )
{
    SPDBG_FUNC( "CSentItemEnum::Next" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SPIsBadWritePtr( pItemEnum, sizeof( TTSSentItem ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if ( m_ListPos )
        {
            *pItemEnum = m_ItemList.GetNext( m_ListPos );
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
} /* CSentItemEnum::Next */

/*****************************************************************************
* CSentItemEnum::Reset *
*----------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CSentItemEnum::Reset( void )
{
    SPDBG_FUNC( "CSentItemEnum::Reset" );
    HRESULT hr = S_OK;
    m_ListPos = m_ItemList.GetHeadPosition();
    return hr;
} /* CSentItemEnum::Reset */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\stdsentenum.h ===
/******************************************************************************
* StdSentEnum.h *
*---------------*
*  This is the header file for the CStdSentEnum implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef StdSentEnum_h
#define StdSentEnum_h

//--- Additional includes
#include "stdafx.h"
#include "ms_entropicengine.h"
#include "resource.h"
#include "SentItemMemory.h"
#include "morph.h"
#include "TTSPropertiesDialog.h"

//=== Constants ====================================================

//--- Vowel WCHAR values - used to disambiguate pronunciations of certain words
const WCHAR g_Vowels[] = 
{
    0x0a,   // AA
    0x0b,   // AE
    0x0c,   // AH
    0x0d,   // AO
    0x0e,   // AW
    0x0f,   // AX
    0x10,   // AY
    0x15,   // EH
    0x16,   // ER
    0x17,   // EY
    0x1b,   // IH
    0x1c,   // IY
    0x23,   // OW
    0x24,   // OY
    0x2a,   // UH
    0x2b,   // UW
};

//--- Normalization constants - see NormData.cpp
extern const char g_pFlagCharacter;
extern const unsigned char g_AnsiToAscii[256];
extern const SPLSTR g_O;
extern const SPLSTR g_negative;
extern const SPLSTR g_decimalpoint;
extern const SPLSTR g_to;
extern const SPLSTR g_a;
extern const SPLSTR g_of;
extern const SPLSTR g_percent;
extern const SPLSTR g_degree;
extern const SPLSTR g_degrees;
extern const SPLSTR g_squared;
extern const SPLSTR g_cubed;
extern const SPLSTR g_ones[10];
extern const SPLSTR g_tens[10];
extern const SPLSTR g_teens[10];
extern const SPLSTR g_onesOrdinal[10]; 
extern const SPLSTR g_tensOrdinal[10];
extern const SPLSTR g_teensOrdinal[10];
extern const SPLSTR g_quantifiers[6];
extern const SPLSTR g_quantifiersOrdinal[6];
extern const SPLSTR g_dash;
extern WCHAR g_Euro[2];

struct CurrencySign
{
    SPLSTR Sign;
    SPLSTR MainUnit;
    SPLSTR SecondaryUnit;
};

struct StateStruct
{
    SPLSTR Abbreviation;
    SPLSTR FullName;
};

extern const StateStruct g_StateAbbreviations[63];
extern const CurrencySign g_CurrencySigns[14];
extern const SPLSTR g_SingularPrimaryCurrencySigns[14];
extern const SPLSTR g_SingularSecondaryCurrencySigns[14];
extern const WCHAR g_DateDelimiters[3];
extern const SPLSTR g_months[12];
extern const SPLSTR g_monthAbbreviations[13];
extern const SPLSTR g_days[7];
extern const SPLSTR g_dayAbbreviations[10];
extern const SPLSTR g_Area;
extern const SPLSTR g_Country;
extern const SPLSTR g_Code;
extern const SPLSTR g_Half;
extern const SPLSTR g_Tenths;
extern const SPLSTR g_Sixteenths;
extern const SPLSTR g_Hundredths;
extern const SPLSTR g_Over;
extern const SPLSTR g_PluralDenominators[10];
extern const SPLSTR g_A;
extern const SPLSTR g_M;
extern const SPLSTR g_P;
extern const SPLSTR g_OClock;
extern const SPLSTR g_hundred;
extern const SPLSTR g_hour;
extern const SPLSTR g_hours;
extern const SPLSTR g_minute;
extern const SPLSTR g_minutes;
extern const SPLSTR g_second;
extern const SPLSTR g_seconds;
extern const SPLSTR g_ANSICharacterProns[256];
extern const SPVSTATE g_DefaultXMLState;
extern const SPLSTR g_And;
extern const SPLSTR g_comma;
extern const SPLSTR g_period;
extern const SPLSTR g_periodString;
extern const SPLSTR g_slash;
extern const SPLSTR g_Decades[];
extern const SPLSTR g_Zeroes;
extern const SPLSTR g_Hundreds;

#define DAYMAX 31
#define DAYMIN 1
#define MONTHMAX 12
#define MONTHMIN 1
#define YEARMAX 9999
#define YEARMIN 0
#define HOURMIN 1
#define HOURMAX 23
#define MINUTEMIN 0
#define MINUTEMAX 59
#define SECONDMIN 0
#define SECONDMAX 59

//--- POS Tagger Constants - see MiscData.cpp

typedef enum TEMPLATETYPE
{
    PREV1T,
    NEXT1T,
    PREV2T,
    NEXT2T,
    PREV1OR2T,
    NEXT1OR2T,
    PREV1OR2OR3T,
    NEXT1OR2OR3T,
    PREV1TNEXT1T,
    PREV1TNEXT2T,
    PREV2TNEXT1T,
    NOTCAP,
    CAP,
    PREVNOTCAP,
    PREVCAP,
    PREV1W,
    NEXT1W,
    PREV2W,
    NEXT2W,
    PREV1OR2W,
    NEXT1OR2W,
    CURRWPREV1W,
    CURRWNEXT1W,
    CURRWPREV1T,
    CURRWNEXT1T,
    CURRW,
    PREV1WT,
    NEXT1WT,
    CURRWPREV1WT,
    CURRWNEXT1WT
} TEMPLATETYPE;

struct BrillPatch
{
    ENGPARTOFSPEECH eCurrentPOS;
    ENGPARTOFSPEECH eConvertToPOS;
    TEMPLATETYPE   eTemplateType;
    ENGPARTOFSPEECH eTemplatePOS1;
    ENGPARTOFSPEECH eTemplatePOS2;
    const WCHAR*   pTemplateWord1;
    const WCHAR*   pTemplateWord2;
};

extern const BrillPatch g_POSTaggerPatches [62];

//=== Class, Enum, Struct and Union Declarations ===================

typedef CSPList<TTSWord,TTSWord&> CWordList;
typedef CSPList<TTSSentItem,TTSSentItem&> CItemList;

//--- Structs used for normalization

typedef enum
{
    PRECEDING,
    FOLLOWING,
    UNATTACHED
} NORM_POSITION;

struct NumberGroup
{
    BOOL    fOnes;          // "one" through "nineteen"
    BOOL    fTens;          // "twenty" through "ninety"
    BOOL    fHundreds;      // "one hundred" through "nine hundred"
    BOOL    fQuantifier;    // "thousand" through "quadrillion"
};

struct TTSIntegerItemInfo
{
    long            lNumGroups;
    NumberGroup     Groups[6];
    BOOL            fOrdinal;
    BOOL            fDigitByDigit;
    ULONG           ulNumDigits;
    //--- Normalization internal only
    long            lLeftOver;
    BOOL            fSeparators;
    const WCHAR*    pStartChar;
    const WCHAR*    pEndChar;
};

struct TTSDigitsItemInfo : TTSItemInfo
{
    const WCHAR*    pFirstDigit;
    ULONG           ulNumDigits;
};

struct TTSNumberItemInfo;

struct TTSFractionItemInfo 
{
    BOOL                    fIsStandard;
    TTSNumberItemInfo*   pNumerator;
    TTSNumberItemInfo*   pDenominator;
    //--- Normalization internal only
    const WCHAR*            pVulgar;
};

struct TTSNumberItemInfo : TTSItemInfo
{
    BOOL                    fNegative;
    TTSIntegerItemInfo*     pIntegerPart;
    TTSDigitsItemInfo*      pDecimalPart;
    TTSFractionItemInfo* pFractionalPart;
    //--- Normalization internal only
    const WCHAR*            pStartChar;
    const WCHAR*            pEndChar;
    CWordList*              pWordList;
};    

struct TTSPhoneNumberItemInfo : TTSItemInfo
{
    //--- Country code members
    TTSNumberItemInfo*  pCountryCode;
    //--- Area code members
    TTSDigitsItemInfo*  pAreaCode;
    BOOL                fIs800;
    BOOL                fOne;
    //--- Main number members
    TTSDigitsItemInfo** ppGroups;
    ULONG               ulNumGroups;
};

struct TTSZipCodeItemInfo : TTSItemInfo
{
    TTSDigitsItemInfo*  pFirstFive;
    TTSDigitsItemInfo*  pLastFour;
};

struct TTSStateAndZipCodeItemInfo : TTSItemInfo
{
    TTSZipCodeItemInfo* pZipCode;
};

struct TTSCurrencyItemInfo : TTSItemInfo
{
    TTSNumberItemInfo*  pPrimaryNumberPart;
    TTSNumberItemInfo*  pSecondaryNumberPart;
    BOOL                fQuantifier;
    long                lNumPostNumberStates;
    long                lNumPostSymbolStates;
};

struct TTSYearItemInfo : TTSItemInfo
{
    const WCHAR*    pYear;
    ULONG           ulNumDigits;
};

struct TTSRomanNumeralItemInfo : TTSItemInfo
{
    TTSItemInfo*    pNumberInfo;
};

struct TTSDecadeItemInfo : TTSItemInfo
{
    const WCHAR*    pCentury;
    ULONG           ulDecade;
};

struct TTSDateItemInfo : TTSItemInfo
{
    ULONG               ulDayIndex;
    ULONG               ulMonthIndex;
    TTSIntegerItemInfo* pDay;
    TTSYearItemInfo*    pYear;
};

typedef enum
{
    AM,
    PM,
    UNDEFINED
} TIMEABBREVIATION;

struct TTSTimeOfDayItemInfo : TTSItemInfo
{
    BOOL    fTimeAbbreviation;
    BOOL    fTwentyFourHour;
    BOOL    fMinutes;
};

struct TTSTimeItemInfo : TTSItemInfo
{
    TTSNumberItemInfo*  pHours;
    TTSNumberItemInfo*  pMinutes;
    const WCHAR*        pSeconds;
};

struct TTSHyphenatedStringInfo : TTSItemInfo
{
    TTSItemInfo* pFirstChunkInfo;
    TTSItemInfo* pSecondChunkInfo;
    const WCHAR* pFirstChunk;
    const WCHAR* pSecondChunk;
};

struct TTSSuffixItemInfo : TTSItemInfo
{
    const WCHAR* pFirstChar;
    ULONG        ulNumChars;
};

struct TTSNumberRangeItemInfo : TTSItemInfo
{
    TTSItemInfo *pFirstNumberInfo;
    TTSItemInfo *pSecondNumberInfo;
};

struct TTSTimeRangeItemInfo : TTSItemInfo
{
    TTSTimeOfDayItemInfo *pFirstTimeInfo;
    TTSTimeOfDayItemInfo *pSecondTimeInfo;
};

struct AbbrevRecord 
{
    const WCHAR*    pOrth;
    WCHAR*          pPron1;
    ENGPARTOFSPEECH POS1;
    WCHAR*          pPron2;
    ENGPARTOFSPEECH POS2;
    WCHAR*          pPron3;
    ENGPARTOFSPEECH POS3;
    int             iSentBreakDisambig;
    int             iPronDisambig;
};

struct TTSAbbreviationInfo : TTSItemInfo
{
    const AbbrevRecord*   pAbbreviation;
};

//--- Structs used for Lex Lookup

typedef enum { PRON_A = 0, PRON_B = 1 };

struct PRONUNIT
{
    ULONG           phon_Len;
    WCHAR           phon_Str[SP_MAX_PRON_LENGTH];		// Allo string
    ULONG			POScount;
    ENGPARTOFSPEECH	POScode[POS_MAX];
};

struct PRONRECORD
{
    WCHAR           orthStr[SP_MAX_WORD_LENGTH];      // Orth text
    WCHAR           lemmaStr[SP_MAX_WORD_LENGTH];     // Root word
    ULONG		    pronType;                   // Pronunciation is lex or LTS
    PRONUNIT        pronArray[2];
    ENGPARTOFSPEECH	POSchoice;
    ENGPARTOFSPEECH XMLPartOfSpeech;
    bool			hasAlt;
    ULONG			altChoice;
    BOOL            fUsePron;
    WCHAR           CustomLtsToken[SP_MAX_WORD_LENGTH];
};

//--- Miscellaneous structs and typedefs

struct SentencePointer
{
    const WCHAR *pSentenceStart;
    const SPVTEXTFRAG *pSentenceFrag;
};

//=== Function Definitions ===========================================

// Misc Number Normalization functions and helpers
int MatchCurrencySign( const WCHAR*& pStartChar, const WCHAR*& pEndChar, NORM_POSITION& ePosition );

//=== Classes

/*** CSentenceStack *************************************************
*   This class is used to maintain a stack of sentences for the Skip
*   call to utilize.
*/
class CSentenceStack
{
  public:
    /*--- Methods ---*/
    CSentenceStack() { m_StackPtr = -1; }
    int GetCount( void ) { return m_StackPtr + 1; }
    virtual SentencePointer& Pop( void ) { SPDBG_ASSERT( m_StackPtr > -1 ); return m_Stack[m_StackPtr--]; }
    virtual HRESULT Push( const SentencePointer& val ) { ++m_StackPtr; return m_Stack.SetAtGrow( m_StackPtr, val ); }
    virtual void Reset( void ) { m_StackPtr = -1; }

  protected:
    /*--- Member data ---*/
    CSPArray<SentencePointer,SentencePointer>  m_Stack;
    int                                m_StackPtr;
};

/*** CSentItem
*   This object is a helper class
*/
class CSentItem : public TTSSentItem
{
  public:
    CSentItem() { memset( this, 0, sizeof(*this) ); }
    CSentItem( TTSSentItem& Other ) { memcpy( this, &Other, sizeof( Other ) ); }
};

/*** CSentItemEnum
*   This object is designed to be used by a single thread.
*/
class ATL_NO_VTABLE CSentItemEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumSENTITEM
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSentItemEnum)
	    COM_INTERFACE_ENTRY(IEnumSENTITEM)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/
    void _SetOwner( IUnknown* pOwner ) { m_cpOwner = pOwner; }
    CItemList& _GetList( void ) { return m_ItemList; }
    CSentItemMemory& _GetMemoryManager( void ) { return m_MemoryManager; }

  /*=== Interfaces ====*/
  public:
    //--- IEnumSpSentence ----------------------------------------
	STDMETHOD(Next)( TTSSentItem *pItemEnum );
	STDMETHOD(Reset)( void );

  /*=== Member data ===*/
  private:
    CComPtr<IUnknown>   m_cpOwner;
    CItemList           m_ItemList;
    SPLISTPOS           m_ListPos;
    CSentItemMemory     m_MemoryManager;
};

/*** CStdSentEnum COM object
*/
class ATL_NO_VTABLE CStdSentEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumSpSentence
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CStdSentEnum)
	    COM_INTERFACE_ENTRY(IEnumSpSentence)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    HRESULT FinalConstruct();
    void FinalRelease();

    /*--- Non interface methods ---*/
    HRESULT InitAggregateLexicon( void );
    HRESULT AddLexiconToAggregate( ISpLexicon *pAddLexicon, DWORD dwFlags );
    HRESULT InitMorphLexicon( void );
    void    fNamesLTS( bool );

    //--- Abbreviation Sentence Breaking Disambiguation Functions
    HRESULT IsAbbreviationEOS( const AbbrevRecord* pAbbreviation, CItemList& ItemList, SPLISTPOS ItemPos, 
                               CSentItemMemory& MemoryManager, BOOL* pfIsEOS );
    HRESULT IfEOSNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList& ItemList, SPLISTPOS ItemPos,
                                  CSentItemMemory& MemoryManager, BOOL* pfIsEOS );
    HRESULT IfEOSAndLowercaseNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList& ItemList, SPLISTPOS ItemPos,
                                              CSentItemMemory& MemoryManager, BOOL* pfIsEOS );

    //--- Abbreviation Pronunciation Disambiguation Functions
    HRESULT SingleOrPluralAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                        CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT DoctorDriveAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                     CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT AbbreviationFollowedByDigit( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                         CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT AllCapsAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                 CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT CapitalizedAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                     CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT SECAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                             CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT DegreeAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                CItemList& ItemList, SPLISTPOS ListPos );
	HRESULT AbbreviationModifier( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT ADisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                       CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT PolishDisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                            CItemList& ItemList, SPLISTPOS ListPos );

    //--- Word Pronunciation Disambiguation Functions
    HRESULT MeasurementDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                 SPLISTPOS ListPos, CSentItemMemory& MemoryManager );
    HRESULT TheDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                         SPLISTPOS ListPos, CSentItemMemory& MemoryManager );
    HRESULT ReadDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                          SPLISTPOS ListPos, CSentItemMemory& MemoryManager );


  private:
    //--- Pronunciation Table init helper
    HRESULT InitPron( WCHAR** OriginalPron );

    //--- Sentence breaking helpers ---//
    HRESULT GetNextSentence( IEnumSENTITEM** pItemEnum );
    HRESULT AddNextSentItem( CItemList& ItemList, CSentItemMemory& MemoryManager, BOOL* pfIsEOS );
    HRESULT SkipWhiteSpaceAndTags( const WCHAR*& pStartChar, const WCHAR*& pEndChar, 
                                   const SPVTEXTFRAG*& pCurrFrag, CSentItemMemory& pMemoryManager, 
                                   BOOL fAddToItemList = false, CItemList* pItemList = NULL );
    const WCHAR* FindTokenEnd( const WCHAR* pStartChar, const WCHAR* pEndChar );

    //--- Lexicon and POS helpers ---//
    HRESULT DetermineProns( CItemList& ItemList, CSentItemMemory& MemoryManager );
    HRESULT Pronounce( PRONRECORD *pPron );

    //--- Normalization helpers ---//
    HRESULT Normalize( CItemList& ItemList, SPLISTPOS ListPos, CSentItemMemory& MemoryManager );
    HRESULT MatchCategory( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT ExpandCategory( TTSItemInfo*& pItemNormInfo, CItemList& ItemList, SPLISTPOS ListPos, 
                            CSentItemMemory& MemoryManager );
    HRESULT DoUnicodeToAsciiMap( const WCHAR *pUnicodeString, ULONG ulUnicodeStringLength,
                                 WCHAR *ppConvertedString );
    HRESULT IsAlphaWord( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo,
                         CSentItemMemory& MemoryManager );
    HRESULT IsInitialism( CItemList& ItemList, SPLISTPOS ItemPos, CSentItemMemory& MemoryManager,
                          BOOL* pfIsEOS );
    //--- Various Number Related Normalization helpers ---//
    HRESULT IsNumberCategory( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT IsNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager,
                      BOOL fMultiItem = true );
    HRESULT IsInteger( const WCHAR* pStartChar, TTSIntegerItemInfo*& pIntegerInfo, 
                       CSentItemMemory& MemoryManager );
    HRESULT IsDigitString( const WCHAR* pStartChar, TTSDigitsItemInfo*& pDigitsInfo,
                           CSentItemMemory& MemoryManager );
    HRESULT ExpandNumber( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandPercent( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandDegrees( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandSquare( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandCube( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    void ExpandInteger( TTSIntegerItemInfo* pItemInfo, const WCHAR* Context, CWordList &WordList );
    void ExpandDigit( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandTwoDigits( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandThreeDigits( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandDigitOrdinal( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandTwoOrdinal( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandThreeOrdinal( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandDigits( TTSDigitsItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsFraction( const WCHAR* pStartChar, TTSFractionItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager );
    HRESULT ExpandFraction( TTSFractionItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsRomanNumeral( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT IsPhoneNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT IsZipCode( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT ExpandZipCode( TTSZipCodeItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsCurrency( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                        CWordList& WordList );
    HRESULT IsNumberRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager );
    HRESULT ExpandNumberRange( TTSNumberRangeItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsCurrencyRange( TTSItemInfo*& pItemInfo, CSentItemMemory& MemoryManager, CWordList& WordList );

    //--- Date Related Normalization helpers ---//
    HRESULT IsNumericCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                  CSentItemMemory& MemoryManager );
    HRESULT IsMonthStringCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                      CSentItemMemory& MemoryManager );
    HRESULT IsLongFormDate_DMDY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT IsLongFormDate_DDMY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT ExpandDate( TTSDateItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandYear( TTSYearItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsDecade( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager );
    HRESULT ExpandDecade( TTSDecadeItemInfo* pItemInfo, CWordList& WordList );
    ULONG MatchMonthString( WCHAR*& pMonth, ULONG ulLength );
    ULONG MatchDayString( WCHAR*& pDayString, WCHAR* pEndChar );
    bool  MatchDateDelimiter( WCHAR **DateString );

    //--- Time Related Normalization helpers ---//
    HRESULT IsTimeOfDay( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList, BOOL fMultiItem = true );
    HRESULT IsTime( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT ExpandTime( TTSTimeItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsTimeRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );

    //--- SPELL tag normalization helper
    HRESULT SpellOutString( CWordList& WordList );
    void ExpandPunctuation( CWordList& WordList, WCHAR wc );

    //--- Default normalization helper
    HRESULT ExpandUnrecognizedString( CWordList& WordList, CSentItemMemory& MemoryManager );

    //--- Misc. normalization helpers
    HRESULT IsStateAndZipcode( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT IsHyphenatedString( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo, 
                                CSentItemMemory& MemoryManager );
    HRESULT ExpandHyphenatedString( TTSHyphenatedStringInfo* pItemInfo, CWordList& WordList );
    HRESULT IsSuffix( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo,
                      CSentItemMemory& MemoryManager );
    HRESULT ExpandSuffix( TTSSuffixItemInfo* pItemInfo, CWordList& WordList );
    bool Zeroes( const WCHAR* );
    bool ThreeZeroes( const WCHAR* );
    bool IsPunctuation(const TTSSentItem *Item);

  /*=== Interfaces ====*/
  public:
    //--- IEnumSpSentence ----------------------------------------
	STDMETHOD(SetFragList)( const SPVTEXTFRAG* pTextFragList, DWORD dwFlags );
	STDMETHOD(Next)( IEnumSENTITEM **ppSentItemEnum );
    STDMETHOD(Previous)( IEnumSENTITEM **ppSentItemEnum );
	STDMETHOD(Reset)( void );

  //=== Data members ===
  private:
    CComPtr<ISpContainerLexicon>    m_cpAggregateLexicon;
    CComPtr<ISpPhoneConverter>      m_cpPhonemeConverter;
    CSMorph*                        m_pMorphLexicon;
    DWORD                           m_dwSpeakFlags;
    const SPVTEXTFRAG*              m_pTextFragList;
    const SPVTEXTFRAG*              m_pCurrFrag;
    const WCHAR*                    m_pNextChar;
    const WCHAR*                    m_pEndChar;
    const WCHAR*                    m_pEndOfCurrToken;
    const WCHAR*                    m_pEndOfCurrItem;
    CSentenceStack                  m_SentenceStack;
    SEPARATOR_AND_DECIMAL           m_eSeparatorAndDecimal;
    SHORT_DATE_ORDER                m_eShortDateOrder;
    static CComAutoCriticalSection  m_AbbrevTableCritSec;
    bool                            m_fNameItem;
    bool                            m_fHaveNamesLTS;
};

//--- Structs and typedefs used for abbreviation stuff

typedef HRESULT (CStdSentEnum::* SentBreakDisambigFunc)(const AbbrevRecord*, CItemList& , SPLISTPOS, 
                                                        CSentItemMemory&, BOOL*);
typedef HRESULT (CStdSentEnum::* PronDisambigFunc) ( const AbbrevRecord*, PRONRECORD*, CItemList&, SPLISTPOS );
typedef HRESULT (CStdSentEnum::* PostLexLookupDisambigFunc) ( const AbbrevRecord*, CItemList&, SPLISTPOS, CSentItemMemory& );
extern AbbrevRecord g_AbbreviationTable[177];
extern const PronDisambigFunc g_PronDisambigTable[];
extern const SentBreakDisambigFunc g_SentBreakDisambigTable[];
extern AbbrevRecord g_AmbiguousWordTable[72];
extern const PronDisambigFunc g_AmbiguousWordDisambigTable[];
extern AbbrevRecord g_PostLexLookupWordTable[41];
extern const PostLexLookupDisambigFunc g_PostLexLookupDisambigTable[];
extern WCHAR *g_pOfA;
extern WCHAR *g_pOfAn;
extern BOOL g_fAbbrevTablesInitialized;
extern void CleanupAbbrevTables( void );

//--- First words table - used in sentence breaking
extern const SPLSTR g_FirstWords[163];

//
//=== Inlines
//

inline ULONG my_wcstoul( const WCHAR *pStartChar, WCHAR **ppEndChar )
{
    if ( iswdigit( *pStartChar ) )
    {
        return wcstoul( pStartChar, ppEndChar, 10 );
    }
    else
    {
        if ( ppEndChar )
        {
            *ppEndChar = (WCHAR*) pStartChar;
        }
        return 0;
    }
}

inline ENGPARTOFSPEECH ConvertItemTypeToPartOfSp( TTSItemType ItemType )
{
    switch ( ItemType )
    {
    case eOPEN_PARENTHESIS:
    case eOPEN_BRACKET:
    case eOPEN_BRACE:
        return MS_GroupBegin;

    case eCLOSE_PARENTHESIS:
    case eCLOSE_BRACKET:
    case eCLOSE_BRACE:
        return MS_GroupEnd;

    case eSINGLE_QUOTE:
    case eDOUBLE_QUOTE:
        return MS_Quotation;

    case ePERIOD:
    case eQUESTION:
    case eEXCLAMATION:
        return MS_EOSItem;

    case eCOMMA:
    case eCOLON:
    case eSEMICOLON:
    case eHYPHEN:
    case eELLIPSIS:
        return MS_MiscPunc;

    default:
        return MS_Unknown;
    }
}

inline bool MatchPhoneNumberDelimiter( const WCHAR wc )
{
    return ( wc == L' ' || wc == L'-' || wc == L'.' );
}   

inline bool NeedsToBeNormalized( const AbbrevRecord* pAbbreviation )
{
    if( !wcscmp( pAbbreviation->pOrth, L"jan" )   ||
        !wcscmp( pAbbreviation->pOrth, L"feb" )   ||
        !wcscmp( pAbbreviation->pOrth, L"mar" )   ||
        !wcscmp( pAbbreviation->pOrth, L"apr" )   ||
        !wcscmp( pAbbreviation->pOrth, L"jun" )   ||
        !wcscmp( pAbbreviation->pOrth, L"jul" )   ||
        !wcscmp( pAbbreviation->pOrth, L"aug" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sep" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sept" )  ||
        !wcscmp( pAbbreviation->pOrth, L"oct" )   ||
        !wcscmp( pAbbreviation->pOrth, L"nov" )   ||
        !wcscmp( pAbbreviation->pOrth, L"dec" )   ||
        !wcscmp( pAbbreviation->pOrth, L"mon" )   ||
        !wcscmp( pAbbreviation->pOrth, L"tue" )   ||
        !wcscmp( pAbbreviation->pOrth, L"tues" )  ||
        !wcscmp( pAbbreviation->pOrth, L"wed" )   ||
        !wcscmp( pAbbreviation->pOrth, L"thu" )   ||
        !wcscmp( pAbbreviation->pOrth, L"thur" )  ||
        !wcscmp( pAbbreviation->pOrth, L"thurs" ) ||
        !wcscmp( pAbbreviation->pOrth, L"fri" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sat" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sun" ) )
    {
        return true;
    }
    else
    {
        return false;
    }
}

inline HRESULT SetWordList( CSentItem& Item, CWordList& WordList, CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    SPLISTPOS WordListPos = WordList.GetHeadPosition();
    Item.ulNumWords = WordList.GetCount();
    Item.Words = (TTSWord*) MemoryManager.GetMemory( Item.ulNumWords * sizeof(TTSWord), &hr );
    if ( SUCCEEDED( hr ) )
    {
        ULONG ulIndex = 0;
        while ( WordListPos )
        {
            SPDBG_ASSERT( ulIndex < Item.ulNumWords );
            Item.Words[ulIndex++] = WordList.GetNext( WordListPos );
        }
    }

    return hr;
}

inline int CompareStringAndSPLSTR( const void* _String, const void* _SPLSTR )
{
    int _StringLen = wcslen( (const WCHAR*) _String );
    int _SPLSTRLen = ( (const SPLSTR*) _SPLSTR )->Len;
    if ( _StringLen < _SPLSTRLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const SPLSTR*) _SPLSTR )->pStr, _StringLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return -1;
        }
    }
    else if ( _StringLen > _SPLSTRLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const SPLSTR*) _SPLSTR )->pStr, _SPLSTRLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        return ( wcsnicmp( (const WCHAR*) _String , ( (const SPLSTR*) _SPLSTR )->pStr, _StringLen ) );
    }
}

inline int CompareStringAndStateStruct( const void* _String, const void* _StateStruct )
{
    int _StringLen = wcslen( (const WCHAR*) _String );
    int _StateStructLen = ( (const StateStruct*) _StateStruct )->Abbreviation.Len;
    if ( _StringLen < _StateStructLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const StateStruct*) _StateStruct )->Abbreviation.pStr, 
                               _StringLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return -1;
        }
    }
    else if ( _StringLen > _StateStructLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const StateStruct*) _StateStruct )->Abbreviation.pStr, 
                               _StateStructLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        return ( wcsnicmp( (const WCHAR*) _String , ( (const StateStruct*) _StateStruct )->Abbreviation.pStr, 
                           _StringLen ) );
    }
}

inline int CompareStringAndAbbrevRecord( const void* _String, const void* _AbbrevRecord )
{
    return ( _wcsicmp( (const WCHAR*) _String, ( (const AbbrevRecord*) _AbbrevRecord )->pOrth ) );
}

inline int CompareWCHARAndWCHAR( const void *pWCHAR_1, const void *pWCHAR_2 )
{
    return ( *( (WCHAR*) pWCHAR_1) - *( (WCHAR*) pWCHAR_2) );
}

inline BOOL IsSpace( WCHAR wc )
{
    return ( ( wc == 0x20 ) || ( wc == 0x9 ) || ( wc == 0xD  ) ||
             ( wc == 0xA ) || ( wc == 0x200B ) );
}

inline BOOL IsCapital( WCHAR wc )
{
    return ( ( wc >= L'A' ) && ( wc <= L'Z' ) );
}

inline TTSItemType IsGroupBeginning( WCHAR wc )
{
    if ( wc == L'(' )
    {
        return eOPEN_PARENTHESIS;
    }
    else if ( wc == L'[' )
    {
        return eOPEN_BRACKET;
    }
    else if ( wc == L'{' )
    {
        return eOPEN_BRACE;
    }
    else
    {
        return eUNMATCHED;
    }
}

inline TTSItemType IsGroupEnding( WCHAR wc )
{
    if ( wc == L')' )
    {
        return eCLOSE_PARENTHESIS;
    }
    else if ( wc == L']' )
    {
        return eCLOSE_BRACKET;
    }
    else if ( wc == L'}' )
    {
        return eCLOSE_BRACE;
    }
    else
    {
        return eUNMATCHED;
    }    
}

inline TTSItemType IsQuotationMark( WCHAR wc )
{
    if ( wc == L'\'' )
    {
        return eSINGLE_QUOTE;
    }
    else if ( wc == L'\"' )
    {
        return eDOUBLE_QUOTE;
    }
    else
    {
        return eUNMATCHED;
    }
}

inline TTSItemType IsEOSItem( WCHAR wc )
{
    if ( wc == L'.' )
    {
        return ePERIOD;
    }
    else if ( wc == L'!' )
    {
        return eEXCLAMATION;
    }
    else if ( wc == L'?' )
    {
        return eQUESTION;
    }
    else
    {
        return eUNMATCHED;
    }
}

inline TTSItemType IsMiscPunctuation( WCHAR wc )
{
    if ( wc == L',' )
    {
        return eCOMMA;
    }
    else if ( wc == L';' )
    {
        return eSEMICOLON;
    }
    else if ( wc == L':' )
    {
        return eCOLON;
    }
    else if ( wc == L'-' )
    {
        return eHYPHEN;
    }
    else
    {
        return eUNMATCHED;
    }
}

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\ttsengine.cpp ===
/*******************************************************************************
* MSE_TTSEngine.cpp *
*---------------*
*   Description:
*       This module is the main implementation file for the CMSE_TTSEngine class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include <stdio.h>
#include "TTSEngine.h"
#include "stdsentenum.h"
#ifdef USE_VOICEDATAOBJ
#include "VoiceDataObj.h"
#endif
#include "commonlx.h"
#include "perf\\ttsperf.h"


#if USE_PERF_COUNTERS
CPerfCounterManager  g_pcm;
#endif


/*****************************************************************************
* MSE_TTSEngine::FinalConstruct *
*----------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT MSE_TTSEngine::FinalConstruct()
{
    SPDBG_FUNC( "MSE_TTSEngine::FinalConstruct" );
    HRESULT hr = S_OK;

    m_pBEnd = NULL;

#if USE_PERF_COUNTERS
    if (g_pcm.Init("TTSPerf", perfcMax / 2 - 1, 100) == ERROR_SUCCESS)
    {
        m_pco.Init(&g_pcm);
    }
#endif

    return hr;
} /* MSE_TTSEngine::FinalConstruct */

/*****************************************************************************
* MSE_TTSEngine::FinalRelease *
*--------------------------*
*   Description:
*       destructor
********************************************************************* EDC ***/
void MSE_TTSEngine::FinalRelease()
{
    SPDBG_FUNC( "MSE_TTSEngine::FinalRelease" );
    if ( m_pBEnd )
    {
        delete m_pBEnd;
    }
} /* MSE_TTSEngine::FinalRelease */

/*****************************************************************************
* MSE_TTSEngine::SetObjectToken *
*-------------------------------*
*   Description:
*       This method is called during construction to give the TTS driver object 
*   access to the voice's object token for initialization purposes...
******************************************************************* AARONHAL ***/
HRESULT MSE_TTSEngine::SetObjectToken( ISpObjectToken *pToken )
{
    SPDBG_FUNC( "MSE_TTSEngine::SetObjectToken" );
    HRESULT hr = S_OK;

    //--- Call old SetObjectToken, in VoiceData
    m_cpToken = pToken;

#ifdef USE_VOICEDATAOBJ
    hr = m_VoiceDataObj.SetObjectToken( pToken );
#endif
    //--- Do old VoiceInit( ) stuff...
    if ( SUCCEEDED( hr ) )
    {
        //--- Create sentence enumerator and initialize
        CComObject<CStdSentEnum> *pSentEnum;
        hr = CComObject<CStdSentEnum>::CreateInstance( &pSentEnum );

        //--- Create aggregate lexicon
        if ( SUCCEEDED( hr ) )
        {
            hr = pSentEnum->InitAggregateLexicon();
        }

        //--- Create vendor lexicon and add to aggregate
        if ( SUCCEEDED( hr ) )
        {
            CComPtr<ISpObjectToken> cpToken;
            hr = SpGetSubTokenFromToken(pToken, L"Lex", &cpToken);

            CComPtr<ISpLexicon> cpCompressedLexicon;
            if ( SUCCEEDED( hr ) )
            {
                hr = SpCreateObjectFromToken(cpToken, &cpCompressedLexicon);
            }

            if (SUCCEEDED(hr))
            {
                hr = pSentEnum->AddLexiconToAggregate(cpCompressedLexicon, eLEXTYPE_PRIVATE1);
            }
        }

        //--- Create LTS lexicon and add to aggregate
        if ( SUCCEEDED( hr ) )
        {
            CComPtr<ISpObjectToken> cpToken;
            hr = SpGetSubTokenFromToken(pToken, L"Lts", &cpToken);

            CComPtr<ISpLexicon> cpLTSLexicon;
            if ( SUCCEEDED( hr ) )
            {
                hr = SpCreateObjectFromToken(cpToken, &cpLTSLexicon);
            }

            if ( SUCCEEDED( hr ) )
            {
                hr = pSentEnum->AddLexiconToAggregate(cpLTSLexicon, eLEXTYPE_PRIVATE2);
            }
        }
		
        //--- Create Names LTS lexicon and add to aggregate
        if ( SUCCEEDED( hr ) )
        {
            CComPtr<ISpObjectToken> cpToken;
            hr = SpGetSubTokenFromToken(pToken, L"Names", &cpToken);

            CComPtr<ISpLexicon> cpLTSLexicon;
            if ( SUCCEEDED( hr ) )
            {
                hr = SpCreateObjectFromToken(cpToken, &cpLTSLexicon);
                if ( SUCCEEDED( hr ) )
                {
                    hr = pSentEnum->AddLexiconToAggregate( cpLTSLexicon, eLEXTYPE_PRIVATE3 );
                    if ( SUCCEEDED( hr ) )
                    {
                        pSentEnum->fNamesLTS( true );
                    }
                }
            }
            else
            {
                //--- No "Names" subtoken in the registry - just behave as we did
                //    before the Names LTS code was added...
                pSentEnum->fNamesLTS( false );
                hr = S_OK;
            }
        }

        //--- Create morphology lexicon
        if ( SUCCEEDED( hr ) )
        {
            hr = pSentEnum->InitMorphLexicon();
        }

        //--- Set member sentence enumerator
        if ( SUCCEEDED( hr ) )
        {
            m_cpSentEnum = pSentEnum;
        }
    }

    //--- Do old InitDriver stuff
    if ( SUCCEEDED( hr ) )
    {
        //--------------------------
        // Get voice information
        //--------------------------
#ifdef USE_VOICEDATAOBJ
        hr = m_VoiceDataObj.GetVoiceInfo( &m_VoiceInfo );

	    if( SUCCEEDED(hr) )
	    {
		    m_SampleRate = m_VoiceInfo.SampleRate;

		    //-----------------------------
		    // Reverb is always stereo
		    //-----------------------------
		    if (m_VoiceInfo.eReverbType != REVERB_TYPE_OFF )
		    {
			    //------------------
			    // Stereo
			    //------------------
			    m_IsStereo = true;
			    m_BytesPerSample = 4;
		    }
		    else
		    {
			    //------------------
			    // MONO
			    //------------------
			    m_IsStereo = false;
			    m_BytesPerSample = 2;
		    }
#else
        {
#endif
		    //--------------------------
		    // Initialize BACKEND 
		    //--------------------------
            m_pBEnd = CBackEnd::ClassFactory();

            if ( m_pBEnd )
            {
                CSpDynamicString dstrSFontPath;

                hr = pToken->GetStringValue( L"Sfont", &dstrSFontPath );

                if ( SUCCEEDED( hr ) )
                {
                    char *pszSFontPath = NULL;
                    pszSFontPath = dstrSFontPath.CopyToChar();

                    if ( !pszSFontPath )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else if ( !m_pBEnd->LoadTable( pszSFontPath ) )
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        m_pBEnd->SetFrontEndFlag ();
                        m_pBEnd->SetGain( 2.0 );
                        ::CoTaskMemFree( pszSFontPath );
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

		    //--------------------------
		    // Initialize FRONTEND obj
		    //--------------------------
		    if( SUCCEEDED( hr ))
		    {
                EntropicPitchInfo PitchInfo;
                int BaseLine, RefLine, TopLine;
                m_pBEnd->GetSpeakerInfo( &BaseLine, &RefLine, &TopLine );
                PitchInfo.BasePitch = ( TopLine + BaseLine ) / 2;
                PitchInfo.Range     = TopLine - BaseLine;
#ifdef USE_VOICEDATAOBJ
			    hr =  m_FEObj.Init( &m_VoiceDataObj, NULL, &m_VoiceInfo, PitchInfo );
#else
			    hr =  m_FEObj.Init( NULL /*&m_VoiceDataObj*/, NULL, NULL /*&m_VoiceInfo*/, PitchInfo, m_pBEnd->GetPhoneSetFlag() );
#endif
		    }
        }
    }

    return hr;
} /* MSE_TTSEngine::SetObjectToken */

/*****************************************************************************
* MSE_TTSEngine::Speak *
*-------------------*
*   Description:
*       This method is supposed to speak the text observing the associated
*   XML state.
********************************************************************* EDC ***/
STDMETHODIMP MSE_TTSEngine::
    Speak( DWORD dwSpeakFlags, REFGUID rguidFormatId,
           const WAVEFORMATEX * /* pWaveFormatEx ignored */,
           const SPVTEXTFRAG* pTextFragList,
           ISpTTSEngineSite* pOutputSite )
{
    SPDBG_FUNC( "MSE_TTSEngine::Speak" );
    HRESULT hr = S_OK;

#if USE_PERF_COUNTERS
    m_pco.IncrementCounter (perfcSpeakCalls);
#endif
    //--- Early exit?
    if( ( rguidFormatId != SPDFID_WaveFormatEx && rguidFormatId != SPDFID_Text ) || SP_IS_BAD_INTERFACE_PTR( pOutputSite ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Debug Macro - open file for debugging output
        TTSDBG_OPENFILE;

        //--- Initialize sentence enumerator
        hr = m_cpSentEnum->SetFragList( pTextFragList, dwSpeakFlags );

        if( SUCCEEDED( hr ) )
        {

            //	The following code is here just for testing.
            //  It should be removed once all the tools accept the
            //  new way of outputing debug info.
            if( rguidFormatId == SPDFID_Text )
            {
                //--- Enumerate and write out all sentence items.
                IEnumSENTITEM *pItemEnum;
                TTSSentItem Item;

                //--- Write unicode signature
                static const WCHAR Signature = 0xFEFF;
                hr = pOutputSite->Write( &Signature, sizeof(Signature), NULL );

                while( (hr = m_cpSentEnum->Next( &pItemEnum) ) == S_OK )
                {
                    while( (hr = pItemEnum->Next( &Item )) == S_OK )
                    {
                        // Is there a valid normalized-word-list?
                        if ( Item.pItemInfo->Type & eWORDLIST_IS_VALID )
                        {
                            for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                            {
                                if ( Item.Words[i].pXmlState->eAction == SPVA_Speak ||
                                     Item.Words[i].pXmlState->eAction == SPVA_SpellOut )
                                {
                                    ULONG cb = Item.Words[i].ulWordLen * sizeof( WCHAR );
                                    hr = pOutputSite->Write( Item.Words[i].pWordText, cb, NULL );
                                    if( hr == S_OK ) 
                                    {
                                        //--- Insert space between items
                                        hr = pOutputSite->Write( L" ", sizeof( WCHAR ), NULL );
                                    }
                                }
                            }
                        }
                        else // no word list - just write the original text.
                        {
                            ULONG cb = Item.ulItemSrcLen * sizeof( WCHAR );
                            hr = pOutputSite->Write( Item.pItemSrcText, cb, NULL ); 
                            if ( SUCCEEDED(hr) )
                            {
                                //--- Insert space between items
                                hr = pOutputSite->Write( L" ", sizeof( WCHAR ), NULL );
                            }
                        }
                    }
                    pItemEnum->Release();

                    //--- Insert mark between sentences
                    if( SUCCEEDED( hr ) ) 
                    {
                        static const WCHAR CRLF[2] = { 0x000D, 0x000A };
                        hr = pOutputSite->Write( CRLF, 2*sizeof(WCHAR), NULL );
                    }
                }
                static const WCHAR ENDL = 0x0000;
                hr = pOutputSite->Write( &ENDL, sizeof(WCHAR), NULL );

            }
            else 
            {
                //--- Render the text
                m_FEObj.PrepareSpeech( m_cpSentEnum, pOutputSite );

                SPEECH_STATE SpeechState = SPEECH_CONTINUE;
                SentenceData *pSentence = NULL;
                short *pSamples = NULL;
                int nSamples = 0;

                while ( SpeechState == SPEECH_CONTINUE )
                {
                    hr = m_FEObj.NextData( (void**)&pSentence, &SpeechState );

                    if ( SUCCEEDED( hr ) &&
                         SpeechState == SPEECH_CONTINUE )
                    {
                        if ( !m_pBEnd->NewPhoneString( pSentence->pPhones, pSentence->ulNumPhones,
                                                       pSentence->pf0, pSentence->ulNumf0 ) )
                        {
                            hr = E_FAIL;
                        }
                        else
                        {
                            while ( SUCCEEDED( hr ) &&
                                    m_pBEnd->OutputPending() )
                            {
                                if ( !m_pBEnd->GenerateOutput( &pSamples, &nSamples ) )
                                {
                                    hr = E_FAIL;
                                }
                                else if ( nSamples )
                                {
                                    hr = pOutputSite->Write( (void*)pSamples, nSamples * sizeof( short ), NULL );
                                }
                            }
                        }
                    }

                    if ( pSentence )
                    {
                        if ( pSentence->pPhones )
                        {
                            delete pSentence->pPhones;
                            pSentence->pPhones = NULL;
                        }
                        if ( pSentence->pf0 )
                        {
                            delete pSentence->pf0;
                            pSentence->pf0 = NULL;
                        }
                        delete pSentence;
                        pSentence = NULL;
                    }
                }
            }
        }

        //--- Debug Macro - close debugging file
        TTSDBG_CLOSEFILE;
    }

    return hr;
} /* MSE_TTSEngine::Speak */

//--- This is the only format the Entropic backend supports...
static const WAVEFORMATEX EntropicFormat = 
{
    1,
    1,
    8000,
    16000,
    2,
    16,
    0
};

/****************************************************************************
* MSE_TTSEngine::GetOutputFormat *
*-----------------------------*
*   Description:
*
*   Returns:
*
******************************************************************* PACOG ***/

STDMETHODIMP MSE_TTSEngine::GetOutputFormat(const GUID * pTargetFormatId, const WAVEFORMATEX * /* pTargetWaveFormatEx */,
                                         GUID * pDesiredFormatId, WAVEFORMATEX ** ppCoMemDesiredWaveFormatEx)
{
    SPDBG_FUNC("MSE_TTSEngine::GetOutputFormat");
    HRESULT hr = S_OK;

    if( ( SP_IS_BAD_WRITE_PTR(pDesiredFormatId)  ) || 
		( SP_IS_BAD_WRITE_PTR(ppCoMemDesiredWaveFormatEx) ) )
    {
        hr = E_INVALIDARG;
    }
    else if (pTargetFormatId == NULL || *pTargetFormatId != SPDFID_Text)
    {
        *pDesiredFormatId = SPDFID_WaveFormatEx;
        *ppCoMemDesiredWaveFormatEx = (WAVEFORMATEX *)::CoTaskMemAlloc(sizeof(WAVEFORMATEX));
        if (*ppCoMemDesiredWaveFormatEx)
        {
            **ppCoMemDesiredWaveFormatEx = EntropicFormat;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *pDesiredFormatId = SPDFID_Text;
        *ppCoMemDesiredWaveFormatEx = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* MSE_TTSEngine::GetOutputFormat */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\ttsengine.h ===
/******************************************************************************
* MSE_TTSEngine.h *
*-------------*
*  This is the header file for the CMSE_TTSEngine implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef MSE_TTSEngine_h
#define MSE_TTSEngine_h

//--- Additional includes
#include "ms_entropicengine.h"
#include <spddkhlp.h>
#include <sphelper.h>
#include "Frontend.h"
#include "FeedChain.h"
#include "resource.h"
#include "perfmon.h"

//=== Constants ====================================================
#define TEXT_VOICE_FMT_INDEX    1

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CMSE_TTSEngine COM object ********************************
*/
class ATL_NO_VTABLE MSE_TTSEngine : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<MSE_TTSEngine, &CLSID_MSE_TTSEngine>,
	public ISpTTSEngine,
    public ISpObjectWithToken
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_MSE_TTSENGINE)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MSE_TTSEngine)
	    COM_INTERFACE_ENTRY(ISpTTSEngine)
	    COM_INTERFACE_ENTRY(ISpObjectWithToken)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    HRESULT FinalConstruct();
    void FinalRelease();

    /*=== Interfaces ====*/
  public:
    //--- ISpTTSEngine --------------------------------------------
    STDMETHOD(Speak)( DWORD dwSpeakFlags,
                      REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx,
                      const SPVTEXTFRAG* pTextFragList, ISpTTSEngineSite* pOutputSite );
    STDMETHOD(GetOutputFormat)( const GUID * pTargetFormatId, const WAVEFORMATEX * pTargetWaveFormatEx,
                                GUID * pDesiredFormatId, WAVEFORMATEX ** ppCoMemDesiredWaveFormatEx );

    //--- ISpObjectWithToken ----------------------------------
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken)
        { return SpGenericGetObjectToken( ppToken, m_cpToken ); }

  private:
#define USE_PERF_COUNTERS (0)
#if USE_PERF_COUNTERS
   void        IncrementPerfCounter(PERFC perfc) { m_pco.IncrementCounter(perfc); }
   void        SetPerfCounter(PERFC perfc, __int32 value) { m_pco.SetCounter(perfc, value); }
#else
   void        IncrementPerfCounter(PERFC perfc) {};
   void        SetPerfCounter(PERFC perfc, __int32 value) {};
#endif
  /*=== Member Data ===*/
    CComPtr<IEnumSpSentence>    m_cpSentEnum;
    CComPtr<ISpObjectToken>     m_cpToken;
	CBackEnd                    *m_pBEnd;
	CFrontend                   m_FEObj;
#ifdef USE_VOICEDATAOBJ
    CVoiceData				    m_VoiceDataObj;        // This should not AddRef
#endif
	ULONG                       m_BytesPerSample;
    bool                        m_IsStereo;
    ULONG                       m_SampleRate;
#ifdef USE_VOICEDATAOBJ
    MSVOICEINFO                 m_VoiceInfo;
#endif

    CPerfCounterObject          m_pco;
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\regvoices\makefile.inc ===
RunProgram :
	$(O)\$(TARGETNAME).exe
!if defined(MAKEDLL)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\perf\ttsperf.h ===
// SYMFILE.H

#define perfcTTS                    0

#define perfcSpeakCalls             2 // increment by Two

#define perfcMax                    4

#define perfVersion                 2       // Increment this when performance data format changes.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\ttspropertiesdialog.cpp ===
/****************************************************************************
*   TTSPropertiesDialog.cpp
*
*       TTS Engine Advanced Properties Dialog handler
*
*   Owner: aaronhal
*
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/

#include "stdafx.h"
#include "ms_entropicengine.h"
#include "resource.h"
#include "sphelper.h"
#include "TTSPropertiesDialog.h"

/*****************************************************************************
* CTTSPropertiesDialog::CTTSPropertiesDialog *
*--------------------------------------------*
*
*   Description:    Constructor
*
***************************************************************** aaronhal ***/
CTTSPropertiesDialog::CTTSPropertiesDialog( HINSTANCE hInstance, HWND hwndParent )
{
    m_hInstance  = hInstance;
    m_hwndParent = hwndParent;
    m_dwSeparatorAndDecimal = 0;
    m_dwShortDateOrder      = 0;
} /* CTTSPropertiesDialog */

/*****************************************************************************
* CTTSPropertiesDialog::Run *
*---------------------------*
*
*   Description:    Launches the dialog associated with this object
*
*   Return:         S_OK if values accepted,
*                   S_FALSE if cancelled,
*
***************************************************************** aaronhal ***/
HRESULT CTTSPropertiesDialog::Run()
{
    HRESULT hr = S_OK;

    if ( SUCCEEDED( hr ) )
    {
        hr = (HRESULT) g_Unicode.DialogBoxParam( m_hInstance, (LPCWSTR) MAKEINTRESOURCE( IDD_TTS_ADV ), m_hwndParent, 
                                       DlgProc, (LPARAM) this );
    }

    return hr;
} /* Run */

/*****************************************************************************
* CTTSPropertiesDialog::InitDialog *
*----------------------------------*
*
*   Description:    Static member function which handles the WM_INITDIALOG
*                   message.  Set windows up, cache this pointer, etc.
*
*   Return:         TRUE
*
***************************************************************** aaronhal ***/
HRESULT CTTSPropertiesDialog::InitDialog( HWND hDlg, LPARAM lParam )
{
    HRESULT hr = S_OK;

    //--- Cache the 'this' pointer
    g_Unicode.SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

    //--- Retrieve the current settings from the registry
    CSpDynamicString dstrTokenKeyName;

    hr = StringFromCLSID( CLSID_MSE_TTSEngine, &dstrTokenKeyName );
    if ( SUCCEEDED( hr ) )
    {
        hr = SpCreateNewToken( L"HKEY_CURRENT_USER\\Software\\Microsoft\\Speech\\Voices", dstrTokenKeyName,
                                 &This(hDlg)->m_cpEngineToken );
    }

    if ( SUCCEEDED( hr ) )
    {
        This(hDlg)->m_cpEngineToken->GetDWORD( L"SeparatorAndDecimal", 
                                                    &This(hDlg)->m_dwSeparatorAndDecimal );
        This(hDlg)->m_cpEngineToken->GetDWORD( L"ShortDateOrder", &This(hDlg)->m_dwShortDateOrder );

        //--- Set the state of the dialog
        if ( This(hDlg)->m_dwSeparatorAndDecimal & (DWORD) PERIOD_COMMA )
        {
            g_Unicode.SendDlgItemMessage( hDlg, IDC_PERIOD_COMMA, BM_SETCHECK, BST_CHECKED, 0 );
            g_Unicode.SendDlgItemMessage( hDlg, IDC_COMMA_PERIOD, BM_SETCHECK, BST_UNCHECKED, 0 );
        }
        else
        {
            //--- Default is comma separator, period decimal point
            g_Unicode.SendDlgItemMessage( hDlg, IDC_PERIOD_COMMA, BM_SETCHECK, BST_UNCHECKED, 0 );
            g_Unicode.SendDlgItemMessage( hDlg, IDC_COMMA_PERIOD, BM_SETCHECK, BST_CHECKED, 0 );
        }

        if ( This(hDlg)->m_dwShortDateOrder & (DWORD) YEAR_MONTH_DAY )
        {
            g_Unicode.SendDlgItemMessage( hDlg, IDC_MDY, BM_SETCHECK, BST_UNCHECKED, 0 );
            g_Unicode.SendDlgItemMessage( hDlg, IDC_DMY, BM_SETCHECK, BST_UNCHECKED, 0 );
            g_Unicode.SendDlgItemMessage( hDlg, IDC_YMD, BM_SETCHECK, BST_CHECKED, 0 );
        }
        else if ( This(hDlg)->m_dwShortDateOrder & (DWORD) DAY_MONTH_YEAR )
        {
            g_Unicode.SendDlgItemMessage( hDlg, IDC_MDY, BM_SETCHECK, BST_UNCHECKED, 0 );
            g_Unicode.SendDlgItemMessage( hDlg, IDC_DMY, BM_SETCHECK, BST_CHECKED, 0 );
            g_Unicode.SendDlgItemMessage( hDlg, IDC_YMD, BM_SETCHECK, BST_UNCHECKED, 0 );
        }
        else
        {
            //--- Default is month day year
            g_Unicode.SendDlgItemMessage( hDlg, IDC_MDY, BM_SETCHECK, BST_CHECKED, 0 );
            g_Unicode.SendDlgItemMessage( hDlg, IDC_DMY, BM_SETCHECK, BST_UNCHECKED, 0 );
            g_Unicode.SendDlgItemMessage( hDlg, IDC_YMD, BM_SETCHECK, BST_UNCHECKED, 0 );
        }
    }

    return hr;
} /* InitDialog */

/*****************************************************************************
* CTTSPropertiesDialog::DlgProc *
*-------------------------------*
*
*   Description:    Static member for Windows callback.
*
*   Return:         TRUE if message was handled, FALSE otherwise
*
***************************************************************** aaronhal ***/
INT_PTR CALLBACK CTTSPropertiesDialog::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fProcessed = FALSE;
    
    switch (message)
    {
        case WM_INITDIALOG:
            fProcessed = SUCCEEDED( InitDialog( hDlg, lParam ) );
            break;

        case WM_COMMAND:
            switch ( LOWORD(wParam) )
            {
            case IDC_COMMA_PERIOD:
                {
                    SendDlgItemMessage( hDlg, IDC_PERIOD_COMMA, BM_SETCHECK, BST_UNCHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_COMMA_PERIOD, BM_SETCHECK, BST_CHECKED, 0 );
                    fProcessed = TRUE;
                }
                break;

            case IDC_PERIOD_COMMA:
                {
                    SendDlgItemMessage( hDlg, IDC_PERIOD_COMMA, BM_SETCHECK, BST_CHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_COMMA_PERIOD, BM_SETCHECK, BST_UNCHECKED, 0 );
                    fProcessed = TRUE;
                }
                break;

            case IDC_MDY:
                {
                    SendDlgItemMessage( hDlg, IDC_MDY, BM_SETCHECK, BST_CHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_DMY, BM_SETCHECK, BST_UNCHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_YMD, BM_SETCHECK, BST_UNCHECKED, 0 );
                    fProcessed = TRUE;
                }
                break;

            case IDC_DMY:
                {
                    SendDlgItemMessage( hDlg, IDC_MDY, BM_SETCHECK, BST_UNCHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_DMY, BM_SETCHECK, BST_CHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_YMD, BM_SETCHECK, BST_UNCHECKED, 0 );
                    fProcessed = TRUE;
                }
                break;

            case IDC_YMD:
                {
                    SendDlgItemMessage( hDlg, IDC_MDY, BM_SETCHECK, BST_UNCHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_DMY, BM_SETCHECK, BST_UNCHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_YMD, BM_SETCHECK, BST_CHECKED, 0 );
                    fProcessed = TRUE;
                }
                break;

            case IDRESTORE:
                {
                    //--- Default is comma separator, period decimal point
                    SendDlgItemMessage( hDlg, IDC_PERIOD_COMMA, BM_SETCHECK, BST_UNCHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_COMMA_PERIOD, BM_SETCHECK, BST_CHECKED, 0 );
                    //--- Default is month day year
                    SendDlgItemMessage( hDlg, IDC_MDY, BM_SETCHECK, BST_CHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_DMY, BM_SETCHECK, BST_UNCHECKED, 0 );
                    SendDlgItemMessage( hDlg, IDC_YMD, BM_SETCHECK, BST_UNCHECKED, 0 );
                }
                break;

            case IDCANCEL:
                EndDialog( hDlg, (int)S_FALSE );
                fProcessed = TRUE;
                break;

            case IDOK:
                This(hDlg)->UpdateValues( hDlg );
                EndDialog( hDlg, (int)S_OK );
                fProcessed = TRUE;
                break;

            }
            break;
    }

    return int(fProcessed);
} /* DlgProc */

/*****************************************************************************
* CTTSPropertiesDialog::Update *
*------------------------------*
*
*   Description:    Write new parameters to the registry.
*
*   Return:         Nothing.
*
***************************************************************** aaronhal ***/
void CTTSPropertiesDialog::UpdateValues( HWND hDlg )
{
    LRESULT lrValue = 0;

    //--- Set short date format
    lrValue = SendDlgItemMessage( hDlg, IDC_MDY, BM_GETCHECK, 0, 0 );
    if ( lrValue == BST_CHECKED )
    {
        This(hDlg)->m_cpEngineToken->SetDWORD( L"ShortDateOrder", (DWORD) MONTH_DAY_YEAR );
    }
    else
    {
        lrValue = SendDlgItemMessage( hDlg, IDC_DMY, BM_GETCHECK, 0, 0 );
        if ( lrValue == BST_CHECKED )
        {
            This(hDlg)->m_cpEngineToken->SetDWORD( L"ShortDateOrder", (DWORD) DAY_MONTH_YEAR );
        }
        else
        {
            This(hDlg)->m_cpEngineToken->SetDWORD( L"ShortDateOrder", (DWORD) YEAR_MONTH_DAY );
        }
    }

    //--- Set number separator and decimal point
    lrValue = SendDlgItemMessage( hDlg, IDC_PERIOD_COMMA, BM_GETCHECK, 0, 0 );
    if ( lrValue == BST_CHECKED )
    {
        This(hDlg)->m_cpEngineToken->SetDWORD( L"SeparatorAndDecimal", (DWORD) PERIOD_COMMA );
    }
    else
    {
        This(hDlg)->m_cpEngineToken->SetDWORD( L"SeparatorAndDecimal", (DWORD) COMMA_PERIOD );
    }
} /* Update */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\ttspropertiesdialog.h ===
/****************************************************************************
*
*   TTSPropertiesDialog.h
*
*       TTS Engine Advanced Properties Dialog handler
*
*   Owner: aaronhal
*
*   Copyright  2000 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/

#pragma once

#include "spunicode.h"

//--- Includes --------------------------------------------------------------

//--- Forward and External Declarations -------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

typedef enum SEPARATOR_AND_DECIMAL
{
    PERIOD_COMMA = (1L << 0),
    COMMA_PERIOD = (1L << 1)
} SEPARATOR_AND_DECIMAL;

typedef enum SHORT_DATE_ORDER
{
    MONTH_DAY_YEAR = (1L << 0),
    DAY_MONTH_YEAR = (1L << 1),
    YEAR_MONTH_DAY = (1L << 2)
} SHORT_DATE_ORDER;

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

class CTTSPropertiesDialog  
{
    public:

	    CTTSPropertiesDialog( HINSTANCE hInstance, HWND hwndParent );

        HRESULT Run( void );

    private:

        static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
        static HRESULT InitDialog( HWND hDlg, LPARAM lParam );
        static CTTSPropertiesDialog * This( HWND );
        void UpdateValues( HWND hDlg );

    private:

        HINSTANCE   m_hInstance;
        HWND        m_hwndParent;
        DWORD       m_dwSeparatorAndDecimal;
        DWORD       m_dwShortDateOrder;
        CComPtr<ISpObjectToken> m_cpEngineToken;
};

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------

inline CTTSPropertiesDialog * CTTSPropertiesDialog::This( HWND hwnd )
{
    return (CTTSPropertiesDialog *)g_Unicode.GetWindowLongPtr(hwnd, GWLP_USERDATA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\voicedataobj.cpp ===
/*******************************************************************************
* VoiceDataObj.cpp *
*------------------*
*   Description:
*       This module is the main implementation file for the CVoiceData class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 05/06/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "VoiceDataObj.h"

/*****************************************************************************
* CVoiceData::FinalConstruct *
*-------------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
CVoiceData::CVoiceData()
{
    //--- Init vars
    m_hVoiceDef  = NULL;
    m_hVoiceData = NULL;
    m_pVoiceData = NULL;
    m_pVoiceDef  = NULL;
} /* CVoiceData::FinalConstruct */

/*****************************************************************************
* CVoiceData::FinalRelease *
*-----------------------------*
*   Description:
*       destructor
********************************************************************* EDC ***/
CVoiceData::~CVoiceData()
{
    SPDBG_FUNC( "CVoiceData::FinalRelease" );

    if( m_pVoiceDef )
    {
        ::UnmapViewOfFile( (void*)m_pVoiceDef );
    }

    if( m_pVoiceData )
    {
        ::UnmapViewOfFile( (void*)m_pVoiceData );
    }

    if( m_hVoiceDef  ) ::CloseHandle( m_hVoiceDef  );
    if( m_hVoiceData ) ::CloseHandle( m_hVoiceData );
} /* CVoiceData::FinalRelease */


/*****************************************************************************
* CVoiceData::MapFile *
*------------------------*
*   Description:
*       Helper function used by SetObjectToken to map file.  This function
*   assumes that m_cpToken has been initialized.+++
********************************************************************* RAL ***/
HRESULT CVoiceData::MapFile( const WCHAR * pszTokenVal,   // Value that contains file path
                                HANDLE * phMapping,          // Pointer to file mapping handle
                                void ** ppvData )            // Pointer to the data
{
    HRESULT hr = S_OK;
    bool fWorked;

    CSpDynamicString dstrFilePath;
    hr = m_cpToken->GetStringValue( pszTokenVal, &dstrFilePath );
    if ( SUCCEEDED( hr ) )
    {
        fWorked = false;
        *phMapping = NULL;
        *ppvData = NULL;


        HANDLE  hFile;

#ifndef _WIN32_WCE
        hFile = g_Unicode.CreateFile( 
                    dstrFilePath, 
                    GENERIC_READ, 
                    FILE_SHARE_READ, 
                    NULL, 
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 
                    NULL );
#else   //_WIN32_WCE
        hFile = g_Unicode.CreateFileForMapping( 
                    dstrFilePath, 
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL, 
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 
                    NULL );
#endif  //_WIN32_WCE
        if (hFile != INVALID_HANDLE_VALUE)
        {
            //-------------------------------------
            // Make a unique map name from path
            //-------------------------------------
            long        i;

            for( i = 0; i < _MAX_PATH-1; i++ )
            {
                if( dstrFilePath[i] == 0 )
                {
                    // End of string
                    break;
                }
                if( dstrFilePath[i] == '\\' )
                {
                    //-------------------------------------
                    // Change backslash to underscore
                    //-------------------------------------
                    dstrFilePath[i] = '_';
                }
            }

            *phMapping = g_Unicode.CreateFileMapping( hFile, NULL, PAGE_READONLY, 0, 0, dstrFilePath );

            ::CloseHandle( hFile );

        }

        if (*phMapping)
        {
            *ppvData = ::MapViewOfFile( *phMapping, FILE_MAP_READ, 0, 0, 0 );
            if (*ppvData)
            {
                fWorked = true;
            }
        }
        if (!fWorked)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            if (hr == E_HANDLE)
            {
                hr &= 0xFFFFF000;
                hr |= ERROR_FILE_NOT_FOUND;
            }

            if (*phMapping)
            {
                ::CloseHandle(*phMapping);
                *phMapping = NULL;
            }
        }
    }
    return hr;
} /* CVoiceData::MapFile */
 
/*****************************************************************************
* CVoiceData::SetObjectToken *
*-------------------------------*
*   Description:
*       This function performs the majority of the initialization of the voice.
*   Once the object token has been provided, the filenames are read from the
*   token key and the files are mapped.+++
********************************************************************* RAL ***/
STDMETHODIMP CVoiceData::SetObjectToken(ISpObjectToken * pToken)
{
    SPDBG_FUNC( "CVoiceData::SetObjectToken" );
    HRESULT hr = S_OK;

    m_cpToken = pToken;

    if ( SUCCEEDED( hr ) )
    {
        hr = MapFile( L"VoiceDef", &m_hVoiceDef, (void **)&m_pVoiceDef );
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = MapFile( L"VoiceData", &m_hVoiceData, (void **)&m_pVoiceData );
    }

    //--- Init voice data pointers
    if (SUCCEEDED(hr))
    {
        hr = InitVoiceData();
    }

    return hr;
} /* CVoiceData::SetObjectToken */

/*****************************************************************************
* CVoiceData::GetVoiceInfo *
*-----------------------------*
*   Description:
*       This method is used to retrieve the voice file data description.+++
********************************************************************* EDC ***/
STDMETHODIMP CVoiceData::GetVoiceInfo( MSVOICEINFO* pVoiceInfo )
{
    SPDBG_FUNC( "CVoiceData::GetVoiceInfo" );
    HRESULT hr = S_OK;
    long    i;

    //--- Check args
    if( ( SP_IS_BAD_WRITE_PTR( pVoiceInfo ) ) || ( m_pVoiceDef == NULL ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (!m_cpToken)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            pVoiceInfo->pWindow = m_pWindow;
            pVoiceInfo->FFTSize = m_FFTSize;
            pVoiceInfo->LPCOrder = m_cOrder;
            pVoiceInfo->ProsodyGain = m_pVoiceDef->ProsodyGain;
            pVoiceInfo->eReverbType = m_pVoiceDef->ReverbType;
            pVoiceInfo->Pitch = m_pVoiceDef->Pitch;
            pVoiceInfo->Rate = m_pVoiceDef->Rate;
            pVoiceInfo->LangID = m_pVoiceDef->LangID;
            pVoiceInfo->SampleRate = m_pVoiceDef->SampleRate;
            pVoiceInfo->VibratoFreq = m_pVoiceDef->VibratoFreq;
            pVoiceInfo->VibratoDepth = m_pVoiceDef->VibratoDepth;
            pVoiceInfo->NumOfTaps = m_pVoiceDef->NumOfTaps;

            // Assumes voices are ALWAYS 16-bit mono (probably valid for now)***
            pVoiceInfo->WaveFormatEx.wFormatTag         = WAVE_FORMAT_PCM;
            pVoiceInfo->WaveFormatEx.nSamplesPerSec     = pVoiceInfo->SampleRate;
            pVoiceInfo->WaveFormatEx.wBitsPerSample     = 16;   // ***
            pVoiceInfo->WaveFormatEx.nChannels          = 1;    // ***
            pVoiceInfo->WaveFormatEx.nBlockAlign        = (unsigned short)(pVoiceInfo->WaveFormatEx.nChannels * sizeof(short)); // ***
            pVoiceInfo->WaveFormatEx.nAvgBytesPerSec    = pVoiceInfo->WaveFormatEx.nSamplesPerSec * pVoiceInfo->WaveFormatEx.nBlockAlign;  
            pVoiceInfo->WaveFormatEx.cbSize             = 0;
            for (i = 0; i < MAXTAPS; i++)
            {
                pVoiceInfo->TapCoefficients[i] = m_pVoiceDef->TapCoefficients[i];
            }
        }
    }
    return hr;
} /* CVoiceData::GetVoiceInfo */


/*****************************************************************************
* CVoiceData::GetUnit *
*------------------------*
*   Description:
*   Retrieves and uncompresses audio data from the unit inventory. +++
*       
********************************************************************* EDC ***/
STDMETHODIMP CVoiceData::GetUnitData( ULONG unitID, MSUNITDATA* pUnitData )
{
    SPDBG_FUNC( "CVoiceData::GetUnit" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_WRITE_PTR( pUnitData ) )
    {
        hr = E_INVALIDARG;
    }
    else if( unitID > m_NumOfUnits )
    {
        //--------------------------
        // ID is out of range!
        //--------------------------
        hr = E_INVALIDARG;
    }
    else
    {
        if (!m_cpToken)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            if( m_CompressionType != COMPRESS_LPC ) 
            {
                //--------------------------------------
                // Unsupported compression type
                //--------------------------------------
                hr = E_FAIL;
            } 
            else 
            {
                //-------------------------------------------------------------------
                // Retrieve data from compressed inventory
                //-------------------------------------------------------------------
                hr = DecompressUnit( unitID, pUnitData );
            }
        }
    }
    return hr;
} /* CVoiceData::GetUnit */


/*****************************************************************************
* CVoiceData::AlloToUnit *
*---------------------------*
*   Description:
*   Converts FE allo code to BE unit phon code.+++
*       
********************************************************************* EDC ***/
STDMETHODIMP CVoiceData::AlloToUnit( short allo, long attributes, long* pUnitID )
{
    SPDBG_FUNC( "CVoiceData::AlloToUnit" );
    HRESULT hr = S_OK;
    long        index;
    union {
        char c[2];
        short s;
    } temp;
    char* pb;

    //--- Check args
    if( (SP_IS_BAD_READ_PTR( pUnitID )) || (allo >= m_NumOfAllos) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        index = (long)allo << 1;           // 2 entries per phon
        if( attributes & ALLO_IS_STRESSED )
        {
            //--- 2nd half
            pb = (char*) &m_AlloToUnitTbl[index + (m_NumOfAllos << 1)];
        }
        else
        {
            pb = (char*) &m_AlloToUnitTbl[index];
        }

        // We read this way to avoid missaligned data accesses in 64bit.
        temp.c[0] = *pb++;
        temp.c[1] = *pb;

        *pUnitID = (long) temp.s;            
    }

   return hr;
} /* CVoiceData::AlloToUnit */



/*****************************************************************************
* CVoiceData::GetUnitIDs *
*---------------------------*
*   Description:
*   Gets the inventory triphone (in context) unit code.+++
*       
********************************************************************* EDC ***/
STDMETHODIMP CVoiceData::GetUnitIDs( UNIT_CVT* pUnits, ULONG cUnits )
{
    SPDBG_FUNC( "CVoiceData::GetUnitIDs" );
    ULONG    i;
    ULONG    curID, prevID, nextID;
    ULONG    curF, prevF, nextF;
    char    cPos;
    ULONG    senoneID;
    UNALIGNED UNIT_STATS  *pStats;
    HRESULT hr = S_OK;

    //--- Check args
    if( (SP_IS_BAD_READ_PTR( pUnits)) ||
        (SP_IS_BAD_WRITE_PTR( pUnits)) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (!m_cpToken)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            for( i = 0; i < cUnits; i++ )
            {
                //---------------------------
                // CURRENT phon
                //---------------------------
                curID = pUnits[i].PhonID;
                curF = pUnits[i].flags;
        
                //---------------------------
                // PREVIOUS phon
                //---------------------------
                if( i == 0 )
                {
                    prevID = m_Sil_Index;
                    prevF = 0;
                }
                else
                {
                    prevID = pUnits[i-1].PhonID;
                    prevF = pUnits[i-1].flags;
                }
        
                //---------------------------
                // NEXT phon
                //---------------------------
                if( i >= cUnits -1 )
                {
                    nextID = m_Sil_Index;
                    nextF = 0;
                }
                else
                {
                    nextID = pUnits[i+1].PhonID;
                    nextF = pUnits[i+1].flags;
                }
        
                if( curID == m_Sil_Index )
                {
                    //----------------------
                    // SILENCE phon
                    //----------------------
                    pUnits[i].UnitID = 0;
                    pUnits[i].SenoneID = 0;
                    pUnits[i].szUnitName[0] = 0;
                    pUnits[i].Dur = SIL_DURATION;
                    pUnits[i].Amp = 0;
                    pUnits[i].AmpRatio = 1.0f;
                }
               else
                {
                    cPos = '\0';
                    if( curF & WORD_START_FLAG )
                    {
                        if( nextF & WORD_START_FLAG )
                            //---------------------------------------
                            // Both Cur and Next are word start
                            //---------------------------------------
                            cPos = 's';
                       else
                            //---------------------------------------
                            // Cur is word start
                            // Next is not
                            //---------------------------------------
                            cPos = 'b';
                    }
                    else if( nextF & WORD_START_FLAG )
                    {
                        //---------------------------------------
                        // Next is word start
                        // Cur is not
                        //---------------------------------------
                        cPos = 'e';
                    }
                    HRESULT     hrt;

                    hrt = GetTriphoneID( m_pForest, 
                                        curID, 
                                        prevID, 
                                        nextID, 
                                        cPos, 
                                        m_pd,
                                        &senoneID);
                    if( FAILED(hrt) )
                    {
                        //------------------------------------------------
                        // Instead of failing, I'll be robust and ignore 
                        // the error. Force triphone to something that's 
                        // valid.
                        //------------------------------------------------
                        senoneID = 0;
                    }
                    pUnits[i].UnitID = (m_pForest->gsOffset[curID] - 
                               m_First_Context_Phone) + (senoneID + 1);
                    pUnits[i].SenoneID = senoneID;

                    //-----------------------------
                    // Get phon name strings
                    //-----------------------------
                    char        *pName;
                    pName = PhonFromID( m_pd, pUnits[i].PhonID );
                    strcpy( &pUnits[i].szUnitName[0], pName );

                    //-----------------------------
                    // Get unit stats
                    //-----------------------------
                    pStats = (UNALIGNED UNIT_STATS*)(m_SenoneBlock[curID] + (char*)m_SenoneBlock);
                    pStats = &pStats[senoneID+1];
                    pStats = (UNALIGNED UNIT_STATS*)(m_SenoneBlock[curID] + (char*)m_SenoneBlock);
                    pStats = &pStats[senoneID-1];

                    pStats = (UNALIGNED UNIT_STATS*)(m_SenoneBlock[curID] + (char*)m_SenoneBlock);
                    pStats = &pStats[senoneID];
                    pUnits[i].Dur = pStats->dur / 1000.0f;      // ms -> sec
                    pUnits[i].Amp = pStats->amp;
                    pUnits[i].AmpRatio = (float)sqrt(pStats->ampRatio);

                    //----------------------------------------------------------
                    // Looks like the "SENONE" table durations are 
                    //   incorrect (not even close!).
                    // Calc the real duration from inv epochs
                    // TODO: Make new table in voice data block
                    //----------------------------------------------------------
                    //hr = GetUnitDur( pUnits[i].UnitID, &pUnits[i].Dur );
                    if( FAILED(hr) )
                    {
                        break;
                    }
                }
            }
        }
    }
    return hr;
} /* CVoiceData::GetUnitIDs */



/*****************************************************************************
* GetDataBlock *
*--------------*
*   Description:
*       Return ptr and length of specified voice data block. +++
*       
********************************************************************** MC ***/
HRESULT CVoiceData::GetDataBlock( VOICEDATATYPE type, char **ppvOut, ULONG *pdwSize )
{
    SPDBG_FUNC( "CVoiceData::GetDataBlock" );
    long    *offs;
    HRESULT hr = S_OK;
    long    dataType;
    
    if( !m_pVoiceData )
    {
        hr = E_INVALIDARG;
   }
    else
    {
        dataType    = (long)type * 2;               // x2 since each entry is an offset/length pair
        offs        = (long*)&m_pVoiceData->PhonOffset;    // Table start
        *ppvOut     = offs[dataType] + ((char*)m_pVoiceData);         // Offset -> abs address
        *pdwSize    = offs[dataType + 1];
    }
        
    
    return hr;
} /* CVoiceData::GetDataBlock */




/*****************************************************************************
* InitVoiceData *
*---------------*
*   Description:
*       Create pointers to voice data blocks from m_pVoiceData offsets.+++
*       
********************************************************************** MC ***/
HRESULT CVoiceData::InitVoiceData()
{
    SPDBG_FUNC( "CVoiceData::InitVoiceData" );
    char    *pRawData;
    ULONG    dataSize;
    HRESULT hr = S_OK;
    
    //------------------------------------------
    // Check data type and version
    //------------------------------------------
    if( (m_pVoiceData != NULL)  
        && (m_pVoiceData->Type == MS_DATA_TYPE) 
        && (m_pVoiceData->Version == HEADER_VERSION) )
    {
        //-------------------------------
        // Get ptr to PHONs
        //-------------------------------
        hr = GetDataBlock( MSVD_PHONE, &pRawData, &dataSize );
        m_pd = (PHON_DICT*)pRawData;
    
        //-------------------------------
        // Get ptr to TREE
        //-------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_TREEIMAGE, &pRawData, &dataSize );
            m_pForest = (TRIPHONE_TREE*)pRawData;
        }
    
        //-------------------------------
        // Get ptr to SENONE
        //-------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_SENONE, &pRawData, &dataSize );
            m_SenoneBlock = (long*)pRawData;
        }
        //-------------------------------
        // Get ptr to ALLOID
        //-------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_ALLOID, &pRawData, &dataSize );
            m_AlloToUnitTbl = (short*)pRawData;
            m_NumOfAllos = dataSize / 8;
        }
    
        if( SUCCEEDED(hr) )
        {
            m_First_Context_Phone = m_pd->numCiPhones;
            m_Sil_Index = PhonToID( m_pd, "SIL" );
        }
        //-----------------------------------------------------
        // Init voice data INVENTORY parameters
        //-----------------------------------------------------
        if( SUCCEEDED(hr) )
        {
            hr = GetDataBlock( MSVD_INVENTORY, &pRawData, &dataSize );
            if( SUCCEEDED(hr) )
            {
                m_pInv = (INVENTORY*)pRawData;
                m_CompressionType = m_pVoiceDef->CompressionType;
                //---------------------------------------------
                // Convert REL to ABS
                //---------------------------------------------
                m_pUnit      = (long*)((char*)m_pInv + m_pInv->UnitsOffset);
                m_pTrig      = (float*)((char*)m_pInv + m_pInv->TrigOffset);
                m_pWindow    = (float*)((char*)m_pInv + m_pInv->WindowOffset);
                m_pGauss     = (float*)((char*)m_pInv + m_pInv->pGaussOffset);
                m_SampleRate = (float)m_pInv->SampleRate;
                m_FFTSize    = m_pInv->FFTSize;
                m_cOrder     = m_pInv->cOrder;
                m_GaussID    = 0;
                m_NumOfUnits = m_pInv->cNumUnits;
           }    
        }
    }
    else
    {
        //-------------------------
        // Not a voice file!
        //-------------------------
        hr = E_FAIL;
    }

    return hr;
} /* CVoiceData::InitVoiceData */





/*****************************************************************************
* CVoiceData::DecompressUnit *
*-------------------------------*
*   Description:
*  Decompress acoustic unit.+++
* 
*   INPUT:
*       UnitID - unit number (1 - 3333 typ)
* 
*   OUTPUT:
*       Fills pSynth if success
*       
********************************************************************** MC ***/
HRESULT CVoiceData::DecompressUnit( ULONG UnitID, MSUNITDATA* pSynth )
{
    SPDBG_FUNC( "CVoiceData::DecompressUnit" );
    long            i, j, k, cNumEpochs, cBytes, cOrder = 0, VectDim;
    long            frameSize, cNumBins, startBin;
    char            *pCurStor;
    unsigned char   index;
    float           pLSP[MAX_LPCORDER], pFFT[MAX_FFTSIZE], pRes[MAX_FFTSIZE], Gain;
    float           *pCurLSP, *pCurLPC, *pMean, *pCurRes;
    HRESULT         hr = S_OK;
    
    
    memset( pSynth, 0, sizeof(MSUNITDATA) );
    //-----------------------------------------
    // Pointer to unit data from inventory
    //-----------------------------------------
    pCurStor = (char*)((char*)m_pInv + m_pUnit[UnitID] );     // Rel to abs

    //---------------------------------
    // Get epoch count - 'cNumEpochs'
    //---------------------------------
    cBytes = sizeof(long);
    memcpy( &cNumEpochs, pCurStor, cBytes );
    pSynth->cNumEpochs = cNumEpochs;
    pCurStor += cBytes;

    //---------------------------------
    // Get epoch lengths - 'pEpoch'
    //---------------------------------
    pSynth->pEpoch = new float[cNumEpochs];
    if( pSynth->pEpoch == NULL )
    {
        hr = E_OUTOFMEMORY;
    }

    if( SUCCEEDED(hr) )
    {
        cBytes = DecompressEpoch( (signed char *) pCurStor, cNumEpochs, pSynth->pEpoch );
        pCurStor += cBytes;

        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        //
        // Uncompress LPC coefficients...
        //
        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        cOrder            = m_pInv->cOrder;
        pSynth->cOrder    = cOrder;
        pSynth->pLPC      = new float[cNumEpochs * (1 + cOrder)];
        if( pSynth->pLPC == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if( SUCCEEDED(hr) )
    {
        pCurLPC = pSynth->pLPC;
        //---------------------------------
        // ... for each epoch
        //---------------------------------
        for( i = 0; i < cNumEpochs; i++, pCurLPC += (1 + cOrder) )
        {
            //-------------------------------------
            // Decode quantized LSP's...
            //-------------------------------------
            pCurLSP = pLSP;
            for( k = 0; k < m_pInv->cNumLPCBooks; k++ )
            {
                VectDim = m_pInv->LPCBook[k].cCodeDim;
                memcpy( &index, pCurStor, sizeof(char));
                pCurStor += sizeof(char);
                pMean = ((float*)((char*)m_pInv + m_pInv->LPCBook[k].pData)) + (index * VectDim);
                for( j = 0; j < VectDim; j++ )
                    pCurLSP[j] = pMean[j];
                pCurLSP += VectDim;
            }
            //--------------------------------------------------
            // ...then convert to predictor coefficients
            // (LSP's quantize better than PC's)
            //--------------------------------------------------
            LSPtoPC( pLSP, pCurLPC, cOrder, i );
        }


        //---------------------------------------
        // Get pointer to residual gains
        //---------------------------------------
        cBytes          = cNumEpochs * sizeof(float);
        pSynth->pGain = (float*) pCurStor;
        pCurStor += cBytes;


        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        //
        // Uncompress residual waveform
        //
        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        //--------------------------------------------
        // First, figure out the buffer length...
        //--------------------------------------------
        pSynth->cNumSamples = 0;
        for( j = 0; j < cNumEpochs; j++ )
        {
            pSynth->cNumSamples += (long) ABS(pSynth->pEpoch[j]);
        }
        //--------------------------------------------
        // ...get buffer memory...
        //--------------------------------------------
        pSynth->pRes = new float[pSynth->cNumSamples];
        if( pSynth->pRes == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if( SUCCEEDED(hr) )
    {
        //--------------------------------------------
        // ...and fill with uncompressed residual
        //--------------------------------------------
        pCurRes = pSynth->pRes;
        for( i = 0; i < (long)pSynth->cNumEpochs; i++ )
        {
            //-------------------------------------
            // Get epoch length
            //-------------------------------------
            frameSize = (long)(ABS(pSynth->pEpoch[i]));

            // restore whisper
            //if( (pSynth->pEpoch[i] > 0) && !(m_fModifiers & BACKEND_BITFLAG_WHISPER) )
            if( pSynth->pEpoch[i] > 0 )
            {
                //-----------------------------------------------
                // VOICED epoch
                //-----------------------------------------------
                if( (m_pInv->cNumDresBooks == 0) || (i == 0) || (pSynth->pEpoch[i - 1] < 0) )
                {
                    //--------------------------------------
                    // Do static quantization
                    //--------------------------------------
                    for( j = 0; j < m_pInv->FFTSize; j++ ) 
                    {
                        pFFT[j] = 0.0f;
                    }
                    startBin = 1;
                    for( k = 0; k < m_pInv->cNumResBooks; k++ )
                    {
                        VectDim     = m_pInv->ResBook[k].cCodeDim;
                        cNumBins    = VectDim / 2;
                        memcpy( &index, pCurStor, sizeof(char) );
                        pCurStor    += sizeof(char);
                        //------------------------------------------
                        // Uncompress spectrum using 'pResBook'
                        //------------------------------------------
                        pMean = ((float*)((char*)m_pInv + m_pInv->ResBook[k].pData)) + (index * VectDim);
                        PutSpectralBand( pFFT, pMean, startBin, cNumBins, m_pInv->FFTSize );
                        startBin    += cNumBins;
                    }
                }
                else
                {
                    //--------------------------------------
                    // Do delta quantization
                    //--------------------------------------
                    startBin = 1;
                    for( k = 0; k < m_pInv->cNumDresBooks; k++ )
                    {
                        VectDim     = m_pInv->DresBook[k].cCodeDim;
                        cNumBins    = VectDim / 2;
                        memcpy( &index, pCurStor, sizeof(char));
                        pCurStor    += sizeof(char);
                        //------------------------------------------
                        // Uncompress spectrum using 'pDresBook'
                        //------------------------------------------
                        pMean = ((float*)((char*)m_pInv + m_pInv->DresBook[k].pData)) + (index * VectDim);
                        AddSpectralBand( pFFT, pMean, startBin, cNumBins, m_pInv->FFTSize );
                        startBin    += cNumBins;
                    }
                }

                //--------------------------------------------------------
                // Convert quantized FFT back to time residual
                //--------------------------------------------------------
                memcpy( pRes, pFFT, m_pInv->FFTSize * sizeof(float) );          // preserve original for delta residual
                InverseFFT( pRes, m_pInv->FFTSize, m_pInv->FFTOrder, m_pTrig );
                GainDeNormalize( pRes, (long)m_pInv->FFTSize, ((UNALIGNED float*)pSynth->pGain)[i] );
                SetEpochLen( pCurRes, frameSize, pRes, m_pInv->FFTSize );
            }
            else
            {
                //-----------------------------------------------
                // UNVOICED epoch
                // NOTE: Assumes 'm_pGauss' is 1 sec
                //-----------------------------------------------
                Gain = 0.02f * ((UNALIGNED float*)pSynth->pGain)[i];
                if( m_GaussID + frameSize >= m_pInv->SampleRate)
                {
                    m_GaussID = 0;
                }
                //----------------------------------------------------------
                // Generate gaussian random noise for unvoiced sounds
                //----------------------------------------------------------
                for( j = 0; j < frameSize; j++ )
                {
                    pCurRes[j] = Gain * m_pGauss[j + m_GaussID];
                }
                m_GaussID += frameSize;
            }
            // restore whisper
            /*if( (pSynth->pEpoch[i] > 0) && m_fModifiers & BACKEND_BITFLAG_WHISPER)
            {
                pSynth->pEpoch[i] = - pSynth->pEpoch[i];
            }*/
            pCurRes += frameSize;
        }
    }
    

    if( FAILED(hr) )
    {
        //----------------------------------
        // Cleanup allocated memory
        //----------------------------------
        if( pSynth->pEpoch )
        {
            delete pSynth->pEpoch;
            pSynth->pEpoch = NULL;
        }
        if( pSynth->pRes )
        {
            delete pSynth->pRes;
            pSynth->pRes = NULL;
        }
        if( pSynth->pLPC )
        {
            delete pSynth->pLPC;
            pSynth->pLPC = NULL;
        }
    }

    return hr;
} /* CVoiceData::DecompressUnit */





/*****************************************************************************
* CVoiceData::DecompressUnit *
*-------------------------------*
*   Description:
*  Decompress acoustic unit. +++
* 
*   INPUT:
*       UnitID - unit number (1 - 3333 typ)
* 
*   OUTPUT:
*       Fills pSynth if success
*       
********************************************************************** MC ***/
HRESULT CVoiceData::GetUnitDur( ULONG UnitID, float* pDur )
{
    SPDBG_FUNC( "CVoiceData::GetUnitDur" );
    char        *pCurStor;
    float       *pEpoch = NULL;
    long        cBytes, cNumEpochs, i;
    float       totalDur;
    HRESULT     hr = S_OK;
   
    
    totalDur = 0;

    if( UnitID > m_NumOfUnits )
    {
        //--------------------------
        // ID is out of range!
        //--------------------------
        hr = E_INVALIDARG;
    }

    if( SUCCEEDED(hr) )
    {
        //-----------------------------------------
        // Pointer to unit data from inventory
        //-----------------------------------------
        pCurStor = (char*)((char*)m_pInv + m_pUnit[UnitID] );     // Rel to abs

        //---------------------------------
        // Get epoch count - 'cNumEpochs'
        //---------------------------------
        cBytes = sizeof(long);
        memcpy( &cNumEpochs, pCurStor, cBytes );
        pCurStor += cBytes;

        //---------------------------------
        // Get epoch lengths - 'pEpoch'
        //---------------------------------
        pEpoch = new float[cNumEpochs];
        if( pEpoch == NULL )
        {
            hr = E_OUTOFMEMORY;
        }

        if( SUCCEEDED(hr) )
        {
            cBytes = DecompressEpoch( (signed char *) pCurStor, cNumEpochs, pEpoch );
            for( i = 0; i < cNumEpochs; i++)
            {
                totalDur += ABS(pEpoch[i]);
            }
        }
    }
    *pDur = totalDur / 22050;

    //----------------------------------
    // Cleanup allocated memory
    //----------------------------------
    if( pEpoch )
    {
        delete pEpoch;
    }
    return hr;
} /* CVoiceData::GetUnitDur */




/*****************************************************************************
* CVoiceData::DecompressEpoch *
*--------------------------------*
*   Description:
*   Decompress epoch len stream from RLE. Fills 'pEpoch' with lengths. 
*   Returns number of 'rgbyte' src bytes consumed.
*       
********************************************************************** MC ***/
long CVoiceData::DecompressEpoch( signed char *rgbyte, long cNumEpochs, float *pEpoch )
{
    SPDBG_FUNC( "CVoiceData::DecompressEpoch" );
    long    iDest, iSrc;
    
    for( iSrc = 0, iDest = 0; iDest < cNumEpochs; ++iDest, ++iSrc )
    {
        //--------------------------------------
        // Decode RLE for VOICED epochs
        //--------------------------------------
        if( rgbyte[iSrc] == 127 )
        {
            pEpoch[iDest] = 127.0f;
            while( rgbyte[iSrc] == 127 )
            {
                pEpoch[iDest] += rgbyte[++iSrc];
            }
        }
        //--------------------------------------
        // Decode RLE for UNVOICED  epochs
        //--------------------------------------
        else if( rgbyte[iSrc] == - 128 )
        {
            pEpoch[iDest] = - 128.0f;
            while( rgbyte[iSrc] == - 128 )
                pEpoch[iDest] += rgbyte[++iSrc];
        }
        //--------------------------------------
        // No compression here
        //--------------------------------------
        else
        {
            pEpoch[iDest] = rgbyte[iSrc];
        }
    }
    return iSrc;
} /* CVoiceData::DecompressEpoch */



/*****************************************************************************
* LSPCompare *
*------------*
*   Description:
*   QSORT callback
*       
********************************************************************** MC ***/
static  int __cdecl LSPCompare( const void *a, const void *b )
{
    SPDBG_FUNC( "LSPCompare" );

    if( *((PFLOAT) a) > *((PFLOAT) b) ) 
    {
        return 1;
    }
    else if( *((PFLOAT) a) == *((PFLOAT) b) ) 
    {
        return 0;
    }
    else 
    {
        return -1;
    }
} /* LSPCompare */


/*****************************************************************************
* CVoiceData::OrderLSP *
*-------------------------*
*   Description:
*   This routine reorders the LSP frequencies so that they are monotonic
*       
********************************************************************** MC ***/
long CVoiceData::OrderLSP( PFLOAT pLSPFrame, INT cOrder )
{
    SPDBG_FUNC( "CVoiceData::OrderLSP" );
    long i, retCode = true;
    
    for( i = 1; i < cOrder; i++ )
    {
        if( pLSPFrame[i - 1] > pLSPFrame[i] ) 
        {
            retCode = false;
        }
    }
    qsort( (void *) pLSPFrame, (size_t) cOrder, (size_t) sizeof (float), LSPCompare );
        
    return retCode;
} /* CVoiceData::OrderLSP */


/*****************************************************************************
* CVoiceData::LSPtoPC *
*------------------------*
*   Description:
*   Converts line spectral frequencies to LPC predictor coefficients.
*       
********************************************************************** MC ***/
void CVoiceData::LSPtoPC( float *pLSP, float *pLPC, long cOrder, long /*frame*/ )
{
    SPDBG_FUNC( "CVoiceData::LSPtoPC" );
    long        i, j, k, noh;
    double      freq[MAXNO], p[MAXNO / 2], q[MAXNO / 2];
    double      a[MAXNO / 2 + 1], a1[MAXNO / 2 + 1], a2[MAXNO / 2 + 1];
    double      b[MAXNO / 2 + 1], b1[MAXNO / 2 + 1], b2[MAXNO / 2 + 1];
    double      pi, xx, xf;
    
    //----------------------------------
    // Check for non-monotonic LSPs
    //----------------------------------
    for( i = 1; i < cOrder; i++ )
    {
        if( pLSP[i] <= pLSP[i - 1] )
        {
            //-----------------------------
            // Reorder LSPs
            //-----------------------------
            OrderLSP( pLSP, cOrder );
            break;
        }
    }
    
    //--------------------------
    // Initialization
    //--------------------------
    pi = KTWOPI;
    noh = cOrder / 2;
    for( j = 0; j < cOrder; j++ )
    {
        freq[j] = pLSP[j];
    }
    for( i = 0; i < noh + 1; i++ )
    {
        a[i]    = 0.0f;
        a1[i]   = 0.0f;
        a2[i]   = 0.0f;
        b[i]    = 0.0f;
        b1[i]   = 0.0f;
        b2[i]   = 0.0f;
    }
    
    //-------------------------------------
    // LSP filter parameters
    //-------------------------------------
    for( i = 0; i < noh; i++ )
    {
        p[i] = - 2.0 * cos( pi * freq[2 * i] );
        q[i] = - 2.0 * cos( pi * freq[2 * i + 1] );
    }
    
    //-------------------------------------
    // Impulse response of analysis filter
    //-------------------------------------
    xf = 0.0f;
    for( k = 0; k < cOrder + 1; k++ )
    {
        xx = 0.0f;
        if( k == 0 )
        {
            xx = 1.0f;
        }
        a[0] = xx + xf;
        b[0] = xx - xf;
        xf = xx;
        for( i = 0; i < noh; i++ )
        {
            a[i + 1]    = a[i] + p[i] * a1[i] + a2[i];
            b[i + 1]    = b[i] + q[i] * b1[i] + b2[i];
            a2[i]       = a1[i];
            a1[i]       = a[i];
            b2[i]       = b1[i];
            b1[i]       = b[i];
        }
        if( k != 0)
        {
            pLPC[k - 1] = (float) (- 0.5 * (a[noh] + b[noh]));
        }
    }
    
    //-------------------------------------------------------
    // Convert to predictor coefficient array configuration
    //-------------------------------------------------------
    for( i = cOrder - 1; i >= 0; i-- )
    {
        pLPC[i + 1] = - pLPC[i];
    }
    pLPC[0] = 1.0f;
} /* CVoiceData::LSPtoPC */



/*****************************************************************************
* CVoiceData::PutSpectralBand *
*--------------------------------*
*   Description:
*   This routine copies the frequency band specified by StartBin as
*   is initial FFT bin, and containing cNumBins.
*       
********************************************************************** MC ***/
void CVoiceData::PutSpectralBand( float *pFFT, float *pBand, long StartBin, 
                                    long cNumBins, long FFTSize )
{
    SPDBG_FUNC( "CVoiceData::PutSpectralBand" );
    long        j, k, VectDim;
    
    VectDim = 2 * cNumBins;
    for( j = 0, k = StartBin; j < cNumBins; j++, k++ )
    {
        pFFT[k] = pBand[j];
    }
    k = FFTSize - (StartBin - 1 + cNumBins);
    for( j = cNumBins; j < 2 * cNumBins; j++, k++ )
    {
        pFFT[k] = pBand[j];
    }
} /* CVoiceData::PutSpectralBand */


/*****************************************************************************
* CVoiceData::AddSpectralBand *
*--------------------------------*
*   Description:
*   This routine adds the frequency band specified by StartBin as
*   is initial FFT bin, and containing cNumBins, to the existing band.
*       
********************************************************************** MC ***/
void CVoiceData::AddSpectralBand( float *pFFT, float *pBand, long StartBin, 
                                    long cNumBins, long FFTSize )
{
    SPDBG_FUNC( "CVoiceData::AddSpectralBand" );
    long        j, k, VectDim;
    
    VectDim = 2 * cNumBins;
    for( j = 0, k = StartBin; j < cNumBins; j++, k++ )
    {
        pFFT[k] += pBand[j];
    }
    k = FFTSize - (StartBin - 1 + cNumBins);
    for( j = cNumBins; j < 2 * cNumBins; j++, k++ )
    {
        pFFT[k] += pBand[j];
    }
} /* CVoiceData::AddSpectralBand */


/*****************************************************************************
* CVoiceData::InverseFFT *
*---------------------------*
*   Description:
*   Return TRUE if consoants can be clustered.
*   This subroutine computes a split-radix IFFT for real data
*   It is a C version of the FORTRAN program in "Real-Valued
*   Fast Fourier Transform Algorithms" by H. Sorensen et al.
*   in Trans. on ASSP, June 1987, pp. 849-863. It uses half 
*   of the operations than its counterpart for complex data.
*                                   *
*   Length is n = 2^(fftOrder). Decimation in frequency. Result is 
*   in place. It uses table look-up for the trigonometric functions.
* 
*   Input order:                            *
*       (Re[0], Re[1], ... Re[n/2], Im[n/2 - 1]...Im[1])
*   Output order:
*       (x[0], x[1], ... x[n - 1])
*   The output transform exhibit hermitian symmetry (i.e. real
*   part of transform is even while imaginary part is odd).
*   Hence Im[0] = Im[n/2] = 0; and n memory locations suffice.
*       
********************************************************************** MC ***/
void CVoiceData::InverseFFT( float *pDest, long fftSize, long fftOrder, float *sinePtr )
{
    SPDBG_FUNC( "CVoiceData::InverseFFT" );
    long    n1, n2, n4, n8, i0, i1, i2, i3, i4, i5, i6, i7, i8;
    long    is, id, i, j, k, ie, ia, ia3;
    float   xt, t1, t2, t3, t4, t5, *cosPtr, r1, cc1, cc3, ss1, ss3;
    
    cosPtr = sinePtr + (fftSize / 2);
    
    //---------------------------------
    // L shaped butterflies
    //---------------------------------
    n2 = 2 * fftSize;
    ie = 1;
    for( k = 1; k < fftOrder; k++ ) 
    {
        is = 0;
        id = n2;
        n2 = n2 / 2;
        n4 = n2 / 4;
        n8 = n4 / 2;
        ie *= 2;
        while( is < fftSize - 1 ) 
        {
            for( i = is; i < fftSize; i += id ) 
            {
                i1 = i;
                i2 = i1 + n4;
                i3 = i2 + n4;
                i4 = i3 + n4;
                t1 = pDest[i1] - pDest[i3];
                pDest[i1] = pDest[i1] + pDest[i3];
                pDest[i2] = 2 * pDest[i2];
                pDest[i3] = t1 - 2 * pDest[i4];
                pDest[i4] = t1 + 2 * pDest[i4];
                if( n4 > 1 ) 
                {
                    i1 = i1 + n8;
                    i2 = i2 + n8;
                    i3 = i3 + n8;
                    i4 = i4 + n8;
                    t1 = K2 * (pDest[i2] - pDest[i1]);
                    t2 = K2 * (pDest[i4] + pDest[i3]);
                    pDest[i1] = pDest[i1] + pDest[i2];
                    pDest[i2] = pDest[i4] - pDest[i3];
                    pDest[i3] = - 2 * (t1 + t2);
                    pDest[i4] = 2 * (t1 - t2);
                }
            }
            is = 2 * id - n2;
            id = 4 * id;
        }
        ia = 0;
        for( j = 1; j < n8; j++ ) 
        {
            ia += ie;
            ia3 = 3 * ia;
            cc1 = cosPtr[ia];
            ss1 = sinePtr[ia];
            cc3 = cosPtr[ia3];
            ss3 = sinePtr[ia3];
            is = 0;
            id = 2 * n2;
            while( is < fftSize - 1 ) 
            {
                for( i = is; i < fftSize; i += id ) 
                {
                    i1 = i + j;
                    i2 = i1 + n4;
                    i3 = i2 + n4;
                    i4 = i3 + n4;
                    i5 = i + n4 - j;
                    i6 = i5 + n4;
                    i7 = i6 + n4;
                    i8 = i7 + n4;
                    t1 = pDest[i1] - pDest[i6];
                    pDest[i1] = pDest[i1] + pDest[i6];
                    t2 = pDest[i5] - pDest[i2];
                    pDest[i5] = pDest[i2] + pDest[i5];
                    t3 = pDest[i8] + pDest[i3];
                    pDest[i6] = pDest[i8] - pDest[i3];
                    t4 = pDest[i4] + pDest[i7];
                    pDest[i2] = pDest[i4] - pDest[i7];
                    t5 = t1 - t4;
                    t1 = t1 + t4;
                    t4 = t2 - t3;
                    t2 = t2 + t3;
                    pDest[i3] = t5 * cc1 + t4 * ss1;
                    pDest[i7] = - t4 * cc1 + t5 * ss1;
                    pDest[i4] = t1 * cc3 - t2 * ss3;
                    pDest[i8] = t2 * cc3 + t1 * ss3;
                }
                is = 2 * id - n2;
                id = 4 * id;
            }
        }
    }
    //---------------------------------
    // length two butterflies
    //---------------------------------
    is = 0;
    id = 4;
    while( is < fftSize - 1 ) 
    {
        for( i0 = is; i0 < fftSize; i0 += id ) 
        {
            i1 = i0 + 1;
            r1 = pDest[i0];
            pDest[i0] = r1 + pDest[i1];
            pDest[i1] = r1 - pDest[i1];
        }
        is = 2 * (id - 1);
        id = 4 * id;
    }
    //---------------------------------
    // digit reverse counter
    //---------------------------------
    j = 0;
    n1 = fftSize - 1;
    for( i = 0; i < n1; i++ ) 
    {
        if( i < j ) 
        {
            xt = pDest[j];
            pDest[j] = pDest[i];
            pDest[i] = xt;
        }
        k = fftSize / 2;
        while( k <= j )
        {
            j -= k;
            k /= 2;
        }
        j += k;
    }
    for( i = 0; i < fftSize; i++ )
    {
        pDest[i] /= fftSize;
    }
} /* CVoiceData::InverseFFT */


/*****************************************************************************
* CVoiceData::SetEpochLen *
*----------------------*
*   Description:
*   Copy residual epoch to 'OutSize' length from 'pInRes' to 'pOutRes'
*       
********************************************************************** MC ***/
void CVoiceData::SetEpochLen( float *pOutRes, long OutSize, float *pInRes, 
                                long InSize )
{
    SPDBG_FUNC( "CVoiceData::AddSpectralBand" );
    long        j, curFrame;
    
    curFrame = MIN(InSize / 2, OutSize);
    
    //-------------------------------
    // Copy SRC to DEST
    //-------------------------------
    for( j = 0; j < curFrame; j++ )
        pOutRes[j] = pInRes[j];
    //-------------------------------
    // Pad DEST if longer
    //-------------------------------
    for( j = curFrame; j < OutSize; j++ )
        pOutRes[j] = 0.0f;
    //-------------------------------
    // Mix DEST if shorter
    //-------------------------------
    for( j = OutSize - curFrame; j < OutSize; j++ )
        pOutRes[j] += pInRes[InSize - OutSize + j];
} /* CVoiceData::SetEpochLen */


/*****************************************************************************
* CVoiceData::GainDeNormalize *
*--------------------------------*
*   Description:
*   Scale residual to given gain.
*       
********************************************************************** MC ***/
void CVoiceData::GainDeNormalize( float *pRes, long FFTSize, float Gain )
{
    SPDBG_FUNC( "CVoiceData::GainDeNormalize" );
    long        j;
    
    for( j = 0; j < FFTSize; j++ )
    {
        pRes[j] *= Gain;
    }
} /* CVoiceData::GainDeNormalize */


/*****************************************************************************
* CVoiceData::PhonHashLookup *
*-------------------------------*
*   Description:
*   Lookup 'sym' in 'ht' and place its associated value in
*   *val. If sym is not found place its key in *val.
*    RETURN
*   Return  0 indicating we found the 'sym' in the table.
*   Return -1 'sym' is not in ht.
*       
********************************************************************** MC ***/
long CVoiceData::PhonHashLookup(    
                            PHON_DICT   *pPD,   // the hash table
                            char       *sym,    // The symbol to look up
                            long       *val )   // Phon ID
{
    SPDBG_FUNC( "CVoiceData::PhonHashLookup" );
    char            *cp;
    unsigned long   key;
    long            i;
    HASH_TABLE      *ht;
    char            *pStr;
    HASH_ENTRY      *pHE;
    
    ht      = &pPD->phonHash;
    key     = 0;
    i       = -1;
    cp      = sym;
    pHE     = (HASH_ENTRY*)((char*)pPD + ht->entryArrayOffs);        // Offset to Abs address 
    do 
    {
        key += *cp++ << (0xF & i--);
    } 
    while( *cp );
    
    while( true )
    {
        key %= ht->size;
    
        if( pHE[key].obj == 0 ) 
        {
            //------------------------------
            // Not in hash table!
            //------------------------------
            *val = (long) key;
            return -1;
        }
    
        //-------------------------------
        // Offset to Abs address
        //-------------------------------
        pStr = (char*)((char*)pPD + pHE[key].obj);
        if( strcmp(pStr, sym) == 0 ) 
        {
            *val = pHE[key].val;
            return 0;
        }
        key++;
    }
} /* CVoiceData::PhonHashLookup */


/*****************************************************************************
* CVoiceData::PhonToID *
*-------------------------*
*   Description:
*   Return ID from phoneme string.
*       
********************************************************************** MC ***/
long CVoiceData::PhonToID( PHON_DICT *pd, char *phone_str )
{
    SPDBG_FUNC( "CVoiceData::PhonToID" );
    long    phon_id;
    
    if( PhonHashLookup( pd, phone_str, &phon_id ) )
    {
        phon_id = NO_PHON;
    }
    
    return phon_id;
} /* CVoiceData::PhonToID */


/*****************************************************************************
* CVoiceData::PhonFromID *
*---------------------------*
*   Description:
*   Return string from phoneme ID
*       
********************************************************************** MC ***/
char *CVoiceData::PhonFromID( PHON_DICT *pd, long phone_id )
{
    SPDBG_FUNC( "CVoiceData::PhonFromID" );
    char    *strPtr;
    long    *pOffs;
    
    pOffs = (long*)((char*)pd + pd->phones_list);
    strPtr = (char*) ((char*)pd + pOffs[phone_id]);
    return strPtr;
} /* CVoiceData::PhonFromID */


#define CNODE_ISA_LEAF(n)   ((n)->yes < 0)

#define BADTREE_ERROR   (-1)
#define PARAM_ERROR (-2)
#define END_OF_PROD  65535


#define WB_BEGIN    1
#define WB_END      2
#define WB_SINGLE   4
#define WB_WWT      8

#define POS_TYPE    4

#define GET_BIT(p,feat,i,b)                             \
{                                                   \
    (i) = ( (p)+POS_TYPE+(feat)->nstateq ) / 32;        \
    (b) = 1 << ( ((p)+POS_TYPE+(feat)->nstateq ) % 32); \
}

#define GET_RBIT(p,feat,i,b)            \
{                                   \
    GET_BIT(p,feat,i,b);                \
    (i) += (feat)->nint32perq;          \
} 

#define GET_CBIT(p,feat,i,b)            \
{                                   \
    GET_BIT(p,feat,i,b);                \
    (i) += 2 * (feat)->nint32perq;      \
}

/*****************************************************************************
* AnswerQ *
*---------*
*   Description:
*   Tree node test.
*       
********************************************************************** MC ***/
static  _inline long AnswerQ( unsigned short *prod, long *uniq_prod, 
                              long li, long bitpos, long ri, long rbitpos, 
                              long pos, long nint32perProd)
{
    UNALIGNED long *p;
    
    for( ; *prod != END_OF_PROD; prod++ ) 
    {
        p = &uniq_prod[(*prod) * nint32perProd];
        if( ((p[0] & pos) == pos) && (p[li] & bitpos) && (p[ri] & rbitpos) )
        {
            return true;
        }
    }
    return false;
} /* AnswerQ */


/*****************************************************************************
* CVoiceData::GetTriphoneID *
*------------------------------*
*   Description:
*   Retrieve triphone ID from phoneme context.+++
*   Store result into 'pResult'
*       
********************************************************************** MC ***/
HRESULT CVoiceData::GetTriphoneID( TRIPHONE_TREE *forest, 
                        long        phon,           // target phon              
                        long        leftPhon,       // left context
                        long        rightPhon,      // right context
                        long        pos,            // word position ("b", "e" or "s"
                        PHON_DICT   *pd,
                        ULONG       *pResult)
{
    SPDBG_FUNC( "CVoiceData::GetTriphoneID" );
    C_NODE          *cnode, *croot;
    TREE_ELEM       *tree = NULL;
    long            *uniq_prod;
    char            *ll, *rr;
    long            li, bitpos, ri, rbitpos, nint32perProd, c;
    unsigned short  *prodspace;
    FEATURE         *feat;
    long            *pOffs;
    HRESULT         hr = S_OK;
    long            triphoneID = 0;
    
    if( (phon       < 0)    ||  (phon       >= pd->numCiPhones) || 
        (leftPhon   < 0)    ||  (leftPhon   >= pd->numCiPhones) || 
        (rightPhon  < 0)    ||  (rightPhon  >= pd->numCiPhones) )
    {
        //--------------------------------
        // Phon out of range!
        //--------------------------------
        hr = E_INVALIDARG;
    }
    
    if( SUCCEEDED(hr) )
    {
        c = phon;
        tree = &forest->tree[c];
        if( tree->nnodes == 0 )
        {
            //--------------------------------
            // No CD triphones in tree!
            //--------------------------------
            hr = E_INVALIDARG;
        }
    }

    if( SUCCEEDED(hr) )
    {
        if( pos == 'b' || pos == 'B' ) 
        {
            pos = WB_BEGIN;
        }
        else if( pos == 'e' || pos == 'E' ) 
        {
            pos = WB_END;
        }
        else if( pos == 's' || pos == 'S' ) 
        {
            pos = WB_SINGLE;
        }
        else if( pos == '\0' ) 
        {
            pos = WB_WWT;
        }
        else 
        {
            //--------------------------------
            // Unknown word position
            //--------------------------------
            hr = E_INVALIDARG;
        }
    }
    
    if( SUCCEEDED(hr) )
    {
        pOffs = (long*)((char*)pd + pd->phones_list);
        ll = (char*) ((char*)pd + pOffs[leftPhon]);
    
        if( ll[0] == '+' || _strnicmp(ll, "SIL", 3) == 0 )
        {
            leftPhon = forest->silPhoneId;
        }
    
        rr = (char*) ((char*)pd + pOffs[rightPhon]);
        if( rr[0] == '+' || _strnicmp(rr, "SIL", 3) == 0 )      // includes SIL
        {
            rightPhon = forest->silPhoneId;
        }
        else if( forest->nonSilCxt >= 0 && (pos == WB_END || pos == WB_SINGLE) )
        {
            rightPhon = forest->nonSilCxt;
        }
    
        feat = &forest->feat;
        GET_BIT(leftPhon,feat,li,bitpos);
        GET_RBIT(rightPhon,feat,ri,rbitpos);
    
        uniq_prod = (long*)(forest->uniq_prod_Offset + (char*)forest);       // Offset to ABS
        croot = cnode = (C_NODE*)(tree->nodes + (char*)forest);              // Offset to ABS
        nint32perProd = forest->nint32perProd;
    
        while( ! CNODE_ISA_LEAF(cnode) ) 
        {
            prodspace = (unsigned short*)((char*)forest + cnode->prod);      // Offset to ABS
            if( AnswerQ (prodspace, uniq_prod, li, bitpos, ri, rbitpos, pos, nint32perProd) ) 
            {
                cnode = &croot[cnode->yes];
            }
            else 
            {
                cnode = &croot[cnode->no];
            }
        }
        //-----------------------------
        // Return successful result
        //-----------------------------
        triphoneID = (ULONG) cnode->no;
    }
    
    *pResult = triphoneID;
    return hr;
} /* CVoiceData::GetTriphoneID */



/*****************************************************************************
* FIR_Filter *
*------------*
*   Description:
*   FIR filter. For an input x[n] it does an FIR filter with
*   output y[n]. Result is in place. pHistory contains the last
*   cNumTaps values.
*
*   y[n] = pFilter[0] * x[n] + pFilter[1] * x[n - 1]
*   + ... + pFilter[cNumTaps - 1] * x[n - cNumTaps - 1]
*       
 ********************************************************************** MC ***/
void CVoiceData::FIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps )
{
    SPDBG_FUNC( "CVoiceData::FIR_Filter" );
    long     i, j;
    float   sum;
    
    for( i = 0; i < cNumSamples; i++ )
    {
        pHistory[0] = pVector[i];
        sum = pHistory[0] * pFilter[0];
        for( j = cNumTaps - 1; j > 0; j-- )
        {
            sum += pHistory[j] * pFilter[j];
            pHistory[j] = pHistory[j - 1];
        }
        pVector[i] = sum;
    }
} /* CVoiceData::FIR_Filter */





/*****************************************************************************
* IIR_Filter *
*------------*
*   Description:
*   IIR filter. For an input x[n] it does an IIR filter with
*   output y[n]. Result is in place. pHistory contains the last
*   cNumTaps values.
*
*   y[n] = pFilter[0] * x[n] + pFilter[1] * y[n - 1]
*   + ... + pFilter[cNumTaps - 1] * y[n - cNumTaps - 1]
*       
********************************************************************** MC ***/
void CVoiceData::IIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps )
{
    SPDBG_FUNC( "CVoiceData::IIR_Filter" );
    long     i, j;
    float   sum;
    
    for( i = 0; i < cNumSamples; i++ )
    {
        sum = pVector[i] * pFilter[0];
        for( j = cNumTaps - 1; j > 0; j-- )
        {
            pHistory[j] = pHistory[j - 1];
            sum += pHistory[j] * pFilter[j];
        }
        pVector[i] = sum;
        pHistory[0] = sum;
    }
} /* CVoiceData::IIR_Filter */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\perf\ttsperf.cpp ===
/*
 * This file is loosely copied from the performance DLL sample in MSDN.
 *
 * To use performance counters with Whisper on NT:
 *    1) Build a debug build of ttsperf.dll.
 *    2) Run regedit and load ttsperf.reg (Just type "ttsperf.reg" at the command prompt)
 *       (Adjust dll location in .reg file if necessary; default is c:\nt\enduser\speech\tts\ms_entropic\perf\objd\i386\ttsperf.dll)
 *    3) Run "unlodctr ms_entropicengine" if necessary to remove old performance registry values.
 *    3) Run "lodctr ttsperf.ini" from this directory.
 *    4) Run ttsapp (for example).
 *    5) Run Perfmon and add counters under "TTS" object.  One instance will appear for each running decoder.
 *
 * To add new TTS performance counter:
 *    1) Add new perfc #define in ttsperf.h.
 *    2) Add new name and help in ttsperf.ini.
 *    3) Add new details in apc[], below.
 *    4) Call m_pco.SetCounter() or m_pco.IncrementCounter() where necessary to implement counter.
 *    5) Rebuild and reinstall ttsperf.dll as described above to add new counters to registry.
 *
 * To add performance counters to a different application:
 *    1) RTFC
 */

// ttsperf.cpp : Defines the entry point for the DLL application.
//

#include <windows.h>
#include <winperf.h>
#include <stdlib.h>
#include "..\perfmon.h"
#include "ttsperf.h"
#include <crtdbg.h>

#define DIM(array) (sizeof(array)/sizeof((array)[0]))

PerfObject  poTTS = 
               {
                  perfcTTS,        // Name
                  PERF_DETAIL_NOVICE,  // Will this make it harder to find for us?
                  0,                   // Default counter
                  {0,0},               // Perf time -- what is this, anyway?
                  {0,0}                // Perf freq
               };


/*
 * The following array must contain all of the perfc #defines from whisperf.h IN ORDER!
 * Debug builds should complain if this condition is not met.
 */
// BUGBUG Should provide #defines for the scale factors.
PerfCounter apc[] = 
   {
      { perfcSpeakCalls,          DWORD(0), PERF_DETAIL_EXPERT, PERF_COUNTER_RAWCOUNT },
//
// Example of a rate counter (i.e. #/second):
//
//      { perfcFramesPerSec,          DWORD(0),  PERF_DETAIL_EXPERT, PERF_COUNTER_COUNTER  },
   };


CPerfCounterManager  g_pcm;

// BUGBUG: how to get dllexport to not decorate names?
// __declspec(dllexport)   
PM_OPEN_PROC    PerformanceOpen;
PM_COLLECT_PROC PerformanceCollect;
PM_CLOSE_PROC   PerformanceClose;


BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
   switch (ul_reason_for_call)
   {
   case DLL_PROCESS_ATTACH:
   case DLL_THREAD_ATTACH:
   case DLL_THREAD_DETACH:
   case DLL_PROCESS_DETACH:
	   break;
   }
   return TRUE;
}


DWORD APIENTRY PerformanceOpen(LPWSTR lpDeviceNames)
{
   _ASSERTE(perfcMax / 2 - 1 == DIM(apc));

   DWORD status = g_pcm.Init("TTSPerf", DIM(apc), 100);
   if (status != ERROR_SUCCESS)
   {
       DebugBreak();
      return status;
   }

   status = g_pcm.Open(lpDeviceNames, "ms_entropicengine", &poTTS, apc);
   if (status != ERROR_SUCCESS)
   {
       DebugBreak();
   }
   return status;
}

DWORD APIENTRY PerformanceCollect(LPWSTR lpwszValue, LPVOID * lppData, LPDWORD lpcbBytes, LPDWORD lpcObjectTypes)
{
   return g_pcm.Collect(lpwszValue, lppData, lpcbBytes, lpcObjectTypes);
}


DWORD APIENTRY PerformanceClose()
{
   return g_pcm.Close();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\voicedataobj.h ===
/******************************************************************************
* VoiceDataObj.h *
*----------------*
*   This is the header file for the CVoiceDataObj implementation. This object
*   is used to provide shared access to a specific voice data file.
*------------------------------------------------------------------------------
*   Copyright (C) 1999 Microsoft Corporation         Date: 05/06/99
*   All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef VoiceDataObj_h
#define VoiceDataObj_h

//--- Additional includes
#include "ms_entropicengine.h"
#include <spddkhlp.h>
#include <sphelper.h>
#include <MMREG.H>
#include "resource.h"
#include "SpTtsEngDebug.h"

//=== Constants ====================================================
static const long VOICE_VERSION   = 0x10001;
static const long HEADER_VERSION  = 0x10000;
static const long MS_VOICE_TYPE   = MAKEFOURCC('V','o','i','s');
static const long MS_DATA_TYPE    = MAKEFOURCC('D','a','t','a');
static const float SIL_DURATION    = 0.01f;


//=== Class, Enum, Struct and Union Declarations ===================

//------------------------------------
// Selector for 'GetData()'
// For accessing voice data blocks
//------------------------------------
enum VOICEDATATYPE
{   
    MSVD_PHONE,
    MSVD_SENONE,
    MSVD_TREEIMAGE,
    MSVD_INVENTORY,
    MSVD_ALLOID
};

//---------------------------
// VOICEINFO data types
//---------------------------
enum GENDER
{   
    GENDER_NEUTRAL = 0,
    GENDER_FEMALE,
    GENDER_MALE
};
enum COMPRESS_TYPE
{   
    COMPRESS_NONE = 0,
    COMPRESS_LPC
};


// THis is the data 
#pragma pack (1)
struct VOICEINFO
{
    long            Type;               // Always 'MS_VOICE_TYPE'
    ULONG           Version;            // Always 'VOICE_VERSION'
    WCHAR           Copyright[256];     // INFO:
    WCHAR           VoiceName[64];      // INFO:
    WCHAR           Example[64];        // INFO: 
    LCID			LangID;
    GENDER          Gender;             // INFO: Male, female or neuter
    ULONG           Age;                // INFO: Speaker age in years
    ULONG           Rate;               // INFO & FE: Words-per-minute
    ULONG           Pitch;              // INFO & FE: Average pitch in Hz 
    COMPRESS_TYPE   CompressionType;    // BE: Always 'COMPRESS_LPC'
    REVERBTYPE      ReverbType;         // BE: Reverb param
    ULONG           NumOfTaps;          // BE: Whisper param
    float           TapCoefficients[8]; // BE: Whisper param
    ULONG           ProsodyGain;        // FE: 0 = monotone
    float           VibratoFreq;        // Hertz
    ULONG           VibratoDepth;       // 0 - 100%
    ULONG           SampleRate;         // 22050 typical
    GUID            formatID;           // SAPI audio format ID
    long            Unused[4];
};
#pragma pack ()
typedef VOICEINFO *PVOICEINFO;



//---------------------------------------------------
// Header definition for voice data block
//---------------------------------------------------
#pragma pack (1)
struct VOICEBLOCKOFFSETS
{
    long    Type;           // Always 'MS_DATA_TYPE'
    long    Version;        // Always 'HEADER_VERSION'
    GUID    DataID;         // File ID
    long    PhonOffset;     // Offset to PHON block (from beginning of file)
    long    PhonLen;        // Length of PHON block
    long    SenoneOffset;   // Offset to SENONE block (from beginning of file)
    long    SenoneLen;      // Length of SENONE block
    long    TreeOffset;     // Offset to TREE block (from beginning of file)
    long    TreeLen;        // Length of TREE block
    long    InvOffset;      // Offset to INV block (from beginning of file)
    long    InvLen;         // Length of INV block
    long    AlloIDOffset;      // Offset to AlloId block (from beginning of file)
    long    AlloIDLen;         // Length of AlloID block
};
#pragma pack ()


// Single VQ Codebook
#pragma pack (1)
typedef struct Book 
{
    long    cCodeSize;          // Number of codewords
    long    cCodeDim;           // Dimension of codeword
    long    pData;              // Offset to data (INVENTORY rel)
} BOOK, *PBOOK;
#pragma pack ()


static const long BOOKSHELF   = 32;

#pragma pack (1)
typedef struct Inventory 
{
    long        SampleRate;             // Sample rate in Hz
    long        cNumLPCBooks;           // Number of LPC Codebooks
    long        cNumResBooks;           // Number of Residual Codebooks
    long        cNumDresBooks;          // Number of Delta Residual Codebooks
    BOOK        LPCBook[BOOKSHELF];     // LPC Codebook array
    BOOK        ResBook[BOOKSHELF];     // Residual Codebook array
    BOOK        DresBook[BOOKSHELF];    // Delta residual Codebook array
    long        cNumUnits;              // Total number of units
    long        UnitsOffset;            // Offset to offset array to unit data (INVENTORY rel)
    long        cOrder;                 // LPC analysis order
    long        FFTSize;                // Size of FFT
    long        FFTOrder;               // Order of FFT
    long        TrigOffset;             // Offset to sine table (INVENTORY rel)
    long        WindowOffset;           // Offset to Hanning Window (INVENTORY rel)
    long        pGaussOffset;           // Offset to Gaussian Random noise (INVENTORY rel)
    long        GaussID;                // Gaussian sample index
} INVENTORY, *PINVENTORY;
#pragma pack ()

//------------------------
// LPC order * 2
//------------------------
static const long MAXNO   = 40;

static const float KONEPI  = 3.1415926535897931032f;
static const float KTWOPI  = (KONEPI * 2);
static const float K2 = 0.70710678118655f;


#pragma pack (1)
typedef struct 
{
    long    val;                // Phon ID
    long    obj;                // Offset to phon string
} HASH_ENTRY;
#pragma pack ()


#pragma pack (1)
typedef struct 
{
    long        size;               // Number entries in the table (127 typ.)
    long        UNUSED1; 
    long        entryArrayOffs;     // Offset to HASH_ENTRY array
    long        UNUSED2;
    long        UNUSED3;
    long        UNUSED4;
    long        UNUSED5;
} HASH_TABLE;
#pragma pack ()



#pragma pack (1)
typedef struct 
{
    HASH_TABLE      phonHash;
    long            phones_list;    // Offset to offsets to phon strings
    long            numPhones;
    long            numCiPhones;    // Number of context ind. phones
} PHON_DICT;
#pragma pack ()




#pragma pack (1)
typedef struct 
{
    long        nfeat;
    long        nint32perq;
    long        b_ques;
    long        e_ques;
    long        s_ques;
    long        eors_ques;
    long        wwt_ques;
    long        nstateq;
} FEATURE;
#pragma pack ()


#pragma pack (1)
typedef struct
{
    long        prod;           // For leaves, it means the counts.
                                //   For non-leaves, it is the offset 
                                //   into TRIPHONE_TREE.prodspace.
    short       yes;            // Negative means there is no child. so this is a leaf
    short       no;             // for leaves, it is lcdsid
    short       shallow_lcdsid; // negative means this is NOT a shallow leaf
} C_NODE;
#pragma pack ()


#pragma pack (1)
typedef struct 
{
    short       nnodes;
    short       nleaves;
    long        nodes;              // Offset
}TREE_ELEM;




#define NUM_PHONS_MAX   64

#pragma pack (1)
typedef struct 
{
    FEATURE         feat;
    long            UNUSED;                     // PHON_DICT *pd usually
    long            nsenones; 
    long            silPhoneId; 
    long            nonSilCxt; 
    
    long            nclass; 
    long            gsOffset[NUM_PHONS_MAX];    // nclass+1 entries
    
    TREE_ELEM       tree[NUM_PHONS_MAX];
    long            nuniq_prod;                 // not used for detailed tree
    long            uniq_prod_Offset;                   // Offset to table
    long            nint32perProd;
} TRIPHONE_TREE;
#pragma pack ()

static const long NO_PHON     = (-1);

#define ABS(x) ((x) >= 0 ? (x) : -(x))
#define MAX(x,y) (((x) >= (y)) ? (x) : (y))
#define MIN(x,y) (((x) <= (y)) ? (x) : (y))


#pragma pack (1)
typedef struct 
{
    float	dur;
    float	durSD;
    float	amp;
    float	ampRatio;
} UNIT_STATS;
#pragma pack ()



//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================



/*** CVoiceDataObj COM object ********************************
*/
class CVoiceData
{
  /*=== Methods =======*/
  public:
      CVoiceData();
      ~CVoiceData();

  private:
    /*--- Non interface methods ---*/
    HRESULT MapFile(const WCHAR * pszTokenValName, HANDLE * phMapping, void ** ppvData);
    HRESULT GetDataBlock( VOICEDATATYPE type, char **ppvOut, ULONG *pdwSize );
    HRESULT InitVoiceData();
    HRESULT DecompressUnit( ULONG UnitID, MSUNITDATA* pSynth );
    long DecompressEpoch( signed char *rgbyte, long cNumEpochs, float *pEpoch );
    long OrderLSP( PFLOAT pLSPFrame, INT cOrder );
    void LSPtoPC( float *pLSP, float *pLPC, long cOrder, long frame );
    void PutSpectralBand( float *pFFT, float *pBand, long StartBin, 
                          long cNumBins, long FFTSize );
    void AddSpectralBand( float *pFFT, float *pBand, long StartBin, 
                          long cNumBins, long FFTSize );
    void InverseFFT( float *pDest, long fftSize, long fftOrder, float *sinePtr );
    void SetEpochLen( float *pOutRes, long OutSize, float *pInRes, 
                      long InSize );
    void GainDeNormalize( float *pRes, long FFTSize, float Gain );
    long PhonToID( PHON_DICT *pd, char *phone_str );
    char *PhonFromID( PHON_DICT *pd, long phone_id );
    HRESULT GetTriphoneID( TRIPHONE_TREE *forest, 
                        long        phon,           // target phon              
                        long        leftPhon,       // left context
                        long        rightPhon,      // right context
                        long        pos,            // word position ("b", "e" or "s"
                        PHON_DICT   *pd,
                        ULONG       *pResult );
    long PhonHashLookup( PHON_DICT  *pPD,   // the hash table
                         char       *sym,   // The symbol to look up
                         long       *val );  // Phon ID
    void FIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps );
    void IIR_Filter( float *pVector, long cNumSamples, float *pFilter, 
                               float *pHistory, long cNumTaps );
    HRESULT GetUnitDur( ULONG UnitID, float* pDur );
    
    /*=== Interfaces ====*/
  public:
    STDMETHOD(GetVoiceInfo)( MSVOICEINFO* pVoiceInfo );
    STDMETHOD(GetUnitIDs)( UNIT_CVT* pUnits, ULONG cUnits );
    STDMETHOD(GetUnitData)( ULONG unitID, MSUNITDATA* pUnitData );
    STDMETHOD(AlloToUnit)( short allo, long attributes, long* pUnitID );
    STDMETHOD(SetObjectToken)( ISpObjectToken *pToken );

  private:
  /*=== Member Data ===*/
    CComPtr<ISpObjectToken> m_cpToken;
    HANDLE                  m_hVoiceDef;
    HANDLE                  m_hVoiceData;
    VOICEINFO*              m_pVoiceDef;
    VOICEBLOCKOFFSETS*      m_pVoiceData;

    PHON_DICT*      m_pd;
    TRIPHONE_TREE*  m_pForest;
    long*           m_SenoneBlock;
    ULONG           m_First_Context_Phone;
    ULONG           m_Sil_Index;

    // Unit Inventory
    INVENTORY*      m_pInv;
    float           m_SampleRate;
    long            m_cOrder;
    long           *m_pUnit;       // Pointer to offsets to unit data
    float          *m_pTrig;       // Sine table
    float          *m_pWindow;     // Hanning Window
    float          *m_pGauss;      // Gaussian Random noise
    COMPRESS_TYPE   m_CompressionType;
    ULONG           m_FFTSize;
    long            m_GaussID;
    short           *m_AlloToUnitTbl;
    long            m_NumOfAllos;
    ULONG           m_NumOfUnits;	// Inventory size
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\makefile.inc ===
SelfRegister :
!if defined(MAKEDLL)
	regsvr32 /s $(O)\$(TARGETNAME).dll
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\common.h ===
/////////////////////////////////////////////////////////////////////////////
// 
// common.h
//
// Created by JOEM  02-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //

#ifndef _COMMON_H_
#define _COMMON_H_

#include <spddkhlp.h>
#include <spcollec.h>
#include <stdio.h>

#ifdef _WIN32
#include <wchar.h>
#include <windows.h>
#else 
#define OutputDebugStringW puts
#endif

#define MAX_LINE 256

#define SkipWhiteSpace(ptr)    while (*(ptr) && isspace(*(ptr))) {(ptr)++;}
#define SkipNonWhiteSpace(ptr) while (*(ptr) && !isspace(*(ptr))) {(ptr)++;}
#define StringUpperCase(ptr)  { char8* str = (ptr); while (*str) {*str = (char)toupper (*str); str++;} }
#define StringLowerCase(ptr)  { char8* str = (ptr); while (*str) {*str = (char)tolower (*str); str++;} }

#define WSkipWhiteSpace(ptr)    while (*(ptr) && iswspace(*(ptr))) {(ptr)++;}
#define WSkipNonWhiteSpace(ptr) while (*(ptr) && !iswspace(*(ptr))) {(ptr)++;}
#define WStringUpperCase(ptr)  { WCHAR* str = (ptr); while (*str) {*str = towupper (*str); str++;} }
#define WStringLowerCase(ptr)  { WCHAR* str = (ptr); while (*str) {*str = towlower (*str); str++;} }

enum PUNC
{
    KEEP_PUNCTUATION = 0,
    REMOVE_PUNCTUATION = 1
};

//////////////////////////////////////////////////////////////////////
//
// CDynStrArray is a helper class for a hash that contains an array
// of strings for each hash value
//
/////////////////////////////////////////////////////// JOEM 7-2000 //
class CDynStr
{
public:
    CDynStr() {}
    CDynStr(const WCHAR* sz) { dstr = sz; }
    CDynStr(const CSpDynamicString& inDstr) { dstr = inDstr; }
    ~CDynStr() { dstr.Clear(); }
public:
    CSpDynamicString dstr;
};

class CDynStrArray : public IUnknown
{
public:
    CDynStrArray() {}
    ~CDynStrArray() 
    { 
        for ( int i=0; i<m_aDstr.GetSize(); i++ ) 
        {
            m_aDstr[i].dstr.Clear();
        } 
    }

    STDMETHOD(QueryInterface)(const IID& iid, void** ppv) { return S_OK; }
    STDMETHOD_(ULONG, AddRef)() { return 0; }
    STDMETHOD_(ULONG, Release)() { delete this; return 0; }

public:
    CSPArray<CDynStr,CDynStr> m_aDstr;
};


//////////////////////////////////////////////////////////////////////
// CountWords
//
/////////////////////////////////////////////////////// JOEM 7-2000 //
inline USHORT CountWords (const WCHAR* pszText)
{
    int wordNum = 0;
    SPDBG_ASSERT (pszText);
    
    while (*pszText) 
    {
        WSkipWhiteSpace(pszText);
        if (!*pszText) 
        {
            break;
        }
        
        WSkipNonWhiteSpace(pszText);
        wordNum++;
    }
    return (USHORT) wordNum;
}

//////////////////////////////////////////////////////////////////////
// SplitWords
//
// Text will be modified, wordList will be allocated with
// wordCount WCHAR*
//
/////////////////////////////////////////////////////// JOEM 7-2000 //
inline HRESULT SplitWords (WCHAR* text, WCHAR*** wordList, USHORT* wordCount)
{
    SPDBG_FUNC( "SplitWords" );
    HRESULT hr  = S_OK;
    ULONG   i   = 0;
    
    SPDBG_ASSERT (text);
    SPDBG_ASSERT (wordList);
    SPDBG_ASSERT (wordCount);
    
    *wordCount = CountWords (text); 
    
    *wordList = (WCHAR**) calloc (*wordCount, sizeof(**wordList));
    if ( !*wordList )
    {
        hr = E_OUTOFMEMORY;
    }
    
    if ( SUCCEEDED(hr) )
    {
        for (i=0; i<*wordCount; i++) 
        {
            WSkipWhiteSpace (text);
            (*wordList)[i] = text;
            WSkipNonWhiteSpace (text);
            *text++ = L'\0';
        }
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// RemovePunctuation
//
// Text will be modified
//
/////////////////////////////////////////////////////// JOEM 8-2000 //
inline HRESULT RemovePunctuation (WCHAR** wordList, USHORT* wordCount)
{
    SPDBG_FUNC( "RemovePunctuation" );
    HRESULT hr          = S_OK;
    WCHAR*  pszWord     = NULL;
    WCHAR*  psz         = NULL;
    USHORT  i           = 0;
    USHORT  nextItem    = 0;
    USHORT  numSkipped  = 0;
    
    SPDBG_ASSERT (wordList);
    SPDBG_ASSERT (wordCount);
    
    for ( i=0; i<*wordCount; i++ )
    {

        // If the first char is ' or " or ` then get rid of it
        if ( !wcscspn(wordList[i], L"\"'`") )
        {
            psz = wordList[i]+1;
            wcscpy(wordList[i], psz);
            psz = NULL;
        }

        // If the last char is ' or " or ` or one of these .,;:?! then get rid of it.
        // psz points to the last char
        psz = wordList[i] + wcslen(wordList[i]) - 1;
        if ( !wcscspn(psz, L"\"'`.,;:?!") )
        {
            psz[0] = L'\0';
        }
    }

    // reposition the list items, skipping empty strings
    for ( i=0; i<*wordCount; i++ )
    {
        if ( !wcslen(wordList[i]) ) 
        {
            nextItem = i+1;
            while ( nextItem < *wordCount && !wcslen(wordList[nextItem]) )
            {
                nextItem++;
            }
            if ( nextItem < *wordCount )
            {
                wordList[i] = wordList[nextItem];
                wordList[nextItem] = L"";
            }
            else
            {
                break; // out of items
            }
        }
    }

    *wordCount = i;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// AssembleText
//
// ppszText will be allocated.
//
/////////////////////////////////////////////////////// JOEM 7-2000 //
inline HRESULT AssembleText(const int iStartWord, const int iEndWord, WCHAR** ppszWordList, WCHAR** ppszText)
{
    SPDBG_FUNC( "AssembleText" );
    HRESULT hr      = S_OK;
    int     i       = 0;
    int     iStrLen = 0;

    for ( i=iStartWord; i<=iEndWord; i++ )
    {
        iStrLen += wcslen(ppszWordList[i]) + 1;
    }
    
    if ( iStrLen )
    {
        *ppszText = new WCHAR[iStrLen];
        if ( !*ppszText )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            (*ppszText)[0] = L'\0';
            for ( i=iStartWord; i<=iEndWord; i++ )
            {
                wcscat(*ppszText, ppszWordList[i]);
                if ( i < iEndWord ) 
                {
                    wcscat(*ppszText, L" ");
                }
            }
            WStringUpperCase(*ppszText);
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// RegularizeText
//
// Regularizes whitespace, optionally removing punctuation.
//
/////////////////////////////////////////////////////// JOEM 7-2000 //
inline HRESULT RegularizeText(WCHAR* pszText, PUNC removePunc)
{
    SPDBG_FUNC( "RegularizeText" );
    HRESULT hr          = S_OK;
    WCHAR** wordList    = NULL;
    WCHAR*  pszNewText  = NULL;
    USHORT  wordCount   = 0;

    if ( !pszText )
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = SplitWords (pszText, &wordList, &wordCount);
    }

    if ( SUCCEEDED(hr) && removePunc )
    {
        hr = RemovePunctuation(wordList, &wordCount);
    }

    if ( SUCCEEDED(hr) )
    {
        hr = AssembleText(0, wordCount-1, wordList, &pszNewText);
    }

    if ( SUCCEEDED(hr) && pszNewText )
    {
        WStringUpperCase(pszNewText);
        wcscpy(pszText, pszNewText);
    }

    if ( pszNewText )
    {
        delete [] pszNewText;
        pszNewText = NULL;
    }

    if ( wordList )
    {
        free(wordList);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// FindUnicodeControlChar
//
/////////////////////////////////////////////////////// JOEM 7-2000 //
inline WCHAR* FindUnicodeControlChar (WCHAR* pszText)
{
    ULONG i = 0;

    while ( i<wcslen(pszText) && !iswcntrl(pszText[i]) )
    {
        i++;
    }

    if ( i == wcslen(pszText) )
    {
        return NULL;
    }
    else
    {
        return &pszText[i];
    }
}

//////////////////////////////////////////////////////////////////////
// FileExist
//
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
inline bool FileExist(const WCHAR *pszName)
{
    SPDBG_FUNC( "FileExist" );
    FILE* fp;
    
    if ( !pszName || !wcslen(pszName) || ( (fp = _wfopen(pszName, L"r")) == NULL ) ) 
    {
        return false;
    }
    fclose (fp);
    return true;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\dbquery.cpp ===
//////////////////////////////////////////////////////////////////////
// DbQuery.cpp: implementation of the CDbQuery class.
//
// Created by JOEM  03-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 3-2000 //

#include "stdafx.h"
#include "DbQuery.h"
#include "PromptDb.h"
#include <LIMITS>

//////////////////////////////////////////////////////////////////////
// CEquivCost
//
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CEquivCost::CEquivCost()  
{ 
    text = NULL; 
    entry = NULL;
    fTagMatch = true;
}

CEquivCost::CEquivCost(const CEquivCost& old)  
{ 
    if ( text )
    {
        text = wcsdup(old.text);
    }
    else
    {
        text = NULL;
    }

    if ( entry )
    {
        entry = new CPromptEntry(*old.entry);
    }
    else 
    {
        entry = NULL;
    }
    cost = old.cost;
    whereFrom = old.whereFrom;
    fTagMatch = old.fTagMatch;
}

CEquivCost::~CEquivCost() 
{ 
    if ( text )
    {
        free(text);
        text = NULL;
    }
    if ( entry )
    {
        entry->Release();
        entry = NULL;
    }
}

//////////////////////////////////////////////////////////////////////
// CCandidate
//
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CCandidate::CCandidate()
{ 
    equivList     = NULL;
    parent        = NULL; 
    firstPos      = 0;
    lastPos       = 0;
    candMax       = 0;
    candNum       = 0;
	iQueryNum    = 0;

}

CCandidate::CCandidate(const CCandidate& old)
{ 
    CEquivCost* equiv = NULL;

    firstPos    = old.firstPos;
    lastPos     = old.lastPos;
    candMax     = old.candMax;
    candNum     = old.candNum;
    iQueryNum   = old.iQueryNum;

    parent = old.parent;

    if ( old.equivList && old.equivList->GetSize() )
    {
        equivList = new CSPArray<CEquivCost*,CEquivCost*>;

        for (USHORT i=0; i<old.equivList->GetSize(); i++)
        {
            equiv = new CEquivCost( *(*old.equivList)[i] );
            equivList->Add(equiv);
        }
    }
}    

CCandidate::~CCandidate() 
{ 
    USHORT i = 0;

    if ( equivList )
    {
        for ( i=0; i<equivList->GetSize(); i++ )
        {
            if ( (*equivList)[i] )
            {
                delete (*equivList)[i];
                (*equivList)[i] = NULL;
            }
        }
        
        equivList->RemoveAll(); 
        delete equivList;
    }
    parent = NULL;
}    
//////////////////////////////////////////////////////////////////////
// CDbQuery
//
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CDbQuery::CDbQuery()
{
    m_pIDb          = NULL;
    m_pPhoneContext = NULL;
    m_papQueries    = NULL;
    m_pOutputSite   = NULL;
    m_iCurrentQuery = 0;
    m_fAbort        = false;
}

CDbQuery::~CDbQuery()
{
    USHORT i = 0;

    if ( m_pIDb )
    {
        m_pIDb->Release();
        m_pIDb          = NULL;
    }

    // These are just pointers set in CDbQuery::Init and CDbQuery::Query (deallocated elsewhere)
    m_pPhoneContext = NULL;
    m_papQueries    = NULL;

    // To be safe, I'll keep this list deletion here.
    // However, it is generally deleted when CDbQuery::Query calls CDbQuery::Reset
    m_apCandEnd.RemoveAll();

    for ( i=0; i<m_apCandidates.GetSize(); i++ )
    {
        if ( m_apCandidates[i] )
        {
            delete m_apCandidates[i];
            m_apCandidates[i] = NULL;
        }
    }
    m_apCandidates.RemoveAll();
}

//////////////////////////////////////////////////////////////////////
// CDbQuery::Init
//
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::Init(IPromptDb *pIDb, CPhoneContext *pPhoneContext)
{
    SPDBG_FUNC( "CDbQuery::Init" );
    HRESULT hr = S_OK;

    SPDBG_ASSERT(pIDb);
    SPDBG_ASSERT(pPhoneContext);

    m_pIDb = pIDb;
    m_pIDb->AddRef();
    m_pPhoneContext = pPhoneContext;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDbQuery::Reset
//
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::Reset()
{
    SPDBG_FUNC( "CDbQuery::Reset" );
    USHORT i = 0;

    m_iCurrentQuery     = 0;
    m_papQueries        = NULL;

    m_apCandEnd.RemoveAll();

    for ( i=0; i<m_apCandidates.GetSize(); i++ )
    {
        if ( m_apCandidates[i] )
        {
            delete m_apCandidates[i];
            m_apCandidates[i] = NULL;
        }
    }
    m_apCandidates.RemoveAll();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDbQuery::Query
//
// Takes a query list, created in CPromptEng::BuildQueryList, and
// figures out which can be handled with prompts, and which must
// go to TTS.  Computes transition costs between candidate items, 
// and Backtracks the list selecting the minimum cost items.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::Query(CSPArray<CQuery*,CQuery*>* papQueries, double* pdCost, 
                        ISpTTSEngineSite* pOutputSite, bool *fAbort)
{
    SPDBG_FUNC( "CDbQuery::Query" );
    HRESULT hr          = S_OK;
    USHORT i            = 0;
    USHORT j            = 0;
    USHORT unIdSize     = 0;
    const WCHAR* pszId  = NULL;
    WCHAR* pszText      = NULL;
    CQuery* pQuery      = NULL;

    SPDBG_ASSERT(papQueries);
    SPDBG_ASSERT(pOutputSite);

    m_pOutputSite = pOutputSite;
    m_papQueries = papQueries;
    m_fAbort = false;

    for ( i=0; SUCCEEDED(hr) && i < m_papQueries->GetSize(); i++ )
    {
        if ( m_pOutputSite->GetActions() & SPVES_ABORT )
        {
            m_fAbort = true;
            break;
        }

        if ( SUCCEEDED(hr) )
        {
            pQuery = (*m_papQueries)[i];
            m_iCurrentQuery = i;

            if ( !pQuery->m_fSpeak )
            {
                continue;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            if ( pQuery->m_fXML )
            {
                // If the database needs to be changed, do it now.
                if ( pQuery->m_unDbAction )
                {
                    switch ( pQuery->m_unDbAction )
                    {
                    case DB_ADD:
                        if ( !pQuery->m_pszDbPath )
                        {
                            hr = E_INVALIDARG;
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            hr = m_pIDb->AddDb(pQuery->m_pszDbName, pQuery->m_pszDbPath, pQuery->m_pszDbIdSet, DB_LOAD);
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            free( pQuery->m_pszDbName );
                            pQuery->m_pszDbName = NULL;
                        }
                        break;
                        
                    case DB_ACTIVATE:
                        if ( !pQuery->m_pszDbName )
                        {
                            hr = E_INVALIDARG;
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            hr = m_pIDb->ActivateDbName(pQuery->m_pszDbName);
                        }
                        break;
                        
                    case DB_UNLOAD:
                        hr = m_pIDb->UnloadDb(pQuery->m_pszDbName);
                        break;
                    default:
                        break;
                    }
                    continue;
                } // if ( pQuery->m_unDbAction )
                
                // ID search
                else if ( pQuery->m_pszId )
                {
                    hr = SearchId( pQuery->m_pszId );
                    continue;
                }
                else
                {
                    // Any XML besides DATABASE or ID can be ignored here.
                    if ( pQuery->m_fXML == UNKNOWN_XML )
                    {
                        pQuery->m_fTTS = true;
                    }
                    continue;
                }
            } // if ( pQuery->m_fXML )
        } // if ( SUCCEEDED(hr) )
        
        
        // For Text, search in the Db first, then do SearchBackup (for TTS costs)
        if ( SUCCEEDED (hr) )
        {
            if ( !pQuery->m_fTTS )
            {
                hr = SearchText( pQuery->m_pszExpandedText, pQuery->m_paTagList );
                if ( FAILED(hr) )
                {
                    pQuery->m_afEntryMatch.Add(false);
                    if ( pQuery->m_fFragType )
                    {
                        hr = RemoveLocalQueries(i);
                    }
                }
            }
            
            // SearchBackup for TTS items, or if SearchText failed. 
            if ( pQuery->m_fSpeak && ( pQuery->m_fTTS || FAILED(hr) ) )
            {
                pszText = new WCHAR[pQuery->m_pTextFrag->ulTextLen + 1];
                if ( pszText )
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                if ( SUCCEEDED(hr) )
                {
                    wcsncpy(pszText, pQuery->m_pTextFrag->pTextStart, pQuery->m_pTextFrag->ulTextLen);
                    pszText[pQuery->m_pTextFrag->ulTextLen] = L'\0';

                    hr = SearchBackup( pszText );

                    delete pszText;
                    pszText = NULL;
                }
                if ( SUCCEEDED(hr) )
                {
                    pQuery->m_fTTS = true;
                    pQuery->m_afEntryMatch.Add(true);
                }
            }
        }
    } // for ( i=0; i < m_papQueries->GetSize(); i++ )

    // Backtrack, selecting the search items with min. cost
    if ( SUCCEEDED(hr) && !m_fAbort )
    {
        hr = Backtrack( pdCost );
    }

    Reset();

    *fAbort = m_fAbort;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDbQuery::SearchId
//
// Checks the Db for specific Ids, adds them to the candidate list
// for backtracking later (in CDbQuery::Query).
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::SearchId(const WCHAR* pszId)
{
    SPDBG_FUNC( "CDbQuery::SearchId" );
    HRESULT         hr          = S_OK;
    CCandidate*     newCand     = NULL;
    IPromptEntry*   pIPE        = NULL;
    USHORT          i           = 0;

    SPDBG_ASSERT( pszId );

    hr = m_pIDb->FindEntry(pszId, &pIPE);

    if ( SUCCEEDED(hr) )
    {
        newCand = new CCandidate;
        if ( !newCand )
        {
            hr = E_OUTOFMEMORY;
        }
        
        if ( SUCCEEDED(hr) )
        {
            newCand->firstPos   = 0;
            newCand->lastPos    = 0;
            newCand->candMax    = 1;
            newCand->candNum    = 0;
            newCand->parent     = NULL; 
            newCand->iQueryNum = m_iCurrentQuery;
            
            hr = ComputeCostsId (newCand, pIPE); 
        }
        
        if ( SUCCEEDED(hr) )
        {
            m_apCandidates.Add(newCand);
            m_apCandEnd.RemoveAll();
            m_apCandEnd.Add(newCand);
        }
        
        if ( FAILED(hr) && newCand )
        {
            delete newCand;
            newCand = NULL;
        }
        
        pIPE->Release();
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
    
//////////////////////////////////////////////////////////////////////
// CDbQuery::SearchText
//
// Searches the Db for text.  If found, adds the items (with computed
// transition costs) to the candidate list for backtracking later 
// (in CDbQuery::Query).
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::SearchText(WCHAR *pszText, const CSPArray<CDynStr,CDynStr>* tags)
{
    SPDBG_FUNC( "CDbQuery::SearchText" );
    HRESULT hr          = S_OK;
    WCHAR** wordList    = NULL;
    USHORT  wordCount   = 0;
    int     i           = 0; // THIS MUST BE SIGNED
    int     j           = 0; 
    int     k           = 0; 
    bool*   pfSearch    = NULL;

    CSPArray<CCandidate*,CCandidate*>* activeCand;
    CSPArray<CCandidate*,CCandidate*>* tmpCandEnd;
    CCandidate* newCand = NULL;

    hr = SplitWords (pszText, &wordList, &wordCount);

    if ( SUCCEEDED(hr) )
    {
        hr = RemovePunctuation(wordList, &wordCount);
    }

    if ( wordCount <= 0 )
    {
        return hr;
    }

    // These flags turn on the searches that start with word position i
    // A search is later turned on if a previous search ended at i-1.
    pfSearch = new bool[wordCount];
    if ( !pfSearch )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pfSearch[0] = true;  // always do the first search
        for ( i=1; i<wordCount; i++ )
        {
            pfSearch[i] = false;
        }
    }

    // Initialize stack decoder
    if ( SUCCEEDED(hr) )
    {
        activeCand = new CSPArray<CCandidate*,CCandidate*>;
        if ( !activeCand )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    // Get the active candidate list from previous search, if any.
    if ( SUCCEEDED(hr) )
    {
        // Any previous candidates? 
        if ( m_apCandEnd.GetSize() == 0 )
        {
            // No, then start a new cand list from scratch.
            newCand = new CCandidate;
            if ( !newCand )
            {
                hr = E_OUTOFMEMORY;
            }

            if ( SUCCEEDED(hr) )
            {            
                newCand->equivList  = NULL;         // the list of IDs that exist for this text
                newCand->firstPos   = 0;            // the word pos where this cand starts
                newCand->lastPos    = -1;           // the last word pos for this candidate (-1 initially)
                newCand->candMax    = wordCount;    // the max number of cands for this string
                newCand->candNum    = 0;            // the number of cands for this path
                newCand->parent     = NULL;         
                newCand->iQueryNum = m_iCurrentQuery;  // the query number where this cand goes when backtracking
                
                m_apCandidates.Add(newCand);
                activeCand->Add(newCand);
            }
        }
        else
        {
            // Yes, then get the current candEnds and put them on the activeCand list
            CCandidate* tmp = NULL;
            
            for ( i = m_apCandEnd.GetUpperBound(); i >= 0; i--) 
            {
                tmp = m_apCandEnd[i];
                if ( !tmp )
                {
                    hr = E_UNEXPECTED;
                }
                
                if ( SUCCEEDED(hr) )
                {
                    tmp->firstPos  = 0;
                    tmp->lastPos   = -1;
                    tmp->candMax   = wordCount;
                    tmp->candNum   = 0;
                    activeCand->Add(tmp);
                }
            }
        } // else
    } // if ( SUCCEEDED(hr)

    // initialize a temporary candEnd list.
    if ( SUCCEEDED(hr) )
    {
        tmpCandEnd = new CSPArray<CCandidate*,CCandidate*>;
        if ( !tmpCandEnd )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    

    // BEGIN THE SEARCH

    // For each word position (i), search to the end, which is (wordcount - i) searches.
    // e.g., for "A B C":
    // when i==0, search "A", "A B", "A B C"
    // when i==1, search "B", "B C"
    // when i==2, search "C"

    // For each successful search, compute the cost from the previous candEnds, and 
    // for each ID returned by the search.
    // For each ID, keep only the cheapest path.  Discard the rest.
    for ( i=0; SUCCEEDED(hr) && i<wordCount; i++ )
    {
        WCHAR*  tmpStr      = NULL;

        // Only search from this position if a prev. candidate ended at i-1
        if ( !pfSearch[i] )
        {
            continue;
        }

        // each search starts at position i, and has (wordCount - i) searches total.
        for ( j=i; SUCCEEDED(hr) && j<wordCount; j++ )
        {
            // keep going?
            if ( m_pOutputSite->GetActions() & SPVES_ABORT )
            {
                m_fAbort = true;
                break;
            }

            if ( SUCCEEDED(hr) )
            {
                hr = AssembleText( i, j, wordList, &tmpStr );
            }

            // Then, search for it
            if ( SUCCEEDED(hr) )
            {
                HRESULT hrSearch = S_OK;
                USHORT  idCount  = 0;
                //OutputDebugStringW ( L"Searching for: " );
                //OutputDebugStringW (tmpStr);
                //OutputDebugStringW ( L"\n" );
            
                hrSearch = m_pIDb->SearchDb(tmpStr, &idCount); // get a count of the id's to retrieve for this text

                // If the search succeeds, retrieve each ID for this text.
                if ( SUCCEEDED(hrSearch) )
                {
                    const WCHAR*    pszId   = NULL;
                    CSPArray<CDynStr,CDynStr> idList;

                    for ( k=0; k<idCount; k++ )
                    {
                        hr = m_pIDb->RetrieveSearchItem( (USHORT) k, &pszId);
                        if ( SUCCEEDED(hr) && pszId )
                        {
                            idList.Add(pszId);
                            pszId = NULL;
                        }
                    }

                    if ( k == idCount )
                    {
                        if ( j < wordCount-1 )  // if this is not the end, 
                        {
                            pfSearch[j+1] = true;  // activate search for remaining items
                        }
                        //OutputDebugStringW ( L"FOUND!\n" );
                    }
                

                    double dMin = DBL_MAX;
                    double dCand = 0.0;
                    CCandidate* bestCandidate = NULL;
                    CCandidate* current       = NULL;

                    // compute costs from each activeCand that ends where this starts
                    for ( k=0; SUCCEEDED(hr) && k<activeCand->GetSize(); k++ )
                    {
                        // keep going?
                        if ( m_pOutputSite->GetActions() & SPVES_ABORT )
                        {
                            m_fAbort = true;
                            break;
                        }

                        if ( SUCCEEDED(hr) )
                        {
                            current = (*activeCand)[k];
                            if ( current->lastPos != i-1 ) // can the new cand attach to this one?
                            {
                                continue;
                            }
                        }
                        
                        // make a new temporary candidate
                        if ( SUCCEEDED(hr) )
                        {
                            newCand = new CCandidate;
                            if ( !newCand )
                            {
                                hr = E_OUTOFMEMORY;
                                break;
                            }
                        }
                        
                        if ( SUCCEEDED(hr) )
                        {
                            newCand->equivList  = NULL;
                            newCand->firstPos   = i;                // starting search position
                            newCand->lastPos    = j; //+1;              // last word number
                            newCand->candMax    = wordCount - j; 
                            newCand->candNum    = 0;
                            newCand->parent     = current; 
                            newCand->iQueryNum = m_iCurrentQuery;
                        }

                        hr = ComputeCosts(current, newCand, tags, &idList, AS_ENTRY, &dCand);
                        
                        if ( SUCCEEDED(hr) )
                        {
                            // keep the best, delete the rest.
                            if ( dCand < dMin )
                            {
                                delete bestCandidate;
                                bestCandidate = newCand;
                                dMin = dCand;
                            }
                            else
                            {
                                delete newCand;
                                newCand = NULL;
                            }
                        }
                    }

                    if ( SUCCEEDED (hr) && !m_fAbort )
                    {
                        if ( j == wordCount-1 )  // complete candidate 
                        {
                            tmpCandEnd->Add(bestCandidate);
                        }
                        else
                        {
                            activeCand->Add(bestCandidate); // save it so we can search for the rest.
                        }
                        m_apCandidates.Add(bestCandidate);
                    }
                    bestCandidate = NULL;
                    for ( k=0; k<idList.GetSize(); k++ )
                    {
                        idList[k].dstr.Clear();
                    }
                    idList.RemoveAll();
                    
                }  // if ( SUCCEEDED(hrSearch) )

                // reset the search string
                if ( tmpStr )
                {
                    delete [] tmpStr;
                    tmpStr = NULL;
                }

            } // if ( SUCCEEDED(hr) )
        } // for ( j=i; SUCCEEDED(hr) && j<wordCount; j++ )
        
        if ( SUCCEEDED(hr) && !m_fAbort )
        {
            // remove all activeCands with lastPos < i (we're done with searches that start with i)
            for ( j=activeCand->GetUpperBound(); j>=0; j-- )
            {
                CCandidate* temp = (*activeCand)[j];
                if ( temp->lastPos < i )
                {
                    activeCand->RemoveAt( j );  // remove it.
                }
                temp = NULL;
            }
        }
        
    } // for ( i=0; SUCCEEDED(hr) && i<wordCount; i++ )

    if ( SUCCEEDED(hr) && !m_fAbort )
    {
        if ( !tmpCandEnd->GetSize() )
        {
            hr = E_FAIL;
        }
    }

    if ( SUCCEEDED(hr) && !m_fAbort )
    {
        CCandidate* saveCand = NULL;
        m_apCandEnd.RemoveAll();
        
        while ( tmpCandEnd->GetSize() )
        {
            saveCand = (*tmpCandEnd)[tmpCandEnd->GetUpperBound()];
            tmpCandEnd->RemoveAt( tmpCandEnd->GetUpperBound() );
            m_apCandEnd.Add(saveCand);
        }
    }

    if ( SUCCEEDED(hr) && !m_fAbort )
    {
        // now these should be empty.
        SPDBG_ASSERT( !tmpCandEnd->GetSize() );
        SPDBG_ASSERT( !activeCand->GetSize() );
    }

    if ( tmpCandEnd )
    {
        delete tmpCandEnd;
    }
    if ( activeCand )
    {
        delete activeCand;
    }
    if ( wordList )
    {
        free (wordList);
    }
    if ( pfSearch )
    {
        delete [] pfSearch;
        pfSearch = NULL;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDbQuery::SearchBackup
//
// Computes costs for a TTS item, adds it to candidate list for
// backtracking (in CDbQuery::Query).
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::SearchBackup(const WCHAR *pszText)
{
    SPDBG_FUNC( "CDbQuery::SearchBackup" );
    HRESULT hr = S_OK;
    CCandidate* newCand = NULL;
    USHORT i = 0;

    newCand = new CCandidate;
    if ( !newCand )
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        newCand->firstPos   = 0;
        newCand->lastPos    = 0;
        newCand->candMax    = 1;
        newCand->candNum    = 0;
        newCand->parent     = NULL; 
        newCand->iQueryNum = m_iCurrentQuery;
    
        hr = ComputeCostsText (newCand, pszText);
    }

    if ( SUCCEEDED(hr) )
    {
        m_apCandidates.Add(newCand);
        m_apCandEnd.RemoveAll();
        m_apCandEnd.Add(newCand);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


//////////////////////////////////////////////////////////////////////
// CDbQuery::Backtrack
//
// Backtracks the candidate list, keeping items that minimize costs.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::Backtrack(double* pdCost)
{
    SPDBG_FUNC( "CDbQuery::Backtrack" );
    CCandidate* cur     = NULL;
    CEquivCost* equiv   = NULL;
    USHORT      nCand   = 0;
    USHORT      nEquiv  = 0;
    int         minIdx  = 0;
    int         minIdx2 = 0;
    USHORT      i       = 0;
    USHORT      j       = 0;
    double      minCost = 0;

    nCand = (USHORT) m_apCandEnd.GetSize();

    if ( nCand )
    {
        minCost = DBL_MAX;
    }
    
    // Look at the last item in each path, and get the Idx of the path with lowest cost
    for (i=0; i<nCand; i++) 
    {
        cur = m_apCandEnd[i];
        
        if ( cur->equivList )
        {
            nEquiv = (USHORT) cur->equivList->GetSize();
        }
        for (j=0; j<nEquiv; j++) 
        {
            equiv = (*cur->equivList)[j];
            if (equiv->cost < minCost) 
            {
                minCost = equiv->cost;
                minIdx  = i;
                minIdx2 = j;
            }
        }
    }
    
    // Go back through the path and get the items
    if (nCand) 
    {
        cur = m_apCandEnd[minIdx];
        while ( cur && cur->equivList && cur->equivList->GetSize() ) 
        {
            equiv = (*cur->equivList)[minIdx2];
            
            if ( equiv->entry )
            {
                (*m_papQueries)[cur->iQueryNum]->m_apEntry.Add(equiv->entry);
                equiv->entry->AddRef();
                (*m_papQueries)[cur->iQueryNum]->m_afEntryMatch.Add(equiv->fTagMatch);
                (*m_papQueries)[cur->iQueryNum]->m_fTTS = false;
            }
            else
            {
                (*m_papQueries)[cur->iQueryNum]->m_fTTS = true;
            }
            
            minIdx2 = equiv->whereFrom;
            cur = cur->parent;
            equiv = NULL;
        }
    }

    *pdCost = minCost;

    return S_OK;
}
//////////////////////////////////////////////////////////////////////
// CDbQuery::ComputeCosts
//
// Cost computation
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::ComputeCosts(CCandidate *parent, CCandidate *child, const CSPArray<CDynStr,CDynStr>* tags,
                               CSPArray<CDynStr,CDynStr>* idList, const bool asEntry, double *dCandCost)
{
    SPDBG_FUNC( "CDbQuery::ComputeCosts" );
    HRESULT hr                  = S_OK;
    USHORT nEquiv               = 0;
    USHORT nParentEquiv         = 0;
    USHORT i                    = 0;
    USHORT j                    = 0;
    int minIdx                  = 0;
    const WCHAR* id             = NULL;
    double minCost              = 0.0;
    double cost                 = 0.0;
    CEquivCost* curCand         = NULL;
    CEquivCost* prevCand        = NULL;
    IPromptEntry* pIPE          = NULL;
    CSPArray<CEquivCost*,CEquivCost*>* equivList = NULL;

    SPDBG_ASSERT (parent);
    SPDBG_ASSERT (child);
    SPDBG_ASSERT (idList);
    
    nEquiv = (USHORT) idList->GetSize();
    if ( parent->equivList )
    {
        nParentEquiv = (USHORT) parent->equivList->GetSize();
    }

    equivList = new CSPArray<CEquivCost*,CEquivCost*>;
    if ( !equivList )
    {
        hr = E_OUTOFMEMORY;
    }

    for (i=0; i<nEquiv && SUCCEEDED(hr); i++) 
    { 
        curCand = new CEquivCost;
        if ( !curCand )
        {
            hr = E_OUTOFMEMORY;
        }
        
        id = (*idList)[i].dstr;
        
        if ( SUCCEEDED(hr) )
        {
            if ( asEntry )
            {
                hr = m_pIDb->FindEntry(id, &pIPE);

                if ( SUCCEEDED(hr) )
                {
                    hr = CopyEntry(pIPE, &curCand->entry);
                    pIPE->Release();
                }
                
            }
        }

        if ( SUCCEEDED(hr) )
        {
            curCand->cost  = 0.0;
            curCand->whereFrom = -1;
            
            minCost = DBL_MAX;
            minIdx = -1;
        }

        // This is the minimizing loop
        if ( SUCCEEDED(hr) )
        {
            if (nParentEquiv) 
            {
                for (j=0; j<nParentEquiv && SUCCEEDED(hr); j++) 
                {
                    prevCand = (*parent->equivList)[j];
                    
                    SPDBG_ASSERT (prevCand);
                    
                    hr = CostFunction (prevCand, curCand, tags, &cost);

                    if ( SUCCEEDED(hr) )
                    {
                        if (cost < minCost ) 
                        {
                            minCost = cost;
                            minIdx = j;
                        }
                    }
                }
                if ( SUCCEEDED(hr) && minIdx == -1 ) 
                {
                    hr = E_FAIL;
                }
                
            } 
            else 
            {
                hr = CostFunction (prevCand, curCand, tags, &minCost);
            }
        }
        
        if ( SUCCEEDED(hr) )
        {
            curCand->cost      = minCost;
            if ( dCandCost )
            {
                *dCandCost = minCost;
            }
            curCand->whereFrom = minIdx;
            
            equivList->Add(curCand);
        }
        
    } // for

    if ( SUCCEEDED(hr) )
    {
        child->equivList = equivList;
    }
    else
    {
        if ( curCand )
        {
            delete curCand;
            curCand = NULL;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDbQuery::ComputeCostsId
//
// Cost computation
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::ComputeCostsId(CCandidate *child, IPromptEntry* pIPE)
{
    SPDBG_FUNC( "CDbQuery::ComputeCostsId" );
    HRESULT     hr          = S_OK;
    CCandidate* parent      = NULL;
    CCandidate* minParent   = NULL;
    CEquivCost* curCand     = NULL;
    CEquivCost* prevCand    = NULL;
    USHORT      nParent     = 0;
    USHORT      nParentEquiv= 0;
    int         minIdx      = 0;
    double      minCost     = 0.0;
    double      cost        = 0.0;
    USHORT      i           = 0;
    USHORT      j           = 0;
    CSPArray<CEquivCost*,CEquivCost*>* equivList;

    curCand = new CEquivCost;
    if ( !curCand )
    {
        hr = E_OUTOFMEMORY;
    }

    hr = CopyEntry( pIPE, &curCand->entry );

    if ( SUCCEEDED(hr) )
    {
        curCand->cost  = 0.0;
        curCand->whereFrom = -1;
        
        minParent  =  NULL;
        minCost    =  DBL_MAX;
        minIdx     = -1;
        
        nParent = (USHORT) m_apCandEnd.GetSize();
    }

    // This is the minimizing loop
    for (i=0; i<nParent && SUCCEEDED(hr); i++) 
    {        
        parent = m_apCandEnd[i];
        nParentEquiv = (USHORT) parent->equivList->GetSize();
        
        if (nParentEquiv) 
        {
            for ( j=0; j<nParentEquiv; j++ ) 
            {
                prevCand = (*parent->equivList)[j];
                
                hr = CostFunction (prevCand, curCand, NULL, &cost);
                
                if ( SUCCEEDED(hr) )
                {
                    if (cost < minCost ) 
                    {
                        minCost = cost;
                        minIdx = j;
                        minParent = parent;
                    }
                }
            }

            if ( SUCCEEDED(hr) && minIdx == -1 ) 
            {
                hr = E_FAIL;
            }
        } 
        else 
        {
            minCost = 0.0;      
        }
        
        if ( SUCCEEDED(hr) )
        {
            curCand->cost      = minCost;
            curCand->whereFrom = minIdx;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        equivList = new CSPArray<CEquivCost*,CEquivCost*>;
        if (!equivList)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        equivList->Add(curCand);
        child->equivList = equivList;
        child->parent = minParent;
    }

    if ( FAILED(hr) )
    {
        delete curCand;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


//////////////////////////////////////////////////////////////////////
// CDbQuery::ComputeCostsText
//
// Cost computation
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::ComputeCostsText(CCandidate *child, const WCHAR *pszText)
{
    SPDBG_FUNC( "CDbQuery::ComputeCostsText" );
    HRESULT hr           = S_OK;
    USHORT nParent       = 0;
    USHORT nParentEquiv  = 0;
    int minIdx           = 0;
    double minCost       = 0.0;
    double cost          = 0.0;
    USHORT i             = 0;
    USHORT j             = 0;
    CEquivCost* curCand  = NULL;
    CEquivCost* prevCand = NULL;
    CCandidate* parent   = NULL;
    CCandidate* minParent= NULL;
    CSPArray<CEquivCost*,CEquivCost*>* equivList;

    SPDBG_ASSERT (child);
    SPDBG_ASSERT (pszText);

    equivList = new CSPArray<CEquivCost*,CEquivCost*>;
    if ( !equivList )
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        curCand = new CEquivCost;
        if ( !curCand )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( SUCCEEDED(hr) )
    {
        curCand->cost           = 0.0;
        curCand->whereFrom      = -1;
        curCand->text = wcsdup(pszText);
        if ( !curCand->text )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        minParent = NULL;
        minCost   = DBL_MAX;
        minIdx    = -1;
        
        nParent = (USHORT) m_apCandEnd.GetSize();
    }

    if ( !nParent )
    {
        hr = CostFunction (NULL, curCand, NULL, &cost);
        if ( SUCCEEDED(hr) )
        {
            curCand->cost      = cost;
            curCand->whereFrom = minIdx;
        }
    }
    else
    {
        // This is the minimizing loop
        for (i=0; i<nParent && SUCCEEDED(hr); i++) 
        {
            parent = m_apCandEnd[i];
            nParentEquiv = (USHORT) parent->equivList->GetSize();
            
            if (nParentEquiv) 
            {            
                for (j=0; j<nParentEquiv; j++) 
                {
                    prevCand = (*parent->equivList)[j];
                    
                    hr = CostFunction (prevCand, curCand, NULL, &cost);
                    
                    if ( SUCCEEDED(hr) )
                    {
                        if (cost < minCost ) 
                        {
                            minCost = cost;
                            minIdx = j;
                            minParent = parent;
                        }
                    }
                }
                
                if ( SUCCEEDED(hr) && minIdx == -1 ) 
                {
                    hr = E_FAIL;            
                }
                
            } 
            else 
            {
                minCost = 0.0;      
            }
            
            if ( SUCCEEDED(hr) )
            {
                curCand->cost      = minCost;
                curCand->whereFrom = minIdx;
            }
        }
    }
    if ( SUCCEEDED(hr) )
    {
        equivList->Add(curCand);
        child->equivList = equivList;
        child->parent = minParent;
    }
    else
    {
        if ( curCand )
        {
            delete curCand;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


//////////////////////////////////////////////////////////////////////
// CDbQuery::CostFunction
//
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CDbQuery::CostFunction(CEquivCost *prev, CEquivCost *cur, const CSPArray<CDynStr,CDynStr>* tags, double *cost)
{
    SPDBG_FUNC( "CDbQuery::CostFunction" );
    HRESULT hr  = S_OK;

    SPDBG_ASSERT (cur);
    SPDBG_ASSERT (cost);

    if ( prev )
    {
        *cost = prev->cost;
    }
    else
    {
        *cost = 0.0;
    }

    // Cost of using TTS 
    if ( cur->text ) 
    {   
        if ( prev )
        {
            // if we're transitioning from prompts, add the transition cost + TTS insert cost.
            if ( prev->entry )
            {
                *cost += FIXED_TRANSITION_COST; // Fixed cost for a transition
                *cost += TTS_INSERT_COST; // * CountWords (cur->text);
            }
        }
        else // otherwise, just add the TTS cost
        {
            *cost += TTS_INSERT_COST; // * CountWords (cur->text);
        }
    } 
    else // Cost of using an entry;
    {
        double tagCost  = MATCHING_TAG_COST;
        USHORT nEntryTags = 0;

        if ( prev ) 
        {
            *cost += FIXED_TRANSITION_COST; // Fixed cost for a transition 
        }
        
        cur->entry->CountTags(&nEntryTags);

        if ( !tags )
        {
            if ( nEntryTags )
            {
                *cost += NON_MATCHING_TAG_COST;
                cur->fTagMatch = false;
            }
        }
        else
        {
            USHORT i        = 0;
            CSpDynamicString curTag;
            USHORT nTags = (USHORT) tags->GetSize();

            for (i=0; i<nTags && SUCCEEDED(hr); i++) 
            {
                curTag = (*tags)[i].dstr;
                const WCHAR* emptyTag = L"";
                
                if ( nEntryTags ) 
                {
                    const WCHAR* entryTag   = NULL;
                    USHORT j                = 0;
                    
                    for (j=0; j< nEntryTags; j++) 
                    {
                        hr = cur->entry->GetTag(&entryTag, j);
                        if ( SUCCEEDED(hr) )
                        {
                            if ( wcscmp(curTag, entryTag) == 0 ) 
                            {
                                entryTag = NULL;
                                break;
                            }
                            entryTag = NULL;
                        }
                    }
                    if (j == nEntryTags) 
                    {
                        tagCost = NON_MATCHING_TAG_COST;
                        cur->fTagMatch = false;
                    }
                } 
                //--- An empty curTag should still match with an entry that has no tags
                else if ( wcscmp(curTag,emptyTag) != 0 )            
                {
                    tagCost = NON_MATCHING_TAG_COST;
                    cur->fTagMatch = false;
                }
                
                *cost += tagCost;
                curTag.Clear();
            } // for each tag
        }
    } // else

    // If there is information about phonetic
    // context, apply it
    if ( SUCCEEDED(hr) )
    {
        if ( m_pPhoneContext && prev && prev->entry && cur->entry ) 
        { 
            double cntxtCost;
            
            hr = m_pPhoneContext->Apply( prev->entry, cur->entry, &cntxtCost );
            if ( SUCCEEDED (hr) ) 
            {
                *cost += cntxtCost;   
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDbQuery::CopyEntry
//
// Creates and returns a copy of the entry pointed to by pIPE.
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
HRESULT CDbQuery::CopyEntry(IPromptEntry *pIPE, CPromptEntry** inEntry)
{
    SPDBG_FUNC( "CDbQuery::CopyEntry" );
    HRESULT hr              = S_OK;
    double entryTime        = 0.0;
    const WCHAR* entryText  = NULL;
    USHORT i                = 0;
    USHORT tagCount         = 0;

    CPromptEntry* newEntry = new CPromptEntry ( *(CPromptEntry*)pIPE );
    if ( !newEntry )
    {
        hr = E_OUTOFMEMORY;
    }

    *inEntry = newEntry;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDbQuery::RemoveLocalQueries
//
// When a local query (from an expansion rule) fails, remove all
// associated local queries, and reinstate the main query.
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
HRESULT CDbQuery::RemoveLocalQueries(const USHORT unQueryNum)
{
    SPDBG_FUNC( "CDbQuery::RemoveLocalQueries" );
    SHORT   i       = 0;
    CQuery* pQuery   = NULL;

    // Take care of current query first
    pQuery = (*m_papQueries)[unQueryNum];
    // If it's a local query, cancel it and the surrounding local queries,
    // and restoring the original for TTS.
    if ( pQuery->m_fFragType == LOCAL_FRAG )
    {
        pQuery->m_fSpeak = FALSE;
        
        // step backward, flagging previous local queries as "don't speak"
        for ( i = unQueryNum-1; i>=0; i-- )
        {
            pQuery = (*m_papQueries)[i];
            if ( pQuery->m_fFragType == LOCAL_FRAG )
            {
                pQuery->m_fSpeak = false;
            }
            else
            {
                break;
            }
        }

        // step forward, flagging upcoming local queries as "don't speak"
        for ( i = unQueryNum+1; i<m_papQueries->GetSize(); i++ )
        {
            pQuery = (*m_papQueries)[i];
            if ( pQuery->m_fFragType == LOCAL_FRAG )
            {
                pQuery->m_fSpeak = false;
            }
            else
            {
                pQuery->m_fSpeak = true;
                pQuery->m_fTTS   = true;
                // this wasn't supposed to be spoken, but now it must, so match is false.
                pQuery->m_afEntryMatch.Add(false);
                break;
            }
        }
    }
    else // It's a combined frag - restore upcoming combined frags too.
    {
        pQuery->m_fTTS = true;
        for ( i = unQueryNum+1; i<m_papQueries->GetSize(); i++ )
        {
            pQuery = (*m_papQueries)[i];
            if ( pQuery->m_fFragType == COMBINED_FRAG )
            {
                pQuery->m_fFragType = SAPI_FRAG;
                pQuery->m_fSpeak = true;
                pQuery->m_fTTS = true;
            }
            else
            {
                break;
            }
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\dbquery.h ===
//////////////////////////////////////////////////////////////////////
// DbQuery.h: interface for the CDbQuery class.
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#if !defined(AFX_DBQUERY_H__04A8E1B8_BCD4_4ABB_AC71_BDC0A04B9E98__INCLUDED_)
#define AFX_DBQUERY_H__04A8E1B8_BCD4_4ABB_AC71_BDC0A04B9E98__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "MSPromptEng.h"
#include "Query.h"
#include "PhoneContext.h"
#include <spcollec.h>

// COSTS FOR DYNAMIC PROGRAMMING
#define FIXED_TRANSITION_COST       1.0
#define MATCHING_TAG_COST           0.0
#define NON_MATCHING_TAG_COST      10.0
#define TTS_INSERT_COST           100.0

#define AS_ENTRY true
#define AS_TTS   false

// TWO HELPER CLASSES
// This is the structure used to 
// hold the network of candidates 
// for the Dynamic Programing search
// These were just structs (in vapi), but need copy constr.
class CEquivCost 
{
public:
    CEquivCost();
    CEquivCost(const CEquivCost& old);
    ~CEquivCost();
    WCHAR* text;
    CPromptEntry* entry;
    double  cost; /* Array length: idCand.size */
    bool fTagMatch;  // test hook:  false=tags mismatch, true=tags matched
    int   whereFrom;
};

class CCandidate 
{
public:
    CCandidate();
    CCandidate(const CCandidate& old);
    ~CCandidate();
    int firstPos;
    int lastPos;
    int candMax;
    int candNum;
	int iQueryNum;
    CSPArray<CEquivCost*,CEquivCost*>* equivList;
    CCandidate* parent;
};


// This is the main class for handling the query list, searching
// the database, and computing transition costs.
class CDbQuery  
{
public:
	CDbQuery();
	~CDbQuery();
public:
	HRESULT Init(IPromptDb* pIDb, CPhoneContext* pPhoneContext);
    HRESULT Query(CSPArray<CQuery*,CQuery*>* papQueries, double* pdCost, 
        ISpTTSEngineSite* pOutputSite, bool *fAbort);
	HRESULT Reset();

private:
    HRESULT SearchId(const WCHAR* pszId);
	HRESULT SearchBackup(const WCHAR* pszText);
    HRESULT SearchText(WCHAR* pszText, const CSPArray<CDynStr,CDynStr>* tags);
	HRESULT Backtrack(double* pdCost);
	HRESULT ComputeCostsText(CCandidate* child, const WCHAR* pszText);
	HRESULT ComputeCosts(CCandidate* parent, CCandidate* child, const CSPArray<CDynStr,CDynStr>* tags, 
        CSPArray<CDynStr,CDynStr>* idList, const bool asEntry, double* dCandCost);
	HRESULT ComputeCostsId(CCandidate* child, IPromptEntry* pIPE);
	HRESULT CostFunction(CEquivCost* prev, CEquivCost* cur, const CSPArray<CDynStr,CDynStr>* tags, 
        double* cost);
	HRESULT RemoveLocalQueries(const USHORT unQueryNum);
	HRESULT CopyEntry(IPromptEntry* pIPE, CPromptEntry** inEntry );

private:
	int                                 m_iCurrentQuery;
	CPhoneContext*                      m_pPhoneContext;
	IPromptDb*                          m_pIDb;
    ISpTTSEngineSite*                   m_pOutputSite;
    CSPArray<CQuery*,CQuery*>*          m_papQueries;
    CSPArray<CCandidate*,CCandidate*>   m_apCandidates;
    CSPArray<CCandidate*,CCandidate*>   m_apCandEnd;
    bool                                m_fAbort;
};

#endif // !defined(AFX_DBQUERY_H__04A8E1B8_BCD4_4ABB_AC71_BDC0A04B9E98__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\ms_entropic\regvoices\regvoices.cpp ===
#include <windows.h>
#include <atlbase.h>
#include "sapi.h"
#include "sphelper.h"
#include "spddkhlp.h"
#include "ms_entropicengine.h"
#include "ms_entropicengine_i.c"
#include "spcommon.h"
#include "spcommon_i.c"
#include <spunicode.h>
#include <io.h>

#include "ms1033ltsmap.h" 

// This code does not ship

// This code creates the registry entries for the TTS voices. The
// datafiles registered here are the ones checked in the slm source tree. This is not
// done using a reg file because we need to compute the absolute path of the datafiles
// which can be different on different machines because of different root slm directories.
// BUGBUG: Check out the ATL UpdateRegistryFromResource et al. and see whether you could
// use them instead, a la RegSR.  That seems much easier.

#define DIRS_TO_GO_BACK_MSVOICE    5        // Back 5 levels and up 2 to "Voices" directory
#define DIRS_TO_GO_BACK_LEX        6        // Back 6 levels and up 1 to Lex Data directory
#define DIRS_TO_GO_BACK_ENTVOICE   5        // Back 5 levels and up 2 to "Voices" directory

CSpUnicodeSupport g_Unicode;

/*****************************************************************************
* CreateLexSubKey  *
*------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateLexSubKey(
    ISpObjectToken * pToken,
    const WCHAR * pszSubKeyName,
    const CLSID * pclsid,
    const WCHAR * pszFilePath, 
    const WCHAR * pszLexName,
    const WCHAR * pszPhoneMap)
{
    HRESULT hr = S_OK;

    //---------------------------------------
    // Create the lex sub-key (Lex or LTS)
    //---------------------------------------
    CComPtr<ISpObjectToken> cpSubToken;
    hr = SpGetSubTokenFromToken(pToken, pszSubKeyName, &cpSubToken, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                cpSubToken, 
                pclsid, 
                NULL,
                0,
                NULL,
                NULL);
    }
    
    WCHAR szLexDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Lex DATA file location
        //--------------------------------
        wcscpy(szLexDataPath, pszFilePath);
        wcscat(szLexDataPath, pszLexName);

        hr = cpSubToken->SetStringValue(L"DataFile", szLexDataPath);
    }

    if (SUCCEEDED(hr) && pszPhoneMap)
    {
        CComPtr<ISpObjectToken> cpPhoneToken;

        if (SUCCEEDED(hr))
            hr = SpGetSubTokenFromToken(cpSubToken, L"PhoneConverter", &cpPhoneToken, TRUE);

        if (SUCCEEDED(hr))
            hr = SpSetCommonTokenData(cpPhoneToken, &CLSID_SpPhoneConverter, NULL, 0, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = cpPhoneToken->SetStringValue(L"PhoneMap", pszPhoneMap);
    }

    return hr;
}

/*****************************************************************************
* CreateUISubKey  *
*-----------------*
*   Description:
*   Creates the UI SubKey under a voice.
*       
********************************************************************** AH ***/
HRESULT CreateUISubKey(
    ISpObjectToken * pToken,
    const CLSID * pclsid)
{
    HRESULT hr = S_OK;

    //-----------------------
    // Create the UI sub-key 
    //-----------------------
    CComPtr<ISpObjectToken> cpSubToken;
    hr = SpGetSubTokenFromToken(pToken, L"UI", &cpSubToken, TRUE);

    //--------------------------------------
    // Create the EngineProperties sub-key
    //--------------------------------------
    CComPtr<ISpObjectToken> cpSubSubToken;
    if ( SUCCEEDED( hr ) )
    {
        hr = SpGetSubTokenFromToken( cpSubToken, L"EngineProperties", &cpSubSubToken, TRUE );
    }

    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                cpSubSubToken, 
                pclsid, 
                NULL,
                0,
                NULL,
                NULL);
    }

    return hr;
}

/*****************************************************************************
* CreateVoiceSubKey  *
*--------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateVoiceSubKey(
    const WCHAR * pszSubKeyName, 
    const WCHAR * pszDescription,
    const WCHAR * pszEntVoicePath,
    const WCHAR * pszEntVoiceName,
    const WCHAR * pszLexPath,
    const WCHAR * pszGender,
    const WCHAR * pszAge,
    BOOL          fUseNamesLTS )
{
    HRESULT hr;

    CComPtr<ISpObjectToken> cpToken;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    hr = SpCreateNewTokenEx(
            SPCAT_VOICES, 
            pszSubKeyName, 
            &CLSID_MSE_TTSEngine, 
            pszDescription,
            0x409,
            pszDescription,
            &cpToken,
            &cpDataKeyAttribs);

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Name", pszDescription);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Vendor", L"Microsoft");
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Language", L"409;9");
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = cpDataKeyAttribs->SetStringValue( L"Gender", pszGender );
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = cpDataKeyAttribs->SetStringValue( L"Age", pszAge );
    }

    WCHAR szVoiceDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Entropic Sfont file location
        //--------------------------------
        wcscpy(szVoiceDataPath, pszEntVoicePath);
        wcscat(szVoiceDataPath, L"\\");
        wcscat(szVoiceDataPath, pszEntVoiceName);

        hr = cpToken->SetStringValue(L"Sfont", szVoiceDataPath);
    }

    //------------------------------------------------
    // Register TTS lexicons
    //------------------------------------------------
    if (SUCCEEDED(hr))
    {
        hr = CreateLexSubKey(cpToken, L"Lex", &CLSID_SpCompressedLexicon, pszLexPath, L"LTTS1033.LXA", NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = CreateLexSubKey(cpToken, L"LTS", &CLSID_SpLTSLexicon, pszLexPath, L"r1033tts.lxa", pszms1033ltsmap);
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = CreateLexSubKey( cpToken, L"Names", &CLSID_SpLTSLexicon, pszLexPath, L"n1033tts.lxa", pszms1033namesltsmap );
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = CreateUISubKey( cpToken, &CLSID_SpTtsEngUI );
    }

    return hr;
}

/*****************************************************************************
* main  *
*-------*
*   Description:
*    Locate the abs path to the Mary, Mike and Sam voices
*    and register them in the system registry.
*       
********************************************************************** MC ***/
int _tmain( int argc )
{
    HRESULT hr = S_OK;

    CoInitialize(NULL);

    bool fUseNamesLTS = ( argc == 1 ? false : true );

    //----------------------------------------
    // Get the exe's location...
    //----------------------------------------
    WCHAR szLexDataPath[MAX_PATH];
    if (!g_Unicode.GetModuleFileName(NULL, szLexDataPath, MAX_PATH))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    WCHAR szEntropicVoiceDirectoryPath[MAX_PATH];
    if ( SUCCEEDED( hr ) )
    {
        wcscpy( szEntropicVoiceDirectoryPath, szLexDataPath );
    }

    //----------------------------------------
    // Derive abs path to LEX data
    //----------------------------------------
    if (SUCCEEDED(hr))
    {
        // modulename is "<sapi5>\Src\TTS\ms_entropic\voices\RegVoices\debug_x86\RegVoices.exe"
        // Data is at    "<sapi5>\Src\lexicon\data\"
        WCHAR * psz = szLexDataPath;
        for (int i = 0; i < DIRS_TO_GO_BACK_LEX; i++)
        {
            psz = wcsrchr(psz, '\\');
            if (!psz)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                *psz = 0;
                psz = szLexDataPath;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        wcscat(szLexDataPath, L"\\src\\lexicon\\data\\");
    }

    //----------------------------------------
    // Derive abs path to Entropic Voice Data
    //----------------------------------------
    if ( SUCCEEDED( hr ) )
    {
        WCHAR * psz = szEntropicVoiceDirectoryPath;
        for ( int i = 0; i < DIRS_TO_GO_BACK_ENTVOICE; i++ )
        {
            psz = wcsrchr( psz, '\\' );
            if ( !psz )
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                *psz = 0;
                psz = szEntropicVoiceDirectoryPath;
            }
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        wcscat( szEntropicVoiceDirectoryPath, L"\\truetalk\\voices\\*" );
    }    

    //------------------------------------------------------
    // Loop over directories in Entropic Voices Directory
    //------------------------------------------------------
    struct _wfinddata_t voicefont_directory;
    long   hDirectory;

    //--- Find first directory...
    hDirectory = _wfindfirst( szEntropicVoiceDirectoryPath, &voicefont_directory );

    if ( hDirectory > 0 )
    {
        do {
            //--- Make sure it's a directory
            if ( wcscmp( voicefont_directory.name, L"." ) &&
                 wcscmp( voicefont_directory.name, L".." ) &&
                 voicefont_directory.attrib & _A_SUBDIR )
            {
                struct _wfinddata_t voicefont_name;
                long hFile;
                WCHAR szDirectory[MAX_PATH] = L"";

                wcscat( szDirectory, szEntropicVoiceDirectoryPath );
                szDirectory[ wcslen( szDirectory ) - 1 ] = 0;
                wcscat( szDirectory, voicefont_directory.name );
                wcscat( szDirectory, L"\\*.sfont" );

                hFile = _wfindfirst( szDirectory, &voicefont_name );
                
                if ( hFile > 0 )
                {
                    WCHAR * psz = szDirectory;
                    psz = wcsrchr( psz, '\\' );
                    *psz = 0;

                    do 
                    {
                        WCHAR Name[MAX_PATH];
                        wcscpy( Name, voicefont_directory.name );
                        wcscat( Name, L"_" );
                        wcscat( Name, voicefont_name.name );

                        psz = Name;
                        psz = wcsrchr( psz, '.' );
                        *psz = 0;

                        WCHAR Gender[7];
                        if ( wcsstr( Name, L"simon" ) )
                        {
                            wcscpy( Gender, L"Male" );
                        }
                        else
                        {
                            wcscpy( Gender, L"Female" );
                        }
                        
                        //--- Register this voice!
                        hr = CreateVoiceSubKey( Name, Name, szDirectory, voicefont_name.name,
                                                szLexDataPath, Gender, L"Adult", fUseNamesLTS );
                    }
                    while ( _wfindnext( hFile, &voicefont_name ) == 0 );
                }
            }
        }
        while ( _wfindnext( hDirectory, &voicefont_directory ) == 0 );
    }

    CoUninitialize();

    if (FAILED(hr))
        return -1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\hash.cpp ===
//////////////////////////////////////////////////////////////////////
// Hash.cpp: implementation of the CHash class.
//
// Created by JOEM  03-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 3-2000 //

#include "stdafx.h"
#include "Hash.h"
#include "common.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
/////////////////////////////////////////////////////// JOEM 3-2000 //
CHashNode::CHashNode()
{
    m_pszKey = NULL;
    m_pValue = NULL;
    m_pNext  = NULL;
}

CHashNode::~CHashNode()
{
    if ( m_pszKey )
    {
        free(m_pszKey);
        m_pszKey = NULL;
    }
    if ( m_pValue )
    {
        m_pValue->Release();
        m_pValue = NULL;
    }
    if ( m_pNext )
    {
        delete m_pNext;
        m_pNext = NULL;
    }
}



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
/////////////////////////////////////////////////////// JOEM 3-2000 //
CHash::CHash()
{
    memset (m_heads, 0, sizeof(m_heads));
}

//////////////////////////////////////////////////////////////////////
// CHash
/////////////////////////////////////////////////////// JOEM 3-2000 //
CHash::~CHash()
{
    for (int i=0; i < HASH_SIZE; i++) 
    {
        if (m_heads[i]) 
        {
            delete m_heads[i];
        }
    }
}

//////////////////////////////////////////////////////////////////////
// CHash
//
// BuildEntry
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CHash::BuildEntry(const WCHAR* pszKey, IUnknown* pValue)
{
    SPDBG_FUNC( "CHash::BuildEntry" );
    HRESULT     hr          = S_OK;
    CHashNode*  pNewNode    = NULL;
    CHashNode*  pTempNode   = NULL;
    CHashNode*  pLastNode   = NULL;
    int         iIndex;

    SPDBG_ASSERT (pszKey);
    SPDBG_ASSERT (pValue);

    if (pszKey && *pszKey) 
    {
        
        iIndex    = HashValue((WCHAR*)pszKey);
        pTempNode = m_heads[iIndex]; 
        
        // Look for the key, see if we already have an entry 
        while (pTempNode) 
        {
            if ( wcscmp(pTempNode->m_pszKey, pszKey) == 0) 
            {
                 break;
            }
            pLastNode = pTempNode;
            pTempNode = pTempNode->m_pNext;
        }

        // If there is an entry, report error
        if (pTempNode)
        {
            hr = E_INVALIDARG;
        }
        
        if ( SUCCEEDED(hr) )
        {
            pNewNode = new CHashNode;
            if ( !pNewNode )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            if ( (pNewNode->m_pszKey = wcsdup (pszKey)) == NULL ) 
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            pNewNode->m_pValue = pValue;
            pValue->AddRef();
            
            if (pLastNode) 
            {
                pLastNode->m_pNext = pNewNode;
            }
            else 
            {
                m_heads[iIndex] = pNewNode;
            }
        }

        if ( FAILED(hr) && pNewNode )
        {
            free (pNewNode);
            pNewNode = NULL;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CHash
//
// DeleteEntry
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CHash::DeleteEntry(const WCHAR *pszKey)
{
    SPDBG_FUNC( "CHash::DeleteEntry" );
    HRESULT     hr          = E_INVALIDARG;
    CHashNode*  pTempNode   = NULL;
    CHashNode*  pLastNode   = NULL;
    int         iIndex;
    
    SPDBG_ASSERT (pszKey);
    
    iIndex    = HashValue((WCHAR*)pszKey);
    pTempNode = m_heads[iIndex]; 
    
    while (pTempNode) 
    {
        if ( wcscmp (pTempNode->m_pszKey, pszKey) == 0 ) 
        {      
            CHashNode* pRem = pTempNode;

            if (pLastNode)
            {
                pLastNode->m_pNext = pRem->m_pNext;
            }
            else
            {
                m_heads[iIndex] = pRem->m_pNext;
            }
            
            pRem->m_pNext = NULL; //Avoid cleaning up the rest of the chain
            delete pRem;
            
            hr = S_OK;
            break;
        }

        pLastNode = pTempNode;
        pTempNode = pTempNode->m_pNext;
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CHash
//
// Find
/////////////////////////////////////////////////////// JOEM 3-2000 //
IUnknown* CHash::Find(const WCHAR *pszKey)
{
    SPDBG_FUNC( "CHash::Find" );
    CHashNode*  pTempNode   = NULL;
    
    SPDBG_ASSERT (*pszKey);
    
    pTempNode = m_heads[HashValue((WCHAR*)pszKey)]; 
    
    while (pTempNode) 
    {
        if ( wcscmp (pTempNode->m_pszKey, pszKey) == 0 ) 
        {
            return pTempNode->m_pValue;
        }
        pTempNode = pTempNode->m_pNext;
    }
    
    return NULL;
}

//////////////////////////////////////////////////////////////////////
// CHash
//
// NextKey
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CHash::NextKey(USHORT *punIdx1, USHORT* punIdx2, WCHAR** ppszKey)
{
    SPDBG_FUNC( "CHash::NextKey" );
    CHashNode*  pNode   = NULL;
    USHORT      i       = 0;
    
    SPDBG_ASSERT (punIdx1);
    SPDBG_ASSERT (punIdx2);
    
    *ppszKey = NULL;
    
    if (m_heads) 
    {
        while (*punIdx1 < HASH_SIZE ) 
        {
            if ((pNode = m_heads[*punIdx1]) != NULL) 
            {
                for ( i=0; i<*punIdx2 && pNode->m_pNext; i++) 
                {
                    pNode = pNode->m_pNext;
                }
                
                if (i==*punIdx2) 
                {
                    (*punIdx2)++;
                    *ppszKey = pNode->m_pszKey;
                    break;
                }
            }
            
            (*punIdx1)++;	
            *punIdx2 = 0;
        }
    }
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CHash
//
// HashValue
/////////////////////////////////////////////////////// JOEM 3-2000 //
int CHash::HashValue (WCHAR *pszKey)
{
    SPDBG_FUNC( "CHash::HashValue" );
    USHORT  unVal   = 0;

    SPDBG_ASSERT (pszKey);

    for (unVal=0; *pszKey ; pszKey++) 
    {
        unVal = (64*unVal + *pszKey) % HASH_SIZE;
    }

  return unVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\hash.h ===
//////////////////////////////////////////////////////////////////////
// Hash.h: interface for the CHash class.
//
// Created by JOEM  03-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 3-2000 //

#if !defined(AFX_HASH_H__4D944890_12DA_4329_9B53_48B185627578__INCLUDED_)
#define AFX_HASH_H__4D944890_12DA_4329_9B53_48B185627578__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "common.h"
#include <spddkhlp.h>
#include <spcollec.h>

//This should be some large prime number 
#define HASH_SIZE 36919

// The main variable within a CHash
class CHashNode 
{
public:
    CHashNode();
    ~CHashNode();

    WCHAR* m_pszKey;
    IUnknown* m_pValue;
    CHashNode* m_pNext;
};


class CHash  
{
public:
	CHash();
	~CHash();
	STDMETHOD(BuildEntry)(const WCHAR* pszKey, IUnknown* pValue);
	STDMETHOD(DeleteEntry)(const WCHAR* pszKey);
	STDMETHOD(NextKey)(USHORT* punIdx1, USHORT* punIdx2, WCHAR** ppszKey );
	IUnknown* Find(const WCHAR* pszKey);

private:
    int HashValue(WCHAR* pszKey);

private:
    CHashNode* m_heads[HASH_SIZE];
};

#endif // !defined(AFX_HASH_H__4D944890_12DA_4329_9B53_48B185627578__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\msprompteng.cpp ===
// MSPromptEng.cpp : Implementation of DLL Exports.
//
// Created by JOEM  01-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MSPromptEngps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MSPromptEng.h"

#include "MSPromptEng_i.c"
#include "PromptEng.h"
#include "PromptDb.h"


//--- Unicode mapping layer helper for Win9X and WinCE
CSpUnicodeSupport g_Unicode;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_PromptEng, CPromptEng)
OBJECT_ENTRY(CLSID_PromptDb, CPromptDb)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C" 
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSPROMPTENGLib);
        //DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\msscpctl.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: MSScriptControl */

#ifndef _msscptctl_H_
#define _msscptctl_H_

DEFINE_GUID(LIBID_MSScriptControl,0x0E59F1D2L,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/* Functions defined in module: ScriptControlConstants */
    const LPSTR GlobalModule = "Global";
    const long NoTimeout = -1;

typedef enum {
    Initialized = 0,
    Connected = 1
} ScriptControlStates;

DEFINE_GUID(IID_IScriptProcedure,0x70841C73L,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptProcedure */
#undef INTERFACE
#define INTERFACE IScriptProcedure

DECLARE_INTERFACE_(IScriptProcedure, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptProcedure methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_NumArgs)(THIS_ long FAR* pcArgs) PURE;
    STDMETHOD(get_HasReturnValue)(THIS_ VARIANT_BOOL FAR* pfHasReturnValue) PURE;
};

DEFINE_GUID(IID_IScriptProcedureCollection,0x70841C71L,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptProcedureCollection */
#undef INTERFACE
#define INTERFACE IScriptProcedureCollection

DECLARE_INTERFACE_(IScriptProcedureCollection, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptProcedureCollection methods */
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppenumProcedures) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT Index, IScriptProcedure FAR* FAR* ppdispProcedure) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* plCount) PURE;
};

DEFINE_GUID(IID_IScriptModule,0x70841C70L,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptModule */
#undef INTERFACE
#define INTERFACE IScriptModule

DECLARE_INTERFACE_(IScriptModule, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptModule methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_CodeObject)(THIS_ IDispatch * FAR* ppdispObject) PURE;
    STDMETHOD(get_Procedures)(THIS_ IScriptProcedureCollection FAR* FAR* ppdispProcedures) PURE;
    STDMETHOD(AddCode)(THIS_ BSTR Code) PURE;
    STDMETHOD(Eval)(THIS_ BSTR Expression, VARIANT FAR* pvarResult) PURE;
    STDMETHOD(ExecuteStatement)(THIS_ BSTR Statement) PURE;
    STDMETHOD(Run)(THIS_ BSTR ProcedureName, SAFEARRAY FAR* FAR* Parameters, VARIANT FAR* pvarResult) PURE;
};

DEFINE_GUID(IID_IScriptModuleCollection,0x70841C6FL,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptModuleCollection */
#undef INTERFACE
#define INTERFACE IScriptModuleCollection

DECLARE_INTERFACE_(IScriptModuleCollection, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptModuleCollection methods */
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppenumContexts) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT Index, IScriptModule FAR* FAR* ppmod) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* plCount) PURE;
    STDMETHOD(Add)(THIS_ BSTR Name, VARIANT FAR* Object, IScriptModule FAR* FAR* ppmod) PURE;
};

DEFINE_GUID(IID_IScriptError,0x70841C78L,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptError */
#undef INTERFACE
#define INTERFACE IScriptError

DECLARE_INTERFACE_(IScriptError, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptError methods */
    STDMETHOD(get_Number)(THIS_ long FAR* plNumber) PURE;
    STDMETHOD(get_Source)(THIS_ BSTR FAR* pbstrSource) PURE;
    STDMETHOD(get_Description)(THIS_ BSTR FAR* pbstrDescription) PURE;
    STDMETHOD(get_HelpFile)(THIS_ BSTR FAR* pbstrHelpFile) PURE;
    STDMETHOD(get_HelpContext)(THIS_ long FAR* plHelpContext) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* pbstrText) PURE;
    STDMETHOD(get_Line)(THIS_ long FAR* plLine) PURE;
    STDMETHOD(get_Column)(THIS_ long FAR* plColumn) PURE;
    STDMETHOD(Clear)(THIS) PURE;
};

DEFINE_GUID(IID_IScriptControl,0x0E59F1D3L,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

/* Definition of interface: IScriptControl */
#undef INTERFACE
#define INTERFACE IScriptControl

DECLARE_INTERFACE_(IScriptControl, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptControl methods */
    STDMETHOD(get_Language)(THIS_ BSTR FAR* pbstrLanguage) PURE;
    STDMETHOD(put_Language)(THIS_ BSTR bstrLanguage) PURE;
    STDMETHOD(get_State)(THIS_ ScriptControlStates FAR* pssState) PURE;
    STDMETHOD(put_State)(THIS_ ScriptControlStates ssState) PURE;
    STDMETHOD(put_SitehWnd)(THIS_ long hwnd) PURE;
    STDMETHOD(get_SitehWnd)(THIS_ long FAR* phwnd) PURE;
    STDMETHOD(get_Timeout)(THIS_ long FAR* plMilleseconds) PURE;
    STDMETHOD(put_Timeout)(THIS_ long lMilleseconds) PURE;
    STDMETHOD(get_AllowUI)(THIS_ VARIANT_BOOL FAR* pfAllowUI) PURE;
    STDMETHOD(put_AllowUI)(THIS_ VARIANT_BOOL fAllowUI) PURE;
    STDMETHOD(get_UseSafeSubset)(THIS_ VARIANT_BOOL FAR* pfUseSafeSubset) PURE;
    STDMETHOD(put_UseSafeSubset)(THIS_ VARIANT_BOOL fUseSafeSubset) PURE;
    STDMETHOD(get_Modules)(THIS_ IScriptModuleCollection FAR* FAR* ppmods) PURE;
    STDMETHOD(get_Error)(THIS_ IScriptError FAR* FAR* ppse) PURE;
    STDMETHOD(get_CodeObject)(THIS_ IDispatch * FAR* ppdispObject) PURE;
    STDMETHOD(get_Procedures)(THIS_ IScriptProcedureCollection FAR* FAR* ppdispProcedures) PURE;
    STDMETHOD(_AboutBox)(THIS) PURE;
    STDMETHOD(AddObject)(THIS_ BSTR Name, IDispatch * Object, VARIANT_BOOL AddMembers) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(AddCode)(THIS_ BSTR Code) PURE;
    STDMETHOD(Eval)(THIS_ BSTR Expression, VARIANT FAR* pvarResult) PURE;
    STDMETHOD(ExecuteStatement)(THIS_ BSTR Statement) PURE;
    STDMETHOD(Run)(THIS_ BSTR ProcedureName, SAFEARRAY FAR* FAR* Parameters, VARIANT FAR* pvarResult) PURE;
};

DEFINE_GUID(DIID_DScriptControlSource,0x8B167D60L,0x8605,0x11D0,0xAB,0xCB,0x00,0xA0,0xC9,0x0F,0xFF,0xC0);

/* Definition of dispatch interface: DScriptControlSource */
#undef INTERFACE
#define INTERFACE DScriptControlSource

DECLARE_INTERFACE_(DScriptControlSource, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* DScriptControlSource methods:
    void Error(void);
    void Timeout(void);
    */
};

DEFINE_GUID(CLSID_Procedure,0x0E59F1DAL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Procedure;
#endif

DEFINE_GUID(CLSID_Procedures,0x0E59F1DBL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Procedures;
#endif

DEFINE_GUID(CLSID_Module,0x0E59F1DCL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Module;
#endif

DEFINE_GUID(CLSID_Modules,0x0E59F1DDL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Modules;
#endif

DEFINE_GUID(CLSID_Error,0x0E59F1DEL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Error;
#endif

DEFINE_GUID(CLSID_ScriptControl,0x0E59F1D5L,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class ScriptControl;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\peerr.h ===
/////////////////////////////////////////////////////////////////////////////
// 
//  PEerr.h
//
// Created by JOEM  08-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
//////////////////////////////////////////////////////////// JOEM  08-2000 //

#ifndef _PEERR_H_
#define _PEERR_H_

#define FACILITY_PE      FACILITY_ITF

#define PE_ERROR_BASE    0x5100

#define MAKE_PE_HRESULT(sev, err)   MAKE_HRESULT(sev, FACILITY_PE, err)
#define MAKE_PE_ERROR(err)          MAKE_PE_HRESULT(SEVERITY_ERROR, err + PE_ERROR_BASE)
#define MAKE_PE_SCODE(scode)        MAKE_PE_HRESULT(SEVERITY_SUCCESS, scode + PE_ERROR_BASE)


#define PEERR_DB_BAD_FORMAT         MAKE_PE_ERROR(0x01)
#define PEERR_DB_DUPLICATE_ID       MAKE_PE_ERROR(0x02)
#define PEERR_DB_ID_NOT_FOUND       MAKE_PE_ERROR(0x03)
#define PEERR_DB_NOT_FOUND          MAKE_PE_ERROR(0x04)
#define PEERR_NO_TTS_VOICE          MAKE_PE_ERROR(0x05)
#define PEERR_FILE_NOT_FOUND        MAKE_PE_ERROR(0x06)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\phonecontext.cpp ===
//////////////////////////////////////////////////////////////////////
// PhoneContext.cpp: implementation of the CPhoneContext class and
// subclasses.
//
// Created by JOEM  03-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 3-2000 //

#include "stdafx.h"
#include "PhoneContext.h"
#include <stdio.h>

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// Construction/Destruction
/////////////////////////////////////////////////////// JOEM 3-2000 //
CPhoneContext::CPhoneContext()
{
    m_ulNRules      = 0;
    m_ppContextRules = NULL;
}

CPhoneContext::~CPhoneContext()
{
    ULONG i = 0;
    ULONG j = 0;
    ULONG k = 0;

    for (i=0; i<m_ulNRules; i++)
    {
        DeleteContextRule( m_ppContextRules[i] );
    }
    free (m_ppContextRules);

}

//////////////////////////////////////////////////////////////////////
// CPhoneContext::Load
// 
// Reads in the phone context file.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::Load(const WCHAR *pszPathName)
{
    HRESULT hr = S_OK;
    FILE* fp = NULL;
    WCHAR line[256] = L"";
    WCHAR* ptr = NULL;
    Macro* macros = NULL;
    USHORT nMacros = 0;
    USHORT state = 0;

    SPDBG_ASSERT (pszPathName);

    if ((fp = _wfopen(pszPathName, L"r")) == NULL) 
    {
        hr = E_FAIL;
    }

    state = 0;
    while ( SUCCEEDED(hr) && fgetws (line, sizeof(line), fp) ) 
    {
        // Strip off the newline character
        if (line[wcslen(line)-1] == L'\n') 
        {
            line[wcslen(line)-1] = L'\0';
        }
        // Line ends when a comment marker is found
        if ( (ptr = wcschr (line, L'#')) != NULL ) 
        {
            *ptr = L'\0';
        }
        
        ptr = line;
        WSkipWhiteSpace (ptr);
        if (!*ptr) 
        {
            continue;
        }
        
        // Could be a macro
        if (*ptr == L'%') 
        {
            hr = ReadMacro (ptr, &macros, &nMacros); 
        } 
        else 
        {
            // It's not a macro, must be a rule
            while ( SUCCEEDED(hr) && *ptr ) 
            {
                switch (state) {
                case 0: 
                    {
                        WCHAR* end;
                        
                        end = ptr;
                        WSkipNonWhiteSpace(end);
                        *end++ = L'\0';
                        state = 1;
                        
                        hr = CreateRule (ptr);
                        if ( SUCCEEDED(hr) )
                        {
                            ptr = end;
                            WSkipWhiteSpace (ptr);
                        }
                    }
                    break;
                case 1:
                    if (*ptr == L'{') 
                    {
                        ptr++;
                        WSkipWhiteSpace(ptr);
                        state = 2;
                    } 
                    else 
                    {
                        hr = E_FAIL;
                    }
                    break;
                case 2:
                    // We are in a rule, load several phoneClasses
                    if (*ptr == L'}') 
                    {
                        state = 0;
                        ptr++;
                        WSkipWhiteSpace (ptr);
                    } 
                    else 
                    {
                        hr = ParsePhoneClass (macros, nMacros, m_ppContextRules[m_ulNRules-1], &ptr); 
                    }
                    break;
                default:
                    hr = E_FAIL;
                }
            }  // while (*ptr)
        } // else (Not a macro)
    } // while ( SUCCEEDED(hr) && fgetws ...

    if (fp)
    {
        fclose(fp);
    }

    if (macros)
    {
        free(macros);
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext::Apply
// 
// Applies phone context rules to determine transition cost between
// the previous and current entry.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::Apply(IPromptEntry *pPreviousIPE, IPromptEntry *pCurrentIPE, double *pdCost)
{
    HRESULT hr = S_OK;
    double partialCost = 0;
    
    const WCHAR* prevPhone   = NULL;
    const WCHAR* prevContext = NULL;
    const WCHAR* curPhone    = NULL;
    const WCHAR* curContext  = NULL;
    
    SPDBG_ASSERT (pPreviousIPE);
    SPDBG_ASSERT (pCurrentIPE);
    SPDBG_ASSERT (pdCost);
    
    *pdCost = 0.0;
    
    // Should these two partial costs have the same weight?
    if ( SUCCEEDED(hr) )
    {
        hr = SearchPhoneTag (pPreviousIPE, &prevPhone, g_Phone_Tags[END_TAG]);
    }
    if ( SUCCEEDED(hr) )
    {
        hr = SearchPhoneTag (pCurrentIPE, &curContext, g_Phone_Tags[LEFT_TAG]); 
    }

    if ( SUCCEEDED(hr) )
    {
        hr = ApplyPhoneticRule (prevPhone, curContext, &partialCost); 
        if ( SUCCEEDED(hr) )
        {
            *pdCost += partialCost;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        hr = SearchPhoneTag (pPreviousIPE, &prevContext, g_Phone_Tags[RIGHT_TAG]);
    }
    if ( SUCCEEDED(hr) )
    {
        SearchPhoneTag (pCurrentIPE, &curPhone, g_Phone_Tags[START_TAG]);
    }
    if ( SUCCEEDED(hr) )
    {
        hr = ApplyPhoneticRule (curPhone, prevContext, &partialCost); 
        if ( SUCCEEDED(hr) )
        {
            *pdCost += partialCost;
        }
    }

    return hr;

}

//////////////////////////////////////////////////////////////////////
// CPhoneContext::ReadMacro
// 
// Helper function to read in a macro from the Phone context file.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::ReadMacro(const WCHAR *pszText, Macro **ppMacros, USHORT *punMacros)
{
    HRESULT hr = S_OK;
    SPDBG_ASSERT(pszText);
    SPDBG_ASSERT(ppMacros);
    SPDBG_ASSERT(punMacros);

    if (*ppMacros) 
    {
        *ppMacros = (Macro*) realloc (*ppMacros, (*punMacros + 1) * sizeof (**ppMacros));
    } 
    else 
    {
        *ppMacros = (Macro*) malloc (sizeof (**ppMacros));
    }
    
    if (*ppMacros == NULL) 
    {
        hr = E_OUTOFMEMORY;
    }
    
    if ( SUCCEEDED(hr) )
    {
        if (swscanf (pszText, L"%%%32s %lf", (*ppMacros)[*punMacros].name, &(*ppMacros)[*punMacros].value) != 2) 
        {
            hr = E_FAIL;
        }
    }
    
    if ( SUCCEEDED(hr) )
    {
        (*punMacros)++;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext::CreateRule
// 
// Helper function to read in a macro from the Phone context file.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::CreateRule(const WCHAR *pszText)
{
    HRESULT hr = S_OK;
    CContextRule* newRule = NULL;
    SPDBG_ASSERT (pszText);
    
    if (m_ppContextRules) 
    {
        m_ppContextRules = (CContextRule**) realloc (m_ppContextRules, (m_ulNRules + 1) *  sizeof(*m_ppContextRules));
    } 
    else 
    {
        m_ppContextRules = (CContextRule**) malloc (sizeof(*m_ppContextRules));
    }

    if (!m_ppContextRules)
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        if ((newRule = (CContextRule*) calloc (1, sizeof(*newRule))) == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        if ( (newRule->m_pszRuleName = wcsdup(pszText)) == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = RegularizeText(newRule->m_pszRuleName, KEEP_PUNCTUATION);
        }
    }

    if ( SUCCEEDED(hr) )
    {
        m_ppContextRules[m_ulNRules] = newRule;
        m_ulNRules++;
    }
    
    if ( FAILED(hr) )
    {
        if ( newRule )
        {
            if ( newRule->m_pszRuleName )
            {
                free (newRule->m_pszRuleName);
                newRule->m_pszRuleName = NULL;
            }
            free (newRule);
            newRule = NULL;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext::ParsePhoneClass
// 
// Reads, parses, creates a phone class.  Adds phones to class.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::ParsePhoneClass(const Macro *pMacros, const USHORT unMacros, CContextRule* pRule, WCHAR **ppszOrig)
{
    HRESULT hr = S_OK;
    WCHAR* ptr = NULL;
    WCHAR* end = NULL;
    int i;

    SPDBG_ASSERT (ppszOrig && *ppszOrig);

    ptr = *ppszOrig;
    
    WSkipWhiteSpace (ptr);
    end = ptr;
    WSkipNonWhiteSpace (end);
    *end++ = L'\0';

    if ( SUCCEEDED(hr) )
    {
        hr = CreatePhoneClass (&pRule->m_pvPhoneClasses, &pRule->m_unNPhoneClasses, ptr);
    }
    
    if ( SUCCEEDED(hr) )
    {
        ptr = end;  
        WSkipWhiteSpace (ptr);
        if (*ptr != L'{') {
            return 0;
        }
        ptr ++;
        WSkipWhiteSpace (ptr);
    }

    if ( SUCCEEDED(hr) )
    {
        while ( SUCCEEDED(hr) && *ptr!= L'}' ) 
        {
            if (*ptr == L'\0') 
            {
                hr = E_FAIL;
            }
            
            if ( SUCCEEDED(hr) )
            {
                end = ptr;
                WSkipNonWhiteSpace (end);
                *end++ = L'\0';
                
                hr = AddPhoneToClass (pRule->m_pvPhoneClasses[pRule->m_unNPhoneClasses-1], ptr);
            }

            if ( SUCCEEDED(hr) )
            {
                ptr = end;
                
                WSkipWhiteSpace (ptr);
            }
        }
    }
    
    if ( SUCCEEDED(hr) )
    {
        ptr++;
        WSkipWhiteSpace(ptr);
        
        if (*ptr == L'%') 
        {
            // It is a macro 
            ptr++;
            for (i=0; i<unMacros; i++) 
            {
                if (wcsncmp (ptr, pMacros[i].name, wcslen(pMacros[i].name)) == 0) 
                {
                    pRule->m_pvPhoneClasses[pRule->m_unNPhoneClasses-1]->m_dWeight 
                        = pMacros[i].value;
                    break;
                }
            }
            if (i == unMacros)
            {
                hr = E_FAIL;
            }
        } 
        else 
        {
            // Get the value directly 
            pRule->m_pvPhoneClasses[pRule->m_unNPhoneClasses-1]->m_dWeight 
                = wcstod(ptr, NULL); 
        }
    }

    if ( SUCCEEDED(hr) )
    {
        WSkipNonWhiteSpace(ptr);
        WSkipWhiteSpace(ptr);
    
        *ppszOrig = ptr;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// 
// CreatePhoneClass
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::CreatePhoneClass(CPhoneClass*** pppClasses, USHORT* punClasses, const WCHAR *psz)
{
    HRESULT hr = S_OK;
    CPhoneClass* phClass = NULL;

    SPDBG_ASSERT (pppClasses);
    SPDBG_ASSERT (punClasses);
    SPDBG_ASSERT (psz);

    if ( SUCCEEDED(hr) )
    {
        if ((phClass = (CPhoneClass*) calloc (1, sizeof(*phClass))) == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( SUCCEEDED(hr) )
    {
        if ((phClass->m_pszPhoneClassName = wcsdup(psz)) == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = RegularizeText(phClass->m_pszPhoneClassName, KEEP_PUNCTUATION);
        }
    }
    
    if ( SUCCEEDED(hr) )
    {
        if (*pppClasses) 
        {
            *pppClasses = (CPhoneClass**) realloc (*pppClasses, (*punClasses +1) * sizeof(**pppClasses));
        } 
        else 
        {
            *pppClasses = (CPhoneClass**) malloc (sizeof(**pppClasses));
        }

        if (*pppClasses == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( SUCCEEDED(hr) )
    {
        (*pppClasses)[*punClasses] = phClass;
        (*punClasses)++;
    }

    if ( FAILED(hr) )
    {
        DeletePhoneClass (phClass);
    }
   
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// 
// AddPhoneToClass
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::AddPhoneToClass(CPhoneClass* phClass, WCHAR *phone)
{
    HRESULT hr = S_OK;
    SPDBG_ASSERT(phClass);
    
    if (phClass->m_pppszPhones) 
    {
        phClass->m_pppszPhones = (WCHAR**) realloc (phClass->m_pppszPhones, (phClass->m_unNPhones +1) * sizeof (*phClass->m_pppszPhones));
    }
    else 
    {
        phClass->m_pppszPhones = (WCHAR**) malloc (sizeof (*phClass->m_pppszPhones));
    }
    
    if (phClass->m_pppszPhones == NULL) 
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        if ( (phClass->m_pppszPhones[phClass->m_unNPhones] = wcsdup(phone)) == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = RegularizeText(phClass->m_pppszPhones[phClass->m_unNPhones], KEEP_PUNCTUATION);
        }
    }

    if ( SUCCEEDED(hr) )
    {
        phClass->m_unNPhones++;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// 
// SearchPhoneTag
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::SearchPhoneTag(IPromptEntry *pIPE, const WCHAR **result, CONTEXT_PHONE_TAG phoneTag)
{
    HRESULT      hr     = S_OK;
    WCHAR*       ptr    = NULL;
    USHORT       nTags  = 0;
    const WCHAR* tag    = L"";
    int          i      = 0;

    SPDBG_ASSERT (result);

    switch ( phoneTag.iPhoneTag )
    {
    case START_TAG:
        hr = pIPE->GetStartPhone( result );
        break;
    case END_TAG:
        hr = pIPE->GetEndPhone( result );
        break;
    case RIGHT_TAG:
        hr = pIPE->GetRightContext( result );
        break;
    case LEFT_TAG:
        hr = pIPE->GetLeftContext( result );
        break;
    default:
        *result = NULL;
        break;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// 
// ApplyPhoneticRule
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::ApplyPhoneticRule(const WCHAR *pszPhone, const WCHAR *pszContext, double *cost)
{
    HRESULT hr = S_OK;
    CContextRule* rule = NULL;
    bool fDone = false;

    WCHAR* phnNextRule = NULL;
    WCHAR* cntxtNextRule = NULL;

    SPDBG_ASSERT (cost);

    if ( SUCCEEDED(hr) )
    {
        hr = FindContextRule (L"MAIN", &rule); 
    }
    
    if ( SUCCEEDED(hr) )
    {
        // cost initialized to no match at all
        hr = GetWeight (rule, L"NONE", cost); 
    }

    if ( !pszPhone || !pszContext )
    {
        fDone = true;
    }

    if ( SUCCEEDED(hr) && !fDone )
    {
        // First try if they are the same
        if (wcscmp (pszPhone, pszContext) == 0) 
        {
            hr = GetWeight (rule, L"ALL", cost);
            fDone = true;
        }
    }
        
    if ( SUCCEEDED(hr) && !fDone )
    {
        // Now iterate over the rules
        do 
        {
            if ( SUCCEEDED(hr) && !fDone )
            {
                hr = ApplyRule (rule, pszPhone, &phnNextRule);
            }
            if ( SUCCEEDED(hr) && !fDone )
            {
                hr = ApplyRule (rule, pszContext, &cntxtNextRule);
            }
            
            if ( SUCCEEDED(hr) && !fDone && phnNextRule && cntxtNextRule )
            {
                // if the two phones are both in the same next rule, continue.  Otherwise, done.
                if ( phnNextRule && cntxtNextRule && wcscmp(phnNextRule, cntxtNextRule) )
                {
                    fDone = true;
                }
            }
            
            if ( SUCCEEDED(hr) && !fDone && phnNextRule && cntxtNextRule )
            {
                // They are the same, get the cost for the next iteration
                hr = GetWeight (rule, phnNextRule, cost); 
            }
            
            if ( SUCCEEDED(hr) && !fDone && phnNextRule && cntxtNextRule )
            {
                // And the next rule to apply
                hr = FindContextRule (phnNextRule, &rule);
                if ( FAILED(hr) )
                {
                    fDone = true;
                    hr = S_OK;
                }
            }
            
        } while ( !fDone && rule && phnNextRule && cntxtNextRule);
    }

    return hr;
    
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// 
// FindContextRule
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::FindContextRule(const WCHAR *pszName, CContextRule** ppRule)
{
    HRESULT hr = E_FAIL;
    USHORT i = 0;

    SPDBG_ASSERT(pszName);

    for (i=0; i< m_ulNRules; i++) 
    {
        if ( wcscmp (m_ppContextRules[i]->m_pszRuleName, pszName) == 0 ) 
        {
            *ppRule = m_ppContextRules[i];
            hr = S_OK;
            break;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// 
// ApplyRule
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::ApplyRule(const CContextRule *pRule, const WCHAR *pszPhone, WCHAR** ppszNextRule)
{
    HRESULT hr = S_FALSE;
    
    USHORT i = 0;
    USHORT j = 0;
    
    SPDBG_ASSERT (pRule);
    SPDBG_ASSERT (pszPhone);
    *ppszNextRule = NULL;
    
    for ( i=0; i < pRule->m_unNPhoneClasses; i++ ) 
    {
        for ( j=0; j < pRule->m_pvPhoneClasses[i]->m_unNPhones; j++ ) 
        {
            if ( wcscmp( pszPhone, pRule->m_pvPhoneClasses[i]->m_pppszPhones[j] ) == 0 )
            {
                *ppszNextRule = pRule->m_pvPhoneClasses[i]->m_pszPhoneClassName;
                hr = S_OK;
                break;
            }
        }
        if ( hr == S_OK )
        {
            break;
        }
    }
    
    return hr;

}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// 
// GetWeight
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPhoneContext::GetWeight(const CContextRule *pRule, const WCHAR *pszName, double *pdCost)
{
    HRESULT hr = E_FAIL;
    USHORT i = 0;
    
    SPDBG_ASSERT (pRule);
    SPDBG_ASSERT (pszName);
    SPDBG_ASSERT (pdCost);
    
    for (i=0; i < pRule->m_unNPhoneClasses; i++) 
    {
        if ( wcscmp(pRule->m_pvPhoneClasses[i]->m_pszPhoneClassName, pszName) == 0 ) 
        {
            *pdCost = pRule->m_pvPhoneClasses[i]->m_dWeight;
            hr = S_OK;
            break;
        }
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// 
// DeletePhoneClass
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
void CPhoneContext::DeletePhoneClass(CPhoneClass *pClass)
{
    if (pClass) 
    {
        if (pClass->m_pszPhoneClassName) 
        {
            free (pClass->m_pszPhoneClassName);
        }
        if (pClass->m_pppszPhones) 
        {
            int i;
            for  (i=0; i<pClass->m_unNPhones; i++) 
            {
                free (pClass->m_pppszPhones[i]);
            }
            free (pClass->m_pppszPhones);
        }
        free (pClass);
    }

}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
// 
// DeleteContextRule
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
void CPhoneContext::DeleteContextRule(CContextRule *pRule)
{
    if (pRule) 
    {
        if (pRule->m_pszRuleName) 
        {
            free (pRule->m_pszRuleName);
        }
        if (pRule->m_pvPhoneClasses) 
        {
            int i;
            for (i=0; i<pRule->m_unNPhoneClasses; i++) 
            {
                DeletePhoneClass (pRule->m_pvPhoneClasses[i]);
            }
            free (pRule->m_pvPhoneClasses);
        }
        free (pRule);
    }

}

//////////////////////////////////////////////////////////////////////
// CPhoneContext
//
// DebugPhoneContext
//
// Function for debug help - just outputs the entire CPhoneContext
// class.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
void CPhoneContext::DebugContextClass()
{
    USHORT i = 0;
    USHORT j = 0;
    USHORT k = 0;
    
    WCHAR* RuleName = NULL;
    WCHAR* PhoneClassName = NULL;
    WCHAR* Phone = NULL;

    ULONG  NumRules = 0;
    USHORT NumPhoneClasses = 0;
    USHORT NumPhones = 0;

    USHORT RuleCount = 0;
    USHORT PCCount = 0;
    USHORT PhoneCount = 0;

    double Weight = 0.0;

    WCHAR DebugStr[128];

    // Print out each rule
    for (i=0; i<m_ulNRules; i++)
    {
        RuleCount = i+1;
        NumRules = m_ulNRules;
        RuleName = m_ppContextRules[i]->m_pszRuleName;
        swprintf (DebugStr, L"Rule: %s, (%d of %d)\n", RuleName, RuleCount, NumRules);
        OutputDebugStringW(DebugStr);

        // Within each rule, print out the phone classes
        for (j=0; j<m_ppContextRules[i]->m_unNPhoneClasses; j++)
        {
            PCCount = j+1;
            NumPhoneClasses = m_ppContextRules[i]->m_unNPhoneClasses;
            PhoneClassName = m_ppContextRules[i]->m_pvPhoneClasses[j]->m_pszPhoneClassName;
            Weight = m_ppContextRules[i]->m_pvPhoneClasses[j]->m_dWeight;
            swprintf (DebugStr, L"\tPhoneClass: %s, (%d of %d) ... weight=%f\n", PhoneClassName, PCCount, NumPhoneClasses, Weight);
            OutputDebugStringW(DebugStr);

            // Within each phone class, print out the phones
            for (k=0; k<m_ppContextRules[i]->m_pvPhoneClasses[j]->m_unNPhones; k++)
            {
                PhoneCount = k+1;
                NumPhones = m_ppContextRules[i]->m_pvPhoneClasses[j]->m_unNPhones;
                Phone = m_ppContextRules[i]->m_pvPhoneClasses[j]->m_pppszPhones[k];
                swprintf (DebugStr, L"\t\tPhone: %s, (%d of %d)\n", Phone, PhoneCount, NumPhones);
                OutputDebugStringW(DebugStr);

            }
        }
    }
}

HRESULT CPhoneContext::LoadDefault()
{
    HRESULT hr = S_OK;
    USHORT i = 0;
    USHORT j = 0;
    Macro* macros = NULL;
    USHORT nMacros = 0;
    WCHAR* pText = NULL;
    WCHAR* ptr  = NULL;

    // Load the macros
    for ( i=0; i < g_nMacros; i++ )
    {
        pText = wcsdup(g_macros[i]);
        if ( !pText )
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {
            hr = ReadMacro (pText, &macros, &nMacros); 
            free(pText);
            pText = NULL;
        }
    }

    // Load the rules
    for ( i=0; i < g_nRules && SUCCEEDED(hr); i++ )
    {
        hr = CreateRule(g_rules[i].name);

        if ( SUCCEEDED(hr) )
        {
            j=0;
            while ( SUCCEEDED(hr) && g_rules[i].rule[j] )
            {
                if ( SUCCEEDED(hr) )
                {
                    pText = wcsdup(g_rules[i].rule[j]);
                    if ( !pText )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        ptr = pText;
                        hr = ParsePhoneClass (macros, nMacros, m_ppContextRules[m_ulNRules-1], &ptr); 
                        free(pText);
                        pText = NULL;
                    }
                }
                j++;
            }
        }
    }


    if (macros)
    {
        free(macros);
    }

    //DebugContextClass();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\promptdb.cpp ===
//////////////////////////////////////////////////////////////////////
// PromptDb.cpp : Implementation of CPromptDb
//
// Created by JOEM  03-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 3-2000 //

#include "stdafx.h"
#include "PromptDb.h"
#include "LocalTTSEngineSite.h"
#include "vapiIO.h"
#include <LIMITS>

//#define ENTRY_TAG L"DB_ENTRY"
const WCHAR ENTRY_TAG[]     = L"DB_ENTRY";
const WCHAR ENTRY_START[]   = L"{";
const WCHAR ENTRY_END[]     = L"}";

const WCHAR ID_TAG[]        = L"ID:";
const WCHAR TEXT_TAG[]      = L"TEXT:";
const WCHAR ORIGINAL_TAG[]  = L"ORIGINAL:";
const WCHAR TAG_TAG[]       = L"TAG:";
const WCHAR FILE_TAG[]      = L"FILE:";
const WCHAR FROM_TAG[]      = L"FROM:";
const WCHAR TO_TAG[]        = L"TO:";

const WCHAR START_PHONE_TAG[]   = L"START_PHONE:";
const WCHAR END_PHONE_TAG[]     = L"END_PHONE:";
const WCHAR RIGHT_CONTEXT_TAG[] = L"RIGHT_CONTEXT:";
const WCHAR LEFT_CONTEXT_TAG[]  = L"LEFT_CONTEXT:";

const int g_iBase = 16;

//////////////////////////////////////////////////////////////////////
// Db
//
// Construction/Destruction
/////////////////////////////////////////////////////// JOEM 3-2000 //
CDb::CDb()
{
    pszPathName     = NULL;
    pszTempName     = NULL;
    pszLogicalName  = NULL;
}

CDb::~CDb()
{
    if ( pszPathName )
    {
        free ( pszPathName );
        pszPathName = NULL;
    }
    if ( pszTempName )
    {
        free ( pszTempName );
        pszTempName = NULL;
    }
    if ( pszLogicalName )
    {
        free ( pszLogicalName );
        pszLogicalName = NULL;
    }
}


//////////////////////////////////////////////////////////////////////
// CPromptDb
//
// Construction/Destruction
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPromptDb::FinalConstruct()
{
    SPDBG_FUNC( "CPromptDb::FinalConstruct" );
    HRESULT hr      = S_OK;
    m_pActiveDb     = NULL;
    m_unIndex       = 0;
    m_vcRef         = 1;

    m_pOutputFormatId   = NULL;
    m_pOutputFormat     = NULL;
    m_flEntryGain       = 1.0;  // This will be set in registry.
    m_flXMLVolume       = 1.0;  // Full volume unless XML changes it.
    m_flXMLRateAdj      = 1.0;  // Regular rate unless XML changes it.

    if ( SUCCEEDED( hr ) )
    {
        m_pVapiIO = VapiIO::ClassFactory();
        if ( !m_pVapiIO )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // create the rate changer
    if ( SUCCEEDED(hr) )
    {
        m_pTsm = new CTsm( g_dRateScale[BASE_RATE] );
        if ( !m_pTsm )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} 


void CPromptDb::FinalRelease()
{
    USHORT i = 0;

    m_pActiveDb = NULL;

    for ( i=0; i < m_apDbList.GetSize(); i++ )
    {
        if ( m_apDbList[i] )
        {
            delete m_apDbList[i];
            m_apDbList[i] = NULL;
        }
    }
    m_apDbList.RemoveAll();

    for ( i=0; i<m_aSearchList.GetSize(); i++ )
    {
        m_aSearchList[i].dstr.Clear();
    }
    m_aSearchList.RemoveAll();

    if ( m_pVapiIO )
    {
        delete m_pVapiIO;
        m_pVapiIO = NULL;
    }
    if ( m_pTsm )
    {
        delete m_pTsm;
        m_pTsm = NULL;
    }
    if ( m_pOutputFormat )
    {
        free(m_pOutputFormat);
        m_pOutputFormat = NULL;
        m_pOutputFormatId = NULL;
    }
} 


//
// IUnknown implementations
//
//////////////////////////////////////////////////////////////////////
// CPromptDb::QueryInterface
//
/////////////////////////////////////////////////////// JOEM 4-2000 //
STDMETHODIMP CPromptDb::QueryInterface(const IID& iid, void** ppv)
{
    if ( iid == IID_IUnknown )
    {
        *ppv = (IPromptDb*) this;
    }
    else if ( iid == IID_IPromptDb )
    {
        *ppv = (IPromptDb*) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::AddRef
//
/////////////////////////////////////////////////////// JOEM 4-2000 //
ULONG CPromptDb::AddRef()
{
    return InterlockedIncrement(&m_vcRef);
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::Release
//
/////////////////////////////////////////////////////// JOEM 4-2000 //
ULONG CPromptDb::Release()
{
    if ( 0 == InterlockedDecrement(&m_vcRef) )
    {
        delete this;
        return 0;
    }

    return (ULONG) m_vcRef;
}


//
// IPromptDb INTERFACE FUNCTION IMPLEMENTATIONS
//

//////////////////////////////////////////////////////////////////////
// CPromptDb::NewDb
//
// Creates a new Db.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::NewDb(const WCHAR* logicalName, const WCHAR* pathName)
{
    SPDBG_FUNC( "CPromptDb::NewDb" );
    HRESULT hr  = S_OK;
    CDb* db     = NULL;

    // See if this Db already exists.
    hr = ActivateDbName(logicalName);
    if ( SUCCEEDED(hr) )
    {
        return E_INVALIDARG;
    }

    db = new CDb;
    if ( db )
    {
        hr = S_OK;
    }

    if ( SUCCEEDED(hr) )
    {
        db->pszLogicalName  = _wcsdup(logicalName);
        if ( !db->pszLogicalName )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        db->pszPathName     = _wcsdup(pathName);
        if ( !db->pszPathName )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        m_apDbList.Add(db);
    }

    if ( FAILED(hr) )
    {
        if ( db )
        {
            delete db;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}


//////////////////////////////////////////////////////////////////////
// CPromptDb::AddDb
//
// Adds a Db to the list, and activates it if desired.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::AddDb(const WCHAR* logicalName, const WCHAR* pathName, const WCHAR* pszIdSet, const USHORT loadOption)
{
    SPDBG_FUNC( "CPromptDb::AddDb" );
    HRESULT hr          = S_OK;
    CDb*    pActiveDb   = m_pActiveDb; 

    if ( !pathName || !wcslen(pathName) )
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED(hr) )
    {
        if ( !FileExist( pathName ) )
        {
            hr = PEERR_DB_NOT_FOUND;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        // if there is logicalName specified, activate or create it.
        if ( logicalName )
        {
            hr = ActivateDbName(logicalName);
            if ( FAILED(hr) )
            {
                hr = NewDb(logicalName, pathName);
                if ( SUCCEEDED(hr) )
                {
                    hr = ActivateDbName(logicalName);
                }
            }
        }
        else
        {
            // if no current Db, activate the default
            if ( !m_pActiveDb )
            {
                hr = ActivateDbName(L"DEFAULT");
            }
        }
    }

    // Set the Active Db's new path name
    if ( SUCCEEDED(hr) )
    {
        if ( m_pActiveDb->pszPathName )
        {
            free(m_pActiveDb->pszPathName);
            m_pActiveDb->pszPathName = wcsdup(pathName);
            if ( !m_pActiveDb->pszPathName )
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // Load it?
    if ( SUCCEEDED(hr) )
    {
        if ( loadOption == DB_LOAD )
        {
            if ( SUCCEEDED( hr ) )
            {
                hr = LoadDb(pszIdSet);
            }
        }
    }
    
    // Reset the active Db
    m_pActiveDb = pActiveDb;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::LoadDb
//
// Initializes the hash tables for a new Db.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::LoadDb(const WCHAR* pszIdSet)
{
    SPDBG_FUNC( "CPromptDb::LoadDb" );
    HRESULT hr = S_OK;
    FILE*   fp = NULL;
    
    SPDBG_ASSERT( m_pActiveDb );
    SPDBG_ASSERT( m_pActiveDb->pszPathName );

    fp = _wfopen (m_pActiveDb->pszPathName, L"r");
    if ( !fp )
    {
        hr = E_ACCESSDENIED;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = LoadIdHash(fp, pszIdSet);
        fclose (fp);
    }

    if ( SUCCEEDED(hr) )
    {
        hr = IndexTextHash();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::UnloadDb
//
// Deactivates and unloads a Db.  Makes the default Db active, or the
// first available Db if the default doesn't exist. 
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::UnloadDb(const WCHAR* pszLogicalName)
{
    SPDBG_FUNC( "CPromptDb::UnloadDb" );
    HRESULT hr      = S_OK;
    USHORT  i       = 0;
    USHORT  dbIndex = 0;

    SPDBG_ASSERT(pszLogicalName);

    for ( i=0; i<m_apDbList.GetSize(); i++ )
    {
        if ( wcscmp(pszLogicalName, m_apDbList[i]->pszLogicalName) == 0 )
        {
            if ( wcscmp(pszLogicalName, m_pActiveDb->pszLogicalName) == 0 )
            {
                m_pActiveDb = NULL;
            }
            delete m_apDbList[i];
            m_apDbList[i] = NULL;
            m_apDbList.RemoveAt( i );
        }
    }

    if ( !m_pActiveDb )
    {
        hr = ActivateDbName(L"DEFAULT");
        if ( FAILED(hr) )
        {
            hr = ActivateDbNumber(0);
        }
		if( FAILED(hr) )
		{
			hr = S_FALSE;
		}
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}


//////////////////////////////////////////////////////////////////////
// CPromptDb::ActivateDbName
//
// Activates the Db specified by logical name.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::ActivateDbName(const WCHAR* pszLogicalName)
{
    SPDBG_FUNC( "CPromptDb::ActivateDbName" );
    HRESULT hr      = PEERR_DB_NOT_FOUND;
    WCHAR*  pszDb   = NULL;
    USHORT  unSize  = 0;
    USHORT  i       = 0;

    SPDBG_ASSERT(pszLogicalName);
    
    if ( m_pActiveDb )
    {
        // See if the Db is already the active one
        if ( !wcscmp(m_pActiveDb->pszLogicalName, pszLogicalName ) )
        {
            hr = S_OK;
        }
    }

    // Did the current Db match?
    if ( FAILED(hr) )
    {
        unSize = (USHORT) m_apDbList.GetSize();
        
        for (i = 0; i < unSize; i++) 
        {        
            if ( _wcsicmp(pszLogicalName, m_apDbList[i]->pszLogicalName) == 0 ) 
            {
                m_pActiveDb = m_apDbList[i];
                hr = S_OK;
            }
        }
    }

    // Don't report failures here - this func is allowed to fail frequently.
    //SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
//////////////////////////////////////////////////////////////////////
// CPromptDb::ActivateDbNumber
//
// Activates the Db specified by number.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::ActivateDbNumber(const USHORT unIndex)
{
    SPDBG_FUNC( "CPromptDb::ActivateDbNumber" );
    HRESULT hr      = S_OK;
    USHORT  unSize  = 0;
    USHORT  i       = 0;

    unSize = (USHORT) m_apDbList.GetSize();
    if ( unIndex >= unSize ) 
    {
        hr = PEERR_DB_NOT_FOUND;
    }
    
    if ( SUCCEEDED(hr) )
    {
        m_pActiveDb = m_apDbList[unIndex];
        if ( !m_pActiveDb )
        {
            hr = E_UNEXPECTED;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::UpdateDb
//
// When creating a Db file, this updates the real Db file with the 
// contents of the temp file.  
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::UpdateDb(WCHAR* pszPath)
{
    SPDBG_FUNC( "CPromptDb::UpdateDb" );
    HRESULT hr              = S_OK;
    FILE* fp                = NULL;
    WCHAR* id               = NULL;
    CPromptEntry* value     = NULL;
    USHORT  idx1            = 0;
    USHORT  idx2            = 0;
    WCHAR backupName[_MAX_PATH + 1];

    SPDBG_ASSERT( m_pActiveDb );

    // New name?
    if ( pszPath )
    {
        if ( m_pActiveDb->pszPathName )
        {
            free( m_pActiveDb->pszPathName);
        }
        m_pActiveDb->pszPathName = wcsdup(pszPath);
        if ( !m_pActiveDb->pszPathName )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Create the temp file name
    if ( SUCCEEDED(hr) )
    {
        hr = TempName();
    }

    // Write the entries to the temp file
    if ( SUCCEEDED(hr) )
    {
        if ((fp = _wfopen(m_pActiveDb->pszTempName, L"w")) == NULL)
        {
            hr = E_ACCESSDENIED;
        }

        if ( SUCCEEDED(hr) )
        {
            fwprintf (fp, L"#\n#  PROMPT Database, generated automatically\n#\n\n");
        
            while ( SUCCEEDED(hr) ) 
            {
                hr = m_pActiveDb->idHash.NextKey(&idx1, &idx2, &id);
                
                if ( id == NULL ) 
                {
                    break;
                }
                
                if ( SUCCEEDED(hr) )
                {
                    value = (CPromptEntry *) m_pActiveDb->idHash.Find(id);
                    if ( !value ) 
                    {
                        hr = E_FAIL;
                    }
                }
                if ( SUCCEEDED(hr) )
                {
                    hr = WriteEntry (fp, value);
                }
            }
            fclose (fp);
        }
    }

    // Now backup the old Db file
    if ( SUCCEEDED(hr) )
    {        
        // Make a backupName 
        wcscat( wcsncpy( backupName, m_pActiveDb->pszPathName, _MAX_PATH-1 ), L"~" );

        // This "remove" is necessary, since the "rename"
        // would fail if the file exists.
        if ( FileExist( backupName ) )
        {
            _wremove (backupName);
        }
    
        if ( FileExist( m_pActiveDb->pszPathName) ) 
        {
            if ( _wrename( m_pActiveDb->pszPathName, backupName ) !=0 ) 
            {
                hr = E_ACCESSDENIED;
            }
        }
    }
     
    if ( SUCCEEDED(hr) )
    {
        if ( _wrename( m_pActiveDb->pszTempName, m_pActiveDb->pszPathName ) !=0 ) 
        {
            hr = E_ACCESSDENIED;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb
//
// CountDb
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::CountDb(USHORT *unCount)
{
    SPDBG_FUNC( "CPromptDb::CountDb" );

	*unCount = (USHORT) m_apDbList.GetSize();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::LoadIdHash
//
// Makes a hash table for entry ID numbers, using unique key values.
// Adds all the Db entry ids to the table.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPromptDb::LoadIdHash(FILE *fp, const WCHAR* pszIdSet)
{
    SPDBG_FUNC( "CPromptDb::LoadIdHash" );
    HRESULT         hr                  = S_OK;
    CPromptEntry*   entry               = NULL;
    const WCHAR*    entryInfo           = NULL;

    SPDBG_ASSERT (fp);

    // S_FALSE indicates no more entries.
    while ( hr == S_OK ) 
    {
        hr = ReadEntry (fp, &entry);
        if ( hr == S_OK && entry )
        {
            if ( SUCCEEDED(hr) )
            {
                hr = entry->GetId(&entryInfo);

                // prepend the IDSET info to the id
                if ( pszIdSet && wcslen(pszIdSet) )
                {
                    WCHAR* pszFullId = NULL;
                    int iLen = wcslen(pszIdSet) + wcslen(entryInfo) + 1;
                    pszFullId = new WCHAR[iLen];
                    if ( pszFullId )
                    {
                        wcscpy(pszFullId, pszIdSet);
                        wcscat(pszFullId, entryInfo);

                        hr = entry->SetId(pszFullId);
                        if ( SUCCEEDED(hr) )
                        {
                            hr = entry->GetId(&entryInfo);
                        }
                        delete [] pszFullId;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                
                if ( SUCCEEDED(hr) )
                {
                    hr = m_pActiveDb->idHash.BuildEntry( entryInfo, entry );
                    if ( hr == E_INVALIDARG )
                    {
                        hr = PEERR_DB_DUPLICATE_ID;
                    }
                    entryInfo = NULL;
                }
            }
            entry->Release();
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::SearchDb
//
// Searches the text in the Db entries for items that can be 
// concatenated to match the query text.  If such a list exists,
// it is put in m_aSearchList.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::SearchDb(const WCHAR* pszQuery, USHORT* unIdCount)
{
    SPDBG_FUNC( "CPromptDb::SearchDb" );
    HRESULT hr                  = S_OK;
    const CDynStrArray* list    = NULL;
    USHORT i                    = 0;
    IPromptEntry* pIPE          = NULL;

    // make sure the search list is clear
    for ( i=0; i<m_aSearchList.GetSize(); i++ )
    {
        m_aSearchList[i].dstr.Clear();
    }
    m_aSearchList.RemoveAll();
        
    *unIdCount = 0;

	if(m_pActiveDb) 
	{
		list = (CDynStrArray*) m_pActiveDb->textHash.Find(pszQuery);
	}

    if ( !list )
    {
        hr = E_FAIL;
    }
    else 
    {
        // If searching the text hash resulted in a list of Ids, save the list.
        for ( i=0; i<list->m_aDstr.GetSize(); i++ )
        {
            m_aSearchList.Add( list->m_aDstr[i].dstr );
        }
    }

    if ( SUCCEEDED(hr) )
    {
        // go through the list of IDs for this text
        // Make sure each id in the list exists; if not, remove it from list.
        for ( i=0; i<m_aSearchList.GetSize(); i++)
        {
            hr = E_FAIL;
            // if FindEntry fails, the list size changes and list#'s shift down, so keep checking i
            while ( FAILED(hr) && i < m_aSearchList.GetSize() )
            {
                hr = FindEntry( m_aSearchList[i].dstr, &pIPE );
                if ( SUCCEEDED(hr) )
                {
                    pIPE->Release();
                }
                else
                {
                    m_aSearchList[i].dstr.Clear();
                    m_aSearchList.RemoveAt( i );
                }
            }
        }
    }

    if ( m_aSearchList.GetSize() )
    {
        *unIdCount = (USHORT) m_aSearchList.GetSize();
        hr = S_OK;
    }

    // Don't report failures here - this func is allowed to fail frequently.
    //SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::RetrieveSearchItem
//
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
STDMETHODIMP CPromptDb::RetrieveSearchItem(const USHORT unId, const WCHAR** ppszId)
{
    SPDBG_FUNC( "CPromptDb::RetrieveSearchItem" );
    HRESULT hr = S_OK;

    if ( unId >= m_aSearchList.GetSize() )
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED(hr) )
    {
        *ppszId = m_aSearchList[unId].dstr;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::GetLogicalName
//
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::GetLogicalName(const WCHAR** ppszLogicalName)
{
    SPDBG_FUNC( "CPromptDb::GetLogicalName" );
    HRESULT hr = S_OK;

    SPDBG_ASSERT( m_pActiveDb );

    *ppszLogicalName = m_pActiveDb->pszLogicalName;

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::FindEntry
//
// Locates a Db entry in the hash, and gets an interface for it.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::FindEntry(const WCHAR *id, IPromptEntry** ppIPE)
{
    SPDBG_FUNC( "CPromptDb::FindEntry" );
    HRESULT         hr              = S_OK;
    CPromptEntry*   entry           = NULL;
    const WCHAR*    entryFileName   = NULL;

    SPDBG_ASSERT(m_pActiveDb);
    SPDBG_ASSERT(id);
    
    entry = (CPromptEntry*) m_pActiveDb->idHash.Find(id);
    
    if ( !entry )
    {
        hr = PEERR_DB_ID_NOT_FOUND;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = entry->GetFileName(&entryFileName);

        if ( SUCCEEDED(hr) )
        {
            if ( FileExist( entryFileName ) )
            {
                hr = entry->QueryInterface(IID_IPromptEntry, (void**)ppIPE);
            }
            else
            {
                *ppIPE = NULL;
                hr = E_ACCESSDENIED;
            }
            entryFileName = NULL;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::NewEntry
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
STDMETHODIMP CPromptDb::NewEntry(IPromptEntry **ppIPE)
{
    SPDBG_FUNC( "CPromptDb::NewEntry" );
    CPromptEntry* newEntry = new CPromptEntry;
    HRESULT hr = S_OK;

    if ( newEntry )
    {
        *ppIPE = newEntry;
    }
    else 
    {
        hr = E_OUTOFMEMORY;
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::SaveEntry
//
// Adds a Db entry to the Db's hash table
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::SaveEntry(IPromptEntry* pIPE)
{
    SPDBG_FUNC( "CPromptDb::SaveEntry" );
    HRESULT hr   = S_OK;
    const WCHAR* entryId = NULL;
    double  to   = 0.0;
    double  from = 0.0;

    if ( SUCCEEDED(hr) )
    {
        hr = pIPE->GetStart(&from);
    }
    if ( SUCCEEDED(hr) )
    {
        hr = pIPE->GetEnd(&to);
    }

    if ( SUCCEEDED(hr) )
    {
        USHORT validTime = (from==0.0 && to == -1.0) || (from>=0.0 && to>from);
        
        const WCHAR* entryFile = NULL;
        const WCHAR* entryText = NULL;
        
        pIPE->GetId(&entryId);
        pIPE->GetText(&entryText);
        pIPE->GetFileName(&entryFile);

        if ( !entryId || !entryText || !entryFile || !validTime )
        {
            hr = E_INVALIDARG;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        hr = m_pActiveDb->idHash.BuildEntry( entryId, pIPE );
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::RemoveEntry
//
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::RemoveEntry(const WCHAR *id)
{
    SPDBG_FUNC( "CPromptDb::RemoveEntry" );
    HRESULT hr = S_OK;
    CPromptEntry* pEntry = NULL;

    SPDBG_ASSERT(m_pActiveDb);
    SPDBG_ASSERT(id);

    if (SUCCEEDED(hr))
    {
        // CHash will Release it
        hr = m_pActiveDb->idHash.DeleteEntry(id);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::OpenEntryFile
//
// Opens the specified entry.
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
STDMETHODIMP CPromptDb::OpenEntryFile(IPromptEntry *pIPE, WAVEFORMATEX* pWaveFormatEx)
{
    SPDBG_FUNC( "CPromptDb::OpenEntryFile" );
    HRESULT      hr        = S_OK;
    const WCHAR* entryFile = NULL;

    SPDBG_ASSERT (pIPE);

    if ( SUCCEEDED(hr) )
    {
        hr = pIPE->GetFileName(&entryFile);
    }
    
    if ( SUCCEEDED(hr) )
    {
        if ( m_pVapiIO->OpenFile(entryFile, VAPI_IO_READ) != 0 )
        {
            hr = E_ACCESSDENIED;
        }
        entryFile = NULL;
    }

    if ( SUCCEEDED(hr) )
    {
        if ( m_pVapiIO->Format(NULL, NULL, pWaveFormatEx) != 0 )
        {
            hr = E_FAIL;
        }
    }

    if ( FAILED(hr) )
    {
        m_pVapiIO->CloseFile();
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::CloseEntryFile
//
// Retrieves the specified audio samples from the database entry.
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
STDMETHODIMP CPromptDb::CloseEntryFile()
{
    m_pVapiIO->CloseFile();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::GetNextEntry
//
// Retrieves the entry, based on the unique key for the Id Hash.
// To retrieve the first entry, use punId1=0, punId2=0.  The Id's
// will be updated with the values that can be used to retrieve the 
// next entry.
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptDb::GetNextEntry(USHORT* punId1, USHORT* punId2, IPromptEntry** ppIPE)
{
    SPDBG_FUNC( "CPromptDb::GetNextEntry" );
    HRESULT hr          = S_OK;
    WCHAR*  pszNextKey  = NULL;

    SPDBG_ASSERT(punId1);
    SPDBG_ASSERT(punId2);

    hr = m_pActiveDb->idHash.NextKey( punId1, punId2, &pszNextKey );

    if ( !pszNextKey ) 
    {
        hr = E_FAIL;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = FindEntry(pszNextKey, ppIPE);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::SetOutputFormat
//
// Sets the format in which samples are returned to the calling app.
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
STDMETHODIMP CPromptDb::SetOutputFormat(const GUID *pOutputFormatId, const WAVEFORMATEX *pOutputFormat)
{
    SPDBG_FUNC( "CPromptDb::SetOutputFormat" );
    HRESULT hr = S_OK;

    if ( pOutputFormatId && *pOutputFormatId == SPDFID_Text )
    {
        m_pOutputFormatId = pOutputFormatId;

        if ( m_pOutputFormat )
        {
            delete m_pOutputFormat;
            m_pOutputFormat      = NULL;
        }
    }
    else if ( pOutputFormat )
    {
        // Do we need to change the format?
        if ( !m_pOutputFormat ||
            m_pOutputFormat->wFormatTag         != pOutputFormat->wFormatTag        ||
            m_pOutputFormat->nChannels          != pOutputFormat->nChannels         ||
            m_pOutputFormat->nSamplesPerSec     != pOutputFormat->nSamplesPerSec    ||
            m_pOutputFormat->nAvgBytesPerSec    != pOutputFormat->nAvgBytesPerSec   ||
            m_pOutputFormat->nBlockAlign        != pOutputFormat->nBlockAlign       ||
            m_pOutputFormat->wBitsPerSample     != pOutputFormat->wBitsPerSample    ||
            m_pOutputFormat->cbSize             != pOutputFormat->cbSize
            )
        {
            // free the current waveformatex
            if ( m_pOutputFormat )
            {
                free(m_pOutputFormat);
                m_pOutputFormat = NULL;
            }
            // this needs to copy the output format, not just point to it,
            // because engine will pass in const pointer.
            m_pOutputFormat = (WAVEFORMATEX*) malloc( sizeof(WAVEFORMATEX) + pOutputFormat->cbSize );
            if ( !m_pOutputFormat )
            {
                hr = E_OUTOFMEMORY;
            }
            else 
            {
                m_pOutputFormatId = pOutputFormatId;
                memcpy(m_pOutputFormat, pOutputFormat, sizeof(WAVEFORMATEX) + pOutputFormat->cbSize );
            }
            
            if ( SUCCEEDED(hr) )
            {
                m_converter.SetOutputFormat(m_pOutputFormat);
            }
            if ( SUCCEEDED(hr) && m_pTsm )
            {
                m_pTsm->SetSamplingFrequency(m_pOutputFormat->nSamplesPerSec);
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::SetEntryGain
//
// Sets the gain factor (from registry) for Prompt entries.
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptDb::SetEntryGain(const double dEntryGain)
{
    SPDBG_FUNC( "CPromptDb::SetEntryGain" );
    m_flEntryGain = (float)dEntryGain;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::SetXMLVolume
//
// Adjust the volume from XML tag.
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptDb::SetXMLVolume(const ULONG ulXMLVol)
{
    SPDBG_FUNC( "CPromptDb::SetXMLVolume" );
    SPDBG_ASSERT(ulXMLVol <=100);

    m_flXMLVolume = ((double) ulXMLVol) / 100;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::SetXMLRate
//
// Adjust the rate from XML tag.
//
/////////////////////////////////////////////////////// JOEM 11-2000 //
STDMETHODIMP CPromptDb::SetXMLRate(const long lXMLRate)
{
    SPDBG_FUNC( "CPromptDb::SetXMLRate" );
    
    ComputeRateAdj(lXMLRate, &m_flXMLRateAdj);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::SendEntrySamples
//
// Retrieves the specified audio samples from the database entry,
// applies rate change, converts them, applies gain/vol, and sends 
// them to output site.
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
STDMETHODIMP CPromptDb::SendEntrySamples(IPromptEntry* pIPE, ISpTTSEngineSite* pOutputSite, ULONG ulTextOffset, ULONG ulTextLen)
{
    HRESULT hr              = S_OK;
    double  entryTo         = 0.0;
    double  entryFrom       = 0.0;
    ULONG   pcbWritten      = 0;

    void*   pvSamples       = NULL;
    void*   pvNewSamples    = NULL;
    int     iNumSamples     = 0;
    int     iNumNewSamples  = 0;

    USHORT  unVol           = 1;   // Full vol unless app changes it
    double  dVol            = 1.0; // Full vol unless app changes it
    long    lRateAdj        = 1;   // Regular rate unless app changes it
    float   flRateAdj       = 1.0; // Regular rate unless app changes it
    double  dBuff           = 0.0;
    USHORT  i               = 0;
    bool    fConvert        = false;
    WAVEFORMATEX wavFormat;

    SPDBG_ASSERT(pIPE);
    SPDBG_ASSERT(pOutputSite);
    
    hr = OpenEntryFile(pIPE, &wavFormat);

    if ( SUCCEEDED(hr) )
    {
        // Does the current prompt format need converting?
        if ( m_pOutputFormat )
        {
            if (wavFormat.wFormatTag        != m_pOutputFormat->wFormatTag      ||
                wavFormat.nAvgBytesPerSec   != m_pOutputFormat->nAvgBytesPerSec ||
                wavFormat.nBlockAlign       != m_pOutputFormat->nBlockAlign     ||
                wavFormat.nChannels         != m_pOutputFormat->nChannels       ||
                wavFormat.nSamplesPerSec    != m_pOutputFormat->nSamplesPerSec  ||
                wavFormat.wBitsPerSample    != m_pOutputFormat->wBitsPerSample )
            {
                fConvert = true;
                m_converter.SetInputFormat(&wavFormat);
            }
        }
        
        // get the start and end points, and clean them up if necessary.
        if ( SUCCEEDED(hr) )
        {
            hr = pIPE->GetStart(&entryFrom);
            if ( SUCCEEDED(hr) )
            {
                if ( entryFrom < 0.0 )
                {
                    entryFrom = 0.0;
                }
                hr = pIPE->GetEnd(&entryTo);
            }
            if ( SUCCEEDED(hr) )
            {
                long lDataSize = 0;
                double dEnd = 0.0;
                // make sure we're not trying to read past end of file
                m_pVapiIO->GetDataSize(&lDataSize);
                dEnd = ((double)lDataSize)/wavFormat.nBlockAlign/wavFormat.nSamplesPerSec;
                if ( entryTo > dEnd )
                {
                    entryTo = dEnd;
                }
                if ( entryTo != -1.0 && entryFrom >= entryTo )
                {
                    entryFrom = entryTo;
                }
            }
        }

        if ( SUCCEEDED(hr) )
        {
            // read the samples
            if ( SUCCEEDED(hr) )
            {
                if ( m_pVapiIO->ReadSamples( entryFrom, entryTo, &pvSamples, &iNumSamples, 1) != 0 )
                {
                    hr = E_FAIL;
                }
                if ( iNumSamples == 0 )
                {
                    hr = E_FAIL;
                }
            }

            // convert to desired output format
            if ( SUCCEEDED(hr) && fConvert && pvSamples )
            {
                hr = m_converter.ConvertSamples(pvSamples, iNumSamples, (void**) &pvNewSamples, &iNumNewSamples);
                if ( SUCCEEDED(hr) )
                {
                    delete [] pvSamples;
                    pvSamples = pvNewSamples;
                    iNumSamples = iNumNewSamples;
                    pvNewSamples = NULL;
                    iNumNewSamples = 0;
                }
            }
                
            // do rate change.  Must be format-converted already!
            if ( SUCCEEDED(hr) && m_pTsm )
            {
                // Don't GetActions - the rate flag is kept on since TTS eng needs it too.
                hr = pOutputSite->GetRate( &lRateAdj );
                if ( SUCCEEDED(hr) )
                {
                    ComputeRateAdj(lRateAdj, &flRateAdj);
                    flRateAdj *= m_flXMLRateAdj;
                    m_pTsm->SetScaleFactor( (double) flRateAdj );

                    if ( flRateAdj != 1.0 && pvSamples )
                    {
                        // can't adjust rate for chunks smaller than the frame length
                        if ( iNumSamples > m_pTsm->GetFrameLen() )
                        {
                            hr = m_pTsm->AdjustTimeScale( pvSamples, iNumSamples, &pvNewSamples, &iNumNewSamples, m_pOutputFormat );
                            if ( SUCCEEDED(hr) )
                            {
                                delete [] pvSamples;
                                pvSamples = pvNewSamples;
                                iNumSamples = iNumNewSamples;
                                pvNewSamples = NULL;
                                iNumNewSamples = 0;
                            }
                        }
                    }
                }
            }

            // check for volume change
            if ( SUCCEEDED(hr) )
            {
                // Prompt Eng doesn't GetActions - the Vol flag is kept on since TTS eng needs it.  
                hr = pOutputSite->GetVolume( &unVol );
            }
            // Multiply the three volume sources
            if ( SUCCEEDED(hr) )
            {
                dVol = ((double) unVol) / 100; // make dVol fractional
                dVol *= m_flEntryGain; // gain from registry
                dVol *= m_flXMLVolume;   // gain from XML
                
                if ( dVol != 1.0 )
                {
                    hr = ApplyGain( pvSamples, &pvNewSamples, iNumSamples, dVol );
                    // Did ApplyGain need to create a new buffer?
                    if ( pvNewSamples )
                    {
                        // send the volume modified buff instead of the original
                        delete [] pvSamples;
                        pvSamples = pvNewSamples;
                        pvNewSamples = NULL;
                    }
                }
            }
            
            // EVENTS:
            // Send a private engine event at beginning of each prompt 
            if ( SUCCEEDED(hr) )
            {
                hr = SendEvent(SPEI_TTS_PRIVATE, pOutputSite, 0, ulTextOffset, ulTextLen);
            }
            // Mid-prompt pausing requires word boundaries.  We don't know word-boundaries within 
            // prompts, so approximate them by sending a word boundary event for every half-second
            // of audio.
            if ( SUCCEEDED(hr) )
            {
                ULONG ulOffset = 0;
                int iHalfSecs = iNumSamples / m_pOutputFormat->nSamplesPerSec * 2; 

                for ( i = 0; i <= iHalfSecs; i++ )
                {
                    ulOffset = i * (m_pOutputFormat->nSamplesPerSec / 2) * m_pOutputFormat->nBlockAlign;
                    SendEvent(SPEI_WORD_BOUNDARY, pOutputSite, ulOffset, ulTextOffset, ulTextLen);
                }
            }
            
            // write samples to output site
            if ( SUCCEEDED(hr) )
            {
                hr = ((CLocalTTSEngineSite*)(pOutputSite))->Write(pvSamples, iNumSamples * m_pOutputFormat->nBlockAlign, &pcbWritten);
                if ( SUCCEEDED(hr) )
                {
                    ((CLocalTTSEngineSite*)(pOutputSite))->UpdateBytesWritten();
                }
                delete [] pvSamples;
                pvSamples = NULL;
                iNumSamples = 0;
                pcbWritten = 0;
            }
        } // if ( SUCCEEDED(hr) )
        hr = CloseEntryFile();
    } // if ( SUCCEEDED(hr) 

    if ( pvSamples )
    {
        delete[]pvSamples;
        pvSamples = NULL;
        iNumSamples = 0;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


//////////////////////////////////////////////////////////////////////
//
// All of the following functions are non-interface helpers.
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// CPromptDb::ComputeRateAdj
//
// Computes the rate multiplier.
//
/////////////////////////////////////////////////////// JOEM 11-2000 //
void CPromptDb::ComputeRateAdj(const long lRate, float* flRate)
{
    SPDBG_FUNC( "CPromptDb::ComputeRateAdj" );

    SPDBG_ASSERT(flRate);

    if ( lRate < 0 )
    {
        if ( lRate < MIN_RATE )
        {
            *flRate = 1.0 / g_dRateScale[0 - MIN_RATE];
        }
        else
        {
            *flRate = 1.0 / g_dRateScale[0 - lRate];
        }
    }
    else 
    {
        if ( lRate > MAX_RATE )
        {
            *flRate = g_dRateScale[MAX_RATE];
        }
        else
        {
            *flRate = g_dRateScale[lRate];
        }
    }
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::SendEvent
//
// Sends the specified engine event to SAPI.
//
////////////////////////////////////////////////////// JOEM 11-2000 //
STDMETHODIMP CPromptDb::SendEvent(const SPEVENTENUM eventName, ISpTTSEngineSite* pOutputSite, 
                                  const ULONG ulAudioOffset, const ULONG ulTextOffset, const ULONG ulTextLen)
{
    SPDBG_ASSERT(pOutputSite);

    SPEVENT event;
    event.eEventId              = eventName;
    event.elParamType           = SPET_LPARAM_IS_UNDEFINED;
    event.ulStreamNum           = 0;
    event.ullAudioStreamOffset  = ulAudioOffset; //LocalEngineSite will add prev. bytes 
    event.lParam                = ulTextOffset;
    event.wParam                = ulTextLen;
    return pOutputSite->AddEvents( &event, 1 );
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::ApplyGain
//
// Volume adjustment.
//
////////////////////////////////////////////////////// JOEM 01-2001 //
STDMETHODIMP CPromptDb::ApplyGain(const void* pvInBuff, void** ppvOutBuff, const int iNumSamples, double dGain)
{
    SPDBG_FUNC( "CPromptDb::ApplyGain" );
    HRESULT hr      = S_OK;
    int     i       = 0;

    SPDBG_ASSERT(pvInBuff);
    SPDBG_ASSERT(iNumSamples);

    // Apply Volume
    if ( SUCCEEDED(hr) && dGain != 1.0 )
    {
        // NOTE THAT REGISTRY GAIN VALUE MAY BE GREATER THAN 1.
        // Make sure it is in bounds of SHRT_MAX, since we'll be multiplying it times samples
        if ( dGain > SHRT_MAX )
        {
            dGain = SHRT_MAX;
        }
        else if ( dGain < 0 ) // gain should never be < 0.
        {
            dGain = 1.0;
        }
        long lGain = ( dGain * (1 << g_iBase) );

        if ( m_pOutputFormat->wFormatTag == WAVE_FORMAT_ALAW || m_pOutputFormat->wFormatTag == WAVE_FORMAT_MULAW )
        {
            short*  pnBuff  = NULL;

            // need to convert samples
            int iOriginalFormatType  = VapiIO::TypeOf (m_pOutputFormat);

            if ( iOriginalFormatType == -1 )
            {
                hr = E_FAIL;
            }
            
            // Allocate the intermediate buffer
            if ( SUCCEEDED(hr) )
            {
                pnBuff = new short[iNumSamples];
                if ( !pnBuff )
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            // Allocate the final (out) buffer
            if ( SUCCEEDED(hr) )
            {
                *ppvOutBuff = new char[iNumSamples * VapiIO::SizeOf(iOriginalFormatType)];
                if ( !*ppvOutBuff )
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // Convert to something we can use
            if ( SUCCEEDED(hr) )
            {                
                if ( 0 == VapiIO::DataFormatConversion ((char *)pvInBuff, iOriginalFormatType, (char*)pnBuff, VAPI_PCM16, iNumSamples) )
                {
                    hr = E_FAIL;
                }
            }
            // Apply gain
            if ( SUCCEEDED(hr) )
            {
                double dSample = 0;

                for ( i=0; i<iNumSamples; i++ )
                {
                    dSample = pnBuff[i] * lGain;
                    if ( dSample > LONG_MAX )
                    {
                        pnBuff[i] = (short) (LONG_MAX >> g_iBase);
                    }
                    else if ( dSample < LONG_MIN )
                    {
                        pnBuff[i] = (short) (LONG_MIN >> g_iBase);
                    }
                    else
                    {
                        pnBuff[i] = (short) ( ( pnBuff[i] * lGain ) >> g_iBase );
                    }
                }
            }
            // convert it back (from intermediate buff to final out buff)
            if ( SUCCEEDED(hr) )
            {                
                if ( 0 == VapiIO::DataFormatConversion ((char *)pnBuff, VAPI_PCM16, (char*)*ppvOutBuff, iOriginalFormatType, iNumSamples) )
                {
                    hr = E_FAIL;
                }
            }

            if ( pnBuff )
            {
                delete [] pnBuff;
                pnBuff = NULL;
            }
        }
        else if ( m_pOutputFormat->wFormatTag == WAVE_FORMAT_PCM )
        {
            double dSample = 0;
            // no converting necessary
            switch ( m_pOutputFormat->nBlockAlign )
            {
            case 1:
                for ( i=0; i<iNumSamples; i++ )
                {
                    for ( i=0; i<iNumSamples; i++ )
                    {
                        dSample = ((char*)pvInBuff)[i] * lGain;
                        if ( dSample > LONG_MAX )
                        {
                            ((char*)pvInBuff)[i] = (char) (LONG_MAX >> g_iBase);
                        }
                        else if ( dSample < LONG_MIN )
                        {
                            ((char*)pvInBuff)[i] = (char) (LONG_MIN >> g_iBase);
                        }
                        else
                        {
                            ((char*)pvInBuff)[i] = (char) ( ( ((char*)pvInBuff)[i] * lGain ) >> g_iBase );
                        }
                    }
                }
                break;
            case 2:
                for ( i=0; i<iNumSamples; i++ )
                {
                    dSample = ((short*)pvInBuff)[i] * lGain;
                    if ( dSample > LONG_MAX )
                    {
                        ((short*)pvInBuff)[i] = (short) (LONG_MAX >> g_iBase);
                    }
                    else if ( dSample < LONG_MIN )
                    {
                        ((short*)pvInBuff)[i] = (short) (LONG_MIN >> g_iBase);
                    }
                    else
                    {
                        ((short*)pvInBuff)[i] = (short) ( ( ((short*)pvInBuff)[i] * lGain ) >> g_iBase );
                    }
                }
                break;
            default:
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }


    if ( FAILED(hr) )
    {
        if ( *ppvOutBuff )
        {
            delete [] *ppvOutBuff;
            *ppvOutBuff = NULL;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::ReadEntry
//
// Reads a Db entry from the Db file.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPromptDb::ReadEntry(FILE* fp, CPromptEntry** ppEntry)
{
    SPDBG_FUNC( "CPromptDb::ReadEntry" );
    HRESULT hr          = S_OK;
    WCHAR*  entryInfo   = NULL;
    WCHAR*  ptr         = NULL;
    WCHAR*  tmpTag      = NULL;
    WCHAR*  start       = NULL;
    SHORT   state       = 0;
    double  dEntryInfo  = 0.0;
    WCHAR   line[1024];
    WCHAR   fullPath[_MAX_PATH+1]  = L"";
    WCHAR   dir[_MAX_DIR]       = L"";
    bool    fId         = false;
    bool    fFile       = false;
    bool    fText       = false;
    bool    fOriginal   = false;
    bool    fFrom       = false;
    bool    fTo         = false;
    bool    fStart      = false;
    bool    fEnd        = false;
    bool    fLeft       = false;
    bool    fRight      = false;
    
    SPDBG_ASSERT (fp);
    
    *ppEntry = new CPromptEntry;
    if (!*ppEntry) 
    {
        hr = E_OUTOFMEMORY;
    }
    
    while ( ( state != -1 ) && SUCCEEDED(hr) ) 
    {
        if ( !fgetws(line, 1024, fp) ) 
        {
            if (state == 0) 
            {
                (*ppEntry)->Release();
                *ppEntry = NULL;
                hr = S_FALSE;
                break; /* No more entries to read */
            } 
            else 
            {
                hr = PEERR_DB_BAD_FORMAT; /* EOF in the middle of reading an entry*/
            }
        }

        if ( SUCCEEDED(hr) )
        {
            // Strip off the newline character
            if (line[wcslen(line)-1] == L'\n') 
            {
                line[wcslen(line)-1] = L'\0';
            }

            // Line ends when a comment marker is found
            if ( (ptr = wcschr (line, L'#')) != NULL ) {
                *ptr = L'\0';
            }
            
            ptr = line;
            
            WSkipWhiteSpace (ptr);
        }
        
        if ( SUCCEEDED(hr) )
        {
            while ( SUCCEEDED(hr) && *ptr )
            {
                switch (state) 
                {
                    
                case 0:
                    // Search for the starting tag
                    // Discard everything up to the starting tag
                    if ( wcsncmp( ptr, ENTRY_TAG, sizeof(ENTRY_TAG)/sizeof(ENTRY_TAG[0]) - 1 ) != 0) 
                    {
                        hr = PEERR_DB_BAD_FORMAT;
                    }
                    if ( SUCCEEDED (hr) )
                    {
                        ptr += wcslen (ENTRY_TAG);
                        state = 1;
                    }
                    break;
                    
                case 1:
                    
                    WSkipWhiteSpace (ptr);
                    
                    if (*ptr) 
                    {
                        if ( wcsncmp(ptr, ENTRY_START, sizeof(ENTRY_START)/sizeof(ENTRY_START[0]) - 1 ) ==0 ) 
                        {
                            ptr += wcslen (ENTRY_START);
                            state = 2;
                        } 
                        else 
                        {
                            hr = PEERR_DB_BAD_FORMAT;   
                        }
                    }
                    break;
                    
                case 2:
                    // Only one item per line 
                    
                    if ( (start = wcsstr(ptr, ENTRY_END)) != NULL) 
                    {
                        // If we find the entry_end marker, this is the last
                        // line. Remember, this line could have an item also
                        *start = L'\0';
                        state = -1;
                    }
                    
                    WSkipWhiteSpace (ptr);
                    
                    if (!*ptr) 
                    {
                        break;
                    }
                    
                    // Must be one of this elements of the entry,
                    // otherwise, error
                    hr = ExtractString (ptr, ID_TAG, &entryInfo); 
                    if ( SUCCEEDED (hr) ) 
                    {
                        if ( fId )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate ID field in database entry.");
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            hr = (*ppEntry)->SetId(entryInfo);
                        }
                        fId = true;
                        ptr = L"";
                        free(entryInfo);
                        entryInfo = NULL;
                        break;
                    }
                    
                    
                    hr = ExtractString (ptr, TEXT_TAG, &entryInfo); 
                    if ( SUCCEEDED (hr) )
                    {
                        if ( fText )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate TEXT field in database entry.");
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            hr = (*ppEntry)->SetText(entryInfo);
                        }
                        fText = true;
                        ptr = L"";
                        free(entryInfo);
                        entryInfo = NULL;
                        break;
                    }
                    
                    hr = ExtractString (ptr, ORIGINAL_TAG, &entryInfo); 
                    if ( SUCCEEDED (hr) )
                    {
                        if ( fOriginal )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate TEXT field in database entry.");
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            hr = (*ppEntry)->SetOriginalText(entryInfo);
                        }
                        fOriginal = true;
                        ptr = L"";
                        free(entryInfo);
                        entryInfo = NULL;
                        break;
                    }
                    
                    hr = ExtractString (ptr, FILE_TAG, &entryInfo);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( fFile )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate FILE NAME field in database entry.");
                        }

                        if ( SUCCEEDED(hr) )
                        {
                            if ( entryInfo )
                            {
                                // Is it a full path? (i.e, does it start with a "\" or is 2nd char a colon)
                                if ( wcslen(entryInfo) >= 2 && ( entryInfo[0] == L'\\' || entryInfo[1] == L':' ) )
                                {
                                    hr = (*ppEntry)->SetFileName(entryInfo);
                                }
                                else // must be a relative path
                                {
                                    // Construct the full path to the entry
                                    _wsplitpath(m_pActiveDb->pszPathName, fullPath, dir, NULL, NULL);
                                    wcscat(fullPath, dir);
                                    wcscat(fullPath, entryInfo);
                                    // Don't check this path here. We don't want Db loading to fail
                                    // if a wav doesn't exist -- load the db anyway, and later when
                                    // searching db, we check the paths and resort to TTS if path is invalid.
                                    hr = (*ppEntry)->SetFileName(fullPath);
                                }
                            }
                        }
            
                        fFile = true;
                        ptr = L"";
                        free(entryInfo);
                        entryInfo = NULL;
                        break;
                    }
                    
                    hr = ExtractString (ptr, TAG_TAG, &entryInfo);
                    if ( SUCCEEDED (hr) )
                    {
                        hr = (*ppEntry)->AddTag(entryInfo);
                        ptr = L"";
                        free(entryInfo);
                        entryInfo = NULL;
                        break;
                    }

                    hr = ExtractString (ptr, START_PHONE_TAG, &entryInfo);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( fStart )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate START PHONE field in database entry.");
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            hr = (*ppEntry)->SetStartPhone(entryInfo);
                        }
                        fStart = true;
                        ptr = L"";
                        free(entryInfo);
                        entryInfo = NULL;
                        break;
                    }
                    
                    hr = ExtractString (ptr, END_PHONE_TAG, &entryInfo);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( fEnd )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate END PHONE field in database entry.");
                        }
                        if ( SUCCEEDED(hr) ) 
                        {
                            hr = (*ppEntry)->SetEndPhone(entryInfo);
                        }
                        fEnd = true;
                        ptr = L"";
                        free(entryInfo);
                        entryInfo = NULL;
                        break;
                    }
                    
                    hr = ExtractString (ptr, RIGHT_CONTEXT_TAG, &entryInfo);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( fRight )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate RIGHT CONTEXT field in database entry.");
                        }
                        if ( SUCCEEDED(hr) ) 
                        {
                            hr = (*ppEntry)->SetRightContext(entryInfo);
                        }
                        fRight = true;
                        ptr = L"";
                        free(entryInfo);
                        entryInfo = NULL;
                        break;
                    }
                    
                    hr = ExtractString (ptr, LEFT_CONTEXT_TAG, &entryInfo);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( fLeft )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate LEFT CONTEXT field in database entry.");
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            hr = (*ppEntry)->SetLeftContext(entryInfo);
                        }
                        fLeft = true;
                        ptr = L"";
                        free(entryInfo);
                        entryInfo = NULL;
                        break;
                    }
                    
                    hr = ExtractDouble (ptr, FROM_TAG, &dEntryInfo);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( fFrom )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate FROM field in database entry.");
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            hr = (*ppEntry)->SetStart(dEntryInfo);
                        }
                        fFrom = true;
                        ptr = L"";
                        break;
                    }
                    
                    hr = ExtractDouble (ptr, TO_TAG, &dEntryInfo);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( fTo )
                        {
                            hr = PEERR_DB_BAD_FORMAT;
                            //SPDBG_ASSERT (!  "Duplicate TO field in database entry.");
                        }
                        if ( SUCCEEDED(hr) )
                        {
                            hr = (*ppEntry)->SetEnd(dEntryInfo);
                        }
                        fTo = true;
                        ptr = L"";
                        break;
                    }
                    
                    hr = PEERR_DB_BAD_FORMAT;
                    
                }  // switch (state)
                
            } // while (*ptr)
        }
    } // while ( SUCCEEDED(hr) && state != -1) 

    // THESE ARE THE MANDATORY FIELDS FOR THE DATABASE ENTRY
    if ( *ppEntry && SUCCEEDED(hr) )
    {
        if ( !fId )
        {
            //SPDBG_ASSERT (!  "Missing ID field in database entry.");
            hr = PEERR_DB_BAD_FORMAT;
        }
        if ( !fFile )
        {
            //SPDBG_ASSERT (!  "Missing FILE field in database entry.");
            hr = PEERR_DB_BAD_FORMAT;
        }
        if ( !fText )
        {
            //SPDBG_ASSERT (!  "Missing TEXT field in database entry.");
            hr = PEERR_DB_BAD_FORMAT;
        }
        if ( !fFrom )
        {
            //SPDBG_ASSERT (!  "Missing FROM field in database entry.");
            hr = PEERR_DB_BAD_FORMAT;
        }
        if ( !fTo )
        {
            //SPDBG_ASSERT (!  "Missing TO field in database entry.");
            hr = PEERR_DB_BAD_FORMAT;
        }
    }

    // From is less than To?
    if ( *ppEntry && SUCCEEDED(hr) )
    {
        double from = 0.0;
        double to   = 0.0;
        
        hr = (*ppEntry)->GetStart(&from);
        if ( SUCCEEDED(hr) )
        {
            hr = (*ppEntry)->GetEnd(&to);
        }
        if ( SUCCEEDED(hr) )
        {
            if ( to <= from )
            {
                // a value of -1.0 is ok for "to" -- it means play to end of file.
                if ( to != -1.0 )
                {
                    hr = PEERR_DB_BAD_FORMAT;
                }
            }
        }
    }

    if ( FAILED(hr) && *ppEntry )
    {
        (*ppEntry)->Release();
        *ppEntry = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::WriteEntry
//
// Writes a formated entry to a Db file.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPromptDb::WriteEntry(FILE *fp, IPromptEntry *pIPE)
{
    SPDBG_FUNC( "CPromptDb::WriteEntry" );
    HRESULT hr              = S_OK;
    const WCHAR* entryText  = NULL;

    SPDBG_ASSERT (fp);
    SPDBG_ASSERT (pIPE);

    fwprintf (fp, L"%s %s\n", ENTRY_TAG, ENTRY_START);
    
    if ( SUCCEEDED(hr) )
    {
        hr = pIPE->GetId(&entryText);
        if ( SUCCEEDED(hr) )
        {
            fwprintf (fp, L"\t%s %s\n", ID_TAG, entryText);
            entryText = NULL;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        hr = pIPE->GetText(&entryText);
        if ( SUCCEEDED(hr) )
        {
            fwprintf (fp, L"\t%s %s\n", TEXT_TAG, entryText);
            entryText = NULL;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        hr = pIPE->GetOriginalText(&entryText);
        if ( SUCCEEDED(hr) )
        {
            fwprintf (fp, L"\t%s %s\n", ORIGINAL_TAG, entryText);
            entryText = NULL;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        USHORT entryTagCount = 0;
        hr = pIPE->CountTags(&entryTagCount);
        if ( SUCCEEDED(hr) && entryTagCount )
        {
            for ( USHORT i=0; i < entryTagCount; i++) 
            {
                hr = pIPE->GetTag(&entryText, i);
                if ( SUCCEEDED(hr) )
                {
                    fwprintf( fp, L"\t%s %s\n", TAG_TAG, entryText );
                    entryText = NULL;
                }
            }

        }
    }
    
    if ( SUCCEEDED(hr) )
    {
        hr = pIPE->GetFileName(&entryText);
        if ( SUCCEEDED(hr) )
        {
            fwprintf (fp, L"\t%s %s\n", FILE_TAG, entryText);
            entryText = NULL;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        double start = 0.0;
        hr = pIPE->GetStart(&start);
        if ( SUCCEEDED(hr) )
        {
            fwprintf( fp, L"\t%s %f\n", FROM_TAG, start);
        }
    }

    if ( SUCCEEDED(hr) )
    {
        double end = 0.0;
        hr = pIPE->GetEnd(&end);
        if ( SUCCEEDED(hr) )
        {
            fwprintf( fp, L"\t%s %f\n", TO_TAG, end);
        }
    }

    fwprintf (fp, L"%s\n\n", ENTRY_END);
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::DuplicateEntry
//
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
CPromptEntry* CPromptDb::DuplicateEntry(const CPromptEntry *oldEntry)
{
    SPDBG_FUNC( "CPromptDb::DuplicateEntry" );
    CPromptEntry* newEntry = new CPromptEntry(*oldEntry);

    return newEntry;
}


//////////////////////////////////////////////////////////////////////
// CPromptDb::ExtractString
//
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPromptDb::ExtractString(WCHAR *line, const WCHAR *tag, WCHAR **value)
{
    SPDBG_FUNC( "CPromptDb::ExtractString" );
    HRESULT hr          = S_OK;
    int     tagLen      = 0;
    int     entryLen    = 0;
    
    tagLen = (USHORT) wcslen (tag);
    
    if (wcsncmp(line, tag, tagLen)==0) 
    {
        line += tagLen;
        
        WSkipWhiteSpace (line);
        
        for (entryLen = wcslen(line) -1; entryLen>=0 && iswspace(line[entryLen]); entryLen--) 
        {
            line[entryLen] = L'\0';
        }
        
        // Control characters are not allowed in Db
        if ( FindUnicodeControlChar(line) )
        {
            hr = E_UNEXPECTED;
        }
        
        if ( SUCCEEDED(hr) && !wcslen(line) )
        {
            hr = E_INVALIDARG;
        }

        if ( SUCCEEDED(hr) )
        {
            if ((*value = _wcsdup(line)) == NULL) 
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else 
    {
        hr = E_FAIL;
    }

    // Don't report failures here - this func is allowed to fail frequently.
    //SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::ExtractDouble
//
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPromptDb::ExtractDouble(WCHAR *line, const WCHAR *tag, double *value)
{
    SPDBG_FUNC( "CPromptDb::ExtractDouble" );
    HRESULT hr          = S_OK;
    int     tagLen      = 0;
    int     entryLen    = 0;
    WCHAR*  psz         = NULL;

    *value = 0.0;

    tagLen = (USHORT) wcslen (tag);
    
    if (wcsncmp(line, tag, tagLen)==0) 
    {
        line += tagLen;
        
        WSkipWhiteSpace (line);
        
        for (entryLen = wcslen(line) -1; entryLen>=0 && iswspace(line[entryLen]); entryLen--) 
        {
            line[entryLen] = L'\0';
        }
        
        // Control characters are not allowed in Db
        if ( FindUnicodeControlChar(line) )
        {
            hr = E_UNEXPECTED;
        }

        if ( SUCCEEDED(hr) && !wcslen(line) )
        {
            hr = E_INVALIDARG;
        }

        // make sure it's a number
        if ( SUCCEEDED(hr) )
        {
            psz = line;
            while ( SUCCEEDED(hr) && psz[0] )
            {
                if ( iswdigit(psz[0]) || psz[0] == L'.' || psz[0] == L'-' )
                {
                    psz++;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
        }

        if ( SUCCEEDED(hr) )
        {
            *value = wcstod( line, NULL );
        }

        if ( SUCCEEDED(hr) && *value < 0 && *value != -1.0 )
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    // Don't report failures here - this func is allowed to fail frequently.
    //SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::TempName
//
// Creates a temporary file name for the active db.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPromptDb::TempName()
{
    SPDBG_FUNC( "CPromptDb::TempName" );
    HRESULT hr = S_OK;
    WCHAR   nameStr[256];
    
    SPDBG_ASSERT( m_pActiveDb );
    SPDBG_ASSERT( m_pActiveDb->pszPathName );
    
    wcscat( wcscpy( nameStr, m_pActiveDb->pszPathName ), L".tmp" );
    
    if ( m_pActiveDb->pszTempName && (wcscmp( m_pActiveDb->pszTempName, nameStr ) != 0) )
    {
        free (m_pActiveDb->pszTempName);
        m_pActiveDb->pszTempName = NULL;
    }

    if ( !m_pActiveDb->pszTempName ) 
    {
        if ( ( m_pActiveDb->pszTempName = _wcsdup(nameStr) ) == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr; 
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::IndexTextHash
//
// Makes a text hash.   Key:    text
//                      Value:  list of IDs for that text 
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
HRESULT CPromptDb::IndexTextHash()
{
    SPDBG_FUNC( "CPromptDb::IndexTextHash" );
    HRESULT         hr          = S_OK;
    WCHAR*          id          = NULL;
    const WCHAR*    entryInfo   = NULL;
    USHORT          idx1        = 0;
    USHORT          idx2        = 0;
    USHORT          i           = 0;
    USHORT          found       = 0;
    CPromptEntry*   entry       = NULL;
    CDynStrArray*   candList    = NULL;

    while ( SUCCEEDED(hr) )
    {
        m_pActiveDb->idHash.NextKey (&idx1, &idx2, &id);
        if ( !id )
        {
            // this was the last one
            break;
        }

        if ( SUCCEEDED(hr) )
        {
            entry = (CPromptEntry*) m_pActiveDb->idHash.Find(id);
            if ( !entry )
            {
                hr = E_UNEXPECTED;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            hr = entry->GetText(&entryInfo);
            
            if ( SUCCEEDED(hr) )
            {
                // Is there already a list of entries for this text?  If not, create one.
                if ( (candList = (CDynStrArray*) m_pActiveDb->textHash.Find(entryInfo)) == NULL )
                {
                    candList = new CDynStrArray;
                    if (!candList)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    if ( SUCCEEDED(hr) )
                    {
                        hr = m_pActiveDb->textHash.BuildEntry(entryInfo, candList);
                    }
                }
            }
            entryInfo = NULL;
            
            if ( SUCCEEDED(hr) )
            {
                // Search the list, check that the entry doesn't exist
                found = 0;
                hr = entry->GetId(&entryInfo);
                
                if ( SUCCEEDED(hr) )
                {
                    for ( i = 0; i < candList->m_aDstr.GetSize(); i++ )
                    {
                        if ( wcscmp(candList->m_aDstr[i].dstr, entryInfo) == 0 )
                        {
                            found = 1;
                            break;
                        }
                    }
                    
                    if ( !found )
                    {
                        // Add item to the list, the list is already in the hash table
                        candList->m_aDstr.Add(entryInfo);
                    }
                    entryInfo = NULL;
                }
            }

            entry = NULL;
        } // if ( SUCCEEDED(hr) )

    } // while

    if ( FAILED(hr) )
    {
        if ( candList )
        {
            delete candList;
            candList = NULL;
        }
    }

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptDb::GetPromptFormat
//
// Gets the format of the first prompt file, used for setting the 
// output format.  Note, however, that the application can change the 
// format, and that prompt files do not need to be all in the same 
// format.
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptDb::GetPromptFormat (WAVEFORMATEX **ppwf)
{
    HRESULT hr      = E_FAIL;
    USHORT  unId1   = 0;
    USHORT  unId2   = 0;
    WCHAR   *pszId  = NULL;    
    IPromptEntry* pIPE = NULL;

    while ( FAILED(hr) ) 
    {
        hr = GetNextEntry(&unId1, &unId2, &pIPE);
    }

    if ( hr == S_OK )
    {
        WAVEFORMATEX* newWF = (WAVEFORMATEX*)::CoTaskMemAlloc( sizeof(WAVEFORMATEX) );

        if ( newWF )
        {
            hr = pIPE->GetFormat( &newWF );
            newWF->cbSize           = 0;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED(hr) )
        {
            *ppwf = newWF;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\prompteng.cpp ===
/////////////////////////////////////////////////////////////////////////////
// PromptEng.cpp : Implementation of CPromptEng
//
// Prompt Engine concatenates pre-recorded phrases for voice output, and 
// falls back on TTS Engine when pre-recorded phrases are unavailable.
//
// Created by JOEM  01-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
//////////////////////////////////////////////////////////// JOEM  01-2000 //
#include "stdafx.h"
#include "MSPromptEng.h"
#include "PromptEng.h"
#include "XMLTag.h"
#include "vapiIO.h"
#include "common.h"

// Text fragments with over 1024 chars should use TTS (no search).
#define MAX_SEARCH_LEN 1024

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::FinalConstruct
//
// Constructor:  Creates the Prompt Db object, TTS voice, and local output site
//
//////////////////////////////////////////////////////////// JOEM  01-2000 //
HRESULT CPromptEng::FinalConstruct()
{
    SPDBG_FUNC( "CPromptEng::FinalConstruct" );
    HRESULT hr              = S_OK;

    m_pOutputSite   = NULL;
    m_dQueryCost    = 0.0;
    m_fAbort        = false;

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpPromptDb.CoCreateInstance(CLSID_PromptDb);
    }
    
    if ( SUCCEEDED( hr ) )
    {
        m_pOutputSite   = new CLocalTTSEngineSite;
        if ( !m_pOutputSite )
        {
            hr = E_OUTOFMEMORY;
        } 
    }

    if ( FAILED( hr ) )
    {
        if ( m_cpPromptDb )
        {
            m_cpPromptDb.Release();
        }
        if ( m_pOutputSite )
        {
            m_pOutputSite->Release();
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;

} /* CPromptEng::FinalConstruct */

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::FinalRelease
//
// Destructor
//
//////////////////////////////////////////////////////////// JOEM  01-2000 //
void CPromptEng::FinalRelease()
{
    SPDBG_FUNC( "CPromptEng::FinalRelease" );
    USHORT i = 0;

    if ( m_cpPromptDb )
    {
        m_cpPromptDb.Release();
    }

    if ( m_cpTTSEngine )
    {
        m_cpTTSEngine.Release();
    }

    if ( m_pOutputSite )
    {
        m_pOutputSite->Release();
    }

    for ( i=0; i<m_apQueries.GetSize(); i++ )
    {
        if ( m_apQueries[i] )
        {
            delete m_apQueries[i];
            m_apQueries[i] = NULL;
        }
    }
    m_apQueries.RemoveAll();

} /* CPromptEng::FinalRelease */

 
/////////////////////////////////////////////////////////////////////////////
// CPromptEng::SetObjectToken
//
// Get all of the relevant registry information for this voice
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //
STDMETHODIMP CPromptEng::SetObjectToken(ISpObjectToken * pToken)
{
    SPDBG_FUNC( "CPromptEng::SetObjectToken" );
    HRESULT hr                  = S_OK;
    ISpDataKey* pDataKey        = NULL;
    WCHAR  pszKey[USHRT_MAX]    = L"";
    USHORT i                    = 0;
    CSpDynamicString dstrPath;
    CSpDynamicString dstrName;
    CSpDynamicString dstrTTSVoice;
    CSpDynamicString dstrGain;

    hr = SpGenericSetObjectToken(pToken, m_cpToken);

    // Get the associated TTS voice token, set the voice and output site
    if ( SUCCEEDED( hr ) )
    {
        hr = m_cpToken->GetStringValue( L"TTSVoice", &dstrName );

        if ( SUCCEEDED( hr ) && dstrName.Length() )
        {
            dstrTTSVoice = L"NAME=";
            dstrTTSVoice.Append(dstrName);

            CComPtr<IEnumSpObjectTokens> cpEnum;
            hr = SpEnumTokens( SPCAT_VOICES, dstrTTSVoice, NULL, &cpEnum );
            if( SUCCEEDED(hr) )
            {
                hr = cpEnum->Next( 1, &m_cpTTSToken, NULL );
            }

            // Any tokens?
            if ( hr != S_OK )
            {
                hr = E_INVALIDARG;
            }

            // Make sure the secondary voice is not another Prompt voice!
            if ( SUCCEEDED(hr) )
            {
                CSpDynamicString dstrTTSEngId;
                CSpDynamicString dstrPromptEngId = CLSID_PromptEng;
                
                hr = m_cpTTSToken->GetStringValue( L"CLSID", &dstrTTSEngId );
                
                if ( SUCCEEDED(hr) )
                {
                    if ( !wcscmp(dstrPromptEngId, dstrTTSEngId) )
                    {
                        hr = E_INVALIDARG;
                    }
                }
                dstrPromptEngId.Clear();
                dstrTTSEngId.Clear();
            }

            if ( SUCCEEDED(hr) )
            {
                hr = SpCreateObjectFromToken( m_cpTTSToken, &m_cpTTSEngine );
            }
        }
        dstrName.Clear();
        dstrTTSVoice.Clear();
    }
    
    // Allow no TTS Engine
    if ( FAILED(hr) )
    {
        //SPDBG_ASSERT(!m_cpTTSEngine);
        hr = S_FALSE;
    }

    // Gain factor for Prompt Entry output
    if ( SUCCEEDED( hr ) )
    {
        hr = m_cpToken->GetStringValue( L"PromptGain", &dstrGain );
        if ( SUCCEEDED(hr) )
        {
            hr = m_cpPromptDb->SetEntryGain( wcstod( dstrGain, NULL ) );
        }
        dstrGain.Clear();
    }

    // Load the text expansion/normalization rules
    // Implementation is script-language independent:  language specified in registry entry.
    if ( SUCCEEDED( hr ) )
    {
        wcscpy(pszKey, L"PromptRules");
        hr = m_cpToken->OpenKey(pszKey, &pDataKey);

        if ( SUCCEEDED(hr) )
        {
            pDataKey->GetStringValue( L"Path", &dstrPath );
            pDataKey->GetStringValue( L"ScriptLanguage", &dstrName );
            if ( dstrName.Length() && dstrPath.Length() )
            {
                hr = m_textRules.ReadRules(dstrName, dstrPath);
            }
            dstrPath.Clear();
            dstrName.Clear();
            pDataKey->Release();
            pDataKey = NULL;
        }
        else 
        {
            hr = S_FALSE;  // allow no rules file
        }
    }

    // Load the phone context file.  (Might be able to do this from language id instead of registry entry.)
    if ( SUCCEEDED( hr ) )
    {
        hr = m_cpToken->GetStringValue( L"PhContext", &dstrPath );
        if ( SUCCEEDED ( hr ) )
        {
            if ( wcscmp( dstrPath, L"DEFAULT" ) == 0 )
            {
                hr = m_phoneContext.LoadDefault();
            }
            else
            {
                hr = m_phoneContext.Load(dstrPath);
            }
        }
        else
        {
            hr = m_phoneContext.LoadDefault();
        }
        dstrPath.Clear();
    }

    // Get all of the Db Entries from the registry for this voice, add them to the list
    while ( SUCCEEDED ( hr ) )
    {
        CSpDynamicString dstrID;

        swprintf( pszKey, L"PromptData%hu", i );

        hr = m_cpToken->OpenKey(pszKey, &pDataKey);
        if ( i > 0 && hr == SPERR_NOT_FOUND )
        {
            hr = S_OK;
            break;
        }
        if ( SUCCEEDED(hr) )
        {
            hr = pDataKey->GetStringValue( L"Path", &dstrPath );
            if ( FAILED(hr) || !wcslen(dstrPath) )
            {
                hr = S_FALSE; // empty keys are just skipped.
            }
        }
        if ( hr == S_OK )
        {
            hr = pDataKey->GetStringValue( L"Name", &dstrName );
            if ( FAILED(hr) || !wcslen(dstrName) )
            {
                dstrName = L"DEFAULT";
                hr = S_OK;
            }
        }
        if ( hr == S_OK )
        {
            pDataKey->GetStringValue( L"ID Set", &dstrID ); // might not exist
        }
        if ( hr == S_OK )
        {
            WStringUpperCase(dstrName);
            if ( dstrID )
            {
                WStringUpperCase(dstrID);
            }
            hr = m_cpPromptDb->AddDb( dstrName, dstrPath, dstrID, DB_LOAD);
        }
        if ( SUCCEEDED ( hr ) )
        {
            i++;
        }
        dstrPath.Clear();
        dstrName.Clear();
        dstrID.Clear();
        if ( pDataKey )
        {
            pDataKey->Release();
            pDataKey = NULL;
        }
    }

    // Activate the default Db (or first Db, if "DEFAULT" doesn't exist)
    if ( SUCCEEDED(hr) )
    {
        hr = m_cpPromptDb->ActivateDbName(L"DEFAULT");

        if ( FAILED (hr) ) 
        {
            hr = m_cpPromptDb->ActivateDbNumber(0);
        }
    }
    
    // Initialize the Db Searching class
    if ( SUCCEEDED( hr ) )
    {
        hr = m_DbQuery.Init( m_cpPromptDb.p, &m_phoneContext );
    }    

    if ( SUCCEEDED(hr) )
    {
        hr = m_pOutputSite->SetBufferSize(20); 
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::GetOutputFormat
//
// Gets the output format for the prompts and TTS.
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //
STDMETHODIMP CPromptEng::GetOutputFormat( const GUID * pTargetFormatId, 
                                         const WAVEFORMATEX * pTargetWaveFormatEx,
                                         GUID * pDesiredFormatId, 
                                         WAVEFORMATEX ** ppCoMemDesiredWaveFormatEx )
{
    SPDBG_FUNC( "CPromptEng::GetOutputFormat" );
    HRESULT hr = S_OK;

    SPDBG_ASSERT(m_cpPromptDb);

    if( ( SP_IS_BAD_WRITE_PTR(pDesiredFormatId)  ) || 
        ( SP_IS_BAD_WRITE_PTR(ppCoMemDesiredWaveFormatEx) ) )
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED(hr) )
    {
        // Use TTS preferred format if available
        if ( m_cpTTSEngine )
        {
            hr = m_cpTTSEngine->GetOutputFormat( pTargetFormatId, pTargetWaveFormatEx, pDesiredFormatId, ppCoMemDesiredWaveFormatEx );
        }
        else if ( m_cpPromptDb )
        {
            // otherwise, agree to text format if requested... 
            if ( pTargetFormatId && *pTargetFormatId == SPDFID_Text )
            {
                *pDesiredFormatId = SPDFID_Text;
                *ppCoMemDesiredWaveFormatEx = NULL;
            }
            // ...or use prompt format. 
            else
            {
                hr = m_cpPromptDb->GetPromptFormat(ppCoMemDesiredWaveFormatEx);
                if ( SUCCEEDED(hr) )
                {
                    *pDesiredFormatId = SPDFID_WaveFormatEx;
                }
            }
        }
    }

    if ( SUCCEEDED(hr) )
    {
        if ( pDesiredFormatId )
        {
            hr = m_pOutputSite->SetOutputFormat( pDesiredFormatId, *ppCoMemDesiredWaveFormatEx );
            if ( SUCCEEDED(hr) )
            {
                hr = m_cpPromptDb->SetOutputFormat( pDesiredFormatId, *ppCoMemDesiredWaveFormatEx );
            }
        }
        else
        {
            hr = m_pOutputSite->SetOutputFormat( pTargetFormatId, pTargetWaveFormatEx );
            if ( SUCCEEDED(hr) )
            {
                hr = m_cpPromptDb->SetOutputFormat( pTargetFormatId, pTargetWaveFormatEx );
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPromptEng::Speak
//
// Builds a Db Query list from the frag list, and dispatches the fragments
// to prompts or tts accordingly.
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //
STDMETHODIMP CPromptEng::Speak(DWORD dwSpeakFlags, 
                            REFGUID rguidFormatId, 
                            const WAVEFORMATEX * pWaveFormatEx,
                            const SPVTEXTFRAG* pTextFragList, 
                            ISpTTSEngineSite* pOutputSite)
{ 
    SPDBG_FUNC( "CPromptEng::Speak" );
    HRESULT hr  = S_OK;
    m_fAbort = false;

    //--- Check args
    if( SP_IS_BAD_INTERFACE_PTR( pOutputSite )  ||
        SP_IS_BAD_READ_PTR( pTextFragList )     ||
        ( dwSpeakFlags & SPF_UNUSED_FLAGS )     )
    {
        return E_INVALIDARG;
    }

    if ( m_pOutputSite )
    {
        m_pOutputSite->SetOutputSite( pOutputSite );
    }
    
    if ( SUCCEEDED (hr) )
    {
        hr = BuildQueryList( dwSpeakFlags, pTextFragList, SAPI_FRAG );
    }
    //DebugQueryList();
    
    if ( SUCCEEDED(hr) && !m_fAbort )
    {
        hr = CompressQueryList();
    }
    //DebugQueryList();
    
    if ( SUCCEEDED(hr) && !m_fAbort )
    {
        hr = m_DbQuery.Query( &m_apQueries, &m_dQueryCost, m_pOutputSite, &m_fAbort );
    }
    //DebugQueryList();

    if ( SUCCEEDED(hr) && !m_fAbort )
    {
        hr = CompressTTSItems(rguidFormatId);
    }
    //DebugQueryList();
    
    if ( SUCCEEDED (hr) && !m_fAbort )
    {
        hr = DispatchQueryList(dwSpeakFlags, rguidFormatId, pWaveFormatEx);
    }

    // Successful or not, delete the query list
    for ( int i=0; i<m_apQueries.GetSize(); i++ )
    {
        if ( m_apQueries[i] )
        {
            delete m_apQueries[i];
            m_apQueries[i] = NULL;
        }
    }
    m_apQueries.RemoveAll();
    m_dQueryCost = 0.0;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::BuildQueryList
//
// Steps through the frag list, handling known XML tags, and builds a list
// of CQuery items.  This function is pseudo-recursive:  If a text expansion
// rule modifies a text frag, this calls CPromptEng::ParseSubQuery to build a 
// secondary fragment list.  ParseSubQuery then calls this function again.
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //
STDMETHODIMP CPromptEng::BuildQueryList(const DWORD dwSpeakFlags, const SPVTEXTFRAG* pCurrentFrag, const FragType fFragType)
{
    SPDBG_FUNC( "CPromptEng::BuildQueryList" );
    HRESULT hr               = S_OK;
    USHORT  i                = 0;
    USHORT  subQueries       = 0;
    bool    fTTSOnly         = false;
    bool    fRuleDone        = false;
   	CQuery* pQuery           = NULL;
    WCHAR*  pszRuleName      = NULL;
    CSPArray<CDynStr,CDynStr> aTags;

    if ( SP_IS_BAD_READ_PTR( pCurrentFrag )  )
    {
        return E_INVALIDARG;
    }

    while ( pCurrentFrag && SUCCEEDED(hr) )
    {
        // Stop speaking?
        if ( m_pOutputSite->GetActions() & SPVES_ABORT )
        {
            m_fAbort = true;
            break;
        }
        
        if ( SUCCEEDED(hr) )
        {
            // If there is nothing in this frag, just go immediately to next one
            if ( pCurrentFrag->State.eAction == SPVA_Speak && !pCurrentFrag->ulTextLen )
            {
                // Go to the next frag
                pCurrentFrag = pCurrentFrag->pNext;
                continue;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            // Otherwise, create a new query
            pQuery = new CQuery;
            if ( !pQuery )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            pQuery->m_fFragType = fFragType;
            
            // Apply a rule to expand the text, if necessary
            if ( pszRuleName && !fRuleDone)
            {
                fRuleDone = true;
                WCHAR* pszOriginalText = (WCHAR*) malloc( sizeof(WCHAR) * (pCurrentFrag->ulTextLen + 1) );
                if ( !pszOriginalText )
                {
                    hr = E_OUTOFMEMORY;
                }
                if ( SUCCEEDED(hr) )
                {
                    wcsncpy(pszOriginalText, pCurrentFrag->pTextStart, pCurrentFrag->ulTextLen);
                    pszOriginalText[pCurrentFrag->ulTextLen] = L'\0';
                    hr = m_textRules.ApplyRule( pszRuleName, pszOriginalText, &pQuery->m_pszExpandedText );
                    if ( SUCCEEDED(hr) )
                    {
                        free(pszOriginalText); 
                        pszOriginalText = NULL;
                        USHORT currListSize = (USHORT) m_apQueries.GetSize();
                        hr = ParseSubQuery( dwSpeakFlags, pQuery->m_pszExpandedText, &subQueries );
                        // Adjust the text offset and len here.  ParseSubQuery needs the len of the modified 
                        // text, but later, the app will need the offset & len of the original text for highlighting it.
                        for ( i=currListSize; i<m_apQueries.GetSize(); i++ )
                        {
                            m_apQueries[i]->m_ulTextOffset = pCurrentFrag->ulTextSrcOffset;
                            m_apQueries[i]->m_ulTextLen = pCurrentFrag->ulTextLen;
                        }
                        
                        // Prefer to speak the subqueries rather than the orig frag.
                        // But keep the orig, in case subq's fail.
                        if ( subQueries )
                        {
                            pQuery->m_fSpeak = false;
                        } // if ( !subQueries )
                    }
                    else // If the rule application fails, just use the original text.
                    {
                        hr = S_OK;
                        //SPDBG_ASSERT( ! "Rule doesn't exist." );
                        pQuery->m_pszExpandedText = pszOriginalText;
                    }
                }
            }
            else // if no expansion rule, set the expanded text to the original text
            {
                pQuery->m_pszExpandedText = (WCHAR*) malloc( sizeof(WCHAR) * (pCurrentFrag->ulTextLen + 1));
                if ( !pQuery->m_pszExpandedText )
                {
                    hr = E_OUTOFMEMORY;
                }
                if ( SUCCEEDED(hr) )
                {
                    wcsncpy(pQuery->m_pszExpandedText, pCurrentFrag->pTextStart, pCurrentFrag->ulTextLen);
                    pQuery->m_pszExpandedText[pCurrentFrag->ulTextLen] = L'\0';
                }
            } // else
        } // if ( SUCCEEDED(hr) )
        
        // Unicode control chars map to space
        if ( SUCCEEDED(hr) && pQuery->m_pszExpandedText )
        {
            WCHAR* psz = pQuery->m_pszExpandedText;
            
            while ( ( psz = FindUnicodeControlChar(psz) ) != NULL )
            {
                psz[0] = L' ';
            }
        }
        
        // HANDLE XML IN THE TEXT FRAG
        if ( SUCCEEDED(hr) )
        {
            // Is there an unknown tag is this fragment?
            if ( pCurrentFrag->State.eAction == SPVA_ParseUnknownTag )
            {
                CXMLTag unknownTag; 
                
                hr = unknownTag.ParseUnknownTag( pQuery->m_pszExpandedText );
                // if this is a new RULE, set flag to process it.
                if ( SUCCEEDED(hr) )
                {
                    const WCHAR* pszName = NULL;
                    
                    hr = unknownTag.GetTagName(&pszName);
                    if ( wcscmp(pszName, XMLTags[RULE_END].pszTag) == 0 )
                    {
                        fRuleDone = false;
                    }
                    
                    if ( SUCCEEDED (hr) )
                    {
                        hr = unknownTag.ApplyXML( pQuery, fTTSOnly, pszRuleName, aTags );
                        if ( hr == S_FALSE )
                        {
                            // Don't know this XML -- must ignore or send it to TTS
                            if ( !fTTSOnly )
                            {
                                pQuery->m_afEntryMatch.Add(false);
                            }
                            else
                            {
                                pQuery->m_afEntryMatch.Add(true);
                            }
                        }
                    }
                    else
                    {
                        pQuery->m_fSpeak = false;
                        hr = S_OK;
                    }
                }
            } // if ( pCurrentFrag->State.eAction == SPVA_ParseUnknownTag )
            else if ( pCurrentFrag->State.eAction == SPVA_Bookmark )
            {
                pQuery->m_fXML = UNKNOWN_XML;
                if ( !fTTSOnly )
                {
                    pQuery->m_afEntryMatch.Add(false);
                }
                else
                {
                    pQuery->m_afEntryMatch.Add(true);
                }
            }
            else if ( pCurrentFrag->State.eAction == SPVA_Silence )
            {
                pQuery->m_fXML = SILENCE;
                if ( !fTTSOnly )
                {
                    pQuery->m_afEntryMatch.Add(false);
                }
                else
                {
                    pQuery->m_afEntryMatch.Add(true);
                }
            }
        } // if ( SUCCEEDED(hr) )


        // Finish setting up this query item
        // We need a copy of the text frag, so we can break the links
        // when inserting new frags based on text expansion rules.
        if ( SUCCEEDED(hr) )
        {
            pQuery->m_pTextFrag = new SPVTEXTFRAG(*pCurrentFrag);
            if ( !pQuery->m_pTextFrag )
            {
                hr = E_OUTOFMEMORY;
            }
            if ( SUCCEEDED(hr) )
            {
                pQuery->m_pTextFrag->pNext = NULL;
                pQuery->m_ulTextOffset = pCurrentFrag->ulTextSrcOffset;
                pQuery->m_ulTextLen    = pCurrentFrag->ulTextLen;
                
                // Use TTS if:
                //  - it's a TTS item
                //  - text is too long
                //  - need to speak punctuation
                if ( (dwSpeakFlags & SPF_NLP_SPEAK_PUNC) 
                    || fTTSOnly 
                    || pQuery->m_pTextFrag->ulTextLen > MAX_SEARCH_LEN )
                {
                    pQuery->m_fTTS = true;
                }
                // This keeps track of WITHTAG tags
                if ( aTags.GetSize() )
                {
                    pQuery->m_paTagList = new CSPArray<CDynStr,CDynStr>;
                    if ( !pQuery->m_paTagList )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    if ( SUCCEEDED(hr) )
                    {
                        for ( i=0; i < aTags.GetSize(); i++)
                        {
                            pQuery->m_paTagList->Add(aTags[i]);
                        }
                    }
                }
                
                // If this is a TTS item, make sure there is a TTS engine
                if ( pQuery->m_fTTS && !m_cpTTSEngine )
                {
                    hr = PEERR_NO_TTS_VOICE;
                }

                // Add it to the query list
                m_apQueries.Add(pQuery);
                pQuery = NULL;
                subQueries = 0;

                // Go to the next frag
                pCurrentFrag = pCurrentFrag->pNext;
            }
        }
    } // while ( pCurrentFrag )

    // MEMORY CLEANUP ON ERROR
    if ( FAILED(hr) )
    {
        if ( pszRuleName )
        {
            free(pszRuleName);
            pszRuleName = NULL;
        }
        if ( pQuery )
        {
            delete pQuery;
            pQuery = NULL;
        }

        for ( i=0; i<aTags.GetSize(); i++ )
        {
            aTags[i].dstr.Clear();
        }
        aTags.RemoveAll();

        for ( i=0; i<m_apQueries.GetSize(); i++ )
        {
            if ( m_apQueries[i] )
            {
                delete m_apQueries[i];
                m_apQueries[i] = NULL;
            }
        }
        m_apQueries.RemoveAll();
    }

    // This makes sure we don't leak memory if user forgets to close <RULE> </RULE> tag.
    if ( pszRuleName )
    {
        free(pszRuleName);
        pszRuleName = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::ParseSubQuery
//
// When a text expansion rule modifies a text fragment, it may insert new
// XML tags that need to be added to the fragment list.  This function is 
// called to build a new fragment list out of the modified text (which may
// or may not include new XML tags).  This function then calls 
// CPromptEng::BuildQueryList to add CQueries based on the new fragment list.
//
//////////////////////////////////////////////////////////// JOEM  04-2000 //
STDMETHODIMP CPromptEng::ParseSubQuery(const DWORD dwSpeakFlags, const WCHAR *pszText, USHORT* unSubQueries)
{
    SPDBG_FUNC( "CPromptEng::ParseSubQuery" );
    HRESULT hr              = S_OK;
    const WCHAR* p          = NULL;
    const WCHAR* pTagStart  = NULL;
    const WCHAR* pTagEnd    = NULL;
    const WCHAR* pStart     = NULL;
    SPVTEXTFRAG* pNextFrag  = NULL;
    SPVTEXTFRAG* pFrag      = NULL;
    SPVTEXTFRAG* pFirstFrag = NULL;

    SPDBG_ASSERT(pszText);
    
    // need a copy of this text 
    pStart = pszText;
    p = pszText;

    WSkipWhiteSpace(pStart);
    WSkipWhiteSpace(pStart);

    // Find an XML tag
    while ( pTagStart = wcschr(p, L'<') )
    {
        // if the first char is a tag, make a frag out of it
        if ( pTagStart == p )
        {            
            pTagEnd = wcschr(pTagStart, L'>');
            if ( !pTagEnd )
            {
                hr = E_INVALIDARG;
            }

            // Create a new SPVTEXTFRAG consisting of just this XML tag.
            if ( SUCCEEDED(hr) )
            {
                pNextFrag = new SPVTEXTFRAG;
                if ( !pNextFrag )
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            if ( SUCCEEDED(hr) )
            {
                memset( pNextFrag, 0, sizeof (SPVTEXTFRAG) );
                memset( &pNextFrag->State, 0, sizeof (SPVSTATE) );
                pNextFrag->pTextStart = pTagStart;
                pNextFrag->ulTextLen = pTagEnd - pTagStart + 1;
                pNextFrag->State.eAction = SPVA_ParseUnknownTag;
                p = ++pTagEnd;
                (*unSubQueries)++;
            }
        }
        // if some text was skipped when searching for '<',
        // make a frag out of the skipped text.
        else 
        {
            pNextFrag = new SPVTEXTFRAG;
            if ( !pNextFrag )
            {
                hr = E_OUTOFMEMORY;
            }
            if ( SUCCEEDED(hr) )
            {
                memset( pNextFrag, 0, sizeof(SPVTEXTFRAG) );
                memset( &pNextFrag->State, 0, sizeof (SPVSTATE) );
                pNextFrag->pTextStart = p;
                pNextFrag->ulTextLen = pTagStart - p;
                pNextFrag->State.eAction = SPVA_Speak;
                p = pTagStart;
                (*unSubQueries)++;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            // Was this the first fragment?
            if ( pFrag )
            {
                pFrag->pNext = pNextFrag;
            }
            else
            {
                pFrag = pNextFrag;
                pFirstFrag = pFrag;
            }
            // Move on to next one
            pFrag = pNextFrag;
            pTagStart = NULL;
            pTagEnd   = NULL;
            pNextFrag = NULL;
            WSkipWhiteSpace(p);
        }
    }

    // If NO tags were found, don't need to create any fragments.
    if ( pFirstFrag && SUCCEEDED (hr) )
    {
        // When done finding tags, check for more text and make a fragment out of it.
        if ( p < pStart + wcslen(pStart) )
        {
            pNextFrag = new SPVTEXTFRAG;
            if ( !pNextFrag )
            {
                hr = E_OUTOFMEMORY;
            }
            if ( SUCCEEDED(hr) )
            {
                memset( pNextFrag, 0, sizeof(SPVTEXTFRAG) );
                memset( &pNextFrag->State, 0, sizeof (SPVSTATE) );
                pNextFrag->pTextStart = p;
                pNextFrag->ulTextLen = pStart + wcslen(pStart) - p;
                pNextFrag->State.eAction = SPVA_Speak;
                pFrag->pNext = pNextFrag;
                (*unSubQueries)++;
            }
        }

        hr = BuildQueryList( dwSpeakFlags, pFirstFrag, LOCAL_FRAG );
    }

    pFrag = pFirstFrag;
    while ( pFrag )
    {
        pNextFrag = pFrag->pNext;
        delete pFrag;
        pFrag = pNextFrag;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::CompressQueryList
//
// Adjacent Db Search items are combined (before search).
//
// Note that there may be intervening XML between search items.  
// If intervening XML is unknown:
//   - ignore it and go to the next search item,
//   - but save it in case the search fails (so it can be restored and 
//     passed on to TTS).
// If intervening XML is KNOWN, stop combining, so XML can be processed
// during the search. 
//
//////////////////////////////////////////////////////////// JOEM  06-2000 //
STDMETHODIMP CPromptEng::CompressQueryList()
{
    SPDBG_FUNC( "CPromptEng::CompressQueryList" );
    HRESULT hr              = S_OK;
    CQuery* pCurrentQuery   = NULL;
    CQuery* pPreviousQuery  = NULL;
    USHORT  unPrevSize      = 0;
    USHORT  unCurrSize      = 0;
    USHORT  i               = 0;
    int     j               = 0;

    for ( i = 0; SUCCEEDED(hr) && i < m_apQueries.GetSize(); i++ )
    {
        pPreviousQuery = pCurrentQuery;

        while ( SUCCEEDED(hr) && i < m_apQueries.GetSize() )
        {
            if ( SUCCEEDED(hr) )
            {
                pCurrentQuery = m_apQueries[i];

                SPDBG_ASSERT(pCurrentQuery);
                
                // Don't combine if either query:
                //  - is not marked "Speak" or
                //  - is marked TTS or
                //  - is an ID or
                //  - is just an SPVSTATE (no m_pszExpandedText) or
                //  - is known XML or
                //  - is silence
                //  - has tags or
                //  - is a local frag or 
                //  - (special case) there is a volume change
                //  - (special case) there is a rate change
                if (!pPreviousQuery                             || 
                    !pPreviousQuery->m_fSpeak                   || 
                    pPreviousQuery->m_fTTS                      ||
                    pPreviousQuery->m_pszId                     ||
                    !pPreviousQuery->m_pszExpandedText          ||
                    pPreviousQuery->m_fXML == KNOWN_XML         ||
                    pPreviousQuery->m_fXML == SILENCE           ||
                    pPreviousQuery->m_paTagList                 ||
                    pPreviousQuery->m_fFragType == LOCAL_FRAG   ||

                    !pCurrentQuery->m_fSpeak                    ||
                    pCurrentQuery->m_fTTS                       || 
                    pCurrentQuery->m_pszId                      ||
                    !pCurrentQuery->m_pszExpandedText           ||
                    pCurrentQuery->m_fXML == KNOWN_XML          ||
                    pCurrentQuery->m_fXML == SILENCE            ||
                    pCurrentQuery->m_paTagList                  ||
                    pCurrentQuery->m_fFragType == LOCAL_FRAG    ||
                    pPreviousQuery->m_pTextFrag->State.Volume != pCurrentQuery->m_pTextFrag->State.Volume  ||
                    pPreviousQuery->m_pTextFrag->State.RateAdj != pCurrentQuery->m_pTextFrag->State.RateAdj  ||
                    // And, don't combine it with any previous unknown XML.
                    ( pPreviousQuery->m_fFragType != COMBINED_FRAG && pPreviousQuery->m_fXML == UNKNOWN_XML )
                    )
                {
                    // Don't combine this item?  Then restore all immediately preceding unknown XML tags.
                    for ( j=i-1; j>=0; j-- )
                    {
                        if ( m_apQueries[j]->m_fXML == UNKNOWN_XML )
                        {
                            m_apQueries[j]->m_fFragType = SAPI_FRAG;
                            m_apQueries[j]->m_fSpeak = true;
                        }
                        else
                        {
                            break;
                        }
                    }
                    break;
                }

                // Combine search items.

                pPreviousQuery->m_fFragType = COMBINED_FRAG;
                // adjust the length - this is complicated because unknown tags in text aren't processed here
                ULONG OffsetFromFirstPrompt = pCurrentQuery->m_ulTextOffset - pPreviousQuery->m_ulTextOffset;
                pPreviousQuery->m_ulTextLen = OffsetFromFirstPrompt + pCurrentQuery->m_ulTextLen;

                // Unknown XML? don't really combine - just mark it out and skip to next one 
                if ( pCurrentQuery->m_fXML == UNKNOWN_XML )
                {
                    pCurrentQuery->m_fFragType = COMBINED_FRAG;
                    pCurrentQuery->m_fSpeak = false;
                    i++;
                    continue;
                }

                // Append current text to previous
                unPrevSize = sizeof(pPreviousQuery->m_pszExpandedText) * wcslen(pPreviousQuery->m_pszExpandedText);
                unCurrSize = sizeof(pCurrentQuery->m_pszExpandedText) * wcslen(pCurrentQuery->m_pszExpandedText);
                pPreviousQuery->m_pszExpandedText = (WCHAR*) realloc( pPreviousQuery->m_pszExpandedText,
                    unPrevSize + unCurrSize + sizeof(WCHAR) );
                if ( !pPreviousQuery->m_pszExpandedText )
                {
                    hr = E_OUTOFMEMORY;
                }
                
                if ( SUCCEEDED(hr) )
                {
                    wcscat(pPreviousQuery->m_pszExpandedText, L" ");
                    wcscat(pPreviousQuery->m_pszExpandedText, pCurrentQuery->m_pszExpandedText);
                }
                
                if ( SUCCEEDED(hr) )
                {
                    pCurrentQuery->m_fFragType = COMBINED_FRAG;
                    pCurrentQuery->m_fSpeak = false;
                    i++;
                } 
            } // if ( SUCCEEDED(hr) )
        } // while
    } // for

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::CompressTTSItems
//
// Adjacent TTS items are combined (after search).
//
//////////////////////////////////////////////////////////// JOEM  06-2000 //
STDMETHODIMP CPromptEng::CompressTTSItems(REFGUID rguidFormatId)
{
    SPDBG_FUNC( "CPromptEng::CompressTTSItems" );
    HRESULT         hr              = S_OK;
    CQuery*         pCurrentQuery   = NULL;
    CQuery*         pPreviousQuery  = NULL;
    SPVTEXTFRAG*    pFrag           = NULL;
    USHORT          i               = 0;

    for ( i = 0; SUCCEEDED(hr) && i < m_apQueries.GetSize(); i++ )
    {
        while ( SUCCEEDED(hr) && i < m_apQueries.GetSize() )
        {
            pCurrentQuery = m_apQueries[i];
            
            SPDBG_ASSERT(pCurrentQuery);

            // If this is a TTS item, make sure there is a TTS engine
            if ( pCurrentQuery->m_fTTS && !m_cpTTSEngine )
            {
                // otherwise, if it's just unknown xml, ignore it
                if ( pCurrentQuery->m_fXML == UNKNOWN_XML )
                {
                    pCurrentQuery->m_fSpeak = false;
                }
                else
                {
                    hr = PEERR_NO_TTS_VOICE;
                }
            }

            if ( SUCCEEDED(hr) )
            {                
                // Don't combine if either query:
                //  - if the output format is text
                //  - is marked "don't speak"
                //  - is not TTS
                if ( rguidFormatId == SPDFID_Text   ||
                    !pPreviousQuery                 || 
                    !pPreviousQuery->m_fSpeak       || 
                    !pPreviousQuery->m_fTTS         ||
                    
                    !pCurrentQuery->m_fSpeak        ||
                    !pCurrentQuery->m_fTTS          
                    )
                {
                    if ( pCurrentQuery->m_fSpeak )
                    {
                        pPreviousQuery = pCurrentQuery;
                    }
                    break;
                }
                
                pFrag = pPreviousQuery->m_pTextFrag;
                while ( pFrag->pNext )
                {
                    pFrag = pFrag->pNext;
                }
                pFrag->pNext = pCurrentQuery->m_pTextFrag;
                m_apQueries[i]->m_fSpeak = false;
                i++;
            }
        } // while
    } // for

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;

}

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::DispatchQueryList
//
// Goes through the query list, sending TTS or prompts as appropriate.
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //
STDMETHODIMP CPromptEng::DispatchQueryList(const DWORD dwSpeakFlags, REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx)
{
    SPDBG_FUNC( "CPromptEng::DispatchQueryList" );
    HRESULT hr              = S_OK;
    USHORT  i               = 0;
    SHORT   j               = 0;
    CQuery* pQuery          = NULL;
    CPromptEntry* entry     = NULL;

    if ( rguidFormatId == SPDFID_Text )
    {
        hr = SendTextOutput( dwSpeakFlags, rguidFormatId );
    }
    else
    {
        for ( i=0; SUCCEEDED(hr) && i < m_apQueries.GetSize(); i++ )
        {
            // Stop speaking?
            if ( m_pOutputSite->GetActions() & SPVES_ABORT )
            {
                m_fAbort = true;
                break;
            }
            
            pQuery = m_apQueries[i];
            
            if ( !pQuery->m_fSpeak )
            {
                continue;
            }
            
            if ( pQuery->m_fTTS )
            {
                // Should not get to this point without a TTS Engine!
                SPDBG_ASSERT(m_cpTTSEngine);
                
                // TTS items get passed directly to TTS Engine
                if ( SUCCEEDED(hr) )
                {
                    hr = m_cpTTSEngine->Speak(dwSpeakFlags, rguidFormatId, NULL, pQuery->m_pTextFrag, m_pOutputSite);
                    if ( SUCCEEDED(hr) )
                    {
                        m_pOutputSite->UpdateBytesWritten();
                    }
                }
            }
            else
            {
                if ( SUCCEEDED(hr) && ( pQuery->m_fFragType != LOCAL_FRAG ) )
                {
                    m_cpPromptDb->SetXMLVolume(pQuery->m_pTextFrag->State.Volume);
                    m_cpPromptDb->SetXMLRate(pQuery->m_pTextFrag->State.RateAdj);
                }
                
                if ( pQuery->m_fXML == SILENCE )
                {
                    hr = SendSilence(pQuery->m_pTextFrag->State.SilenceMSecs, pWaveFormatEx->nAvgBytesPerSec);
                }
                else
                {
                    // The search process backtracks the list, so these are in reverse order.
                    // So, play in last-to-first order.
                    for ( j=pQuery->m_apEntry.GetSize()-1; j>=0; j-- )
                    {
                        entry = pQuery->m_apEntry[j];
                        if ( !entry )
                        {
                            hr = E_FAIL;
                        }
                        
                        if ( SUCCEEDED(hr) )
                        {
                            hr = m_cpPromptDb->SendEntrySamples(entry, m_pOutputSite, pQuery->m_ulTextOffset, pQuery->m_ulTextLen);
                        }
                    } // for ( j=pQuery->m_apEntry.GetSize()-1 ...
                }
            }
        }
    }
        
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;    
}
/////////////////////////////////////////////////////////////////////////////
// CPromptEng::SendSilence
//
// Generates silence and writes to output site.
//
//////////////////////////////////////////////////////////// JOEM  11-2000 //
STDMETHODIMP CPromptEng::SendSilence(const int iMsec, const DWORD iAvgBytesPerSec)
{
    SPDBG_FUNC( "CPromptEng::SendSilence" );
    HRESULT hr = S_OK;

    BYTE*   pbSilence   = NULL;
    int     iBytes      = iMsec/1000 * iAvgBytesPerSec;

    if ( iBytes )
    {
        pbSilence = new BYTE[iBytes];
        if ( !pbSilence )
        {
            hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED(hr) )
        {
            memset( (void*) pbSilence, 0, iBytes * sizeof(BYTE) );
            hr = m_pOutputSite->Write(pbSilence, iBytes, 0);

            if ( SUCCEEDED(hr) )
            {
                m_pOutputSite->UpdateBytesWritten();
            }
            delete [] pbSilence;
            pbSilence = NULL;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::SendTextOutput
//
// Output function for SPDFID_Text format.  Goes through the query list, 
// sending text from TTS or prompts as appropriate.
//
// This functionality is needed mainly for the test team.
//
//////////////////////////////////////////////////////////// JOEM  11-2000 //
STDMETHODIMP CPromptEng::SendTextOutput(const DWORD dwSpeakFlags, REFGUID rguidFormatId)
{
    SPDBG_FUNC( "CPromptEng::SendTextOutput" );
    HRESULT hr              = S_OK;
    USHORT  i               = 0;
    SHORT   j               = 0;
    CQuery* pQuery          = NULL;
    
    static const WCHAR Signature = 0xFEFF; // write the Unicode signature
    hr = m_pOutputSite->Write( &Signature, sizeof(Signature), NULL );

    for ( i=0; SUCCEEDED(hr) && i < m_apQueries.GetSize(); i++ )
    {
        // Stop speaking?
        if ( m_pOutputSite->GetActions() & SPVES_ABORT )
        {
            m_fAbort = true;
            break;
        }
        
        pQuery = m_apQueries[i];
        
        if ( !pQuery->m_fSpeak )
        {
            continue;
        }
        
        if ( pQuery->m_fTTS )
        {
            // Should not get to this point without a TTS Engine!
            SPDBG_ASSERT(m_cpTTSEngine);
            
            WCHAR szText[7] = L"0:"; // 7 chars for "0:TTS:" (6 plus \0)
            if ( pQuery->m_afEntryMatch.GetSize() && pQuery->m_afEntryMatch[0] )
            {
                wcscpy(szText, L"1:");
            }
            wcscat(szText, L"TTS:");
            hr = m_pOutputSite->Write( szText, (wcslen(szText) + 1) * sizeof(WCHAR), NULL );
            
            // TTS items get passed directly to TTS Engine
            if ( SUCCEEDED(hr) )
            {
                hr = m_cpTTSEngine->Speak(dwSpeakFlags, rguidFormatId, NULL, pQuery->m_pTextFrag, m_pOutputSite);
                if ( SUCCEEDED(hr) )
                {
                    m_pOutputSite->UpdateBytesWritten();
                }
            }
        }
        else
        {
            CPromptEntry* entry = NULL;

            if ( SUCCEEDED(hr) && ( pQuery->m_fFragType != LOCAL_FRAG ) )
            {
                hr = m_cpPromptDb->SetXMLVolume(pQuery->m_pTextFrag->State.Volume);
            }
            
            // The search process backtracks the list, so these are in reverse order.
            // So, play in last-to-first order.
            for ( j=pQuery->m_apEntry.GetSize()-1; j>=0; j-- )
            {
                entry = pQuery->m_apEntry[j];
                if ( !entry )
                {
                    hr = E_FAIL;
                }
                
                if ( SUCCEEDED(hr) )
                {
                    // For text output (TEST HOOKS)
                    WCHAR* pszOutput        = NULL;
                    WCHAR* pszTagOutput     = NULL;
                    WCHAR  szMatch          = L'0';
                    const  WCHAR* pszId     = NULL;
                    const  WCHAR* pszText   = NULL;
                    const  WCHAR* pszTag    = NULL;
                    int     iLen    = 0;
                    USHORT  k       = 0;
                    USHORT  unTags  = 0;
                        
                    // get the tag match indicator
                    SPDBG_ASSERT(j < pQuery->m_afEntryMatch.GetSize());
                    if ( pQuery->m_afEntryMatch[j] )
                    {
                        szMatch = L'1';
                    }
                    
                    // get the ID#, text, and tags -- and write them in the output
                    if ( SUCCEEDED(hr) )
                    {
                        // Get the ID
                        if ( SUCCEEDED(hr) )
                        {
                            hr = entry->GetId(&pszId);
                        }
                        // Get the Text
                        if ( SUCCEEDED(hr) )
                        {
                            hr = entry->GetText(&pszText);
                        }
                        // Assemble the collection of Tags
                        hr = entry->CountTags(&unTags);
                        if ( SUCCEEDED(hr) )
                        {
                            for ( k=0; SUCCEEDED(hr) && k<unTags; k++ )
                            {
                                hr = entry->GetTag(&pszTag, k);
                                if ( SUCCEEDED(hr) )
                                {
                                    iLen += wcslen(pszTag);
                                    iLen++; // +1 for the comma or \0
                                }
                            }
                            
                            if ( iLen )
                            {
                                pszTagOutput = new WCHAR[iLen];
                            }
                            else
                            {
                                pszTagOutput = new WCHAR[2];
                            }
                            
                            if ( !pszTagOutput )
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            else
                            {
                                if ( !iLen )
                                {
                                    wcscpy( pszTagOutput, L" " );
                                }
                            }
                            
                            for ( k=0; SUCCEEDED(hr) && k<unTags; k++ )
                            {
                                hr = entry->GetTag(&pszTag, k);
                                if ( SUCCEEDED(hr) )
                                {
                                    if ( k==0 )
                                    {
                                        wcscpy(pszTagOutput, pszTag);
                                    }
                                    else
                                    {
                                        wcscat(pszTagOutput, L",");
                                        wcscat(pszTagOutput, pszTag);
                                    }
                                }
                            }
                            
                        }
                        
                        // Put it all together
                        if ( SUCCEEDED(hr) )
                        {
                            if ( pszText && pszId )
                            {
                                iLen = wcslen(pszId) + wcslen(pszTagOutput) + wcslen(pszText) + wcslen(L"0:ID()():\r\n");
                                pszOutput = new WCHAR[iLen+1];
                                if ( !pszOutput )
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                                if ( SUCCEEDED(hr) )
                                {
                                    // signal to the app that the upcoming output is from prompts, not TTS.
                                    swprintf (pszOutput, L"%c:ID(%s)(%s):%s\r\n", szMatch, pszId, pszTagOutput, pszText);
                                    hr = m_pOutputSite->Write(pszOutput, (wcslen(pszOutput) + 1) * sizeof(WCHAR), NULL);
                                }
                            }
                            else // no text/id, must be an XML-specified wav file
                            {   
                                const  WCHAR* pszPath = NULL;
                                hr = entry->GetFileName(&pszPath);

                                if ( SUCCEEDED(hr) )
                                {
                                    // make sure that the file is actually wav data
                                    VapiIO* pVapiIO = VapiIO::ClassFactory();
                                    if ( !pVapiIO )
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }

                                    if ( SUCCEEDED(hr) )
                                    {
                                        if ( pVapiIO->OpenFile(pszPath, VAPI_IO_READ) != 0 )
                                        {
                                            hr = E_ACCESSDENIED;
                                        }
                                        delete pVapiIO;
                                        pVapiIO = NULL;
                                    }
                                }

                                if ( SUCCEEDED(hr) )
                                {
                                    iLen = wcslen(L"1:WAV()\r\n") + wcslen(pszPath) + 1;
                                    pszOutput = new WCHAR[iLen];
                                    swprintf (pszOutput, L"1:WAV(%s)\r\n", pszPath);
                                    hr = m_pOutputSite->Write(pszOutput, (wcslen(pszOutput) + 1) * sizeof(WCHAR), NULL);
                                }
                            }
                        }
                        if ( pszOutput )
                        {
                            delete [] pszOutput;
                            pszOutput = NULL;
                        }
                        if ( pszTagOutput )
                        {
                            delete [] pszTagOutput;
                            pszTagOutput = NULL;
                        }
                    }
                }
            } // for ( j=pQuery->m_apEntry.GetSize()-1 ...
        }
    }
    
    // TEST HOOK:  OUTPUT THE PATH COST
    if ( SUCCEEDED(hr) && !m_fAbort )
    {
        const iStrLen = 20;  // arbitrary -- plenty of space for 6 dig precision, plus sign, exponent, etc if necessary
        char  szCost[iStrLen];   
        WCHAR wszCost[iStrLen];  
        WCHAR* pszOutput = NULL;
        
        pszOutput = new WCHAR[iStrLen + wcslen(L"Cost: \r\n")];
        if ( !pszOutput )
        {
            hr = E_OUTOFMEMORY;
        }
        if ( SUCCEEDED(hr) )
        {
            _gcvt( m_dQueryCost, 6, szCost ); // convert to string
            if ( !MultiByteToWideChar( CP_ACP, 0, szCost, -1, wszCost, iStrLen ) )
            {
                hr = E_FAIL;
            }
            
            if ( SUCCEEDED(hr) )
            {
                swprintf (pszOutput, L"Cost: %.6s\r\n", wszCost );
                hr = m_pOutputSite->Write(pszOutput, (wcslen(pszOutput) + 1) * sizeof(WCHAR), NULL);
            }
        }
        if ( pszOutput )
        {
            delete [] pszOutput;
            pszOutput = NULL;
        }
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
// CPromptEng::DebugQueryList
//
// Just outputs the contents of each CQuery in the query list.
//
//////////////////////////////////////////////////////////// JOEM  04-2000 //
void CPromptEng::DebugQueryList()
{
    SPDBG_FUNC( "CPromptEng::DebugQueryList" );
    USHORT i = 0;
    USHORT j = 0;
    USHORT k = 0;
    CQuery* query = NULL;
    CPromptEntry* entry = NULL;
    double dEntryInfo = 0.0;
    const WCHAR* szEntryInfo = NULL;
    USHORT count = 0;
    const USHORT MAX_FRAG = 1024;
    WCHAR DebugStr[MAX_FRAG+1];

    if ( !m_apQueries.GetSize() )
    {
        OutputDebugStringW(L"\nNO QUERY LIST!\n\n");
        return;
    }


    for (i=0; i<m_apQueries.GetSize(); i++)
    {
        query = m_apQueries[i];
        swprintf (DebugStr, L"Query %d:\n", i+1);
        OutputDebugStringW(DebugStr);

        if ( !query )
        {
            OutputDebugStringW(L"NULL QUERY!\n");
            continue;
        }

        if ( query->m_fSpeak )
        {
            OutputDebugStringW(L"\tSpeak Flag = true\n");
        }
        else
        {
            OutputDebugStringW(L"\tSpeak Flag = false\n");
        }
        if ( query->m_fTTS )
        {
            OutputDebugStringW(L"\tTTS Flag = true\n");
        }
        else
        {
            OutputDebugStringW(L"\tTTS Flag = false\n");
        }
        if ( query->m_fXML == KNOWN_XML )
        {
            OutputDebugStringW(L"\tKNOWN XML\n");
        }
        else if ( query->m_fXML == UNKNOWN_XML )
        {
            OutputDebugStringW(L"\tUNKNOWN XML\n");
        }
        if ( query->m_fFragType == LOCAL_FRAG )
        {
            OutputDebugStringW(L"\tLOCAL FRAG\n");
        }
        if ( query->m_fFragType == COMBINED_FRAG )
        {
            OutputDebugStringW(L"\tCOMBINED FRAG\n");
        }

        OutputDebugStringW(L"\tText Frag: ");
        if ( query->m_pTextFrag && query->m_pTextFrag->pTextStart )
        {
            wcsncpy(DebugStr, query->m_pTextFrag->pTextStart, 1024);
            DebugStr[1024] = L'\0';
            OutputDebugStringW(DebugStr);
            OutputDebugStringW(L"\n");
        }

        OutputDebugStringW(L"\tExpanded Text: ");
        if ( query->m_pszExpandedText )
        {
            OutputDebugStringW(query->m_pszExpandedText);
            OutputDebugStringW(L"\n");
        }

        swprintf (DebugStr, L"\tDbAction: %d\n", query->m_unDbAction);
        OutputDebugStringW(DebugStr);
        swprintf (DebugStr, L"\tDbIndex: %d\n", query->m_unDbIndex);
        OutputDebugStringW(DebugStr);
        if ( query->m_pszDbName )
        {
            OutputDebugStringW(L"\tDbName: ");
            OutputDebugStringW(query->m_pszDbName);
            OutputDebugStringW(L"\n");
        }
        if ( query->m_pszDbPath )
        {
            OutputDebugStringW(L"\tDbPath: ");
            OutputDebugStringW(query->m_pszDbPath);
            OutputDebugStringW(L"\n");
        }

        OutputDebugStringW(L"\tID: ");
        if ( query->m_pszId )
        {
            swprintf (DebugStr, L"%s\n", query->m_pszId);
            OutputDebugStringW(DebugStr);
        }
        else
        {
            OutputDebugStringW(L"(none)\n");
        }
        
        if ( query->m_paTagList )
        {
            OutputDebugStringW(L"\tWITHTAG List:\n");
            for (j=0; j<query->m_paTagList->GetSize(); j++)
            {
                swprintf (DebugStr, L"\t\t%s\n", (*query->m_paTagList)[j]);
                OutputDebugStringW(DebugStr);
            }
        }

        swprintf (DebugStr, L"\tText Offset: %d\n", query->m_ulTextOffset);
        OutputDebugStringW(DebugStr);
        swprintf (DebugStr, L"\tText Length: %d\n", query->m_ulTextLen);
        OutputDebugStringW(DebugStr);

        if ( query->m_apEntry.GetSize() )
        {
            for (j=0; j<query->m_apEntry.GetSize(); j++)
            {
                entry = query->m_apEntry[j];
                if ( entry )
                {
                    swprintf (DebugStr, L"\tDbEntry %d:\n", j+1);
                    OutputDebugStringW(DebugStr);
                    
                    entry->GetStart(&dEntryInfo);
                    swprintf (DebugStr, L"\t\tFrom: %f\n", dEntryInfo);
                    OutputDebugStringW(DebugStr);
                    
                    entry->GetEnd(&dEntryInfo);
                    swprintf (DebugStr, L"\t\tTo: %f\n", dEntryInfo);
                    OutputDebugStringW(DebugStr);
                    
                    entry->GetFileName(&szEntryInfo);
                    OutputDebugStringW(L"\t\tFileName: ");
                    OutputDebugStringW(szEntryInfo);
                    OutputDebugStringW(L"\n");
                    szEntryInfo = NULL;
                    
                    entry->GetText(&szEntryInfo);
                    OutputDebugStringW(L"\t\tText: ");
                    OutputDebugStringW(szEntryInfo);
                    OutputDebugStringW(L"\n");
                    szEntryInfo = NULL;
                    
                    entry->GetId(&szEntryInfo);
                    OutputDebugStringW(L"\t\tID: ");
                    OutputDebugStringW(szEntryInfo);
                    OutputDebugStringW(L"\n");
                    szEntryInfo = NULL;
                    
                    entry->GetStartPhone(&szEntryInfo);
                    if ( szEntryInfo )
                    {
                        OutputDebugStringW(L"\t\tStartPhone: ");
                        OutputDebugStringW(szEntryInfo);
                        OutputDebugStringW(L"\n");
                        szEntryInfo = NULL;
                    }
                    
                    entry->GetEndPhone(&szEntryInfo);
                    if ( szEntryInfo )
                    {
                        OutputDebugStringW(L"\t\tEndPhone: ");
                        OutputDebugStringW(szEntryInfo);
                        OutputDebugStringW(L"\n");
                        szEntryInfo = NULL;
                    }
                    
                    entry->GetLeftContext(&szEntryInfo);
                    if ( szEntryInfo )
                    {
                        OutputDebugStringW(L"\t\tLeftContext: ");
                        OutputDebugStringW(szEntryInfo);
                        OutputDebugStringW(L"\n");
                        szEntryInfo = NULL;
                    }
                    
                    entry->GetRightContext(&szEntryInfo);
                    if ( szEntryInfo )
                    {
                        OutputDebugStringW(L"\t\tRightContext: ");
                        OutputDebugStringW(szEntryInfo);
                        OutputDebugStringW(L"\n");
                        szEntryInfo = NULL;
                    }
                    
                    OutputDebugStringW(L"\t\tEntry Tags:\n");
                    entry->CountTags(&count);
                    for (k=0; k<count; k++)
                    {
                        entry->GetTag(&szEntryInfo, k);
                        swprintf (DebugStr, L"\t\t\t%s\n", szEntryInfo);
                        OutputDebugStringW(DebugStr);
                        szEntryInfo = NULL;
                    }

                    if ( query->m_afEntryMatch[j] )
                    {
                        OutputDebugStringW(L"\t\tMatch?: true\n");
                    }
                    else
                    {
                        OutputDebugStringW(L"\t\tMatch: false\n");
                    }

                } // if ( entry )
                else
                {
                    OutputDebugStringW(L"NULL ENTRY.\n");
                }
            } // for
        } // if
        else
        {
            OutputDebugStringW(L"\tDbEntries: none\n");
            if ( query->m_afEntryMatch.GetSize() )
            {
                if ( query->m_afEntryMatch[0] )
                {
                    OutputDebugStringW(L"\tMatch: true\n");
                }
                else
                {
                    OutputDebugStringW(L"\tMatch: false\n");
                }
            }
            else
            {
                    OutputDebugStringW(L"\tMatch: unknown\n");
            }
        }
        OutputDebugStringW(L"END OF QUERY.\n\n");
    }

    swprintf ( DebugStr, L"END OF QUERY LIST. (Total Queries: %d)\n\n", m_apQueries.GetSize() );
    OutputDebugStringW(DebugStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\promptdb.h ===
//////////////////////////////////////////////////////////////////////
// PromptDb.h : Declaration of the CPromptDb
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#ifndef __PROMPTDB_H_
#define __PROMPTDB_H_

#include "resource.h"       // main symbols
#include "common.h"
#include "PEErr.h"
#include "PromptEntry.h"
#include "Hash.h"
#include "fmtconvert.h"
#include "tsm.h"
#include <spddkhlp.h>
#include <spcollec.h>

// forward references
class VapiIO;
extern const IID IID_IPromptDb;

// DB ACTIONS
enum { DB_ADD = 1, DB_ACTIVATE, DB_UNLOAD };

// DB_LOAD OPTIONS
#define DB_LOAD        0
#define DB_CREATE      1


class CDb 
{
public:
    CDb();
    ~CDb();
    WCHAR*  pszPathName;
    WCHAR*  pszTempName;
    WCHAR*  pszLogicalName;
    CHash   idHash;
    CHash   textHash;
};


/////////////////////////////////////////////////////////////////////////////
// CPromptDb
class ATL_NO_VTABLE CPromptDb : 
    public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPromptDb, &CLSID_PromptDb>,
	public IPromptDb
{
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_PROMPTDB)
        
    DECLARE_PROTECT_FINAL_CONSTRUCT()
      
    BEGIN_COM_MAP(CPromptDb)
    COM_INTERFACE_ENTRY(IPromptDb)
    END_COM_MAP()
        
    // Constructor/Destructor
    HRESULT FinalConstruct();
    void FinalRelease();

public:
    // IPromptDb
	STDMETHOD(NewDb)(const WCHAR *logicalName, const WCHAR *pathName);
	STDMETHOD(AddDb)(const WCHAR *logicalName, const WCHAR *pathName, const WCHAR *pszIdSet, const USHORT loadOption);
	STDMETHOD(UnloadDb)(const WCHAR* pszLogicalName);
	STDMETHOD(ActivateDbName)(const WCHAR *pszLogicalName);
	STDMETHOD(ActivateDbNumber)(const USHORT unIndex);
	STDMETHOD(UpdateDb)(WCHAR* pszPath);
	STDMETHOD(CountDb)(USHORT *unCount);
	STDMETHOD(SearchDb)(const WCHAR* pszQuery, USHORT* unIdCount);
	STDMETHOD(RetrieveSearchItem)(const USHORT unId, const WCHAR** ppszId);
	STDMETHOD(GetLogicalName)(const WCHAR** ppszLogicalName);
	STDMETHOD(GetNextEntry)(USHORT* punId1, USHORT* punId2, IPromptEntry** ppIPE);
	STDMETHOD(FindEntry)(const WCHAR* id, IPromptEntry** ppIPE);
	STDMETHOD(NewEntry)(IPromptEntry** ppIPE);
	STDMETHOD(SaveEntry)(IPromptEntry* pIPE);
	STDMETHOD(RemoveEntry)(const WCHAR* id);
	STDMETHOD(OpenEntryFile)(IPromptEntry* pIPE, WAVEFORMATEX* pWaveFormatEx);
	STDMETHOD(CloseEntryFile)();
    STDMETHOD(GetPromptFormat)(WAVEFORMATEX** ppwf);
	STDMETHOD(SetOutputFormat)(const GUID * pOutputFormatId, const WAVEFORMATEX *pOutputFormat);
	STDMETHOD(SetEntryGain)(const double dEntryGain);
	STDMETHOD(SetXMLVolume)(const ULONG ulXMLVol);
	STDMETHOD(SetXMLRate)(const long lXMLRate);
	STDMETHOD(SendEntrySamples)(IPromptEntry* pIPE, ISpTTSEngineSite* pOutputSite, ULONG ulTextOffset, ULONG ulTextLen);

private:
	STDMETHOD(SendEvent)(const SPEVENTENUM event, ISpTTSEngineSite* pOutputSite, const ULONG ulAudioOffset, const ULONG ulTextOffset, const ULONG ulTextLen);
    void ComputeRateAdj(const long lRate, float* flRate);
    STDMETHOD(ApplyGain)(const void* pvInBuff, void** ppvOutBuff, const int iNumSamples, double dGain);
	STDMETHOD(LoadDb)(const WCHAR* pszIdSet);
	STDMETHOD(LoadIdHash)(FILE* fp, const WCHAR* pszIdSet);
	STDMETHOD(IndexTextHash)();
	STDMETHOD(ExtractDouble)(WCHAR* line, const WCHAR* tag, double* value);
	STDMETHOD(ExtractString)(WCHAR* line, const WCHAR* tag, WCHAR** value);
	STDMETHOD(ReadEntry)(FILE* fp, CPromptEntry** ppEntry);
	STDMETHOD(WriteEntry)(FILE* fp, IPromptEntry* pIPE);
	STDMETHOD(TempName)();
	CPromptEntry* DuplicateEntry(const CPromptEntry* oldEntry);

private:
    CSPArray<CDb*,CDb*>         m_apDbList;
    CSPArray<CDynStr,CDynStr>   m_aSearchList;

    CDb*            m_pActiveDb;
    USHORT          m_unIndex;
    volatile LONG   m_vcRef;
    float           m_flEntryGain;
    float           m_flXMLVolume;
    float           m_flXMLRateAdj;
    const GUID*     m_pOutputFormatId;
    WAVEFORMATEX*   m_pOutputFormat;
    CFmtConvert     m_converter;
    CTsm*           m_pTsm;
    VapiIO*         m_pVapiIO;
};

#endif //__PROMPTDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\phonecontext.h ===
//////////////////////////////////////////////////////////////////////
// PhoneContext.h: interface for the CPhoneContext class.
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#if !defined(AFX_PHONECONTEXT_H__9E560692_45A6_4472_B0F9_31AD3F6157B8__INCLUDED_)
#define AFX_PHONECONTEXT_H__9E560692_45A6_4472_B0F9_31AD3F6157B8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "common.h"
#include "MSPromptEng.h"

enum PHONE_CONTEXT_TAG_ID
{
    START_TAG,
    END_TAG,
    RIGHT_TAG,
    LEFT_TAG
};

struct CONTEXT_PHONE_TAG
{
    PHONE_CONTEXT_TAG_ID iPhoneTag;
    WCHAR* pszPhoneTag;
};

static const CONTEXT_PHONE_TAG g_Phone_Tags[] = 
{
    { START_TAG,    L"START_PHONE" },
    { END_TAG,      L"END_PHONE" },
    { RIGHT_TAG,    L"RIGHT_CONTEXT" },
    { LEFT_TAG,     L"LEFT_CONTEXT" }
};

struct Macro 
{
  WCHAR  name[32];
  double value;
};


struct CPhoneClass 
{
    WCHAR*    m_pszPhoneClassName;
    WCHAR**   m_pppszPhones;
    USHORT    m_unNPhones;
    double    m_dWeight;
};

struct CContextRule 
{
    WCHAR*         m_pszRuleName;
    USHORT         m_unNPhoneClasses;
    CPhoneClass**  m_pvPhoneClasses;
};

//--- START OF DEFAULT PHONE CONTEXT RULES -----------------------------
// The following are used for default US English context rules.
#define MAX_RULES 15

static WCHAR* g_macros[] =
{
    L"%NoMatchWeight   5.0",
    L"%BadMatchWeight  3.0",
    L"%GoodMatchWeight 1.0",
    L"%MatchWeight     0.0"
};

static const USHORT g_nMacros = sizeof(g_macros)/sizeof(g_macros[0]);

enum RULE_CODES
{
    main,
    phone,
    consonant,
    velar,
    alveolar,
    palatal,
    deltal,
    labial,
    labiodental
};

struct RULE
{
    RULE_CODES code;
    WCHAR* name;
    WCHAR* rule[MAX_RULES];
};

static const RULE g_rules[] =
{
    // main rule - these four classes are mandatory
    {   
        main,
        L"main",
        {   
            L"none    {} %NoMatchWeight",
            L"all     {} %MatchWeight",
            L"silence { sp sil }  %MatchWeight",
            L"phone   { uw uh oy ow iy ih ey eh ay ax aw ao ah ae aa zh \
                      z y w v th t sh s r er p ng n m l k jh g \
                      f dh d ch b h }  %BadMatchWeight" 
        }
    },

    // phone rule
    {   
        phone,
        L"phone",
        {   
            L"vowel   { uw uh oy ow iy ih ey eh ay ax aw ao ah ae aa } %GoodMatchWeight",
            L"consonant { zh z y w v th t sh s r er p ng n m l k jh g f dh d ch b h }  %BadMatchWeight"
        }
    },

    // consonant rule
    {   
        consonant,
        L"consonant",
        {
            L"nasal { m ng n } %GoodMatchWeight",
            L"lateral { l } %GoodMatchWeight",
            L"retroflex { er r } %GoodMatchWeight",
            L"velar { k g } %BadMatchWeight",
            L"alveolar { z s t d } %BadMatchWeight",
            L"palatal { zh sh ch jh } %BadMatchWeight",
            L"dental { dh th } %BadMatchWeight",
            L"labial { b p } %BadMatchWeight",
            L"labiodental { v f } %BadMatchWeight",
            L"glide { w y } %GoodMatchWeight"
            L"glottal { h } %GoodMatchWeight"
        }
    },

    // velar rule
    {   
        velar,
        L"velar",
        {
            L"voiced { g } %GoodMatchWeight",
            L"unvoiced { k } %GoodMatchWeight"
        }
    },

    // alveolar rule
    {
        alveolar,
        L"alveolar",
        {
            L"voiced { z d } %GoodMatchWeight",
            L"unvoiced { s t } %GoodMatchWeight"
        }
    },

    // palatal rule
    {
        palatal,
        L"palatal",
        {
            L"voiced { zh jh } %GoodMatchWeight",
            L"unvoiced { sh ch } %GoodMatchWeight"
        }
    },

    // deltal rule
    {
        deltal,
        L"deltal",
        {
            L"voiced { dh } %GoodMatchWeight",
            L"unvoiced { th } %GoodMatchWeight"
        }
    },

    // labial rule
    {
        labial,
        L"labial",
        {
            L"voiced { b } %GoodMatchWeight",
            L"unvoiced { p } %GoodMatchWeight"
        }
    },

    // labiodental rule
    {
        labiodental,
        L"labiodental",
        {
            L"voiced { v } %GoodMatchWeight",
            L"unvoiced { f } %GoodMatchWeight"
        }
    },
};

static const USHORT g_nRules = sizeof(g_rules) / sizeof(g_rules[0]);

//--- END OF DEFAULT PHONE CONTEXT RULES -------------------------------


class CPhoneContext  
{
public:
	HRESULT LoadDefault();
	CPhoneContext();
	~CPhoneContext();
	STDMETHOD(Load)(const WCHAR* pszPathName);
	STDMETHOD(Apply)(IPromptEntry* pPreviousEntry, IPromptEntry* pCurrentEntry, double* pdCost);
	void DebugContextClass();

private:
	void DeleteContextRule(CContextRule* pRule);
	void DeletePhoneClass(CPhoneClass* pClass);
	STDMETHOD(ApplyRule)(const CContextRule* pRule, const WCHAR* pszPhone, WCHAR** ppszNextRule);
	STDMETHOD(GetWeight)(const CContextRule* pRule, const WCHAR* pszName, double* pdCost);
	STDMETHOD(ApplyPhoneticRule)(const WCHAR* pszPhone, const WCHAR* pszContext, double* pdCost);
	STDMETHOD(SearchPhoneTag)(IPromptEntry* DbEntry, const WCHAR** result, CONTEXT_PHONE_TAG phoneTag);
	STDMETHOD(AddPhoneToClass)(CPhoneClass* phClass, WCHAR *phone);
	STDMETHOD(CreatePhoneClass)(CPhoneClass*** pppClasses, USHORT* punClasses, const WCHAR *psz);
	STDMETHOD(ReadMacro)(const WCHAR* pszText, Macro** ppMacros, USHORT* punMacros);
	STDMETHOD(ParsePhoneClass)(const Macro *pMacros, const USHORT unMacros, CContextRule* pRule, WCHAR **ppszOrig);
	STDMETHOD(CreateRule)(const WCHAR* pszText);
	STDMETHOD(FindContextRule)(const WCHAR* pszName, CContextRule** ppRule);

private:
    ULONG          m_ulNRules;
    CContextRule** m_ppContextRules;

};

#endif // !defined(AFX_PHONECONTEXT_H__9E560692_45A6_4472_B0F9_31AD3F6157B8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\prompteng.h ===
//////////////////////////////////////////////////////////////////////
// PromptEng.h : Declaration of the CPromptEng
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#ifndef __PROMPTENG_H_
#define __PROMPTENG_H_

#include "resource.h"       // main symbols
#include "PromptDb.h"
#include "Query.h"
#include "DbQuery.h"	
#include "LocalTTSEngineSite.h"
#include "PhoneContext.h"
#include "TextRules.h"
#include <spddkhlp.h>
#include <spcollec.h>

/////////////////////////////////////////////////////////////////////////////
// CPromptEng
//
// Voice with associated prerecorded prompt database will use this engine
// to search for a set of prompts that match the desired message.
// This prompt engine class should contain a TTS engine member. 
//
///////////////////////////////////////////////////////// JOEM 02-15-2000 ///
class ATL_NO_VTABLE CPromptEng : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPromptEng, &CLSID_PromptEng>,
	public ISpObjectWithToken,
	public ISpTTSEngine
{


public:

DECLARE_REGISTRY_RESOURCEID(IDR_PROMPTENG)
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CPromptEng)
	COM_INTERFACE_ENTRY(ISpTTSEngine)
	COM_INTERFACE_ENTRY(ISpObjectWithToken)
END_COM_MAP()


public:

    // Constructors/Destructors 
    HRESULT FinalConstruct();
    void FinalRelease();


    // ISpObjectWithToken
	STDMETHOD(SetObjectToken)(ISpObjectToken *pToken);
	STDMETHOD(GetObjectToken)(ISpObjectToken **ppToken)
        { return SpGenericGetObjectToken( ppToken, m_cpToken ); }


    // ISpTTSEngine
	STDMETHOD(Speak)(DWORD dwSpeakFlags, REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx,
                      const SPVTEXTFRAG* pTextFragList, ISpTTSEngineSite* pOutputSite);
	STDMETHOD(GetOutputFormat)( const GUID * pTargetFormatId, const WAVEFORMATEX * pTargetWaveFormatEx,
                                GUID * pDesiredFormatId, WAVEFORMATEX ** ppCoMemDesiredWaveFormatEx );


private:
	STDMETHOD(DispatchQueryList)(const DWORD dwSpeakFlags, REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx);
	STDMETHOD(SendTextOutput)(const DWORD dwSpeakFlags, REFGUID rguidFormatId);
	STDMETHOD(BuildQueryList)(const DWORD dwSpeakFlags, const SPVTEXTFRAG* pCurrentFrag, const FragType fFragType );
	STDMETHOD(ParseSubQuery)(const DWORD dwSpeakFlags, const WCHAR* pszText, USHORT* unSubQueries );
	STDMETHOD(CompressQueryList)();
	STDMETHOD(CompressTTSItems)(REFGUID rguidFormatId);
    STDMETHOD(SendSilence)(const int iMsec, const DWORD iAvgBytesPerSec);
    void DebugQueryList();

private:
    CComPtr<ISpObjectToken>     m_cpToken;
    CComPtr<ISpObjectToken>     m_cpTTSToken;
    CComPtr<IPromptDb>          m_cpPromptDb;
    CComPtr<ISpTTSEngine>       m_cpTTSEngine;
    CPhoneContext               m_phoneContext;
    CTextRules                  m_textRules;
	CDbQuery                    m_DbQuery;
	CLocalTTSEngineSite*        m_pOutputSite;
    CSPArray<CQuery*,CQuery*>   m_apQueries;
    double                      m_dQueryCost;
    bool                        m_fAbort;
};

#endif //__PROMPTENG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\promptentry.h ===
//////////////////////////////////////////////////////////////////////
// PromptEntry.h: interface for the CPromptEntry class.
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#if !defined(AFX_DBENTRY_H__0A787DC1_8000_4D97_883E_E82558597089__INCLUDED_)
#define AFX_DBENTRY_H__0A787DC1_8000_4D97_883E_E82558597089__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Hash.h"
#include "MSPromptEng.h"
#include <spddkhlp.h>
#include <spcollec.h>

extern const IID IID_IPromptEntry;

class CPromptEntry : public IPromptEntry
{
public:
	CPromptEntry();
	CPromptEntry(const CPromptEntry & old);
    ~CPromptEntry();
public:
    // IUnknown
    STDMETHOD(QueryInterface)(const IID& iid, void** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPromptEntry
	STDMETHOD(SetId)(const WCHAR* pszId);
	STDMETHOD(GetId)(const WCHAR** ppszId);
	STDMETHOD(SetText)(const WCHAR* pszText);
	STDMETHOD(GetText)(const WCHAR** ppszText);
	STDMETHOD(SetOriginalText)(const WCHAR* pszText);
	STDMETHOD(GetOriginalText)(const WCHAR** ppszText);
	STDMETHOD(SetFileName)(const WCHAR* pszFileName);
	STDMETHOD(GetFileName)(const WCHAR** ppszFileName);
	STDMETHOD(SetStartPhone)(const WCHAR* pszStartPhone);
	STDMETHOD(GetStartPhone)(const WCHAR** ppszStartPhone);
	STDMETHOD(SetEndPhone)(const WCHAR* pszEndPhone);
	STDMETHOD(GetEndPhone)(const WCHAR** ppszEndPhone);
	STDMETHOD(SetLeftContext)(const WCHAR* pszLeftContext);
	STDMETHOD(GetLeftContext)(const WCHAR** ppszLeftContext);
	STDMETHOD(SetRightContext)(const WCHAR* pszRightContext);
	STDMETHOD(GetRightContext)(const WCHAR** ppszRightContext);
    STDMETHOD(SetStart)(const double dFrom);
	STDMETHOD(GetStart)(double* dFrom);
	STDMETHOD(SetEnd)(const double dTo);
	STDMETHOD(GetEnd)(double* dTo);
	STDMETHOD(AddTag)(const WCHAR* pszTag);
	STDMETHOD(RemoveTag)(const USHORT unId);
	STDMETHOD(GetTag)(const WCHAR** ppszTag, const USHORT unId);
	STDMETHOD(CountTags)(USHORT* unTagCount);
    STDMETHOD(GetSamples)(SHORT** ppnSamples, int* iNumSamples, WAVEFORMATEX* pFormat);
    STDMETHOD(GetFormat)(WAVEFORMATEX** ppFormat);
private:
    volatile LONG m_vcRef;
    WCHAR*    m_pszId;
    WCHAR*    m_pszText;
    WCHAR*    m_pszOriginalText;
    WCHAR*    m_pszFileName;
    WCHAR*    m_pszStartPhone;
    WCHAR*    m_pszEndPhone;
    WCHAR*    m_pszRightContext;
    WCHAR*    m_pszLeftContext;
    double    m_dFrom;
    double    m_dTo;
    CSPArray<CDynStr,CDynStr> m_aTags;

};

#endif // !defined(AFX_DBENTRY_H__0A787DC1_8000_4D97_883E_E82558597089__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\promptentry.cpp ===
//////////////////////////////////////////////////////////////////////
// PromptEntry.cpp: implementation of the CPromptEntry class.
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#include "stdafx.h"
#include "PromptEntry.h"
#include "common.h"
#include "vapiIO.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
/////////////////////////////////////////////////////// JOEM 4-2000 //
CPromptEntry::CPromptEntry()
{
    m_pszId             = NULL;
    m_pszText           = NULL;
    m_pszOriginalText   = NULL;
    m_pszFileName       = NULL;
    m_pszStartPhone     = NULL;
    m_pszEndPhone       = NULL;
    m_pszRightContext   = NULL;
    m_pszLeftContext    = NULL;
    
    m_dFrom = 0;
    m_dTo = 0;
    m_vcRef  = 1;
}

// Copy constructor
CPromptEntry::CPromptEntry(const CPromptEntry & old)
{
    USHORT i = 0;

    if ( old.m_pszId )
    {
        m_pszId = wcsdup( old.m_pszId );
    }
    else 
    {
        m_pszId = NULL;
    }

    if ( old.m_pszText )
    {
        m_pszText = wcsdup( old.m_pszText );
    }
    else 
    {
        m_pszText = NULL;
    }

    if ( old.m_pszOriginalText )
    {
        m_pszOriginalText = wcsdup( old.m_pszOriginalText );
    }
    else 
    {
        m_pszOriginalText = NULL;
    }

    if ( old.m_pszFileName )
    {
        m_pszFileName = wcsdup( old.m_pszFileName );
    }
    else 
    {
        m_pszFileName = NULL;
    }

    if ( old.m_pszStartPhone )
    {
        m_pszStartPhone = wcsdup( old.m_pszStartPhone );
    }
    else 
    {
        m_pszStartPhone = NULL;
    }

    if ( old.m_pszEndPhone )
    {
        m_pszEndPhone = wcsdup( old.m_pszEndPhone );
    }
    else 
    {
        m_pszEndPhone = NULL;
    }

    if ( old.m_pszRightContext )
    {
        m_pszRightContext = wcsdup( old.m_pszRightContext );
    }
    else 
    {
        m_pszRightContext = NULL;
    }

    if ( old.m_pszLeftContext )
    {
        m_pszLeftContext = wcsdup( old.m_pszLeftContext );
    }
    else 
    {
        m_pszLeftContext = NULL;
    }

    m_dFrom       = old.m_dFrom;
    m_dTo         = old.m_dTo;

    for ( i=0; i<old.m_aTags.GetSize(); i++ )
    {
        m_aTags.Add( old.m_aTags[i] );
    }
    
    m_vcRef = 1;
}

// Destructor
CPromptEntry::~CPromptEntry()
{
    int i = 0;

    if (m_pszId) 
    {
        free(m_pszId);
        m_pszId = NULL;
    }
    if (m_pszText) 
    {
        free(m_pszText);
        m_pszText = NULL;
    }
    if (m_pszOriginalText) 
    {
        free(m_pszOriginalText);
        m_pszOriginalText = NULL;
    }
    if (m_pszFileName) 
    {
        free(m_pszFileName);
        m_pszFileName = NULL;
    }

    if (m_pszStartPhone) 
    {
        free(m_pszStartPhone);
        m_pszStartPhone = NULL;
    }
    if (m_pszEndPhone) 
    {
        free(m_pszEndPhone);
        m_pszEndPhone = NULL;
    }
    if (m_pszRightContext) 
    {
        free(m_pszRightContext);
        m_pszRightContext = NULL;
    }
    if (m_pszLeftContext) 
    {
        free(m_pszLeftContext);
        m_pszLeftContext = NULL;
    }

    for ( i=0; i<m_aTags.GetSize(); i++ )
    {
        m_aTags[i].dstr.Clear();
    }
    m_aTags.RemoveAll();
}

//
// IUnknown implementations
//
//////////////////////////////////////////////////////////////////////
// CPromptEntry::QueryInterface
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
STDMETHODIMP CPromptEntry::QueryInterface(const IID& iid, void** ppv)
{
    if ( iid == IID_IUnknown )
    {
        *ppv = dynamic_cast<IPromptEntry*> (this);
    }
    else if ( iid == IID_IPromptEntry )
    {
        *ppv = dynamic_cast<IPromptEntry*> (this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}
//////////////////////////////////////////////////////////////////////
// CPromptEntry::AddRef
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
ULONG CPromptEntry::AddRef()
{
    return InterlockedIncrement(&m_vcRef);
}
//////////////////////////////////////////////////////////////////////
// CPromptEntry::Release
//
/////////////////////////////////////////////////////// JOEM 5-2000 //
ULONG CPromptEntry::Release()
{
    if ( 0 == InterlockedDecrement(&m_vcRef) )
    {
        delete this;
        return 0;
    }

    return (ULONG) m_vcRef;
}

//
// IPromptEntry implementations
//
// All of the following should be reasonably self-explanatory functions
// for reading/writing entry data.
//

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetId
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::SetId(const WCHAR *pszId)
{
    SPDBG_FUNC( "CPromptEntry::SetId" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(pszId);

    if ( m_pszId ) 
    {
        free ( m_pszId );
        m_pszId = NULL;
    }

    m_pszId = wcsdup(pszId);

    if ( !m_pszId ) 
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = RegularizeText(m_pszId, KEEP_PUNCTUATION);
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetId
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::GetId(const WCHAR **ppszId)
{
    SPDBG_FUNC( "CPromptEntry::GetId" );
    HRESULT hr = S_OK;

    *ppszId = m_pszId;

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetText
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::SetText(const WCHAR *pszText)
{
    SPDBG_FUNC( "CPromptEntry::SetText" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(pszText);

    if ( m_pszText ) 
    {
        free ( m_pszText );
        m_pszText = NULL;
    }

    m_pszText = wcsdup(pszText);

    if ( !m_pszText ) 
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = RegularizeText(m_pszText, REMOVE_PUNCTUATION);
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetText
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::GetText(const WCHAR** ppszText)
{
    SPDBG_FUNC( "CPromptEntry::GetText" );
    HRESULT hr = S_OK;
    
    *ppszText = m_pszText;

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetOriginalText
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::SetOriginalText(const WCHAR *pszText)
{
    SPDBG_FUNC( "CPromptEntry::SetOriginalText" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(pszText);

    if ( m_pszOriginalText ) 
    {
        free ( m_pszOriginalText );
        m_pszOriginalText = NULL;
    }

    m_pszOriginalText = wcsdup(pszText);

    if ( !m_pszOriginalText ) 
    {
        hr = E_OUTOFMEMORY;
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetOriginalText
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::GetOriginalText(const WCHAR** ppszText)
{
    SPDBG_FUNC( "CPromptEntry::GetOriginalText" );
    HRESULT hr = S_OK;
    
    *ppszText = m_pszOriginalText;

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetFileName
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::SetFileName(const WCHAR *pszFileName)
{
    SPDBG_FUNC( "CPromptEntry::SetFileName" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(pszFileName);

    if ( m_pszFileName ) 
    {
        free ( m_pszFileName );
        m_pszFileName = NULL;
    }

    m_pszFileName = wcsdup(pszFileName);

    if ( !m_pszFileName ) 
    {
        hr = E_OUTOFMEMORY;
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetFileName
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::GetFileName(const WCHAR** ppszFileName)
{
    SPDBG_FUNC( "CPromptEntry::GetFileName" );
    HRESULT hr = S_OK;

    *ppszFileName = m_pszFileName;

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetStartPhone
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::SetStartPhone(const WCHAR *pszStartPhone)
{
    SPDBG_FUNC( "CPromptEntry::SetStartPhone" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(pszStartPhone);

    if ( m_pszStartPhone ) 
    {
        free ( m_pszStartPhone );
        pszStartPhone = NULL;
    }

    m_pszStartPhone = wcsdup(pszStartPhone);

    if ( !m_pszStartPhone ) 
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = RegularizeText(m_pszStartPhone, KEEP_PUNCTUATION);
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetStartPhone
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::GetStartPhone(const WCHAR** ppszStartPhone)
{
    SPDBG_FUNC( "CPromptEntry::GetStartPhone" );
    HRESULT hr = S_OK;

    *ppszStartPhone = m_pszStartPhone;

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetEndPhone
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::SetEndPhone(const WCHAR *pszEndPhone)
{
    SPDBG_FUNC( "CPromptEntry::SetEndPhone" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(pszEndPhone);

    if ( m_pszEndPhone ) 
    {
        free ( m_pszEndPhone );
        pszEndPhone = NULL;
    }

    m_pszEndPhone = wcsdup(pszEndPhone);

    if ( !m_pszEndPhone ) 
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = RegularizeText(m_pszEndPhone, KEEP_PUNCTUATION);
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetEndPhone
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::GetEndPhone(const WCHAR** ppszEndPhone)
{
    SPDBG_FUNC( "CPromptEntry::GetEndPhone" );
    HRESULT hr = S_OK;

    *ppszEndPhone = m_pszEndPhone;

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetLeftContext
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::SetLeftContext(const WCHAR *pszLeftContext)
{
    SPDBG_FUNC( "CPromptEntry::SetLeftContext" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(pszLeftContext);

    if ( m_pszLeftContext ) 
    {
        free ( m_pszLeftContext );
        pszLeftContext = NULL;
    }

    m_pszLeftContext = wcsdup(pszLeftContext);

    if ( !m_pszLeftContext ) 
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = RegularizeText(m_pszLeftContext, KEEP_PUNCTUATION);
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetLeftContext
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::GetLeftContext(const WCHAR** ppszLeftContext)
{
    SPDBG_FUNC( "CPromptEntry::GetLeftContext" );
    HRESULT hr = S_OK;

    *ppszLeftContext = m_pszLeftContext;

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetRightContext
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::SetRightContext(const WCHAR *pszRightContext)
{
    SPDBG_FUNC( "CPromptEntry::SetRightContext" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(pszRightContext);

    if ( m_pszRightContext ) 
    {
        free ( m_pszRightContext );
        pszRightContext = NULL;
    }

    m_pszRightContext = wcsdup(pszRightContext);

    if ( !m_pszRightContext ) 
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = RegularizeText(m_pszRightContext, KEEP_PUNCTUATION);
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetRightContext
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::GetRightContext(const WCHAR** ppszRightContext)
{
    SPDBG_FUNC( "CPromptEntry::GetRightContext" );
    HRESULT hr = S_OK;

    *ppszRightContext = m_pszRightContext;

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetStart
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::SetStart(const double dFrom)
{
    SPDBG_FUNC( "CPromptEntry::SetStart" );
    if ( dFrom < 0.0 )
    {
        return E_INVALIDARG;
    }

    m_dFrom = dFrom;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetStart
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::GetStart(double *dFrom)
{
    SPDBG_FUNC( "CPromptEntry::GetStart" );
    *dFrom = m_dFrom;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// SetEnd
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::SetEnd(const double dTo)
{
    SPDBG_FUNC( "CPromptEntry::SetEnd" );
    if ( dTo <= 0.0 )
    {
        if ( dTo != -1.0 )
        {
            return E_INVALIDARG;
        }
    }

    m_dTo = dTo;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetEnd
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::GetEnd(double *dTo)
{
    SPDBG_FUNC( "CPromptEntry::GetEnd" );
    *dTo = m_dTo;

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// AddTag
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::AddTag(const WCHAR *pszTag)
{
    SPDBG_FUNC( "CPromptEntry::AddTag" );
    HRESULT hr          = S_OK;
    WCHAR*  pszCapTag   = NULL;

    SPDBG_ASSERT(pszTag);

    pszCapTag = wcsdup(pszTag);
    if ( !pszCapTag )
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED(hr) )
    {
        WStringUpperCase(pszCapTag);
        m_aTags.Add(pszCapTag);
        free(pszCapTag);
        pszCapTag = NULL;
    }

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// RemoveTag
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::RemoveTag(const USHORT unId)
{
    SPDBG_FUNC( "CPromptEntry::RemoveTag" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(unId);

    if ( unId >= m_aTags.GetSize() )
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED(hr) )
    {
        m_aTags[unId].dstr.Clear();
        m_aTags.RemoveAt( unId );
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetTag
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::GetTag(const WCHAR **ppszTag, const USHORT unId)
{
    SPDBG_FUNC( "CPromptEntry::GetTag" );
    HRESULT hr = S_OK;

    if ( unId >= m_aTags.GetSize() )
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED(hr) )
    {
        *ppszTag = m_aTags[unId].dstr;
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// CountTags
//
/////////////////////////////////////////////////////// JOEM 3-2000 //
STDMETHODIMP CPromptEntry::CountTags(USHORT *unTagCount)
{
    SPDBG_FUNC( "CPromptEntry::CountTags" );
    *unTagCount = (USHORT) m_aTags.GetSize();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetSamples
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::GetSamples(SHORT** ppnSamples, int* iNumSamples, WAVEFORMATEX* pFormat)
{
    SPDBG_FUNC( "CPromptEntry::GetSamples" );
    HRESULT hr      = S_OK;
    VapiIO* pVapiIO = NULL;

    SPDBG_ASSERT(ppnSamples);
    SPDBG_ASSERT(iNumSamples);
    SPDBG_ASSERT(pFormat);

    if ( SUCCEEDED( hr ) )
    {
        pVapiIO = VapiIO::ClassFactory();
        if ( !pVapiIO )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        if ( pVapiIO->OpenFile(m_pszFileName, VAPI_IO_READ) != 0 )
        {
            hr = E_ACCESSDENIED;
        }
        
        if ( SUCCEEDED(hr) )
        {
            if ( pVapiIO->Format(NULL, NULL, pFormat) != 0 )
            {
                hr = E_FAIL;
            }
            
            if ( SUCCEEDED(hr) )
            {
                if ( pVapiIO->ReadSamples(m_dFrom, m_dTo, (void**) ppnSamples, iNumSamples, 1) != 0 )
                {
                    hr = E_FAIL;
                }
                
            }
            
            pVapiIO->CloseFile();
        }

        delete pVapiIO;
        pVapiIO = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPromptEntry
//
// GetFormat
//
/////////////////////////////////////////////////////// JOEM 6-2000 //
STDMETHODIMP CPromptEntry::GetFormat(WAVEFORMATEX** ppFormat)
{
    SPDBG_FUNC( "CPromptEntry::GetSamples" );
    HRESULT hr      = S_OK;
    VapiIO* pVapiIO = NULL;

    SPDBG_ASSERT(ppFormat);

    if ( SUCCEEDED( hr ) )
    {
        pVapiIO = VapiIO::ClassFactory();
        if ( !pVapiIO )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( SUCCEEDED(hr) )
    {
        if ( pVapiIO->OpenFile(m_pszFileName, VAPI_IO_READ) != 0 )
        {
            hr = E_ACCESSDENIED;
        }
        
        if ( SUCCEEDED(hr) )
        {
            if ( pVapiIO->Format(NULL, NULL, *ppFormat) != 0 )
            {
                hr = E_FAIL;
            }
            
            pVapiIO->CloseFile();
        }

        delete pVapiIO;
        pVapiIO = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//
// Created by JOEM  01-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//

#if !defined(AFX_STDAFX_H__944A993F_CF82_47E5_9675_EF78F56691DF__INCLUDED_)
#define AFX_STDAFX_H__944A993F_CF82_47E5_9675_EF78F56691DF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "spunicode.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__944A993F_CF82_47E5_9675_EF78F56691DF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information
//
// Created by JOEM  03-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSPromptEng.rc
//
#define IDS_PROJNAME                    100
#define IDR_PROMPTENG                   101
#define IDR_PROMPTDB                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\query.h ===
//////////////////////////////////////////////////////////////////////
// Query.h: interface for the CQuery class.
//
// Created by JOEM  03-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 3-2000 //

#if !defined(AFX_QUERY_H__F65AE4EC_2D69_4DAC_B1E2_8BB07D22B51B__INCLUDED_)
#define AFX_QUERY_H__F65AE4EC_2D69_4DAC_B1E2_8BB07D22B51B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "PromptEntry.h"
#include <spddkhlp.h>
#include <spcollec.h>

enum FragType
{
    SAPI_FRAG = 0,
    LOCAL_FRAG,
    COMBINED_FRAG
};

enum XMLStatus
{
    NOT_XML = 0,
    KNOWN_XML,
    UNKNOWN_XML,
    SILENCE
};

class CQuery  
{
public:
	CQuery();
	CQuery(const CQuery& old);
	~CQuery();
public:
	XMLStatus           m_fXML;
	bool                m_fTTS;
	bool                m_fSpeak;
    FragType            m_fFragType;
	WCHAR*              m_pszExpandedText;
	WCHAR*              m_pszDbName;
	WCHAR*              m_pszDbPath;
	WCHAR*              m_pszDbIdSet;
    WCHAR*              m_pszId;
	USHORT              m_unDbAction;
    USHORT              m_unDbIndex;
    ULONG               m_ulTextOffset;
    ULONG               m_ulTextLen;
	SPVTEXTFRAG*        m_pTextFrag;

    CSPArray<CDynStr,CDynStr>*              m_paTagList;
    CSPArray<CPromptEntry*,CPromptEntry*>   m_apEntry;
    CSPArray<bool,bool>                     m_afEntryMatch;


};

#endif // !defined(AFX_QUERY_H__F65AE4EC_2D69_4DAC_B1E2_8BB07D22B51B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\query.cpp ===
//////////////////////////////////////////////////////////////////////
// Query.cpp: implementation of the CQuery class.
//
// Created by JOEM  03-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 3-2000 //

#include "stdafx.h"
#include "Query.h"
#include "common.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CQuery::CQuery()
{
    m_fXML              = NOT_XML;
    m_fTTS              = false;
    m_fFragType         = SAPI_FRAG;
    m_fSpeak            = true;
    m_pszExpandedText   = NULL;
    m_pszDbName         = NULL;
	m_pszDbPath         = NULL;
    m_pszDbIdSet        = NULL;
	m_pszId             = NULL;
	m_unDbAction        = 0;
    m_unDbIndex         = 0;
    m_pTextFrag         = NULL;
    m_paTagList         = NULL;
    m_ulTextOffset      = 0;
    m_ulTextLen         = 0;
}

CQuery::CQuery(const CQuery& old)
{
    USHORT i = 0;

    if ( old.m_pszExpandedText )
    {
        m_pszExpandedText   = wcsdup(old.m_pszExpandedText);
    }
    else
    {
        m_pszExpandedText = NULL;
    }


    if ( old.m_pszDbName )
    {
        m_pszDbName         = wcsdup(old.m_pszDbName);
    }
    else
    {
        m_pszDbName = NULL;
    }

    if ( old.m_pszDbPath )
    {
        m_pszDbPath         = wcsdup(old.m_pszDbPath);
    }
    else
    {
        m_pszDbPath = NULL;
    }
	
    if ( old.m_pszDbIdSet )
    {
        m_pszDbIdSet         = wcsdup(old.m_pszDbIdSet);
    }
    else
    {
        m_pszDbIdSet = NULL;
    }
	
    m_fXML              = old.m_fXML;
	m_fTTS              = old.m_fTTS;
	m_fFragType         = old.m_fFragType;
	m_fSpeak            = old.m_fSpeak;
	m_unDbAction        = old.m_unDbAction;
    m_unDbIndex         = old.m_unDbIndex;
    m_ulTextOffset      = old.m_ulTextOffset;
    m_ulTextLen         = old.m_ulTextLen;
    	
    m_pTextFrag = new SPVTEXTFRAG(*old.m_pTextFrag);
    m_pszId = wcsdup (old.m_pszId);

    for (i=0; i<old.m_apEntry.GetSize(); i++)
    {
        m_apEntry.Add(old.m_apEntry[i]);
        m_apEntry[i]->AddRef();
    }

    for (i=0; i<old.m_afEntryMatch.GetSize(); i++)
    {
        m_afEntryMatch.Add(old.m_afEntryMatch[i]);
    }

    if ( old.m_paTagList )
    {
        m_paTagList = new CSPArray<CDynStr,CDynStr>;
        m_paTagList->Copy(*old.m_paTagList);
    }
    else
    {
        m_paTagList = NULL;
    }
}

CQuery::~CQuery()
{
    USHORT i = 0;

    if ( m_pszDbName )
    {
        free (m_pszDbName);
        m_pszDbName = NULL;
    }
    if ( m_pszDbPath )
    {
        free (m_pszDbPath);
        m_pszDbPath = NULL;
    }
    if ( m_pszDbIdSet )
    {
        free (m_pszDbIdSet);
        m_pszDbIdSet = NULL;
    }
    if ( m_pszExpandedText )
    {
        free ( m_pszExpandedText );
        m_pszExpandedText = NULL;
    }
    if ( m_pszId )
    {
        free ( m_pszId );
        m_pszId = NULL;
    }
    if ( m_paTagList )
    {
        for ( i=0; i<m_paTagList->GetSize(); i++ )
        {
            (*m_paTagList)[i].dstr.Clear();
        }
        m_paTagList->RemoveAll();
        delete m_paTagList;
        m_paTagList = NULL;
    }
    if ( m_pTextFrag )
    {
        delete m_pTextFrag;
        m_pTextFrag = NULL;
    }

    for ( i=0; i<m_apEntry.GetSize(); i++ )
    {
        m_apEntry[i]->Release();
        m_apEntry[i] = NULL;
    }
    m_apEntry.RemoveAll();

    m_afEntryMatch.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\textrules.cpp ===
//////////////////////////////////////////////////////////////////////
// TextRules.cpp: implementation of the CTextRules class.
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#include "stdafx.h"
#include "TextRules.h"
#include "common.h"
#include <comdef.h>
#include <stdio.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTextRules::CTextRules()
{
    m_pIScriptInterp        = NULL;
    m_pszRuleScript         = NULL;
    m_pszScriptLanguage     = NULL;
    m_fActive               = false;
}

CTextRules::~CTextRules()
{
    if ( m_pIScriptInterp )
    {
        m_pIScriptInterp->Reset();
        m_pIScriptInterp->Release();
        m_pIScriptInterp = NULL;
    }

    if ( m_pszRuleScript )
    {
        free(m_pszRuleScript);
        m_pszRuleScript = NULL;
    }
    if ( m_pszScriptLanguage )
    {
        free(m_pszScriptLanguage);
        m_pszScriptLanguage = NULL;
    }
}

//////////////////////////////////////////////////////////////////////
// CTextRules::ApplyRule
// 
// On first execution, creates script interpreter, sets the script
// language, and loads/parses the script.
//
// On first and subsequent calls, checks loaded script for a 
// text expansion/normalization rule (pszRuleName), applies the rule 
// to pszOriginalText, producing ppszNewText.
//
/////////////////////////////////////////////////////// JOEM 4-2000 //
HRESULT CTextRules::ApplyRule(const WCHAR* pszRuleName, const WCHAR* pszOriginalText, WCHAR** ppszNewText)
{
    SPDBG_FUNC( "CTextRules::ApplyRule" );
    HRESULT     hr = S_OK;
    LPSAFEARRAY psaScriptPar = NULL;
    _variant_t  varNewText;

    SPDBG_ASSERT (pszRuleName);
    SPDBG_ASSERT (pszOriginalText);

    hr = SetInputParam(pszOriginalText, &psaScriptPar); 

    // IMPORTANT NOTE:  
    // Script code must be added (AddCode) and used (Run) within the same thread.
    // SAPI's LazyInit is a different thread than Speak calls, so AddCode must be
    // delayed until the first Run call is needed.  Once AddCode has occurred, 
    // the m_fActive flag is turned on so the code doesn't get added multiple times.
    if ( !m_fActive )
    {
        if ( !m_pszRuleScript || !m_pszScriptLanguage )
        {
            hr = E_INVALIDARG;
        }

        // Initialize Script Control
        if ( SUCCEEDED(hr) )
        {
            hr = CoCreateInstance(CLSID_ScriptControl, NULL, CLSCTX_ALL, IID_IScriptControl, (LPVOID *)&m_pIScriptInterp);
        }
        
        if ( SUCCEEDED (hr) )
        {
            hr = m_pIScriptInterp->put_Language( (_bstr_t)m_pszScriptLanguage );
        }
           
        if ( SUCCEEDED (hr) )
        {
            hr = m_pIScriptInterp->AddCode( (_bstr_t)m_pszRuleScript );
        }

        if ( SUCCEEDED(hr) )
        {
            m_fActive = true;
            
            if ( m_pszRuleScript )
            {
                free(m_pszRuleScript);
                m_pszRuleScript = NULL;
            }
            
            if ( m_pszScriptLanguage )
            {
                free(m_pszScriptLanguage);
                m_pszScriptLanguage = NULL;
            }
        }
        else
        {
            if ( m_pIScriptInterp )
            {
                m_pIScriptInterp->Reset();
                m_pIScriptInterp->Release();
                m_pIScriptInterp = NULL;
            }
        }
    }
    
    if ( SUCCEEDED(hr) )
    { 
        hr = m_pIScriptInterp->Run( (_bstr_t)pszRuleName, &psaScriptPar, &varNewText);
    }

    if ( SUCCEEDED (hr) )
    {
        if ( varNewText.vt == VT_EMPTY )
        {
            hr = E_UNEXPECTED;
        }
    }
    
    if ( SUCCEEDED(hr) )
    {
        *ppszNewText = wcsdup( (wchar_t*) ( (_bstr_t)varNewText ) );
        if ( !*ppszNewText )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( psaScriptPar )
    {
        SafeArrayDestroy(psaScriptPar);
        psaScriptPar = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CTextRules::SetInputParam
//
// Builds a SafeArray input parameter for the script engine,
// out of the text to be modified.
//
/////////////////////////////////////////////////////// JOEM 4-2000 //
HRESULT CTextRules::SetInputParam(const WCHAR *pswzTextParam, LPSAFEARRAY *ppsaScriptPar)
{
    SPDBG_FUNC( "CTextRules::SetInputParam" );
    HRESULT hr      = S_OK;
    VARIANT vFlavors[1];
	long    lZero   = 0;
    int     i       = 0;
	SAFEARRAYBOUND rgsabound[]  = {1, 0}; // 1 element, 0 - base start

    *ppsaScriptPar = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
    if (! *ppsaScriptPar)
	{
		hr = E_FAIL;
	}

    if ( SUCCEEDED(hr) )
    {
        VariantInit(&vFlavors[0]);
        V_VT(&vFlavors[0]) = VT_BSTR;
        V_BSTR(&vFlavors[0]) = SysAllocString( (_bstr_t)pswzTextParam );

        hr = SafeArrayPutElement(*ppsaScriptPar, &lZero, &vFlavors[0]);

        if ( FAILED(hr) )
        {
            SafeArrayDestroy(*ppsaScriptPar);
            *ppsaScriptPar = NULL;
        }

        SysFreeString(vFlavors[0].bstrVal);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CTextRules::ReadRules
//
// Reads in the script from the script file.  Sets the script language.
//
/////////////////////////////////////////////////////// JOEM 4-2000 //
HRESULT CTextRules::ReadRules(const WCHAR* pszScriptLanguage, const WCHAR *pszPath)
{
    SPDBG_FUNC( "CTextRules::ReadRules" );
    HRESULT hr          = S_OK;
    FILE*   phRuleFile  = NULL;
    LONG    ret         = 0;

    // Open the rule file and read in the script
    phRuleFile = _wfopen(pszPath, L"r");
    if ( phRuleFile == NULL )
    {
        hr = E_ACCESSDENIED;
    }

    if ( SUCCEEDED(hr) )
    {
        fseek(phRuleFile, 0L, SEEK_SET);
        LONG start = ftell(phRuleFile);
        fseek(phRuleFile, 0L, SEEK_END);
        LONG end = ftell(phRuleFile);
        rewind(phRuleFile);
        LONG len = end - start;
        
        // allocate len (bytes) plus an extra char for a NULL char
        m_pszRuleScript = (char*) malloc( len + sizeof(char) );
        if ( !m_pszRuleScript )
        {
            hr = E_OUTOFMEMORY;
        }
        
        if ( SUCCEEDED (hr) )
        {
            ret = fread(m_pszRuleScript, sizeof(char), len, phRuleFile);
            if ( ftell(phRuleFile) != end )
            {
                hr = E_ABORT;
            }
        }
        if ( SUCCEEDED (hr) )
        {
            m_pszRuleScript[ret] = '\0';
        }

        fclose(phRuleFile);
    }

    if ( SUCCEEDED(hr) )
    {
        m_pszScriptLanguage = wcsdup(pszScriptLanguage);
        if ( !m_pszScriptLanguage )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Create the script interpreter and add code.  This is to check
    // that the code is valid.  Later, ApplyRule will add the code again,
    // because script code must be added and used within the same thread.
    // (SAPI's LazyInit is a different thread than Speak).
    if ( SUCCEEDED(hr) )
    {
        hr = CoCreateInstance(CLSID_ScriptControl, NULL, CLSCTX_ALL, IID_IScriptControl, (LPVOID *)&m_pIScriptInterp);
    }
    
    if ( SUCCEEDED(hr) )
    {
        hr = m_pIScriptInterp->put_Language( (_bstr_t)m_pszScriptLanguage );
        
        if ( SUCCEEDED (hr) )
        {
            hr = m_pIScriptInterp->AddCode( (_bstr_t)m_pszRuleScript );
        }
        // Release immediately, since this Instance is useless in this thread.
        m_pIScriptInterp->Release();
        m_pIScriptInterp = NULL;
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\textrules.h ===
//////////////////////////////////////////////////////////////////////
// TextRules.h: interface for the CTextRules class.
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#if !defined(AFX_TEXTRULES_H__2A4E2D03_6982_478E_B09A_8994C91E573C__INCLUDED_)
#define AFX_TEXTRULES_H__2A4E2D03_6982_478E_B09A_8994C91E573C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "msscpctl.h"

class CTextRules  
{
public:
	CTextRules();
	~CTextRules();
	HRESULT ApplyRule(const WCHAR* pszRuleName, const WCHAR* pszOriginalText, WCHAR** ppszNewText);
	HRESULT ReadRules(const WCHAR* pszScriptLanguage, const WCHAR *pszPath);

public:

private:
	HRESULT SetInputParam(const WCHAR* pswzTextParam, LPSAFEARRAY *psaScriptPar);

private:
    IScriptControl* m_pIScriptInterp; // interface pointer to ScriptControl object
    char*           m_pszRuleScript;
    WCHAR*          m_pszScriptLanguage;
	bool            m_fActive;
};

#endif // !defined(AFX_TEXTRULES_H__2A4E2D03_6982_478E_B09A_8994C91E573C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\xmltag.cpp ===
//////////////////////////////////////////////////////////////////////
// XMLTag.cpp: implementation of the CXMLTag class.
//
// Created by JOEM  05-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLTag.h"
#include "PromptDb.h"
#include "common.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CXMLTag::CXMLTag()
{
}

CXMLTag::~CXMLTag()
{
    int i = 0;

    for ( i=0; i<m_apXMLAtt.GetSize(); i++ )
    {
        if ( m_apXMLAtt[i] )
        {
            delete m_apXMLAtt[i];
            m_apXMLAtt[i] = NULL;
        }
    }
    m_apXMLAtt.RemoveAll();

    m_dstrXMLName.Clear();
}

/////////////////////////////////////////////////////////////////////////////
// CXMLTag::ParseUnknownTag
//
// Helper function for CPromptEng::BuildQueryList.  Parses prompt-engine 
// specific XML tags which SAPI ignored.
//
//////////////////////////////////////////////////////////// JOEM  07-2000 //
STDMETHODIMP CXMLTag::ParseUnknownTag(const WCHAR *pszTag)
{
    SPDBG_FUNC( "CXMLTag::ParseUnknownTag" );
    HRESULT hr              = S_OK;
    WCHAR* pszTagHolder     = NULL;
    WCHAR* pszTagNameStart  = NULL;
    WCHAR* pszTagNameEnd    = NULL;
    WCHAR* pszAtt           = NULL;

    SPDBG_ASSERT(pszTag);

    pszTagHolder = wcsdup(pszTag);
    if (!pszTagHolder)
    {
        return E_OUTOFMEMORY;
    }

    // Get the tag name.
    pszTagNameStart = pszTagHolder;
    pszTagNameStart++;
    WSkipWhiteSpace(pszTagNameStart); // marks the beginning of the tag name

    pszTagNameEnd = pszTagNameStart;
    pszTagNameEnd++; // must move ahead one character in case pszTagNameStart is '/';
    pszTagNameEnd = pszTagNameEnd + wcscspn(pszTagNameEnd, L"> /"); // find first space, '>', or '/'

    // Did we hit the end of the string?
    if ( pszTagNameEnd[0] == L'\0' )
    {
        hr = S_FALSE;  // empty tags are allowed, but ignored as unknown.
    }
    else
    {
        pszAtt = pszTagNameEnd; // pointer for attribute search
        pszAtt++;
        if ( pszAtt[0] == L'\0' )
        {
            pszAtt = NULL;
        }

        pszTagNameEnd[0] = L'\0'; // marks the end of the tag name
    }

    if ( SUCCEEDED(hr) )
    {       
        m_dstrXMLName = pszTagNameStart;
        WStringUpperCase(m_dstrXMLName);
    }

    // Get all the attributes
    if ( SUCCEEDED(hr) && pszAtt && pszAtt[0] != L'\0' )
    {
        while ( hr == S_OK && pszAtt )
        {
            hr = ParseAttribute(&pszAtt);
        }
    }

    if ( pszTagHolder )
    {
        free(pszTagHolder);
        pszTagHolder = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CXMLTag::ParseAttribute
//
// Parses the attributes in XML tags which SAPI ignored.
//
//////////////////////////////////////////////////////////// JOEM  07-2000 //
STDMETHODIMP CXMLTag::ParseAttribute(WCHAR **pszAtt)
{
    SPDBG_FUNC( "CXMLTag::ParseAttribute" );
    HRESULT hr              = S_OK;
    WCHAR* pszAttEnd        = NULL;
    WCHAR* pszAttValue      = NULL;
    WCHAR* pszAttValueEnd   = NULL;
    WCHAR  pszAttValueMark  = L'\0';

    if ( SUCCEEDED(hr) )
    {
        // move to beginning of Attribute Name
        WSkipWhiteSpace(*pszAtt);
        if ( (*pszAtt)[0] == L'/' )
        {
            (*pszAtt)++; // this is an end of tag marker - next non-whitespace char should be '>'
            WSkipWhiteSpace(*pszAtt);
            if ( (*pszAtt)[0] != L'>' )
            {
                hr = SPERR_XML_BAD_SYNTAX;
            }
        }
        if ( SUCCEEDED(hr) )
        {
            if ( (*pszAtt)[0] == L'>' || (*pszAtt)[0] == L'\0' )
            {
                hr = S_FALSE; // end of tag - no attributes left.
                *pszAtt = NULL; 
            }
        }
    }

    // Find the end of the Attribute Name
    if ( hr == S_OK )
    {
        pszAttEnd = *pszAtt;
        pszAttEnd = pszAttEnd++;
        pszAttEnd = pszAttEnd + wcscspn(pszAttEnd, L"> ="); // find first space, '>', or '='
        if ( pszAttEnd[0] == L'\0' )
        {
            hr = SPERR_XML_BAD_SYNTAX;  // shouldn't reach end of string before getting '>'
        }
        else
        {
            pszAttValue = pszAttEnd;

            WSkipWhiteSpace(pszAttValue);
            if ( pszAttValue[0] != L'=' ) // no '=' means no value for this attribute
            {
                pszAttEnd[0] = L'\0'; // allow no value - for unknown XML
                hr = S_FALSE;
                pszAttValue = NULL;
                pszAttValueEnd = pszAttEnd;
            } 
            else if ( hr == S_OK )
            {
                pszAttValue++; // go past the '='
                pszAttEnd[0] = L'\0';

                // Move to the beginning of the attribute value
                WSkipWhiteSpace(pszAttValue);
                if ( pszAttValue[0] != L'"' && pszAttValue[0] != L'\'' ) // no '"' means no value for this attribute
                {                    
                    hr = S_FALSE;
                    pszAttValue = NULL;
                    pszAttValueEnd = pszAttEnd;
                }
                else
                {
                    // XML syntax requires open/close quotes to match, so keep track of which was used.
                    pszAttValueMark = pszAttValue[0];
                    pszAttValue++;
                }
            }
        }
    }

    if ( hr == S_OK )
    {
        // Find the end of the Attribute Value
        if ( hr == S_OK )
        {
            pszAttValueEnd = pszAttValue;
            //while ( pszAttValueEnd[0] && pszAttValueEnd[0] != L'"' )
            while ( pszAttValueEnd[0] && pszAttValueEnd[0] != pszAttValueMark )
            {
                pszAttValueEnd++;
            }
            if ( pszAttValueEnd[0] != pszAttValueMark ) // no closing '"' means this is not actually a value.
            {
                hr = S_FALSE;
                pszAttValue = NULL;
                pszAttValueEnd = pszAttEnd;
            }
            if ( hr == S_OK )
            {
                pszAttValueEnd[0] = L'\0';
            }
        }
    }

    // Make sure the attribute is valid
    if ( SUCCEEDED(hr) && *pszAtt )
    {
        hr = CheckAttribute(*pszAtt, pszAttValue);
    }

    // Save this attribute
    if ( hr == S_OK )
    {
        CXMLAttribute* newAtt = new CXMLAttribute;
        if ( !newAtt )
        {
            hr =  E_OUTOFMEMORY;
        }
        if ( SUCCEEDED(hr) )
        {
            newAtt->m_dstrAttName = *pszAtt;
            newAtt->m_dstrAttValue = pszAttValue;
            m_apXMLAtt.Add(newAtt);
        }
    }

    // set pszAtt for the next attribute search.
    if ( hr == S_OK )
    {
        *pszAtt = ++pszAttValueEnd;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;

}
/////////////////////////////////////////////////////////////////////////////
// CXMLTag::CheckAttribute
//
// Checks to make sure the attribute isn't a duplicate, then saves it.
//
//////////////////////////////////////////////////////////// JOEM  07-2000 //
STDMETHODIMP CXMLTag::CheckAttribute(WCHAR *pszAtt, WCHAR* pszAttValue)
{
    SPDBG_FUNC( "CXMLTag::SaveAttribute" );
    HRESULT hr      = S_OK;
    int             iTagId  = 0;
    int             i       = 0;

    SPDBG_ASSERT(pszAtt);

    if ( !pszAtt )
    {
        hr = SPERR_XML_BAD_SYNTAX;
    }

    WStringUpperCase(pszAtt);

    // find out which XML tag this is
    if ( SUCCEEDED(hr) )
    {
        iTagId = g_unNumXMLTags;
        for ( i=0; i < g_unNumXMLTags; i++ )
        {
            if ( !wcscmp( m_dstrXMLName, XMLTags[i].pszTag ) )
            {
                iTagId = XMLTags[i].unTag;
                break;
            }
        }
    }
    
    // for whatever tag it is, search through valid attributes.
    if ( SUCCEEDED(hr) )
    {
        hr = SPERR_XML_BAD_SYNTAX;
        
        switch ( iTagId )
        {
            
        case ID:
            for ( i=0; i<NUM_ID_ATT_NAMES; i++ )
            {
                if ( wcscmp(pszAtt, g_IDAttNames[i] ) == 0 )
                {
                    hr = S_OK;
                    break;
                }
            }
            if ( pszAttValue )
            {
                WStringUpperCase(pszAttValue);
                hr = RegularizeText(pszAttValue, KEEP_PUNCTUATION);
            }
            break;
        case RULE:
            for ( i=0; i<NUM_RULE_ATT_NAMES; i++ )
            {
                if ( wcscmp(pszAtt, g_RuleAttNames[i] ) == 0 )
                {
                    hr = S_OK;
                    break;
                }
            }
            break;
        case WITHTAG:
            for ( i=0; i<NUM_WITHTAG_ATT_NAMES; i++ )
            {
                if ( wcscmp(pszAtt, g_WithTagAttNames[i] ) == 0 )
                {
                    hr = S_OK;
                    break;
                }
            }
            if ( pszAttValue )
            {
                WStringUpperCase(pszAttValue);
            }
            break;
        case DATABASE:
            for ( i=0; i<NUM_DB_ATT_NAMES; i++ )
            {
                if ( wcscmp(pszAtt, g_DbAttNames[i] ) == 0 )
                {
                    hr = S_OK;
                    break;
                }
            }
            // for any attributes except LOADPATH, upcase the value
            if ( wcscmp( g_DbAttNames[i], L"LOADPATH" ) )
            {
                if ( pszAttValue )
                {
                    WStringUpperCase(pszAttValue);
                }
            }
            break;
        case WAV:
            for ( i=0; i<NUM_WAV_ATT_NAMES; i++ )
            {
                if ( wcscmp(pszAtt, g_WavAttNames[i] ) == 0 )
                {
                    hr = S_OK;
                    break;
                }
            }
            break;
        case BREAK:
        case TTS:
        case TTS_END:
        case RULE_END:
        case WITHTAG_END:
            // attributes not allowed for these tags
            break;
        default:
            hr = S_OK; // Unknown XML - don't care about its attributes
        }
    }

    // Finally, make sure this Attribute isn't a repeat
    if ( SUCCEEDED(hr) && iTagId != g_unNumXMLTags )
    {
        for ( i=0; i < m_apXMLAtt.GetSize(); i++ )
        {
            if ( m_apXMLAtt[i]->m_dstrAttName.Length() && pszAtt )
            {
                if ( wcscmp(m_apXMLAtt[i]->m_dstrAttName, pszAtt) == 0 )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
            }
        }
    }

    return hr;

}

/////////////////////////////////////////////////////////////////////////////
// CXMLTag::GetTagName
//
// Retrieves the Tag identifier
//
//////////////////////////////////////////////////////////// JOEM  05-2000 //
STDMETHODIMP CXMLTag::GetTagName(const WCHAR **ppszTagName)
{
    SPDBG_FUNC( "CXMLTag::GetTagName" );
    HRESULT hr = S_OK;

    *ppszTagName = m_dstrXMLName;

    if ( !*ppszTagName )
    {
        hr = E_FAIL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CXMLTag::GetAttribute
//
// Retrieves the Tag Attribute
//
//////////////////////////////////////////////////////////// JOEM  05-2000 //
STDMETHODIMP CXMLTag::GetAttribute(const USHORT unAttId, CXMLAttribute **ppXMLAtt)
{
    SPDBG_FUNC( "CXMLTag::GetAttribute" );
    SPDBG_ASSERT( unAttId < m_apXMLAtt.GetSize() );

    *ppXMLAtt = m_apXMLAtt[unAttId];

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CXMLTag::CountAttributes
//
// Retrieves the number of pszAttributes.
//
//////////////////////////////////////////////////////////// JOEM  05-2000 //
STDMETHODIMP CXMLTag::CountAttributes(USHORT *unCount)
{
    SPDBG_FUNC( "CXMLTag::CountAttributes" );
    *unCount = (USHORT) m_apXMLAtt.GetSize();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CXMLTag::ApplyXML
//
// Applies the current XML tag to the CQuery item.
//
//////////////////////////////////////////////////////////// JOEM  06-2000 //
STDMETHODIMP CXMLTag::ApplyXML(CQuery *&rpQuery, bool &rfTTSOnly, 
                               WCHAR *&rpszRuleName, CSPArray<CDynStr,CDynStr> &raTags)
{
    SPDBG_FUNC( "CXMLTag::ApplyXML" );
    HRESULT         hr      = S_OK;
    CXMLAttribute*  xmlAtt  = NULL;
    int             iTagId  = 0;
    int             i       = 0;

    iTagId = g_unNumXMLTags;
    for ( i=0; i < g_unNumXMLTags; i++ )
    {
        if ( !wcscmp( m_dstrXMLName, XMLTags[i].pszTag ) )
        {
            iTagId = XMLTags[i].unTag;
            break;
        }
    }

    switch ( iTagId )
    {

    case BREAK:
        rpQuery->m_fSpeak = false;
        rpQuery->m_fXML = KNOWN_XML;
        rpQuery->m_fTTS = false;
        break;

    case ID:
        if ( rfTTSOnly )
        {
            hr = SPERR_XML_BAD_SYNTAX;
        }
        else 
        {
            if ( m_apXMLAtt.GetSize() == 1 && m_apXMLAtt[0]->m_dstrAttValue.Length() ) // does the attribute exist?
            {
                xmlAtt = m_apXMLAtt[0];

                if ( SUCCEEDED(hr) )
                {
                    rpQuery->m_pszId = wcsdup( xmlAtt->m_dstrAttValue );
                    xmlAtt = NULL;
                    if ( !rpQuery->m_pszId )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    rpQuery->m_fXML = KNOWN_XML;
                }
            }
            else
            {
                rpQuery->m_fSpeak = false;
                hr = SPERR_XML_BAD_SYNTAX;
            }
        }
        break;

    case TTS:
        if ( rfTTSOnly ) // nesting not allowed
        {
            hr = SPERR_XML_BAD_SYNTAX;
        }
        else 
        {
            rpQuery->m_fXML = KNOWN_XML;
            rfTTSOnly = true;
            rpQuery->m_fSpeak = FALSE;
        }
        break;

    case TTS_END:
        if ( !rfTTSOnly ) // close not allowed unless opened
        {
            hr = SPERR_XML_BAD_SYNTAX;
        }
        else 
        {
            rpQuery->m_fXML = KNOWN_XML;
            rfTTSOnly = false;
            rpQuery->m_fSpeak = FALSE;
        }
        break;

    case RULE:
        if ( rpszRuleName )
        {
            hr = SPERR_XML_BAD_SYNTAX;
        }
        else 
        {
            if ( m_apXMLAtt.GetSize() == 1 && m_apXMLAtt[0]->m_dstrAttValue.Length() ) // does the attribute exist?
            {
                xmlAtt = m_apXMLAtt[0];

                if ( SUCCEEDED(hr) )
                {
                    rpszRuleName = wcsdup( xmlAtt->m_dstrAttValue );
                    if ( !rpszRuleName )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    xmlAtt = NULL;
                }
                rpQuery->m_fXML = KNOWN_XML;
                rpQuery->m_fTTS = false;
            }
            else
            {
                rpQuery->m_fSpeak = false;
                hr = SPERR_XML_BAD_SYNTAX;
            }
        }
        break;

    case RULE_END:
        if ( !rpszRuleName ) // close not allowed unless opened
        {
            hr = SPERR_XML_BAD_SYNTAX;
        }
        else
        {
            free(rpszRuleName);
            rpszRuleName = NULL;
            rpQuery->m_fXML = KNOWN_XML;
            rpQuery->m_fTTS = false;
        }
        break;

    case WITHTAG:
        if ( m_apXMLAtt.GetSize() == 1  && m_apXMLAtt[0] ) // does the attribute exist?
        {
            xmlAtt = m_apXMLAtt[0];
			
            if ( SUCCEEDED(hr) )
            {
                raTags.Add( xmlAtt->m_dstrAttValue );
                rpQuery->m_fXML = KNOWN_XML;
                rpQuery->m_fTTS = false;
                xmlAtt = NULL;
            }
        }
        else
        {
            rpQuery->m_fSpeak = false;
            hr = SPERR_XML_BAD_SYNTAX;
        }
        break;

    case WITHTAG_END:
        if ( !raTags.GetSize() ) // close not allowed unless opened
        {
            hr = SPERR_XML_BAD_SYNTAX;
        }
        else
        {
            raTags[raTags.GetUpperBound()].dstr.Clear();
            raTags.RemoveAt( raTags.GetUpperBound() );
            rpQuery->m_fXML = KNOWN_XML;
            rpQuery->m_fTTS = false;
        }
        break;

    case DATABASE:
        if ( !m_apXMLAtt.GetSize() ) // this MUST have at least one attribute
        {
            hr = SPERR_XML_BAD_SYNTAX;
        }
        else
        {
            bool fLoadPath  = false;
            bool fLoadName  = false;
            bool fIdSet     = false;
            for ( i=0; SUCCEEDED(hr) && i < m_apXMLAtt.GetSize(); i++ )
            {
                xmlAtt = NULL;
                xmlAtt = m_apXMLAtt[i];

                if ( SUCCEEDED(hr) )
                {
                    // For ACTIVATE attribute
                    if ( wcscmp(xmlAtt->m_dstrAttName, L"ACTIVATE") == 0 )
                    {
                        rpQuery->m_unDbAction = DB_ACTIVATE;
                        rpQuery->m_pszDbName = wcsdup(xmlAtt->m_dstrAttValue);
                        if ( !rpQuery->m_pszDbName )
                        {
                            hr = E_OUTOFMEMORY;
                        }                        
                        continue;
                    }
                }
                
                if ( SUCCEEDED(hr) )
                {
                    // For UNLOAD attribute
                    if ( wcscmp(xmlAtt->m_dstrAttName, L"UNLOAD") == 0 )
                    {
                        rpQuery->m_unDbAction = DB_UNLOAD;
                        rpQuery->m_pszDbName = wcsdup(xmlAtt->m_dstrAttValue);
                        if ( !rpQuery->m_pszDbName )
                        {
                            hr = E_OUTOFMEMORY;
                        }                        
                        continue;
                    }
                }
                
                if ( SUCCEEDED(hr) )
                {
                    // For LOADPATH attribute
                    if ( wcscmp(xmlAtt->m_dstrAttName, L"LOADPATH") == 0 )
                    {
                        fLoadPath = true;
                        rpQuery->m_unDbAction = DB_ADD;
                        rpQuery->m_pszDbPath = wcsdup(xmlAtt->m_dstrAttValue);
                        if ( !rpQuery->m_pszDbPath )
                        {
                            hr = E_OUTOFMEMORY;
                        }                        
                        continue;
                    }
                }
                
                if ( SUCCEEDED(hr) )
                {
                    // For LOADNAME attribute
                    if ( wcscmp( xmlAtt->m_dstrAttName, L"LOADNAME") == 0 )
                    {
                        fLoadName = true;
                        // don't set a DbAction for LOADNAME - can't load without a path.
                        rpQuery->m_pszDbName = wcsdup(xmlAtt->m_dstrAttValue);                        
                        if ( !rpQuery->m_pszDbName )
                        {
                            hr = E_OUTOFMEMORY;
                        }                        
                        continue;
                    }
                }

                if ( SUCCEEDED(hr) )
                {
                    // For IDSET attribute
                    if ( wcscmp( xmlAtt->m_dstrAttName, L"IDSET") == 0 )
                    {
                        fIdSet = true;
                        // don't set a DbAction for IDSET - can't load without a path.
                        rpQuery->m_pszDbIdSet = wcsdup(xmlAtt->m_dstrAttValue);                        
                        if ( !rpQuery->m_pszDbIdSet )
                        {
                            hr = E_OUTOFMEMORY;
                        }                        
                        continue;
                    }
                }
            }  // for ( i=0; SUCCEEDED(hr) && i < m_apXMLAtt.GetSize(); i++ )

            if ( SUCCEEDED(hr) )
            {
                // LOADNAME and IDSET attributes require a LOADPATH
                if ( (fLoadName || fIdSet ) && !fLoadPath )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
                rpQuery->m_fXML = KNOWN_XML;
                rpQuery->m_fTTS = false;
                xmlAtt = NULL;
            }
        }
        break;

    case WAV:
        if ( m_apXMLAtt.GetSize() == 1  && m_apXMLAtt[0] ) // does the attribute exist?
        {
            xmlAtt = m_apXMLAtt[0];
            CPromptEntry* entry = NULL;
			
            if ( SUCCEEDED(hr) )
            {
                rpQuery->m_fXML = KNOWN_XML;
                rpQuery->m_fTTS = false;

                if ( !FileExist( xmlAtt->m_dstrAttValue ) )
                {
                    hr = E_ACCESSDENIED;
                }

                if ( SUCCEEDED(hr) )
                {
                    entry = new CPromptEntry;
                    if ( !entry )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if ( SUCCEEDED(hr) )
                {
                    hr = entry->SetFileName( xmlAtt->m_dstrAttValue );
                    if ( SUCCEEDED(hr) )
                    {
                        entry->SetStart( 0.0 );
                        entry->SetEnd( -1.0 );
                    }
                }

                if ( SUCCEEDED(hr) )
                {
                    rpQuery->m_apEntry.Add(entry);
                    rpQuery->m_afEntryMatch.Add(true);
                    rpQuery->m_fTTS = false;
                }

                xmlAtt = NULL;
            }
        }
        else
        {
            rpQuery->m_fSpeak = false;
            hr = SPERR_XML_BAD_SYNTAX;
        }
        break;

    default: // An unknown tag - ignore it.
        rpQuery->m_fXML = UNKNOWN_XML;
        hr = S_FALSE;
        break;

    } // switch ( iTagId )
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\engine\xmltag.h ===
//////////////////////////////////////////////////////////////////////
// XMLTag.h: interface for the CXMLTag class.
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#if !defined(AFX_XMLTAG_H__C0E43092_5FA1_4C6D_8A2E_17520B964C14__INCLUDED_)
#define AFX_XMLTAG_H__C0E43092_5FA1_4C6D_8A2E_17520B964C14__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Query.h"
#include <spddkhlp.h>
#include <spcollec.h>

//
// List of prompt engine tags
enum XML_Id
{
    BREAK,
    ID,
    TTS,
    TTS_END,
    RULE,
    RULE_END,
    WITHTAG,
    WITHTAG_END,
    DATABASE,
    WAV
};

struct XMLType
{
    XML_Id unTag;
    WCHAR* pszTag;
};

static XMLType XMLTags[] =
{
    { BREAK,        L"BREAK"   }, 
    { ID,           L"ID"       }, 
    { TTS,          L"TTS"      }, 
    { TTS_END,      L"/TTS"     }, 
    { RULE,         L"RULE"     },
    { RULE_END,     L"/RULE"    },
    { WITHTAG,      L"WITHTAG"  },
    { WITHTAG_END,  L"/WITHTAG" }, 
    { DATABASE,     L"DATABASE" },
    { WAV,          L"WAV"      },
};

const USHORT g_unNumXMLTags = sizeof(XMLTags) / sizeof(XMLTags[0]);

const int NUM_ID_ATT_NAMES = 1;
static const WCHAR* g_IDAttNames[NUM_ID_ATT_NAMES] =
{
    L"ID"
};

const int NUM_RULE_ATT_NAMES = 1;
static const WCHAR* g_RuleAttNames[NUM_RULE_ATT_NAMES] =
{
    L"NAME"
};

const int NUM_WITHTAG_ATT_NAMES = 1;
static const WCHAR* g_WithTagAttNames[NUM_WITHTAG_ATT_NAMES] =
{
    L"TAG"
};

const int NUM_DB_ATT_NAMES = 5;
static const WCHAR* g_DbAttNames[NUM_DB_ATT_NAMES] =
{
    L"LOADPATH",
    L"LOADNAME",
    L"ACTIVATE",
    L"UNLOAD",
    L"IDSET"
};

const int NUM_WAV_ATT_NAMES = 1;
static const WCHAR* g_WavAttNames[NUM_WAV_ATT_NAMES] =
{
    L"FILE"
};

class CXMLAttribute
{
public:
    CXMLAttribute() {}
    ~CXMLAttribute() { m_dstrAttName.Clear(); m_dstrAttValue.Clear(); }

    CSpDynamicString m_dstrAttName;
    CSpDynamicString m_dstrAttValue;
};


class CXMLTag  
{
public:
	CXMLTag();
	~CXMLTag();
	STDMETHOD(ParseUnknownTag)(const WCHAR* pszTag);
	STDMETHOD(ParseAttribute)(WCHAR** pszAtt);
	STDMETHOD(CheckAttribute)(WCHAR* pszAtt, WCHAR* pszAttValue);
	STDMETHOD(GetAttribute)(const USHORT unAttId, CXMLAttribute** ppXMLAtt);
	STDMETHOD(GetTagName)(const WCHAR** ppszTagName);
	STDMETHOD(CountAttributes)(USHORT* unCount);
	STDMETHOD(ApplyXML)(CQuery*& rpQuery, bool& rfTTSOnly, 
        WCHAR*& pszRuleName, CSPArray<CDynStr,CDynStr> &raTags);

private:
    CSpDynamicString m_dstrXMLName;
    CSPArray<CXMLAttribute*,CXMLAttribute*> m_apXMLAtt;

};

#endif // !defined(AFX_XMLTAG_H__C0E43092_5FA1_4C6D_8A2E_17520B964C14__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\regprompts\makefile.inc ===
RunProgram :
	$(O)\$(TARGETNAME).exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\prompts\regprompts\regprompts.cpp ===
/******************************************************************************
* RegPrompt.cpp *
*---------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 05/05/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include <windows.h>
#include "sphelper.h"
#include "spddkhlp.h"
#include <stdio.h>
#include <assert.h>
#include <spunicode.h>

const CLSID CLSID_PromptEng = {0x4BA3C5FA,0x2236,0x4EE7,{0xBA,0x28,0x1C,0x8B,0x39,0xD3,0x1D,0x48}};
const int g_iNumDbs = 2;
const int g_iNumLevelsBack = 4;

struct Confg
{
    WCHAR* voiceName;
    WCHAR* name409;
    WCHAR* contextRules;
    WCHAR* ttsVoice;
    WCHAR* promptGain;
    WCHAR* gender;
    WCHAR* age;
    WCHAR* language;
    WCHAR* vendor;
    WCHAR* rulesLang;
    WCHAR  rulesPath[MAX_PATH];
    WCHAR* dbNames[g_iNumDbs];
    WCHAR  dbPaths[g_iNumDbs][MAX_PATH];
};


static Confg g_sarahCfg = 
{
    L"MSSarah",
    L"MS Sarah",
    L"DEFAULT",
    L"TrueTalk Simon Min",
    L"1.0",
    L"Female",
    L"Adult",
    L"409;9",
    L"Microsoft",
    L"JScript",
    L"",
    {L"DEFAULT", L"TEST"},
    {L"", L""}
};


static HRESULT CreateVoiceSubKey( Confg* pConfg, bool fVendorDefault );

//-- Static 

CSpUnicodeSupport g_Unicode;
                            

/*****************************************************************************
* main  *
*-------*
*   Description:
*   Locate the abs path to prompt example database.
*   and register it in the system registry.
*       
******************************************************************* PACOG ***/
int wmain (int argc, wchar_t* argv[])
{
    HRESULT hr = S_OK;
    WCHAR szVoiceDataPath[MAX_PATH];        
    CoInitialize(NULL);

    switch (argc)
    {
    case 2:
        wcscpy (szVoiceDataPath, argv[1]);
        wcscat (szVoiceDataPath, L"\\" );
        break;
    case 1:
        //-- Get the exe's location...
        if( !g_Unicode.GetModuleFileName(NULL, szVoiceDataPath, MAX_PATH) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        //-- ...and derive abs path to VOICE and DICT data
        if( SUCCEEDED(hr) )
        {
            WCHAR *psz;
            // modulename is "<speech>\TTS\Prompts\RegPrompts\Objd\i386\RegPrompts.exe"
            // data is at "<speech>\TTS\Prompts\Voices\sw"
            for ( int i = 0; i < g_iNumLevelsBack; i++ )
            {
                psz = wcsrchr( szVoiceDataPath, '\\' );
                if (psz != 0)
                {
                    *psz= 0;
                }
                else
                {
                    hr = E_FAIL;
                    break;
                }
            }
        }

        wcscat( szVoiceDataPath, L"\\Voices\\sw\\" );
        break;

    default:
        printf ("RegPrompts [voicePath]\n");
        goto exit;
    }
    
    wcscat( wcscpy(g_sarahCfg.rulesPath, szVoiceDataPath), L"rules.js");

    wcscat( wcscpy(g_sarahCfg.dbPaths[0], szVoiceDataPath), L"prompts_main.vdb");
    wcscat( wcscpy(g_sarahCfg.dbPaths[1], szVoiceDataPath), L"prompts_test.vdb");
    
    
    //-- Register the voice
    hr = CreateVoiceSubKey(&g_sarahCfg, FALSE);

    
exit:

    CoUninitialize();

    if (FAILED(hr))
    {
        return -1;
    }

    return 0;
}


/*****************************************************************************
* CreateVoiceSubKey  *
*--------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateVoiceSubKey( Confg* pConfg, bool fVendorDefault)
{
    HRESULT hr;
    CComPtr<ISpObjectToken> cpToken;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    ISpDataKey* pRulesKey = 0;
    ISpDataKey* pDbKey = 0;

    hr = SpCreateNewTokenEx(
            SPCAT_VOICES, 
            pConfg->voiceName, 
            &CLSID_PromptEng, 
            pConfg->name409,
            0x409,
            pConfg->name409,
            &cpToken,
            &cpDataKeyAttribs);

    //Set attributes
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Name", pConfg->name409);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Gender", pConfg->gender);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Age", pConfg->age);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Vendor", pConfg->vendor);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Language", pConfg->language);
    }

    if (SUCCEEDED(hr) && fVendorDefault)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"VendorDefault", L"");
    }
    
    // Now, the string values in the main key
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetStringValue(L"TTSVoice", pConfg->ttsVoice);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetStringValue(L"PromptGain", pConfg->promptGain);
    }

    // Create rules key
    if (SUCCEEDED (hr))
    {
        hr = cpToken->CreateKey(L"PromptRules", &pRulesKey);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = pRulesKey->SetStringValue(L"ScriptLanguage", pConfg->rulesLang);
    }
    if (SUCCEEDED(hr))
    {
        hr = pRulesKey->SetStringValue(L"Path", pConfg->rulesPath);
    }
    if (pRulesKey)
    {
        pRulesKey->Release();
    }

    // Database Key
    if (SUCCEEDED(hr))
    {
        WCHAR pszKeyName[MAX_PATH];
   
        for (int i = 0; i<g_iNumDbs && SUCCEEDED(hr); i++)
        {
            swprintf(pszKeyName, L"PromptData%d", i);

            hr = cpToken->CreateKey(pszKeyName, &pDbKey);

            if (SUCCEEDED(hr))
            {
                hr = pDbKey->SetStringValue(L"Name", pConfg->dbNames[i]);
            }
            if (SUCCEEDED(hr))
            {
                hr = pDbKey->SetStringValue(L"Path", pConfg->dbPaths[i]);
            }
            
            if (pDbKey)
            {
                pDbKey->Release();
            }

        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\tools\dbconvert\dbconvert.cpp ===
/////////////////////////////////////////////////////////////////////
// DBconvert - A simple command line tool to convert between the two
//			   prompt database formats.
/////////////////////////////////////////////////////////// SS //////

#include <stdlib.h>
#include <stdio.h>
#include <atlbase.h>
#include <wchar.h>

#include "msprompteng.h"
#include "msprompteng_i.c"

void Error(const WCHAR* msg)
{
	wprintf(L"ERROR - %s\n", msg);
}

// TODO: should use multibyte text convert.
// a quick hack to convert commandline arguments to WCHAR's.
WCHAR* PlainToWide(const char* str)
{
	WCHAR* tmp;
	unsigned int i;
	tmp = (WCHAR*) malloc(sizeof(WCHAR) * (strlen(str) + 1));

	for (i = 0; i < strlen(str); i++)
		tmp[i] = (WCHAR) str[i];
	tmp[i] = 0;

	return tmp;
}

bool FileExists(WCHAR* filename)
{
	FILE* fp;
	fp = _wfopen(filename, L"rb");

	if (fp) {
		fclose(fp);
		return true;
	}
	return false;
}

void main(int argc, char** argv)
{
	IPromptDb* db;
	WCHAR* source;
	WCHAR* destination;
	HRESULT hr = E_FAIL;
	int f_convertToNew = 0;
	int f_convertToOld = 0;

	if (argc == 4) {

		// process command line arguments
		f_convertToNew = (0 == strcmp("-new", argv[1]));
		f_convertToOld = (0 == strcmp("-old", argv[1]));

		source = PlainToWide(argv[2]);
		destination = PlainToWide(argv[3]);

		// check for file existence
		if (! FileExists(source)) {
			wprintf(L"ERROR - %s doesn't exist\n", source);
		} else if (FileExists(destination)) {
			wprintf(L"ERROR - %s exists\n", destination);
		} else {
			
			if (f_convertToNew || f_convertToOld) {
				wprintf(L"Prompt Engine Database Conversion   ");
				
				if (SUCCEEDED(::CoInitialize(NULL))) {	
					if (SUCCEEDED(::CoCreateInstance(CLSID_PromptDb, NULL, CLSCTX_ALL, IID_IPromptDb, (void**) &db))) {
						
						// TODO: I should use DB_LOAD_WITH_WRITE defined in CPromptDb.

                        // I use IPromptDb directly instead of MsPromptEng, and so some enums are invisible
                        //  with simply including promptdb.h .
						if (SUCCEEDED(db->AddDb(L"DEFAULT", source, 2 /* = DB_LOAD_WITH_WRITE */))) {	// read database
							db->ActivateDbName(L"DEFAULT");
							
							wprintf(L"%s -> %s   ", source, destination);
							
							if (f_convertToNew)
								hr = db->UpdateDb(destination);					// save to new format
							else
								hr = db->UpdateDbOldFormat(destination);		// save to old format
							
							if (SUCCEEDED(hr))
								wprintf(L"success\n");
							else
								wprintf(L"failure\n");
						} else {
							Error(L"bad database format");
						}
						
						db->Release();
					} else {
						Error(L"cannot load PromptDb COM object");
					}
					
					::CoUninitialize();
				} else {
					Error(L"cannot initialize COM library");
				}
			} else {
				printf("ERROR - illegal switch \"%s\".  use \"-new\" or \"-old\".\n", argv[1]);
			}

		}

		free(source);
		free(destination);
	} else {
		// help message
		wprintf(L"DBconvert usage:\n");
		wprintf(L"dbconvert -new <source (new/old)> <destination (new)>\n");
		wprintf(L"dbconvert -old <source (new/old)> <destination (old)>\n");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\tools\filedist\main.cpp ===
/*
 *===========================================================================
 *
 * main.c
 *
 * This material contains unpublished, proprietary software of 
 * Entropic, Inc. Any reproduction, distribution, or publication
 * of this work must be authorized in writing by Entropic, Inc.,
 * and must bear the notice: 
 *
 *    "Copyright (c) 1998  Entropic, Inc. All rights reserved"
 * 
 * The copyright notice above does not evidence any actual or intended 
 * publication of this source code.     
 *
 * rcs_id: $Id: main.c,v 1.1 1999/10/12 19:44:42 galanes Exp $
 *
 *
 *
 *===================================================mplumpe 12/19/00========================
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <sigproc.h>
#include <math.h>
#include "viterbi.h"

typedef char TName[_MAX_PATH+1];

#define SYNTAX fprintf(stderr, "USAGE: fileDist file1 file2 (DTW) (DELTA:wt) (output.txt)\n\n")

double* ReadInputFile (char *fName, int *nFrames, int *frameSize);

int *FindOptimalPath (double *adOriginal, int iOrigLen, double *adSynth, int iSynthLen, int iDim);

// globals for cost functions

int giMaxShift=-1;
int giOrigLen=-1;
int giSynthLen=-1;
int giDim=-1;
double *gadOriginal=NULL;
double *gadSynth=NULL;
float *gafConcatCosts=NULL;

/*
 *-----------------------------------------------------------------------------
 *
 *  MAIN
 *
 *-----------------------------------------------------------------------------
 */
int 
main(int argc, char **argv)
{
    FILE*   output = stdout;
    TName   fName1;
    TName   fName2;
    TName   fName3 = "";
    double* data1;
    double* data2;
    int     nFrames1;
    int     nFrames2;
    int     frameSize1;
    int     frameSize2;
    double  distance = 0.0;
    int     i, j;
    int     cnt = 0;
    int     *aiOptimalPath;
    bool    fDTW = false;
    bool    fDeltaDist = false;
    double  dDeltaScale = 1.;
        
    if ( argc < 3 || argc > 6 )
    {
        SYNTAX;
        return 1;
    }
    
    strncpy (fName1, argv[1], _MAX_PATH);
    strncpy (fName2, argv[2], _MAX_PATH);
    if (argc == 4)
    {
        strncpy (fName3, argv[3], _MAX_PATH);
        if (0 == strcmp (fName3, "DTW"))
        {
            fDTW = true;
            fName3[0] = '\0';
        }
        else if (0 == strncmp (fName3, "DELTA:", 6))
        {
            fDeltaDist = true;
            fName3[0] = '\0';
            dDeltaScale = atof(fName3+6);
        }
    }
    else if (argc == 5)
    {
        if (0 == strcmp (argv[3], "DTW"))
        {
            fDTW = true;
            if (0 == strncmp (argv[4], "DELTA:", 6))
            {
                fDeltaDist = true;
                dDeltaScale = atof(argv[4]+6);
            }
            else
            {
                strncpy (fName3, argv[4], _MAX_PATH);
            }
        }
        else
        {
            if (0 == strncmp (argv[3], "DELTA:", 6))
            {
                fDeltaDist = true;
                dDeltaScale = atof(argv[3]+6);
            }
            strncpy (fName3, argv[4], _MAX_PATH);
        }
    }
    else if (argc == 6)
    {
        if (0 == strcmp (argv[3], "DTW"))
        {
            fDTW = true;
        }
        if (0 == strncmp (argv[4], "DELTA:", 6))
        {
            fDeltaDist = true;
            dDeltaScale = atof(argv[4]+6);
        }
        strncpy (fName3, argv[5], _MAX_PATH);
    }

    /*
     * read data 
     */
    
    data1 = ReadInputFile(fName1, &nFrames1, &frameSize1);
    data2 = ReadInputFile(fName2, &nFrames2, &frameSize2);
    
    if (frameSize1 != frameSize2)
    {
        fprintf(stderr, "Different data order between %s %s\n", fName1, fName2);
        return 1;
    }
    
    if (fDTW)
    {
        //
        // Find the optimal path - assumes the original is fName1
        //
        aiOptimalPath = FindOptimalPath (data1, nFrames1, data2, nFrames2, frameSize1);
    }
    else
    {
        if (nFrames2 < nFrames1)
        {
            nFrames1 = nFrames2;
        }
        aiOptimalPath = (int *)malloc (sizeof(int)*nFrames1);
        for (i=0; i < nFrames1; i++)
        {
            aiOptimalPath[i] = i;
        }
    }

    //
    // Find the distance between the optimal path & the original
    //
    if (!fDeltaDist)
    {
        for (i = 0; i < nFrames1 ; i++)
        {
            /* only use voiced segments */
            if (data1[i * frameSize1] > 0.8 || data2[aiOptimalPath[i] * frameSize2] > 0.8)
            { 
                distance += EuclideanDist(&data1[i * frameSize1], &data2[aiOptimalPath[i] * frameSize2], frameSize1);
                cnt++;
            }
        }
    }
    else // fDeltaDist
    {
        // just skip the first and last frames.  These are surely silence and don't matter anyway.
        // This makes delta calculations easier
        double *adDelta1, *adDelta2;
        adDelta1 = (double *)malloc (sizeof(double)*frameSize1);
        adDelta2 = (double *)malloc (sizeof(double)*frameSize1);
        for (i = 1; i < nFrames1-1 ; i++)
        {
            /* only use voiced segments */
            if (data1[i * frameSize1] > 0.8 || data2[aiOptimalPath[i] * frameSize2] > 0.8)
            { 
                distance += EuclideanDist(&data1[i * frameSize1], &data2[aiOptimalPath[i] * frameSize2], frameSize1);
                for (j=0; j < frameSize1; j++)
                {
                    adDelta1[j] = data1[(i+1)*frameSize1+j] - data1[(i-1)*frameSize1+j];
                    adDelta2[j] = data2[(aiOptimalPath[i]+1)*frameSize1+j] - data2[(aiOptimalPath[i]-1)*frameSize1+j];
                }
                distance += dDeltaScale * EuclideanDist(adDelta1, adDelta2, frameSize1);
                cnt++;
            }
        }
        free (adDelta1);
        free (adDelta2);
    }
    free (aiOptimalPath);
    
    if (cnt > 0)
    {
        distance /= cnt;
    }

    /*
     * write result 
     */
    if (fName3[0])
    {
        if( (output = fopen(fName3, "wt")) == NULL)
        {
            fprintf(stderr, "Can not open file %s\n", fName3);
            return 1;
        }
    }
    fprintf(output, "%f", distance);
    fclose(output);
    
    free(data1);
    free(data2);
    
    return 0;
}

/*
 *-----------------------------------------------------------------------------
 *
 * Read spectral data
 *
 *-----------------------------------------------------------------------------
 */
double *  
ReadInputFile (char *fName, int *nFrames, int *frameSize)
{
    FILE*  fp;
    int    i;
    double *data;
    int    type;
    
    if( (fp = fopen(fName, "rb")) == NULL)
    {
        fprintf(stderr, "Can not open file %s\n", fName);
        return NULL;
    }
    
    /* read header */
    fread(&type, sizeof(int), 1, fp);
    fread(frameSize, sizeof(int), 1, fp);
    fread(nFrames, sizeof(int), 1, fp);
        
    /* alloc memory */
    data = (double *)malloc((*frameSize) * (*nFrames) * sizeof(double));
    
    if (data == NULL)
    {
        fprintf(stderr, "Can not alloc memory \n");
        return NULL;
    }
    
    /* read cep data */
    for ( i = 0;  i < *nFrames;  i++ )
    {
        fread(&data[i * (*frameSize)], sizeof(double), (*frameSize), fp);
    }
    
    fclose(fp);
    
    return data;
}

float _cdecl ConcatCost (const void *pElem1, const void *pElem2, float fUnitCost)
{
    // check if it is a valid concat option
    int i1 = (int)pElem1;
    int i2 = (int)pElem2;

    if (i1 > i2)
        return 9E9f;
    else if (i2-i1 > giMaxShift)
        return 9e9f;
    else
        return fUnitCost*gafConcatCosts[i2-i1];
}
float _cdecl UnitCost (const void *pElem1, const int iOrigPos)
{
    // Just the Euclidean distance
    int iSynthPos = (int)pElem1;
    iSynthPos--;
    assert ((iOrigPos >=0) && (iOrigPos < giOrigLen));
    assert ((iSynthPos >=0) && (iSynthPos < giSynthLen));

    return (float)EuclideanDist(gadOriginal + iOrigPos * giDim, gadSynth + iSynthPos * giDim, giDim);

}


int *FindOptimalPath (double *adOriginal, int iOrigLen, double *adSynth, int iSynthLen, int iDim)
{
    //
    // Put the appropriate vectors into Viterbi, then call it
    //
    int i, j;
    CViterbi Viterbi;
    float fCost, fMidShift;
    int *aiPath;
    int iStart, iStop;

    //
    // Find ConcatCosts
    //
    giMaxShift = 2*iSynthLen/iOrigLen + 1;
    fMidShift=(float)iSynthLen/(float)iOrigLen;
    gafConcatCosts = (float *)malloc (sizeof(float)*(giMaxShift+1));
    for (i=0; i <= giMaxShift; i++)
    {
        gafConcatCosts[i] = (float )(1.f+fabs(fMidShift-i)/fMidShift);
    }
    giOrigLen = iOrigLen;
    giSynthLen = iSynthLen;
    giDim = iDim;
    gadOriginal = adOriginal;
    gadSynth = adSynth;

    Viterbi.Init (iOrigLen, 51);

    // The passed in position always must be one greater, because 0 is a special tag for the viterbi algorithm

    // Add endpoint constrants
    Viterbi.Add (0, (void *)1);
    Viterbi.Add (iOrigLen-1, (void *)iSynthLen);
    // Add one more constraint to allow delta calculation
    Viterbi.Add (1, (void *)2);
    Viterbi.Add (iOrigLen-2, (void *)(iSynthLen-1));
    // add intermediate options
    for (i=2; i <= iOrigLen-3; i++)
    {
        // for now, add in 25 frames on either side (a window of .51 seconds total) of average
        iStart = (int)(i*fMidShift-25);
        iStop = (int)(i*fMidShift+25);
        if (iStart < 0)
        {
            iStart = 0;
        }
        if (iStop > iSynthLen)
        {
            iStop=iSynthLen;
        }
        iStart += 1;
        for (j=iStart; j <= iStop; j++)
        {
            Viterbi.Add (i, (void *)j);
        }
    }
    Viterbi.FindBestPath (ConcatCost, UnitCost, &fCost);
    //
    // Best path now in void ** Viterbi.m_rgpBestElems
    //
    free (gafConcatCosts);
    aiPath = (int *)malloc (sizeof(int)*iOrigLen);
    for (i=0; i < iOrigLen; i++)
    {
        aiPath[i] = (int)(Viterbi.m_rgpBestElems[i]) - 1;
    }
    return aiPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\tools\filedist\viterbi.cpp ===
#include <stdlib.h>
#include "viterbi.h"
#include <float.h>

CPtrArray::CPtrArray()
{
  m_iSize=0;
  m_rgpv=NULL;
  m_iTop=0;
  m_iGrow=10;
}

CPtrArray::~CPtrArray()
{
  if (m_rgpv)
    free (m_rgpv);
}

void CPtrArray::SetSize(int iSize, int iGrowSize)
{
  if (iSize > m_iSize)
  {
    m_rgpv = (void **)realloc (m_rgpv, iSize*sizeof(void *));
    m_iSize = iSize;
  }
  if (0 < iGrowSize)
    m_iGrow = iGrowSize;
  else
    m_iGrow = 10;
}

int CPtrArray::Add(void *pElem)
{
  if (m_iTop >= m_iSize)
  {
    m_iSize += m_iGrow;
    m_rgpv = (void **)realloc (m_rgpv, m_iSize*sizeof(void *));
  }
  m_rgpv[m_iTop] = pElem;
  return (m_iTop++);
}
/*
void *CPtrArray::Get(int iElem)
{
  if ((iElem >= m_iTop) || (iElem < 0))
    return NULL;
  return m_rgpv[iElem];
}
*/
/*
__inline int CPtrArray::GetSize()
{
  return m_iSize;
}
*/
CViterbi::CViterbi ()
{
  m_fPruneLevel = 0.f;
  m_pConcatCostFunction = NULL;
  m_pUnitCostFunction = NULL;
  m_rgpBestElems = NULL;
  m_rgpElemArray = NULL;
  m_iLen = 0;
}

CViterbi::~CViterbi ()
{
  int i;
  for (i=0; i < m_iLen; i++)
    delete m_rgpElemArray[i];
  if (m_rgpElemArray)
    free (m_rgpElemArray);
  if (m_rgpBestElems)
    free (m_rgpBestElems);
}

int CViterbi::Init (int iLen, int iInitialDepth, int iGrowSize)
{
  int i;

  m_iLen = iLen;
  if (NULL == (m_rgpElemArray = (CPtrArray **)malloc (sizeof (CPtrArray*)*m_iLen)))
    return -1;
  for (i=0; i < m_iLen; i++)
  {
    m_rgpElemArray[i] = new CPtrArray;
    if (NULL == m_rgpElemArray[i])
    {
      m_iLen = i;
      return -1;
    }
    m_rgpElemArray[i]->SetSize (iInitialDepth, iGrowSize);
  }
  return 0;
}

int CViterbi::Add (int iPos, void *pElem)
{
  if ((iPos > m_iLen) || (iPos < 0))
    return -1;
  m_rgpElemArray[iPos]->Add(pElem);
  return 0;
}

int CViterbi::FindBestPath(ConcatCostFn pConcatCostFunction, UnitCostFn pUnitCostFunction, float *pfCost)
{
  if (pConcatCostFunction)
    m_pConcatCostFunction = pConcatCostFunction;
  if (pUnitCostFunction)
    m_pUnitCostFunction = pUnitCostFunction;

  float **rgrgfCosts=NULL, *rgfBuf=NULL;
  int **rgrgiBestLeft=NULL, *rgiBuf=NULL;
  int iMaxLen, iLLen, iRLen, iTotalLen, iPos, iLElem, iRElem, iBestElem, iTempLen;
  float fCost, fUnitCost;
  int iRet=-1;
  iMaxLen = m_rgpElemArray[0]->GetUsed();
  iRLen = iMaxLen;
  if (0 == iMaxLen)
    iMaxLen=1;
  iTotalLen = iMaxLen;
  for (iPos=1; iPos < m_iLen; iPos++)
  {
    iTempLen = m_rgpElemArray[iPos]->GetUsed();
    if (0 == iTempLen)
      iTempLen=1;
    if (iTempLen > iMaxLen)
      iMaxLen = iTempLen;
    iTotalLen += iTempLen;
  }
  rgfBuf = (float *)calloc (iTotalLen, sizeof (float));
  rgiBuf = (int *)calloc (iTotalLen, sizeof(int));
  iTotalLen=0;
  rgrgfCosts = (float **)malloc (m_iLen * sizeof (float*));
  rgrgiBestLeft = (int **)malloc (sizeof (int)*m_iLen);
  if ((NULL == rgrgfCosts) || (NULL == rgfBuf) || (NULL == rgrgiBestLeft) || (NULL == rgiBuf))
    goto Err;
  rgrgfCosts[0] = rgfBuf+iTotalLen;
  rgrgiBestLeft[0] = rgiBuf+iTotalLen;
  if (0 == iRLen)
    iTotalLen++;
  else
    iTotalLen += iRLen;
  for (iLElem=0; iLElem < iRLen; iLElem++)
    if (NULL != (*m_rgpElemArray[0])[iLElem])
      rgrgfCosts[0][iLElem] = m_pUnitCostFunction((*m_rgpElemArray[0])[iLElem],0);
  for (iPos=1; iPos < m_iLen; iPos++)
  {
    iLLen = iRLen;
    iRLen = m_rgpElemArray[iPos]->GetUsed();
    rgrgfCosts[iPos] = rgfBuf+iTotalLen;
    rgrgiBestLeft[iPos] = rgiBuf+iTotalLen;
    if (0 == iRLen)
      iTotalLen++;
    else
      iTotalLen += iRLen;
    for (iRElem=0; iRElem < iRLen; iRElem++)
    {
      rgrgfCosts[iPos][iRElem] = FLT_MAX;  // much bigger than any potential cost.
      fUnitCost = m_pUnitCostFunction((*m_rgpElemArray[iPos])[iRElem],iPos);
      for (iLElem=0; iLElem < iLLen; iLElem++)
      {
        if (NULL != (*m_rgpElemArray[iPos-1])[iLElem])
        {
          fCost = m_pConcatCostFunction((*m_rgpElemArray[iPos-1])[iLElem],
                                        (*m_rgpElemArray[iPos])[iRElem], fUnitCost) +
                  rgrgfCosts[iPos-1][iLElem];// + fUnitCost;
                  
          if (fCost <= rgrgfCosts[iPos][iRElem])
          {
            rgrgfCosts[iPos][iRElem]   = fCost;
            rgrgiBestLeft[iPos][iRElem] = iLElem;
          }
        }
        // else it was pruned earlier
      }
      if ((0.f != m_fPruneLevel) && (rgrgfCosts[iPos][iRElem] > m_fPruneLevel))
        (*m_rgpElemArray[iPos])[iRElem] = NULL;
    }
  }

  *pfCost = 0.f;
  fCost = rgrgfCosts[m_iLen-1][0];
  iBestElem = 0;
  for (iRElem=1; iRElem < iRLen; iRElem++)
    if (rgrgfCosts[m_iLen-1][iRElem] < fCost)
    {
      iBestElem = iRElem;
      fCost = rgrgfCosts[m_iLen-1][iRElem];
    }
  m_rgpBestElems = (void **)calloc (m_iLen, sizeof (void *));
  if (NULL == m_rgpBestElems)
    goto Err;
  if (iBestElem >= m_rgpElemArray[m_iLen-1]->GetUsed())
    m_rgpBestElems[m_iLen-1] = NULL;
  else
  {
    m_rgpBestElems[m_iLen-1] = (*m_rgpElemArray[m_iLen-1])[iBestElem];
    *pfCost = fCost;
  }
  for (iPos=m_iLen-2; iPos >= 0; iPos--)
  {
    if (0 == m_rgpElemArray[iPos+1]->GetUsed())
    {
      iRLen = m_rgpElemArray[iPos]->GetUsed();
      fCost = rgrgfCosts[iPos][0];
      for (iRElem=1; iRElem < iRLen; iRElem++)
        if (rgrgfCosts[iPos][iRElem] < fCost)
        {
          iBestElem = iRElem;
          fCost = rgrgfCosts[iPos][iRElem];
        }
    }
    else
      iBestElem = rgrgiBestLeft[iPos+1][iBestElem];
    if (iBestElem >= m_rgpElemArray[iPos]->GetUsed())
      m_rgpBestElems[iPos] = NULL;
    else
    {
      m_rgpBestElems[iPos] = (*m_rgpElemArray[iPos])[iBestElem];
      if (0 == *pfCost)
        *pfCost = fCost;
    }
  }

  iRet = 0;
Err:
  if (rgrgfCosts)
    free (rgrgfCosts);
  if (rgfBuf)
    free (rgfBuf);
  if (rgrgiBestLeft)
    free (rgrgiBestLeft);
  if (rgiBuf)
    free (rgiBuf);
  return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\backendint.h ===
/******************************************************************************
* BackendInt.h *
*--------------*
*  Internal defs for Backend
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/
#ifndef __BACKENDINT_H_
#define __BACKENDINT_H_

#include "backend.h"

#include <vector>
struct Epoch;
struct NewF0Struct;

class CSynth 
{
    friend class COlaBuf;
    friend class CSpeakerData;

    public:
        CSynth();
        ~CSynth();

        int  LpcAnalysis (int iSampFreq, int iOrder);
        int  FindPrecedent ();
        void GetNewF0 (std::vector<NewF0Struct>* pvNewF0, double* pdTime, double* pdRunTime );

    protected:
        double* GetDurbinCoef(double* data, int nData);
        void FreeLpcCoef();

        // Read from the input files 
        double  m_dRunTimeLimit;
        double  m_dGain;          // Gain to aply to the whole segment

        // Read from the database 
        int     m_iNumSamples;
        double* m_pdSamples;
        int     m_iNumEpochs;
        Epoch*  m_pEpochs;

        // Computed for synthesis 
        double* m_pdSynEpochs;    // Synthesis epoch track
        int*    m_piMapping;  
        double* m_pdGainVect;
        int     m_iNumSynEpochs;

        // For lpc synthesis
        double** m_ppdLpcCoef;
        int      m_iLpcOrder;
};


class COlaBuf
{
    public:
        COlaBuf(bool fRtips = false);
        ~COlaBuf();

        int  Init ( int sampFreq);
        int  FillBuffer ( CSynth* unit, int periodNum, double gain);
        int  NextPeriod (int periodLen, double** samples);

    private:
        enum {WindowFirstHalf, WindowSecondHalf};
        static const double m_iDefaultPeriod;

        int  GetWindowedSignal (int whichBuffer, int periodLength, double** windowed, int* nWindowed);
        void HalfHanning (double* x, int xLen, double ampl, int whichHalf);

        struct CBuffer {
            double* m_pdSamples;
            int     m_iNumSamples;
            int     m_iCenter;
            double  m_dDelay;
        } m_aBuffer[2];

        int  m_iSampFreq;
        bool m_fRtips;
        // How to dither unvoiced regions 
        int  m_iRepetitions;
        int  m_iInvert;
};


class CTips
{
    public:
        static enum {LpTips = 1, RTips= 2};

        virtual ~CTips() {};

        virtual void Init (int iSampFormat, int iSampFreq) = 0;
        virtual void SetGain (double dGain) = 0;

        virtual void NewSentence    (float* pfF0, int iNumF0, int iF0SampFreq) = 0;
        virtual int  SynthesizeUnit (CSynth* pUnit, short** ppnSamples, int* piNumSamples) = 0;

        static CTips* ClassFactory(int iOptions);
};

        

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\backend.h ===
/******************************************************************************
* Backend.h *
*-----------*
*  Backend interface definition
*------------------------------------------------------------------------------
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef __BACKEND_H_
#define __BACKEND_H_

#define PHONE_MAX_LEN 10
#define CHUNK_NAME_MAX_LEN 1024

struct Phone 
{
    char   phone[PHONE_MAX_LEN];
    short  f0;  //Average f0;
    int    isWordEnd;
    double end; 
};

struct ChkDescript
{
    char  name[ CHUNK_NAME_MAX_LEN ];
    double end;
    double from;
    double to;
    double gain;
    double targF0;
    double srcF0;
    double f0Ratio;
    union {
        int chunkIdx;
        const char*  fileName;
    } chunk;
    int isFileName;
};

class CSynth;

class CSlm
{
    public:
        static enum {UseGain=1, Blend= 2, DynSearch= 4, UseTargetF0= 8};

        virtual ~CSlm() {};

        virtual int   Load (const char *pszFileName, bool fCheckVersion) = 0;
        virtual void  Unload () = 0;

        virtual bool  GetSynthMethod() = 0;
        virtual int   GetSampFreq () = 0;
        virtual int   GetSampFormat () = 0;
        virtual bool  GetPhoneSetFlag () = 0;
        virtual void  SetFrontEndFlag () = 0;

        virtual void  SetF0Weight      (float fWeight) = 0;
        virtual void  SetDurWeight     (float fWeight) = 0;
        virtual void  SetRmsWeight     (float fWeight) = 0;
        virtual void  SetLklWeight     (float fWeight) = 0;
        virtual void  SetContWeight    (float fWeight) = 0;
        virtual void  SetSameSegWeight (float fWeight) = 0;
        virtual void  PreComputeDist() = 0;
        virtual void  CalculateF0Ratio () = 0;
        virtual void  GetNewF0 (float** ppfF0, int* piNumF0, int iF0SampFreq) = 0;

        virtual void  GetTtpParam (int* piBaseLine, int* piRefLine, int* piTopLine) = 0;

        virtual int   Process (Phone* phList, int nPh, double startTime) = 0;

        virtual CSynth* GetUnit (int iUnitIndex) = 0;
        virtual ChkDescript* GetChunk (int iChunkIndex) = 0; //For command line slm

        static CSlm* ClassFactory (int iOptions);
};

class CBackEnd {
    public:
        virtual ~CBackEnd() {};

        virtual int  LoadTable (const char* pszFilePath, int iDebug = 0) = 0;
        virtual int  GetSampFreq () = 0;
        virtual void SetGain (double dGain)= 0;
        virtual void SetF0SampFreq(int iF0SampFreq) = 0;
        virtual int  NewPhoneString (Phone* pPhList, int iNumPh, float* pfNewF0, int iNumNewF0) = 0;
        virtual int  OutputPending () = 0;
        virtual int  GenerateOutput (short** ppnSamples, int* piNumSamples) = 0;
        virtual int  GetChunk (ChkDescript** ppChunk) = 0;

        virtual void GetSpeakerInfo (int* piBaseLine, int* piRefLine, int* piTopLine) = 0;
        virtual bool GetPhoneSetFlag () = 0;
        virtual void SetFrontEndFlag () = 0;

        static  CBackEnd* ClassFactory();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\tools\usearch\usearch.cpp ===
/******************************************************************************
* usearch.cpp *
*-------------*
*  I/O library functions for extended speech files (vapi format)
*------------------------------------------------------------------------------
*  Copyright (C) 1997 Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998 Entropic, Inc.
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/21/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "backend.h"
#include "beVersion.h"
#include "getopt.h"
#include <ctype.h>
#include <math.h>
#include <malloc.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#define SYNTAX fprintf(stderr,\
 "Usage:\nusearch [-f f0wght] [-d durwght] [-r rmswght] [-l lklwght] [-c contwght]\n\
 \t[-m SameSegWght] [-s (dynsearch)] [-b (blend)] [-g (gain)] \n\
 \t[-t (targetF0)] [-x cros_ref] [-S script_file] table_file \n\
 \t[ifile] [ofile]\n")


#define MAX_LINE  128
#define MAX_SENT_PHONES 500
#define CHUNK_ALLOC_INCR 1000

enum {
    GOT_F0_WEIGHT=1, 
    GOT_RMS_WEIGHT=2, 
    GOT_DUR_WEIGHT=4, 
    GOT_LKLH_WEIGHT=8, 
    GOT_CONT_WEIGHT=16, 
    GOT_SAME_WEIGHT=32 
};

/*
 *
 */
struct NamePair {
    char in[_MAX_PATH+1];
    char out[_MAX_PATH+1];
};

class Crf 
{
    public: 
        Crf();
        ~Crf();
        int Load (const char* fileName);

        const char* FileName(int i);
        double Offset (int i);

    private:
        struct CrfInfo {
            char* fileName;
            double offset;
        } *m_pChunks;
        int m_iNumChunks;
        int m_iNumAlloc;
};


struct InputInfo {
    char tableFile[_MAX_PATH+1];
    char crfFile[_MAX_PATH+1];
    char scriptFile[_MAX_PATH+1];
    char input[_MAX_PATH+1];
    char output[_MAX_PATH+1];
    int  slmOptions;
    float f0Wt;
    float durWt;
    float rmsWt;
    float lklWt;
    float contWt;
    float sameSeg;
    int   setWeights;
};

/*
 *
 */
static int ProcessCommandLine (int argc, char *argv[], InputInfo* inInfo);

static int GetIoNames (InputInfo* inInfo, NamePair** names, int* nNames);

static int ReadScriptLine (FILE* script, char* inFile, char* outFile);

static int OpenInputFile (const char* fileName, FILE** fp, double *time);

static int OpenOutputFile (const char* fileName, double startTime, FILE** fp);

static int GetInputPhone (FILE* fp, double* time, char* phone, short* f0, int* sentenceEnd);

/*****************************************************************************
* main *
*------*
*   Description:
*       
******************************************************************* PACOG ***/
int main (int argc, char *argv[])
{
    InputInfo inInfo;

    CSlm* slm = 0;
    Crf crf;

    NamePair* fileNames = 0;
    int nFiles = 0;
    int fileCount;

    FILE *fin;
    FILE *fout;

    Phone phList[MAX_SENT_PHONES];
    int nPh;
    
    ChkDescript* newChunk = 0;
    int nNewChunks = 0;
    
    double startTime;
    double fTo;
    double fFrom;
    int    sentenceEnd;
    const char*  fName;
    int i;
        
    
    if (!ProcessCommandLine (argc, argv, &inInfo)) 
    {
        SYNTAX;
        return 1;
    }

    if (!GetIoNames (&inInfo, &fileNames, &nFiles))
    {
        fprintf (stderr, "Error loading input and output file names\n");
        return 1;
    }
    
    if ( (slm = CSlm::ClassFactory(inInfo.slmOptions)) == 0) 
    {
        return 1;
    }
    
    if (!slm->Load(inInfo.tableFile, 1)) 
    {
        fprintf(stderr, "Error loading speaker info %s\n", inInfo.tableFile);
        return 1;
    }
    
    if (inInfo.setWeights & GOT_F0_WEIGHT) 
    {
        slm->SetF0Weight( inInfo.f0Wt );
    }
    if (inInfo.setWeights & GOT_DUR_WEIGHT) 
    {
        slm->SetDurWeight( inInfo.durWt );
    }
    if (inInfo.setWeights & GOT_RMS_WEIGHT) 
    {
        slm->SetRmsWeight( inInfo.rmsWt );
    }
    if (inInfo.setWeights & GOT_LKLH_WEIGHT) 
    {
        slm->SetLklWeight( inInfo.lklWt );
    }
    if (inInfo.setWeights & GOT_CONT_WEIGHT) 
    {
        slm->SetContWeight( inInfo.contWt );
    }
    if (inInfo.setWeights & GOT_SAME_WEIGHT) 
    {
        slm->SetSameSegWeight( inInfo.sameSeg );
    }

    /*
     * If we override the weights, we need to
     * precompute the distances again 
     * (done by default within Slm_Load())
     */
    if (inInfo.setWeights) 
    {
        slm->PreComputeDist();
    }
    
/*    if (Slm_GetFileName(slm, 0) == 0 && inInfo.crfFile[0]=='\0') 
    {
        fprintf(stderr, "Error: Either use a table with file names or provide cross_ref file\n");
        return 1;
    }
  */
    
    if ( inInfo.crfFile[0] && !crf.Load(inInfo.crfFile) ) 
    {
        printf("Error opening CRF file %s\n", inInfo.crfFile);
        return 1;
    }
    

    for (fileCount = 0; fileCount < nFiles; fileCount ++)
    {
        fprintf (stdout, "%s %s\n", fileNames[fileCount].in, fileNames[fileCount].out);
        fflush (stdout);


        if (!OpenInputFile(fileNames[fileCount].in, &fin, &startTime)) 
        {
            printf("Error opening input file %s\n", fileNames[fileCount].in);
            return 1;
        }
        
        if (!OpenOutputFile(fileNames[fileCount].out, startTime, &fout)) 
        {
            printf("Error opening output file %s\n", fileNames[fileCount].out);
            return 1;
        }
        
        nPh = 0;
        while (GetInputPhone(fin, &phList[nPh].end, phList[nPh].phone, &phList[nPh].f0, &sentenceEnd)) 
        {
            nPh++;

            if ( sentenceEnd && (nPh>1))
            {
                if ((nNewChunks = slm->Process (phList, nPh, startTime)) == 0)
                {
                    fprintf (stderr, "Slm error while processing %s\n", fileNames[fileCount].in);
                    break;
                }
                startTime = phList[nPh-1].end;
                
                // Print results of slm Search 
                
                for (i=0; i<nNewChunks; i++) 
                {
                    newChunk = slm->GetChunk(i);                    

                    fFrom = newChunk->from;
                    fTo   = newChunk->to;
                    
                    if (newChunk->isFileName) 
                    {
                        fName = newChunk->chunk.fileName;
                    }
                    else 
                    {
                        fName  = crf.FileName(newChunk->chunk.chunkIdx);
                        fFrom += crf.Offset(newChunk->chunk.chunkIdx);
                        fTo   += crf.Offset(newChunk->chunk.chunkIdx);
                    }
                    fprintf(fout,"%f %s %s %lf %lf %f\n", 
                        newChunk->end, newChunk->name, fName, fFrom, fTo, newChunk->gain);
                }
                
                nPh=0;
            }
        } 
        
        fclose(fin);
        fclose(fout);
    } 
    
    if (fileNames)
    {
        free (fileNames);
    }    
        
    delete slm;

    return 0;
}


/*****************************************************************************
* Crf::Crf *
*----------*
*   Description:
*       
******************************************************************* PACOG ***/
Crf::Crf ()
{
    m_pChunks    = 0;
    m_iNumChunks = 0;
    m_iNumAlloc  = 0;
}

/*****************************************************************************
* Crf::~Crf *
*-----------*
*   Description:
*       
******************************************************************* PACOG ***/
Crf::~Crf ()
{
    if (m_pChunks) 
    {
        for (int i=0; i<m_iNumChunks; i++) 
        {
            if (m_pChunks[i].fileName) 
            {
                free (m_pChunks[i].fileName);
            }
        }
        free (m_pChunks);
    }
}

/*****************************************************************************
* Crf::FileName *
*---------------*
*   Description:
*       
******************************************************************* PACOG ***/
const char* Crf::FileName(int i)
{
    return m_pChunks[i].fileName;
}

/*****************************************************************************
* Crf::Offset *
*-------------*
*   Description:
*       
******************************************************************* PACOG ***/
double Crf::Offset (int i)
{
    return m_pChunks[i].offset;
}

/*****************************************************************************
* Crf::Load *
*-----------*
*   Description:
*       Load the cross reference file into the chunk cross reference structure        
******************************************************************* PACOG ***/
int Crf::Load (const char *fileName)
{
    BendVersion bev;
    FILE*  fp;
    int    chunkIdx;
    char   file[_MAX_PATH+1];
    double offset;
     
    if ((fp = fopen (fileName,"r")) == 0) 
    {
        fprintf(stderr,"Can not open file %s\n", fileName);
        return 0;
    }
     
    if (!bev.CheckVersionString (fp)) 
    {
        fprintf (stderr, "Incompatible cross-reference file\n");
        return 0;
    }        
        
    while (fscanf(fp,"%d %s %lf",&chunkIdx, file ,&offset)==3) 
    {
        if (chunkIdx != m_iNumChunks) 
        {
            fprintf(stderr, "Error loading chunk list from cross ref file\n");
            return 0;
        }
        
        if (m_iNumChunks == m_iNumAlloc) 
        {
            if (m_pChunks) 
            {
                m_pChunks = (CrfInfo* )realloc (m_pChunks, (m_iNumAlloc + CHUNK_ALLOC_INCR) * sizeof (*m_pChunks));
            }
            else 
            {
                m_pChunks = (CrfInfo* )malloc (CHUNK_ALLOC_INCR * sizeof (*m_pChunks));
            }
            
            if (m_pChunks == 0) 
            {
                fprintf(stderr,"Out of Memory\n");
                return 0;
            }
            m_iNumAlloc += CHUNK_ALLOC_INCR;
        }
        
        if ( (m_pChunks[m_iNumChunks].fileName = strdup (file)) == 0) 
        {
            fprintf(stderr,"Out of Memory\n");
            return 0;
        }
        m_pChunks[m_iNumChunks].offset  = offset;
        m_iNumChunks++;
    }
    
    fclose(fp);
    
    return 1;
}
/*****************************************************************************
* OpenOutputFile *
*----------------*
*   Description:
*       
******************************************************************* PACOG ***/
int OpenOutputFile (const char* fileName, double startTime, FILE** fp)
{
    char str[40];
    
    assert (fp);
    
    if (fileName) 
    {
        if (strcmp(fileName,"-")==0) 
        {
            *fp = stdout;
        }
        else 
        {
            *fp = fopen (fileName, "w");
            if (*fp==0) 
            {
                return 0;
            }
        }
    } 
    else 
    {
        *fp = 0;
    }
    
    sprintf (str, "#%f\n", startTime);
    if (*fp) 
    {
        fprintf (*fp, str);
    }
    else 
    {
        printf("%s\n",str);
    }
    
    return 1;
}
/*****************************************************************************
* OpenInputFile *
*---------------*
*   Description:
*       
******************************************************************* PACOG ***/
int OpenInputFile (const char* fileName, FILE** fp, double *time)
{
    char line[MAX_LINE+1];
    char *ptr;
    
    assert (fileName);
    assert (fp);
    assert (time);
    
    *fp = fopen (fileName, "r");
    if (*fp==0) 
    {
        return 0;
    }
    
    // Jump over the header
    do 
    {
        if (!fgets(line, MAX_LINE, *fp)) 
        {
            return 0;
        }
        
        ptr= line;
        while (*ptr==' ' || *ptr=='\t') 
        {
            ptr++;
        }
    } 
    while (*ptr!='#');
    
    if ( sscanf(ptr+1, "%lf", time)!= 1) 
    {
        *time = 0.0;
    }
    
    
    return 1;
}


/*****************************************************************************
* GetInputPhone  *
*----------------*
*   Description:
*        sentenceEnd is used to judge sentence final in cmdl slm
******************************************************************* PACOG ***/

int GetInputPhone (FILE* fp, double* time, char* phone, short* f0, int* sentenceEnd) 
{
    char line[MAX_LINE+1];
    char *ptr;
    double mark;
    
    assert (fp);
    assert (time);
    assert (phone);
    assert (f0);
    
    while (fgets(line, MAX_LINE, fp)) 
    {        
        ptr = line;
        
        while (*ptr && isspace (*ptr)) 
        {
            ptr++;
        }
        
        if (!*ptr || *ptr=='#') {
            /*
             * Allows for embeded comments
             */
            continue; 
        }    
        
        mark = -1.0;
        if (sscanf (ptr, "%lf %*s %s %d %lf", time, phone, f0, &mark)!=4) 
        {
            if (sscanf (ptr, "%lf %*s %s %d", time, phone, f0)!=3) 
            {
                printf("Error in line %s\n",line);
                return 0;
            }
        }
        
        if (phone[strlen(phone)-1] == ';') 
        {
            phone[strlen(phone)-1] = '\0';
        }
        
        if (strcmp(phone, "sp")==0 || strcmp(phone, "SIL") == 0) 
        {
            strcpy(phone,"sil");
        }
        
        *sentenceEnd = (mark == 0.0);

        return 1;
    }
    
    return 0;
}


/*****************************************************************************
* ReadScriptLine *
*----------------*
*   Description:
*        read Input/output from a script file
******************************************************************* PACOG ***/

int ReadScriptLine (FILE* script, char* inFile, char* outFile) 
{
    char line[MAX_LINE+1];
    char *ptr;
    
    assert (script);
    
    while (fgets(line, MAX_LINE, script)) 
    {        
        if (ptr = strchr (line, '#')) 
        {
            *ptr = '\0';
        }
        ptr = line;
        
        while (*ptr && isspace (*ptr)) 
        {
            ptr++;
        }
        
        if (!*ptr ) 
        {
            continue; 
        }    
        
        if (sscanf (ptr, "%s %s", inFile, outFile) != 2) 
        {
            fprintf(stderr,"Error: reading script file at \n\t %s\n",ptr);
            return 0;
        }
        return 1;
    }
    
    return 0;
}

/*****************************************************************************
* GetIoNames *
*------------*
*   Description:
*       
******************************************************************* PACOG ***/

int GetIoNames (InputInfo* inInfo, NamePair** names, int* nNames)
{
    FILE *script;

    assert (inInfo);
    assert (names);
    assert (nNames);

    if (inInfo->scriptFile[0]) 
    {
        if ((script = fopen(inInfo->scriptFile,"r")) == 0 )
        {
            fprintf(stderr, "Error: Could not open scriptFile %s\n", inInfo->scriptFile);
            return 1;
        }
        else 
        {
            while (ReadScriptLine(script, inInfo->input, inInfo->output)) 
            {
                if (*names) 
                {
                    *names = (NamePair*)realloc (*names, (*nNames + 1) * sizeof(**names));
                }
                else 
                {
                    *names = (NamePair*)malloc (sizeof(**names));
                }

                if (*names == 0)
                {
                    return 0;
                }


                strcpy((*names)[*nNames].in,  inInfo->input);
                strcpy((*names)[*nNames].out, inInfo->output);

                (*nNames)++;
            }
        }
    }
    else 
    {
        if ((*names = (NamePair*)malloc (sizeof(**names))) == 0) 
        {
            return 0;
        }
        strcpy((*names)[0].in,  inInfo->input);
        strcpy((*names)[0].out, inInfo->output);
        *nNames = 1;
    }

    return 1;
}


/*****************************************************************************
* ProcessCommandLine *
*--------------------*
*   Description:
*       
******************************************************************* PACOG ***/

int ProcessCommandLine (int argc, char *argv[], InputInfo* inInfo)
{
    CGetOpt getOpt;
    int optIdx;
    int ch;
    
    assert (argv);
    assert (argc>0);
    assert (inInfo);   

    memset (inInfo, 0, sizeof(*inInfo));
    
    getOpt.Init (argc, argv, "bstgf:d:r:l:c:x:m:S:");


    while ((ch = getOpt.NextOption()) != EOF) 
    {
        switch (ch) 
        {
        case 'b':
            inInfo->slmOptions |= CSlm::Blend;
            break;
        case 's':
            inInfo->slmOptions |= CSlm::DynSearch;
            break;
        case 't':
            inInfo->slmOptions |= CSlm::UseTargetF0;
            break;
        case 'g':
            inInfo->slmOptions |= CSlm::UseGain;
            break;
        case 'f':
            inInfo->f0Wt = (float) atof (getOpt.OptArg());
            inInfo->setWeights |= GOT_F0_WEIGHT;
            break;
        case 'd':
            inInfo->durWt = (float) atof (getOpt.OptArg());
            inInfo->setWeights |= GOT_DUR_WEIGHT;
            break;
        case 'r':
            inInfo->rmsWt = (float) atof (getOpt.OptArg());
            inInfo->setWeights |= GOT_RMS_WEIGHT;
            break;
        case 'l':
            inInfo->lklWt = (float) atof (getOpt.OptArg());
            inInfo->setWeights |= GOT_LKLH_WEIGHT;
            break;
        case 'm':
            inInfo->sameSeg = (float) atof (getOpt.OptArg());
            inInfo->setWeights |= GOT_SAME_WEIGHT;
            break;
        case 'c':
            inInfo->contWt = (float) atof (getOpt.OptArg());
            inInfo->setWeights |= GOT_CONT_WEIGHT;
            break;
        case 'x':
            strncpy (inInfo->crfFile, getOpt.OptArg(), _MAX_PATH);
            break;
        case 'S':
            strncpy (inInfo->scriptFile, getOpt.OptArg(), _MAX_PATH);
            break;
        default:
            return 0;
        }
    }
    
    optIdx = getOpt.OptInd();

    if ((argc - optIdx) < 1) 
    {
        return 0;
    }
    else 
    {
        strcpy(inInfo->tableFile,argv[optIdx++]);
    }
    
    if (inInfo->scriptFile[0]) 
    {
        if (argc-optIdx) 
        {
            printf("Using script file for I/O and ignoring the input file argument\n");
            return 1;
        }
        else 
        {
            return 1;
        }
    }
    
    if (argc-optIdx) 
    {
        strcpy(inInfo->input,argv[optIdx++]);
    }
    
    if (argc-optIdx) 
    {
        strcpy(inInfo->output,argv[optIdx++]);
        if (argc-optIdx) 
        {
            return 0;
        }
    } 
    else 
    {
        strcpy(inInfo->output,"-");
    }
    
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\tools\filedist\viterbi.h ===
#ifndef __VITERBI__
#define __VITERBI__
#include <assert.h>
typedef float (_cdecl *ConcatCostFn) (const void *pElem1, const void *pElem2, float fUnitCost);
typedef float (_cdecl *UnitCostFn) (const void *pElem1, const int iPos);


class CPtrArray
{
private:
  int m_iSize;
  int m_iTop;
  int m_iGrow;
  void **m_rgpv;
public:
  CPtrArray();
  ~CPtrArray();
  int Add(void *pElem);
  void *Get(int iElem) const {if ((iElem >= m_iTop) || (iElem < 0)) return NULL;
                        return m_rgpv[iElem];}
  void *&ElementAt(int iElem) {assert((iElem < m_iTop) && (iElem >= 0));
                        return m_rgpv[iElem];}
  int GetSize() {return m_iSize;}
  int GetUsed() {return m_iTop;}
  void SetSize(int iSize, int iGrowSize=-1);
  void *operator[](int iElem) const {return Get(iElem);}
  void *&operator[](int iElem) {return ElementAt(iElem);}
};

class CViterbi
{
public:
  CViterbi();
  ~CViterbi();
  int Init (int iLen, int iInitialDepth, int iGrowSize=-1);
  int Add (int iPos, void *pElem);
  int FindBestPath (ConcatCostFn pConcatCostFunction, UnitCostFn pUnitCostFunction, float *pfCost);

  float          m_fPruneLevel;
  ConcatCostFn   m_pConcatCostFunction;
  UnitCostFn     m_pUnitCostFunction;
  void         **m_rgpBestElems;
private:
  int      m_iLen;
  CPtrArray **m_rgpElemArray;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\beversion.cpp ===
/******************************************************************************
* BeVersion.cpp *
*---------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "BeVersion.h"
#include <stdlib.h>
#include <string.h>
#include <assert.h>

const char * const BendVersion::pszVersion = "2.3.0";

/*****************************************************************************
* BendVersion::WriteVersionString *
*---------------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
  
void BendVersion::WriteVersionString( FILE* fp)
{
    assert (fp);
    
    if (fp ) 
    {
        fprintf (fp, "%s\n", pszVersion);
    }
}

/*****************************************************************************
* BendVersion::CheckVersionString *
*---------------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
  
bool BendVersion::CheckVersionString( FILE* fp)
{
    char str[_MAX_PATH+1];
    char* ptr;

    assert (fp);
  
    if (fp && fgets(str, _MAX_PATH, fp)) 
    {                
        ptr = (str + strlen(str)-1); // Strip last carriage return
        if ( *ptr == '\n') 
        {
            *ptr = '\0';
        }

        if (strcmp(str, pszVersion) == 0) 
        {
            return true;
        }
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\tools\tsm\tsmain.cpp ===
//==========================================================================
//
// tsmain.cpp --
// 
// 	Copyright (c) 2000 Microsoft, Corp.
// 	Copyright (c) 1998 Entropic, Inc. 
//
//==========================================================================
 
#include "tsm.h"
#include "getopt.h"
#include "vapiio.h"
#include <stdio.h>
#include <stdlib.h>
#include <iostream.h>

#define SYNTAX fprintf(stderr,"Usage: tsm [-t (timescale)] infile [outfile]\n")

struct TInput 
{
    char input[MAX_PATH+1];
    char output[MAX_PATH+1];
    double from;
    double to;
    double timeScale;
};

/*
 *
 */
static int ProcessCommandLine (int argc, char *argv[], TInput* pInInfo);


//--------------------------------------------------------------------------
//
// MAIN
//
//--------------------------------------------------------------------------

int main(int argc, char **argv)
{
    TInput inInfo;
    CTsm*   tsm;
    VapiIO* pOutputFile; 

    int iSampFreq; 
    int iFormat;

    short* pnSamples;
    int    iNumSamples;
    
    double* pfBuffer = NULL;
    short* pnBuffer = NULL;

    int firstSample;
    int frameLen;
    int frameShift;
    int lag;
    int lastProcSamp;
    int nSamp;
    int fileEnd;

    if (!ProcessCommandLine (argc, argv, &inInfo)) 
    {
        SYNTAX;
        return 1;
    }

    if (VapiIO::ReadVapiFile(inInfo.input, &pnSamples, &iNumSamples, &iSampFreq, &iFormat, 
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL) != VAPI_IOERR_NOERROR)
    {
        cerr << "Error reading input file " <<inInfo.input << endl;
        return 1;
    }


    if ((tsm = new CTsm(inInfo.timeScale, iSampFreq, &frameLen, &frameShift)) == NULL) 
    {
        cerr << "Error initializing tsm" << endl;
        return 1;
    }

    if ( (pfBuffer = new double[frameLen]) == NULL) 
    {
        cerr << "Memory error" << endl;
        return 1;
    }

    if ( (pnBuffer = new short[frameLen]) == NULL) 
    {
        cerr << "Memory error" << endl;
        return 1;
    }

    // Open output file, and prepare for writing
    if ((pOutputFile = VapiIO::ClassFactory()) == NULL) 
    {
        cerr << "Memory error" << endl;
        return 1;
    }

    if (pOutputFile->OpenFile (inInfo.output, VAPI_IO_WRITE) != VAPI_IOERR_NOERROR)
    {
        cerr << "Error opening output file " << inInfo.output << endl;
        return 1;
    }
 
    if (pOutputFile->WriteFormat( iSampFreq, VAPI_PCM16) != VAPI_IOERR_NOERROR)
    {
        cerr << "Error formating output file " << inInfo.output << endl;
        return 1;
    }

    if (pOutputFile->CreateChunk( "data") != VAPI_IOERR_NOERROR)
    {
        cerr << "Error formating output file " << inInfo.output << endl;
        return 1;
    }
       
    // First frame to process
    for (int i=0; i<frameLen; i++)
    {
        pfBuffer[i] = (double) pnSamples[i];
    }

    lastProcSamp = tsm->FirstFrame(pfBuffer);

    pOutputFile->WriteToChunk ((char *)pnSamples, lastProcSamp * VapiIO::SizeOf(VAPI_PCM16));

    // LOOP OVER FRAMES
    fileEnd = 0;
    firstSample = 0;

    while (!fileEnd)
    {
        for (i=0; i<frameLen; i++)
        {
            if (firstSample + i < iNumSamples)
            {
                pfBuffer[i] = pnSamples[firstSample + i];
            }
            else 
            {
                frameLen = i;
                fileEnd = 1;
                break;
            }
        }

        if (fileEnd)
        {
            lastProcSamp = tsm->LastFrame (pfBuffer, frameLen, &lag, &nSamp);
        } 
        else
        {
            lastProcSamp = tsm->AddFrame (pfBuffer, &lag, &nSamp);
        }


        for (i = 0; i< nSamp; i++)
        {
            pnBuffer[i] = (short)pfBuffer[i+lag];
        }

        pOutputFile->WriteToChunk ((char*)pnBuffer, nSamp * VapiIO::SizeOf(VAPI_PCM16));

        firstSample += frameShift;
    }    

    // Flush the remaining samples
    if (frameLen > lastProcSamp) 
    {
        for (i = 0; i< frameLen - lastProcSamp; i++)
        {
            pnBuffer[i] = (short)pfBuffer[i+lastProcSamp];
        }

        pOutputFile->WriteToChunk ((char*)pnBuffer, frameLen - lastProcSamp);
    }

  
    pOutputFile->CloseChunk ();
    pOutputFile->CloseFile ();
    
    delete tsm;
    delete[] pfBuffer;
    delete[] pnBuffer;
    delete[] pnSamples;

    return 0;  
}


//--------------------------------------------------------------------------
//
// ProcessCommandLine
//
//--------------------------------------------------------------------------

int ProcessCommandLine (int argc, char *argv[], TInput* pInInfo)
{
    int iCh;
    CGetOpt getOpt;
  
    memset (pInInfo, 0 ,sizeof(*pInInfo));

    strcpy (pInInfo->output, "-");
    pInInfo->to = -1.0;
    pInInfo->timeScale = 1.0;

    getOpt.Init(argc, argv, "s:t:");

    while ((iCh = getOpt.NextOption()) != EOF) 
    {
        switch (iCh) 
        {
        case 's':
            {
                int iNumMatch=sscanf(getOpt.OptArg(),"%lf:%lf",&(pInInfo->from), &(pInInfo->to));
            
                if (!iNumMatch) 
                {
                    iNumMatch=sscanf(getOpt.OptArg(),":%lf",&(pInInfo->to));
                    if (!iNumMatch || iNumMatch==EOF) 
                    {
                        fprintf(stderr,"Invalid parameters with the option -s");
                        exit(1);
                    }
                }
            }
            break;
        case 't':
            pInInfo->timeScale = atof(getOpt.OptArg());
            if (pInInfo->timeScale<0.0) 
            {
                fprintf (stderr, "timescale must be > 0.0\n");
                return 0;
            }
            break;
        default:
            return 0;
        }
    }

    

    int optind = getOpt.OptInd();
    if ((argc-optind) == 0) {
        return 0;
    }
    
    strcpy (pInInfo->input, argv[optind++]);
    
    if (argc-optind == 1) {
        strcpy (pInInfo->output, argv[optind++]);
    } else if (argc-optind) {
        return 0;
    }
    
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\backend.cpp ===
/******************************************************************************
* Backend.cpp *
*-------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "backend.h"
#include "tips.h"
#include "SynthUnit.h"
#include "SpeakerData.h"
#include "vapiIo.h"
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

static const int DEFAULT_F0_SAMPFREQ = 200;
static const double SYNTH_PROPORTION = .1;

class CBEndImp : public CBackEnd 
{
    public:
        CBEndImp();

        ~CBEndImp();

        int  LoadTable (const char* pszFilePath, int iDebug = 0);
        int  GetSampFreq ();
        void SetGain (double dGain);
        void GetSpeakerInfo (int* piBaseLine, int* piRefLine, int* piTopLine);        
        void SetF0SampFreq (int iF0SampFreq = DEFAULT_F0_SAMPFREQ);
        int  NewPhoneString (Phone* phList, int nPh, float* newF0, int nNewF0);
        int  OutputPending ();
        int  GenerateOutput (short** ppnSamples, int* piNumSamples);
        int  GetChunk (ChkDescript** ppChunk);
        bool GetPhoneSetFlag ();
        void SetFrontEndFlag () { m_pSlm->SetFrontEndFlag(); }

    private:
        static const int m_iDefSampFreq;
        CSlm*  m_pSlm;
        CTips* m_pTips;
        int    m_iNumUnits;
        int    m_iCurrUnit;
        int    m_iF0SampFreq;
        float* m_pflF0;
        short* m_pnSynthBuff;
        int    m_iSynthBuffSamples;
        short* m_pnOverflow;
        int    m_iOverflowCurSamples;
        int    m_iOverflowMaxSamples;
        int    m_iPrevSamples;
};

const int CBEndImp::m_iDefSampFreq = 8000;

/*****************************************************************************
* CBackEnd::ClassFactory *
*------------------------*
*   Description:
*
******************************************************************* PACOG ***/
CBackEnd* CBackEnd::ClassFactory()
{
    return new CBEndImp; 
}

/*****************************************************************************
* CBEndImp::CBEndImp *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/

CBEndImp::CBEndImp()
{
    int iSlmOptions = CSlm::UseGain | CSlm::Blend | CSlm::DynSearch | CSlm::UseTargetF0;
    int iTipsOptions = 0;

    if ( (m_pSlm = CSlm::ClassFactory(iSlmOptions)) == NULL) 
    {
        goto error;
    }
    
    if ((m_pTips = new CTips(iTipsOptions)) == NULL) 
    {
        goto error;
    }

    m_iPrevSamples = 0;
    m_iSynthBuffSamples = 0;
    m_pnSynthBuff = NULL;
    m_pnOverflow = NULL;
    m_iOverflowCurSamples = 0;
    m_iOverflowMaxSamples = 0;

    m_pTips->Init(VAPI_PCM16, m_iDefSampFreq);

    m_iNumUnits  = 0;
    m_iCurrUnit  = 0;
    m_iF0SampFreq  = DEFAULT_F0_SAMPFREQ;
    m_pflF0 = NULL;
  
    return;

error:
    if ( m_pTips )
    {
        delete m_pTips;
        m_pTips = NULL;
    }

    return;
}

/*****************************************************************************
* CBEndImp::~CBEndImp *
*---------------------*
*   Description:
*
******************************************************************* PACOG ***/

CBEndImp::~CBEndImp ()
{
    if (m_pSlm) 
    {
        delete m_pSlm;
    }

    if (m_pTips) 
    {
        delete m_pTips;
    }

    if ( m_pflF0 )
    {
        delete[] m_pflF0;
        m_pflF0 = NULL;
    }

    if ( m_pnSynthBuff )
    {
        delete [] m_pnSynthBuff;
        m_pnSynthBuff = NULL;
    }

    if ( m_pnOverflow )
    {
        delete [] m_pnOverflow;
        m_pnOverflow = NULL;
    }
}


/*****************************************************************************
* CBEndImp::LoadTable *
*---------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CBEndImp::LoadTable (const char* pszFilePath, int iDebug)
{
    assert (pszFilePath);

    if (!m_pSlm->Load (pszFilePath, true)) 
    {
        if (iDebug) 
        {
            fprintf (stderr, "BackEnd: can't load table file %s\n", pszFilePath);
        }
        return 0;
    }

    m_pTips->Init(m_pSlm->GetSampFormat(), m_pSlm->GetSampFreq());

    m_iSynthBuffSamples = SYNTH_PROPORTION * m_pSlm->GetSampFreq();
    if ((m_pnSynthBuff = new short[m_iSynthBuffSamples]) == NULL)
    {
        return 0;
    }

    return 1; 
}


/*****************************************************************************
* CBEndImp::SetGain *
*-------------------*
*   Description:
*
******************************************************************* PACOG ***/
void CBEndImp::SetGain (double dGain)
{
    m_pTips->SetGain(dGain);
}

/*****************************************************************************
* CBEndImp::GetSampFreq *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CBEndImp::GetSampFreq ()
{
    return m_pSlm->GetSampFreq();
}

/*****************************************************************************
* CBEndImp::GetSpeakerInfo *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/

void CBEndImp::GetSpeakerInfo (int* piBaseLine, int* piRefLine, int* piTopLine)
{
    m_pSlm->GetTtpParam (piBaseLine, piRefLine, piTopLine);
}

/*****************************************************************************
* CBEndImp::GetPhoneSetFlag *
*--------------------------*
*   Description:
*
******************************************************************* mplumpe ***/

bool CBEndImp::GetPhoneSetFlag ()
{
    return m_pSlm->GetPhoneSetFlag ();
}

/*****************************************************************************
* CBEndImp::SetF0SampFreq *
*-------------------------*
*   Description:
*
******************************************************************* PACOG ***/
void CBEndImp::SetF0SampFreq(int iF0SampFreq)
{
    assert (iF0SampFreq>0);
    m_iF0SampFreq = iF0SampFreq;
}

/*****************************************************************************
* CBEndImp::NewPhoneString *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CBEndImp::NewPhoneString (Phone* phList, int nPh, float* newF0, int nNewF0)
{
    assert (nPh==0 || phList!=NULL);
    assert (nNewF0==0 || newF0!=NULL);
    int    nF0 = 0;

    m_iCurrUnit = 0;

    if (( m_iNumUnits = m_pSlm->Process (phList, nPh, 0.0)) == 0)
    {
        return 0;
    }

    if ( m_pSlm->GetSynthMethod() )
    {
        m_pSlm->GetNewF0 ( &m_pflF0, &nF0, m_iF0SampFreq);
        m_pTips->NewSentence (m_pflF0, nF0, m_iF0SampFreq);
    }
    else
    {
        m_pTips->NewSentence (newF0, nNewF0, m_iF0SampFreq);
    }

    return 1;
}

/*****************************************************************************
* CBEndImp::OutputPending *
*-------------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CBEndImp::OutputPending ()
{
    return (m_iNumUnits - m_iCurrUnit) || m_pTips->Pending() || m_iOverflowCurSamples;
}

/*****************************************************************************
* CBEndImp::GenerateOutput *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CBEndImp::GenerateOutput (short** ppnSamples, int* piNumSamples)
{
    bool fDone = false;
    short* pnCurSamples = NULL;
    int iNumCurSamples = 0;
    
    assert (ppnSamples && piNumSamples && m_pnSynthBuff);
    
    if ( m_iOverflowCurSamples )
    {
        assert( m_pnOverflow );
        memcpy(m_pnSynthBuff, m_pnOverflow, m_iOverflowCurSamples * sizeof(short));
        m_iPrevSamples = m_iOverflowCurSamples;
        m_iOverflowCurSamples = 0;
    }
    
    do 
    {
        while ( m_pTips->Pending() )
        {
            if (m_pTips->NextPeriod( &pnCurSamples, &iNumCurSamples))
            {
                if ( m_iPrevSamples + iNumCurSamples <= m_iSynthBuffSamples )
                {
                    memcpy(&m_pnSynthBuff[m_iPrevSamples], pnCurSamples, iNumCurSamples * sizeof(short));
                    m_iPrevSamples += iNumCurSamples;
                }
                else
                {
                    // something's wrong if a single period exceeds the buffer.
                    assert (iNumCurSamples <= m_iSynthBuffSamples);
                    // is the overflow buffer too small?
                    if ( m_iOverflowMaxSamples < iNumCurSamples )
                    {
                        if ( m_pnOverflow )
                        {
                            delete [] m_pnOverflow;
                            m_pnOverflow = NULL;
                        }
                        if ( (m_pnOverflow = new short[iNumCurSamples]) == NULL )
                        {
                            return 0;
                        }
                        m_iOverflowMaxSamples = iNumCurSamples;
                    }
                    // save the extra in the overflow buffer
                    memcpy(m_pnOverflow, pnCurSamples, iNumCurSamples * sizeof(short));
                    m_iOverflowCurSamples = iNumCurSamples;
                    fDone = true;
                    break;
                }
            }
        }

        if (!fDone)
        {
            if (m_iCurrUnit < m_iNumUnits) 
            {            
                if (! m_pTips->NewUnit (m_pSlm->GetUnit (m_iCurrUnit)))
                {
                    return 0;
                } 
                m_iCurrUnit ++;
            }
            else 
            {
                *ppnSamples  = 0;
                *piNumSamples = 0;
                fDone = true;
            }
            
        }
    } while (! fDone);

    if ( m_iPrevSamples )
    {
        *ppnSamples = m_pnSynthBuff;
        *piNumSamples = m_iPrevSamples;
        m_iPrevSamples = 0;
    }
    else
    {
        *ppnSamples = 0;
        *piNumSamples = 0;
    }
                           
    return 1;
}

/*****************************************************************************
* CBEndImp::GetChunk *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CBEndImp::GetChunk(ChkDescript** ppChunk)
{
    assert (ppChunk);

    if (!ppChunk)
    {
        return 0;
    }

    if (m_iNumUnits > 0) 
    {        
        if (m_iCurrUnit < m_iNumUnits) 
        {            
            *ppChunk = m_pSlm->GetChunk (m_iCurrUnit++);
        }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\beversion.h ===
/******************************************************************************
* BeVersion.h *
*-------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/
#ifndef __BEVERSION_H_
#define __BEVERSION_H_

#include <stdio.h>

class BendVersion 
{
    public:
        void WriteVersionString( FILE* fp);
        bool CheckVersionString( FILE* fp);

    private:
        static const char * const pszVersion;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\ftol.h ===
/******************************************************************************
* FTOL.h *
*-------------*
*
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 12/04/00
*  All Rights Reserved
*
********************************************************************* mplumpe ***/

#pragma once

// Do a floating to integer conversion quickly
// NOTE : FTOL rounds, while (int) truncates!!!
#ifdef _M_IX86
#define FTOL(f) fast_ftol(f)
__inline int fast_ftol (double f)
{
   int i;
   __asm FLD f
   __asm FISTP i
   return i;
}
#else
#define FTOL(f) (int) (f)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\list.h ===
/******************************************************************************
* list.h *
*--------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/21/00 - 12/5/00
*  All Rights Reserved
*
********************************************************************* mplumpe  was PACOG ***/

#ifndef __LIST_H_
#define __LIST_H_

#include <string.h>
#include <assert.h>

// *** CDynString helper class
//
//
class CDynString 
{
    public:
        char*     m_psz;
        CDynString()
        {
            m_psz = 0;
        }
        CDynString(int cchReserve)
        {
            m_psz = (char*)new char[cchReserve];
        }
        char * operator=(const CDynString& src)
        {
            if (m_psz != src.m_psz)
            {
                delete[] m_psz;
                m_psz = src.Copy();
            }
            return m_psz;
        }

        char * operator=(const char * pSrc)
        {
            Clear();
            if (pSrc)
            {
                int cbNeeded = strlen(pSrc) + 1;
                m_psz = new char [cbNeeded];
                if (m_psz)
                {
                    memcpy(m_psz, pSrc, cbNeeded);    
                }
            }
            return m_psz;
        }
        //
        // TempCopy and TempClear are used below in Find, so we don't have
        // to allocate mem, copy, and de-allocate.   mplumpe 12/5/00
        //
        void TempCopy (const char *pSrc)
        {
            Clear();
            m_psz = (char *)pSrc;
        }

        void TempClear ()
        {
            m_psz = NULL;
        }
        
        /*explicit*/ CDynString(const char * pSrc)
        {
            m_psz = 0;
            operator=(pSrc);
        }
        /*explicit*/ CDynString(const CDynString& src)
        {
            m_psz = src.Copy();
        }
        
        ~CDynString()
        {
            delete[] m_psz;
        }
        unsigned int Length() const
        {
            return (m_psz == 0)? 0 : strlen(m_psz);
        }
        
        operator char * () const
        {
            return m_psz;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the m_psz member explicitly.
        char ** operator&()
        {
            assert (m_psz == 0);
            return &m_psz;
        }
        
        char * Append(const char * pszSrc)
        {
            if (pszSrc)
            {
                int lenSrc = strlen(pszSrc);
                if (lenSrc)
                {
                    int lenMe = Length();
                    char *pszNew = new char[(lenMe + lenSrc + 1)];
                    if (pszNew)
                    {
                        if (m_psz)  // Could append to an empty string so check...
                        {
                            if (lenMe)
                            {
                                memcpy(pszNew, m_psz, lenMe * sizeof(char));
                            }
                            delete[] m_psz;
                        }
                        memcpy(pszNew + lenMe, pszSrc, (lenSrc + 1) * sizeof(char));
                        m_psz = pszNew;
                    }
                    else
                    {
                        assert(false);
                    }
                }
            }
            return m_psz;
        }
        char * Append2(const char * pszSrc1, const char * pszSrc2)
        {
            int lenSrc1 = strlen(pszSrc1);
            int lenSrc2 = strlen(pszSrc2);
            if (lenSrc1 || lenSrc2)
            {
                int lenMe = Length();
                char *pszNew = new char[(lenMe + lenSrc1 + lenSrc2 + 1)];
                if (pszNew)
                {
                    if (m_psz)  // Could append to an empty string so check...
                    {
                        if (lenMe)
                        {
                            memcpy(pszNew, m_psz, lenMe * sizeof(char));
                        }
                        delete[] m_psz;
                    }
                    // In both of these cases, we copy the trailing NULL so that we're sure it gets
                    // there (if lenSrc2 is 0 then we better copy it from pszSrc1).
                    if (lenSrc1)
                    {
                        memcpy(pszNew + lenMe, pszSrc1, (lenSrc1 + 1) * sizeof(char));
                    }
                    if (lenSrc2)
                    {
                        memcpy(pszNew + lenMe + lenSrc1, pszSrc2, (lenSrc2 + 1) * sizeof(char));
                    }
                    m_psz = pszNew;
                }
                else
                {
                    assert (false);
                }
            }
            return m_psz;
            
        }
        char * Copy() const
        {
            if (m_psz)
            {
                CDynString szNew(m_psz);
                return szNew.Detach();
            }
            return 0;
        }
        void Attach(char * pszSrc)
        {
            assert (m_psz == 0);
            m_psz = pszSrc;
        }
        char * Detach()
        {
            char * s = m_psz;
            m_psz = 0;
            return s;
        }
        void Clear()
        {
            if ( m_psz )
            {
                delete[] m_psz;
                m_psz = 0;
            }
        }
        bool operator!() const
        {
            return (m_psz == 0);
        }
        void TrimToSize(int ulNumChars)
        {
            assert (m_psz);
            assert (Length() <= (unsigned)ulNumChars);
            m_psz[ulNumChars] = 0;
        }
        char * Compact()
        {
            if (m_psz)
            {
                int cch = strlen(m_psz);
                char* psz = new char[(cch + 1)];
                if (psz) 
                {
                    strcpy(psz, m_psz);
                    delete[] m_psz;

                    m_psz = psz;
                }
            }
            return m_psz;
        }
        char * ClearAndGrowTo(int cch)
        {
            if (m_psz)
            {
                Clear();
            }
            m_psz = new char[cch];
            return m_psz;
        }
};



// *** CList helper class
//
//
template <class TYPE> 
class CList
{
    public:
        CList(int size = 0);
        ~CList();
        
        CList& operator= (CList& rSrc);
        int   Size ();
        bool  PushBack(const char* name, TYPE& item);
        TYPE& PopBack();
        TYPE& PopFront();
        TYPE& operator[] (int index);
        TYPE& Back();
        void  Clear();
        void  Remove (int index);
        void  Sort();
        bool  Find(const char* name, TYPE& rItem);
        bool  Find(const char* name, TYPE** ppItem);

    protected:
        bool  Grow ();
        bool  Alloc (int size);
        static int   Compare (const void* a, const void* b);

        struct Bucket 
        {
            Bucket() : name() {};
            Bucket& operator= (Bucket& rSrc)
            {
                name = rSrc.name;
                data = rSrc.data;
                return *this;
            }
            CDynString name;
            TYPE data;
        } *m_pElem;
        int  m_iNumElem;
        int  m_iNumAlloc;
        bool m_bSorted;
};

//--------------------------------------------------------------
// Template implementation
//

template <class TYPE> 
CList<TYPE>::CList (int size)
{
    m_pElem     = 0;
    m_iNumElem  = 0;
    m_iNumAlloc = size;
    m_bSorted   = false;
    Grow();
}

template <class TYPE> 
CList<TYPE>::~CList ()
{
    Clear();        
}

template <class TYPE> 
CList<TYPE>& CList<TYPE>::operator= (CList<TYPE>& rSrc)
{
    Clear();

    if (Alloc(rSrc.m_iNumAlloc))
    {
        for (int i=0; i<rSrc.m_iNumElem; i++)
        {
            m_pElem[i] = rSrc.m_pElem[i];            
        }
        m_iNumElem = rSrc.m_iNumElem;
    }
    return *this;
}


template <class TYPE> 
inline int CList<TYPE>::Size ()
{
    return m_iNumElem;
}

template <class TYPE> 
bool CList<TYPE>::PushBack(const char* name, TYPE& item)
{
    if (m_iNumElem == m_iNumAlloc) 
    {
        if (!Grow())
        {
            return false;
        }
    }

    m_pElem[m_iNumElem].name = name;
    m_pElem[m_iNumElem].data = item;
    m_iNumElem ++;

    m_bSorted = false;

    return true;
}

template <class TYPE> 
TYPE& CList<TYPE>::PopBack()
{
    if (m_iNumElem) 
    {
        return m_pElem[--m_iNumElem].data;
    }

    return 0;
}

template <class TYPE> 
TYPE& CList<TYPE>::PopFront()
{
    if (m_iNumElem) 
    {
        TYPE& item = m_pElem[0].data;
        m_iNumElem--;

        for (int i=0; i<m_iNumElem; i++) 
        {
            m_pElem[i] = m_pElem[i+1];
        }
        return item;
    }  

    return 0;
}

template <class TYPE> 
inline TYPE& CList<TYPE>::operator[] (int index)
{
    return m_pElem[index].data;
}

template <class TYPE> 
inline TYPE& CList<TYPE>::Back()
{
    return m_pElem[m_iNumElem -1].data;
}

template <class TYPE> 
void CList<TYPE>::Clear()
{
    if (m_pElem) 
    {
        delete[] m_pElem;
    }
    m_pElem = 0;
    m_iNumElem = 0;
    m_iNumAlloc = 0;
}

template <class TYPE> 
void CList<TYPE>::Remove (int index)
{
    m_iNumElem--;

    for (int i=index; i<m_iNumElem; i++) 
    {
        m_pElem[i] = m_pElem[i+1];    
    }
}

template <class TYPE> 
void CList<TYPE>::Sort()
{
    qsort (m_pElem, m_iNumElem, sizeof(*m_pElem), Compare);
    m_bSorted = true;
}

template <class TYPE> 
bool CList<TYPE>::Find(const char* pszName, TYPE& rItem)
{
    if (m_bSorted)
    {
        Bucket  key;
        Bucket* result;
    
        key.name.TempCopy (pszName);

        result = (Bucket*) bsearch (&key, m_pElem, m_iNumElem, sizeof(*m_pElem), Compare);
        key.name.TempClear ();

        if (result)
        {
            rItem = result->data;
            return true;
        }
    }
    else 
    {
        for (int i = 0; i< m_iNumElem; i++)
        {
            if (strcmp (pszName, m_pElem[i].name) == 0)
            {
                rItem = m_pElem[i].data;
                return true;
            }
        }
    }

    return false;
}


template <class TYPE> 
bool CList<TYPE>::Find(const char* pszName, TYPE** rItem)
{
    if (m_bSorted)
    {
        Bucket  key;
        Bucket* result;
    
        key.name.TempCopy (pszName);

        result = (Bucket*) bsearch (&key, m_pElem, m_iNumElem, sizeof(*m_pElem), Compare);
        key.name.TempClear ();

        if (result)
        {
            *rItem = &result->data;
            return true;
        }
    }
    else 
    {
        for (int i = 0; i< m_iNumElem; i++)
        {
            if (strcmp (pszName, m_pElem[i].name) == 0)
            {
                *rItem = &m_pElem[i].data;
                return true;
            }
        }
    }

    return false;
}


template <class TYPE> 
int CList<TYPE>::Compare (const void* a, const void* b)
{
    Bucket* x = (Bucket*)a;
    Bucket* y = (Bucket*)b;

    return strcmp( (x)->name.m_psz, (y)->name.m_psz);
}


template <class TYPE> 
bool CList<TYPE>::Grow ()
{
    int size;

    // Make space for more items       
    if (m_iNumAlloc) 
    {
        size = m_iNumAlloc; 
        size += size/2;
    }
    else 
    {
        size = 4;
    }

    return Alloc (size);
}

template <class TYPE> 
bool CList<TYPE>::Alloc (int size)
{
    Bucket* ptr = new Bucket[size];
    if (ptr == 0) 
    {
        return false;
    
    }

    if (m_pElem)
    {
        for (int i=0; i<m_iNumElem; i++)
        {
            ptr[i] = m_pElem[i];
        }
        delete[] m_pElem;
    }

    m_pElem = ptr;
    m_iNumAlloc = size;

    return true;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\slm.cpp ===
/******************************************************************************
* slm.cpp *
*---------*
*
*------------------------------------------------------------------------------
*  Copyright (c) 1997  Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/
#include "backendInt.h"
#include "SpeakerData.h"
#include "UnitSearch.h"
#include <float.h>
#include <math.h>
#include <assert.h>


#define MAX_F0          500
#define MIN_F0          40
#define LOW_F0_RATIO    1.0
#define HIGH_F0_RATIO   1.0
#define F0_RATIO_INC    0.05
#define F0_WEIGHT       0.8

struct DPUnit
{
    double f0;
    double f0Zs;
    double f0Ratio;
    double acumCost;
    double targCost;
    double modCost;
    int    iPrevCand;
};

struct DPList
{
    std::vector<DPUnit> cands;
    double targF0Zs;
    int    iBestPath;
};

struct NewF0Struct
{
    double f0;
    double time;
};

struct DurStruct
{
    double ratio;
    double runTime;
    double chunkTime;
};

//-------------------------------------------------------------------------
//
// Implementation of virtual class CSlm
//
class CSlmImp : CSlm 
{
    public:
        CSlmImp (int iOptions);
        ~CSlmImp ();

        int   Load (const char *pszFileName, bool fCheckVersion);
        void  Unload ();

        int   GetSampFreq ();
        int   GetSampFormat ();
        bool  GetSynthMethod() { return m_pSpeakerData->GetSynthMethod(); }
        bool  GetPhoneSetFlag() {return m_pSpeakerData->GetPhoneSetFlag(); }
        void  SetFrontEndFlag() { m_pSpeakerData->SetFrontEndFlag(); }

        void  SetF0Weight      (float fWeight);
        void  SetDurWeight     (float fWeight);
        void  SetRmsWeight     (float fWeight);
        void  SetLklWeight     (float fWeight);
        void  SetContWeight    (float fWeight);
        void  SetSameSegWeight (float fWeight);
        void  SetPhBdrWeight   (float fWeight);
        void  SetF0BdrWeight   (float fWeight);
        void  GetTtpParam (int* piBaseLine, int* piRefLine, int* piTopLine);

        int   Process (Phone* phList, int nPh, double startTime);

        CSynth* GetUnit (int iUnitIndex);

        ChkDescript* GetChunk (int iChunkIndex); //For command line slm

        void  PreComputeDist();
        void  CalculateF0Ratio ();
        void  GetNewF0 (float** ppfF0, int* piNumF0, int iF0SampFreq);

    private:
        void  GetNeighborF0s ( double dTime,
                               std::vector<NewF0Struct>* pvNewF0, 
                               double* pdLeftF0, 
                               double* pdLeftOffset, 
                               double* pdRightF0, 
                               double* pdRightOffset,
                               int*    piLastIdx );
        void GetCandicates ( int iIdx, DPList *pDpLink );
        void GetAvgF0();
        void ComputeDPInfo ( DPList* pPrevLink, DPList& rCurLink);
        void GetUnitF0Ratio();
        void FindBdrF0 (double* pdLeftF0, double* pdRightF0, int idx);

        double m_dAvgTargF0;
        double m_dAvgSrcF0;

    private:
        CSpeakerData* m_pSpeakerData;
        CUnitSearch*  m_pUnitSearch;
        ChkDescript*  m_pChunks;
        int           m_iNumChunks;
        int           m_iOptions;
};


/*****************************************************************************
* CSlm::ClassFactory *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/
CSlm* CSlm::ClassFactory (int iOptions)
{
    return new CSlmImp( iOptions );
}

/*****************************************************************************
* CSlmImp::CSlmImp *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/

CSlmImp::CSlmImp( int iOptions )
{
    m_pSpeakerData = 0;
    m_iOptions     = iOptions;
    m_pChunks      = 0;
    m_iNumChunks   = 0;
}

/*****************************************************************************
* CSlmImp::~CSlmImp *
*-------------------*
*   Description:
*
******************************************************************* PACOG ***/

CSlmImp::~CSlmImp ( )
{
    if (m_pChunks)
    {
        free (m_pChunks);
        m_pChunks = 0;
        m_iNumChunks = 0;
    }
    Unload ();
}

/*****************************************************************************
* CSlmImp::Load *
*---------------*
*   Description:
*
******************************************************************* PACOG ***/
int CSlmImp::Load(const char *pszFileName, bool fCheckVersion)
{
    assert (pszFileName);
  
    if ((m_pSpeakerData = CSpeakerData::ClassFactory( pszFileName, fCheckVersion )) != 0)
    {
        if ((m_pUnitSearch = new CUnitSearch(m_iOptions & CSlm::DynSearch, 
                                             m_iOptions & CSlm::Blend, 
                                             m_iOptions & CSlm::UseTargetF0, 
                                             m_iOptions & CSlm::UseGain)) != 0)
        {
//            if (m_pSpeakerData->Load (m_pUnitSearch, checkVersion))
            {
                m_pUnitSearch->SetSpeakerData(m_pSpeakerData);
                return 1;
            }
        }
    }
    return 0;
}

/*****************************************************************************
* CSlmImp::Unload *
*-----------------*
*   Description:
*
******************************************************************* PACOG ***/

void CSlmImp::Unload ( )
{
    if (m_pSpeakerData) 
    {
        m_pSpeakerData->Release();
        m_pSpeakerData = 0;
    }
    if (m_pUnitSearch)
    {
        delete m_pUnitSearch;
        m_pUnitSearch = 0;
    }
}

/*****************************************************************************
* CSlmImp::GetTtpParam *
*----------------------*
*   Description:
*       Return Prosody Range Parameters
******************************************************************* PACOG ***/
void CSlmImp::GetTtpParam (int* piBaseLine, int* piRefLine, int* piTopLine)
{
    m_pSpeakerData->GetTtpParam(piBaseLine, piRefLine, piTopLine);

}

/*****************************************************************************
* CSlmImp::GetSampFreq *
*----------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CSlmImp::GetSampFreq ()
{
    return m_pSpeakerData->GetSampFreq();
}

/*****************************************************************************
* CSlmImp::GetSampFormat *
*------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CSlmImp::GetSampFormat ()
{
    return m_pSpeakerData->GetSampFormat();
}

/*****************************************************************************
* CSlmImp::SetF0Weight *
*----------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSlmImp::SetF0Weight (float fWeight)
{
    m_pSpeakerData->SetF0Weight( fWeight);
}

/*****************************************************************************
* CSlmImp::SetDurWeight *
*-----------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSlmImp::SetDurWeight (float fWeight)
{
    m_pSpeakerData->SetDurWeight( fWeight);
}


/*****************************************************************************
* CSlmImp::SetRmsWeight *
*-----------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSlmImp::SetRmsWeight (float fWeight)
{
    m_pSpeakerData->SetRmsWeight( fWeight);
}


/*****************************************************************************
* CSlmImp::SetLklWeight *
*-----------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSlmImp::SetLklWeight (float fWeight)
{
    m_pSpeakerData->SetLklWeight( fWeight);
}


/*****************************************************************************
* CSlmImp::SetContWeight *
*------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSlmImp::SetContWeight (float fWeight)
{
    m_pSpeakerData->SetContWeight( fWeight);
}


/*****************************************************************************
* CSlmImp::SetSameSegWeight *
*---------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSlmImp::SetSameSegWeight (float fWeight)
{
    m_pSpeakerData->SetSameWeight( fWeight);
}

/*****************************************************************************
* CSlmImp::SetPhBdrWeight *
*-------------------------*
*   Description:
*       
******************************************************************* WD ******/
void CSlmImp::SetPhBdrWeight (float fWeight)
{
    m_pSpeakerData->SetPhBdrWeight( fWeight);
}

/*****************************************************************************
* CSlmImp::SetF0BdrWeight *
*-------------------------*
*   Description:
*       
******************************************************************* WD ******/
void CSlmImp::SetF0BdrWeight (float fWeight)
{
    m_pSpeakerData->SetF0BdrWeight( fWeight);
}

/*****************************************************************************
* CSlmImp::PreComputeDist *
*-------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSlmImp::PreComputeDist ()
{
    if (m_pUnitSearch && m_pSpeakerData)
    {    
        m_pUnitSearch->SetSpeakerData(m_pSpeakerData);
    }                
}

/*****************************************************************************
* CSlmImp::Process *
*------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CSlmImp::Process (Phone* pPhList, int iNumPh, double dStartTime)
{
    if (m_pChunks) 
    {
        free (m_pChunks);
        m_pChunks = 0;
        m_iNumChunks = 0;
    }

    if (!m_pUnitSearch->Search (pPhList, iNumPh, &m_pChunks, &m_iNumChunks, dStartTime))
    {
        return 0;
    }

    return m_iNumChunks;
}

/*****************************************************************************
* CSlmImp::GetChunk *
*-------------------*
*   Description:
*       
******************************************************************* PACOG ***/
ChkDescript* CSlmImp::GetChunk(int iChunkIndex)
{
    return &m_pChunks[iChunkIndex];
}

/*****************************************************************************
* CSlmImp::GetUnit *
*------------------*
*   Description:
*       
******************************************************************* PACOG ***/
CSynth* CSlmImp::GetUnit (int iUnitIndex)
{
    CSynth* pSynth = 0;

    return m_pSpeakerData->GetUnit(&m_pChunks[iUnitIndex]);
    
}

/*****************************************************************************
* CSlmImp::GetNewF0 *
*-------------------*
*
*       
*********************************************************************** WD ***/
void CSlmImp::GetNewF0 (float** ppfF0, int* piNumF0, int iF0SampFreq)
{
    assert ( iF0SampFreq > 0 );

    std::vector<NewF0Struct> vF0;
    std::vector<NewF0Struct> vNewF0;
    std::vector<DurStruct> vDurRatio;
    DurStruct   durRatio;
    NewF0Struct f0Struct;

    int    i;
    int    iLastIdx = 0;
    double dTime = 0.0;
    double dF0Step = 1.0 / (double) iF0SampFreq; // in second 
    double dLeftF0;
    double dLeftOffset;
    double dRightF0;
    double dRightOffset;
    CSynth* pSynth = 0;

    //--- clean old f0
    if ( *ppfF0 )
    {
        delete[] *ppfF0;
        *ppfF0 = NULL;
    }

    //--- get unit f0 ratio, using 3-point averaging tech
    for ( i = 0; i < m_iNumChunks; i++ )
    {
        m_pChunks[ i ].f0Ratio = 1.0;
    }
    GetUnitF0Ratio();

    //--- use original target duration
    double dRunTime  = 0;
    double dPrevTime = 0;
    memset ( &durRatio, 0, sizeof( durRatio ) );

    //--- first, resample the f0 values of units
    for ( i = 0; i < m_iNumChunks; i++ )
    {
        pSynth = m_pSpeakerData->GetUnit(&m_pChunks[ i ]);
        pSynth->GetNewF0( &vNewF0,  &dTime, &dRunTime );
        if ( dTime - dPrevTime > 0 && dRunTime - durRatio.runTime > 0 )
        {
            durRatio.ratio = ( dTime - dPrevTime ) / ( dRunTime - durRatio.runTime );
        }
        else
        {
            durRatio.ratio = 1;
        }
        dPrevTime = dTime;
        durRatio.runTime   = dRunTime;
        durRatio.chunkTime = dTime;
        vDurRatio.push_back ( durRatio );
        delete pSynth;
        pSynth = 0;
    }
    
    iLastIdx = 0;
    for ( i = 0; i < int (dTime / dF0Step ); i++ )
    {
        GetNeighborF0s ( (i + 1) * dF0Step, &vNewF0, &dLeftF0, &dLeftOffset, &dRightF0, &dRightOffset, &iLastIdx );
        if ( dRightOffset + dLeftOffset > 0 )
        {
            f0Struct.f0 = (float) ( (dLeftF0 * dRightOffset + dRightF0 * dLeftOffset ) / ( dRightOffset + dLeftOffset ) );
        }
        else
        {
            f0Struct.f0 = 100.0;
        }
        f0Struct.time = (i + 1) * dF0Step;
        vF0.push_back ( f0Struct );
    }
    vNewF0.resize( 0 );

    //--- next, get new f0 values
    *piNumF0 = int ( vDurRatio[ vDurRatio.size() - 1 ].runTime / dF0Step );
    *ppfF0 = new float[ *piNumF0 ];
    if (*ppfF0 )
    {   
        int idx = 0;
        double dChunkSt = 0;
        double dTargSt  = 0;
        double dChunkTime = 0;
        dTime   = 0;

        while ( dF0Step > vDurRatio[ idx ].runTime )
        {
            idx++;
            if ( idx >= vDurRatio.size() )
            {
                idx--;
                break;
            }
        }
        iLastIdx = 0;
        for ( i = 0; i < *piNumF0; i++ )
        {
            dTime += dF0Step;
            if ( idx > 0 )
            {
                dChunkSt = vDurRatio[ idx - 1 ].chunkTime;
                dTargSt  = vDurRatio[ idx - 1 ].runTime;
            }
            dChunkTime = dChunkSt + ( dTime - dTargSt ) * vDurRatio[ idx ].ratio;
            GetNeighborF0s ( dChunkTime, &vF0, &dLeftF0, &dLeftOffset, &dRightF0, &dRightOffset, &iLastIdx );
            if ( dRightOffset + dLeftOffset > 0 )
            {
                (*ppfF0)[ i ] = (short) ( (dLeftF0 * dRightOffset + dRightF0 * dLeftOffset ) / ( dRightOffset + dLeftOffset ) );
            }
            else
            {
                (*ppfF0)[ i ] = 100.0;
            }

            while ( (i + 1) * dF0Step > vDurRatio[ idx ].runTime )
            {
                idx++;
                if ( idx >= vDurRatio.size() )
                {
                    idx--;
                    break;
                }
            }
        }
    }

    vDurRatio.resize( 0 );
    vF0.resize( 0 );
    m_pSpeakerData->ResetRunTime();
}

/*****************************************************************************
* CSlmImp::GetNeighborF0s  *
*--------------------------*
*
*       
*********************************************************************** WD ***/
void CSlmImp::GetNeighborF0s ( double dTime,
                               std::vector<NewF0Struct>* pvNewF0, 
                               double* pdLeftF0, 
                               double* pdLeftOffset, 
                               double* pdRightF0, 
                               double* pdRightOffset,
                               int*    piLastIdx )
{
    for ( int i = *piLastIdx; i < pvNewF0->size(); i++ )
    {
        if ( (*pvNewF0)[ i ].time >= dTime )
        {
            if ( i - 1 < 0 )
            {
                *pdLeftF0      = 0;
                *pdRightF0     = (*pvNewF0)[ i ].f0;
                *pdLeftOffset  = (*pvNewF0)[ i ].time;
                *pdRightOffset = 0;
            }
            else
            {
                *pdLeftF0      = (*pvNewF0)[ i - 1 ].f0;
                *pdRightF0     = (*pvNewF0)[ i ].f0;
                *pdLeftOffset  = dTime - (*pvNewF0)[ i - 1 ].time;
                *pdRightOffset = (*pvNewF0)[ i ].time - dTime;
            }
            break;
        }
    }
    *piLastIdx = i;
}

/*****************************************************************************
* CSlmImp::CalculateF0Ratio *
*---------------------------*
*   Description: skip unit with srcF0 = 0
*       
*********************************************************************** WD ***/
void CSlmImp::CalculateF0Ratio ()
{
    std::vector<DPList> dpList;
    DPList  dpLink;
    int     iPrevIdx = -1; // the last cand with non-zero f0
    int     i;

    GetAvgF0 ();

    for ( i = 0; i < m_iNumChunks; i++ )
    {
        dpLink.cands.resize ( 0 );
        GetCandicates ( i, &dpLink );

        if ( i > 0 )
        {
            if ( dpLink.cands.size() > 1 )
            {
                if ( iPrevIdx < 0 )
                {
                    ComputeDPInfo ( NULL, dpLink );
                }
                else
                {
                    ComputeDPInfo ( &dpList[ iPrevIdx ], dpLink );
                }
                iPrevIdx = i;
            }
        }
        else
        {
            if ( dpLink.cands.size() > 1 )
            {
                ComputeDPInfo ( NULL, dpLink );
                iPrevIdx = i;
            }
        }

        dpList.push_back ( dpLink );
    }
    //--- find optimal path
    i = m_iNumChunks - 1;
    iPrevIdx = -1;
    int iCurIdx;

    iCurIdx = dpList[ i ].iBestPath;
    if ( dpList[ i ].cands.size() > 1 )
    {
        iPrevIdx = dpList[ i ].cands[ iCurIdx ].iPrevCand;
    }
    m_pChunks[ i ].f0Ratio = dpList[ i ].cands[ iCurIdx ].f0Ratio;
    i--;

    for ( ; i >= 0; i-- )
    {
        iCurIdx = dpList[ i ].iBestPath;
        if ( dpList[ i ].cands.size() > 1 )
        {
            if ( iPrevIdx >= 0 )
            {
                iCurIdx  = iPrevIdx;
            }
            iPrevIdx = dpList[ i ].cands[ iCurIdx ].iPrevCand;
        }
        m_pChunks[ i ].f0Ratio = dpList[ i ].cands[ iCurIdx ].f0Ratio;
    }

    //--- free memory 
    for ( i = 0; i < dpList.size(); i++ )
    {
            dpList[ i ].cands.resize ( 0 );
    }
    dpList.resize( 0 );

}

/*****************************************************************************
* CSlmImp::ComputeDPInfo *
*------------------------*
*   Description:
*       
*********************************************************************** WD ***/
void CSlmImp::ComputeDPInfo ( DPList* pPrevLink, DPList& rCurLink)
{
    DPUnit         candIseg;
    DPUnit         candJseg;
    int            nCandI;
    int            nCandJ;
    double         dMinCost;
    double         dTotalMinCost;
    double         dAcumCost;
    double         dJointCost;

    nCandI = rCurLink.cands.size();
    if ( pPrevLink )
    {
        nCandJ = pPrevLink->cands.size();
    }
    rCurLink.iBestPath = -1;
    dTotalMinCost = DBL_MAX;

    for ( int i = 0; i < nCandI; i++ )
    {
        candIseg = rCurLink.cands[ i ];
        
        if ( pPrevLink )
        {
            dMinCost = DBL_MAX;
            for ( int j = 0; j < nCandJ; j++ )
            {
                candJseg = pPrevLink->cands[ j ];
                
                dJointCost = fabs ( ( candIseg.f0Zs - candJseg.f0Zs ) - ( rCurLink.targF0Zs - pPrevLink->targF0Zs ) );

                //--- acum cost
                dAcumCost = dJointCost + pPrevLink->cands[ j ].acumCost + rCurLink.cands[ i ].targCost;
                dAcumCost += F0_WEIGHT * ( rCurLink.cands[ i ].modCost + pPrevLink->cands[ j ].modCost );

                if ( dAcumCost < dMinCost )
                {
                    dMinCost = dAcumCost;
                    rCurLink.cands[ i ].iPrevCand = j;
                }
            }            
            rCurLink.cands[ i ].acumCost = dMinCost;
        }
        else
        {
            rCurLink.cands[ i ].iPrevCand = 0;
            rCurLink.cands[ i ].acumCost = rCurLink.cands[ i ].targCost;
        }

        if ( dTotalMinCost > rCurLink.cands[ i ].acumCost )
        {
            dTotalMinCost = rCurLink.cands[ i ].acumCost;
            rCurLink.iBestPath = i;
        }
    }
}

/*****************************************************************************
* CSlmImp::GetAvgF0 *
*-------------------*
*   Description: 
*       
*********************************************************************** WD ***/
void CSlmImp::GetAvgF0()
{
    int iNumTargF0 = 0;
    int iNumSrcF0  = 0;
    m_dAvgTargF0 = 0.0;
    m_dAvgSrcF0  = 0.0;

    for ( int i = 0; i < m_iNumChunks; i++ )
    {
        if ( m_pChunks[ i ].srcF0 > 0 )
        {
            m_dAvgSrcF0 += m_pChunks[ i ].srcF0;
            iNumSrcF0++;
        }

        if ( m_pChunks[ i ].targF0 > 0 )
        {
            m_dAvgTargF0 += m_pChunks[ i ].targF0;
            iNumTargF0++;
        }
    }
    
    if ( iNumSrcF0 > 0 )
    {
        m_dAvgSrcF0 /= iNumSrcF0;
    }
    if ( iNumTargF0 > 0 )
    {
        m_dAvgTargF0 /= iNumTargF0;
    }

}

/*****************************************************************************
* CSlmImp::GetCandicates *
*------------------------*
*   Description: 
*       
*********************************************************************** WD ***/
void CSlmImp::GetCandicates ( int idx, DPList *pDpLink )
{
    DPUnit  dpCand;
    double  dF0;

    pDpLink->targF0Zs =  ( m_pChunks[ idx ].targF0 - m_dAvgTargF0 ) / m_dAvgTargF0;
    pDpLink->iBestPath = 0;

    for ( double d = LOW_F0_RATIO; d <= HIGH_F0_RATIO; d += F0_RATIO_INC )
    {
        memset ( &dpCand, 0, sizeof ( DPUnit ) );
        if ( m_pChunks[ idx ].srcF0 == 0.0 || m_dAvgSrcF0 == 0.0 )
        {
            dpCand.f0Ratio = 1.0;
            pDpLink->cands.push_back ( dpCand );
            break;
        }
        dF0 = m_pChunks[ idx ].srcF0 * d;
        if ( dF0 <= MAX_F0 && dF0 >= MIN_F0 )
        {
            dpCand.f0   = dF0;
            dpCand.f0Zs = ( dF0 - m_dAvgSrcF0 ) / m_dAvgSrcF0;
            dpCand.f0Ratio = d;
            dpCand.modCost = fabs ( 1.0 - d );
            pDpLink->cands.push_back ( dpCand );
        }
    }
}

/*****************************************************************************
* CSlmImp::GetUnitF0Ratio *
*-------------------------*
*   Description:
*       
*********************************************************************** WD ***/
void CSlmImp::GetUnitF0Ratio ()
{

    double dLeftF0;
    double dRightF0;
    double dCurF0;
    double dCenterF0 = 0;

    for ( int i = 0; i < m_iNumChunks; i++ )
    {
        if ( m_pChunks[ i ].srcF0 == 0 )
        {
            continue;
        }

        FindBdrF0 ( &dLeftF0, &dRightF0, i );

        dCurF0 = m_pChunks[ i ].srcF0 * m_pChunks[ i ].f0Ratio;
        
        if ( dCurF0 > 0 )
        {
            if ( dLeftF0 > 0 && dRightF0 > 0 )
            {
                dCenterF0 = ( dCurF0 + dLeftF0 + dRightF0 ) / 3;
            } 
            else if ( dRightF0 > 0 )
            {
                dCenterF0 = ( dCurF0 + dRightF0 ) / 2;
            }
            else if ( dLeftF0 > 0 )
            {
                dCenterF0 = ( dCurF0 + dLeftF0 ) / 2;
            }

            if ( dCenterF0 > 0 )
            {
                m_pChunks[ i ].f0Ratio = dCenterF0 / dCurF0;
            }
        }
    }
}

/*****************************************************************************
* CSlmImp::FindBdrF0 *
*------------------------*
*   Description:
*       
*********************************************************************** WD ***/
void CSlmImp::FindBdrF0 (double* pdLeftF0, double* pdRightF0, int idx)
{
    int i = idx - 1;
    while ( i >= 0 && m_pChunks[ i ].srcF0 == 0 )
    {
        i--;
    }

    if ( i < 0 )
    {
        *pdLeftF0 = -1;
    }
    else
    {
        *pdLeftF0 = m_pChunks[ i ].srcF0 * m_pChunks[ i ].f0Ratio;
    }

    i = idx + 1;
    while ( i < m_iNumChunks && m_pChunks[ i ].srcF0 == 0 )
    {
        i++;
    }

    if ( i >= m_iNumChunks )
    {
        *pdRightF0 = -1;
    }
    else
    {
        *pdRightF0 = m_pChunks[ i ].srcF0 * m_pChunks[ i ].f0Ratio;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\clusters.h ===
/******************************************************************************
* clusters.h *
*------------*
*
*------------------------------------------------------------------------------
*  Copyright (C) 1997  Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef __CLUSTERS_H_
#define __CLUSTERS_H_

#include <vector>

#define MAX_CLUSTER_LEN 12
#define HASHSIZE        36919

struct StateInfo 
{
    char  clusterName[MAX_CLUSTER_LEN];
    float start;
    float dur;
    short rms;
    short f0;
    short lklhood;
    short f0flag;
    int   chunkIdx;
};

struct StateInfoVQ : public StateInfo
{
    short leftVqIdx; /* left vq index */
    short rightVqIdx; /* right vq index */
};

struct SegInfo : public StateInfoVQ
{
    double repDist;    // Distance to cluster centroid
};




struct hashNode 
{
    hashNode();

    const char*  m_pszKey;
    short  m_sF0flag;
    short  m_sF0aver;
    short  m_sRmsaver;
    float  m_fDuraver;
    float  m_fLikaver;
    std::vector<SegInfo*> m_equiv;
    hashNode *m_pNext;
};

class CHash 
{
    public:
        CHash();
        ~CHash();

        bool  Init ();

        hashNode* BuildEntry (const char *pszName);
        hashNode* Find (const char *pszName);
        hashNode* NextEntry(int* iIdx1, int* iIdx2);

    private:
        unsigned int HashValue (unsigned char *pszName);

        hashNode *m_ppHeads[HASHSIZE];
};


class CClusters
{
    public:
        CClusters();
        ~CClusters();

        int  LoadFromFile (FILE* fp);      
        int  LoadGainTable(FILE* fp);      
        int  PreComputeDist(double dDurWeight, double dRmsWeight, double dLklhoodWeight);

        SegInfo* GetBestExample (const char* cluster);

        int  GetEquivalentCount (const char* cluster);
        SegInfo* GetEquivalent(int index);

        int GetStats (const char* cluster, int* f0Flag, double* f0Aver, double* rmsAver, double* durAver);

    private:
        static const int m_iHistMax;
        static const double m_dVerySmallProb;
        bool Init(int iNumSegments);
        int  SetClusterEquivalent (int iIndex, SegInfo* pSeginfo);
        int  ComputeStats (hashNode* cluster);
        static int  ShortCmp (const void *a, const void *b);
        static int  FloatCmp (const void *a, const void *b);

        void Debug();

        SegInfo*  m_pSegments;
        int       m_iNumSegments;
        CHash     m_hash;
        hashNode* m_pFound;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\clusters.cpp ===
/******************************************************************************
* clusters.cpp *
*--------------*
*
*------------------------------------------------------------------------------
*  Copyright (C) 1997  Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "clusters.h"
#include "backendInt.h"
#include <assert.h>
#include <math.h>

const int CClusters::m_iHistMax = 4;
const double CClusters::m_dVerySmallProb = -100000.0;


/*****************************************************************************
* CClusters::CClusters *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
CClusters::CClusters ()
{
    m_pSegments = 0;
}

/*****************************************************************************
* CClusters::~CClusters *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
CClusters::~CClusters ()
{
    if (m_pSegments)
    {
        delete[] m_pSegments;
    }
}
/*****************************************************************************
* CClusters::LoadFromFile *
*-------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClusters::LoadFromFile (FILE* fp)
{
    SegInfo segment;
    int iNumSegments;

    int iUseVq;
    int iReadSize;
    int i;
    
    assert (fp);

    // Number of segments in the file
    if (! fread (&iNumSegments, sizeof(iNumSegments), 1, fp)) 
    {
        return 0;
    }

    if (!Init (iNumSegments))
    {
        return 0;
    }
    
    // VQ info in file or not?

    if (! fread (&iUseVq, sizeof(iUseVq), 1, fp)) 
    {
        return 0;
    }
    iReadSize = iUseVq ? sizeof(StateInfoVQ) : sizeof(StateInfo);
    
    // Read segments
    memset (&segment, 0, sizeof(segment));

    for ( i=0; i<iNumSegments; i++) 
    {
        if (!fread (&segment, iReadSize, 1, fp) )  
        {
            return 0;
        }
        SetClusterEquivalent (i, &segment);
    }

#ifdef _DEBUG_
    Debug();
#endif

    return 1;
}

/*****************************************************************************
* CClusters::Init *
*-----------------*
*   Description:
*
******************************************************************* PACOG ***/
bool CClusters::Init(int iNumSegments)
{
    if ((m_pSegments = new SegInfo[iNumSegments]) != 0)
    {
        m_iNumSegments = iNumSegments;
        return m_hash.Init();
    }

    return false;
}

/*****************************************************************************
* CClusters::SetClusterEquivalent *
*---------------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClusters::SetClusterEquivalent (int iIndex, SegInfo* pSeginfo)
{
    hashNode* node;

    m_pSegments[iIndex] = *pSeginfo;

    if ((node = m_hash.BuildEntry(m_pSegments[iIndex].clusterName)) == 0) 
    {
        return 0;
    }

    node->m_equiv.push_back(&m_pSegments[iIndex]);

    return 1;
}

/*****************************************************************************
* CClusters::GetEquivalentCount *
*-------------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClusters::GetEquivalentCount (const char* cluster)
{
    if ((m_pFound = m_hash.Find(cluster)) != 0)
    {
        if (m_pFound->m_sRmsaver == 0.0) 
        {
            if (!ComputeStats (m_pFound)) 
            {
                return 0;
            }
        }

        return m_pFound->m_equiv.size();
    }
    return 0;
}

/*****************************************************************************
* CClusters::GetEquivalent *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/
SegInfo* CClusters::GetEquivalent(int index)
{
    assert (m_pFound!=0);
    assert (index < m_pFound->m_equiv.size() );

    return m_pFound->m_equiv[index];
}

/*****************************************************************************
* CClusters::GetBestExample *
*---------------------------*
*   Description:
*
******************************************************************* PACOG ***/
SegInfo* CClusters::GetBestExample (const char* cluster)
{
    int iNumEquiv;
    SegInfo* equiv;
    SegInfo* best = 0;

    double lklhood = m_dVerySmallProb;
    double f0dev;
    double rmsdev;
    double durdev;
    int i;
    
    assert (cluster);
    
    if ((iNumEquiv = GetEquivalentCount (cluster)) <=0)
    {
        return 0;
    }
    
    for (i=0; i<iNumEquiv; i++) 
    {      
        equiv = GetEquivalent (i);

        if (equiv->f0flag == 1 && m_pFound->m_sF0aver) 
        {
            f0dev = fabs(equiv->f0 - m_pFound->m_sF0aver) / m_pFound->m_sF0aver;
        }
        else 
        {
            f0dev = 0.0;
        }

        durdev =  fabs(equiv->dur - m_pFound->m_fDuraver) / m_pFound->m_fDuraver;
        rmsdev =  fabs(equiv->rms - m_pFound->m_sRmsaver) / m_pFound->m_sRmsaver;
        
        if ((durdev < 0.2) && (equiv->f0flag == m_pFound->m_sF0flag) && (f0dev < 0.2) && (rmsdev < 0.2)) 
        {            
            if (equiv->lklhood > lklhood) 
            {
                lklhood = equiv->lklhood;
                best = equiv;
            } 
        }       
    }
    
    if (best==NULL) 
    {	
        // Need to relax constraints and look some more? 
        float durcon;
        float rmscon;
        
        for (rmscon = 0.1F ; best==NULL && rmscon < 2.0F; rmscon *= 2.0F) 
        {            
            for (durcon = 0.1F; best==NULL && durcon < 100.0F; durcon *= 2.0F) 
            {
                lklhood = m_dVerySmallProb;
                
                for (i=0; i<iNumEquiv; i++) 
                {
                    durdev = (equiv->dur - m_pFound->m_fDuraver)/m_pFound->m_fDuraver;
                    rmsdev = fabs(equiv->rms - m_pFound->m_sRmsaver)/m_pFound->m_sRmsaver;
                    if ( (durdev >= 0.0) && (durdev < durcon) && (rmsdev < rmscon) ) 
                    { 
                        if (equiv->lklhood > lklhood) 
                        {
                            lklhood = equiv->lklhood;
                            best = equiv;
                        }
                    }
                }                
            }
        }
    }
    
    return best;
}

/*****************************************************************************
* CClusters::GetStats *
*---------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClusters::GetStats (const char* cluster, int* f0Flag, double* f0Aver, double* rmsAver, double* durAver)
{
    hashNode* clustFound;
    
    assert (cluster);
    
    if ((clustFound = m_hash.Find (cluster)) == 0)
    {
        return 0;
    }
    
    if (clustFound->m_sRmsaver == 0) 
    {
        if (!ComputeStats (clustFound)) 
        {
            return 0;
        }
    }
    
    if (f0Flag) 
    {
        *f0Flag = clustFound->m_sF0flag;
    }
    
    if (f0Aver) 
    {
        *f0Aver = clustFound->m_sF0aver;
    }
    
    if (rmsAver) 
    {
        *rmsAver = clustFound->m_sRmsaver;
    }
    
    if (durAver) 
    {
        *durAver = clustFound->m_fDuraver;
    }

    return 1;
}

/*****************************************************************************
* CClusters::LoadGainTable *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClusters::LoadGainTable (FILE* fin)
{
    hashNode* clustFound;
    char cluster[MAX_CLUSTER_LEN];
    float dur;  
    short rms;  
    short f0flag;
    short f0;
    float likl;
    int nRec;
    int i;
    
    assert (fin);
    
    if (!fscanf (fin, "%d\n", &nRec)) 
    {
        return 0;
    }
    
    for (i = 0; i < nRec; i++) 
    {
        fscanf(fin, "%s %f %hd %hd %hd %f\n", cluster, &dur, &f0flag, &f0, &rms, &likl);
        
        if ((clustFound = m_hash.Find(cluster)) == 0) 
        {
            return 0;
        } 

        clustFound->m_fDuraver = dur;
        clustFound->m_sRmsaver = rms;
        clustFound->m_sF0flag  = f0flag;
        clustFound->m_sF0aver  = f0;
        clustFound->m_fLikaver = likl;
    }
    
    return 1;
}

/*****************************************************************************
* CClusters::ComputeStats *
*-------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClusters::ComputeStats (hashNode* cluster)
{
    int hist[m_iHistMax];
    short *f0val;
    float *durval;
    float *likval;
    long rmsacum = 0;
    int iNumEquiv;
    int max;
    
    assert (cluster);

    memset (hist, 0, sizeof(hist));
    
    if ( (iNumEquiv = cluster->m_equiv.size()) > 0) 
    {     
        if ( (f0val = new short[iNumEquiv]) == 0 )
        {
            return 0;
        }
        
        if ( (durval = new float[iNumEquiv]) == 0 )
        {
            return 0;
        }
        
        if ( (likval = new float[iNumEquiv]) == 0 )
        {
            return 0;
        }
        
        for (int i=0; i<iNumEquiv; i++ ) 
        {
            f0val[i]  = cluster->m_equiv[i]->f0;
            durval[i] = cluster->m_equiv[i]->dur;
            likval[i] = cluster->m_equiv[i]->lklhood;
        }
        
        qsort(f0val, iNumEquiv, sizeof(*f0val), ShortCmp);
        qsort(durval, iNumEquiv, sizeof(*durval), FloatCmp);
        qsort(likval, iNumEquiv, sizeof(*likval), FloatCmp);
        
        cluster->m_sF0aver  = f0val[iNumEquiv/2];
        cluster->m_fDuraver = durval[iNumEquiv/2];
        cluster->m_fLikaver = likval[iNumEquiv/2];
        
        delete[] f0val;
        delete[] durval;
        delete[] likval;
        
        for (i=0; i<iNumEquiv; i++) 
        {
            rmsacum += cluster->m_equiv[i]->rms;
            hist[cluster->m_equiv[i]->f0flag + 2]++;
        }
        cluster->m_sRmsaver = rmsacum/iNumEquiv;
        
        cluster->m_sF0flag = 0;
        max = 0;

        for (i=0; i<m_iHistMax; i++) 
        {
            if (hist[i]>max) 
            {
                max = hist[i];
                cluster->m_sF0flag = i-2;
            }
        }
        
    }
    
    return 1;
}

/*****************************************************************************
* hashNode::hashNode *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/
hashNode::hashNode()
{
    m_pszKey   = 0;
    m_sF0flag  = 0;
    m_sF0aver  = 0;
    m_sRmsaver = 0;
    m_fDuraver = 0.0;
    m_fLikaver = 0.0;
    m_pNext    = 0;
}

/*****************************************************************************
* CHash::HashValue *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/

unsigned int CHash::HashValue (unsigned char *name)
{
    assert (name);

    for (unsigned int h=0; *name ; name++) 
    {
        h = (64*h + *name) % HASHSIZE;
    }

    return h;
}

/*****************************************************************************
* CHash::CHash *
*--------------*
*   Description:
*
******************************************************************* PACOG ***/
CHash::CHash()
{
    memset (m_ppHeads, 0, sizeof(m_ppHeads));
}

/*****************************************************************************
* CHash::~CHash *
*---------------*
*   Description:
*
******************************************************************* PACOG ***/
CHash::~CHash ()
{
    hashNode* busy;
    hashNode* empty;
    
    for (int i=0; i<HASHSIZE; i++) 
    {
        busy = m_ppHeads[i];
            
        while (busy->m_pNext)
        {
            empty = busy;
            busy  = busy->m_pNext;
            delete empty;
        }    
        delete busy;
    }
}

/*****************************************************************************
* CHash::Init *
*-------------*
*   Description:
*
******************************************************************* PACOG ***/

bool CHash::Init ()
{
    for (int i=0; i < HASHSIZE; i++) 
    {
        if ( (m_ppHeads[i] = new hashNode) == 0)
        {
            return false;
        }
    }
    return true;
}

/*****************************************************************************
* CHash::BuildEntry *
*-------------------*
*   Description:
*
******************************************************************* PACOG ***/

struct hashNode* CHash::BuildEntry (const char *name)
{
    hashNode* x;
    hashNode* t;

    assert (name);

    if (name && *name) 
    {

        t = m_ppHeads[ HashValue((unsigned char*)name)];
        
        while (t->m_pNext) 
        {
            if (strcmp (t->m_pNext->m_pszKey, name) == 0) 
            {
                break;
            }
            t = t->m_pNext;
        }
    
        if (t->m_pNext) 
        {
            return t->m_pNext;
        }

        if ((x = new hashNode) != 0)
        {
            x->m_pNext = t->m_pNext;
            t->m_pNext = x;
            x->m_pszKey = name;

            return x;
        }
    }

    return 0;
}

/*****************************************************************************
* CHash::Find *
*-------------*
*   Description:
*
******************************************************************* PACOG ***/

hashNode* CHash::Find (const char *name)
{
    hashNode* t;

    assert (name);

    t = m_ppHeads[HashValue((unsigned char*)name)]; 

    while (t->m_pNext) 
    {
        if ( strcmp(t->m_pNext->m_pszKey, name) == 0 ) 
        {
            return t->m_pNext;
        }
        t = t->m_pNext;
    }

    return 0;
}

/*****************************************************************************
* CHash::NextEntry *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/

hashNode* CHash::NextEntry(int* idx1, int* idx2)
{
    hashNode* node;
    int i;

    assert (idx1);
    assert (idx2);
        
    while (*idx1 < HASHSIZE ) 
    {
        if ((node = m_ppHeads[*idx1]->m_pNext) != 0) 
        {

            for ( i=0; i<*idx2 && node->m_pNext; i++) 
            {
                node = node->m_pNext;
            }

            if (i==*idx2) 
            {
                (*idx2)++;
                return node;
            }
        }

        (*idx1)++;	
        *idx2 = 0;
    }    

    return 0;
}


/*****************************************************************************
* CClusters::Debug *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/
void CClusters::Debug()
{    
    for (int i=0; i<m_iNumSegments; i++) 
    {
        printf ("%s %d %d %f %f %d %d %d %f %d %d\n", 
                m_pSegments[i].clusterName,
                m_pSegments[i].chunkIdx,
                m_pSegments[i].f0flag,
                m_pSegments[i].start,
                m_pSegments[i].dur,
                m_pSegments[i].f0,
                m_pSegments[i].rms,
                m_pSegments[i].lklhood,
                m_pSegments[i].leftVqIdx,
                m_pSegments[i].rightVqIdx);
    }
}

/*****************************************************************************
* CClusters::PreComputeDist *
*---------------------------*
*   Description:
*       Pre-compute some of the distances used in the dynamic search of units
******************************************************************* PACOG ***/
int CClusters::PreComputeDist(double dDurWeight, double dRmsWeight, double dLklhoodWeight)
{
    hashNode* cluster;
    double durDev;
    double rmsDev;
    double lklhood;
    
    for (int i=0; i<m_iNumSegments; i++)
    {
        if ((cluster = m_hash.Find (m_pSegments[i].clusterName)) == 0)
        {
            return 0;
        }
        if (cluster->m_fDuraver == 0)
        {
            ComputeStats (cluster);
        }
        
        durDev =  fabs(m_pSegments[i].dur - cluster->m_fDuraver)/cluster->m_fDuraver;
        rmsDev =  fabs(m_pSegments[i].rms - cluster->m_sRmsaver)/cluster->m_sRmsaver;
        lklhood = -(m_pSegments[i].lklhood - cluster->m_fLikaver) * sqrt(m_pSegments[i].dur);
    
        m_pSegments[i].repDist = dDurWeight * durDev + dRmsWeight * rmsDev + dLklhoodWeight * lklhood;
    }
 
    return 1;
}

/*****************************************************************************
* CClusters::FloatCmp *
*---------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CClusters::FloatCmp ( const void *a, const void  *b )
{
    float acum;
    
    assert (a);
    assert (b);
    
    acum = *((float*)a) - *((float*)b);
    
    if ( acum>0.0) 
    {
        return 1;
    }
    
    if ( acum<0.0) 
    {
        return -1;
    }
    
    return 0;
}
/*****************************************************************************
* CClusters::ShortCmp *
*---------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CClusters::ShortCmp ( const void *a, const void  *b )
{
    assert (a);
    assert (b);
    
    return  *((short*)a) - *((short*)b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\speakerdata.cpp ===
/******************************************************************************
* SpeakerData.cpp *
*-----------------*
*
*------------------------------------------------------------------------------
*  Copyright (c) 1997  Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "SpeakerData.h"
#include "UnitSearch.h"
#include "clusters.h"
#include "trees.h"
#include "VqTable.h"
#include "BeVersion.h"
#include "vapiio.h"
#include "SynthUnit.h"
#include "BackEnd.h"
#include <assert.h>

#ifdef WIN32
#include <fcntl.h>
#endif

#define MAX_LINE 512

struct UnitSamples 
{
    char*    samples;
    int      nSamples;
    Epoch*   epochs;
    int      nEpochs;
};

CList<CSpeakerData*> CSpeakerData::m_speakers;
CComAutoCriticalSection CSpeakerData::m_critSect;

/*****************************************************************************
* CSpeakerData::ClassFactory *
*----------------------------*
*   Description:
*
******************************************************************* PACOG ***/
CSpeakerData* CSpeakerData::ClassFactory (const char* pszFileName, bool fCheckVersion)
{
    CSpeakerData* pSpkrData = 0;

    assert (pszFileName);

    m_critSect.Lock();

    if ((m_speakers.Find(pszFileName, pSpkrData)) != 0)
    {
        pSpkrData->AddRef();
    }
    else if (( pSpkrData = new CSpeakerData(pszFileName) ) != 0)
    {
        m_speakers.PushBack(pszFileName, pSpkrData);
        pSpkrData->AddRef();


        if (!pSpkrData->Load (fCheckVersion) )
        {
            delete pSpkrData;
            pSpkrData = 0;
        }
    }

    m_critSect.Unlock();

    return pSpkrData;
}
/*****************************************************************************
* CSpeakerData::AddRef *
*-------------------------*
*   Description:
*
******************************************************************* PACOG ***/
void CSpeakerData::AddRef()
{
    m_iRefCount++;
}
/*****************************************************************************
* CSpeakerData::Release *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
void CSpeakerData::Release() 
{
    if (--m_iRefCount == 0) 
    {
        delete this;
    }
}

/*****************************************************************************
* CSpeakerData::CSpeakerData *
*----------------------------*
*   Description:
*
******************************************************************* PACOG ***/
CSpeakerData::CSpeakerData (const char* pszFileName)
{
    strcpy(m_pszFileName, pszFileName);
    m_iRefCount = 0;
    m_iSampFreq = 0;
    m_iFormat = 0;
    
    m_pTrees = 0;
    m_pClusters = 0;
    m_pVq = 0;
    
    m_ttpPar.baseLine = 0;
    m_ttpPar.refLine = 0;
    m_ttpPar.topLine = 0;

    m_pFileNames = 0;
    m_iNumFileNames = 0;
    m_pUnits = 0;
    m_iNumUnits= 0;    
    m_dRumTime = 0;
    m_fWaveConcat = false;
    m_fMSPhoneSet = false;
    m_fMSEntropic = false;
}

/*****************************************************************************
* CSpeakerData::~CSpeakerData *
*-----------------------------*
*   Description:
*
******************************************************************* PACOG ***/
CSpeakerData::~CSpeakerData ()
{    

    m_critSect.Lock();
    for (int i = 0; i<m_speakers.Size(); i++)
    {
        if (m_speakers[i] == this)
        {
            m_speakers.Remove(i);
        }
    }
    m_critSect.Unlock();
    
    delete m_pVq;
    delete m_pTrees;
    delete m_pClusters;   
    FreeSamples();
}

/*****************************************************************************
* CSpeakerData::Load *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CSpeakerData::Load (bool fCheckVersion)
{
    FILE* fin;
    char line[MAX_LINE +1];

#ifdef WIN32
    _fmode = _O_BINARY;
#endif
    
    fin = fopen (m_pszFileName, "r");

#ifdef WIN32
    _fmode = _O_TEXT;
#endif

    if (!fin) 
    {
        return 0;
    }

    if (fCheckVersion)
    {
        BendVersion bVers;
         
        if (! bVers.CheckVersionString(fin) )
        {
            goto end;
        }
    }     

    if ((m_pTrees = CClustTree::ClassFactory()) == 0) 
    {
        goto end;
    }

    if (!m_pTrees->LoadFromFile (fin)) {
        goto end;
    }
  
    if ((m_pClusters = new CClusters) == 0)
    {
        goto end;
    }

    if (!m_pClusters->LoadFromFile(fin)) 
    {
        goto end;
    }

    while (fgets (line, MAX_LINE, fin)) 
    {        
        // Gain table, vq table and ttp params are optional
        if (strcmp(line, "#Slm Weights\n") == 0) 
        {
            if (!LoadWeights (fin)) 
            {
                goto end;
            }
        } 
        else if (strcmp(line, "#Slm New Weights\n") == 0) 
        {
            if (!LoadNewWeights (fin)) 
            {
                goto end;
            }
        } 
        else if ( strcmp(line, "#Waveform Concatenation\n") == 0) 
        {
            m_fWaveConcat = true;
        }
        else if ( strcmp(line, "#MS Phone Set\n") == 0) 
        {
            m_fMSPhoneSet = true;
        }
        else if ( strcmp(line, "#Slm AvgGain Table\n") == 0) 
        {
            if (!m_pClusters->LoadGainTable (fin)) 
            {
                goto end;
            } 
        } 
        else if ( strcmp(line, "#Slm VQ Table\n") == 0) 
        {
            if ((m_pVq = new CVqTable) == 0) 
            {
                goto end;
            }
    
            if (!m_pVq->LoadFromFile(fin)) 
            {
                goto end;
            } 
        } 
        else if ( strcmp(line, "#Ttp Params\n") == 0) 
        {
            if (!LoadTtpParam (fin)) 
            {
                goto end;
            }
        } 
        else if ( strcmp(line, "#Samples\n") == 0) 
        {
            if (!LoadSamples (fin)) 
            {
                goto end;
            }
        } 
        else if ( strcmp(line, "#File names\n") == 0) 
        {
            if (!LoadFileNames (fin)) 
            {
                goto end;
            }
        } 
        else 
        {
            goto end;
        }
    } 

    return 1;

end:
    return 0;
}

/*****************************************************************************
* CSpeakerData::LoadFileNames *
*--------------------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CSpeakerData::LoadFileNames (FILE* fp)
{
    char fileName[_MAX_PATH+1];
    
    assert (fp);
    
    if (fscanf (fp, "%d\n", &m_iNumFileNames)!=1) 
    {
        return 0;
    }

    if ((m_pFileNames = new CDynString[m_iNumFileNames]) == 0)
    {
        return 0;
    }

    for (int i=0; i<m_iNumFileNames; i++) 
    {
        if (fscanf (fp, "%s\n", fileName) != 1) 
        {
            return 0;
        }

        m_pFileNames[i] = fileName;
    }
        
    return 1;
}

/*****************************************************************************
* CSpeakerData::LoadTtpParam *
*----------------------------*
*   Description:
*       Loads the Text-to-Prosody Parameters
******************************************************************* PACOG ***/
int CSpeakerData::LoadTtpParam (FILE* fin)
{
  assert (fin);

  if (!fread (&m_ttpPar, sizeof (m_ttpPar), 1, fin)) 
  {
    return 0;
  } 

  return 1;
}

/*****************************************************************************
* CSpeakerData::LoadWeights *
*---------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CSpeakerData::LoadWeights (FILE* fin)
{
    assert (fin);
    
    if (!fread (&m_weights, sizeof (WeightsBasic), 1, fin)) 
    {
        return 0;
    }

    m_weights.f0Bdr = 0.2F;
    m_weights.phBdr = 0.4F;

    return 1;
}

/*****************************************************************************
* CSpeakerData::LoadNewWeights *
*------------------------------*
*   Description:
*
******************************************************************* WD    ***/
int CSpeakerData::LoadNewWeights (FILE* fin)
{
    assert (fin);
    
    if (!fread (&m_weights, sizeof (m_weights), 1, fin)) 
    {
        return 0;
    }

    return 1;
}

/*****************************************************************************
* CSpeakerData::PreComputeDist *
*------------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSpeakerData::PreComputeDist()
{
    m_critSect.Lock();
    if (m_pClusters)
    {
        m_pClusters->PreComputeDist(m_weights.dur, m_weights.rms, m_weights.lkl);
    }
    if (m_pVq) 
    {
        m_pVq->Scale (m_weights.cont);
    }
    m_critSect.Unlock();
}

/*****************************************************************************
* CSpeakerData::GetTtpParam *
*---------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSpeakerData::GetTtpParam (int* piBaseLine, int* piRefLine, int* piTopLine)
{
    assert (piBaseLine && piRefLine && piTopLine);

    *piBaseLine = m_ttpPar.baseLine;
    *piRefLine  = m_ttpPar.refLine;
    *piTopLine  = m_ttpPar.topLine;
}



/*****************************************************************************
* CSpeakerData::LoadSamples *
*------------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CSpeakerData::LoadSamples (FILE* fin)
{
    int sampSize;
    
    assert (fin);

    if (!fread (&m_iNumUnits, sizeof(m_iNumUnits), 1, fin)) 
    {
        return 0;
    }

    if (!fread (&m_iFormat, sizeof(m_iFormat), 1, fin)) 
    {
        return 0;
    }

    sampSize = VapiIO::SizeOf (m_iFormat);

    if (!fread (&m_iSampFreq, sizeof(m_iSampFreq), 1, fin)) 
    {
        return 0;
    }

    if ((m_pUnits = new UnitSamples[m_iNumUnits]) == 0) 
    {
        return 0;
    }

    for (int i=0; i<m_iNumUnits; i++) 
    {
        if (!fread (&m_pUnits[i].nSamples, sizeof (int), 1, fin)) {
            return 0;
        }

        if ((m_pUnits[i].samples = new char[m_pUnits[i].nSamples * sampSize]) == 0)
        {
            return 0;
        }

        if (fread (m_pUnits[i].samples, sampSize, m_pUnits[i].nSamples, fin) != (unsigned)m_pUnits[i].nSamples) 
        {
            return 0;
        }

        if (!fread (&m_pUnits[i].nEpochs, sizeof (int), 1, fin)) 
        {
            return 0;
        }

        if ((m_pUnits[i].epochs = new Epoch[m_pUnits[i].nEpochs]) == 0)
        {
            return 0;
        }

        if (fread (m_pUnits[i].epochs , sizeof(Epoch), m_pUnits[i].nEpochs, fin) != (unsigned)m_pUnits[i].nEpochs) 
        {
            return 0;
        }

    }   
    
    return 1;
}


/*****************************************************************************
* CSpeakerData::FreeSamples *
*------------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CSpeakerData::FreeSamples ()
{
  
    if (m_pUnits) 
    {
        for (int i=0; i<m_iNumUnits; i++) 
        {
            if (m_pUnits[i].samples) 
            {
                delete[] m_pUnits[i].samples;
            }
            if (m_pUnits[i].epochs) 
            {
                delete[] m_pUnits[i].epochs;
            }
        }
        delete[] m_pUnits;
        m_pUnits  = NULL;
    }
    m_iNumUnits = 0;
}

/*****************************************************************************
* CSpeakerData::GetSampFreq *
*---------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CSpeakerData::GetSampFreq ()
{
    return m_iSampFreq;
}
/*****************************************************************************
* CSpeakerData::GetSampFormat *
*-----------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CSpeakerData::GetSampFormat ()
{
    return m_iFormat;
}

/*****************************************************************************
* CSpeakerData::GetUnit *
*-----------------------*
*   Description:
*       
******************************************************************* PACOG ***/
CSynth* CSpeakerData::GetUnit (ChkDescript* pDescript)
{
    CSynth* pSynth;

    assert (pDescript);

    if (pDescript->isFileName)
    {
        pSynth = UnitFromFile (pDescript);
    }
    else 
    {
        pSynth = UnitFromMemory (pDescript);
    }

    return pSynth;
}

/*****************************************************************************
* CSpeakerData::UnitFromFile *
*----------------------------*
*   Description:
*
******************************************************************* PACOG ***/

CSynth* CSpeakerData::UnitFromFile (ChkDescript* chunk)
{
    CSynth* pUnit;
    short *psSamples = NULL;
    int   iNumSamples;
    Epoch* pEpochs;
    int   iNumEpochs;
    int iSampFreq;
    int i;
  
    assert (chunk);
  
    if ( !ReadSamples(chunk->chunk.fileName, chunk->from, chunk->to,  
                      &psSamples, &iNumSamples, &pEpochs, &iNumEpochs, &iSampFreq) ) 
    {
        fprintf (stderr, "Error accessing file  %s\n", chunk->chunk.fileName);
    }
  
    if ((pUnit = new CSynth(iSampFreq)) == 0)
    {
        return 0;
    }

    if ((pUnit->m_pdSamples = new double[pUnit->m_iNumSamples]) == 0) 
    {
        return 0;
    }
    for (i=0; i<pUnit->m_iNumSamples; i++) 
    {
        pUnit->m_pdSamples[i] = psSamples[i];
    }
    delete []psSamples;

    pUnit->m_iNumSamples = iNumSamples;
    pUnit->m_pEpochs     = pEpochs;
    pUnit->m_iNumEpochs  = iNumEpochs;

    //Override sampling frequency and sample format
//    m_iSampFreq   = iSampFreq;
//    m_iSampFormat = VAPI_PCM16;

    strcpy ( pUnit->m_pszChunkName, chunk->name );

    pUnit->m_dF0Ratio  = chunk->f0Ratio;
    pUnit->m_dGain = chunk->gain;
/* --- use unit duration as target duration
    if ( m_fWaveConcat )
    {
        m_dRumTime += pEpochs[ iNumEpochs - 1 ].time;
        pUnit->m_dRunTimeLimit = m_dRumTime;
    }
    else
    {
        pUnit->m_dRunTimeLimit = chunk->end;
    }
*/
    pUnit->m_dRunTimeLimit = chunk->end;

    return pUnit;
}  

/*****************************************************************************
* CSpeakerData::UnitFromMemory *
*------------------------------*
*   Description:
*
******************************************************************* PACOG ***/

CSynth* CSpeakerData::UnitFromMemory (ChkDescript* pChunk)
{
    CSynth* pUnit;
    UnitSamples* pUSamples;
    int iFirstEpoch;
    int iLastEpoch;
    int firstSamp;
    int lastSamp;
    double from;
    double to;
    int i;
  
    assert (pChunk);

    if ((pUnit = new CSynth(m_iSampFreq)) == 0)
    {
        return 0;
    }

    if (!m_pUnits || pChunk->chunk.chunkIdx<0 || pChunk->chunk.chunkIdx>=m_iNumUnits) 
    {
        return 0;
    }
    pUSamples = m_pUnits + pChunk->chunk.chunkIdx;
    
    strcpy ( pUnit->m_pszChunkName, pChunk->name );

    from = pChunk->from;
    to   = pChunk->to;

    do 
    {
        for (iFirstEpoch=0; iFirstEpoch<pUSamples->nEpochs && from > pUSamples->epochs[iFirstEpoch].time; iFirstEpoch++) 
        {
            //Empty block
        }
        if (iFirstEpoch && from < pUSamples->epochs[iFirstEpoch].time) 
        {
            iFirstEpoch--;
        }
      
        for (iLastEpoch = iFirstEpoch; iLastEpoch<(pUSamples->nEpochs-1) && to > pUSamples->epochs[iLastEpoch].time; iLastEpoch++) 
        {
            //Empty block
        }
      
        pUnit->m_iNumEpochs = iLastEpoch - iFirstEpoch +1;
        from-= 0.005;
        to += 0.005;

    } 
    while (pUnit->m_iNumEpochs < 3 && (iFirstEpoch >0  || iLastEpoch < (pUSamples->nEpochs -1)));
    
    if ((pUnit->m_pEpochs = new Epoch[pUnit->m_iNumEpochs]) == NULL) 
    {
        return 0;
    }
    memcpy(pUnit->m_pEpochs, pUSamples->epochs + iFirstEpoch, pUnit->m_iNumEpochs * sizeof(*pUnit->m_pEpochs));
    
    firstSamp = (int)(pUnit->m_pEpochs[0].time * m_iSampFreq);
    lastSamp  = (int)(pUnit->m_pEpochs[pUnit->m_iNumEpochs-1].time * m_iSampFreq + 0.5);

    if (lastSamp >= pUSamples->nSamples) {
      lastSamp = pUSamples->nSamples -1;
    }

    pUnit->m_iNumSamples = lastSamp - firstSamp +1;
    
    if ((pUnit->m_pdSamples = new double[pUnit->m_iNumSamples]) == 0) 
    {
        return 0;
    }

    {
        char*  pcInPtr;
        short* pnBuffer;

        // pUSamples->samples is a char*, add correct number of bytes.
        pcInPtr = pUSamples->samples + (firstSamp * VapiIO::SizeOf(m_iFormat));

        if (m_iFormat != VAPI_PCM16) 
        {
            if ((pnBuffer = new short[pUnit->m_iNumSamples]) == 0) 
            {
                return 0;
            }

            VapiIO::DataFormatConversion (pcInPtr, m_iFormat, (char*)pnBuffer, VAPI_PCM16, pUnit->m_iNumSamples);
        }
        else 
        {
            pnBuffer = (short*)pcInPtr;
        }

        for (i=0; i< pUnit->m_iNumSamples; i++) 
        {
            pUnit->m_pdSamples[i] = (double)pnBuffer[i];
        }

        if (pnBuffer != (short*)pcInPtr) 
        {
            delete[] pnBuffer;
        }
    }
  
    for (i=0; i<pUnit->m_iNumEpochs; i++) 
    {
        pUnit->m_pEpochs[i].time -= (firstSamp /(double)m_iSampFreq);
    }
    
    pUnit->m_dF0Ratio = pChunk->f0Ratio;
    pUnit->m_dGain = pChunk->gain;
/* --- use unit duration as target duration
    if ( m_fWaveConcat )
    {
        m_dRumTime += pUnit->m_pEpochs[pUnit->m_iNumEpochs-1].time;
        pUnit->m_dRunTimeLimit = m_dRumTime;
    }
    else
    {
        pUnit->m_dRunTimeLimit = pChunk->end;
    }
*/
    pUnit->m_dRunTimeLimit = pChunk->end;

    return pUnit;
}


/*****************************************************************************
* CSpeakerData::ReadSamples *
*---------------------------*
*   Description:
*       Given some basic information about unit required, it reads the unit in
*       and gets the epochs and the samples
******************************************************************* PACOG ***/

int CSpeakerData::ReadSamples (const char* pszPathName, // Base file with directory path 
                               double dFrom,          // Starting time of unit 
                               double dTo,            // Ending time of unit 
                               short** ppnSamples,      // Read samples 
                               int* piNumSamples,        // Number of samples read
                               Epoch** ppEpochs,       // Array of Epochs 
                               int* piNumEpochs,         // Number of Epochs read 
                               int* piSampFreq)        // Sampling Frequence 
{
    VapiIO* pViof = 0;
    int iRetVal = VAPI_IOERR_NOERROR;
    int iSampFormat;
    Epoch* pEpochBuffer = NULL;
    int iNumReadEpochs;
    int iFirstEpoch;
    int iLastEpoch;
    double dStartTime;
    char* pcBuffer = 0;
    int i;
    
    assert (pszPathName);
    assert (dFrom>=0.0);
    assert (dTo == -1.0 || dTo >= dFrom);
    assert (ppnSamples);
    assert (piNumSamples);
    assert (ppEpochs);
    assert (piNumEpochs);
    assert (piSampFreq);
    
    if (( pViof = VapiIO::ClassFactory()) == 0) 
    {
        iRetVal = VAPI_IOERR_MEMORY;
        goto error;
    }

    
    if ( (iRetVal = pViof->OpenFile (pszPathName, VAPI_IO_READ)) != VAPI_IOERR_NOERROR) 
    {
        goto error;
    }
    
    if ( (iRetVal = pViof->Format (piSampFreq, &iSampFormat)) != VAPI_IOERR_NOERROR) 
    {
        goto error;
    }
    
    // Read epochs first

    if ((iRetVal = pViof->ReadEpochs(&pEpochBuffer, &iNumReadEpochs)) != VAPI_IOERR_NOERROR) 
    {
        goto error;
    }
    
    do 
    {
        for (iFirstEpoch = 0; iFirstEpoch < iNumReadEpochs && 
                             dFrom > pEpochBuffer[iFirstEpoch].time; iFirstEpoch++) 
        {
            //Empty loop
        } 

        if (iFirstEpoch && dFrom < pEpochBuffer[iFirstEpoch].time) 
        {
            iFirstEpoch--;
        }
        
        if (iFirstEpoch >= iNumReadEpochs) 
        {
            iFirstEpoch--;
        }
        
        for (iLastEpoch = iFirstEpoch; iLastEpoch < iNumReadEpochs && 
                                     dTo > pEpochBuffer[iLastEpoch].time; iLastEpoch++) 
        {
            //Emtpy loop
        }
        
        if (iLastEpoch >= iNumReadEpochs) 
        {
            iLastEpoch--;
        }
        
        *piNumEpochs = iLastEpoch  - iFirstEpoch + 1;
        dFrom -= 0.005;
        dTo   += 0.005;
    } 
    while (*piNumEpochs < 3 && (iFirstEpoch > 0  || iLastEpoch < (iNumReadEpochs -1)));
    
    if ((*ppEpochs = new Epoch[*piNumEpochs]) == 0) 
    {
        iRetVal = VAPI_IOERR_MEMORY;
        goto error;
    }
    memcpy (*ppEpochs, pEpochBuffer + iFirstEpoch, *piNumEpochs * sizeof (**ppEpochs));
    
    dFrom = pEpochBuffer[iFirstEpoch].time;
    dTo   = pEpochBuffer[iLastEpoch].time;
    
    // CAREFUL! We need to reset the epochs to the starting time
    // of the chunk! 
    
    dStartTime =  ((int)(dFrom * *piSampFreq))/ (double)*piSampFreq;
    for (i=0; i<*piNumEpochs; i++) 
    {
        (*ppEpochs)[i].time -= dStartTime;
    }
    
    delete[] pEpochBuffer;
    pEpochBuffer = NULL;
    
    if ( (iRetVal = pViof->ReadSamples (dFrom, dTo, (void**)&pcBuffer, piNumSamples, 1)) != VAPI_IOERR_NOERROR) 
    {
        goto error;
    }
    
    pViof->CloseFile ();
    delete pViof;
    pViof = 0;
    
    // Convert the samples to output format

    if ( (*ppnSamples = (short*)new char [*piNumSamples * VapiIO::SizeOf(VAPI_PCM16)]) == NULL) 
    {
        iRetVal = VAPI_IOERR_MEMORY;
        goto error;
    }
    
    VapiIO::DataFormatConversion ((char *)pcBuffer, iSampFormat, (char*) *ppnSamples, VAPI_PCM16, *piNumSamples);
    delete[] pcBuffer;
    
    return 1; 
    
error:
    
    if (pViof) {
        pViof->CloseFile ();
        delete pViof;
    }
    
    if (pEpochBuffer) 
    {
        delete[] pEpochBuffer;
    }
    
    if (pcBuffer) 
    {
        delete[] pcBuffer;
    }
    
    return iRetVal;
}

/*****************************************************************************
* CSpeakerData::SetF0Weight *
*--------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void  CSpeakerData::SetF0Weight (float fWeight)
{
    m_weights.f0 = fWeight;
}

/*****************************************************************************
* CSpeakerData::SetDurWeight *
*---------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void  CSpeakerData::SetDurWeight (float fWeight)
{
    m_weights.dur = fWeight;
}

/*****************************************************************************
* CSpeakerData::SetRmsWeight *
*---------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void  CSpeakerData::SetRmsWeight (float fWeight)
{
    m_weights.rms = fWeight;
}

/*****************************************************************************
* CSpeakerData::SetLklWeight *
*---------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void  CSpeakerData::SetLklWeight (float fWeight)
{
    m_weights.lkl = fWeight;
}

/*****************************************************************************
* CSpeakerData::SetContWeight *
*----------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void  CSpeakerData::SetContWeight (float fWeight)
{
    m_weights.cont = fWeight;
}

/*****************************************************************************
* CSpeakerData::SetSameWeight *
*----------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void  CSpeakerData::SetSameWeight (float fWeight)
{
    m_weights.sameSeg = fWeight;
}

/*****************************************************************************
* CSpeakerData::SetPhBdrWeight *
*------------------------------*
*   Description:
*       
******************************************************************* WD    ***/
void  CSpeakerData::SetPhBdrWeight (float fWeight)
{
    m_weights.phBdr = fWeight;
}

/*****************************************************************************
* CSpeakerData::SetF0BdrWeight *
*------------------------------*
*   Description:
*       
******************************************************************* WD    ***/
void  CSpeakerData::SetF0BdrWeight (float fWeight)
{
    m_weights.f0Bdr = fWeight;
}

/*****************************************************************************
* CSpeakerData::GetWeights *
*--------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
Weights CSpeakerData::GetWeights ()
{
    return m_weights;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\speakerdata.h ===
/******************************************************************************
* SpeakerData.h *
*---------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/
#ifndef __SPEAKERDATA_H_
#define __SPEAKERDATA_H_

#include "list.h"
#include "unitsearch.h"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <atlbase.h>

struct Epoch;
struct SegInfo;
struct UnitSamples;
struct ChkDescript;

class  CClustTree;
class  CClusters;
class  CVqTable;
class  CSynth;

// Defines parameters that are set for a defined voice
// and the front end needs to know about.
struct TtpParam
{
    //Pitch Related pars.
    short baseLine;
    short refLine;
    short topLine;
};

class CSpeakerData 
{
    friend class CUnitSearch;

    public:
        static CSpeakerData* ClassFactory(const char* pszFileName, bool fCheckVersion);
        void AddRef();
        void Release();

        const char* Name();
        int   GetSampFreq ();
        int   GetSampFormat ();

        void  SetF0Weight   (float fWeight);
        void  SetDurWeight  (float fWeight);
        void  SetRmsWeight  (float fWeight);
        void  SetLklWeight  (float fWeight);
        void  SetContWeight (float fWeight);
        void  SetSameWeight (float fWeight);
        void  SetPhBdrWeight (float fWeight);
        void  SetF0BdrWeight (float fWeight);
        bool  GetSynthMethod () { return m_fWaveConcat;}
        bool  GetPhoneSetFlag () { return m_fMSPhoneSet;}
        void  SetFrontEndFlag () { m_fMSEntropic = true; }
        bool  GetFrontEndFlag () { return m_fMSEntropic; }
        void  ResetRunTime () {m_dRumTime = 0;}

        void  PreComputeDist();
        void  GetTtpParam (int* piBaseLine, int* piRefLine, int* piTopLine);

        int   GetStateCount (const char* pszCluster);
        int   GetEquivalentCount (const char* pszCluster, int iStateNum);
        int   GetEquivalent(SegInfo** ppSegInfo); 
        
        CSynth* GetUnit (ChkDescript* pChunk); 

        Weights GetWeights ();

    private:
        CSpeakerData(const char* pszFileName);
        ~CSpeakerData();

        int  Load (bool fCheckVersion);
        int  LoadFileNames (FILE* fp);
        int  LoadTtpParam  (FILE* fp);
        int  LoadWeights   (FILE* fp);
        int  LoadNewWeights   (FILE* fp);
        int  LoadSamples   (FILE* fp);
        void FreeSamples  ();

        CSynth* UnitFromFile   (ChkDescript* pChunk); 
        CSynth* UnitFromMemory (ChkDescript* pChunk); 
        
        int  ReadSamples  (const char* pszPathName, double dFrom, double dTo,   
                           short** ppnSamples, int* piNumSamples,   
                           Epoch** ppEpochs, int* piNumEpochs, int* piSampFreq);


        // Member data
        static CList<CSpeakerData*> m_speakers;
        static CComAutoCriticalSection m_critSect;

        char m_pszFileName[_MAX_PATH+1];
        int  m_iRefCount;
        int  m_iSampFreq;
        int  m_iFormat;
        double m_dRumTime;

        CClustTree*   m_pTrees;
        CClusters*    m_pClusters;
        TtpParam      m_ttpPar;
        CVqTable*     m_pVq;
        CDynString*   m_pFileNames;
        int           m_iNumFileNames;
        UnitSamples*  m_pUnits;
        int           m_iNumUnits;    
        Weights       m_weights;
        bool          m_fWaveConcat;
        bool          m_fMSPhoneSet;
        bool          m_fMSEntropic; // do we use MS_Entropic FrontEnd

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\synthunit.h ===
/******************************************************************************
* SynthUnit.h *
*-------------*
*
*------------------------------------------------------------------------------
*  Copyright (C) 1996  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef __SYNTHUNIT_H_
#define __SYNTHUNIT_H_

#include <vector>

struct Epoch;
struct NewF0Struct;

class CSynth 
{
    friend class CTips;
    friend class CSpeakerData;

    public:
        CSynth(int iSampFreq);
        ~CSynth();

        int  LpcAnalysis (int iSampFreq, int iOrder);
        int  FindPrecedent ();
        int  NextBuffer (CTips* pTips);
        void GetNewF0 (std::vector<NewF0Struct>* pvNewF0, double* pdTime, double* pdRunTime );

    protected:
        double* GetDurbinCoef(double* data, int nData);
        void FreeLpcCoef();
        short ClipData (double x);

        int     m_iSampFreq;
        // Read from the input files 
        double  m_dRunTimeLimit;
        double  m_dGain;          // Gain to aply to the whole segment

        // Read from the database 
        char    m_pszChunkName[256];
        int     m_iNumSamples;
        double* m_pdSamples;
        int     m_iNumEpochs;
        Epoch*  m_pEpochs;

        // Computed for synthesis 
        double* m_pdSynEpochs;    // Synthesis epoch track
        int*    m_piMapping;  
        int     m_iNumSynEpochs;

        // For lpc synthesis
        double** m_ppdLpcCoef;
        int      m_iLpcOrder;

        //While synthesizing, tracks current epoch
        int  m_iCurrentPeriod;
        int  m_iRepetitions;
        int  m_iInvert;

        // For Wave Concatenation Synth
        double   m_dF0Ratio;


};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\synthunit.cpp ===
/******************************************************************************
* SynthUnit.cpp *
*---------------*
*
*------------------------------------------------------------------------------
*  Copyright (C) 1996  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "SynthUnit.h"
#include "tips.h"
#include <sigproc.h>
#include <assert.h>
#include <string.h>
#include <vapiIo.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <limits.h>
#include <assert.h>

#include "ftol.h"

/*
 * This is the internal frequency at which the prosody module works.
 * This value of samp freq. is arbitary. We chose 44100 for high resolution
 */
#define TIME_STEP   (1.0/44100.0)

struct NewF0Struct
{
    double f0;
    double time;
};

/*****************************************************************************
* CSynth::CSynth *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/
CSynth::CSynth(int iSampFreq)
{
    m_iSampFreq = iSampFreq;
    m_pdSamples = 0;
    m_pEpochs = 0;
    m_pdSynEpochs = 0;
    m_piMapping = 0;
    m_iNumSynEpochs = 0;
    m_ppdLpcCoef = 0;
    m_iCurrentPeriod = 0;
    m_iRepetitions = 0;
    m_iInvert = 0;
    m_iLpcOrder = 0;
}

/*****************************************************************************
* CSynth::~CSynth *
*-----------------*
*   Description:
*
******************************************************************* PACOG ***/
CSynth::~CSynth()
{
    if ( m_pdSamples ) 
    {
        delete[] m_pdSamples;
    }

    if ( m_pEpochs ) 
    {
        delete[] m_pEpochs;
    }

    if ( m_pdSynEpochs ) 
    {
        delete[] m_pdSynEpochs;
    }
    
    if ( m_piMapping ) 
    {
        delete[] m_piMapping;
    }
    
    if (m_ppdLpcCoef)
    {
        FreeLpcCoef();
    }
}

/*****************************************************************************
* CSynth:: GetNewF0 *
*-------------------*
*   Description:
*
*********************************************************************** WD ***/
void CSynth::GetNewF0 (std::vector<NewF0Struct>* pvNewF0, double* pdTime, double* pdRunTime )
{
    NewF0Struct newF0;
    for ( int i = 1; i < m_iNumEpochs; i++ )
    {
        newF0.f0 = (int) ( 1.0 / ( m_pEpochs[ i ].time - m_pEpochs[ i - 1 ].time ) );
        newF0.f0 *= m_dF0Ratio;
        newF0.time = *pdTime + m_pEpochs[ i ].time;

        pvNewF0->push_back ( newF0 );
    }
    *pdTime += m_pEpochs[ m_iNumEpochs - 1 ].time;
    if ( pdRunTime )
    {
        *pdRunTime = m_dRunTimeLimit;
    }
}

/*****************************************************************************
* CTips::ClipData *
*-----------------*
*   Description:
*       12/4/00 - now using the FTOL function, since the compiler doesn't do
*                 the conversion efficiently.
*
******************************************************************* mplumpe ***/

short CSynth::ClipData (double x)
{
    

    if (x>=0) 
    {
        if (x > SHRT_MAX ) 
        {
            return SHRT_MAX;
        }
        x+= 0.5;
    }
    else 
    {
        if (x < SHRT_MIN ) 
        {
            return SHRT_MIN;
        }
        x-= 0.5;
    }
    
    return (short)FTOL(x);
}


/*****************************************************************************
* CSynth::LpcAnalysis *
*---------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CSynth::LpcAnalysis (int iSampFreq, int iOrder)
{
    double* pdFiltMem = 0;
    double* pdInterpCoef = 0;
    double alfa;
    int  frameLen;
    int  frameIdx;
    int  start;
    int  end;
    int i;
    int j;    
    
    if (m_iNumEpochs) 
    {
        m_iLpcOrder = iOrder;

        if ((m_ppdLpcCoef = new double*[m_iNumEpochs] ) == 0)
        {
            goto error;
        }
        memset( m_ppdLpcCoef, 0, m_iNumEpochs * sizeof (*m_ppdLpcCoef));
        
        if ((pdFiltMem = new double[m_iLpcOrder]) == 0)
        {
            goto error;
        }
        memset (pdFiltMem, 0, m_iLpcOrder * sizeof(*pdFiltMem));

        if ((pdInterpCoef = new double[m_iLpcOrder]) == 0)
        {
            goto error;
        }
        memset (pdInterpCoef, 0, m_iLpcOrder * sizeof(*pdInterpCoef));


        for (frameIdx=0; frameIdx<m_iNumEpochs; frameIdx ++) 
        {
            if (frameIdx==0) 
            {
                start =0;	
            } 
            else 
            {
                start = (int) (m_pEpochs[frameIdx-1].time * iSampFreq);
            }
      
            if (frameIdx==m_iNumEpochs-1) 
            {
                end = m_iNumSamples-1;      
            } 
            else 
            {
                end = (int)(m_pEpochs[frameIdx+1].time * iSampFreq);
            }
      
            frameLen = end-start;
            m_ppdLpcCoef[frameIdx] = GetDurbinCoef(m_pdSamples + start, frameLen);
        }


        for (frameIdx=0; frameIdx<m_iNumEpochs-1; frameIdx ++) 
        {
            if (frameIdx==0) 
            {
                start = 0;
            } 
            else 
            {
                start = (int)(m_pEpochs[frameIdx].time * iSampFreq);
            }
            if (frameIdx==m_iNumEpochs-2) 
            {
                end = m_iNumSamples-1;
            } 
            else 
            {
                end = (int)(m_pEpochs[frameIdx+1].time * iSampFreq);
            }
      
            for (i=start; i<end; i++) 
            {
                alfa = (double)(i-start)/(double)(end-start);
                for (j=0; j<m_iLpcOrder ; j++) 
                {
                    pdInterpCoef[j] = (1.0 - alfa) * m_ppdLpcCoef[frameIdx][j] + 
                                       alfa * m_ppdLpcCoef[frameIdx+1][j];
                }
        
                ParcorFilterAn (m_pdSamples + i, 1, pdInterpCoef, pdFiltMem, m_iLpcOrder);
            }
        }
    }

    delete[] pdFiltMem;
    delete[] pdInterpCoef;

    return 1;
error:
    if (pdFiltMem)
    {
        delete[] pdFiltMem;
    }

    if (pdInterpCoef)
    {
        delete[] pdInterpCoef;
    }
    return 0;
}


/*****************************************************************************
* CSynth::FindPrecedent *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CSynth::FindPrecedent ()
{
    double* warp;
    double durFactor;
    double distAnt;
    double distPost;
    int sIndex;
    int aIndex;
    int i;

    durFactor = m_pdSynEpochs[m_iNumSynEpochs-1]/m_pEpochs[m_iNumEpochs-1].time;

    warp = new double[m_iNumEpochs];
    if (!warp) 
    {
        return -1;
    }
    for (i=0; i<m_iNumEpochs; i++) 
    {
        warp[i]= m_pEpochs[i].time * durFactor;
    }
    
    if ((m_piMapping= new int[m_iNumSynEpochs]) == 0) 
    {
        return -1;
    }
    m_piMapping[0]=0;
    m_piMapping[m_iNumSynEpochs-1] = m_iNumEpochs-1;
    
    aIndex=1;
    for ( sIndex=1; sIndex<(m_iNumSynEpochs-1); sIndex++ ) 
    {
        while (warp[aIndex] < m_pdSynEpochs[sIndex]) 
        {
            aIndex++;
        }
        distAnt  = fabs ( m_pdSynEpochs[sIndex] - warp[aIndex-1] );
        distPost = fabs ( m_pdSynEpochs[sIndex] - warp[aIndex] );
        
        if (distAnt<distPost) 
        {
            if (aIndex<2) 
            {
                m_piMapping[sIndex] = aIndex;
            }
            else 
            {
                m_piMapping[sIndex] = aIndex-1;
            }
        } 
        else 
        {
            if (aIndex>m_iNumEpochs-2) 
            {
                m_piMapping[sIndex] = m_iNumEpochs-2;
            }
            else 
            {
                m_piMapping[sIndex] = aIndex;
            }
        }
    }

    delete[] warp;

    //DEBUG
    /*  
    fprintf (stderr, "+++++++++++++++++++++++++++\n");
    for (i=0; i<m_iNumEpochs; i++) {
        fprintf (stderr, "m_pEpochs[%d]=%f\n", i, m_pEpochs[i].time);
    }
    for (i=0; i<m_iNumSynEpochs; i++) {
        fprintf (stderr, "Syn[%d]=%f ->m_pEpochs[%d]\n", i, m_pdSynEpochs[i], (*m_piMapping)[i]);
    }
    */

    return 1;
}

/*****************************************************************************
* CSynth::NextBuffer *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CSynth::NextBuffer (CTips* pTips)
{
    double* pdSamples;
    int     iNumSamples;
    int     iCenter;
    double  dDelay;
    double* pdLpcCoef;

    double gainVal;
    int centerIdx;
    int from;
    int to;
    int center;
    double origDelay;
    double synthDelay;
    int reverse=0;
    int voiced;
    int iPeriodLen;
    int i;

    assert (pTips);

    if (m_iCurrentPeriod >= m_iNumSynEpochs-2 )
    {
        return 0; //We are done with this unit
    }

    // The first short-term signal is centered in 1, not 0 
    m_iCurrentPeriod++; 

    centerIdx = (int)m_piMapping[m_iCurrentPeriod];
    voiced    = m_pEpochs[centerIdx].voiced;

    //Round to internal sampling freq
    synthDelay = (m_pdSynEpochs[m_iCurrentPeriod] * m_iSampFreq) - 
                 (int)(m_pdSynEpochs[m_iCurrentPeriod] * m_iSampFreq + TIME_STEP/2.0);  

    if ( !voiced && (centerIdx==m_piMapping[m_iCurrentPeriod-1]) ) 
    {
        m_iRepetitions++;
        m_iRepetitions%=4;
        m_iInvert = !m_iInvert;
        if (m_iRepetitions==1 || m_iRepetitions==2) 
        {
            reverse=1;
        }
    } 
    else 
    {
        m_iRepetitions=0;
        m_iInvert=0;
    }

    from   = (int)( m_pEpochs[centerIdx-1].time * m_iSampFreq );
    to     = (int)( m_pEpochs[centerIdx+1].time * m_iSampFreq );
    center = (int)( m_pEpochs[centerIdx].time   * m_iSampFreq );
    
    origDelay = (m_pEpochs[centerIdx].time * m_iSampFreq) - center + TIME_STEP/2.0;
  
    iNumSamples = to-from;
    iCenter     = center - from;
    dDelay      = origDelay - synthDelay;

    if ((pdSamples = new double[iNumSamples]) == 0)
    {
        return 0;
    }
    if ( !reverse )
    {
        memcpy (pdSamples, m_pdSamples + from, (iNumSamples)*sizeof(double));
    }
    else
    {
        for (i = 0; i<iNumSamples ; i++ )
        {
            pdSamples[i] = m_pdSamples[from + iNumSamples - i -1];
        }
        iCenter = iNumSamples - iCenter;
        dDelay  = -dDelay;
    }

    gainVal = m_dGain * pTips->GetGain();

    if (m_iInvert) 
    {
        gainVal *= -1;
    }

    for (i=0; i<iNumSamples; i++) 
    {
        pdSamples[i] *= gainVal;
    }


    if (m_ppdLpcCoef)
    {
        pdLpcCoef = m_ppdLpcCoef[centerIdx];
    }
    else
    {
        pdLpcCoef = 0;
    }

    pTips->SetBuffer (pdSamples, iNumSamples, iCenter, dDelay, pdLpcCoef);
    //NOTE: Do not delete pdSamples, it will be deleted in CTips::Synthesize

    iPeriodLen = (int)(m_pdSynEpochs[m_iCurrentPeriod+1] * m_iSampFreq) - 
            (int)(m_pdSynEpochs[m_iCurrentPeriod] * m_iSampFreq);

    return iPeriodLen;
}

/*****************************************************************************
* CSynth::LpcGetDurbinCoef *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/

double* CSynth::GetDurbinCoef(double* data, int nData)
{
    double* win;
    double* coef;
    int i;

    assert(data);

    win = ComputeWindow (WINDOW_HAMM, nData, 0);
    for (i=0; i<nData; i++) 
    {
        win[i] *= data[i];
    }

    coef = ::GetDurbinCoef (win, nData, m_iLpcOrder, LPC_PARCOR, 0);
    delete[] win;  
  
    return coef;
}
/*****************************************************************************
* CSynth::FreeLpcCoef *
*---------------------*
*   Description:
*
******************************************************************* PACOG ***/

void CSynth::FreeLpcCoef()
{
    for (int i=0; i< m_iNumEpochs; i++) 
    {
        if (m_ppdLpcCoef[i])
        {
            delete[] m_ppdLpcCoef[i];
        }
    }
    delete[] m_ppdLpcCoef;   

    m_ppdLpcCoef = 0;
}

/*****************************************************************************
*                      *
*----------------------*
*   Description:
*
******************************************************************* PACOG ***/
/*
int CSynth::FindPrecedentCopy ( )
{
    int i;

    m_iNumSynEpochs = m_iNumEpochs;
    m_pdSynEpochs   = new double[m_iNumEpochs];
    m_piMapping = new int[m_iNumEpochs];

    for (i=0; i<m_iNumEpochs; i++) 
    {
        m_pdSynEpochs[i]=  m_pEpochs[i].time;  
    }


    for (i=0; i<m_iNumEpochs; i++) 
    {
        m_piMapping[i] = i;
    }

    return 1;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\tips.h ===
/******************************************************************************
* tips.h *
*--------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00 - 12/4/00
*  All Rights Reserved
*
********************************************************************* mplumpe  was PACOG ***/

#ifndef __TIPS_H_
#define __TIPS_H_



class CSynth;

class CTips
{
    friend class CSynth;

    public:
        static enum {LpTips = 1, RTips= 2};

        CTips(int iOptions);
        ~CTips();

        int    Init (int iSampFormat, int iSampFreq);
        void   SetGain (double dGain);
        double GetGain ();

        void   NewSentence (float* pfF0, int iNumF0, int iF0SampFreq);
        int    NewUnit (CSynth* pUnit);
        int    Pending ();
        int    NextPeriod (short** ppsSamples, int* piNumSamples);
        int    SetBuffer ( double* pdSamples, int iNumSamples, int iCenter, double dDelay, double* pdLpcCoef);

        // Waveform concatenation buffer
        int    SetWaveSeg ( double* pdSamples, int iNumSamples, double dGain );
        int    GetWaveSeg ( double** ppdSamples, int* piNumSamples, double* pdGain );

    protected:
        int  Prosody (CSynth* pUnit);
        int  Synthesize (int iPeriodLen);
        int  GetWindowedSignal (int whichBuffer, int periodLength, double** windowed, int* nWindowed);
        void HalfHanning (double* x, int xLen, double ampl, int whichHalf);
        static short ClipData (double x);

        bool LpcInit ();
        void LpcSynth( double* pdData, int iNumData);
        void LpcFreeAll();

        enum {WindowFirstHalf, WindowSecondHalf};
        static const double m_iDefaultPeriod;
        static const double m_dMinF0;

        int m_iSampFormat;
        int m_iSampFreq;
        double m_dGain;
        // Operation flags 
        bool m_fLptips;
        bool m_fRtips;
        // Compute prosody Variables 
        float* m_pfF0;
        int    m_iNumF0;
        double m_dRunTime;
        double m_dF0SampFreq;
        double m_dF0TimeNext;
        double m_dF0TimeStep;
        double m_dF0Value;
        double m_dAcumF0; 
        int    m_iF0Idx;
        double m_dLastEpochTime;
        double m_dNewEpochTime;
        // Buffers for synthesis
        struct CBuffer {
            double* m_pdSamples;
            int     m_iNumSamples;
            int     m_iCenter;
            double  m_dDelay;
        } m_aBuffer[2];
        // Lpc Synthesis
        int     m_iLpcOrder;
        double* m_pdFiltMem;
        double* m_pdInterpCoef;
        double* m_pdNewCoef;
        double* m_pdLastCoef;

        // Holds current synthesis unit 
        CSynth* m_pUnit;
        short*  m_psSynthSamples;
        int     m_iNumSynthSamples;

        static const int m_iHalfHanLen_c;
        double* m_adHalfHanning;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\trees.h ===
/******************************************************************************
* trees.h *
*---------*
*
*------------------------------------------------------------------------------
*  Copyright (c) 1997  Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/
#ifndef __TREES_H_
#define __TREES_H_

#include <stdio.h>

class CClustTree 
{
    public:
        virtual ~CClustTree() {};

        virtual int LoadFromFile (FILE* fp) = 0;
        virtual int GetNumStates (const char* pszTriphone) = 0;
        virtual const char* TriphoneToCluster(const char* pszTriphone, int iState) = 0;
#ifdef _DEBUG_
        virtual void Debug() = 0;
#endif
        static CClustTree* ClassFactory();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\tips.cpp ===
/******************************************************************************
* tips.cpp *
*----------*
*
*------------------------------------------------------------------------------
*  Copyright (c) 1996-1997  Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00-12/4/00
*  All Rights Reserved
*
********************************************************************* mplumpe  was PACOG ***/

#include "tips.h"
#include "SynthUnit.h"
#include "sigproc.h"
#include <vapiIo.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <assert.h>

#include "ftol.h"

const double CTips::m_iDefaultPeriod = .01; //10 msec.
const double CTips::m_dMinF0 = 15.0;  // Absolute minimum F0 alowed
const int    CTips::m_iHalfHanLen_c = 1024;

/*****************************************************************************
* CTips::CTips *
*--------------*
*   Description:
*
******************************************************************* PACOG ***/

CTips::CTips (int iOptions)
{
    m_fLptips     = (bool) (iOptions & LpTips);
    m_fRtips      = (iOptions & RTips) != 0;

    m_iSampFormat = 0;
    m_iSampFreq   = 0;
    m_dGain       = 1.0;

    m_pfF0   = 0;
    m_iNumF0 = 0;
    m_dRunTime    = 0.0;
    m_dF0SampFreq = 0.0;
    m_dF0TimeNext = 0.0;
    m_dF0TimeStep = 0.0;
    m_dF0Value    = 0.0;
    m_dAcumF0     = 0.0; 
    m_iF0Idx      = 0;
    m_dLastEpochTime = 0.0;
    m_dNewEpochTime  = 0.0;

    m_aBuffer[0].m_pdSamples = 0;
    m_aBuffer[1].m_pdSamples = 0;

    m_iLpcOrder    = 0;
    m_pdFiltMem    = 0;
    m_pdInterpCoef = 0;
    m_pdLastCoef   = 0;

    m_pUnit = 0;
    m_psSynthSamples = 0;
    m_iNumSynthSamples = 0;

    m_adHalfHanning = 0;
}

/*****************************************************************************
* CTips::~CTips *
*---------------*
*   Description:
*
******************************************************************* mplumpe ***/
CTips::~CTips ()
{
    if (m_pdFiltMem)
    {
        delete[] m_pdFiltMem;
    }
    if (m_pdInterpCoef)
    {
        delete[] m_pdInterpCoef;
    }
    if (m_pdLastCoef)
    {
        delete[] m_pdLastCoef;
    }
    if (m_aBuffer[0].m_pdSamples) 
    {
        delete[] m_aBuffer[0].m_pdSamples;
    }

    if (m_aBuffer[1].m_pdSamples) 
    {
        delete[] m_aBuffer[1].m_pdSamples;
    }

    if (m_psSynthSamples)
    {
        delete[] m_psSynthSamples;
    }

    if (m_adHalfHanning)
    {
        delete [] m_adHalfHanning;
    }
}


/*****************************************************************************
* CTips::Init *
*-------------*
*   Description:
*
******************************************************************* mplumpe ***/

int CTips::Init (int iSampFormat, int iSampFreq)
{
    int i;
    assert (iSampFreq>0);

    m_iSampFreq    = iSampFreq;
    m_iSampFormat  = iSampFormat;
    int iPeriodLen = (int) (iSampFreq * m_iDefaultPeriod);

    // Delete old buffers, if they exist
    if (m_aBuffer[0].m_pdSamples) 
    {
        delete[] m_aBuffer[0].m_pdSamples;
    }
    if (m_aBuffer[1].m_pdSamples) 
    {
        delete[] m_aBuffer[1].m_pdSamples;
    }

    // Allocate new ones, and initialize them to Zero.
    // NOTE: Only need to allocate buffer[1], really, since they'll be rotated before
    // synthesis.

    if ((m_aBuffer[0].m_pdSamples = new double[2 * iPeriodLen]) == 0 )
    {
        return 0;
    }
    //memset(m_aBuffer[0].m_pdSamples, 0, sizeof(double) * 2 * iPeriodLen);

    if ((m_aBuffer[1].m_pdSamples  = new double [2 * iPeriodLen]) == 0)
    {
        return 0;
    }
    memset(m_aBuffer[1].m_pdSamples, 0, sizeof(double) * 2 * iPeriodLen);

    m_aBuffer[0].m_iNumSamples = 2 * iPeriodLen;    
    m_aBuffer[0].m_iCenter     = iPeriodLen;
    m_aBuffer[0].m_dDelay      = 0.0;

    m_aBuffer[1].m_iNumSamples = 2 * iPeriodLen;    
    m_aBuffer[1].m_iCenter     = iPeriodLen;
    m_aBuffer[1].m_dDelay      = 0.0;

    //
    // make Hanning buffer
    //
    if (m_adHalfHanning)
    {
        delete m_adHalfHanning;
    }
    if ((m_adHalfHanning = new double [m_iHalfHanLen_c]) == 0)
    {
        return 0;
    }
    for (i=0; i < m_iHalfHanLen_c; i++)
    {
        m_adHalfHanning[i] = 0.5-0.5*cos(M_PI*i/m_iHalfHanLen_c);
    }

    if (m_fLptips)
    {
        return LpcInit();
    }

    return 1;
}

/*****************************************************************************
* CTips::SetGain *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/

void CTips::SetGain (double dGain) 
{
    assert (dGain>=0.0);
    m_dGain = dGain;
}

/*****************************************************************************
* CTips::GetGain *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/

double CTips::GetGain () 
{
    return m_dGain;
}

/*****************************************************************************
* CTips::NewSentence *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/

void CTips::NewSentence (float* pfF0, int iNumF0, int iF0SampFreq) 
{
    assert (pfF0);
    assert (iNumF0>0);
    assert (iF0SampFreq>0);

    m_pfF0   = pfF0;
    m_iNumF0 = iNumF0;
    m_dF0SampFreq = iF0SampFreq;
    m_dF0TimeStep = 1.0/iF0SampFreq;
    m_dRunTime    = 0.0;
    m_dF0TimeNext = 0.0; 
    m_dAcumF0     = 0.0;
    m_iF0Idx      = 0;
    m_dLastEpochTime =  0.0;
    m_dNewEpochTime  =  0.0;
}

/*****************************************************************************
* CTips::NewUnit *
*----------------*
*   Description:
*       Gets a new unit to synthesize, and does some analysis on it.
******************************************************************* PACOG ***/
int CTips::NewUnit (CSynth* pUnit)
{
    if (pUnit)
    {
        m_pUnit = pUnit;

        if (m_fLptips) 
        {
            if (!m_pUnit->LpcAnalysis(m_iSampFreq, m_iLpcOrder)) 
            {
                return 0;
            }
        }

        if ( Prosody (pUnit) == -1)
        {
            return 0;
        }
        return 1;
    }

    return 0;
}

/*****************************************************************************
* CTips::Prosody *
*----------------*
*   Description:
*       We get synthesis epochs track for a segment. F0 curve integration is 
*     therefore carried out here. The sampling frequency chosen is high enough
*     as to reduce jitter to an umperceivable level, but that depends on the
*     synthesis module being capable of synthesizing at that interval.
*
******************************************************************* PACOG ***/

int CTips::Prosody ( CSynth* pUnit )
{
    double dF0IntegralTime = 0.0;

    assert (m_pfF0 && m_iNumF0>0);
       
    if (m_dNewEpochTime != m_dLastEpochTime) 
    {
        if ((pUnit->m_pdSynEpochs = new double[2]) == 0) 
        {
            return -1;
        }

        pUnit->m_pdSynEpochs[0] = m_dLastEpochTime;
        pUnit->m_pdSynEpochs[1] = m_dNewEpochTime;
        pUnit->m_iNumSynEpochs   = 2;   
    } 
    else 
    {
        if ((pUnit->m_pdSynEpochs = new double[1]) == 0) 
        {
            return -1;
        }

        pUnit->m_pdSynEpochs[0] = m_dNewEpochTime;
        pUnit->m_iNumSynEpochs  = 1;   
    }


    while ( m_dRunTime < pUnit->m_dRunTimeLimit || 
                // Find an extra epoch, for the overlapping period
                // if the last epoch doesn't already cross the segment limit
            pUnit->m_pdSynEpochs[pUnit->m_iNumSynEpochs-1] < pUnit->m_dRunTimeLimit) 
    {        
        if (m_dRunTime >= m_dF0TimeNext) 
        {            
            m_dF0Value = m_pfF0[m_iF0Idx];

            if (m_iF0Idx < m_iNumF0-1) 
            {
                m_iF0Idx++;
            }
            
            if (m_dF0Value<=0.0) 
            {
                m_dF0Value = 100.0; // Best choice is f0=100Hz
            }
            else if (m_dF0Value <= m_dMinF0) 
            {
                m_dF0Value = m_dMinF0;
            }

            m_dF0TimeNext += m_dF0TimeStep;
        }
            
        dF0IntegralTime = (1.0 - m_dAcumF0) / m_dF0Value;
        
        if (dF0IntegralTime >= m_dF0TimeStep)
        {
            m_dRunTime += m_dF0TimeStep;
            m_dAcumF0 += m_dF0Value * m_dF0TimeStep;
        } 
        else 
        {
            m_dRunTime += dF0IntegralTime;
            m_dAcumF0 = 0;

            //Got epoch
            m_dLastEpochTime = m_dNewEpochTime;
            m_dNewEpochTime  = m_dRunTime;

            //Reallocate the synthesis epochs array
            double* pdSynEpochs = new double[pUnit->m_iNumSynEpochs + 1];
            if (!pdSynEpochs)
            {
                return -1;
            }

            memcpy(pdSynEpochs, pUnit->m_pdSynEpochs, pUnit->m_iNumSynEpochs * sizeof(double));
            delete[] pUnit->m_pdSynEpochs;
            pUnit->m_pdSynEpochs = pdSynEpochs;

            // And add a new epoch
            pUnit->m_pdSynEpochs[pUnit->m_iNumSynEpochs] = m_dNewEpochTime;
            pUnit->m_iNumSynEpochs++;
        }
    }
           
    if (pUnit->m_iNumSynEpochs <3) 
    {
        delete[] pUnit->m_pdSynEpochs;
        pUnit->m_pdSynEpochs = 0;
        return 0;
    }
  
    // Synthesis epochs are in absolute synthesis time
    double epStartTime = ((long)(pUnit->m_pdSynEpochs[0] * m_iSampFreq)) / (double)m_iSampFreq; 
    for (int i=0; i<pUnit->m_iNumSynEpochs; i++) 
    {
        pUnit->m_pdSynEpochs[i] -= epStartTime;
    }
      
    return pUnit->FindPrecedent ();
}


/*****************************************************************************
* CTips::Pending *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/
int CTips::Pending ()
{
    return m_pUnit != 0;
}

/*****************************************************************************
* CTips::NextPeriod *
*-------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CTips::NextPeriod (short** ppnSamples, int *piNumSamples)
{
    int iPeriodLen;

    assert (ppnSamples  && piNumSamples> 0);

    if (m_pUnit)
    {
        iPeriodLen = m_pUnit->NextBuffer (this);
        if ( iPeriodLen > 0 )
        {
            Synthesize (iPeriodLen);
            *ppnSamples   = m_psSynthSamples;
            *piNumSamples = iPeriodLen;
            return 1;
        }
        else 
        {
            delete m_pUnit;
            m_pUnit = 0;
        }
    }

    return 0;
}


/*****************************************************************************
* CTips::FillBuffer *
*-------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CTips::SetBuffer ( double* pdSamples, int iNumSamples, int iCenter, double dDelay, double* pdLpcCoef)
{
    // Advance buffers
    delete[] m_aBuffer[0].m_pdSamples;
    m_aBuffer[0] = m_aBuffer[1];

        
    m_aBuffer[1].m_pdSamples   = pdSamples;
    m_aBuffer[1].m_iNumSamples = iNumSamples;
    m_aBuffer[1].m_iCenter     = iCenter;
    m_aBuffer[1].m_dDelay      = dDelay;

    m_pdNewCoef = pdLpcCoef;

    return 1;
}



/*****************************************************************************
* CTips::Synthesize *
*-------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CTips::Synthesize (int iPeriodLen)
{
    double* pdPeriodSamples = 0;
    double* windowedLeft = 0;
    int     leftSize;
    double* windowedRight = 0;
    int     rightSize;
    double  *p1, *p2;
    int i;

    assert (iPeriodLen);

    if (m_fRtips) 
    {
        NonIntegerDelay (m_aBuffer[1].m_pdSamples, m_aBuffer[1].m_iNumSamples, m_aBuffer[1].m_dDelay);
    }

    if (!GetWindowedSignal(0, iPeriodLen, &windowedLeft, &leftSize)) 
    {
        goto error;
    }
    if (!GetWindowedSignal(1, iPeriodLen, &windowedRight, &rightSize) ) 
    {
        goto error;
    }

    assert (windowedLeft && leftSize);
    assert (windowedRight && rightSize);

    if (!windowedLeft || !leftSize || !windowedRight || !rightSize ) 
    {
        goto error;
    }

    if ((pdPeriodSamples = new double[iPeriodLen]) == 0)
    {
        goto error;
    }

    p1=windowedLeft;
    p2=windowedRight;
  
    for (i=0; i<iPeriodLen - rightSize && i<leftSize; i++) 
    {
        pdPeriodSamples[i] = *p1++;
    }

    // If windows overlap, they are added
    for ( ;i<leftSize; i++) 
    {
        pdPeriodSamples[i] = *p1++ + *p2++;
    }

    // Else, we fill the space with zeros     
    for (; i<iPeriodLen - rightSize; i++) 
    {
        pdPeriodSamples[i] = 0.0;
    }

    for (;i<iPeriodLen;i++) 
    {
        pdPeriodSamples[i] = *p2++;
    }
 
    delete[] windowedLeft;
    delete[] windowedRight;

    if (m_fLptips) 
    {
        LpcSynth (pdPeriodSamples, iPeriodLen);
    }  

    // reuse the same buffer if possible
    if ( m_iNumSynthSamples < iPeriodLen )
    {
        if (m_psSynthSamples)
        {
            delete[] m_psSynthSamples;
        }
        if ((m_psSynthSamples = new short[iPeriodLen]) == 0)
        {
            goto error;
        }
        m_iNumSynthSamples = iPeriodLen;
    }

    for (i=0; i<iPeriodLen; i++) 
    {
        m_psSynthSamples[i] = ClipData(pdPeriodSamples[i]);
    }

    delete[] pdPeriodSamples;

    return 1;

error:
    if (pdPeriodSamples)
    {
        delete[] pdPeriodSamples;
    }
    if (windowedLeft)
    {
        delete[] windowedLeft;
    }
    if (windowedRight)
    {
        delete[] windowedRight;
    }

    return 0;
}

/*****************************************************************************
* CTips::GetWindowedSignal *
*----------------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CTips::GetWindowedSignal (int whichBuffer, int iPeriodLen, 
                              double** windowed, int* nWindowed)
{
    double* sampPtr;
    int    nSamples;
    int from;
    

    if (whichBuffer==0) 
    {    
        sampPtr  = m_aBuffer[0].m_pdSamples + m_aBuffer[0].m_iCenter;
        nSamples = __min(iPeriodLen, (m_aBuffer[0].m_iNumSamples - m_aBuffer[0].m_iCenter));
    } 
    else 
    {
        from = __max(0, m_aBuffer[1].m_iCenter - iPeriodLen);
        sampPtr  = m_aBuffer[1].m_pdSamples + from;
        nSamples = m_aBuffer[1].m_iCenter - from;
    }

    
    if (nSamples) 
    {
        if ((*windowed = new double[nSamples]) == 0) 
        { 
            return 0;
        }
        *nWindowed = nSamples;

        memcpy (*windowed, sampPtr, nSamples * sizeof(**windowed)); 

        if (whichBuffer==0) 
        {
            HalfHanning (*windowed, nSamples, 1.0, WindowSecondHalf);
        }
        else 
        {
            HalfHanning (*windowed, nSamples, 1.0, WindowFirstHalf); 
        }

        return 1;

    } 
    else 
    {
        fprintf (stderr, "NULL vector in GetWindowedSignal\n");
    }

    return 0;
}


/*****************************************************************************
* CTips::HalfHanning *
*--------------------*
*   Description:
*       12/4/00 - Since ampl wasn't being used, I'm now asserting it equal
*                 to 1 and ignoring it.  Also, a large hanning window is
*                 pre-computed and interpolated here, instead of being
*                 calculated here.
*
******************************************************************* mplumpe ***/

void CTips::HalfHanning (double* x, int xLen, double ampl, int whichHalf)
{
    double delta;
    double dk;
    int start;
    int sign;
    int i;

    assert (1 == ampl);

    if (x && xLen) 
    {
        delta = m_iHalfHanLen_c / xLen;
        dk=0.; // FTOL function does rounding.  If casting to int, need to start at 0.5 to get rounding
        
        /*
         * When multiplying by the second half, the window function is the same,
         * but we multiply from the last sample in the vector to the first
         * NOTE: The first sample is multiplyed by 0 in the case of the first
         * half, and by 1 (*ampl, of course) in the case of the second half.
         */
        switch (whichHalf) 
        {
        case WindowSecondHalf:
            start=xLen;
            sign=-1;
            break;
        case WindowFirstHalf:
            x[0]=0.0;
            start=0;
            sign=1;
            break;
        default:
            fprintf(stderr, "Hanning, should especify a half window\n");
            return;
        }
        
        for (i=1; i<xLen; i++) 
        {
            dk += delta;
            x[start+sign*i] *= m_adHalfHanning[FTOL(dk)]; 
        }
    }
}

/*****************************************************************************
* CTips::ClipData *
*-----------------*
*   Description:
*       12/4/00 - now using the FTOL function, since the compiler doesn't do
*                 the conversion efficiently.
*       1/18/01 - The FTOL function rounds, whereas casting truncates.  So,
*                 we no longer need to ad .5 for pos numbers and subtract .5
*                 for negative numbers.
*
******************************************************************* mplumpe ***/

short CTips::ClipData (double x)
{
    

    if (x > SHRT_MAX ) 
    {
        return SHRT_MAX;
    }
    if (x < SHRT_MIN ) 
    {
        return SHRT_MIN;
    }
    return (short)FTOL(x);
}


/*****************************************************************************
* CTips::LpcInit *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/
bool CTips::LpcInit ()
{
    m_iLpcOrder = LpcOrder (m_iSampFreq);

    if ((m_pdFiltMem = new double [m_iLpcOrder]) == 0)
    {
        goto error;
    }
    memset( m_pdFiltMem, 0, m_iLpcOrder * sizeof (*m_pdFiltMem));

    if ((m_pdInterpCoef = new double [m_iLpcOrder]) == 0)
    {
        goto error;
    }
    memset( m_pdInterpCoef, 0, m_iLpcOrder * sizeof (*m_pdInterpCoef));

    if ((m_pdLastCoef = new double [m_iLpcOrder]) == 0)
    {
        goto error;
    }
    memset( m_pdLastCoef, 0, m_iLpcOrder * sizeof (*m_pdLastCoef));

    return true;

error:

    LpcFreeAll();
    return false;
}

/*****************************************************************************
* CTips::LpcSynth *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/

void CTips::LpcSynth (double* pdPeriod, int iPeriodLen)
{
    double alfa;
    int i;
    int j;

    for (i=0; i<iPeriodLen; i++) 
    {
        alfa = i/(double)iPeriodLen;

        for (j=0; j<m_iLpcOrder ; j++) {
            m_pdInterpCoef[j] = (1.0 - alfa) * m_pdLastCoef[j] + alfa * m_pdNewCoef[j];
        }
        ParcorFilterSyn(pdPeriod+i, 1, m_pdInterpCoef, m_pdFiltMem, m_iLpcOrder );
    }

    memcpy( m_pdLastCoef, m_pdNewCoef, m_iLpcOrder * sizeof(*m_pdLastCoef));
}

/*****************************************************************************
* CTips::LpcFreeAll *
*----------------------*
*   Description:
*
******************************************************************* PACOG ***/

void CTips::LpcFreeAll()
{
    if (m_pdFiltMem)
    {
        delete[] m_pdFiltMem;
        m_pdFiltMem = 0;
    }

    if (m_pdInterpCoef)
    {
        delete[] m_pdInterpCoef;
        m_pdInterpCoef = 0;
    }

    if (m_pdLastCoef)
    {
        delete[] m_pdLastCoef;
        m_pdInterpCoef = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\vqtable.h ===
/******************************************************************************
* VqTable.h *
*-----------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00 - 12/4/00
*  All Rights Reserved
*
********************************************************************* mplumpe ***/
#ifndef __VQTABLE_H_
#define __VQTABLE_H_

#include <stdio.h>

class CVqTable 
{
    public:
        CVqTable();
        ~CVqTable();

        int LoadFromFile (FILE* fin);
        void Scale (double dContWeight);
        int Write (FILE* fin);
        int Dimension ();
        inline float& Element(int i, int j)
        {
            return m_ppfValue[i][j];
        };

    private:
        float *m_pfValue;  // Data 
        float **m_ppfValue; // pointers into the table
        int   m_iDim;     // The data is a square matrix dim x dim
        float m_fOldWeight;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\trees.cpp ===
/******************************************************************************
* trees.cpp *
*-----------*
*
*------------------------------------------------------------------------------
*  Copyright (c) 1997  Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00 - 12/5/00
*  All Rights Reserved
*
********************************************************************* mplumpe  was PACOG ***/

#include "trees.h"
#include "list.h"
#include "clusters.h"
#include <assert.h>
#include <ctype.h>

#define MAX_QS_LEN      128
#define MAX_LINE        512

class CRegExp
{
    public:
        CRegExp ();
        CRegExp (const char* string);
        bool Evaluate(const char* pszString);

    private:
        char m_text[MAX_QS_LEN];
};

//----------------------------------------------------------
//  Question set classes
//
class CQuest 
{
    public:
        CQuest& operator= (CQuest& rSrc) 
        {
            m_pExpr = rSrc.m_pExpr;
            return *this;
        }
        int  AddExpression (const char* pszLine);
        bool Matches (const char* pszString);

#ifdef _DEBUG_
        void Debug();
#endif
    private:
        CList<CRegExp> m_pExpr;
};

//----------------------------------------------------------
// 
//
class CQuestSet
{
    public:
        bool Matches (const char* pszQuestTag, const char* pszTriph);
        bool AddQuestion ( const char* pszLine);
        void Sort();
#ifdef _DEBUG_
        void Debug();
#endif

    private:
        CList<CQuest> m_pQuest; 
};


//----------------------------------------------------------
//  Tree classes
//
class CLeave
{
    public:
        CLeave () {m_pszLeave[0] = '\0';};
        CLeave (const char* pszLeaveValue);
        const char* Value();
    private:
        char m_pszLeave[MAX_QS_LEN];
};

//----------------------------------------------------------
// 
//

class CBranch 
{
    public:
        CBranch () 
        {
            m_pszQuestion[0] = '\0';
            m_iLeft  = 0;
            m_iRight = 0;
        }
        CBranch( const char* pszQuestion, int iLeft, int iRight);
        int   Left();
        int   Right();
        const char* Question();
        
    private:
        char m_pszQuestion[MAX_QS_LEN];
        int  m_iLeft;
        int  m_iRight;
};

//----------------------------------------------------------
// 
//

class CTree 
{
    public:
        CTree& operator= (CTree& rSrc) 
        {
            m_branches  = rSrc.m_branches;
            m_terminals = rSrc.m_terminals;
            return *this;
        }
        int AddNode( const char* pszLine);
        const char* Traverse(CQuestSet* pQuestSet, const char* pszTriphone);

#ifdef _DEBUG_
        void Debug();
#endif
    private:
        CList<CBranch> m_branches;
        CList<CLeave>  m_terminals;
};


//----------------------------------------------------------
// 
//

class CClustTreeImp : CClustTree 
{
    public:
        ~CClustTreeImp();

        int LoadFromFile (FILE* fp);
        int GetNumStates (const char* pszTriphone);
        const char* TriphoneToCluster(const char* pszTriphone, int iState);
#ifdef _DEBUG_
        void Debug();
#endif

    private:
        int ParseTree (const char* pszLine);
        int CentralPhone (const char *pszTriphone, char *pszThone);

        CQuestSet* m_pQuestSet;
        CList<CTree> m_trees; 
};


/*****************************************************************************
* CLeave::CLeave *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/
CLeave::CLeave (const char* pszLeaveValue)
{
    strcpy(m_pszLeave, pszLeaveValue);
}
/*****************************************************************************
* CLeave::Value *
*---------------*
*   Description:
*
******************************************************************* PACOG ***/
const char* CLeave::Value()
{
    return m_pszLeave;
}

/*****************************************************************************
* CBranch::CBranch *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/
CBranch::CBranch( const char* pszQuestion, int iLeft, int iRight)
{
    strcpy(m_pszQuestion, pszQuestion);
    m_iLeft  = iLeft;
    m_iRight = iRight;
}
/*****************************************************************************
* CBranch::Left *
*---------------*
*   Description:
*
******************************************************************* PACOG ***/
int CBranch::Left()
{
    return m_iLeft;
}
/*****************************************************************************
* CBranch::Right *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/
int CBranch::Right()
{
    return m_iRight;
}
/*****************************************************************************
* CBranch::Question *
*-------------------*
*   Description:
*
******************************************************************* PACOG ***/
const char* CBranch::Question()
{
    return m_pszQuestion;
}


/*****************************************************************************
* CClustTree::ClassFactory *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/
CClustTree* CClustTree::ClassFactory ()
{
    return new CClustTreeImp;
}

/*****************************************************************************
* CClustTreeImp::~CClustTreeImp *
*-------------------------------*
*   Description:
*
******************************************************************* PACOG ***/
CClustTreeImp::~CClustTreeImp ()
{
    delete m_pQuestSet;
}


/*****************************************************************************
* CClustTreeImp::LoadFromFile *
*-----------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClustTreeImp::LoadFromFile (FILE* fp)
{
    char line[MAX_LINE+1];
    char *ptr;
    
    assert (fp);
    

    if ((m_pQuestSet = new CQuestSet) == 0)
    {
        return 0;
    }

    while (fgets(line, MAX_LINE, fp) && line[0]!='#') 
    {
        
        if (line[strlen(line)-1]=='\r' || line[strlen(line)-1]=='\n') 
        {
            line[strlen(line)-1]= '\0';
        }
        
        ptr = line;
        while (*ptr && isspace (*ptr)) 
        {
            ptr++;
        }
        
        if (strncmp(ptr, "QS ", 3)==0) 
        {
            if (!m_pQuestSet->AddQuestion (ptr+3)) 
            {
                return 0;
            }
        } 
        else 
        {
            if (!ParseTree (ptr))
            {
                return 0;
            }
        }
    }
    
    m_pQuestSet->Sort();
    m_trees.Sort();

#ifdef _DEBUG_
    Debug();
#endif
    
    return 1;
}
/*****************************************************************************
* CClustTreeImp::GetNumStates *
*-----------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClustTreeImp::GetNumStates(const char* triphone)
{
    char triphHtk[20];  
    char centralPhone[10];
    char stateName[20];  
    int  stateCount = 0;

    strcpy(triphHtk, triphone);

    if ( CentralPhone(triphHtk, centralPhone) ) 
    {        
        for (stateCount = 0; stateCount<3; stateCount++)
        {
            sprintf(stateName, "%s[%d]", centralPhone, stateCount+2);

            CTree* tree;    
            if ( ! m_trees.Find (stateName, &tree) )
            {
               break;
            }
        }
    }

    return stateCount;
}
/*****************************************************************************
* CClustTreeImp::TriphoneToCluster *
*----------------------------------*
*   Description:
*
******************************************************************* PACOG ***/
const char *CClustTreeImp::TriphoneToCluster (const char *triphone, int state)
{
    char centralPhone[10];
    char stateName[20];  
    char triphHtk[20];  

    
    assert (triphone);
    assert (0<=state && state<3);
     
    strcpy(triphHtk, triphone);

    if ( CentralPhone(triphHtk,  centralPhone) ) 
    {        
        sprintf(stateName, "%s[%d]", centralPhone, state+2);
        
        CTree* tree = 0;
        if ( m_trees.Find (stateName, &tree) )
        {
            return tree->Traverse(m_pQuestSet, triphHtk);
        }        
    }
    
    return 0;
}

/*****************************************************************************
* CClustTreeImp::CentralPhone *
*-----------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClustTreeImp::CentralPhone (const char *triphone, char *phone)
{
    char *index1;
    char *index2;
    
    assert (phone);
    assert (triphone);
    
    index1 = strchr(triphone, '-');
        
    if (index1) 
    {
        index2 = strchr (++index1, '+');
    } 
        
    if ( index1 && index2 ) 
    {
        strncpy ( phone, index1, index2-index1);
        phone[index2-index1] = '\0';

        return 1;
    }
    
    return 0;
}
/*****************************************************************************
* CClustTreeImp::ParseTree *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CClustTreeImp::ParseTree (const char *ptr)
{
    static int newTree = 1;

    assert (ptr);
    
    if (!strlen (ptr)) 
    {        
        newTree = 1;        
    } 
    else if (strncmp(ptr,"{",1)==0) 
    {        
        newTree = 0;        
    } 
    else if (strncmp(ptr,"}",1)==0) 
    {        
        newTree = 1;        
    } 
    else 
    {        
        if (newTree ) 
        {            
            CTree tree;
            m_trees.PushBack(ptr, tree);
            newTree = 0;
        }
        else 
        {
            m_trees.Back().AddNode(ptr);
        }
    }
    
    return 1;
}


/*****************************************************************************
* CTree::AddNode *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/

int CTree::AddNode (const char *line)
{    
    char aux1[50] = "";
    char aux2[50] = "";
    char *index1;
    char *index2;
    int  leftIdx;
    int  rightIdx;
    int i;
    
    assert (line);
    
    if (line[0]=='"') 
    {
        // This is the final node (tree only has one cluster)
        
        index1 = strchr(line+1, '"');
        
        if (index1)
        {
            strncpy(aux1, line+1, index1 - line - 1);
            aux1[index1 - line - 1] = '\0';
            
            CLeave terminal(aux1);
            m_terminals.PushBack("", terminal);
        }
    }
    else 
    {        
        //Node name
        index1 = strchr(line, '\'');
        if (index1) 
        {
            index2 = strchr(++index1, '\'');

            strncpy(aux1, index1, index2 - index1);
            aux1[index2 - index1] = '\0';
        }
        
        index1 = ++index2;
        while (*index1 && isspace (*index1)) 
        {
            index1++;
        }
        
        //Left node
        if (*index1 == '"') 
        {
            index2 = strchr (++index1, '"');

            strncpy(aux2, index1, index2 - index1);
            aux2[index2 - index1] = '\0';

            CLeave terminal(aux2);
            m_terminals.PushBack("", terminal);

            leftIdx = m_terminals.Size() - 1;
            index1 = ++index2;
        } 
        else 
        {      
            if (*index1 == '-') 
            {
                aux2[0]= *index1++;
            }

            for (i=1 ; isdigit(*index1); i++) 
            {
                aux2[i]= *index1++;
            }
            aux2[i]='\0';

            leftIdx = atoi (aux2);
        }
        
        
        while (isspace(*++index1))
        {
            //Empty loop
        }

        //Right node
        if (*index1 == '"') 
        {
            index2 = strchr (++index1, '"');
            strncpy(aux2, index1, index2 - index1);
            aux2[index2 - index1] = '\0';

            CLeave terminal(aux2);
            m_terminals.PushBack("", terminal);

            rightIdx = m_terminals.Size() - 1;
        } 
        else 
        {      
            
            if (*index1== '-') 
            {
                aux2[0]= *index1++;
            }
            
            for (i=1; isdigit(*index1); i++) 
            {
                aux2[i]= *index1++;
            }
            aux2[i]='\0';

            rightIdx = atoi (aux2);
        }


        CBranch node(aux1, leftIdx, rightIdx);

        m_branches.PushBack("", node);
    }
    
    return 1;
}

/*****************************************************************************
* CTree::Traverse *
*-----------------*
*   Description:
*
******************************************************************* PACOG ***/

const char *CTree::Traverse (CQuestSet* pQuestSet, const char *triph)
{ 
    char *retVal = 0;
    int nodeIdx = 0;
    int nextIdx;
    
    assert (triph);
    
    if (m_branches.Size() == 0)
    {
        return m_terminals[0].Value();
    }
            
    // Search until we find a leave     
    while (!retVal) 
    {
        if (nodeIdx > m_branches.Size()) 
        {
            return 0;
        }
      
        if (pQuestSet->Matches (m_branches[nodeIdx].Question(), triph))
        {
            nextIdx = m_branches[nodeIdx].Right();     
        }
        else 
        {
            nextIdx = m_branches[nodeIdx].Left();     
        }

        if ( nextIdx >= 0) 
        {
            retVal = (char *)m_terminals[nextIdx].Value();
        }
        else
        {
            nodeIdx = -nextIdx; 
        }
    }
   
    return retVal;
}

/*****************************************************************************
* CRegExp::CRegExp *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/
CRegExp::CRegExp ()
{
    m_text[0] = '\0';
}

/*****************************************************************************
* CRegExp::CRegExp *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/
CRegExp::CRegExp (const char* regExp)
{
    strcpy(m_text, regExp);
}

/*****************************************************************************
* CRegExp::Evaluate *
*-------------------*
*   Description:
*
******************************************************************* PACOG ***/
bool CRegExp::Evaluate (const char *string)
{
    const char *index1;
    const char *index2;
    int len;
    int i;
    int jump = 0;
    
    assert (string);
    
    len    = strlen(m_text);    
    index1 = string;
    
    for (i=0; i<len; i++) 
    {        
        if (m_text[i]=='*') 
        {
            jump = 1;
        }
        else 
        {
            if (jump) 
            { 
                // After a star, several characters can be skipped                   
                index2 = strchr(index1, m_text[i]);
                
                if (index2 == NULL) 
                {
                    return 0; /* Next character not found, expresion not matched */
                }
                
                index1 = ++index2;     
                
                jump = 0;                
            } 
            else 
            {
                // If not a star, next character must match                  
                if (m_text[i] != *index1++) 
                {
                    return false;
                }	
            }
        }
    }
    
    // If we complete the pass over the regexp string, we probably found a match
    // If the last char in regexp is '*', the is match else, 
    // if both strings reached the end, is match   
    if (m_text[len-1]=='*' || !*index1) 
    {
        return true;
    }
    
    return false;
}

/*****************************************************************************
* CQuest::AddExpression *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CQuest::AddExpression (const char* line)
{
    CRegExp regExp(line);

    m_pExpr.PushBack("", regExp);     

    return 1;
}

/*****************************************************************************
* CQuest::Matches *
*-----------------*
*   Description:
*
******************************************************************* PACOG ***/
bool CQuest::Matches (const char *triphone)
{
    assert (triphone);
    
    for (int i=0; i<m_pExpr.Size(); i++) 
    {
        if (m_pExpr[i].Evaluate (triphone))
        {
            return true;
        }
    }
    return false;
}


/*****************************************************************************
* CQuestSet::AddQuestion *
*------------------------*
*   Description:
*
******************************************************************* PACOG ***/
bool CQuestSet::AddQuestion (const char *line)
{
    char name[30];
    char aux[30];
    const char *index1 = NULL;
    const char *index2 = NULL;
    
    assert (line);
    
    if (line!=NULL) 
    {        
        index1 = strchr(line,'\'');
        if (index1) 
        {
            index2 = strchr(++index1, '\'');
        }    
        
        if (index1 && index2) 
        {

            strncpy (name, index1, index2-index1);
            name[index2-index1] = '\0';

            CQuest newQuestion;

            do 
            {
                line = index2+1;
                
                index1 = strchr (line,'"');
                if (index1) 
                {
                    index2 = strchr (++index1, '"');
                }
            
                if (index1 && index2) 
                {
                    strncpy(aux, index1, index2-index1);
                    aux[index2-index1] = '\0';
                    newQuestion.AddExpression(aux);                                
                }
            }  while (index1 && index2);
        
            return m_pQuest.PushBack (name, newQuestion); 
        }
    }
    
    return false;
}

/*****************************************************************************
* CQuestSet::Matches *
*--------------------*
*   Description:
*
*   Changes:
*           12/5/00 Was getting pQuestion by reference, which forced a big
*                   nested copy.  Now getting a pointer which we can use
*                   and discard.
*
******************************************************************* mplumpe ***/
bool CQuestSet::Matches (const char* tag, const char* triph)
{
    CQuest *pQuestion;
    
    if ( m_pQuest.Find(tag, &pQuestion) )
    { 
        return pQuestion->Matches (triph);
    }

    return false;
}

/*****************************************************************************
* CQuestSet::Sort *
*-----------------*
*   Description:
*
******************************************************************* PACOG ***/
void  CQuestSet::Sort ()
{
    m_pQuest.Sort();
}

#ifdef _DEBUG_

/*****************************************************************************
* CClustTreeImp::Debug *
*----------------------*
*   Description:
*
******************************************************************* PACOG ***/

void CClustTreeImp::Debug ()
{   
    m_questionSet.Debug();
    
    for (int i=0; i<m_trees.size(); i++) 
    {
        printf ("\nTrees[%ld]=%s", i, m_trees[i].Name());    
        m_trees[i].Debug();
    }
    puts ("");
}

/*****************************************************************************
* CTree::Debug *
*--------------*
*   Description:
*
******************************************************************* PACOG ***/

void CTree::Debug ()
{
    int idx;

    for (int i=0; i<m_branches[i].size(); i++) 
    {
        idx = m_branches[i].Left();
        if (idx>=0)
        {
            printf("Left= %s ", m_terminals[i].Value());
        }
        else 
        {
            printf("Left= %ld ", -idx);
        }

        idx = m_branches[i].Right();
        if (idx>=0)
        {
            printf("Right= %s ", m_terminals[i].Value());
        }
        else 
        {
            printf("Right= %ld ", -idx);
        }
    }
}

/*****************************************************************************
* CQuestSet::Debug *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/

void CQuestSet::Debug ()
{
    for (int i=0; i<m_pQuest.size(); i++) 
    {
        printf("Question[%ld]=%s\n", i, m_pQuest[i].GetName());
        m_pQuest[i].Debug();
    }
}

/*****************************************************************************
* CQuest::Debug *
*---------------*
*   Description:
*
******************************************************************* PACOG ***/

void CQuest::Debug ()
{
    for (int i=0; j<m_pExpr.size(); i++) 
    {
        printf("\texpr[%ld]=%s\n",i, m_pExpr[i].c_str() );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\unitsearch.cpp ===
/******************************************************************************
* UnitSearch.cpp *
*----------------*
*
*------------------------------------------------------------------------------
*  Copyright (c) 1997  Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00 - 12/4/00
*  All Rights Reserved
*
********************************************************************* mplumpe  was PACOG ***/

#include "UnitSearch.h"
#include "clusters.h"
#include "vqtable.h"
#include "trees.h"
#include "SpeakerData.h"
#include "backendInt.h"
#include <float.h>
#include <math.h>
#include <assert.h>

//
// definitions for DPCand and DPLink moved to UnitSearch.h so they can be
// used in the CUnitSearch class.  mplumpe 12/5/00
//

static const double s_dDefaultF0Weight      = 0.5F;
static const double s_dDefaultDurWeight     = 0.1F;
static const double s_dDefaultRmsWeight     = 0.3F;
static const double s_dDefaultLklWeight     = 0.1F;
static const double s_dDefaultContWeight    = 2.0F;
static const double s_dDefaultSameSegWeight = 1.0F;
static const double s_dDefaultPhBdrWeight   = 0.4F;
static const double s_dDefaultF0BdrWeight   = 0.2F;


/*****************************************************************************
* CUnitSearch::CUnitSearch *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/

CUnitSearch::CUnitSearch (int iDynSearch, int iBlend, int iUseTargetF0, int iUseGain)
{
    m_iDynSearch   = iDynSearch;
    m_iBlend       = iBlend;
    m_iUseTargetF0 = iUseTargetF0;
    m_iUseGain     = iUseGain;
    m_pszLastPhone[0] = '\0';
    m_pszUnitName[0]  = '\0'; 
    m_iChunkIdx1 = -1;
    m_dTime1 = 0.0;
    m_dFrom1 = 0.0;
    m_dTo1   = 0.0;
    m_dGain1 = 0.0;
    m_dNumAcum = 0.0;

    m_weights.f0      = s_dDefaultF0Weight;
    m_weights.dur     = s_dDefaultDurWeight;
    m_weights.rms     = s_dDefaultRmsWeight;
    m_weights.lkl     = s_dDefaultLklWeight;
    m_weights.cont    = s_dDefaultContWeight;
    m_weights.sameSeg = s_dDefaultSameSegWeight;
    m_weights.phBdr   = s_dDefaultPhBdrWeight;
    m_weights.f0Bdr   = s_dDefaultF0BdrWeight;
}

/*****************************************************************************
* CUnitSearch::SetSpeakerData *
*-----------------------------*
*   Description:
*       This is the main slm function, dp search for a segment of input phone
*     sequence will be done here.
******************************************************************* PACOG ***/

void CUnitSearch::SetSpeakerData (CSpeakerData* pSpeakerData)
{
    m_pSpeakerData = pSpeakerData;
    m_weights      = pSpeakerData->GetWeights();
    m_pSpeakerData->PreComputeDist();
}

/*****************************************************************************
* CUnitSearch::ComputeDPInfo *
*----------------------------*
*   Description:
*       This is the main slm function, dp search for a segment of input phone
*     sequence will be done here.
******************************************************************* mplumpe ***/

void CUnitSearch::ComputeDPInfo (DPLink* pLastLink, DPLink& rNewLink, double targetF0)
{
    SegInfo *candIseg;
    SegInfo *candJseg;
    int      nCandI;
    int      nCandJ;
    double f0Dev;
    double timePenalty;
    double bestWeight = 0.0;
    short  targetF0Positive;
    int i;
    int j;
    int iBest;
    bool fF0Dist;
              
    nCandI = rNewLink.m_cands.size();
    rNewLink.m_iBestPath = -1;
    
    rNewLink.m_dTargF0 = targetF0;

    /* Pre compute  booleans */
    targetF0Positive = (short) (targetF0 > 0);

    timePenalty = m_weights.sameSeg;
    
    for (i=0; i<nCandI; i++) 
    {
        candIseg = rNewLink.m_cands[i].segment;
        
        // Compute weights 
        if (candIseg->f0flag == 1) 
        {
            if (m_iUseTargetF0) 
            {
                if (targetF0Positive) 
                {
                    f0Dev = fabs(candIseg->f0 - targetF0) / targetF0;
                }
                else 
                {
                    f0Dev = 0.0;
                }
            } 
            else 
            {      
                if ( rNewLink.m_dAverF0 ) 
                {
                    f0Dev = fabs(candIseg->f0 - rNewLink.m_dAverF0) / rNewLink.m_dAverF0;
                }
                else 
                {
                    f0Dev = 0.0;
                }
            }
        }
        else 
        {
            f0Dev = 0.0;
        }
        
        rNewLink.m_cands[i].f0Weight   = m_weights.f0 * f0Dev;
        rNewLink.m_cands[i].acumWeight = rNewLink.m_cands[i].f0Weight + candIseg->repDist;
        
        if (pLastLink)
        {
            fF0Dist = ( candIseg->f0flag == 1 ) || ( candIseg->f0flag == -2 );

            double minimum = DBL_MAX;
            double totalWeight;
            
            nCandJ = pLastLink->m_cands.size();
            
            //
            // For now, I have two loops, one for with VQ one for without VQ.  I don't want to
            // have to check for VQ within the loop, that happens too often.  Probably a better
            // solution is to have just not call this routine if we're doing a Min database,
            // and otherwise require a VQ table
            //
            if (m_pSpeakerData->m_pVq)
            {
                for (j=0; j<nCandJ; j++) 
                {                
                    DPCand& rCand = pLastLink->m_cands[j];
                    candJseg = rCand.segment;
                    
                    // I've simplified this : instead of calculating the end point of the left and making sure it is close
                    // to the start point of the right, I'm just checking that the VQ indexes are the same.
                    // This perhaps isn't quite as accurate, but it is much quicker.
                    //
                    // I've also made the assumption that we are using VQ.
                    //
                    // Also not calculating contWeight since it wasn't used anywhere.
                    //
                    // Also assuming VQ table (asserted above)
                    //
                    // Also, doing some lossless pruning right below.  Since totalWeight after the first calculation
                    // is much larger than timePenalty (often 10x), it happens often enough that we don't need to
                    // do the calculations to determine this weight (whether or not the segments are sequential)
                    //
                    // mplumpe 12/1/00
                    totalWeight = rCand.acumWeight + m_pSpeakerData->m_pVq->Element(candJseg->rightVqIdx, candIseg->leftVqIdx);
                    if (totalWeight < minimum)
                    {
                        if ( (candIseg->chunkIdx != candJseg->chunkIdx) || (candJseg->rightVqIdx != candIseg->leftVqIdx))
                        {
                            if ( pLastLink->m_dTime > 0.0 )
                            {
                                totalWeight += timePenalty + m_weights.phBdr;
                            }
                            else
                            {
                                totalWeight += timePenalty;
                            }
                            //--- f0 flag
                            //        1    if f0 of the unit is all 1 (have non-zero f0 value) 
                            //        0    if f0 of the unit is all 0
                            //       -1    if f0 of the unit is from 0 to 1
                            //       -2    if f0 of the unit is from 1 to 0

                            if ( fF0Dist && ( candJseg->f0flag == 1 || candJseg->f0flag == -1 ) ) 
                            {
                                totalWeight += fabs(candIseg->f0 - candJseg->f0) / 10.0 * m_weights.f0Bdr;
                            }
                            
                            if (totalWeight < minimum) 
                            {
                                minimum   = totalWeight;
                                iBest = j;
                            }
                        }
                        else
                        {
                            if ( fabs(candJseg->start + candJseg->dur - candIseg->start) < 0.001 ) 
                            {
                                minimum   = totalWeight;
                                iBest = j;
                            }
                            else
                            {
                                if ( pLastLink->m_dTime > 0.0 )
                                {
                                    totalWeight += timePenalty  + m_weights.phBdr;
                                }
                                else
                                {
                                    totalWeight += timePenalty;
                                }

                                if ( fF0Dist && ( candJseg->f0flag == 1 || candJseg->f0flag == -1 ) ) 
                                {
                                    totalWeight += fabs(candIseg->f0 - candJseg->f0) / 10.0 * m_weights.f0Bdr;
                                }

                                if (totalWeight < minimum) 
                                {
                                    minimum   = totalWeight;
                                    iBest = j;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                for (j=0; j<nCandJ; j++) 
                {                
                    DPCand& rCand = pLastLink->m_cands[j];
                    candJseg = rCand.segment;
                    
                    totalWeight = rCand.acumWeight;
                    if (totalWeight < minimum)
                    {
                        if ((candIseg->chunkIdx != candJseg->chunkIdx) || (fabs(candJseg->start+candJseg->dur - candIseg->start) > .0001))
                        {
                            if ( pLastLink->m_dTime > 0.0 )
                            {
                                totalWeight += timePenalty + m_weights.phBdr;
                            }
                            else
                            {
                                totalWeight += timePenalty;
                            }

                            if (candIseg->f0flag == 1 && candJseg->f0flag == 1) 
                            {
                                totalWeight += fabs(candIseg->f0 - candJseg->f0) / 10.0 * m_weights.f0Bdr;
                            }

                            if (totalWeight < minimum) 
                            {
                                minimum   = totalWeight;
                                iBest = j;
                            }
                        }
                        else
                        {
                            minimum   = totalWeight;
                            iBest = j;
                        }
                    }
                }
            }
            
            rNewLink.m_cands[i].acumWeight += minimum;
            rNewLink.m_cands[i].prevPath = iBest;
        } 
        else 
        {
            rNewLink.m_cands[i].prevPath = -1;      
        }
        
        if (i==0) 
        {
            bestWeight = rNewLink.m_cands[i].acumWeight + 1.0;
        }
        
        if (rNewLink.m_cands[i].acumWeight < bestWeight) 
        {
            bestWeight = rNewLink.m_cands[i].acumWeight;
            rNewLink.m_iBestPath = i;
        }
    }
    
}

/*****************************************************************************
* CUnitSearch::Search *
*---------------------*
*   Description:
*       This is the main slm function, dp search for a segment of input phone
*     sequence will be done here.
*
*   Changes:
*       12/5/00 dpList and dpLink are now member variables so we don't have
*               to reallocate them each time.
*
******************************************************************* mplumpe ***/

int CUnitSearch::Search (Phone* phList, int nPh, ChkDescript** ppChunks, int* piNumChunks, double dStartTime)
{

    char leftPh[PHONE_MAX_LEN]="";
    char rightPh[PHONE_MAX_LEN]="";
    char centralPh[PHONE_MAX_LEN]="sil";
    char triph[MAX_CLUSTER_LEN];
    const char* clusterName;
    double newTime;
    double oldTime = 0.0;
    double newF0;
    double oldF0 = 100.0;
    int phonCnt;
    int i;
    int stateCount;
    int lastDone;
  
    assert (nPh==0 || phList!=NULL);
    assert (ppChunks && piNumChunks);
    
    oldTime = dStartTime;  
    phonCnt = 0;
    lastDone = 0;
    
    while ((phonCnt<nPh) || (!lastDone)) 
    {
        if ( phonCnt>=nPh ) 
        {
            sprintf(rightPh,"sil");
            lastDone = 1;
        }
        else 
        {
            strcpy(rightPh, phList[phonCnt].phone);
            newTime = phList[phonCnt].end;
            newF0   = phList[phonCnt].f0;
        }
    
        if (*leftPh && strcmp(centralPh,"sil")) 
        {	
            sprintf(triph,"%s-%s+%s",leftPh,centralPh,rightPh) ;

            if ((stateCount = m_pSpeakerData->m_pTrees->GetNumStates(triph)) <= 0)
            {
                return 0;
            }
                
            // Find cluster for each state 
            for ( i=0; i <stateCount; i++) 
            {                 
                if ((clusterName = m_pSpeakerData->m_pTrees->TriphoneToCluster( triph, i)) == 0 )
                {
                    return 0;
                }

                m_dpLink.m_cands.resize(0);
                m_pSpeakerData->m_pClusters->GetStats( clusterName, 0, &m_dpLink.m_dAverF0, 
                                                     &m_dpLink.m_dAverRms, &m_dpLink.m_dAverDur);
                                
                m_dpLink.m_dTime = (i < (stateCount-1)) ? ((float) i - stateCount + 1) : oldTime;

                if (m_iDynSearch) 
                {
                    m_pSpeakerData->m_critSect.Lock();

                    int iEquivCount = m_pSpeakerData->m_pClusters->GetEquivalentCount (clusterName);                
                
                    for (int j=0; j<iEquivCount; j++)
                    {
                        DPCand cand;
                        cand.segment = m_pSpeakerData->m_pClusters->GetEquivalent( j );
                        m_dpLink.m_cands.push_back(cand);
                    }

                    m_pSpeakerData->m_critSect.Unlock();

                }
                else 
                {
                    DPCand cand;

                    m_pSpeakerData->m_critSect.Lock();
                    cand.segment = m_pSpeakerData->m_pClusters->GetBestExample( clusterName );
                    m_pSpeakerData->m_critSect.Unlock();

                    m_dpLink.m_cands.push_back(cand);
                }


                ComputeDPInfo( &m_dpList.back(), m_dpLink, oldF0);

                m_dpList.push_back(m_dpLink);
            }
        }        
        else if (*leftPh) 
        {

            m_dpLink.m_cands.resize(0);
            m_pSpeakerData->m_pClusters->GetStats( "sil", 0, &m_dpLink.m_dAverF0, 
                                                    &m_dpLink.m_dAverRms, &m_dpLink.m_dAverDur);
                                
            m_dpLink.m_dTime = oldTime;

            if (m_iDynSearch)
            {
                m_pSpeakerData->m_critSect.Lock();
                int iEquivCount = m_pSpeakerData->m_pClusters->GetEquivalentCount ("sil");                
                
                for (int j=0; j<iEquivCount; j++)
                {
                    DPCand cand;
                    cand.segment = m_pSpeakerData->m_pClusters->GetEquivalent( j );
                    m_dpLink.m_cands.push_back(cand);
                }   
                m_pSpeakerData->m_critSect.Unlock();

            }
            else 
            {
                DPCand cand;
                m_pSpeakerData->m_critSect.Lock();
                cand.segment = m_pSpeakerData->m_pClusters->GetBestExample( "sil" );
                m_pSpeakerData->m_critSect.Unlock();
                m_dpLink.m_cands.push_back(cand);
            }

            if (m_dpList.size() == 0)
            {
                ComputeDPInfo( 0, m_dpLink, oldF0);
            }
            else 
            {
                ComputeDPInfo( &m_dpList.back(), m_dpLink, oldF0);
            }

            m_dpList.push_back(m_dpLink);
        }
    
        strcpy(leftPh, centralPh);
        strcpy(centralPh, rightPh);
        oldTime = newTime;
        oldF0   = newF0;
        phonCnt++;    
    }
  
    
#ifdef _DEBUG_
    DebugDPInfo (m_dpList);
#endif
  
    if (!FindOptimalPath (m_dpList, dStartTime, ppChunks, piNumChunks) ) 
    {
        return 0;
    }
  
    m_dpList.resize(0); 
  
    return 1;  
}

/*****************************************************************************
* CUnitSearch::FindOptimalPath *
*------------------------------*
*   Description:
*
******************************************************************* PACOG ***/

int CUnitSearch::FindOptimalPath (std::vector<DPLink>& rDPList, double dStartTime, 
                                  ChkDescript** ppChunks, int* piNumChunks)
{
    int* piIndexes;
    int  iNumIndexes;
    double dRunTime = 0.0;
    double dTimeSlot = 0.0;
    double dTotalSegDur;
    double dGain;
    double dPrevTime = 0.0;
    int i;
    int j;
    
    assert (ppChunks);
    assert (piNumChunks);
    
    dRunTime = dStartTime;
    
    iNumIndexes = rDPList.size();
    piIndexes = new int[iNumIndexes];
    
    if (piIndexes) 
    {        
        Backtrack (rDPList, piIndexes);
        
#ifdef _SLM_DEBUG
        DebugOptimalPath (list, lLength, piIndexes);
#endif
        
        for (i=0; i<iNumIndexes; i++) 
        {            
            if ( !m_pSpeakerData->GetFrontEndFlag() )
            {
                //--- use TrueTalk Front End
                //--- use target duration as finnal output duration
                if (rDPList[i].m_dTime > 0.0) 
                {   // final state 
                    dRunTime  = rDPList[i].m_dTime;        
                } 
                else if (rDPList[i].m_dTime< 0) 
                {
                    dTotalSegDur = 0;
                    for (j=(int)rDPList[i].m_dTime; j<=0; j++)
                    {
                        dTotalSegDur += rDPList[i-j].m_cands[piIndexes[i-j]].segment->dur; // remember, j is -ve 
                    }
                    dTimeSlot =  (rDPList[i-(int)rDPList[i].m_dTime].m_dTime- dRunTime)/dTotalSegDur;
                    dRunTime += dTimeSlot * rDPList[i].m_cands[piIndexes[i]].segment->dur;
                    for (j=(int)rDPList[i].m_dTime; j<0; j++)
                    {
                        rDPList[i-j].m_dTime= 0; // remember, j is -ve 
                    }                
                } 
                else 
                {
                    dRunTime += dTimeSlot * rDPList[i].m_cands[piIndexes[i]].segment->dur;
                }
            }
            else
            {   
                //--- use MS Entropic Front End
                //--- use tree cluster duration as target duration, and m_dTime is dur_ratio  from frontend ---
                dTimeSlot = 1.0;
                j = i;
                if (0 == strcmp ("sil", rDPList[j].m_cands[0].segment->clusterName))
                {
                    dRunTime += rDPList[j].m_dTime - dPrevTime;
                    dPrevTime = rDPList[j].m_dTime;
                }
                else
                {
                    while ( j < iNumIndexes && rDPList[j].m_dTime < 0 )
                    {
                        j++;
                    }
                    if ( j < iNumIndexes && rDPList[j].m_dTime > 0 )
                    {
                        dTimeSlot = rDPList[j].m_dTime - dPrevTime;
                        if (i == j)
                        {
                            dPrevTime = rDPList[j].m_dTime;
                        }
                    }
                    dRunTime += rDPList[i].m_dAverDur * dTimeSlot;
                }
            }
            if(rDPList[i].m_cands[piIndexes[i]].segment->rms > 0) 
            {
                dGain = rDPList[i].m_dAverRms/rDPList[i].m_cands[piIndexes[i]].segment->rms;
            }
            else 
            {
                dGain = 1.0;
            }
    
            GenerateOutput (ppChunks, piNumChunks, 
                            rDPList[i].m_cands[piIndexes[i]].segment->clusterName, 
                            dRunTime, 
                            rDPList[i].m_cands[piIndexes[i]].segment->chunkIdx,
                            rDPList[i].m_cands[piIndexes[i]].segment->start, 
                            rDPList[i].m_cands[piIndexes[i]].segment->start + 
                            rDPList[i].m_cands[piIndexes[i]].segment->dur,
                            rDPList[i].m_cands[piIndexes[i]].segment->rms,
                            rDPList[i].m_dTargF0,
                            rDPList[i].m_cands[piIndexes[i]].segment->f0 * (rDPList[i].m_cands[piIndexes[i]].segment->f0flag != 0 ? 1 : 0 ),
                            dGain);
        }
        
        delete[] piIndexes;
    }
    
    FlushOutput (ppChunks, piNumChunks);
    
    return 1;
}


/*****************************************************************************
* CUnitSearch::Backtrack *
*------------------------*
*   Description:
*
******************************************************************* PACOG ***/
void CUnitSearch::Backtrack (std::vector<DPLink>& rDPList, int* piIndexes) 
{
    assert (piIndexes);
    
    int i = rDPList.size() - 1;
    int iPrev = rDPList[i].m_iBestPath;
    
    for (; i>=0; i--) 
    {
        piIndexes[i] = iPrev;        
        iPrev = rDPList[i].m_cands[iPrev].prevPath;
    }  
}

/*****************************************************************************
* CUnitSearch::Backtrack *
*------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CUnitSearch::GenerateOutput (ChkDescript** ppChunks, int* piNumChunks, const char* pszCluster,
                                 double dTime, int iChunkIdx, double dFrom, double dTo, 
                                 double dRms, double targF0, double srcF0, double dGain)
{
    char   pszPhone[20] = "";
//    int    difSegments;
    int    contiguous;
    double outGain = 1.0;


    if (!m_iBlend)
    {

        outGain = (m_iUseGain) ? dGain :  1.0;

        AddChunk (ppChunks, piNumChunks, pszCluster, dTime, iChunkIdx, dFrom, dTo, targF0, srcF0, outGain);

    } 
    else 
    {
  
        if (pszCluster) 
        {

            CentralPhone (pszCluster, pszPhone);
    
            if (m_iChunkIdx1!= -1) {
      
                //        difSegments =  (strcmp (pszPhone, m_pszLastPhone)!=0);
/*                difSegments =  (strcmp (pszPhone, m_pszLastPhone)!=0) 
                        && ( (Unvoiced(pszPhone) && !Unvoiced(m_pszLastPhone) ) || 
                        ( !Unvoiced(pszPhone) && Unvoiced(m_pszLastPhone)) );
*/
                contiguous = (fabs(dFrom - m_dTo1) < .0001) && (m_iChunkIdx1 == iChunkIdx);
      
//                if ( contiguous && !difSegments ) {
                if ( contiguous ) {
        
                    if (strcmp(m_pszLastPhone, pszPhone)) {
                        strcat(strcat (m_pszUnitName, "_"), pszPhone);
                    }
        
                    m_dTime1    = dTime;
                    m_dTo1      = dTo;
                    m_dGain1   += dGain * dRms;
                    m_dNumAcum += dRms;
                    if ( srcF0 > 0.0 )
                    {
                        m_dSrcF0 += srcF0;
                        m_iNumSrcF0++;
                    }
                    m_dTargF0 += targF0;
                    m_iNumTargF0++;
                    
                } else {
                    
                    outGain = (m_iUseGain) ? m_dGain1/(m_dNumAcum) : 1.0;
                    if ( m_iNumTargF0 > 1 )
                    {
                        m_dTargF0 /= m_iNumTargF0;
                    }
                    if ( m_iNumSrcF0 > 1 )
                    {
                        m_dSrcF0 /= m_iNumSrcF0;
                    }
                    
                    AddChunk (ppChunks, piNumChunks, m_pszUnitName, m_dTime1, m_iChunkIdx1, 
                        m_dFrom1, m_dTo1, m_dTargF0, m_dSrcF0, outGain);
                    
                    strcpy(m_pszUnitName, pszPhone);
                    m_dNumAcum = dRms;
                    m_iChunkIdx1 = iChunkIdx;
                    m_dTime1 = dTime;
                    m_dFrom1 = dFrom;
                    m_dTo1 = dTo;
                    m_dGain1= dGain * dRms;
                    m_dSrcF0 = srcF0;
                    if ( srcF0 > 0 )
                    {
                        m_iNumSrcF0 = 1;
                    }
                    else
                    {
                        m_iNumSrcF0 = 0;
                }
                    m_dTargF0 = targF0;
                    m_iNumTargF0 = 1;
                }
                
            } else {
                
                if (strcmp(m_pszLastPhone, pszPhone)) 
                {
                    strcat (m_pszUnitName, pszPhone);
                }
                
                m_dTime1 = dTime;
                m_iChunkIdx1 = iChunkIdx;
                m_dFrom1 = dFrom;
                m_dTo1 = dTo;
                m_dNumAcum = dRms;
                m_dGain1 = dGain * dRms;
                m_dSrcF0 = srcF0;
                if ( srcF0 > 0 )
                {
                    m_iNumSrcF0 = 1;
                }
                else
                {
                    m_iNumSrcF0 = 0;
            }
                m_dTargF0 = targF0;
                m_iNumTargF0 = 1;
            
            }
            
            strcpy (m_pszLastPhone, pszPhone);
            
        } else {
            
            outGain = (m_iUseGain) ? m_dGain1/(m_dNumAcum) : 1.0;
            
            if ( m_iNumTargF0 > 1 )
            {
                m_dTargF0 /= m_iNumTargF0;
            }
            if ( m_iNumSrcF0 > 1 )
            {
                m_dSrcF0 /= m_iNumSrcF0;
            }
            
            AddChunk (ppChunks, piNumChunks, m_pszUnitName, m_dTime1, m_iChunkIdx1, 
                        m_dFrom1, m_dTo1, m_dTargF0, m_dSrcF0, outGain);
            
        }
        
    }
    
    return 1;
}
/*****************************************************************************
* CUnitSearch::Unvoiced *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CUnitSearch::Unvoiced (const char* pszPhone)
{
    if (*pszPhone=='s' || *pszPhone=='z' || *pszPhone== 'f' ||  //Includes z and zh
        *pszPhone=='k' || *pszPhone=='p' || *pszPhone=='t' )    // Includes t and th
    {
        return 1;
    }
    return 0;
}

/*****************************************************************************
* CUnitSearch::CentralPhone *
*---------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CUnitSearch::CentralPhone ( const char *pszTriphone, char *pszPhone )
{
    char *ptr;
    
    strcpy( pszPhone, pszTriphone);
    
    ptr = strchr(pszPhone, '_');  
    if (ptr) 
    {
        *ptr = '\0';
    }
    else 
    {
        ptr = strchr(pszPhone, ';');  
        if (ptr) 
        {
            *ptr='\0';
        }
    }
    
    return 1;
}


/*****************************************************************************
* CUnitSearch::AddChunk *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CUnitSearch::AddChunk (ChkDescript** ppChunks, int* piNumChunks, const char* name, 
                           double time, int chunkIdx, double from, double to, 
                           double targF0, double srcF0, double gain)
{
    assert (ppChunks);
    assert (piNumChunks);
    assert (time>=0.0);
    assert (chunkIdx>=0);
    assert (from>=0.0);
    assert (to>from);
    assert (gain!=0.0);

    if (*ppChunks) 
    {
        *ppChunks = (ChkDescript *)realloc (*ppChunks, (*piNumChunks + 1) * sizeof (**ppChunks));
    }
    else 
    {
        assert (*piNumChunks ==0);
        *ppChunks = (ChkDescript *)malloc (sizeof (**ppChunks));
    }

    if (*ppChunks == 0) 
    {
        return 0;
    }

    if (name) 
    {
         strcpy( (*ppChunks)[*piNumChunks].name, name );
    }
    else
    {
        (*ppChunks)[*piNumChunks].name[0] = 0;
    }
    (*ppChunks)[*piNumChunks].end            = time;
    (*ppChunks)[*piNumChunks].from           = from;
    (*ppChunks)[*piNumChunks].to             = to;
    (*ppChunks)[*piNumChunks].gain           = gain;
    (*ppChunks)[*piNumChunks].srcF0          = srcF0;
    (*ppChunks)[*piNumChunks].targF0         = targF0;

    if (m_pSpeakerData->m_pFileNames)
    {
        (*ppChunks)[*piNumChunks].isFileName     = 1;
        (*ppChunks)[*piNumChunks].chunk.fileName = m_pSpeakerData->m_pFileNames[chunkIdx].m_psz;
        if ((*ppChunks)[*piNumChunks].chunk.fileName == NULL) 
        {
            return 0;
        }
    } 
    else 
    {  
        (*ppChunks)[*piNumChunks].isFileName     = 0;
        (*ppChunks)[*piNumChunks].chunk.chunkIdx = chunkIdx;
    }

    (*piNumChunks)++;
  
    return 1;
}

/*****************************************************************************
* CUnitSearch::AddChunk *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
void CUnitSearch::FlushOutput (ChkDescript** ppChunks, int* piNumChunks)
{  
    if (*m_pszUnitName) 
    {
        double gain = (m_iUseGain) ? m_dGain1/(m_dNumAcum) : 1.0;

        if ( m_iNumTargF0 > 1 )
        {
            m_dTargF0 /= m_iNumTargF0;
        }
        if ( m_iNumSrcF0 > 1 )
        {
            m_dSrcF0 /= m_iNumSrcF0;
        }


        AddChunk (ppChunks, piNumChunks, m_pszUnitName, 
            m_dTime1, m_iChunkIdx1, m_dFrom1, m_dTo1, m_dTargF0, m_dSrcF0, gain);
    }

    m_pszLastPhone[0] = '\0';
    m_pszUnitName[0]  = '\0';
    m_iChunkIdx1      = -1;
    m_dNumAcum        = 0.0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\makefile.inc ===
SelfRegister :
!if defined(MAKEDLL)
	regsvr32 /s $(O)\$(TARGETNAME).dll
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\frontend\frontend.h ===
/******************************************************************************
* FrontEnd.h *
*------------*
*  This module is the declaration of class CTrueTalk 
*------------------------------------------------------------------------------
*  Copyright (C) 1998 Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 02/29/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef __FRONTEND_H_
#define __FRONTEND_H_

#include <stdio.h>
struct Phone;

class CFrontEnd
{
    public:
        virtual ~CFrontEnd() {};

        virtual int   Init (const char* pszDictPath, const char* pszUserDict = 0) = 0;
        virtual void  SetSpeakerParams (int iBaseLine, int iRefLine, int iTopLine, bool fIsBrEng) = 0;
        virtual void  Lock() = 0;
        virtual void  Unlock() = 0;
        virtual char* Process (char* pszTextInput, Phone** ppPhones, int* piNumPhones, float** ppfF0, int* piNumF0) = 0;
        virtual char* Pronunciation (char* pszTextInput, FILE* fp) = 0;
        virtual void  SetDebugLevel (int iModule, int iDebugLevel) = 0;
        virtual void  SetRate (int iRate) = 0;
        static CFrontEnd* ClassFactory();
        static void   InitThreading();
        static void   ReleaseThreading();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\unitsearch.h ===
/******************************************************************************
* UnitSearch.h *
*--------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00 - 12/5/00
*  All Rights Reserved
*
********************************************************************* mplumpe ***/

#ifndef __UNITSEARCH_H_
#define __UNITSEARCH_H_

#include <stdio.h>
#include <vector>

class  CSpeakerData;
struct DPLink;
struct Phone;
struct ChkDescript;

struct WeightsBasic 
{
    float f0;
    float dur;
    float rms;
    float lkl;
    float cont;
    float sameSeg;
};

struct Weights 
{
    float f0;
    float dur;
    float rms;
    float lkl;
    float cont;
    float sameSeg;
    float phBdr;
    float f0Bdr;
};

struct SegInfo;

struct DPCand 
{  
    SegInfo* segment;
    double  f0Weight;
    double  durWeight;
    double  lklWeight;
    double  rmsWeight;
    double  contWeight;
    double  acumWeight;
    int     prevPath;
};

struct DPLink
{
    std::vector<DPCand> m_cands;
    int    m_iBestPath;
    double m_dTime;
    double m_dAverRms;
    double m_dAverDur;
    double m_dAverF0;
    double m_dTargF0;
};


class CUnitSearch
{
    public:
        CUnitSearch(int iDynSearch = 0, int iBlend = 0, int iUseTargetF0 = 0, int iUseGain = 0);

        void  SetSpeakerData (CSpeakerData* pSpeakerData);
        int   Search (Phone* pPhList, int iNumPh, ChkDescript** ppChunks, int* piNumChunks, double dStartTime);

    private:
        void ComputeDPInfo (DPLink* rLastLink, DPLink& rNewLink, double targetF0);
        int  FindOptimalPath (std::vector<DPLink>& rDPList, double dStartTime, ChkDescript** ppChunks, int* piNumChunks);
        void Backtrack (std::vector<DPLink>& rDPList, int* piIndexes);
        int  GenerateOutput (ChkDescript** chunks, int* nChunks, const char* cluster,
                             double time, int chunkIdx, double from, double to, double rms, 
                             double targF0, double srcF0, double gain);    
        int  AddChunk (ChkDescript** ppChunks, int* piNumChunks, const char* pszName, double dTime, 
                       int iChunkIdx, double dFrom, double dTo, double targF0, double srcF0, double dGain);
        void FlushOutput (ChkDescript** ppChunks, int* piNumChunks);
        int CentralPhone ( const char *pszTriphone, char *pszPhone );
        int Unvoiced (const char* pszPhone);

        int    m_iDynSearch;
        int    m_iBlend;
        int    m_iUseTargetF0;
        int    m_iUseGain;
        
        Weights       m_weights;
        CSpeakerData* m_pSpeakerData;

        // Blend variables
        char   m_pszLastPhone[20];
        char   m_pszUnitName[1024]; //Don't know if this is enough (We probably don't need it)
        int    m_iChunkIdx1;
        double m_dTime1;
        double m_dFrom1;
        double m_dTo1;
        double m_dGain1;
        double m_dNumAcum;

        // f0 ratio
        double m_dSrcF0;
        double m_dTargF0;
        int    m_iNumSrcF0;
        int    m_iNumTargF0;

        // Worker variables used in Search, here so they aren't constantly deleted and re-allocated
        std::vector<DPLink> m_dpList;
        DPLink              m_dpLink;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\regvoices\makefile.inc ===
RunProgram :
	$(O)\$(TARGETNAME).exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\backend\vqtable.cpp ===
/******************************************************************************
* VqTable.cpp *
*-------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00 - 12/4/00
*  All Rights Reserved
*
********************************************************************* mplumpe  was PACOG ***/

#include "VqTable.h"
#include <assert.h>

/*****************************************************************************
* CVqTable::CVqTable *
*--------------------*
*   Description:
*
******************************************************************* mplumpe ***/
CVqTable::CVqTable ()
{   
    m_pfValue = 0;
    m_ppfValue = 0;
    m_iDim = 0;
    m_fOldWeight = 1.0;
}   

/*****************************************************************************
* CVqTable::~CVqTable *
*---------------------*
*   Description:
*
******************************************************************* mplumpe ***/
CVqTable::~CVqTable ()
{
    if (m_pfValue)
    {
        delete[] m_pfValue;
    }
    if (m_ppfValue)
    {
        delete[] m_ppfValue;
    }
}

/*****************************************************************************
* CVqTable::Element *
*-------------------*
*   Description:
*  Now located in header
******************************************************************* mplumpe ***/

/*****************************************************************************
* CVqTable::Dimension *
*---------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CVqTable::Dimension ()
{
    return m_iDim;
}

/*****************************************************************************
* CVqTable::Load *
*----------------*
*   Description:
*
******************************************************************* mplumpe ***/
int CVqTable::LoadFromFile (FILE* fin)
{
    short aux;

    assert (fin);

    if (!fread (&aux, sizeof (aux), 1, fin)) {
        return 0;
    }
    m_iDim = aux;

    if (!fread (&aux, sizeof(aux), 1, fin)) {
        return 0;
    }

    assert (aux == m_iDim);  //Should be the a square matrix

    if (m_pfValue)
    {
        delete[] m_pfValue;
    }

    if ((m_pfValue = new float[m_iDim * m_iDim]) == 0)
    {
        return 0;
    }
    if ((m_ppfValue = new float*[m_iDim]) == 0)
    {
        return 0;
    }

    if (!fread (m_pfValue, sizeof (float), m_iDim * m_iDim, fin)) 
    {
        return 0;
    }
    // Make array to lookup in table so we don't have to do a multiply
    for (aux=0; aux < m_iDim; aux++)
    {
        m_ppfValue[aux] = m_pfValue+aux*m_iDim;
    }

    m_fOldWeight = 1.0;

    return 1;
}

/*****************************************************************************
* CVqTable::Scale *
*-----------------*
*   Description:
*
******************************************************************* PACOG ***/

void CVqTable::Scale (double dContWeight)
{
    if (m_iDim > 0 )
    {
        for (int i=0; i<m_iDim; i++) 
        {
            for (int j=0; j<m_iDim; j++) 
            {
                m_pfValue[i * m_iDim + j] *= (float) (dContWeight / m_fOldWeight);
            }
        }

        m_fOldWeight = (float)dContWeight;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\queue.cpp ===
/******************************************************************************
* queue.cpp *
*-----------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 02/29/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "stdafx.h"
#include "queue.h"
#include <stdio.h>
#include <assert.h>



/*****************************************************************************
* CPhStrQueue::CPhStrQueue *
*--------------------------*
*   Description:
*       Allocate memory to implement a queueue of the desired 
*     length, and with the desired structure size
*       int length  - length (or depth) of the queue.
*       int size    - size of each of the queue elements in number of bytes
******************************************************************* PACOG ***/
CPhStrQueue::CPhStrQueue (int iLength)
{
    assert(iLength>0);

    m_pArrayBegin = 0;
    m_pArrayEnd   = 0;
    m_pTop        = 0;
    m_pBottom     = 0;
    m_iLength     = iLength;
    m_iNumEntries = 0;
}


/*****************************************************************************
* CPhStrQueue::~CPhStrQueue *
*---------------------------*
*   Description:
*
******************************************************************* PACOG ***/
CPhStrQueue::~CPhStrQueue()
{  
    if (m_pArrayBegin) 
    {
        delete[] m_pArrayBegin;
    }
}

/*****************************************************************************
* CPhStrQueue::Init *
*-------------------*
*   Description:
*       Allocates memory for the queue.
*
******************************************************************* PACOG ***/

bool CPhStrQueue::Init ()
{
    PhoneString* pData;  

    assert(m_iLength>0);

    pData = new PhoneString[m_iLength]; // memory for the data elements 
        
    if (pData) 
    {
        m_pArrayBegin = pData;                 // Top of memory 
        m_pArrayEnd   = pData + m_iLength - 1; // last element of memory 
        m_pTop        = pData;                 // first entry in the queue 
        m_pBottom     = pData;                 // last entry in the queue 

        return true;
    }

    return false;
}


/*****************************************************************************
* CPhStrQueue::Reset *
*--------------------*
*   Description:
*       
*
******************************************************************* PACOG ***/
void CPhStrQueue::Reset ()
{
    while (m_iNumEntries>0) 
    {    
        if (m_pBottom == m_pArrayBegin) 
        {
            m_pBottom = m_pArrayEnd - 1;
        } 
        else 
        {
            m_pBottom--;
        }
  
        m_iNumEntries--;

        free (m_pBottom->pPhones); //BUGBUG-- Do not free this way!!!
        free (m_pBottom->pfF0);
    }
}

/*****************************************************************************
* CPhStrQueue::Push *
*-------------------*
*   Description:
*       Push a new element on the queue 
*
******************************************************************* PACOG ***/

bool CPhStrQueue::Push (Phone* pPhones, int iNumPhones, float* pfF0, int iNumF0)
{
    assert(pPhones && iNumPhones>0);
    assert(pfF0 && iNumF0>0);
  
    if (m_pArrayBegin == 0 && ! Init() )
    {
        return false; // Couldn't allocate memory
    }

    if (m_iNumEntries >= m_iLength) 
    {
        return false; // Out of space in queue
    }

    m_pBottom->pPhones    = pPhones;
    m_pBottom->iNumPhones = iNumPhones;
    m_pBottom->pfF0       = pfF0;
    m_pBottom->iNumF0     = iNumF0;
    
    m_iNumEntries++;
  
    if (++m_pBottom >= m_pArrayEnd)
    {
        m_pBottom = m_pArrayBegin; // wrap arount linear memory to simulate circular buffer 
    }

    return true;
}


/*****************************************************************************
* CPhStrQueue::FirstElement *
*---------------------------*
*   Description:
*       Examine an element on the top of the que (FIFO)
*     Returns true- if somethin was retrieved. false- if queue was empty
*
******************************************************************* PACOG ***/

bool CPhStrQueue::FirstElement (Phone** ppPhones, int* piNumPhones, float** ppfF0, int* piNumF0)
{
    
    assert(ppPhones && piNumPhones);
    assert(ppfF0 && piNumF0);

    if (m_iNumEntries <= 0)
    {
        return false;
    }

    *ppPhones    = m_pTop->pPhones;
    *piNumPhones = m_pTop->iNumPhones;
    *ppfF0       = m_pTop->pfF0;
    *piNumF0     = m_pTop->iNumF0;
    
    return true;
}


/*****************************************************************************
* CPhStrQueue::Forward *
*----------------------*
*   Description:
*       Skip to the next element on the top of the queue
*   
******************************************************************* PACOG ***/

bool CPhStrQueue::Forward ()
{
    if (m_iNumEntries <= 0)
    {
        return false;
    }

    if (++m_pTop >= m_pArrayEnd) 
    {
        m_pTop = m_pArrayBegin;
    }

    m_iNumEntries--;  

    return true;
}


/*****************************************************************************
* CPhStrQueue::Pop *
*------------------*
*   Description:
*       Remove the last added element from the bottom of the queue
*
*     void *element - (O) pointer to the output elemnt
*   
******************************************************************* PACOG ***/

bool CPhStrQueue::Pop (Phone** ppPhones, int* piNumPhones, float** ppfF0, int* piNumF0)
{
    
    if (m_iNumEntries <= 0) 
    {
        return false;
    }

    if (m_pBottom == m_pArrayBegin) 
    {
        m_pBottom = m_pArrayEnd - 1;
    } 
    else 
    {
        m_pBottom--;
    }
  
    m_iNumEntries--;

    *ppPhones    = m_pBottom->pPhones;
    *piNumPhones = m_pBottom->iNumPhones;
    *ppfF0       = m_pBottom->pfF0;
    *piNumF0     = m_pBottom->iNumF0;

    return true;
}


/*****************************************************************************
* CPhStrQueue::Size *
*-------------------*
*   Description:
*       Number of elements currently in the queue
*   
******************************************************************* PACOG ***/
int CPhStrQueue::Size ()
{
    return m_iNumEntries;
}


/*****************************************************************************
* CPhStrQueue::Debug *
*--------------------*
*   Description:
*       Prints all the elements of the queue struct
*   
******************************************************************* PACOG ***/
void CPhStrQueue::Debug ()
{
  fprintf (stderr, "arrayBegin = %x\n", m_pArrayBegin);
  fprintf (stderr, "arrayEnd   = %x\n", m_pArrayEnd);
  fprintf (stderr, "top        = %x\n", m_pTop);
  fprintf (stderr, "bottom     = %x\n", m_pBottom);
  fprintf (stderr, "length     = %d\n", m_iLength);
  fprintf (stderr, "nentries   = %d\n", m_iNumEntries);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sptruetalk.rc
//
#define IDS_PROJNAME                    100
#define IDR_TRUETALK                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\sptruetalk.h ===
/* MIDL: this ALWAYS GENERATED file contains the definitions for the interfaces */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\queue.h ===
/******************************************************************************
* queue.h *
*---------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 02/29/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef __QUEUE_H_
#define __QUEUE_H_

#include <windows.h>

struct Phone;

struct PhoneString {
    Phone* pPhones;
    int    iNumPhones;
    float* pfF0;
    int    iNumF0;
};


class CPhStrQueue {
    public:
        CPhStrQueue (int iLength);
        ~CPhStrQueue (); 

        bool Push (Phone* pPhones, int iNumPhones, float* pfF0, int iNumF0);
        bool Pop  (Phone** ppPhones, int* piNumPhones, float** ppfF0, int* piNumF0);
        bool FirstElement (Phone** ppPhones, int* piNumPhones, float** ppfF0, int* piNumF0);
        bool Forward ();
        int  Size ();
        void Debug ();
        void Reset ();

    private:
        bool Init ();

        PhoneString* m_pArrayBegin; // Top of memory 
        PhoneString* m_pArrayEnd;   // last element of memory 
        PhoneString* m_pTop;        // first entry in the queue 
        PhoneString* m_pBottom;     // last entry in the queue 
        int   m_iLength;             // Length of the queue 
        int   m_iNumEntries;         // Current Number of entries in the queue 
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\regvoices\regvoices.cpp ===
/******************************************************************************
* RegVoices.cpp *
*---------------*
*  
* This code does not ship. Based on MC's code for msttsdrv.
*
* This code creates the registry entries for the TTS voices. The
* datafiles registered here are the ones checked in the slm source 
* tree. This is not done using a reg file because we need to compute 
* the absolute path of the datafiles which can be different on different 
* machines because of different root slm directories.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/20/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/
#include <windows.h>
#include <atlbase.h>
#include "sphelper.h"
#include "spddkhlp.h"
#include "getopt.h"
#include <spunicode.h>
#include <stdio.h>


#define SYNTAX fprintf (stderr, "RegVoices [-u (UK Eng voice)] [voicesPath]\n")

#define DIR_LEVELS_BACK 4       // Back levels to 'TrueTalk' directory


static HRESULT CreateVoiceSubKey(
                                 const WCHAR * pszSubKeyName, 
                                 const WCHAR  * pszDescription,
                                 BOOL fVendorDefault, 
                                 const WCHAR * pszLanguage,
                                 const WCHAR * pszGender,
                                 const WCHAR * pszAge,
                                 const WCHAR * pszVoicePath, 
                                 const WCHAR * pszVoiceName,
                                 const WCHAR * pszLexPath,
                                 double dGain);

const CLSID CLSID_TrueTalk       = {0x8E67289A,0x609C,0x4B68,{0x91,0x8B,0x5C,0x35,0x2D,0x9E,0x5D,0x38}};
const CLSID CLSID_PhoneConverter = {0x9185F743,0x1143,0x4C28,{0x86,0xB5,0xBF,0xF1,0x4F,0x20,0xE5,0xC8}};
const WCHAR* g_UKPhoneMap = L"- 0001 ! 0002 & 0003 , 0004 . 0005 ? 0006 _ 0007 1 0008 2 0009 AA 000A AE 000B AH 000C AO 000D AW 000E AX 000F AY 0010 B 0011 CH 0012 D 0013 DH 0014 EH 0015 ER 0016 EY 0017 F 0018 G 0019 H 001A IH 001B IY 001C JH 001D K 001E L 001F M 0020 N 0021 NG 0022 OW 0023 OY 0024 P 0025 R 0026 S 0027 SH 0028 T 0029 TH 002A UH 002B UW 002C V 002D W 002E Y 002F Z 0030 ZH 0031 EX 0032 UR 0033";

//-- Static 
CSpUnicodeSupport g_Unicode;
                            
/*****************************************************************************
* main  *
*-------*
*   Description:
*   Locate the abs path to Simon, etc.
*   and register them in the system registry.
*       
******************************************************************* PACOG ***/
int wmain (int argc, wchar_t* argv[])
{
    HRESULT hr = S_OK;
    WCHAR szVoiceDataPath[MAX_PATH];
    WCHAR szDictDataPath[MAX_PATH];
    bool fUkVoice = false;
    CWGetOpt getOpt;
    int iChar;

    CoInitialize(NULL);

    getOpt.Init(argc, argv, L"u");

    while ( (iChar = getOpt.NextOption()) != EOF )
    {
        switch (iChar)
        {
        case L'u':
            fUkVoice = true;
            break;
        case L'?':
        default:
            SYNTAX;
            goto exit;
        }
    }

    switch (argc - getOpt.OptInd()) 
    {
    case 1:
        wcscpy (szVoiceDataPath, argv[getOpt.OptInd()]);
        wcscat (szVoiceDataPath, L"\\" );
        break;
    case 0:
        //-- Get the exe's location...
        if( !g_Unicode.GetModuleFileName(NULL, szVoiceDataPath, MAX_PATH) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        //-- ...and derive abs path to VOICE and DICT data
        if( SUCCEEDED(hr) )
        {
            WCHAR *psz;
            // modulename is "<sapi5>\Src\TTS\TrueTalk\RegVoices\Obj\i386\RegVoices.exe"
            // data is at "<sapi5>\Src\TTS\TrueTalk\Voices\"
            for ( int i = 0; i < DIR_LEVELS_BACK; i++ )
            {
                psz = wcsrchr( szVoiceDataPath, '\\' );
                if (psz != 0)
                {
                    *psz= 0;
                }
                else
                {
                    hr = E_FAIL;
                    break;
                }
            }
        }

        wcscat( szVoiceDataPath, L"\\Voices\\" );
        break;

    default:
        SYNTAX;
        goto exit;
    }

    wcscat( wcscpy(szDictDataPath, szVoiceDataPath), L"Dict");

    //-- Register the TrueTalk voices..
    if( SUCCEEDED(hr) )
    {
        hr = CreateVoiceSubKey(L"TTSimonMin", 
                               L"TrueTalk Simon Min", 
                               FALSE,
                               L"409;9",
                               L"Male",
                               L"Adult",
                               szVoiceDataPath,
                               L"Simon\\sa8kMin.sfont",
                               szDictDataPath,
                               3.0);
    }

    if( SUCCEEDED(hr) )
    {
        hr = CreateVoiceSubKey(L"TTSimon150", 
                               L"TrueTalk Simon 150", 
                               FALSE,
                               L"409;9",
                               L"Male",
                               L"Adult",
                               szVoiceDataPath,
                               L"Simon\\sa8k150.sfont",
                               szDictDataPath,
                               3.0);
    }

    if( SUCCEEDED(hr) )
    {
        hr = CreateVoiceSubKey(L"TTMaryMin", 
                               L"TrueTalk Mary Min", 
                               FALSE,
                               L"409;9",
                               L"Female",
                               L"Adult",
                               szVoiceDataPath,
                               L"Mary\\ml8kMin.sfont",
                               szDictDataPath,
                               3.0);
    }

    if( SUCCEEDED(hr) )
    {
        hr = CreateVoiceSubKey(L"TTMary150", 
                               L"TrueTalk Mary 150", 
                               FALSE,
                               L"409;9",
                               L"Female",
                               L"Adult",
                               szVoiceDataPath,
                               L"Mary\\ml8k150.sfont",
                               szDictDataPath,
                               3.0);
    }

    if (fUkVoice)
    {
        if( SUCCEEDED(hr) )
        {
            hr = CreateVoiceSubKey(L"TTDianeMin", 
                L"TrueTalk Diane Min", 
                FALSE,
                L"809;9",
                L"Female",
                L"Adult",
                szVoiceDataPath,
                L"Diane\\dk8kMin.sfont",
                szDictDataPath,
                5.0);
        }
        
        if( SUCCEEDED(hr) )
        {
            hr = CreateVoiceSubKey(L"TTDiane150", 
                L"TrueTalk Diane 150", 
                FALSE,
                L"809;9",
                L"Female",
                L"Adult",
                szVoiceDataPath,
                L"Diane\\dk8k150.sfont",
                szDictDataPath,
                5.0);
        }

        if( SUCCEEDED(hr) )
        {
            CComPtr<ISpObjectToken> cpToken;
            CComPtr<ISpDataKey> cpDataKeyAttribs;

            hr = SpCreateNewTokenEx(
                SPCAT_PHONECONVERTERS, 
                L"English (UK)", 
                &CLSID_PhoneConverter, 
                L"UK English Phone Converter",
                0x0,
                NULL,
                &cpToken,
                &cpDataKeyAttribs);

            if (SUCCEEDED(hr))
            {
                hr = cpToken->SetStringValue(L"PhoneMap", g_UKPhoneMap);
            }
            if (SUCCEEDED(hr))
            {
                hr = cpDataKeyAttribs->SetStringValue(L"Language", L"809");
            }

        }

    }

exit:

    CoUninitialize();

    if (FAILED(hr))
    {
        return -1;
    }

    return 0;
}

/*****************************************************************************
* CreateVoiceSubKey  *
*--------------------*
*   Description:
*   Each TTS voice gets installed under one registry sub-key.
*   This function installs the single voice from the passed params.
*       
********************************************************************** MC ***/
HRESULT CreateVoiceSubKey(
                          const WCHAR * pszSubKeyName, 
                          const WCHAR  * pszDescription,
                          BOOL fVendorDefault, 
                          const WCHAR * pszLanguage,
                          const WCHAR * pszGender,
                          const WCHAR * pszAge,
                          const WCHAR * pszVoicePath, 
                          const WCHAR * pszVoiceName,
                          const WCHAR * pszDictPath,
                          double dGain)
{
    HRESULT hr;

    CComPtr<ISpObjectToken> cpToken;
    CComPtr<ISpDataKey> cpDataKeyAttribs;

    hr = SpCreateNewTokenEx(
            SPCAT_VOICES, 
            pszSubKeyName, 
            &CLSID_TrueTalk, 
            pszDescription,
            0x409,
            pszDescription,
            &cpToken,
            &cpDataKeyAttribs);

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Name", pszDescription);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Vendor", L"Microsoft");
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Language", pszLanguage);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Age", pszAge);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Gender", pszGender);
    }

    if (SUCCEEDED(hr) && fVendorDefault)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"VendorDefault", L"");
    }
    
    WCHAR szVoiceDataPath[MAX_PATH];
    if (SUCCEEDED(hr))
    {
        //--------------------------------
        // Voice DATA file location
        //--------------------------------
        wcscpy(szVoiceDataPath, pszVoicePath);
        wcscat(szVoiceDataPath, pszVoiceName);

        hr = cpToken->SetStringValue(L"Sfont", szVoiceDataPath);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetStringValue(L"Dictionary", pszDictPath);
    }

    if (SUCCEEDED(hr))
    {
        WCHAR pszGain[20];

        swprintf (pszGain, L"%.1f", dGain);
        hr = cpToken->SetStringValue(L"Gain", pszGain);
    }
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\sptruetalk.cpp ===
/******************************************************************************
* spTrueTalk.cpp *
*----------------*
*  This module is the DLL interace for the TrueTalk SAPI5 engine
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 02/29/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TrueTalk.h"

const IID   LIBID_SPTRUETALKLib = {0xEAAA999C,0xFCF0,0x412D,{0xAF,0xD9,0x08,0xD2,0xB5,0xE5,0x59,0xFD}};
const CLSID CLSID_TrueTalk      = {0x8E67289A,0x609C,0x4B68,{0x91,0x8B,0x5C,0x35,0x2D,0x9E,0x5D,0x38}};


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_TrueTalk, CTrueTalk)
END_OBJECT_MAP()

/*****************************************************************************
* DllMain *
*---------*
*   Description:
*       DLL Entry Point
******************************************************************* PACOG ***/
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SPTRUETALKLib);
        DisableThreadLibraryCalls(hInstance);
        CTrueTalk::InitThreading();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        CTrueTalk::ReleaseThreading();
    }
    return TRUE;    // ok
}

/*****************************************************************************
* DllCanUnloadNow *
*-----------------*
*   Description:
*       Used to determine whether the DLL can be unloaded by OLE
******************************************************************* PACOG ***/

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/*****************************************************************************
* DllGetClassObject *
*-------------------*
*   Description:
*       Returns a class factory to create an object of the requested type
******************************************************************* PACOG ***/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/*****************************************************************************
* DllRegisterServer  *
*--------------------*
*   Description:
*       Adds entries to the system registry
******************************************************************* PACOG ***/

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/*****************************************************************************
* DllUnregisterServer *
*---------*
*   Description:
*       Removes entries from the system registry
******************************************************************* PACOG ***/

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__64BB01C1_3E04_4CFF_9D51_2DCB72C16DF6__INCLUDED_)
#define AFX_STDAFX_H__64BB01C1_3E04_4CFF_9D51_2DCB72C16DF6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef STRICT
#undef STRICT
#endif
#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__64BB01C1_3E04_4CFF_9D51_2DCB72C16DF6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\truetalk.cpp ===
/******************************************************************************
* TrueTalk.cpp *
*--------------*
*  This module is the main implementation for class CTrueTalk 
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 02/29/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "stdafx.h"
#include "TrueTalk.h"
#include "frontend.h"
#include "backend.h"
#include "queue.h"

const int CTrueTalk::m_iQueueSize = 512;


static const char g_pFlagCharacter = 0x00;
static const unsigned char g_AnsiToAscii[] = 
{
    /*** Control characters - map to whitespace ***/
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20,
    /*** ASCII displayables ***/
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,
    /*** Control character ***/
    0x20,
    /*** Euro symbol ***/
    0x80,
    /*** Control character ***/
    0x20,
    /*** Extended ASCII values ***/
    0x27,     // low single quote - map to single quote
    0x20,     // f-like character - map to space
    0x22,     // low double quote - map to double quote
    0x2C,     // elipsis - map to comma
    0x20,     // cross - map to space
    0x20,     // double cross - map to space
    0x5E,     // caret like accent - map to caret
    0x89,     // strange percent like sign
    0x53,     // S-hat - map to S
    0x27,     // left angle bracket like thing - map to single quote
    0x20,     // weird OE character - map to space
    0x20,     // control characters - map to space
    0x20,
    0x20,
    0x20,
    0x27,     // left single quote - map to single quote
    0x27,     // right single quote - map to single quote
    0x22,     // left double quote - map to double quote
    0x22,     // right double quote - map to double quote
    0x20,     // bullet - map to space
    0x2D,     // long hyphen - map to hyphen
    0x2D,     // even longer hyphen - map to hyphen
    0x7E,     // tilde-like thing - map to tilde
    0x98,     // TM
    0x73,     // s-hat - map to s
    0x27,     // right angle bracket like thing - map to single quote
    0x20,     // weird oe like character - map to space
    0x20,     // control character - map to space
    0x20,     // control character - map to space
    0x59,     // Y with umlaut like accent - map to Y
    0x20,     // space? - map to space
    0x20,     // upside-down exclamation point - map to space
    0xA2,     // cents symbol
    0xA3,     // pounds symbol
    0x20,     // generic currency symbol - map to space
    0xA5,     // yen symbol
    0x7C,     // broken bar - map to bar
    0x20,     // strange symbol - map to space 
    0x20,     // umlaut - map to space
    0xA9,     // copyright symbol
    0x20,     // strange a character - map to space
    0x22,     // strange <<-like character - map to double quote
    0x20,     // strange line-like character - map to space
    0x2D,     // hyphen-like character - map to hyphen
    0xAE,     // registered symbol
    0x20,     // high line - map to space
    0xB0,     // degree sign
    0xB1,     // plus-minus sign
    0xB2,     // superscript 2
    0xB3,     // superscript 3
    0xB4,     // single prime
    0x20,     // greek character - map to space
    0x20,     // paragraph symbol - map to space
    0x20,     // mid-height dot - map to space
    0x20,     // cedilla - map to space
    0xB9,     // superscript one
    0x20,     // circle with line - map to space
    0x22,     // strange >>-like character - map to double quote
    0xBC,     // vulgar 1/4
    0xBD,     // vulgar 1/2
    0xBE,     // vulgar 3/4
    0x20,     // upside-down question mark - map to space
    0x41,     // Accented uppercase As - map to A
    0x41,
    0x41,
    0x41,
    0x41,
    0x41,
    0x41,
    0x43,     // C with cedilla - map to C
    0x45,     // Accented uppercase Es - map to E
    0x45,
    0x45,
    0x45,
    0x49,     // Accented uppercase Is - map to I
    0x49,
    0x49,
    0x49,
    0x20,     // strange character - map to space
    0x4E,     // Accented uppercase N - map to N
    0x4F,     // Accented uppercase Os - map to O
    0x4F,
    0x4F,
    0x4F,
    0x4F,
    0x20,     // strange character - map to space
    0x4F,     // another O? - map to O
    0x55,     // Accented uppercase Us - map to U
    0x55,
    0x55,
    0x55,
    0x59,     // Accented uppercase Y - map to Y
    0x20,     // strange character - map to space
    0xDF,     // Beta
    0x61,     // Accented lowercase as - map to a
    0x61,
    0x61,
    0x61,
    0x61,
    0x61,
    0x61,
    0x63,     // c with cedilla - map to c
    0x65,     // Accented lowercase es - map to e
    0x65,
    0x65,
    0x65,
    0x69,    // Accented lowercase is - map to i
    0x69,
    0x69,
    0x69,
    0x75,    // eth - map to t
    0x6E,    // Accented lowercase n - map to n
    0x6F,    // Accented lowercase os - map to o
    0x6F,
    0x6F,
    0x6F,
    0x6F,
    0xF7,     // division symbol
    0x6F,     // another o? - map to o
    0x76,    // Accented lowercase us - map to u
    0x76,
    0x76,
    0x76,
    0x79,     // accented lowercase y - map to y
    0x20,     // strange character - map to space
    0x79,     // accented lowercase y - map to y
};


/*****************************************************************************
* CTrueTalk::InitThreading *
*--------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CTrueTalk::InitThreading()
{
    CFrontEnd::InitThreading();
}

/*****************************************************************************
* CTrueTalk::ReleaseThreading *
*-----------------------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CTrueTalk::ReleaseThreading()
{
    CFrontEnd::ReleaseThreading();
}

/*****************************************************************************
* CTrueTalk::FinalConstruct *
*---------------------------*
*   Description:
*       Constructor
******************************************************************* PACOG ***/
HRESULT CTrueTalk::FinalConstruct()
{
    HRESULT hr = S_OK;

    m_cpToken = 0;
    m_pTtp    = 0;
    m_pBend   = 0;
    m_pPhoneQueue = 0;
    m_dGain   = 1.0;
    m_dwDebugLevel = 0;
    m_fTextOutput = false;

    m_WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM; 
    m_WaveFormatEx.nChannels = 1; 
    m_WaveFormatEx.nSamplesPerSec = 0; 
    m_WaveFormatEx.nAvgBytesPerSec = 0; 
    m_WaveFormatEx.nBlockAlign = 2; 
    m_WaveFormatEx.wBitsPerSample = 16; 
    m_WaveFormatEx.cbSize = 0;

    return hr;
}

/*****************************************************************************
* CTrueTalk::FinalRelease *
*-------------------------*
*   Description:
*       Destructor
******************************************************************* PACOG ***/
void CTrueTalk::FinalRelease()
{
    if ( m_pTtp) 
    {
        delete m_pTtp;
    }
    if ( m_pBend ) 
    {
        delete m_pBend;
    }
    if (m_pPhoneQueue)
    {
        delete m_pPhoneQueue;
    }
}

/*****************************************************************************
* CTrueTalk::SetObjectToken *
*---------------------------*
*   Description:
*       This function performs the majority of the initialization of the voice.
*   Once the object token has been provided, the filenames are read from the
*   token key and the files are mapped.+++
******************************************************************* PACOG ***/
STDMETHODIMP CTrueTalk::SetObjectToken (ISpObjectToken * pToken)
{
    HRESULT hr = SpGenericSetObjectToken(pToken, m_cpToken);
    char pszFilePath[_MAX_PATH+1];
    bool fIsBrEng = false;

    //-- Read debug info first
    if ( SUCCEEDED (hr) ) 
    {
        hr = m_cpToken->GetDWORD (L"DebugInterest", &m_dwDebugLevel);
        if ( FAILED(hr) ) 
        {
            m_dwDebugLevel = 0;
            hr = S_OK;
        }
    }

    // Determine engine language
    if (SUCCEEDED(hr))
    {
        CComPtr<ISpObjectToken> cpToken;
        CSpDynamicString dstrLanguage;

        hr = SpGetSubTokenFromToken(m_cpToken, L"Attributes", &cpToken);

        if (SUCCEEDED(hr))
        {
            hr = cpToken->GetStringValue (L"Language", &dstrLanguage);
        }
        if (SUCCEEDED(hr))
        {
            WCHAR* ptr;

            ptr = wcschr (dstrLanguage.m_psz, ';');
            if ( ptr )
            {
                *ptr = 0;
            }
            if (wcscmp(dstrLanguage.m_psz, L"809") == 0)
            {
                fIsBrEng = true;
            }
        }
    }
    
    //-- Initialize front-end
    if ( SUCCEEDED (hr) ) 
    {
        CSpDynamicString dstrFilePath;

        hr = m_cpToken->GetStringValue( L"Dictionary", &dstrFilePath );
        if (SUCCEEDED(hr))
        {
            WideCharToMultiByte (CP_ACP, 0, dstrFilePath.m_psz, -1, pszFilePath, _MAX_PATH, 0, 0); 
        }
    }
    if ( SUCCEEDED (hr) )
    {
        if ((m_pTtp = CFrontEnd::ClassFactory()) == 0) 
        {
            return E_OUTOFMEMORY;
        }
        

        if (!m_pTtp->Init (pszFilePath, 0)) 
        {
            if (m_dwDebugLevel) 
            {
                fprintf (stderr, "Error initializing ttp with dictionary path %s\n", pszFilePath);
            }
            return E_OUTOFMEMORY;
        }

        if ((m_pPhoneQueue = new CPhStrQueue (m_iQueueSize)) == 0) 
        {
            return E_OUTOFMEMORY;
        }        
    }
 
    //-- And now, the back end
    if ( SUCCEEDED (hr) ) 
    {
        CSpDynamicString dstrFilePath;

        hr = m_cpToken->GetStringValue( L"Sfont", &dstrFilePath );
        if (SUCCEEDED(hr))
        {
            WideCharToMultiByte (CP_ACP, 0, dstrFilePath.m_psz, -1, pszFilePath, _MAX_PATH, 0, 0); 
        }
    }
    if ( SUCCEEDED (hr) ) 
    {
        int iBaseLine;
        int iRefLine;
        int iTopLine;

        if ((m_pBend = CBackEnd::ClassFactory()) == 0) {
            return E_OUTOFMEMORY;
        }

        if ( !m_pBend->LoadTable (pszFilePath, m_dwDebugLevel) ) {
            if (m_dwDebugLevel) 
            {
                fprintf (stderr, "Error loading table %s\n", pszFilePath);
            }
            return E_OUTOFMEMORY;
        }
        
        CSpDynamicString dstrGain;
        hr = m_cpToken->GetStringValue( L"Gain", &dstrGain);
        if (SUCCEEDED(hr))
        {
            m_dGain = wcstod (dstrGain.m_psz, NULL);
            m_pBend->SetGain (m_dGain);
        }

        m_pBend->GetSpeakerInfo(&iBaseLine, &iRefLine, &iTopLine);
        m_pTtp->SetSpeakerParams(iBaseLine, iRefLine, iTopLine, fIsBrEng);

        m_WaveFormatEx.nSamplesPerSec  = m_pBend->GetSampFreq();
        m_WaveFormatEx.nAvgBytesPerSec = m_WaveFormatEx.nSamplesPerSec * m_WaveFormatEx.nBlockAlign;
    }

    return hr;
}

/****************************************************************************
* CTrueTalk::GetOutputFormat *
*----------------------------*
*   Description:
*
*   Returns:
*
******************************************************************* PACOG ***/
HRESULT CTrueTalk::GetOutputFormat( const GUID * pTargetFormatId, 
                                    const WAVEFORMATEX * pTargetWaveFormatEx,
                                    GUID * pDesiredFormatId, 
                                    WAVEFORMATEX ** ppCoMemDesiredWaveFormatEx )        
{
    HRESULT hr = S_OK;

    if( ( SP_IS_BAD_WRITE_PTR(pDesiredFormatId)  ) || 
		( SP_IS_BAD_WRITE_PTR(ppCoMemDesiredWaveFormatEx) ) )
    {
        hr = E_POINTER;
    }


    if ( pTargetFormatId && *pTargetFormatId == SPDFID_Text)
    {
        *pDesiredFormatId = SPDFID_Text;
        m_fTextOutput = true;
    }
    else 
    {        
        *pDesiredFormatId = SPDFID_WaveFormatEx;
        *ppCoMemDesiredWaveFormatEx = (WAVEFORMATEX *)::CoTaskMemAlloc(sizeof(WAVEFORMATEX));
        if (*ppCoMemDesiredWaveFormatEx)
        {
            **ppCoMemDesiredWaveFormatEx = m_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

/*****************************************************************************
* CTrueTalk::Speak *
*------------------*
*   Description:
*       This method is supposed to speak the text observing the associated
*   XML state.
******************************************************************* PACOG ***/
HRESULT CTrueTalk::Speak (DWORD dwSpeakFlags, 
                          REFGUID rguidFormatId, 
                          const WAVEFORMATEX * pWaveFormatEx, 
                          const SPVTEXTFRAG * pTextFragList, 
                          ISpTTSEngineSite * pOutputSite)
{
    HRESULT hr = S_OK;
    Phone*  pPhones = 0;
    int     iNumPhones;
    float*  pfF0 = 0;
    int     iNumF0;    
    char*   pcSamples = 0;
    int     iNumSamples = 0;
    
    if (SyncActions(pOutputSite) != 0)
    {
        goto exit;
    }

    hr = RunFrontEnd (pTextFragList, pOutputSite);

    if ( FAILED(hr)  )
    {
        goto exit;
    }
    
    while ( m_pPhoneQueue->Size() >0 ) //-- While something to synthesize
    {
        pPhones    = 0;
        iNumPhones = 0;
        pfF0   = 0;
        iNumF0 = 0;

        //-- Got something from front end, synthesize
        if (m_pPhoneQueue->FirstElement (&pPhones, &iNumPhones, &pfF0, &iNumF0))
        {
            m_pPhoneQueue->Forward();

            m_pBend->NewPhoneString (pPhones, iNumPhones, pfF0, iNumF0);

            while ( m_pBend->OutputPending() ) 
            {
                
                if (SyncActions(pOutputSite) != 0)
                {
                    break;
                }
                
                if (!m_pBend->GenerateOutput ( (short**)&pcSamples, &iNumSamples)) {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }

                if (pcSamples) 
                {
                    hr = pOutputSite->Write (pcSamples, iNumSamples*sizeof(short), 0);

                    pcSamples = 0;
                    iNumSamples = 0;

                    if ( FAILED (hr) )
                    {
                        goto exit;
                    }
                }
            }    
        }
        if (pPhones)
        {
            free (pPhones);
            pPhones = 0;
        }
        if (pfF0)
        {
            free (pfF0);
            pfF0 = 0;
        }
    }
        
exit:
    if (pPhones)
    {
        free (pPhones);
    }
    if (pfF0)
    {
        free (pfF0);
    }
    return hr;
}

/*****************************************************************************
* CTrueTalk::RunFrontEnd *
*------------------------*
*   Description:
*
******************************************************************* PACOG ***/
HRESULT CTrueTalk::RunFrontEnd (const SPVTEXTFRAG *pTextFragList, ISpTTSEngineSite* pOutputSite)
{
    HRESULT hr = S_OK;
    int   iStrLen;
    char* pszTxtPtr;
    Phone*  pPhones;
    int     iNumPhones;
    float*  pfF0;
    int     iNumF0;    
    const SPVTEXTFRAG* pTempFrag = pTextFragList;


    m_pPhoneQueue->Reset();


    //Estimate size of array
    iStrLen = 0;
    for ( pTempFrag = pTextFragList; pTempFrag ; pTempFrag = pTempFrag->pNext )
    {
        if (pTempFrag->State.eAction == SPVA_Speak || 
            pTempFrag->State.eAction == SPVA_Pronounce || 
            pTempFrag->State.eAction == SPVA_SpellOut)
        {
            iStrLen += pTempFrag->ulTextLen + 1;
        }        
    }
    
    if ( iStrLen )
    {
        if (m_fTextOutput)
        {
            //--- Write unicode signature
            static const WCHAR Signature = 0xFEFF;
            hr = pOutputSite->Write( &Signature, sizeof(Signature), NULL );
            
            for (pTempFrag = pTextFragList; SUCCEEDED(hr) && pTempFrag; pTempFrag = pTempFrag->pNext)
            {
                if (pTempFrag->State.eAction == SPVA_Speak || 
                    pTempFrag->State.eAction == SPVA_Pronounce || 
                    pTempFrag->State.eAction == SPVA_SpellOut)
                {
                    hr = pOutputSite->Write( (WCHAR*)pTempFrag->pTextStart, pTempFrag->ulTextLen * sizeof(WCHAR), NULL );
                    if (SUCCEEDED(hr))
                    {
                        hr = pOutputSite->Write( L" ", sizeof(WCHAR), NULL );
                    }
                }    
            }
            
            //--- Insert mark between blocks
            if( SUCCEEDED( hr ) ) 
            {
                static const WCHAR CRLF[2] = { 0x000D, 0x000A };
                hr = pOutputSite->Write( CRLF, 2*sizeof(WCHAR), NULL );
            }
            if( SUCCEEDED( hr ) ) 
            {
                static const WCHAR ENDL = 0x0000;
                hr = pOutputSite->Write( &ENDL, sizeof(WCHAR), NULL );
            }
        }
        else 
        {    
            
            //Allocate array
            char* pszString = new char[iStrLen + 2];
            if ( !pszString)
            {
                hr = E_OUTOFMEMORY;
            }            
            iStrLen = 0;
            
            //Copy data into array            
            for (pTempFrag = pTextFragList; SUCCEEDED(hr) && pTempFrag; pTempFrag = pTempFrag->pNext)
            {
                if (pTempFrag->State.eAction == SPVA_Speak || 
                    pTempFrag->State.eAction == SPVA_Pronounce || 
                    pTempFrag->State.eAction == SPVA_SpellOut)
                {
                    hr = DoUnicodeToAsciiMap( (WCHAR*)pTempFrag->pTextStart, pTempFrag->ulTextLen, pszString + iStrLen);            
                    iStrLen += pTempFrag->ulTextLen;
                    pszString[iStrLen++] = ' ';
                }    
            }
            pszString[iStrLen] = '\0';
            
            //Process string
            m_pTtp->Lock();
            
            pszTxtPtr = pszString;
            
            while (SUCCEEDED(hr) && pszTxtPtr)
            {
                pPhones    = 0;
                iNumPhones = 0;
                pfF0   = 0;
                iNumF0 = 0;
                
                //--  These calls are serialized (critical section), to avoid 
                //    conflicts with other channels.
                pszTxtPtr = m_pTtp->Process (pszTxtPtr, &pPhones, &iNumPhones, &pfF0, &iNumF0);
                if (iNumPhones) 
                {
                    if ( ! m_pPhoneQueue->Push (pPhones, iNumPhones, pfF0, iNumF0) )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            m_pTtp->Unlock();
            
            delete[] pszString;
        }
    }

    return hr;
}

/*****************************************************************************
* CTrueTalk::DoUnicodeToAsciiMap *
*--------------------------------*
*   Description:
*
******************************************************************* PACOG ***/
HRESULT CTrueTalk::DoUnicodeToAsciiMap ( const WCHAR *pUnicodeString, ULONG ulUnicodeStringLength, 
                                         char* pszAsciiString )
{
    HRESULT hr = S_OK;

    if ( pUnicodeString && ulUnicodeStringLength > 0 && pszAsciiString)
    {                       
        //--- Map WCHARs to ANSI chars 
        if ( !WideCharToMultiByte( 1252, NULL, pUnicodeString, ulUnicodeStringLength, pszAsciiString, 
                                   ulUnicodeStringLength, &g_pFlagCharacter, NULL ) )
        {
            hr = E_UNEXPECTED;
        }

        if (SUCCEEDED(hr))
        {
            //--- Use internal table to map ANSI to ASCII 
            for (ULONG i = 0; i <ulUnicodeStringLength; i++)
            {   
                pszAsciiString[i] = g_AnsiToAscii[(unsigned char)pszAsciiString[i]];
            }
            pszAsciiString[i] = '\0';
//            pszAsciiString[i] = ' ';
//            pszAsciiString[i+1] = '\0';
        }
    }

    return hr;

} /* CTrueTalk::DoUnicodeToAsciiMap */

/*****************************************************************************
* CTrueTalk::SyncActions *
*------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int CTrueTalk::SyncActions(ISpTTSEngineSite * pOutputSite)
{
    int iActions = pOutputSite->GetActions();

    if ( iActions != SPVES_CONTINUE )
    {
        if (iActions & SPVES_SKIP)
        {
            //This might not be the best default
            // maybe completely ignoring the flag...
            pOutputSite->CompleteSkip (0); 
        }
        if (iActions & SPVES_RATE)
        {
            long lRate;
    
            pOutputSite->GetRate (&lRate);
            m_pTtp->SetRate (lRate);
        }            
        if (iActions & SPVES_VOLUME)
        {
            unsigned short usVolume;
    
            pOutputSite->GetVolume (&usVolume);
            m_pBend->SetGain ( (m_dGain * usVolume) / 100.0);
        }
    }

    return (iActions & SPVES_ABORT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\asycfilt\asycfilt.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    hlink.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 1-Mar-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

STUBFUNC(DllCanUnloadNow)
STUBFUNC(FilterCreateInstance)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\atl30\atl.cpp ===
// atl.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 or higher in order to build
// this project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f atlps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "RegObj.h"

#define _ATLBASE_IMPL
#include <atlbase.h>
#define _ATLCOM_IMPL
#include <atlcom.h>
#define _ATLWIN_IMPL
#include <atlwin.h>
#define _ATLCTL_IMPL
#include <atlctl.h>
#define _ATLCONV_IMPL
#include <atlconv.h>
#define _ATLHOST_IMPL
#include <atlhost.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Registrar, CDLLRegObject)
	OBJECT_ENTRY_NON_CREATEABLE(CAxHostWindow)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		OSVERSIONINFOA info;
		info.dwOSVersionInfoSize = sizeof(info);
		if (GetVersionExA(&info))
		{
#ifdef _UNICODE
			if (info.dwPlatformId != VER_PLATFORM_WIN32_NT)
			{
				MessageBoxA(NULL, "Can not run Unicode version of ATL.DLL on Windows 95.\nPlease install the correct version.", "ATL", MB_ICONSTOP|MB_OK);
				return FALSE;
			}
#else
			if (info.dwPlatformId == VER_PLATFORM_WIN32_NT)
			{
				OutputDebugString(_T("Running Ansi version of ATL.DLL on Windows NT : Slight Performace loss.\nPlease install the UNICODE version on NT.\n"));
			}
#endif
		}
#ifdef _DEBUG
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF);
		int n = 0;
		_CrtSetBreakAlloc(n);
#endif
		_Module.Init(ObjectMap, hInstance, &LIBID_ATLLib);
#ifdef _ATL_DEBUG_INTERFACES
		int ni = 0;
		_Module.m_nIndexBreakAt = ni;
#endif // _ATL_DEBUG_INTERFACES
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef _DEBUG
		::OutputDebugString(_T("ATL.DLL exiting.\n"));
#endif
		_Module.Term();
		AtlAxWinTerm();
#ifdef _DEBUG
		if (_CrtDumpMemoryLeaks())
			::MessageBeep(MB_ICONEXCLAMATION);
#endif
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	//No need to unregister typelib since ATL is a system component.
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\truetalk\sptruetalk\truetalk.h ===
/******************************************************************************
* TrueTalk.h *
*--------------*
*  This module is the declaration of class CTrueTalk 
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 02/29/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef __TRUETALK_H_
#define __TRUETALK_H_

#include "resource.h"       // main symbols
#include <spddkhlp.h>
//#include <sapi.h>

EXTERN_C const CLSID CLSID_TrueTalk;

class CFrontEnd;
class CBackEnd;
class CPhStrQueue;

/////////////////////////////////////////////////////////////////////////////
// CTrueTalk
class ATL_NO_VTABLE CTrueTalk : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTrueTalk, &CLSID_TrueTalk>,
	public ISpTTSEngine,
	public ISpObjectWithToken
{
    public:
        DECLARE_REGISTRY_RESOURCEID(IDR_TRUETALK)
        DECLARE_NOT_AGGREGATABLE(CTrueTalk)

        BEGIN_COM_MAP(CTrueTalk)
            COM_INTERFACE_ENTRY(ISpTTSEngine)
            COM_INTERFACE_ENTRY(ISpObjectWithToken)
        END_COM_MAP()

        //-- Constructors, destructors
        HRESULT FinalConstruct();
        void FinalRelease();

        //-- Threading control
        static void InitThreading();
        static void ReleaseThreading();

        //-- ISpObjectWithToken
        STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken)
        { return SpGenericGetObjectToken( ppToken, m_cpToken ); }
        STDMETHOD(SetObjectToken)(ISpObjectToken * pToken);

        //-- ISpTTSEngine
        STDMETHOD(Speak)(DWORD dwSpeakFlags, REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx, 
                         const SPVTEXTFRAG * pTextFragList, ISpTTSEngineSite * pOutputSite);
        STDMETHOD(GetOutputFormat)( const GUID * pTargetFormatId, const WAVEFORMATEX * pTargetWaveFormatEx,
                                    GUID * pOutputFormatId, WAVEFORMATEX ** ppCoMemOutputWaveFormatEx );        

    private:
        HRESULT DoUnicodeToAsciiMap ( const WCHAR *pUnicodeString, ULONG ulUnicodeStringLength, char* pszAsciiString);
        HRESULT RunFrontEnd ( const SPVTEXTFRAG *pTextFragList, ISpTTSEngineSite * pOutputSite);
        int   SyncActions (ISpTTSEngineSite * pOutputSite);
        
        static const int m_iQueueSize;

        CComPtr<ISpObjectToken> m_cpToken;        
        WAVEFORMATEX m_WaveFormatEx;
        bool         m_fTextOutput;

        DWORD        m_dwDebugLevel;

        CFrontEnd*   m_pTtp;
        CPhStrQueue* m_pPhoneQueue;
        CBackEnd*    m_pBend;
        double       m_dGain;
};

#endif //__TRUETALK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\atl30\atliface.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0198 */
/* at Thu Sep 10 21:38:47 1998
 */
/* Compiler settings for atliface.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __atliface_h__
#define __atliface_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRegistrar_FWD_DEFINED__
#define __IRegistrar_FWD_DEFINED__
typedef interface IRegistrar IRegistrar;
#endif 	/* __IRegistrar_FWD_DEFINED__ */


#ifndef __IDocHostUIHandlerDispatch_FWD_DEFINED__
#define __IDocHostUIHandlerDispatch_FWD_DEFINED__
typedef interface IDocHostUIHandlerDispatch IDocHostUIHandlerDispatch;
#endif 	/* __IDocHostUIHandlerDispatch_FWD_DEFINED__ */


#ifndef __IAxWinHostWindow_FWD_DEFINED__
#define __IAxWinHostWindow_FWD_DEFINED__
typedef interface IAxWinHostWindow IAxWinHostWindow;
#endif 	/* __IAxWinHostWindow_FWD_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_FWD_DEFINED__
#define __IAxWinAmbientDispatch_FWD_DEFINED__
typedef interface IAxWinAmbientDispatch IAxWinAmbientDispatch;
#endif 	/* __IAxWinAmbientDispatch_FWD_DEFINED__ */


#ifndef __IInternalConnection_FWD_DEFINED__
#define __IInternalConnection_FWD_DEFINED__
typedef interface IInternalConnection IInternalConnection;
#endif 	/* __IInternalConnection_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_atliface_0000 */
/* [local] */ 

EXTERN_C const CLSID CLSID_Registrar;


extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_s_ifspec;

#ifndef __IRegistrar_INTERFACE_DEFINED__
#define __IRegistrar_INTERFACE_DEFINED__

/* interface IRegistrar */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44EC053B-400F-11D0-9DCD-00A0C90391D3")
    IRegistrar : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddReplacement( 
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ClearReplacements( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceRegisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceUnregisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FileRegister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FileUnregister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StringRegister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StringUnregister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceRegister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResourceUnregister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRegistrar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRegistrar __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddReplacement )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearReplacements )( 
            IRegistrar __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceRegisterSz )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceUnregisterSz )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileRegister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR fileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileUnregister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR fileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StringRegister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StringUnregister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceRegister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResourceUnregister )( 
            IRegistrar __RPC_FAR * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        END_INTERFACE
    } IRegistrarVtbl;

    interface IRegistrar
    {
        CONST_VTBL struct IRegistrarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegistrar_AddReplacement(This,key,item)	\
    (This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrar_ClearReplacements(This)	\
    (This)->lpVtbl -> ClearReplacements(This)

#define IRegistrar_ResourceRegisterSz(This,resFileName,szID,szType)	\
    (This)->lpVtbl -> ResourceRegisterSz(This,resFileName,szID,szType)

#define IRegistrar_ResourceUnregisterSz(This,resFileName,szID,szType)	\
    (This)->lpVtbl -> ResourceUnregisterSz(This,resFileName,szID,szType)

#define IRegistrar_FileRegister(This,fileName)	\
    (This)->lpVtbl -> FileRegister(This,fileName)

#define IRegistrar_FileUnregister(This,fileName)	\
    (This)->lpVtbl -> FileUnregister(This,fileName)

#define IRegistrar_StringRegister(This,data)	\
    (This)->lpVtbl -> StringRegister(This,data)

#define IRegistrar_StringUnregister(This,data)	\
    (This)->lpVtbl -> StringUnregister(This,data)

#define IRegistrar_ResourceRegister(This,resFileName,nID,szType)	\
    (This)->lpVtbl -> ResourceRegister(This,resFileName,nID,szType)

#define IRegistrar_ResourceUnregister(This,resFileName,nID,szType)	\
    (This)->lpVtbl -> ResourceUnregister(This,resFileName,nID,szType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_AddReplacement_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR key,
    /* [in] */ LPCOLESTR item);


void __RPC_STUB IRegistrar_AddReplacement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ClearReplacements_Proxy( 
    IRegistrar __RPC_FAR * This);


void __RPC_STUB IRegistrar_ClearReplacements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegisterSz_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregisterSz_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_FileRegister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_FileUnregister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_StringRegister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_StringUnregister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregister_Proxy( 
    IRegistrar __RPC_FAR * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegistrar_INTERFACE_DEFINED__ */


#ifndef __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__
#define __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__

/* interface IDocHostUIHandlerDispatch */
/* [object][unique][helpstring][uuid] */ 

typedef 
enum tagDOCHOSTUIDBLCLKDispatch
    {	docHostUIDblClkDEFAULT	= 0,
	docHostUIDblClkSHOWPROPERTIES	= 1,
	docHostUIDblClkSHOWCODE	= 2
    }	DOCHOSTUIDBLCLKDispatch;

typedef 
enum tagDocHostUIFlagDispatch
    {	docHostUIFlagDIALOG	= 1,
	docHostUIFlagDISABLE_HELP_MENU	= 2,
	docHostUIFlagNO3DBORDER	= 4,
	docHostUIFlagSCROLL_NO	= 8,
	docHostUIFlagDISABLE_SCRIPT_INACTIVE	= 16,
	docHostUIFlagOPENNEWWIN	= 32,
	docHostUIFlagDISABLE_OFFSCREEN	= 64,
	docHostUIFlagFLAT_SCROLLBAR	= 128,
	docHostUIFlagDIV_BLOCKDEFAULT	= 256,
	docHostUIFlagACTIVATE_CLIENTHIT_ONLY	= 512
    }	DocHostUIFlagDispatch;


EXTERN_C const IID IID_IDocHostUIHandlerDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("425B5AF0-65F1-11d1-9611-0000F81E0D0D")
    IDocHostUIHandlerDispatch : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            /* [in] */ DWORD dwID,
            /* [in] */ DWORD x,
            /* [in] */ DWORD y,
            /* [in] */ IUnknown __RPC_FAR *pcmdtReserved,
            /* [in] */ IDispatch __RPC_FAR *pdispReserved,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostInfo( 
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
            /* [out][in] */ DWORD __RPC_FAR *pdwDoubleClick) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowUI( 
            /* [in] */ DWORD dwID,
            /* [in] */ IUnknown __RPC_FAR *pActiveObject,
            /* [in] */ IUnknown __RPC_FAR *pCommandTarget,
            /* [in] */ IUnknown __RPC_FAR *pFrame,
            /* [in] */ IUnknown __RPC_FAR *pDoc,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideUI( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateUI( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate( 
            /* [in] */ VARIANT_BOOL fActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate( 
            /* [in] */ VARIANT_BOOL fActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom,
            /* [in] */ IUnknown __RPC_FAR *pUIWindow,
            /* [in] */ VARIANT_BOOL fFrameWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ DWORD hWnd,
            /* [in] */ DWORD nMessage,
            /* [in] */ DWORD wParam,
            /* [in] */ DWORD lParam,
            /* [in] */ BSTR bstrGuidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath( 
            /* [out] */ BSTR __RPC_FAR *pbstrKey,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
            /* [in] */ IUnknown __RPC_FAR *pDropTarget,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDropTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExternal( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateUrl( 
            /* [in] */ DWORD dwTranslate,
            /* [in] */ BSTR bstrURLIn,
            /* [out] */ BSTR __RPC_FAR *pbstrURLOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterDataObject( 
            /* [in] */ IUnknown __RPC_FAR *pDO,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDORet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDocHostUIHandlerDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowContextMenu )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [in] */ DWORD x,
            /* [in] */ DWORD y,
            /* [in] */ IUnknown __RPC_FAR *pcmdtReserved,
            /* [in] */ IDispatch __RPC_FAR *pdispReserved,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHostInfo )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
            /* [out][in] */ DWORD __RPC_FAR *pdwDoubleClick);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowUI )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [in] */ IUnknown __RPC_FAR *pActiveObject,
            /* [in] */ IUnknown __RPC_FAR *pCommandTarget,
            /* [in] */ IUnknown __RPC_FAR *pFrame,
            /* [in] */ IUnknown __RPC_FAR *pDoc,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HideUI )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateUI )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableModeless )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDocWindowActivate )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fActivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnFrameWindowActivate )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fActivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResizeBorder )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom,
            /* [in] */ IUnknown __RPC_FAR *pUIWindow,
            /* [in] */ VARIANT_BOOL fFrameWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateAccelerator )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DWORD hWnd,
            /* [in] */ DWORD nMessage,
            /* [in] */ DWORD wParam,
            /* [in] */ DWORD lParam,
            /* [in] */ BSTR bstrGuidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptionKeyPath )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrKey,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDropTarget )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDropTarget,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDropTarget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExternal )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateUrl )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ DWORD dwTranslate,
            /* [in] */ BSTR bstrURLIn,
            /* [out] */ BSTR __RPC_FAR *pbstrURLOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterDataObject )( 
            IDocHostUIHandlerDispatch __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDO,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDORet);
        
        END_INTERFACE
    } IDocHostUIHandlerDispatchVtbl;

    interface IDocHostUIHandlerDispatch
    {
        CONST_VTBL struct IDocHostUIHandlerDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDocHostUIHandlerDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocHostUIHandlerDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDocHostUIHandlerDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDocHostUIHandlerDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDocHostUIHandlerDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDocHostUIHandlerDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDocHostUIHandlerDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDocHostUIHandlerDispatch_ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)	\
    (This)->lpVtbl -> ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)

#define IDocHostUIHandlerDispatch_GetHostInfo(This,pdwFlags,pdwDoubleClick)	\
    (This)->lpVtbl -> GetHostInfo(This,pdwFlags,pdwDoubleClick)

#define IDocHostUIHandlerDispatch_ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)	\
    (This)->lpVtbl -> ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)

#define IDocHostUIHandlerDispatch_HideUI(This)	\
    (This)->lpVtbl -> HideUI(This)

#define IDocHostUIHandlerDispatch_UpdateUI(This)	\
    (This)->lpVtbl -> UpdateUI(This)

#define IDocHostUIHandlerDispatch_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#define IDocHostUIHandlerDispatch_OnDocWindowActivate(This,fActivate)	\
    (This)->lpVtbl -> OnDocWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_OnFrameWindowActivate(This,fActivate)	\
    (This)->lpVtbl -> OnFrameWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)	\
    (This)->lpVtbl -> ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)

#define IDocHostUIHandlerDispatch_TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)	\
    (This)->lpVtbl -> TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)

#define IDocHostUIHandlerDispatch_GetOptionKeyPath(This,pbstrKey,dw)	\
    (This)->lpVtbl -> GetOptionKeyPath(This,pbstrKey,dw)

#define IDocHostUIHandlerDispatch_GetDropTarget(This,pDropTarget,ppDropTarget)	\
    (This)->lpVtbl -> GetDropTarget(This,pDropTarget,ppDropTarget)

#define IDocHostUIHandlerDispatch_GetExternal(This,ppDispatch)	\
    (This)->lpVtbl -> GetExternal(This,ppDispatch)

#define IDocHostUIHandlerDispatch_TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)	\
    (This)->lpVtbl -> TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)

#define IDocHostUIHandlerDispatch_FilterDataObject(This,pDO,ppDORet)	\
    (This)->lpVtbl -> FilterDataObject(This,pDO,ppDORet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowContextMenu_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [in] */ DWORD x,
    /* [in] */ DWORD y,
    /* [in] */ IUnknown __RPC_FAR *pcmdtReserved,
    /* [in] */ IDispatch __RPC_FAR *pdispReserved,
    /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetHostInfo_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
    /* [out][in] */ DWORD __RPC_FAR *pdwDoubleClick);


void __RPC_STUB IDocHostUIHandlerDispatch_GetHostInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowUI_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [in] */ IUnknown __RPC_FAR *pActiveObject,
    /* [in] */ IUnknown __RPC_FAR *pCommandTarget,
    /* [in] */ IUnknown __RPC_FAR *pFrame,
    /* [in] */ IUnknown __RPC_FAR *pDoc,
    /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_HideUI_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This);


void __RPC_STUB IDocHostUIHandlerDispatch_HideUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_UpdateUI_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This);


void __RPC_STUB IDocHostUIHandlerDispatch_UpdateUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_EnableModeless_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB IDocHostUIHandlerDispatch_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnDocWindowActivate_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnDocWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnFrameWindowActivate_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnFrameWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ResizeBorder_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ long left,
    /* [in] */ long top,
    /* [in] */ long right,
    /* [in] */ long bottom,
    /* [in] */ IUnknown __RPC_FAR *pUIWindow,
    /* [in] */ VARIANT_BOOL fFrameWindow);


void __RPC_STUB IDocHostUIHandlerDispatch_ResizeBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateAccelerator_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ DWORD hWnd,
    /* [in] */ DWORD nMessage,
    /* [in] */ DWORD wParam,
    /* [in] */ DWORD lParam,
    /* [in] */ BSTR bstrGuidCmdGroup,
    /* [in] */ DWORD nCmdID,
    /* [retval][out] */ HRESULT __RPC_FAR *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetOptionKeyPath_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrKey,
    /* [in] */ DWORD dw);


void __RPC_STUB IDocHostUIHandlerDispatch_GetOptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetDropTarget_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDropTarget,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDropTarget);


void __RPC_STUB IDocHostUIHandlerDispatch_GetDropTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetExternal_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IDocHostUIHandlerDispatch_GetExternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateUrl_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ DWORD dwTranslate,
    /* [in] */ BSTR bstrURLIn,
    /* [out] */ BSTR __RPC_FAR *pbstrURLOut);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_FilterDataObject_Proxy( 
    IDocHostUIHandlerDispatch __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDO,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDORet);


void __RPC_STUB IDocHostUIHandlerDispatch_FilterDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__ */


#ifndef __IAxWinHostWindow_INTERFACE_DEFINED__
#define __IAxWinHostWindow_INTERFACE_DEFINED__

/* interface IAxWinHostWindow */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAxWinHostWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6EA2050-048A-11d1-82B9-00C04FB9942E")
    IAxWinHostWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateControl( 
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream __RPC_FAR *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateControlEx( 
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
            /* [in] */ REFIID riidAdvise,
            /* [in] */ IUnknown __RPC_FAR *punkAdvise) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AttachControl( 
            /* [in] */ IUnknown __RPC_FAR *pUnkControl,
            /* [in] */ HWND hWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryControl( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExternalDispatch( 
            /* [in] */ IDispatch __RPC_FAR *pDisp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExternalUIHandler( 
            /* [in] */ IDocHostUIHandlerDispatch __RPC_FAR *pDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAxWinHostWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAxWinHostWindow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAxWinHostWindow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateControl )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream __RPC_FAR *pStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateControlEx )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ LPCOLESTR lpTricsData,
            /* [in] */ HWND hWnd,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
            /* [in] */ REFIID riidAdvise,
            /* [in] */ IUnknown __RPC_FAR *punkAdvise);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachControl )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkControl,
            /* [in] */ HWND hWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryControl )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExternalDispatch )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pDisp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExternalUIHandler )( 
            IAxWinHostWindow __RPC_FAR * This,
            /* [in] */ IDocHostUIHandlerDispatch __RPC_FAR *pDisp);
        
        END_INTERFACE
    } IAxWinHostWindowVtbl;

    interface IAxWinHostWindow
    {
        CONST_VTBL struct IAxWinHostWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAxWinHostWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinHostWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAxWinHostWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAxWinHostWindow_CreateControl(This,lpTricsData,hWnd,pStream)	\
    (This)->lpVtbl -> CreateControl(This,lpTricsData,hWnd,pStream)

#define IAxWinHostWindow_CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)	\
    (This)->lpVtbl -> CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)

#define IAxWinHostWindow_AttachControl(This,pUnkControl,hWnd)	\
    (This)->lpVtbl -> AttachControl(This,pUnkControl,hWnd)

#define IAxWinHostWindow_QueryControl(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryControl(This,riid,ppvObject)

#define IAxWinHostWindow_SetExternalDispatch(This,pDisp)	\
    (This)->lpVtbl -> SetExternalDispatch(This,pDisp)

#define IAxWinHostWindow_SetExternalUIHandler(This,pDisp)	\
    (This)->lpVtbl -> SetExternalUIHandler(This,pDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControl_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ LPCOLESTR lpTricsData,
    /* [in] */ HWND hWnd,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IAxWinHostWindow_CreateControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControlEx_Proxy( 
    IAxWinHostWindow __RPC_FAR * This,
    /* [in] */ LPCOLESTR lpTricsData,
    /* [in] */ HWND hWnd,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
    /* [in] */ REFIID riidAdvise,
    /* [in] */ IUnknown __RPC_FAR *punkAdvise);


void __RPC_STUB IAxWinHostWindow_CreateControlEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pd