		RS_SETVALUE,
					0, (LONG)wFlag);
#endif

		if (pZ->nCrcType == ZP_CRC_32)
			SendMessage(GetDlgItem(hDlg, BIT_32_PB),
						BM_SETCHECK, 1, 0L);
		else
			SendMessage(GetDlgItem(hDlg, BIT_16_PB),
						BM_SETCHECK, 1, 0L);

		if (pZ->nEolConvert)
			SendMessage(GetDlgItem(hDlg, EOL_PB),
						BM_SETCHECK, 1, 0L);

		if (pZ->nEscCtrlCodes)
			SendMessage(GetDlgItem(hDlg, ESC_CODE_PB),
						BM_SETCHECK, 1, 0L);
		break;

	case WM_DESTROY:
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDOK:
			pD = (SDS *)GetWindowLong(hDlg, DWL_USER);
			assert(pD);

			pZ = (XFR_Z_PARAMS *)pD->lPar;
			assert(pZ);
			/*
			 * TODO: decide how we are going to handle confirmable changes
			 */

			/*
			 * Do the receive stuff
			 */
			pZ->nAutostartOK = IsDlgButtonChecked(hDlg, AUTOSTART_CHECK);

			pZ->nFileExists = ZP_FE_DLG;
			if (IsDlgButtonChecked(hDlg, USE_SENDER_PB))
				pZ->nFileExists = ZP_FE_SENDER;

			if (IsDlgButtonChecked(hDlg, REC_NEGOTIATE_PB))
				pZ->nCrashRecRecv = ZP_CRR_NEG;
			else if (IsDlgButtonChecked(hDlg, REC_NEVER_PB))
				pZ->nCrashRecRecv = ZP_CRR_NEVER;
			else
				pZ->nCrashRecRecv = ZP_CRR_ALWAYS;

			/*
			 * Do the send stuff
			 */
			pZ->nOverwriteOpt = (LONG)SendMessage(GetDlgItem(hDlg, AO_COMBO),
										CB_GETCURSEL, 0, 0L);
			if (pZ->nOverwriteOpt == CB_ERR)
				{
				pZ->nOverwriteOpt = 1;
				}
			else
				{
				pZ->nOverwriteOpt += 1;			/* Zero vs. one base list */
				}

			pZ->nCrashRecSend = ZP_CRS_ALWAYS;
			if (IsDlgButtonChecked(hDlg, SEND_NEGOTIATE_PB))
				pZ->nCrashRecSend = ZP_CRS_NEG;
			else if (IsDlgButtonChecked(hDlg, SEND_ONE_TIME_PB))
				pZ->nCrashRecSend = ZP_CRS_ONCE;

			/*
			 * Do the generic stuff
			 */
			pZ->nWinSize = (LONG)SendMessage(GetDlgItem(hDlg, WINDOW_COMBO),
										CB_GETCURSEL, 0, 0L);
			if (pZ->nWinSize == CB_ERR)
				{
				pZ->nWinSize = 1;
				/* TODO: check the format */
				}

			if (IsDlgButtonChecked(hDlg, STREAMING_PB))
				pZ->nXferMthd = ZP_XM_STREAM;
			else
				pZ->nXferMthd = ZP_XM_WINDOW;

			pZ->nBlkSize = (LONG)SendMessage(GetDlgItem(hDlg, PACKET_COMBO),
										CB_GETCURSEL, 0, 0L);
			if (pZ->nBlkSize == CB_ERR)
				{
				/* TODO: check the format */
				pZ->nBlkSize = 1;
				}

			if (IsDlgButtonChecked(hDlg, BIT_32_PB))
				pZ->nCrcType = ZP_CRC_32;
			else
				pZ->nCrcType = ZP_CRC_16;

			/* TODO: remember that this used to be a rocker */
			pZ->nRetryWait = GetDlgItemInt(hDlg, WAIT_ROCKER, NULL, FALSE);
			if (pZ->nRetryWait < 5)
				pZ->nRetryWait = 5;
			if (pZ->nRetryWait > 100)
				pZ->nRetryWait = 100;

			pZ->nEolConvert = IsDlgButtonChecked(hDlg, EOL_PB);

			pZ->nEscCtrlCodes = IsDlgButtonChecked(hDlg, ESC_CODE_PB);

			free(pD);
			pD = (SDS *)0;
			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			/* Not much to do except free the memory */
			pD = (SDS *)GetWindowLong(hDlg, DWL_USER);
			free(pD);
			pD = (SDS *)0;
			EndDialog(hDlg, FALSE);
			break;

		case STREAMING_PB:
			if (IsDlgButtonChecked(hDlg, STREAMING_PB))
				EnableWindow(GetDlgItem(hDlg, WINDOW_COMBO), FALSE);
			break;

		case WINDOWED_PB:
			if (IsDlgButtonChecked(hDlg, WINDOWED_PB))
				EnableWindow(GetDlgItem(hDlg, WINDOW_COMBO), TRUE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

#endif
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\xfer\zmodem.h ===
/* Zmodem.h -- exported constants, variables and functions for zmodem
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */
/*
 *   Z M O D E M . H     Manifest constants for ZMODEM
 *    application to application file transfer protocol
 *    05-23-87  Chuck Forsberg Omen Technology Inc
 */
#define ZPAD '*'	/* 052 Padding character begins frames */
#define ZDLE 030	/* Ctrl-X Zmodem escape - `ala BISYNC DLE */
#define ZDLEE (ZDLE^0100)	/* Escaped ZDLE as transmitted */
#define ZBIN 'A'	/* Binary frame indicator */
#define ZHEX 'B'	/* HEX frame indicator */
#define ZBIN32 'C'	/* Binary frame with 32 bit FCS */

/* Frame types (see array "frametypes" in zm.c) */

#define ZRQINIT	0	/* Request receive init */
#define ZRINIT	1	/* Receive init */
#define ZSINIT 2	/* Send init sequence (optional) */
#define ZACK 3		/* ACK to above */
#define ZFILE 4		/* File name from sender */
#define ZSKIP 5		/* To sender: skip this file */
#define ZNAK 6		/* Last packet was garbled */
#define ZABORT 7	/* Abort batch transfers */
#define ZFIN 8		/* Finish session */
#define ZRPOS 9		/* Resume data trans at this position */
#define ZDATA 10	/* Data packet(s) follow */
#define ZEOF 11		/* End of file */
#define ZFERR 12	/* Fatal Read or Write error Detected */
#define ZCRC 13		/* Request for file CRC and response */
#define ZCHALLENGE 14	/* Receiver's Challenge */
#define ZCOMPL 15	/* Request is complete */
#define ZCAN 16		/* Other end canned session with CAN*5 */
#define ZFREECNT 17	/* Request for free bytes on filesystem */
#define ZCOMMAND 18	/* Command from sending program */
#define ZSTDERR 19	/* Output to standard error, data follows */
#define ZBADFMT 20	/* Data packed format error */
#define ZMDM_ACKED	21
#define ZMDM_VIRUS	22
#define ZMDM_REFUSE 23 /* File was unconditinally refused */
#define ZMDM_OLDER  24 /* File refused because it was older */
#define ZMDM_INUSE  25  /* File is currently in use */

/* ZDLE sequences */

#define ZCRCE 'h'	/* CRC next, frame ends, header packet follows */
#define ZCRCG 'i'	/* CRC next, frame continues nonstop */
#define ZCRCQ 'j'	/* CRC next, frame continues, ZACK expected */
#define ZCRCW 'k'	/* CRC next, ZACK expected, end of frame */
#define ZRUB0 'l'	/* Translate to rubout 0177 */
#define ZRUB1 'm'	/* Translate to rubout 0377 */

/* zdlread return values (internal) */
/* -1 is general error, -2 is timeout */

#define GOTOR 0400
#define GOTCRCE (ZCRCE|GOTOR)	/* ZDLE-ZCRCE received */
#define GOTCRCG (ZCRCG|GOTOR)	/* ZDLE-ZCRCG received */
#define GOTCRCQ (ZCRCQ|GOTOR)	/* ZDLE-ZCRCQ received */
#define GOTCRCW (ZCRCW|GOTOR)	/* ZDLE-ZCRCW received */
#define GOTCAN	(GOTOR|030)	/* CAN*5 seen */

/* Byte positions within header array */

#define ZF0	3	/* First flags byte */
#define ZF1	2
#define ZF2	1
#define ZF3	0
#define ZP0	0	/* Low order 8 bits of position */
#define ZP1	1
#define ZP2	2
#define ZP3	3	/* High order 8 bits of file position */

/* Bit Masks for ZRINIT flags byte ZF0 */

#define CANFDX	01	/* Rx can send and receive true FDX */
#define CANOVIO	02	/* Rx can receive data during disk I/O */
#define CANBRK	04	/* Rx can send a break signal */
#define CANCRY	010	/* Receiver can decrypt */
#define CANLZW	020	/* Receiver can uncompress */
#define CANFC32	040	/* Receiver can use 32 bit Frame Check */
#define ESCCTL 0100	/* Receiver expects ctl chars to be escaped */
#define ESC8   0200	/* Receiver expects 8th bit to be escaped */

/* Bit Masks for ZSINIT flags byte ZF0 */

#define TESCCTL 0100	/* Transmitter expects ctl chars to be escaped */
#define TESC8   0200	/* Transmitter expects 8th bit to be escaped */

/* Parameters for ZFILE frame */
/* Conversion options one of these in ZF0 */

#define ZCBIN	1	/* Binary transfer - inhibit conversion */
#define ZCNL	2	/* Convert NL to local end of line convention */
#define ZCRESUM 3	/* Resume interrupted file transfer */
#define ZCRECOV 3	/* Some of the documentation uses this name */

/* Management include options, one of these ored in ZF1 */

#define ZMSKNOLOC	0200	/* Skip file if not present at rx */

/* Management options, one of these ored in ZF1 */

#define ZMMASK	037	/* Mask for the choices below */
#define ZMNEWL	1	/* Transfer if source newer or longer */
#define ZMCRC	2	/* Transfer if different file CRC or length */
#define ZMAPND	3	/* Append contents to existing file (if any) */
#define ZMCLOB	4	/* Replace existing file */
#define ZMNEW	5	/* Transfer if source newer */
	/* Number 5 is alive ... */
#define ZMDIFF	6	/* Transfer if dates or lengths different */
#define ZMPROT	7	/* Protect destination file */

/* Transport options, one of these in ZF2 */

#define ZTLZW	1	/* Lempel-Ziv compression */
#define ZTCRYPT	2	/* Encryption */
#define ZTRLE	3	/* Run Length encoding */

/* Extended options for ZF3, bit encoded */

#define ZXSPARS	64	/* Encoding for sparse file operations */

/* Parameters for ZCOMMAND frame ZF0 (otherwise 0) */
#define ZCACK1	1	/* Acknowledge, then do command */

#define DEFBYTL 	2000000000L

/* Function prototypes */

USHORT zmdm_snd(HSESSION h, int method, int attended, unsigned nfiles, long nbytes);

USHORT zmdm_rcv(HSESSION h, int method, int attended, int single_file);

/* End of ZMODEM.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\bmobject.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "toolbox.h"
#include "imgfile.h"
#include "colorsrc.h"
#include "undo.h"
#include "props.h"
#include "ferr.h"
#include "cmpmsg.h"
#include "loadimag.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CBitmapObj, CObject )

#include "memtrace.h"

/***************************************************************************/
// Map from the value in CBitmapObj::m_nColors to bits per pixel

int mpncolorsbits [] =
    {
    1, 4, 8, 24
    };

/***************************************************************************/

CBitmapObj::CBitmapObj() : CObject(), m_dependants()
    {
    m_bDirty      = FALSE;
    m_bTempName   = FALSE;
    m_hThing      = NULL;
    m_lMemSize    = 0L;
    m_pImg        = NULL;
    m_nWidth      = 0;
    m_nHeight     = 0;
    m_nColors     = 0;
    m_nSaveColors = -1;
#ifdef ICO_SUPPORT
    m_bSaveIcon   = FALSE;
#endif
#ifdef PCX_SUPPORT
    m_bPCX        = FALSE;
#endif
    m_bCompressed = FALSE;
    m_nShrink     = 0;
    m_dwOffBits   = 0;
    }

/***************************************************************************/

CBitmapObj::~CBitmapObj()
    {
    ASSERT_VALID(this);

    InformDependants( SN_DESTROY );

    if (m_hThing != NULL)
        {
        Free();
        }
    if (m_pImg)
        FreeImg(m_pImg);
    }

/***************************************************************************/

void CBitmapObj::AddDependant( CBitmapObj* newDependant )
    {
    POSITION pos = m_dependants.Find( newDependant );

    if (pos == NULL)
        m_dependants.AddTail( newDependant );
    }

/***************************************************************************/

void CBitmapObj::RemoveDependant( CBitmapObj* oldDependant )
    {
    POSITION pos = m_dependants.Find(oldDependant);

    if (pos != NULL)
        m_dependants.RemoveAt(pos);
    }

/***************************************************************************/

void CBitmapObj::InformDependants( UINT idChange )
    {
    POSITION pos = m_dependants.GetHeadPosition();

    while (pos != NULL)
        {
        CBitmapObj* pSlob = (CBitmapObj*)m_dependants.GetNext(pos);
        pSlob->OnInform(this, idChange);
        }
    }

/***************************************************************************/

void CBitmapObj::OnInform( CBitmapObj* pChangedSlob, UINT idChange )
    {
    if (idChange == SN_DESTROY)
        {
        POSITION pos = m_dependants.Find(pChangedSlob);

        if (pos != NULL)
            m_dependants.RemoveAt(pos);
        }
    }

/***************************************************************************/

void CBitmapObj::SetDirty(BOOL bDirty)
    {
    m_bDirty = bDirty;
    }

/*****************************************************************************/

void CBitmapObj::Zap()
    {
    m_bDirty = FALSE;
    }

/*****************************************************************************/

BOOL CBitmapObj::Alloc()  // m_hThing of size m_lMemSize
    {
    if (m_lMemSize == 0L)
        return FALSE;

    m_hThing = GlobalAlloc(GPTR, m_lMemSize);

    if (m_hThing == NULL)
        {
        theApp.SetMemoryEmergency( TRUE );
        return FALSE;
        }

    return TRUE;
    }

/*****************************************************************************/

void CBitmapObj::Free()             // m_hThing and set m_lMemSize to zero
    {
    if (m_hThing == NULL)
        {
        TRACE(TEXT("Warning: called Free on a CBitmapObj with no thing!\n"));
        return;
        }

    GlobalFree(m_hThing);

    m_hThing   = NULL;
    m_lMemSize = 0;
    }

/***************************************************************************/

CString CBitmapObj::GetDefExtension(int iStringId)
    {
    CString cStringExtension;

    if (iStringId != 0)
        {
        TRY
            {
            cStringExtension.LoadString( iStringId );
            }
        CATCH(CMemoryException,e)
            {
            cStringExtension.Empty();
            }
        END_CATCH
        }
    else
        {
        cStringExtension.Empty();
        }

    return cStringExtension;
    }

void PBGetDefDims(int &pnWidth, int &pnHeight)
{
    // Setup default parameters...
    // Don't use the whole screen, those bitmaps get HUGE
    //
    pnWidth  = GetSystemMetrics( SM_CXSCREEN )/2;
    pnHeight = GetSystemMetrics( SM_CYSCREEN )/2;

    // Check if this is a low memory machine and use a small default bitmap
    // size
    if (GetSystemMetrics(SM_SLOWMACHINE) & 0x0002)
    {
        pnWidth  = 640/2;
        pnHeight = 480/2;
    }
}

/*****************************************************************************/

BOOL CBitmapObj::MakeEmpty()
    {
    PBGetDefDims(m_nWidth, m_nHeight);

    if (theApp.m_sizeBitmap.cx
    &&  theApp.m_sizeBitmap.cy)
        {
        m_nWidth  = theApp.m_sizeBitmap.cx;
        m_nHeight = theApp.m_sizeBitmap.cy;
        }

    if (theApp.m_bEmbedded)
        {
       // make a nice size for embedded objects, lets try for 5 centimeters
        m_nWidth  = theApp.ScreenDeviceInfo.ixPelsPerDM / 2;
        m_nHeight = theApp.ScreenDeviceInfo.iyPelsPerDM / 2;
        }

    //
    // default to 256 colors if not monochrome
    //
    m_nColors = theApp.m_bMonoDevice? 0 : 2;
    m_bDirty  = TRUE;

    return TRUE;
    }

/*****************************************************************************/
// Create and setup an IMG for this resource

BOOL CBitmapObj::CreateImg()
    {
    ASSERT(! m_pImg);

    LONG cXPelsPerMeter = 0;
    LONG cYPelsPerMeter = 0;

    LPSTR lpbi = (LPSTR) GlobalLock(m_hThing); // NOTE: this is NULL for new resources!

    if (lpbi)
        {
        if (IS_WIN30_DIB( lpbi ))
            {
            PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) lpbi;
            m_bCompressed = pbmih->biCompression != BI_RGB;
            cXPelsPerMeter = pbmih->biXPelsPerMeter;
            cYPelsPerMeter = pbmih->biYPelsPerMeter;
            }

        m_nWidth  = (int)DIBWidth ( lpbi );
        m_nHeight = (int)DIBHeight( lpbi );
        m_nColors =   DIBNumColors( lpbi, FALSE );

        if (m_nColors <= 0 || m_nColors > 256)
            m_nColors  = 3;
        else
            if (m_nColors <= 2)
                m_nColors = 0;
            else
                if (m_nColors <= 16)
                    m_nColors  = 1;
                else
                    if (m_nColors <= 256)
                        m_nColors  = 2;
        }

    UINT nColors = (m_nColors? 0: 1);

    m_pImg = ::CreateImg( lpbi ? 0 : m_nWidth, lpbi ? 0 : m_nHeight,
                nColors, nColors, cXPelsPerMeter, cYPelsPerMeter, theApp.m_bPaletted );

    if (! m_pImg)
        {
        TRACE(TEXT("CreateImg failed\n"));

        theApp.SetMemoryEmergency();
        GlobalUnlock(m_hThing);
        return FALSE;
        }

    if (g_pColors)
    {
       g_pColors->ResetColors ((m_nColors==1)?16:256);
    }

    m_pImg->cxWidth  = m_nWidth;
    m_pImg->cyHeight = m_nHeight;

    if (! lpbi)
        {
        nColors = m_pImg->cPlanes * m_pImg->cBitCount;

        //FEATURE - Shouldn't this be " == 0 || == 1" ??
        //Half a page up negative values == TRUE color!

                //This shell game with the values isn't very good...

        if (nColors <= 1)
            m_nColors = 0;
        else
            if (nColors <= 4)
                m_nColors = 1;
            else
                if (nColors <= 8)
                    m_nColors = 2;
                else // 24-bit image
                    m_nColors = 3;
        }

    m_pImg->m_pBitmapObj = this;
    m_pImg->bDirty       = m_bDirty;

   if (lpbi)
        {
        // Load the bitmap/icon/cursor...
        HBITMAP hbm = DIBToDS( lpbi, m_dwOffBits, m_pImg->hDC );

        if (! hbm)
            {
            theApp.SetMemoryEmergency();
            GlobalUnlock(m_hThing);
            return FALSE;
            }

        m_pImg->hBitmap    = hbm;
        m_pImg->hBitmapOld = (HBITMAP)::SelectObject( m_pImg->hDC, hbm );
        }

        if ( theApp.m_bPaletted)
        // If LoadImage was used && paletted
                {
                // Create the Palette from the dib section instead.
        m_pImg->m_pPalette = PaletteFromDS(m_pImg->hDC);
                }

    theApp.m_pPalette = NULL;

    if (m_pImg->m_pPalette && theApp.m_bPaletted)
        {
        m_pImg->m_hPalOld = SelectPalette( m_pImg->hDC,
                                    (HPALETTE)m_pImg->m_pPalette->m_hObject,
                                              FALSE );
        RealizePalette( m_pImg->hDC );

        theApp.m_pPalette = m_pImg->m_pPalette;
        }
    else
        if (m_pImg->m_pPalette)
            {
            delete m_pImg->m_pPalette;
            m_pImg->m_pPalette = NULL;
            m_pImg->m_hPalOld  = NULL;
            }

    if (g_pColors)
        g_pColors->SetMono( ! m_nColors );

    GlobalUnlock(m_hThing);

    return TRUE;
    }

/*****************************************************************************/

BOOL CBitmapObj::Export(const TCHAR* szFileName)
    {
    // If the file already exists and we aren't dirty, then don't bother
    // saving, just return...
    CFileStatus fStat;
    CString strFullName;

    MkFullPath( strFullName, (const TCHAR*)szFileName );

    if (CFile::GetStatus( strFullName, fStat ) && ! m_bDirty)
        return TRUE;

    CFile file;

    CFileException e;
    CFileSaver saver( szFileName );

    if (! saver.CanSave())
        return FALSE;

    theApp.SetFileError( IDS_ERROR_EXPORT, CFileException::none, szFileName );

    if (! OpenSubFile( file, saver, CFile::modeWrite
                                  | CFile::modeCreate
                                  | CFile::typeBinary, &e ))
        {
        theApp.SetFileError( IDS_ERROR_EXPORT, e.m_cause );
        return FALSE;
        }

    BOOL bWritten = FALSE;

    TRY
        {
#ifdef PCX_SUPPORT
        if (m_bPCX)
            bWritten = WritePCX( &file );
        else
#endif
            bWritten = WriteResource( &file );

        file.Close();
        }
    CATCH( CFileException, ex )
        {
        file.Abort();
        theApp.SetFileError( IDS_ERROR_EXPORT, ex->m_cause );
        return FALSE;
        }
    END_CATCH

    if (bWritten)
        bWritten = saver.Finish();
    else
                   saver.Finish();

    return bWritten;
    }

typedef union _BITMAPHEADER
{
        BITMAPINFOHEADER bmi;
        BITMAPCOREHEADER bmc;
} BITMAPHEADER, *LPBITMAPHEADER;

inline WORD PaletteSize(LPBITMAPHEADER lpHdr) {return(PaletteSize((LPSTR)lpHdr));}
inline WORD DIBNumColors(LPBITMAPHEADER lpHdr) {return(DIBNumColors((LPSTR)lpHdr));}
inline DWORD DIBWidth(LPBITMAPHEADER lpHdr) {return(DIBWidth((LPSTR)lpHdr));}
inline DWORD DIBHeight(LPBITMAPHEADER lpHdr) {return(DIBHeight((LPSTR)lpHdr));}

/*****************************************************************************/

BOOL CBitmapObj::WriteResource( CFile* pfile, PBResType rtType )
    {
    BOOL bPBrushOLEHeader = (rtType == rtPBrushOLEObj);
    BOOL bFileHeader = (rtType == rtFile)|| (rtType == rtPaintOLEObj) || bPBrushOLEHeader;

    if (m_pImg == NULL)
        {
        // The image has not been loaded, so we'll just copy the
        // original out to the file...
        ASSERT( m_hThing );

        if (! m_hThing)
            return FALSE;
        }
    else
        {
        // The image has been loaded and may have been edited, so
        // we'll convert it back to a dib to save...
        if (! m_hThing)
            SaveResource( FALSE );

        if (! m_hThing)
            return FALSE;
        }

    LPBITMAPHEADER lpDib    = (LPBITMAPHEADER)GlobalLock(m_hThing);
    DWORD dwLength = m_lMemSize;
    DWORD dwWriteLength = dwLength;
    DWORD dwHeadLength = 0;

        struct _BMINFO
        {
                BITMAPINFOHEADER hdr;
                RGBQUAD rgb[256];
        } bmInfo;

        LPBITMAPHEADER lpOldHdr = lpDib;
        LPBITMAPHEADER lpNewHdr = lpOldHdr;

        DWORD dwOldHdrLen = lpOldHdr->bmi.biSize + PaletteSize(lpOldHdr);
        DWORD dwNewHdrLen = dwOldHdrLen;

    if (bPBrushOLEHeader)
        {
                if (!IS_WIN30_DIB(lpDib))
                {
                        LPBITMAPCOREINFO lpCoreInfo = (LPBITMAPCOREINFO)(&lpOldHdr->bmc);
                        memset(&bmInfo.hdr, 0, sizeof(bmInfo.hdr));
                        bmInfo.hdr.biSize = sizeof(bmInfo.hdr);
                        bmInfo.hdr.biWidth  = lpCoreInfo->bmciHeader.bcWidth;
                        bmInfo.hdr.biHeight = lpCoreInfo->bmciHeader.bcHeight;
                        bmInfo.hdr.biPlanes   = lpCoreInfo->bmciHeader.bcPlanes;
                        bmInfo.hdr.biBitCount = lpCoreInfo->bmciHeader.bcBitCount;
                        bmInfo.hdr.biCompression = BI_RGB;

                        for (int i=DIBNumColors(lpOldHdr)-1; i>=0; --i)
                        {
                                bmInfo.rgb[i].rgbBlue  = lpCoreInfo->bmciColors[i].rgbtBlue;
                                bmInfo.rgb[i].rgbGreen = lpCoreInfo->bmciColors[i].rgbtGreen;
                                bmInfo.rgb[i].rgbRed   = lpCoreInfo->bmciColors[i].rgbtRed;
                                bmInfo.rgb[i].rgbReserved = 0;
                        }

                        lpNewHdr = (LPBITMAPHEADER)(&bmInfo);
                        dwNewHdrLen = lpNewHdr->bmi.biSize + PaletteSize(lpNewHdr);
                }

                dwWriteLength += dwNewHdrLen - dwOldHdrLen;
                dwLength      += dwNewHdrLen - dwOldHdrLen;

                if (bFileHeader)
                {
       #ifdef ICO_SUPPORT
                        if (IsSaveIcon())
                        {
                                dwHeadLength = sizeof(ICONFILEHEADER);
                                dwWriteLength += dwHeadLength;
                        }
                        else
       #endif
                        {
                                dwHeadLength = sizeof(BITMAPFILEHEADER);
                                dwWriteLength += dwHeadLength;

                                // PBrush rounded up to 32 bytes (I don't know why)
                                dwWriteLength = (dwWriteLength+31) & ~31;
                        }
                }

        pfile->Write( &dwWriteLength, sizeof( dwWriteLength ));
        }

    if (bFileHeader)
        {
                // Icon support is not in application anymore, right?
    #ifdef ICO_SUPPORT
        if (IsSaveIcon())
            {
            ICONFILEHEADER hdr;

            hdr.icoReserved      = 0;
            hdr.icoResourceType  = 1;
            hdr.icoResourceCount = 1;

            pfile->Write( &hdr, sizeof( ICONFILEHEADER ) );
            pfile->Seek( sizeof( ICONDIRENTRY ), CFile::current );
            }
        else
    #endif
            {
            BITMAPFILEHEADER hdr;

            hdr.bfType      = ((WORD)('M' << 8) | 'B');
            hdr.bfSize      = dwLength + sizeof( BITMAPFILEHEADER );
            hdr.bfReserved1 = 0;
            hdr.bfReserved2 = 0;
            hdr.bfOffBits   = (DWORD)sizeof(hdr)
                            + lpNewHdr->bmi.biSize
                            + PaletteSize(lpNewHdr);

            pfile->Write( &hdr, sizeof( hdr ));
            }
        }

        pfile->Write(lpNewHdr, dwNewHdrLen);

    BYTE* hp  = ((BYTE*)lpDib) + dwOldHdrLen;
        // We subtract the new header length because we have already translated
        // dwLength to the new size
    DWORD dwWrite   = dwLength - dwNewHdrLen;
    DWORD dwIconPos = pfile->GetPosition();;

    while (dwWrite > 0)
        {
        UINT cbWrite = (UINT)min( dwWrite, 16384 );

        pfile->Write( (LPVOID)hp, cbWrite );

        hp      += cbWrite;
        dwWrite -= cbWrite;
        }

        dwWriteLength -= dwHeadLength;
        if (dwWriteLength > dwLength)
        {
                // We rounded up to 32 bytes above, so this should always be < 32
                ASSERT(dwWriteLength-dwLength < 32);

                DWORD dwZeros[] =
                {
                        0, 0, 0, 0, 0, 0, 0, 0,
                } ;

                pfile->Write( dwZeros, dwWriteLength-dwLength );
        }

    ASSERT( dwWrite == 0 );

        // Icon support is not in application anymore, right?
   #ifdef ICO_SUPPORT
    if (IsSaveIcon())
        {
        DWORD nextPos = pfile->GetPosition();

        pfile->Seek( (bFileHeader? sizeof( ICONFILEHEADER ): 0), CFile::begin );

        ICONDIRENTRY dir;

        dir.nWidth       = (BYTE)DIBWidth    ( lpDib );
        dir.nHeight      = (BYTE)DIBHeight   ( lpDib ) / 2;
        dir.nColorCount  = (BYTE)DIBNumColors( lpDib );
        dir.bReserved    = 0;
        dir.wReserved1   = 0;
        dir.wReserved2   = 0;
        dir.icoDIBSize   = dwLength;
        dir.icoDIBOffset = dwIconPos;

        pfile->Write( &dir, sizeof( ICONDIRENTRY ) );
        pfile->Seek( nextPos, CFile::begin );
        }
    else
   #endif
        m_bDirty = FALSE;

    pfile->Flush();

    GlobalUnlock(m_hThing);

    return TRUE;
    }

/*****************************************************************************/

BOOL CBitmapObj::Import( LPCTSTR szFileName )
    {
    CFile          file;
    CFileException e;

    theApp.SetFileError( IDS_ERROR_READLOAD, CFileException::none, szFileName );

    if (! file.Open( szFileName, CFile::modeRead | CFile::typeBinary, &e ))
        {
        theApp.SetFileError( IDS_ERROR_READLOAD, e.m_cause );
        return FALSE;
        }

    BOOL bGoodFile = TRUE;


    TRY
        {
        bGoodFile = ReadResource( &file );
        file.Close();
        }
    CATCH(CFileException, ex)
        {
        file.Abort();
        bGoodFile = FALSE;
        }
    END_CATCH

    if (!bGoodFile)
        {
        HGLOBAL hDib;

        if (hDib = LoadDIBFromFile(szFileName, &theApp.m_guidFltTypeUsed))
            {
            bGoodFile = ReadResource(hDib);

            if (bGoodFile)
                {
                theApp.SetFileError(0, CFileException::none);
                }
            else
                {
                theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp);
                }
            }
        }

    return bGoodFile;
    }

/*****************************************************************************/

BOOL CBitmapObj::ReadResource( CFile* pfile, PBResType rtType )
    {

    BOOL bPBrushOLEHeader = (rtType == rtPBrushOLEObj);
    BOOL bFileHeader = (rtType == rtFile)
     || (rtType == rtPaintOLEObj)|| bPBrushOLEHeader;

    DWORD dwLength = pfile->GetLength();
    // special case zero length files.
    if (! dwLength)
        {
        if (m_hThing)
            Free();

        m_bDirty = TRUE;

        return TRUE;
        }

        if (bPBrushOLEHeader)
        {
                DWORD dwReadLen;

                if (pfile->Read( &dwReadLen, sizeof( dwReadLen )) != sizeof( dwReadLen )
                        || dwReadLen > dwLength)
                {
                        theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp );
                        return FALSE;
                }
                dwLength -= sizeof(dwReadLen);
        }

        m_dwOffBits = 0;

    if (bFileHeader)
        {
        BITMAPFILEHEADER hdr;

        if (pfile->Read( &hdr, sizeof( hdr )) != sizeof( hdr ))
            {
            theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp );
            return FALSE;
            }


        if (hdr.bfType != ((WORD)('M' << 8) | 'B'))
            {
            theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp );
            return FALSE;
            }


        dwLength -= sizeof( hdr );

        // Store the offset from the beginning of the BITMAPINFO
        if (hdr.bfOffBits)
        {
            m_dwOffBits = hdr.bfOffBits - sizeof(hdr);
        }
        else
        {
            m_dwOffBits = 0;
        }


       }

    if (m_hThing != NULL)
        Free();

    m_lMemSize = dwLength;

    if (! Alloc())
        return FALSE;

    ASSERT( m_hThing );

    PVOID lpvThing = GlobalLock(m_hThing);

    BYTE* hp = (BYTE*)lpvThing;

    while (dwLength > 0)
        {
        UINT cbRead = (UINT)min( dwLength, 16384 );

        if (pfile->Read( (void FAR*)hp, cbRead ) != cbRead)
            {
            theApp.SetFileError( IDS_ERROR_READLOAD, ferrReadFailed );
            GlobalUnlock(m_hThing);
            return FALSE;
            }

        dwLength -= cbRead;
        hp       += cbRead;
        }

    ASSERT( dwLength == 0 );

    //
    // Calculate the bits offset because the BITMAPFILEHEADER had 0
    //
    if (!m_dwOffBits)
    {
        m_dwOffBits = (DWORD)(FindDIBBits ((LPSTR)lpvThing, 0) -
	                      (LPSTR)lpvThing);
    }

    GlobalUnlock(m_hThing);
    return TRUE;
    }

/*****************************************************************************/

BOOL CBitmapObj::ReadResource( HGLOBAL hDib )
    {
    LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER) GlobalLock(hDib);

    DWORD dwSizeImage;

    if (lpbi == NULL || lpbi->biSize != sizeof(BITMAPINFOHEADER))
        {
        theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp );
        return FALSE;
        }

    m_dwOffBits = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        m_dwOffBits += (1 << lpbi->biBitCount) * sizeof(RGBQUAD);

    if (lpbi->biSizeImage) 
    {
        lpbi->biSizeImage = abs(lpbi->biSizeImage);
        dwSizeImage = lpbi->biSizeImage;
    }
    else
    {
        dwSizeImage = abs(lpbi->biHeight) * ((lpbi->biWidth*lpbi->biBitCount+31)&~31)/8;
    }

    if (m_hThing != NULL)
        Free();

    m_lMemSize = m_dwOffBits + dwSizeImage;

    m_hThing = hDib;

    GlobalUnlock(hDib);

    return TRUE;
    }

/*****************************************************************************/

void CBitmapObj::ReLoadImage( CPBDoc* pbDoc )
    {
    FreeImg( m_pImg );
    CleanupImgUndo();
    CleanupImgRubber();
    m_pImg = NULL;

    if (CreateImg())
        {
        POSITION pos   = pbDoc->GetFirstViewPosition();
        CPBView* pView = (CPBView*)pbDoc->GetNextView( pos );

        if (pView)
            {
            pView->m_pImgWnd->SetImg( m_pImg );
            pbDoc->UpdateAllViews( pView );
            InvalImgRect( m_pImg, NULL );
            }
        }
    }

/*****************************************************************************/

void SwapBitmaps(HDC hDC1, int x1, int y1, int wid, int hgt,
        HDC hDC2, int x2, int y2, CPalette* pPalette)
{
#if 0
// We would like to just XOR 3 times to swap, but sometimes the middle of the
// palette is empty, so we cannot
    BitBlt(m_pImg->hDC, rect.left   , rect.top,
                        rect.Width(), rect.Height(), hDC, 0, 0, DSx);
    BitBlt(hDC, 0, 0, rect.Width(), rect.Height(), m_pImg->hDC,
                                           rect.left, rect.top, DSx);
    BitBlt(m_pImg->hDC, rect.left, rect.top, rect.Width(), rect.Height(),
                                                     hDC, 0, 0, DSx);
#else
        CDC dcTemp;

        CDC dc1, dc2;
        dc1.Attach(hDC1);
        dc2.Attach(hDC2);



        BOOL bSuccess = dcTemp.CreateCompatibleDC(&dc1);

        // Don't create a bitmap that is too large, or we will spend all our time
        // swapping
        int hgtTemp = 0x10000/wid;
        hgtTemp = min(hgt, max(1, hgtTemp));

        CBitmap bmTemp;
        bSuccess = bSuccess && bmTemp.CreateCompatibleBitmap(&dc1, wid, hgtTemp);
        bSuccess = bSuccess && dcTemp.SelectObject(&bmTemp)!=NULL;

        if (!bSuccess)
        {
                // Make sure the DC's do not get deleted
                dc1.Detach();
                dc2.Detach();
                return;
        }

        if (pPalette)
        {
                dcTemp.SelectPalette(pPalette, TRUE);
                dcTemp.RealizePalette();
        }

        int yTemp;
        for (yTemp=0; yTemp<hgt; yTemp+=hgtTemp)
        {
                hgtTemp = min(hgtTemp, hgt-yTemp);

                dcTemp.BitBlt(0, 0, wid, hgtTemp, &dc1, x1, y1+yTemp, SRCCOPY);
                dc1.BitBlt(x1, y1+yTemp, wid, hgtTemp, &dc2   , x2, y2+yTemp, SRCCOPY);
                dc2.BitBlt(x2, y2+yTemp, wid, hgtTemp, &dcTemp, 0 , 0, SRCCOPY);
        }

        // Make sure the DC's do not get deleted
        dc1.Detach();
        dc2.Detach();

        // Note that I explicitly delete the DC first, so I do not have to worry
        // about selecting old objects back in
        dcTemp.DeleteDC();
#endif
}

void CBitmapObj::UndoAction( CBmObjSequence* pSeq, UINT nActionID )
    {
    switch (nActionID)
        {
        default:
            break;

        case A_ImageChange:

            if (((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
            ||   (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
               && theImgBrush.m_pImg != NULL)
                {
                HideBrush();
                InvalImgRect( theImgBrush.m_pImg, NULL ); // hide tracker
                theImgBrush.m_pImg = NULL;
                }

            int     cb;
            CRect   rect;
            HBITMAP hImgBitmap;

            pSeq->RetrieveInt( cb );

            ASSERT(cb == sizeof( CRect ) + sizeof( hImgBitmap  ));

            pSeq->RetrieveRect( rect );

            int nCursor = pSeq->m_nCursor;

            pSeq->Retrieve( (BYTE*)&hImgBitmap, sizeof( hImgBitmap ) );

            // Wipe out the old handles since we're reusing them in the
            // new record and we don't what them deleted when this record
            // is removed!
            memset(&pSeq->ElementAt(nCursor), 0, sizeof( hImgBitmap ));

            // Perform undo using these parameters...

            SetupRubber(m_pImg);
            SetUndo(m_pImg); // For redo...
            HideBrush();

            ASSERT(m_pImg != NULL);

            HDC hDC = CreateCompatibleDC(m_pImg->hDC);

            if (hDC == NULL)
                {
                theApp.SetGdiEmergency();
                return;
                }

            HPALETTE hOldPalette = NULL;
            HBITMAP  hOldBitmap  = (HBITMAP)SelectObject(hDC, hImgBitmap);

            ASSERT(hOldBitmap != NULL);

            if (m_pImg->m_pPalette)
                {
                hOldPalette = SelectPalette( hDC, (HPALETTE)m_pImg->m_pPalette->m_hObject,
                                                   FALSE ); // Background ??
                RealizePalette( hDC );
                }

            // Three blits here swap the image and the undo bits, that
            // way the undo bits are set up for a redo!

            ASSERT(m_pImg->hDC != NULL);
            SwapBitmaps(m_pImg->hDC, rect.left, rect.top,
                rect.Width(), rect.Height(), hDC, 0, 0, m_pImg->m_pPalette);

            if (hOldPalette)
                SelectPalette( hDC, hOldPalette, FALSE ); // Background ??

            SelectObject(hDC, hOldBitmap);
            DeleteDC(hDC);

            InvalImgRect (m_pImg, &rect);
            CommitImgRect(m_pImg, &rect);

            // Record the redo information...

            theUndo.Insert((BYTE*)&hImgBitmap, sizeof (hImgBitmap));
            theUndo.InsertRect(rect);
            theUndo.InsertInt(sizeof (CRect) + sizeof (hImgBitmap));
            theUndo.InsertInt(A_ImageChange);
            theUndo.InsertPtr(m_pImg->m_pBitmapObj);
            theUndo.InsertByte(CUndoBmObj::opAction);

            break;
        }
    }

/*****************************************************************************/

void CBitmapObj::DeleteUndoAction(CBmObjSequence* pSeq, UINT nActionID)
    {
    switch (nActionID)
        {
        default:
            break;

        case A_ImageChange:
            CRect rect;
            HBITMAP hImgBitmap;

            pSeq->RetrieveRect(rect);
            pSeq->Retrieve((BYTE*)&hImgBitmap, sizeof (hImgBitmap));

            if (hImgBitmap != NULL)
                DeleteObject(hImgBitmap);
            break;
        }
    }

/*****************************************************************************/

BOOL CBitmapObj::FinishUndo(const CRect* pRect)
    {
    ASSERT( g_hUndoImgBitmap );

    CRect rect;
    if (pRect == NULL)
        rect.SetRect(0, 0, m_pImg->cxWidth, m_pImg->cyHeight);
    else
        rect = *pRect;

    HDC      hDC1 = NULL;
    HDC      hDC2 = NULL;
    HPALETTE hOldPalette  = NULL;
    HPALETTE hOldPalette2 = NULL;
    HBITMAP  hImgBitmap  = NULL;
    HBITMAP  hOldBitmap1;
    HBITMAP  hOldBitmap2;

    if (rect.left >= rect.right || rect.top >= rect.bottom)
        {
        // Not an error, just nothing to do...
        return TRUE;
        }

    hImgBitmap = CreateCompatibleBitmap( m_pImg->hDC, rect.Width(), rect.Height() );

    if (hImgBitmap == NULL)
        goto LError;

    if ((hDC1 = CreateCompatibleDC(m_pImg->hDC)) == NULL)
        goto LError;

    if ((hDC2 = CreateCompatibleDC(m_pImg->hDC)) == NULL)
        goto LError;

    if (m_pImg->m_pPalette)
        {
        hOldPalette = SelectPalette(hDC1, (HPALETTE)m_pImg->m_pPalette->m_hObject, FALSE );
        RealizePalette( hDC1 );

        hOldPalette2 = SelectPalette(hDC2, (HPALETTE)m_pImg->m_pPalette->m_hObject, FALSE );
        RealizePalette( hDC2 );
        }

    VERIFY((hOldBitmap1 = (HBITMAP)SelectObject(hDC1,       hImgBitmap)) != NULL);
    VERIFY((hOldBitmap2 = (HBITMAP)SelectObject(hDC2, g_hUndoImgBitmap)) != NULL);

    BitBlt(hDC1, 0, 0, rect.Width(), rect.Height(),
           hDC2,       rect.left   , rect.top, SRCCOPY);

    SelectObject(hDC1, hOldBitmap1);
    SelectObject(hDC2, hOldBitmap2);

    if (hOldPalette != NULL)
        {
        ::SelectPalette(hDC1, hOldPalette, FALSE ); // Background ??
        }
    if (hOldPalette2 != NULL)
        {
        ::SelectPalette(hDC2, hOldPalette2, FALSE ); // Background ??
        }

    DeleteDC(hDC1);
    DeleteDC(hDC2);

    theUndo.BeginUndo( IDS_UNDO_PAINTING );

    theUndo.Insert((BYTE*)&hImgBitmap , sizeof (hImgBitmap));
    theUndo.InsertRect(rect);
    theUndo.InsertInt(sizeof (CRect) + sizeof (hImgBitmap));
    theUndo.InsertInt(A_ImageChange);
    theUndo.InsertPtr(this);
    theUndo.InsertByte(CUndoBmObj::opAction);

    theUndo.EndUndo();

    // NOTE: At this point, we could free the undo bitmaps, but instead
    // they are left around for next time...

    return TRUE;

LError:

    if (hImgBitmap != NULL)
        DeleteObject(hImgBitmap);

    if (hDC1 != NULL)
        DeleteDC(hDC1);

    if (hDC2 != NULL)
        DeleteDC(hDC2);

    // REVIEW: Since we couldn't allocate something here, there will
    // be no way to undo the last operation...  What should we do?
    // Chances are, the system is so low on memory, a message box
    // giving an option might even fail.
    //
    // For now, let's just beep to try to tell the user that whatever
    // just happend can't be undone.  Also, free the image sized bitmaps
    // so the system has a little free memory.

    CleanupImgUndo();

    MessageBeep(0);

    #ifdef _DEBUG
    TRACE(TEXT("Not enough memory to undo image change!\n"));
    #endif

    return FALSE;
    }


/*****************************************************************************/

BOOL CBitmapObj::SetIntProp(UINT nPropID, int val)
    {
    CWaitCursor waitCursor; // these all take awhile!

    switch (nPropID)
        {
        case P_Width:
            return SetSizeProp( P_Size, CSize( val, m_nHeight ) );
            break;

        case P_Height:
            return SetSizeProp( P_Size, CSize( m_nWidth, val ) );
            break;

        case P_Colors:
            if (CImgTool::GetCurrentID() == IDMB_PICKTOOL
            ||  CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
                {
                CommitSelection( TRUE );
                theImgBrush.m_pImg = NULL;
                }

            SetUndo( m_pImg );
            FinishUndo( NULL );

            // Perform the color-count conversion with DIBs
            DWORD dwSize;

            ::SelectObject( m_pImg->hDC, m_pImg->hBitmapOld );

            LPSTR lpDib = (LPSTR) DibFromBitmap( 
                m_pImg->hBitmap, BI_RGB, m_pImg->cPlanes * m_pImg->cBitCount,
                m_pImg->m_pPalette, NULL, dwSize, 
                m_pImg->cXPelsPerMeter, m_pImg->cYPelsPerMeter );

            ::SelectObject( m_pImg->hDC, m_pImg->hBitmap );

            if (lpDib == NULL)
                {
                theApp.SetGdiEmergency();
                return FALSE;
                }

            // Make a new palette appropriate for this colors setting
            CPalette* pNewPalette = NULL;

            int iPlanes = (val? 1: ::GetDeviceCaps( m_pImg->hDC, PLANES    ));
            int iBitCnt = (val? 1: ::GetDeviceCaps( m_pImg->hDC, BITSPIXEL ));
            int iColors = iPlanes * iBitCnt;

            val = 3;

            if (theApp.m_bPaletted)
                switch (iColors)
                    {
                    case 1:
                        pNewPalette = GetStd2Palette();
                        break;

                    case 4:
                        pNewPalette = GetStd16Palette();
                        break;

                    case 8:
                        pNewPalette = GetStd256Palette();
                        break;
                    }

            switch (iColors)
                {
                case 8:
                    val = 2;
                    break;

                case 4:
                    val = 1;
                    break;

                case 1:
                    val = 0;
                    break;
                }

            HBITMAP hTmpBitmap = CreateBitmap( 1, 1, iPlanes, iBitCnt, NULL );
            HBITMAP hNewBitmap = CreateBitmap( m_pImg->cxWidth,
                                               m_pImg->cyHeight,
                                               iPlanes, iBitCnt, NULL );
            if (! hTmpBitmap || ! hNewBitmap)
                {
                FreeDib( lpDib );

                if (hTmpBitmap)
                    ::DeleteObject( hTmpBitmap );

                if (hNewBitmap)
                    ::DeleteObject( hNewBitmap );

                if (pNewPalette)
                    delete pNewPalette;

                theApp.SetGdiEmergency();
                return FALSE;
                }

            HPALETTE hPalOld = NULL;

            ::SelectObject( m_pImg->hDC, hTmpBitmap );

            if (pNewPalette)
                {
                hPalOld = ::SelectPalette( m_pImg->hDC, (HPALETTE)pNewPalette->m_hObject, FALSE );
                ::RealizePalette( m_pImg->hDC );
                }

            int iLinesDone = SetDIBits( m_pImg->hDC, hNewBitmap, 0,
                                        m_pImg->cyHeight,
                                        FindDIBBits( lpDib ),
                                        (LPBITMAPINFO)lpDib, DIB_RGB_COLORS );
            FreeDib( lpDib );

            if (iLinesDone != m_pImg->cyHeight)
                {
                ::SelectObject( m_pImg->hDC, m_pImg->hBitmap );

                if (hPalOld)
                    {
                    ::SelectPalette( m_pImg->hDC, hPalOld, FALSE );
                    ::RealizePalette( m_pImg->hDC );

                    delete pNewPalette;
                    }

                ::DeleteObject( hTmpBitmap );
                ::DeleteObject( hNewBitmap );

                theApp.SetGdiEmergency();

                return FALSE;
                }
            m_pImg->cPlanes   = iPlanes;
            m_pImg->cBitCount = iBitCnt;

            m_nColors = val;

            ::SelectObject( m_pImg->hDC, hNewBitmap );
            ::DeleteObject( m_pImg->hBitmap );

            m_pImg->hBitmap = hNewBitmap;

            if (m_pImg->m_pPalette)
                {
                if (! pNewPalette)
                    {
                    ::SelectPalette( m_pImg->hDC, m_pImg->m_hPalOld, FALSE );
                    m_pImg->m_hPalOld = NULL;
                    }
                delete m_pImg->m_pPalette;
                }

            m_pImg->m_pPalette = pNewPalette;
             theApp.m_pPalette = pNewPalette;

            ::DeleteObject( hTmpBitmap );

            DirtyImg( m_pImg );
            InvalImgRect( m_pImg, NULL );

            // The rubber-banding bitmap is now invalid...
            if (m_pImg == pRubberImg)
                {
                TRACE(TEXT("Clearing rubber\n"));
                pRubberImg = NULL;
                SetupRubber( m_pImg );
                }

            if (g_pColors)
                g_pColors->SetMono( ! m_nColors );

            InformDependants( P_Image );
            break;
        }

    m_bDirty = TRUE;

    return TRUE;
    }

/*****************************************************************************/

GPT CBitmapObj::GetIntProp(UINT nPropID, int& val)
    {
    switch (nPropID)
        {
        case P_Colors:
            val = m_nColors;
            return valid;
            break;

        case P_Image:
            val = NULL;
            return valid; // Must return now since this is a fake prop...
        }

    return invalid;
    }


/*****************************************************************************/

BOOL CBitmapObj::SetSizeProp(UINT nPropID, const CSize& val)
    {
    ASSERT(m_pImg != NULL);

    if ((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
    ||  (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
        {
        CommitSelection(TRUE);
        theImgBrush.m_pImg = NULL;
        }

    switch (nPropID)
        {
        default:
            ASSERT(FALSE);

        case P_Size:
            if (val.cx == m_pImg->cxWidth && val.cy == m_pImg->cyHeight)
                return TRUE;

            if (val.cx < 1 || val.cy < 1)
                {
                CmpMessageBox(IDS_ERROR_BITMAPSIZE, AFX_IDS_APP_TITLE,
                              MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
                }

            CWaitCursor waitCursor;
            BOOL bStretch = FALSE;

            CSize curSize;
            GetImgSize(m_pImg, curSize);

            bStretch = m_nShrink;

            SetUndo(m_pImg);
            CRect undoRect(0, 0, m_pImg->cxWidth, m_pImg->cyHeight);

            if (! SetImgSize(m_pImg, (CSize)val, bStretch))
                {
                theApp.SetMemoryEmergency();
                return FALSE;
                }

            FinishUndo(&undoRect);

            DirtyImg(m_pImg);

            pRubberImg = NULL;
            SetupRubber(m_pImg);

            if (theUndo.IsRecording())
                {
                theUndo.OnSetIntProp(this, P_Width, m_nWidth);
                theUndo.OnSetIntProp(this, P_Height, m_nHeight);
                }

            int nOldWidth = m_nWidth;
            int nOldHeight = m_nHeight;

            m_nWidth = val.cx;
            m_nHeight = val.cy;

            if (m_nWidth != nOldWidth)
                InformDependants(P_Width);

            if (m_nHeight != nOldHeight)
                InformDependants(P_Height);

            InformDependants(P_Image);

            break;
        }

    return TRUE;
    }

/*****************************************************************************/

BOOL CBitmapObj::SaveResource( BOOL bClear )
    {
    if (m_pImg == NULL)
        return TRUE;

    if (bClear)
        {
        if (m_hThing && ! m_pImg->bDirty && ! m_bDirty)
            return TRUE; // nothing to save

        m_bDirty |= m_pImg->bDirty;

        if (m_pImg == theImgBrush.m_pImg)
            theImgBrush.m_pImg = NULL;

        if (m_pImg == pRubberImg)
            pRubberImg = NULL;

        HideBrush();
        }

    DWORD dwStyle = BI_RGB;
    int   iColors = m_nColors;

    if (m_nSaveColors >= 0)
        {
        iColors = m_nSaveColors;
        m_nSaveColors = -1;
        }

    if (m_bCompressed)
        {
        switch (iColors)
            {
            case 1:
                dwStyle = BI_RLE4;
                break;

            case 2:
                dwStyle = BI_RLE8;
                break;
            }
        }

    switch (iColors)
        {
        case 0:
            iColors = 1;
            break;

        case 1:
            iColors = 4;
            break;

        case 2:
            iColors = 8;
            break;

        case 3:
            iColors = 24;
            break;

        default:
            iColors = 0;
            break;
        }

    HBITMAP hBitmap     = m_pImg->hBitmap;
    HBITMAP hMaskBitmap = NULL;
    BOOL    bNewBitmap  = FALSE;
    HGLOBAL lpDIB;
    DWORD   dwSize;

        // Icon support is not in application anymore, right?
   #ifdef ICO_SUPPORT
    if (IsSaveIcon())
        {
        // build a mask based on the current background color
        // and make sure the bitmap is the icon size
        bNewBitmap = SetupForIcon( hBitmap, hMaskBitmap );

        if (iColors > 4 || iColors < 1)
            iColors = 4;
        }
   #endif

    ::SelectObject( m_pImg->hDC, m_pImg->hBitmapOld );

    lpDIB = DibFromBitmap( 
        hBitmap, dwStyle, (WORD)iColors, 
        theApp.m_pPalette, hMaskBitmap, dwSize, 
        m_pImg->cXPelsPerMeter, m_pImg->cYPelsPerMeter );

    ::SelectObject( m_pImg->hDC, m_pImg->hBitmap );

    if (bNewBitmap)
        {
        ::DeleteObject(     hBitmap );
        ::DeleteObject( hMaskBitmap );
        }

    if (lpDIB == NULL)
        {
        theApp.SetMemoryEmergency();

        return FALSE;
        }

    if (m_hThing != NULL)
        Free();

    // We packed the DIB, so the offset will always be right after the palette,
    // which is implied by this being 0
    m_dwOffBits = 0;
    m_hThing    = lpDIB;
    m_lMemSize  = dwSize;

    if (bClear)
        m_pImg->bDirty = FALSE;

    return TRUE;
    }

/*****************************************************************************/

// Icon support is not in application anymore, right?
BOOL CBitmapObj::SetupForIcon( HBITMAP& hBitmap, HBITMAP& hMaskBitmap )
    {
    CDC       dcIcon;
    CDC       dcMask;
    CBitmap   bmIcon;
    CBitmap   bmMask;
    CDC*      pdcBitmap = CDC::FromHandle( m_pImg->hDC );
    CSize     sizeIcon( ::GetSystemMetrics( SM_CXICON ),
                        ::GetSystemMetrics( SM_CYICON ) );
    BOOL      bNewBitmap = FALSE;

    if (dcIcon.CreateCompatibleDC( pdcBitmap )
    &&  dcMask.CreateCompatibleDC( pdcBitmap )
    &&  bmIcon.CreateCompatibleBitmap( pdcBitmap, sizeIcon.cx, sizeIcon.cy )
    &&  bmMask.CreateBitmap( sizeIcon.cx, sizeIcon.cy, 1, 1, NULL ))
        {
        CPalette* ppalOld = NULL;
        CBitmap*  pbmOldIcon = dcIcon.SelectObject( &bmIcon );
        CBitmap*  pbmOldMask = dcMask.SelectObject( &bmMask );

        if (theApp.m_pPalette)
            {
            ppalOld = dcIcon.SelectPalette( theApp.m_pPalette, FALSE );
            dcIcon.RealizePalette();
            }
        dcIcon.PatBlt( 0, 0, sizeIcon.cx, sizeIcon.cy, WHITENESS );

        CBrush brBackGround( crRight );

        if (brBackGround.GetSafeHandle() != NULL)
            {
            CRect rect( 0, 0, sizeIcon.cx, sizeIcon.cy );

            dcIcon.FillRect( &rect, &brBackGround );

            brBackGround.DeleteObject();
            }
        int iWidth  = min( sizeIcon.cx, m_pImg->cxWidth );
        int iHeight = min( sizeIcon.cy, m_pImg->cyHeight );

        dcIcon.BitBlt( 0, 0, iWidth, iHeight, pdcBitmap, 0, 0, SRCCOPY );

        COLORREF oldBkColor = dcIcon.SetBkColor( crRight );

        dcMask.BitBlt( 0, 0, sizeIcon.cx, sizeIcon.cy, &dcIcon, 0, 0, SRCCOPY );

        COLORREF cRefFGColorOld = dcMask.SetTextColor( RGB(   0,   0,   0 ) );
        COLORREF cRefBKColorOld = dcMask.SetBkColor  ( RGB( 255, 255, 255 ) );

        dcIcon.BitBlt( 0, 0, sizeIcon.cx, sizeIcon.cy, &dcMask, 0, 0, DSna );

        dcMask.SetTextColor( cRefFGColorOld );
        dcMask.SetBkColor  ( cRefBKColorOld );
        dcIcon.SetBkColor  ( oldBkColor );

        if (ppalOld != NULL)
            dcIcon.SelectPalette( ppalOld, FALSE );

        if (pbmOldIcon != NULL)
            dcIcon.SelectObject( pbmOldIcon );

        if (pbmOldMask != NULL)
            dcMask.SelectObject( pbmOldMask );

            hBitmap = (HBITMAP)bmIcon.Detach();
        hMaskBitmap = (HBITMAP)bmMask.Detach();
         bNewBitmap = TRUE;
        }

    if (dcIcon.GetSafeHdc() != NULL)
        dcIcon.DeleteDC();

    if (dcMask.GetSafeHdc() != NULL)
        dcMask.DeleteDC();

    if (bmIcon.GetSafeHandle() != NULL)
        bmIcon.DeleteObject();

    if (bmMask.GetSafeHandle() != NULL)
        bmMask.DeleteObject();

    return bNewBitmap;
    }

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\hypertrm\xfer\zmodem.hh ===
/*
 * xmodem.hh -- Include file for ZMODEM private stuff
 *
 * Copyright 1989 by Hilgraeve Inc. -- Monroe, MI
 * All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

// These constants are used to turn on various types of debug display
// #define DEBUG_DUMPPACKET    // Log bad packet contents to a file

#if defined(ERROR)
#undef	ERROR
#endif
#if defined(CAN)
#undef	CAN
#endif

#define OK				0
#define FALSE			0
#define TRUE			1
#if defined(ERROR)
#undef	ERROR
#endif
#define ERROR		  (-1)
#define FILE_DONE		1
#define TRANSFER_DONE	2

/*
 * Max value for HOWMANY is 255.
 *   A larger value reduces system overhead but may evoke kernel bugs.
 *   133 corresponds to an XMODEM/CRC sector
 */
#ifndef HOWMANY
#define HOWMANY 133
#endif

/* Ward Christensen / CP/M parameters - Don't change these! */
#define ENQ 005
#define CAN ('X'&037)
#define XOFF ('s'&037)
#define XON ('q'&037)
#define SOH 1
#define STX 2
#define EOT 4
#define ACK 6
#define NAK 025
#define CPMEOF 032
#define WANTCRC 0103	/* send C not NAK to get crc not checksum */
#define TIMEOUT (-2)
#define RCDO (-3)
#define ZCARRIER_LOST	 (-4)
#define ERRORMAX 5
#define RETRYMAX 5
#define WCEOT (-10)
#define PATHLEN 257	/* ready for 4.2 bsd ? */
#define UNIXFILE 0xF000	/* The S_IFMT file mask bit for stat */

/* Parameters for ZSINIT frame */

#define ZATTNLEN 32	/* Max length of attention string */

/* Control structure, allocated during transfers to hold control variables */
struct z_mdm_cntrl
	{
	HSESSION hSession;			/* in case we actually need this */
	HCOM     hCom;				/* derived from above */

	int		 nMethod;			/* Zmodem, or Zmodem wiht crash recovery? */
	int		 fSavePartial;		/* Save partially received files? */
	unsigned long	ulOverride;	/* Override "file exists" overwrite options? */

	long	 real_bytes;		/* real number of bytes, not virtual number */
	long	 file_bytes;		/* number of bytes processed in current file */
	long	 total_bytes;		/* number of bytes total in previous files */
	long	 actual_bytes;		/* previous value includes skipped files */
	int		 nSkip;				/* true if skipping a file */
	void *	 flagkey;			/* used for detecting the user abort key */
	jmp_buf  flagkey_buf;		/* used for long jump after user abort */
	jmp_buf  intrjmp;
	ST_IOBUF *fh;				/* handle for the current file */
	long	 basesize;			/* used when appending to a file */
	long	 xfertimer; 		/* used for timing the transfers */
	long	 xfertime;			/* ditto */
	int      nfiles;			/* total number of files to transfer */
	int      filen; 			/* number of the current file */
	long	 filesize;			/* size of the current file */
	long	 nbytes;			/* total number of bytes to transfer */
	int      Rxtimeout;			/* Tenths of a second to wait for something */
	long     *z_cr3tab; 		/* pointer to 32 bit checksum table */
	unsigned short *z_crctab;	/* pointer to 16 bit checksum table */
	int      Rxframeind; 	/* ZBIN ZBIN32, or ZHEX type of frame received */
	int      Rxtype; 			/* Type of header received */
	int      Rxcount;			/* Count of data bytes received */
	char     Rxhdr[4];			/* Received header */
	char     Txhdr[4];			/* Transmitted header */
	long     Rxpos; 			/* Received file position */
	long     Txpos; 			/* Transmitted file position */
	int      Txfcs32; 		/* TRUE means send binary frames with 32 bit FCS */
	int      Crc32t; 		/* Display flag indicating 32 bit CRC being sent */
	int      Crc32;		/* Display flag indicating 32 bit CRC being received */
	char     Attn[ZATTNLEN+1];	/* Attention string rx sends to tx on err */
	int      lastsent;			/* Last char we sent */
	int      Not8bit; 			/* Seven bits seen on header */
	long     displayed_time;

	int      Zctlesc;
	int      Zrwindow;
	int      Eofseen;
	int      tryzhdrtype;
	int	     Thisbinary;
	int	     Filemode;
	long     Modtime;
	int      do_init;
	TCHAR    zconv; 		/* ZMODEM file conversion request */
	TCHAR    zmanag;		/* ZMODEM file management request */
	TCHAR    ztrans;		/* ZMODEM file transport request */
	TCHAR   *secbuf;
	TCHAR   *fname;
	TCHAR   *our_fname;

	stFB	 stP;			/* used in foo com functions */

	TCHAR   *txbuf;
	int	     Filesleft;
	long     Totalleft;
	int	     blklen;
	int	     blkopt; 			 /* do we override zmodem block length */
	int	     Beenhereb4;
	TCHAR	 Wantfcs32;			/* Do we want 32 bit crc			   */
	int	     Rxflags;
	unsigned Rxbuflen;			/* receiver maximum buffer length */
	unsigned Txwindow;
	unsigned Txwcnt;			/* counter used to space ack requests */
	unsigned Txwspac;			/* space between ZCRCQ requests */
	TCHAR    Myattn[1];
	int      errors;
	int      s_error;
	int      pstatus;
	int      last_event;

	int      Lskipnocor;
	long     Lastsync;			/* last offset to which we got a ZRPOS */
	long     Lrxpos;			/* receivers last reported offset */
	};

typedef struct z_mdm_cntrl ZC;

#define updcrc(x,cp,crc) (x->z_crctab[((crc >> 8) & 255)] ^ (crc << 8) ^ cp)
#define UPDC32(x,b,c) (x->z_cr3tab[((int)c ^ b) & 0xff] ^ ((c >> 8) & 0x00FFFFFF))

/* from zmdm.c */

void zsbhdr		(ZC *zc, int type, BYTE *hdr);
void zsbh32		(ZC *zc, BYTE *hdr, int type);
void zshhdr		(ZC *zc, int type, BYTE *hdr);
void zsdata		(ZC *zc, BYTE *buf, int length, int frameend);
void zsda32		(ZC *zc, BYTE *buf, int length, int frameend);

int  zrdata		(ZC *zc, BYTE *buf, int length);
int  zrdat32	(ZC *zc, BYTE *buf, int length);
int  zgethdr	(ZC *zc, BYTE *hdr, int eflag);
int  zrbhdr		(ZC *zc, BYTE *hdr, int eflag);
int  zrbhdr32 	(ZC *zc, BYTE *hdr, int eflag);
int  zrhhdr		(ZC *zc, BYTE *hdr, int eflag);

void zputhex	(ZC *zc, int c);
void zsendline	(ZC *zc, int c);
int  zgethex	(ZC *zc);
int  zgeth1		(ZC *zc);
int  zdlread	(ZC *zc);
int  noxrd7		(ZC *zc);
void stohdr		(ZC *zc, long pos);
long rclhdr		(BYTE *hdr);

int  zmdm_rl	(ZC *zc, int timeout);

/* Functions used to fiddle with the displays */

void zmdms_progress  (ZC *zc, int status);
void zmdms_newfile   (ZC *zc, int filen, TCHAR *fname, long flength);
void zmdms_update    (ZC *zc, int state);

void zmdmr_progress  (ZC *zc, int status);
void zmdmr_update    (ZC *zc, int status);
void zmdmr_filecnt   (ZC *zc, int cnt);
void zmdmr_totalsize (ZC *zc, long bytes);
void zmdmr_newfile   (ZC *zc, int filen, BYTE *theirname, TCHAR *ourname);
void zmdmr_filesize  (ZC *zc, long fsize);

unsigned int zmdm_error  (ZC *zc, int error);
		 int zmdm_retval (ZC *zc, int flag, int error);

/* from zmdm_rcv.c */

int  tryz 	(ZC *zc);
int  rzfiles	(ZC *zc);
int  rzfile	(ZC *zc);
void zmputs	(ZC *zc, char *s);
int  closeit	(ZC *zc);
void ackbibi	(ZC *zc);
/* void bttyout  (char c); */

/* from zmdm_snd.c */

int  wcs		  (ZC *zc, char *oname);
int  wctxpn	  (ZC *zc, char *name);
int  zfilbuf	  (ZC *zc);
void canit	  (ZC *zc);
int  getzrxinit (ZC *zc);
int  sendzsinit (ZC *zc);
int  zsendfile  (ZC *zc, char *buf, int blen);
int  zsendfdata (ZC *zc);
int  getinsync  (ZC *zc, int flag);
void saybibi	  (ZC *zc);

/* the following stuff is here as an attempt to match names into HA5 */

#define readline(h,x)	zmdm_rl(h,x)

#define xsendline(h,p,c)	fooComSendChar(h->hCom,p,c)
#define sendline(h,p,c)		fooComSendChar(h->hCom,p,c)
#define flushmo(h,p)		fooComSendPush(h->hCom,p)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\bmpstrm.cpp ===
//
// loadimag.cpp
//
// implementation of the CBmpStream class
//

#include "stdafx.h"
#include "bmpstrm.h"
#include "imaging.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

CBmpStream::CBmpStream()
{
    m_cRef = 1;

    m_hBuffer   = 0;
    m_nSize     = 0;
    m_nPosition = 0;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CBmpStream::~CBmpStream()
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CBmpStream::Create(CBmpStream **ppvObject)
{
    if (ppvObject == 0)
    {
	    return E_POINTER;
    }

    TRY
    {
        *ppvObject = new CBmpStream;
    }
    CATCH(CMemoryException, e)
    {
        *ppvObject = 0;
    }
    END_CATCH

    if (*ppvObject == 0)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HGLOBAL CBmpStream::GetBuffer()
{
    return m_hBuffer;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

VOID CBmpStream::SetBuffer(HGLOBAL hBuffer, DWORD dwSize, DWORD dwOffBits)
{
    m_hBuffer   = hBuffer;
    m_nSize     = dwSize;
    m_nPosition = 0;

    if (dwOffBits == 0)
    {
        PBYTE pBuffer = (PBYTE) GlobalLock(m_hBuffer);

        if (pBuffer)
        {
            dwOffBits = FindDibOffBits(pBuffer);

            GlobalUnlock(m_hBuffer);
        }
    }

    m_Header.bfType      = MAKEWORD('B', 'M');
    m_Header.bfSize      = sizeof(BITMAPFILEHEADER) + dwSize;
    m_Header.bfReserved1 = 0;
    m_Header.bfReserved2 = 0;
    m_Header.bfOffBits   = sizeof(BITMAPFILEHEADER) + dwOffBits;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

VOID CBmpStream::FreeBuffer()
{
    if (m_hBuffer)
    {
        GlobalFree(m_hBuffer);

        m_hBuffer   = 0;
        m_nSize     = 0;
        m_nPosition = 0;
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CBmpStream::ReAllocBuffer(SIZE_T dwBytes)
{
    HGLOBAL hBuffer;

    if (m_hBuffer == 0)
    {
        hBuffer = GlobalAlloc(GMEM_MOVEABLE, dwBytes);
    }
    else
    {
        hBuffer = GlobalReAlloc(m_hBuffer, dwBytes, 0);
    }

    if (hBuffer == 0)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    m_hBuffer = hBuffer;
    m_nSize = dwBytes;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::QueryInterface(REFIID riid, void **ppvObject)
{
    if (ppvObject == 0)
    {
	    return E_POINTER;
    }

    if (riid == IID_IUnknown)
    {
	    AddRef();
	    *ppvObject = (IUnknown*) this;
	    return S_OK;
    }

    if (riid == IID_IStream)
    {
	    AddRef();
	    *ppvObject = (IStream *) this;
	    return S_OK;
    }

    *ppvObject = 0;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CBmpStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}
    
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CBmpStream::Release()
{
    LONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    if (pcbRead)
    {
        *pcbRead = 0;
    }

    if (m_nPosition > sizeof(m_Header) + m_nSize)
    {
        return S_FALSE;
    }

    if (cb == 0)
    {
        return S_OK;
    }

    if (cb > sizeof(m_Header) + m_nSize - m_nPosition)
    {
        cb = (ULONG) (sizeof(m_Header) + m_nSize - m_nPosition);
    }

    if (m_nPosition < sizeof(m_Header))
    {
        ULONG nBytesToReadInHeader = min(cb, sizeof(m_Header) - m_nPosition);

        CopyMemory(pv, (PBYTE) &m_Header + m_nPosition, nBytesToReadInHeader);

        pv = (PBYTE) pv + nBytesToReadInHeader;

        cb -= nBytesToReadInHeader;

        m_nPosition += nBytesToReadInHeader;

        if (pcbRead)
        {
            *pcbRead += nBytesToReadInHeader;
        }
    }

    if (cb > 0)
    {
        PBYTE pBuffer = (PBYTE) GlobalLock(m_hBuffer);

        if (pBuffer == 0)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        CopyMemory(pv, pBuffer + m_nPosition - sizeof(m_Header), cb);

        GlobalUnlock(m_hBuffer);

        m_nPosition += cb;

        if (pcbRead)
        {
            *pcbRead += cb;
        }
    }

    return S_OK;
}
    
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    if (pcbWritten)
    {
        *pcbWritten = 0;
    }

    if (cb == 0)
    {
        return S_OK;
    }

    if (m_nSize + sizeof(m_Header) < m_nPosition + cb)
    {
        HRESULT hr = ReAllocBuffer(m_nPosition + cb - sizeof(m_Header));

        if (hr != S_OK)
        {
            return hr;
        }
    }

    if (m_nPosition < sizeof(m_Header))
    {
        ULONG nBytesToWriteInHeader = min(cb, sizeof(m_Header) - m_nPosition);

        CopyMemory((PBYTE) &m_Header + m_nPosition, pv, nBytesToWriteInHeader);

        pv = (PBYTE) pv + nBytesToWriteInHeader;

        cb -= nBytesToWriteInHeader;

        m_nPosition += nBytesToWriteInHeader;

        if (pcbWritten)
        {
            *pcbWritten += nBytesToWriteInHeader;
        }
    }

    if (cb > 0)
    {
        PBYTE pBuffer = (PBYTE) GlobalLock(m_hBuffer);

        if (pBuffer == 0)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        CopyMemory(pBuffer + m_nPosition - sizeof(m_Header), pv, cb);

        GlobalUnlock(m_hBuffer);

        m_nPosition += cb;

        if (pcbWritten)
        {
            *pcbWritten += cb;
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    switch (dwOrigin)
    { 
        case STREAM_SEEK_SET: 
            m_nPosition = (SIZE_T) dlibMove.QuadPart; 
            break;

        case STREAM_SEEK_CUR: 
            m_nPosition += (SIZE_T) dlibMove.QuadPart; 
            break;

        case STREAM_SEEK_END: 
            m_nPosition = m_nSize - (SIZE_T) dlibMove.QuadPart; 
            break;

        default:
            return E_INVALIDARG;
    }

    if (plibNewPosition)
    {
        plibNewPosition->QuadPart = m_nPosition;
    }

    return S_OK;
}
    
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::SetSize(ULARGE_INTEGER libNewSize)
{
    return ReAllocBuffer((SIZE_T) libNewSize.QuadPart);
}
        
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}
    
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Revert()
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\bmpstrm.h ===
#ifndef _BMPSTRM_H_
#define _BMPSTRM_H_

class CBmpStream : public IStream
{
protected:
    CBmpStream();
    ~CBmpStream();

public:
    static HRESULT Create(CBmpStream **ppvObject);

    HGLOBAL GetBuffer();
    VOID    SetBuffer(HGLOBAL hBuffer, DWORD dwSize, DWORD dwOffBits);
    VOID    FreeBuffer();
    HRESULT ReAllocBuffer(SIZE_T dwBytes);

public:
    // IUnknown 

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ISequentialStream

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

    // IStream

    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);

private:
    LONG             m_cRef;
    HGLOBAL          m_hBuffer;
    SIZE_T           m_nSize;
    SIZE_T           m_nPosition;
    BITMAPFILEHEADER m_Header;
};

#endif //_BMPSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\bar.cpp ===
/******************************************************************************/
/* Bar.CPP: IMPLEMENTATION OF THE CStatBar (Status Bar) CLASS                 */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*    CStatBar::CStatBar                                                      */
/*    CStatBar::~CStatBar                                                     */
/*    CStatBar::Create                                                        */
/*    CStatBar::OnSetFont                                                     */
/*    CStatBar::DoPaint                                                       */
/*    CStatBar::DrawStatusText                                                */
/*    CStatBar::SetText                                                       */
/*    CStatBar::SetPosition                                                   */
/*    CStatBar::SetSize                                                       */
/*    CStatBar::ClearPosition                                                 */
/*    CStatBar::ClearSize                                                     */
/*    CStatBar::Reset                                                         */
/*    CStatBar::OnPaletteChanged                                                                                          */
/*                                                                            */
/*                                                                            */
/* Functions in this file                                                     */
/*                                                                            */
/*    ClearStatusBarSize                                                      */
/*    ClearStatusBarPosition                                                  */
/*    SetPrompt                                                               */
/*    SetPrompt                                                               */
/*    ShowStatusBar                                                           */
/*    IsStatusBarVisible                                                      */
/*    GetStatusBarHeight                                                      */
/*    InvalidateStatusBar                                                     */
/*    ClearStatusBarPositionAndSize                                           */
/*    ResetStatusBar                                                          */
/*    SetStatusBarPosition                                                    */
/*    SetStatusBarSize                                                        */
/*    SetStatusBarPositionAndSize                                             */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CStatBar, CStatusBar )

#include "memtrace.h"

CStatBar        *g_pStatBarWnd = NULL;

static UINT BASED_CODE indicators[] =
    {
    ID_SEPARATOR,           // status line indicator
    IDB_SBPOS,
    IDB_SBSIZE
    };

BEGIN_MESSAGE_MAP( CStatBar, CStatusBar )
                ON_WM_SYSCOLORCHANGE()
        ON_MESSAGE(WM_SETFONT, OnSetFont)
                ON_MESSAGE(WM_SIZEPARENT, OnSizeParent)
        ON_WM_NCDESTROY()
END_MESSAGE_MAP()

static int miSlackSpace;

/******************************************************************************/

CStatBar::CStatBar()
    {
    m_iBitmapWidth  = 0;
    m_iBitmapHeight = 0;
    miSlackSpace = 0;
    m_iSizeY = 0;
    }

CStatBar::~CStatBar()
        {
        // Ensure that the CControlBar doesn't assert trying access our parent
        // object (CPBFrame) during the destruction of our parent object.
        m_pDockSite = NULL;
        }

/******************************************************************************/

BOOL CStatBar::Create( CWnd* pParentWnd )
    {
    BOOL bRC = TRUE;
    int cxStatBar;  // width of a char in the status bar

    // Create the status Bar Window.
    bRC = CStatusBar::Create(pParentWnd);

    ASSERT (bRC != FALSE);

    if (bRC != FALSE)
        {
        // Set the Pane Indicators.
        bRC = SetIndicators( indicators, sizeof( indicators ) / sizeof( UINT ) );

        ASSERT( bRC != FALSE );

        if (bRC != FALSE)
            {
            TRY
                {
                // Load the Separator Strings
                VERIFY(m_cstringSizeSeparator.LoadString(IDS_SIZE_SEPARATOR));
                VERIFY(m_cstringPosSeparator.LoadString(IDS_POS_SEPARATOR));
                }
            CATCH(CMemoryException,e)
                {
                m_cstringSizeSeparator.Empty();
                m_cstringPosSeparator.Empty();
                }
            END_CATCH

            // Load the Position and Size Bitmaps
            VERIFY(m_posBitmap.LoadBitmap(IDB_SBPOS));
            VERIFY(m_sizeBitmap.LoadBitmap(IDB_SBSIZE));

            if ( (m_posBitmap.GetSafeHandle() != NULL) &&
                 (m_sizeBitmap.GetSafeHandle() != NULL)    )
                {
                //Calculate the size of the pane and set them

                CClientDC dc(this);

                /*DK* What font to select? */
                /*DK* What to do if in foreign Language, Size "0"? */

                cxStatBar = (dc.GetTextExtent(TEXT("0"), 1)).cx;
                BITMAP bmp;

                m_posBitmap.GetObject(sizeof (BITMAP), &bmp);

                m_iBitmapWidth  = bmp.bmWidth;
                m_iBitmapHeight = bmp.bmHeight;

                int iPaneWidth;
                UINT uiID, uiStyle;

                GetPaneInfo( 0, uiID, uiStyle, iPaneWidth) ;
                SetPaneInfo( 0, uiID, SBPS_NORMAL | SBPS_STRETCH, iPaneWidth );

                GetPaneInfo(1, uiID, uiStyle, iPaneWidth);

                if (iPaneWidth < bmp.bmWidth + (SIZE_POS_PANE_WIDTH * cxStatBar))
                    {
                    iPaneWidth = bmp.bmWidth + (SIZE_POS_PANE_WIDTH * cxStatBar);
                    SetPaneInfo(1, uiID, uiStyle, iPaneWidth);
                    }

                GetPaneInfo(2, uiID, uiStyle, iPaneWidth);

                if (iPaneWidth < bmp.bmWidth + (SIZE_POS_PANE_WIDTH * cxStatBar))
                    {
                    iPaneWidth = bmp.bmWidth + (SIZE_POS_PANE_WIDTH * cxStatBar);
                    SetPaneInfo(2, uiID, uiStyle, iPaneWidth);
                    }

                // force a height change
                CFont *pcFontTemp = GetFont();

                // initialize font height etc
                OnSetFont( (WPARAM)(HFONT)pcFontTemp->GetSafeHandle(), 0 );
                }
            else
                {
                bRC = FALSE;
                }
            }
        }
    return bRC;
    }

/******************************************************************************/

void CStatBar::OnNcDestroy( void )
    {
    m_posBitmap.DeleteObject();
    m_sizeBitmap.DeleteObject();

    m_posBitmap.m_hObject = NULL;
    m_sizeBitmap.m_hObject = NULL;

    m_cstringSizeSeparator.Empty();
    m_cstringPosSeparator.Empty();

    CStatusBar::OnNcDestroy();
    }

/******************************************************************************/

CSize CStatBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
    {
    CSize size = CStatusBar::CalcFixedLayout( bStretch, bHorz );

    size.cy = m_iSizeY;

    return size;
    }

/******************************************************************************/
/* Change the height of the status bar to allow the bitmaps to   be painted   */
/* in the panes. The height is set in the OnSetFont  OnSetFont method.  Save  */
/* the current border values, change  then call OnSetFont and then reset the  */
/* border values                                                              */
/*                                                                            */
/* This will increase the height of the whole status bar  until the next      */
/* OnSetFont (font change) for the status bar.                                */
/*                                                                            */
/* In Barcore.cpp, the Height of the status bar is set in the  OnSetFont      */
/* method as follows:                                                         */
/*                                                                            */
/*  Height =  = (tm.tmHeight - tm.tmInternalLeading) +                        */
/*              CY_BORDER*4 (which is 2 extra on top, 2                       */
/*              on bottom) - rectSize.Height();                               */
/*                                                                            */
/*  This is really                                                            */
/*    Height = Height of Font + Border between Font and                       */
/*             Pane edges + Border between Pane edges and                     */
/*             Status bar window.                                             */
/*                                                                            */
/*  tm.tmHeight - tm.tmInternalLeading is Font Height CY_BORDER*4 is border   */
/*  between font and pane edges rectSize.Height is Neg of Border between Pane */
/*  and SBar rectSize is set to 0, then the deflated by the border size.      */
/*  Deflating from 0 => negative, and  - negative gives us a positive amount. */
/*                                                                            */
/*  by default m_cyBottomBorder = m_cyTopBorder = 1                           */
/******************************************************************************/
/* We only change the border sizes temporarily for the calculation of the     */
/* status bar height.  We really don't want to change the border sizes, but   */
/* are just using them as a way to affect the size of the whole bar.          */
/******************************************************************************/

LRESULT CStatBar::OnSetFont(WPARAM wParam, LPARAM lParam)
    {

    CRect rect;

    int iTmpcyTopBorder    = m_cyTopBorder;
    int iTmpcyBottomBorder = m_cyBottomBorder;

    m_cyTopBorder = m_cyBottomBorder = 2;
    miSlackSpace = 0;

    // Can't do this in MFC 4
//    lResult = CStatusBar::OnSetFont(wParam, lParam); //initialize font height etc

    rect.SetRectEmpty();
    CalcInsideRect( rect, TRUE ); // will be negative size

    int iBorder = CY_BORDER * 4 - rect.Height();
    int iSize   = m_iSizeY - iBorder;
    int cyTallest = m_iBitmapHeight;
    CDC dc;

    if( dc.CreateIC( TEXT("DISPLAY"), NULL, NULL, NULL ) )
        {
        TEXTMETRIC tm;
                tm.tmHeight=0;
        CFont *font = CFont::FromHandle( (HFONT)wParam );
                if ( font )
                        {
                        CFont *oldFont = dc.SelectObject(font);

                if( dc.GetTextMetrics( &tm ) && tm.tmHeight > cyTallest )
                    cyTallest = tm.tmHeight;

                        if (oldFont)
                                dc.SelectObject(oldFont);
                        }
                dc.DeleteDC();
        }

    if (cyTallest > iSize)
        m_iSizeY     = cyTallest + iBorder;

    if (m_iBitmapHeight > iSize)
        miSlackSpace = m_iBitmapHeight - iSize;

    m_cyTopBorder    = iTmpcyTopBorder;
    m_cyBottomBorder = iTmpcyBottomBorder;

    return 1L;
    }

/******************************************************************************/
/* This routine is overloaded to allow us to paint the bitmaps in the panes.  */
/* If this routine was not here, it would work fine, but no bitmaps would     */
/* appear in the status indicator panes.                                      */
/******************************************************************************/

void CStatBar::DoPaint( CDC* pDC )
    {
    BOOL     bRC;
    CString  cstringText_Pane1;
    CString  cstringText_Pane2;
    CRect    rect_Pane1;
    CRect    rect_Pane2;
    CRgn     cRgn_Pane1;
    CRgn     cRgn_Pane2;
    CBitmap* pOldBitmap;
    UINT     uiStyle_Pane1;
    UINT     uiStyle_Pane2;
    UINT     uiID;
    int      iPaneWidth;
    HDC      hdc = pDC->GetSafeHdc();

    GetItemRect( 1, &rect_Pane1 );  // get pane rect
    GetItemRect( 2, &rect_Pane2 );  // get pane rect

    pDC->ExcludeClipRect( &rect_Pane1 ); // exclude pane rect from paint
    pDC->ExcludeClipRect( &rect_Pane2 ); // exclude pane rect from paint

    CStatusBar::DoPaint( pDC ); // Let Parent Class paint remainder of status bar

    CFont* pfntOld = pDC->SelectObject( GetFont() );

    GetPaneText( 1, cstringText_Pane1 );  // Get the Text for the Pane
    GetPaneText( 2, cstringText_Pane2 );  // The status bar holds the text for us.

    GetPaneInfo( 1, uiID, uiStyle_Pane1, iPaneWidth );
    GetPaneInfo( 2, uiID, uiStyle_Pane2, iPaneWidth );

    uiStyle_Pane1 = SBPS_NORMAL;
    uiStyle_Pane2 = SBPS_NORMAL;

    CDC srcDC; // select current bitmap into a compatible CDC

    bRC = srcDC.CreateCompatibleDC( pDC );

    ASSERT( bRC != FALSE );

    if (bRC != FALSE)
        {
        // Set the Text and Background Colors for a Mono to Color Bitmap
        // Conversion.  These are also set in DrawStatusText, so should not
        // have to reset them for the other bitmap/pane
        COLORREF crTextColor = pDC->SetTextColor( GetSysColor( COLOR_BTNTEXT ) );
        COLORREF crBkColor   = pDC->SetBkColor  ( GetSysColor( COLOR_BTNFACE ) );

        bRC = cRgn_Pane1.CreateRectRgnIndirect( rect_Pane1 );

        ASSERT( bRC != FALSE );

        if (bRC != FALSE)
            {
            pDC->SelectClipRgn( &cRgn_Pane1 ); // set clip region to pane rect

            pOldBitmap = srcDC.SelectObject( &m_posBitmap );

            rect_Pane1.InflateRect( -CX_BORDER, -CY_BORDER ); // deflate => don't paint on the borders

            pDC->BitBlt( rect_Pane1.left,    rect_Pane1.top,
                         rect_Pane1.Width(), rect_Pane1.Height(),
                         &srcDC, 0, 0, SRCCOPY ); // BitBlt to pane rect
            srcDC.SelectObject( pOldBitmap );

            rect_Pane1.InflateRect( CX_BORDER, CY_BORDER ); // Inflate back for drawstatustext

            // paint the borders and the text.
            DrawStatusText( hdc, rect_Pane1, cstringText_Pane1, uiStyle_Pane1,
                                                           m_iBitmapWidth + 1 );
            }

        cRgn_Pane2.CreateRectRgnIndirect(rect_Pane2);

        ASSERT( bRC != FALSE );

        if (bRC != FALSE)
            {
            pDC->SelectClipRgn(&cRgn_Pane2); // set clip region to pane rect

            pOldBitmap = srcDC.SelectObject(&m_sizeBitmap);
            rect_Pane2.InflateRect(-CX_BORDER, -CY_BORDER); // deflate => don't paint on the borders
            pDC->BitBlt(rect_Pane2.left, rect_Pane2.top, rect_Pane2.Width(),
                        rect_Pane2.Height(), &srcDC, 0, 0, SRCCOPY); // BitBlt to pane rect
            srcDC.SelectObject(pOldBitmap);
            rect_Pane2.InflateRect(CX_BORDER, CY_BORDER); // Inflate back for drawstatustext
            // DrawStatusText will paint the borders and the text.
            DrawStatusText(hdc, rect_Pane2, cstringText_Pane2, uiStyle_Pane2, m_iBitmapWidth+1);
            }
        pDC->SetTextColor( crTextColor );
        pDC->SetBkColor  ( crBkColor   );
        }
    if (pfntOld != NULL)
        pDC->SelectObject( pfntOld );
    }

/******************************************************************************/
/* Partially taken from BARCORE.CPP DrawStatusText method of CStatusBar.      */
/* Last parameter was added                                                   */
/*                                                                            */
/* This will allow us to output the text indented the space amount for our    */
/* bitmap.  Normally, this routine puts the text left alligned to the pane.   */
/******************************************************************************/

void PASCAL CStatBar::DrawStatusText( HDC    hDC,
                                      CRect const& rect,
                                      LPCTSTR lpszText,
                                      UINT   nStyle,
                                      int    iIndentText )
    {
    ASSERT(hDC != NULL);

    CBrush* cpBrushHilite;
    CBrush* cpBrushShadow;
    HBRUSH  hbrHilite = NULL;
    HBRUSH  hbrShadow = NULL;

    if (! (nStyle & SBPS_NOBORDERS))
        {
        if (nStyle & SBPS_POPOUT)
            {
            // reverse colors
            cpBrushHilite = GetSysBrush( COLOR_BTNSHADOW    );
            cpBrushShadow = GetSysBrush( COLOR_BTNHIGHLIGHT );
            }
        else
            {
            // normal colors
            cpBrushHilite = GetSysBrush( COLOR_BTNHIGHLIGHT );
            cpBrushShadow = GetSysBrush( COLOR_BTNSHADOW    );
            }

        hbrHilite = (HBRUSH)cpBrushHilite->GetSafeHandle();
        hbrShadow = (HBRUSH)cpBrushShadow->GetSafeHandle();
        }

    // background is already grey
    UINT nOpts           = ETO_CLIPPED;
    int nOldMode         = SetBkMode   ( hDC, OPAQUE );
    COLORREF crTextColor = SetTextColor( hDC, GetSysColor( COLOR_BTNTEXT ) );
    COLORREF crBkColor   = SetBkColor  ( hDC, GetSysColor( COLOR_BTNFACE ) );

    // Draw the hilites
    if (hbrHilite)
        {
        HGDIOBJ hOldBrush = SelectObject( hDC, hbrHilite );

        if (hOldBrush)
            {
            PatBlt( hDC, rect.right, rect.bottom, -(rect.Width() - CX_BORDER),
                                                        -CY_BORDER, PATCOPY );
            PatBlt( hDC, rect.right, rect.bottom, -CX_BORDER,
                                      -(rect.Height() - CY_BORDER), PATCOPY );
            SelectObject( hDC, hOldBrush );
            }
        }

    if (hbrShadow)
        {
        HGDIOBJ hOldBrush = SelectObject( hDC, hbrShadow );

        if (hOldBrush)
            {
            PatBlt( hDC, rect.left, rect.top, rect.Width(), CY_BORDER, PATCOPY );
            PatBlt( hDC, rect.left, rect.top,
                                   CX_BORDER, rect.Height(), PATCOPY );
            SelectObject( hDC, hOldBrush );
            }
        }

    // We need to adjust the rect for the ExtTextOut, and then adjust it back
    // just support left justified text
    if (lpszText != NULL && !(nStyle & SBPS_DISABLED))
        {
        CRect rectText( rect );

        rectText.InflateRect( -2 * CX_BORDER, -CY_BORDER );

        // adjust left edge for indented Text
        rectText.left += iIndentText;

            // align on bottom (since descent is more important than ascent)
        SetTextAlign( hDC, TA_LEFT | TA_BOTTOM );

        if (miSlackSpace > 0)
            rectText.InflateRect( 0, -(miSlackSpace / 2) );

        ExtTextOut( hDC, rectText.left, rectText.bottom,
                 nOpts, &rectText, lpszText, lstrlen( lpszText ), NULL );
        }

    SetTextColor( hDC, crTextColor );
    SetBkColor  ( hDC, crBkColor   );
    }

/******************************************************************************/

BOOL CStatBar::SetText(LPCTSTR szText)
    {
    BOOL bRC = TRUE;

    if (theApp.InEmergencyState())
        {
        bRC = FALSE;
        }
    else
        {
        bRC = SetPaneText(0, szText);
        }

    return bRC;
    }

/******************************************************************************/

BOOL CStatBar::SetPosition(const CPoint& pos)
    {
    BOOL bRC = TRUE;
    int cch;
    TCHAR szBuf [20];

    cch = wsprintf(szBuf, TEXT("%d~%d"), pos.x, pos.y);

    for (int i = 0; i < cch; i++)
        if (szBuf[i] == TEXT('~'))
            {
            szBuf[i] = m_cstringPosSeparator[0];
            break;
            }

    ASSERT (cch != 0);

    if (cch != 0)
        {
        bRC = SetPaneText(1, szBuf);
        }
    else
        {
        bRC = FALSE;
        }

    return bRC;
    }

/******************************************************************************/

BOOL CStatBar::SetSize(const CSize& size)
    {
    BOOL bRC = TRUE;
    int cch;
    TCHAR szBuf [20];

    cch = wsprintf( szBuf, TEXT("%d~%d"), size.cx, size.cy );

    for (int i = 0; i < cch; i++)
        if (szBuf[i] == TEXT('~'))
            {
            szBuf[i] = m_cstringSizeSeparator[0];
            break;
            }

    ASSERT (cch != 0);

    if (cch != 0)
        bRC = SetPaneText(2, szBuf);
    else
        bRC = FALSE;

    return bRC;
    }

/******************************************************************************/

BOOL CStatBar::ClearPosition()
    {
    BOOL bRC = TRUE;
    bRC = SetPaneText(1, TEXT(""));  // clear the position
    return bRC;
    }

/******************************************************************************/

BOOL CStatBar::ClearSize()
    {
    BOOL bRC = TRUE;
    bRC = SetPaneText(2, TEXT(""));  // clear the size
    return bRC;
    }


/******************************************************************************/

BOOL CStatBar::Reset()
    {
    return ClearPosition() && ClearSize();
    }

/******************************************************************************/

void CStatBar::OnSysColorChange()
        {
        CStatusBar::OnSysColorChange();
        InvalidateRect(NULL,FALSE);
        }

/******************************************************************************/

void ClearStatusBarSize()
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->ClearSize();
    }

/******************************************************************************/

void ClearStatusBarPosition()
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->ClearPosition();
    }

/******************************************************************************/

void SetPrompt(LPCTSTR szPrompt, BOOL bRedrawNow)
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->SetText(szPrompt);
    if (bRedrawNow)
        g_pStatBarWnd->UpdateWindow();
    }

/******************************************************************************/

void SetPrompt(UINT nStringID, BOOL bRedrawNow)
    {
        ASSERT(g_pStatBarWnd);
    CString str;
    VERIFY(str.LoadString(nStringID));

    g_pStatBarWnd->SetText(str);

    if (bRedrawNow)
        g_pStatBarWnd->UpdateWindow();
    }

/******************************************************************************/

void ShowStatusBar(BOOL bShow /* = TRUE */)
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->ShowWindow(bShow ? SW_SHOWNOACTIVATE : SW_HIDE);
    }

/******************************************************************************/

BOOL IsStatusBarVisible()
    {
        ASSERT(g_pStatBarWnd);
    return (g_pStatBarWnd->GetStyle() & WS_VISIBLE) != 0;
    }

/******************************************************************************/

int GetStatusBarHeight()
    {
        ASSERT(g_pStatBarWnd);
    CRect rect;
    g_pStatBarWnd->GetWindowRect(rect);
    return rect.Height();
    }

/******************************************************************************/

void InvalidateStatusBar(BOOL bErase /* = FALSE */)
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->Invalidate(bErase);
    }

/******************************************************************************/

void ClearStatusBarPositionAndSize()
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->ClearSize();
    g_pStatBarWnd->ClearPosition();
    }

/******************************************************************************/

void ResetStatusBar()
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->Reset();
    }

/******************************************************************************/

void SetStatusBarPosition(const CPoint& pos)
    {
        ASSERT(g_pStatBarWnd);
        if ( ::IsWindow(g_pStatBarWnd->m_hWnd) )
        g_pStatBarWnd->SetPosition(pos);
    }

/******************************************************************************/

void SetStatusBarSize(const CSize& size)
    {
        ASSERT(g_pStatBarWnd);
    if ( ::IsWindow( g_pStatBarWnd->m_hWnd) )
        g_pStatBarWnd->SetSize(size);
    }

/******************************************************************************/

void SetStatusBarPositionAndSize(const CRect& rect)
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->SetPosition(((CRect&)rect).TopLeft());
    g_pStatBarWnd->SetSize(rect.Size());
    }

/******************************************************************************/

LRESULT CStatBar::OnSizeParent(WPARAM wParam, LPARAM lParam)
{
        LRESULT lRes = CStatusBar::OnSizeParent(wParam, lParam);

        return(lRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\bar.h ===
/******************************************************************************/
/* Bar.H:   Defines the Interface to the CStatBar (Status Bar) CLASS          */
/*                                                                            */
/******************************************************************************/

#ifndef __BAR_H__
#define __BAR_H__

//below size does not include bitmap width
#define SIZE_POS_PANE_WIDTH 12    // Bitmap Width + 1 char separator + 5 digits + 1 char separator + 5 digits

// The 2 below defines were needed, since we had to duplicate the DrawStatusText
// method from the barcore.cpp file in the msvc\mfc\src directory
#define CX_BORDER 1   // from auxdata.h in the msvc\mfc\src directory
#define CY_BORDER 1   // from auxdata.h in the msvc\mfc\src directory

/******************************************************************************/

class CStatBar : public CStatusBar
    {
    DECLARE_DYNAMIC( CStatBar )

private:

    CBitmap m_posBitmap;
    CBitmap m_sizeBitmap;
    CString m_cstringSizeSeparator;
    CString m_cstringPosSeparator;
    int     m_iBitmapWidth;
    int     m_iBitmapHeight;
    int     m_iSizeY;

protected:

    virtual void DoPaint(CDC* pDC);
    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

    static  void PASCAL DrawStatusText( HDC hDC, CRect const& rect,
                                            LPCTSTR lpszText, UINT nStyle,
                                            int iIndentText = 0);

    afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
    afx_msg void    OnNcDestroy( void );
        afx_msg void    OnSysColorChange( void );

public:

    CStatBar();
    ~CStatBar();

    BOOL Create(CWnd* pParentWnd);

    BOOL SetText(LPCTSTR sz);

    BOOL SetPosition(const CPoint& pos);
    BOOL SetSize(const CSize& size);

    BOOL ClearPosition();
    BOOL ClearSize();

    BOOL Reset();

    DECLARE_MESSAGE_MAP()
    };

extern CStatBar *g_pStatBarWnd;

/******************************************************************************/
// NON-OBJECT Status bar API, Uses global object pointer to the StatBar object

void ShowStatusBar                ( BOOL bShow = TRUE );
BOOL IsStatusBarVisible           ();
void InvalidateStatusBar          ( BOOL bErase = FALSE );
void ClearStatusBarSize           ();
void ClearStatusBarPosition       ();
void ClearStatusBarPositionAndSize();
void ResetStatusBar               ();
void SetStatusBarPosition         ( const CPoint& pos );
void SetStatusBarSize             ( const CSize& size );
void SetStatusBarPositionAndSize  ( const CRect& rect );
void SetPrompt                    ( LPCTSTR, BOOL bRedrawNow = FALSE );
void SetPrompt                    ( UINT, BOOL bRedrawNow = FALSE );

/******************************************************************************/

#endif // __BAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\bmobject.h ===
#ifndef __BMOBJECT_H__
#define __BMOBJECT_H__

class CBmObjSequence;

// Get*Prop return type
enum GPT
    {
    invalid,    // Not a known property or disabled
    valid,      // Value is correct
    ambiguous   // Multiple selection with different values
    };

// Selection Object
class CFileBuffer;

class CBitmapObj : public CObject
    {
    DECLARE_DYNCREATE( CBitmapObj )

    public:

    CBitmapObj();

    ~CBitmapObj();

    void Clear();

    void InformDependants( UINT idChange );
    void AddDependant    ( CBitmapObj* newDependant );
    void RemoveDependant ( CBitmapObj* oldDependant );

    // Notification Callback
    void OnInform( CBitmapObj* pChangedSlob, UINT idChange );

    // Property Management
    BOOL SetIntProp (UINT idProp, int val);
    GPT  GetIntProp (UINT idProp, int& val);
    BOOL SetSizeProp(UINT nPropID, const CSize& val);

    BOOL MakeEmpty       ();
    BOOL Import          ( LPCTSTR szFileName );
    BOOL Export          ( LPCTSTR szFileName );

    // Specify the type of header to put on a resource
    typedef enum _PBResType
    {
        rtFile,
        rtDIB,
        rtPaintOLEObj,
        rtPBrushOLEObj,
    } PBResType;

    BOOL ReadResource    ( HGLOBAL hDib );
    BOOL ReadResource    ( CFile* pfile, PBResType rtType = rtFile );
    BOOL WriteResource   ( CFile* pfile, PBResType rtType = rtFile );

#ifdef PCX_SUPPORT
    BOOL ReadPCX         ( CFile* pfile );
    BOOL WritePCX        ( CFile* pfile );
    BOOL PackBuff        ( CFileBuffer *FileBuffer, BYTE *PtrDib, int byteWidth);
#endif


    BOOL CreateImg       ();
    BOOL SaveResource    ( BOOL bClear = TRUE );
    void ReLoadImage     ( CPBDoc* pbDoc );
    void UndoAction      ( CBmObjSequence* pSeq, UINT nActionID );
    void DeleteUndoAction( CBmObjSequence* pSeq, UINT nActionID );
    BOOL FinishUndo      ( const CRect* pRect );

    // Resource data access helpers...
    BOOL    Alloc(); // m_hThing of size m_lMemSize
    void    Free();                 // m_hThing and set m_lMemSize to zero
    void    Zap();  // frees memory and zeros out the file position
                    // information - used to completely empty a resobject

    CString GetDefExtension(int iStringId=0);

    BOOL SetupForIcon( HBITMAP& hBitmap, HBITMAP& hMaskBitmap );

    // Load m_hThing with the resource data from the res file
    inline  BOOL  IsDirty() const { return m_bDirty; }

    void SetDirty(BOOL bDirty = TRUE);

#ifdef  ICO_SUPPORT
    BOOL IsSaveIcon() { return(m_bSaveIcon); }
#endif

    struct IMG* m_pImg;

    // Properties...
    int  m_nWidth;
    int  m_nHeight;
    int  m_nColors;
    int  m_nSaveColors;
#ifdef ICO_SUPPORT
    BOOL m_bSaveIcon;
#endif

#ifdef PCX_SUPPORT
    BOOL m_bPCX;
#endif

    BOOL m_bCompressed;
    BOOL m_nShrink; // 0=crop, 1=shrink, 2=ask

    BOOL   m_bTempName;     // true if not save as m_strFileName yet
    BOOL   m_bDirty;        // true if changed

    HGLOBAL m_hThing;      // in memory resource (must be valid)
    DWORD   m_dwOffBits;     // offset of pixels in m_hThing; packed if 0
    LONG    m_lMemSize;      // size in bytes

    protected:

    CObList m_dependants;
    };

// Standard Slob Notifications
#define SN_DESTROY      0
#define SN_ALL          1

extern int mpncolorsbits[];

void PBGetDefDims(int& pnWidth, int& pnHeight);

#ifndef _WIN32
#define POINTS POINT
#endif

#endif // __BMOBJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\debugres.h ===
//
//	DEBUGRES.H
//		IDs for debug resources.
//

#define IDMX_IDLECHECKMEMORY		6100
#define IDMX_ALLOCCHECKMEMORY		6101
#define IDMX_DELAYFREEMEMORY		6102
#define IDMX_MEMORYSTATUSBAR		6103
#define IDMX_MKDLG                  7000
#define IDMX_BINDDLG                7001
#define IDMX_TRYDLG                 7002
#define IDMX_NAMEMAP                7003
#define IDMX_LOADFILE               7004
#define IDMX_SAVEFILE               7005
#define IDMX_LISTPROPS              7006
#define IDMX_CMDWND                 7007
#define IDMX_TESTSYMMANONE          7008
#define IDMX_TESTSYMMANTWO          7009
#define IDMX_TESTSYMMANTHREE        7010
#define IDMX_TESTSYMMANFOUR         7011
#define IDMX_POPPROP                7012
#define IDMX_LOGUNDO                7013
#define IDMX_FLUSHUNDO              7014
#define IDMX_TESTSHOWSYMRES         7015
#define IDMX_TESTPARSE              7016
#define IDMX_SETHELP				7500
#define IDMX_MAKEDIRTY				7501
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\colorsrc.h ===
// colorsrc.h : main header file for the PBRUSH application
//

#ifndef __COLORSRC_H__
#define __COLORSRC_H__

/******************************************************************************/

class CColors : public CObject
    {
    DECLARE_DYNCREATE( CColors )

    public:

    CColors();
   ~CColors();

    enum { MAXCOLORS = 256 };

    private:

    COLORREF*   m_colors;
    COLORREF*   m_monoColors;
    int         m_nColorCount;
    BOOL        m_bMono;

    public:

    void        SetMono ( BOOL bMono = TRUE );
    COLORREF    GetColor( int nColor );
    void        SetColor( int nColor, COLORREF color );

    int         GetColorCount() const { return m_nColorCount; }
    BOOL        GetMonoFlag  () const { return m_bMono; }

    void        EditColor( BOOL bLeft, BOOL bTrans );
    void        ResetColors(int nColors=256);
    void        CmdEditColor();
    #if 0 // unused features
    void        CmdLoadColors();
    void        CmdSaveColors();
    #endif
    };

/******************************************************************************/

extern CColors* g_pColors;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\docking.h ===
// docking.h : interface of the CDocking class
//

class CDocking : public CObject
    {
    DECLARE_DYNAMIC( CDocking )

    // Constructors
    public:     /***********************************************************/

    CDocking();

    // Attributes

    BOOL    Create( CPoint ptDrop, CRect& rectCurrent, BOOL bDocked, CPBView::DOCKERS tool );
    void    Move  ( CPoint ptNew );
    BOOL    Move  ( CPoint ptNew, CRect& rectFrame );
    BOOL    Clear ( CRect* prectLast = NULL );

    protected:  /***********************************************************/

    BOOL    DrawFocusRect();

    int     m_iDockingX;
    int     m_iDockingY;
    BOOL    m_bStarted;
    BOOL    m_bDocked;
    BOOL    m_bDocking;
    CRect   m_rectDockingPort;
    CRect   m_rectDocked;
    CRect   m_rectFree;
    CPoint  m_ptLast;
    CPoint  m_ptDocking;

    CPBView::DOCKERS m_Tool;
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\colorsrc.cpp ===
/******************************************************************************/
/*                                                                            */
/* Class Implementations for The Colors
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "ipframe.h"
#include "bmobject.h"
#include "minifwnd.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "colorsrc.h"
#include "toolbox.h"
#include "props.h"
#include "ferr.h"
#include "imgdlgs.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CColors, CObject )

#include "memtrace.h"

/******************************************************************************/

// Color Palette

COLORREF colorColors16 [] =
{
   RGB(  0,   0,   0), // Black
    RGB(128, 128, 128), // Dark Gray
    RGB(128,   0,   0), // Dark Red
    RGB(128, 128,   0), // Pea Green
    RGB(  0, 128,   0), // Dark Green
    RGB(  0, 128, 128), // Slate
    RGB(  0,   0, 128), // Dark Blue
    RGB(128,   0, 128), // Lavender
    RGB(255, 255, 255), // White
    RGB(192, 192, 192), // Light Gray
    RGB(255,   0,   0), // Bright Red
    RGB(255, 255,   0), // Yellow
    RGB(  0, 255,   0), // Bright Green
    RGB(  0, 255, 255), // Cyan
    RGB( 64,   0, 255), //
    RGB(255,   0, 255), // Magenta


};

COLORREF colorColorsDef [] =
    {
       RGB(  0,   0,   0), // Black
       RGB(128, 128, 128), // Dark Gray
       RGB(128,   0,   0), // Dark Red
       RGB(128, 128,   0), // Pea Green
       RGB(  0, 128,   0), // Dark Green
       RGB(  0, 128, 128), // Slate
       RGB(  0,   0, 128), // Dark Blue
       RGB(128,   0, 128), // Lavender
       RGB(128, 128,  64), //
       RGB(  0,  64,  64), //
       RGB(  0, 128, 255), //
       RGB(  0,  64, 128), //
       RGB(128,   0, 255), //
       RGB(128,  64,   0), //

       RGB(255, 255, 255), // White
       RGB(192, 192, 192), // Light Gray
       RGB(255,   0,   0), // Bright Red
       RGB(255, 255,   0), // Yellow
       RGB(  0, 255,   0), // Bright Green
       RGB(  0, 255, 255), // Cyan
       RGB(  0,   0, 255), // Bright Blue
       RGB(255,   0, 255), // Magenta
       RGB(255, 255, 128), //
       RGB(  0, 255, 128), //
       RGB(128, 255, 255), //
       RGB(128, 128, 255), //
       RGB(255,   0, 128), //
       RGB(255, 128,  64), //
    };

COLORREF bwColorsDef [] =
    {
    RGB(0,0,0),
    RGB(9,9,9),
    RGB(18,18,18),
    RGB(27,27,27),
    RGB(37,37,37),
    RGB(46,46,46),
    RGB(55,55,55),
    RGB(63,63,63),
    RGB(73,73,73),
    RGB(82,82,82),
    RGB(92,92,92),
    RGB(101,101,101),
    RGB(110,110,110),
    RGB(119,119,119),

    RGB(255,255,255),
    RGB(250,250,250),
    RGB(242,242,242),
    RGB(212,212,212),
    RGB(201,201,201),
    RGB(191,191,191),
    RGB(182,182,182),
    RGB(159,159,159),
    RGB(128,128,128),
    RGB(173,173,173),
    RGB(164,164,164),
    RGB(155,155,155),
    RGB(146,146,146),
    RGB(137,137,137),
    };

CColors* g_pColors;

/******************************************************************************/

void SetDrawColor( int iColor )
    {
    if (! g_pColors)
        return;

    COLORREF cr = g_pColors->GetColor( iColor );

    theLeft = iColor;

    SetDrawColor(cr);
    }

void SetDrawColor( COLORREF cr )
    {
     crLeft = cr;

    if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd) )
        g_pImgColorsWnd->InvalidateCurColors();

    if (   theImgBrush.m_pImg != NULL
    &&  (! theImgBrush.m_bFirstDrag || CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
    &&  ! g_bCustomBrush)
        CImgWnd::GetCurrent()->MoveBrush(theImgBrush.m_rcSelection);

    CImgTool* pcImgTool = CImgTool::GetCurrent();

    if (pcImgTool)
        {
        CFrameWnd* pFrame = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());

        if (pFrame)
            {
            CPBView* pcbActiveView = DYNAMIC_DOWNCAST(CPBView, pFrame->GetActiveView());

            if (pcbActiveView)
                pcImgTool->OnUpdateColors( pcbActiveView->m_pImgWnd );
            }
        }
    }

/***************************************************************************/

void SetEraseColor(int iColor)
    {
    if (! g_pColors)
        return;

    COLORREF cr = g_pColors->GetColor( iColor );

    theRight = iColor;

    SetEraseColor(cr);
    }


void SetEraseColor(COLORREF cr)
    {
     crRight = cr;

    if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd))
        g_pImgColorsWnd->InvalidateCurColors();

    if (   theImgBrush.m_pImg != NULL
    &&  (! theImgBrush.m_bFirstDrag || CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
    &&   ! g_bCustomBrush)
        {
        theImgBrush.RecalcMask(crRight);
        CImgWnd::GetCurrent()->MoveBrush(theImgBrush.m_rcSelection);
        }

    CImgTool* pcImgTool = CImgTool::GetCurrent();

    if (pcImgTool != NULL)
        {
        CFrameWnd* pFrame = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());

        if (pFrame)
            {
            CPBView* pcbActiveView = DYNAMIC_DOWNCAST(CPBView, pFrame->GetActiveView());

            if (pcbActiveView)
                pcImgTool->OnUpdateColors( pcbActiveView->m_pImgWnd );
            }
        }
    }

/***************************************************************************/

void SetLeftColor(int nColor)
    {
    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        HideBrush();

    SetDrawColor(nColor);
    }

/***************************************************************************/

void SetRightColor(int nColor)
    {
    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        HideBrush();

    SetEraseColor(nColor);

    theImgBrush.RecalcMask(crRight);
    }

/***************************************************************************/

//extern COLORREF crTrans; // transparent color

void SetTransColor( int iColor )
    {
    if (! g_pColors)
        return;

    theTrans = iColor;

    SetTransColor(g_pColors->GetColor( iColor ));
    }

void SetTransColor( COLORREF cr )
    {
    crTrans = cr;

    if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd) )
        g_pImgColorsWnd->InvalidateCurColors();

    if (   theImgBrush.m_pImg != NULL
    &&  (! theImgBrush.m_bFirstDrag || CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
    &&  ! g_bCustomBrush)
        CImgWnd::GetCurrent()->MoveBrush(theImgBrush.m_rcSelection);

    CImgTool* pcImgTool = CImgTool::GetCurrent();

    if (pcImgTool)
        {
        CFrameWnd* pFrame = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());

        if (pFrame)
            {
            CPBView* pcbActiveView = DYNAMIC_DOWNCAST(CPBView, pFrame->GetActiveView());

            if (pcbActiveView)
                pcImgTool->OnUpdateColors( pcbActiveView->m_pImgWnd );
            }
        }
    }

/***************************************************************************/

void InvalColorWnd()
    {
    if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd&& IsWindow(g_pImgColorsWnd->m_hWnd) )
        g_pImgColorsWnd->Invalidate(TRUE);

    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) &&
        CImgTool::GetCurrent()->IsFilled())
        g_pImgToolWnd->InvalidateOptions( FALSE );
    }

/***************************************************************************/

int AddNewColor( IMG* pImg, COLORREF crNew )
    {
    int iColor = -1;

    if (! pImg->m_pPalette)
        return iColor;

    LOGPALETTE256* pLogPal = new LOGPALETTE256;

    if (! pLogPal)
        {
        theApp.SetMemoryEmergency();
        return iColor;
        }


    pLogPal->palVersion    = 0x300;
    pLogPal->palNumEntries = (WORD)pImg->m_pPalette->GetPaletteEntries(
                                             0, MAX_PALETTE_COLORS,
                                             &pLogPal->palPalEntry[0] );

    pImg->m_pPalette->GetPaletteEntries (0, pLogPal->palNumEntries,
                                             &pLogPal->palPalEntry[0] );

    PALETTEENTRY PalEntry;
    PalEntry.peRed   = GetRValue( crNew );
    PalEntry.peGreen = GetGValue( crNew );
    PalEntry.peBlue  = GetBValue( crNew );
    PalEntry.peFlags = 0;

    UINT uNearest = pImg->m_pPalette->GetNearestPaletteIndex( crNew );

    if  (pLogPal->palPalEntry[uNearest].peRed   != PalEntry.peRed
    ||   pLogPal->palPalEntry[uNearest].peGreen != PalEntry.peGreen
    ||   pLogPal->palPalEntry[uNearest].peBlue  != PalEntry.peBlue)
        {
        int  iUsePalEntry = pLogPal->palNumEntries;
        BOOL bAdd = FALSE;

        ::SelectPalette( pImg->hDC, pImg->m_hPalOld, FALSE );

        if (iUsePalEntry >= MAX_PALETTE_COLORS)
            {
            // this needs to keep track of the colors added somehow
            // and not always write over the last one. Done
            iUsePalEntry  = MAX_PALETTE_COLORS + pImg->m_nLastChanged--;


            // This is so highly unlikely that I shudder to think?
            if (pImg->m_nLastChanged <= -MAX_PALETTE_COLORS)
                pImg->m_nLastChanged  = -1;

            bAdd = TRUE;
            }
        else
            bAdd = pImg->m_pPalette->ResizePalette( iUsePalEntry + 1 );

        if (bAdd)
            bAdd = pImg->m_pPalette->SetPaletteEntries( iUsePalEntry,
                                                        1, &PalEntry );
        if (bAdd)
            iColor = iUsePalEntry;

        ::SelectPalette(  pImg->hDC,
                (HPALETTE)pImg->m_pPalette->GetSafeHandle(), FALSE );
        ::RealizePalette( pImg->hDC );
        }

    delete pLogPal;

    return iColor;
    }

/******************************************************************************/

CColors::CColors() : CObject()
    {
    ASSERT( sizeof( colorColorsDef ) == sizeof( bwColorsDef ) );

    m_nColorCount = 0;
    m_bMono       = theApp.m_bMonoDevice;
    m_colors      = new COLORREF[MAXCOLORS];
    m_monoColors  = new COLORREF[MAXCOLORS];

    if (m_colors && m_monoColors)
        ResetColors();
    }

/******************************************************************************/

CColors::~CColors()
    {
    if (m_colors     != NULL)
        delete m_colors;

    if (m_monoColors != NULL)
        delete m_monoColors;

    m_colors     = NULL;
    m_monoColors = NULL;
    }

/******************************************************************************/

void CColors::SetMono( BOOL bMono )
    {
    if ((  m_bMono &&   bMono)
    ||  (! m_bMono && ! bMono))
        return;

    m_bMono = bMono;

    InvalColorWnd();
    }

/******************************************************************************/

COLORREF CColors::GetColor( int nColor )
    {
    ASSERT(nColor >= 0 && nColor < m_nColorCount);
    return (m_bMono ? m_monoColors : m_colors)[nColor];
    }

/******************************************************************************/

void CColors::SetColor( int nColor, COLORREF color )
    {
    ASSERT( nColor >= 0 && nColor < m_nColorCount );

    int iRed   = GetRValue( color );
    int iGreen = GetGValue( color );
    int iBlue  = GetBValue( color );

    if (m_bMono)
        {
        long bwvalue = (30 * iRed   +
                        59 * iGreen +
                        11 * iBlue) / 100;
        m_monoColors[nColor] = RGB(bwvalue, bwvalue, bwvalue);
        }
    else
        {
        if (theApp.m_bPaletted)
            color = PALETTERGB( iRed, iGreen, iBlue );
        else
            color = RGB( iRed, iGreen, iBlue );

        m_colors[nColor] = color;
        }

    InvalColorWnd();
    }

void CColors::CmdEditColor()
    {
    EditColor( TRUE, FALSE );
    }

/***************************************************************************/

extern INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);

UINT CALLBACK
MyAfxCommDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        if (hWnd == NULL)
                return 0;

        if (message == WM_SETFONT || message == WM_INITDIALOG)
                return (UINT) AfxDlgProc(hWnd, message, wParam, lParam);

        return 0;
}

/***************************************************************************/

static UINT_PTR CALLBACK /*LPCCHOOKPROC*/
EditColorHook(HWND hColorDlg, UINT nMessage, WPARAM wParam, LPARAM lParam)
{
// Are we initializing the dialog window?
if ( nMessage == WM_INITDIALOG )
        {
        // Reset the common dialog title
        CString strDialogTitle;
        strDialogTitle.LoadString(IDS_EDIT_COLORS);
        SetWindowText( hColorDlg, strDialogTitle );
        }
// Pass All Messages Along to Common Dialog
return MyAfxCommDlgProc(hColorDlg, nMessage, wParam, lParam );
}

void CColors::EditColor( BOOL bLeft, BOOL bTrans )
    {
    COLORREF* pColor;
    INT_PTR bRet;
    if (bTrans)
    {
       pColor = &crTrans;
    }
    else
    {
       pColor = bLeft? &crLeft: &crRight;
    }

    CColorDialog dlg( *pColor & 0xFFFFFF ); // Disregard palette-relative
    dlg.m_cc.Flags &= ~CC_SHOWHELP;  // Get rid of Help flag
    dlg.m_cc.lpfnHook = EditColorHook;

    bRet = dlg.DoModal();

    if (bRet != IDOK)
    {
       return;
    }
    COLORREF color = dlg.GetColor();

    BYTE iRed   = GetRValue( color );
    BYTE iGreen = GetGValue( color );
    BYTE iBlue  = GetBValue( color );

    if (theApp.m_bPaletted)
        *pColor = PALETTERGB( iRed, iGreen, iBlue );
    else
        *pColor =        RGB( iRed, iGreen, iBlue );

    int theColor;

    if (bTrans)
    {
       theColor = theTrans;
    }
    else
    {
       theColor = (bLeft? theLeft: theRight);
    }


    if (theColor != -1)
        {
        CPBDoc* pDoc = (CPBDoc*)((CFrameWnd*)AfxGetMainWnd())->GetActiveDocument();

        if (pDoc && pDoc->m_pBitmapObj->m_pImg)
            AddNewColor( pDoc->m_pBitmapObj->m_pImg, color );

        SetColor( theColor, color );
        }

    InvalColorWnd();
    }

/******************************************************************************/
#if 0 // poorly implemented, rarely used feature as of NT 5/ Memphis

void CColors::CmdLoadColors()
    {
    DWORD lFlags = 0;

    #ifndef _DEBUG
    lFlags = 0x00080000 /* OFN_EXPLORER */;
    #endif

        CString strFileTypes;
        strFileTypes.LoadString(IDS_PAL_FILETYPES);

    CFileDialog dlgFile( TRUE, TEXT(""), NULL, lFlags, strFileTypes, NULL );

        CString dlgtitle;
        dlgtitle.LoadString(IDS_LOAD_PALETTE_COLORS);
    dlgFile.m_ofn.lpstrTitle = dlgtitle;
    dlgFile.m_ofn.Flags  &= ~OFN_SHOWHELP;  // Get rid of Help flag
    dlgFile.m_ofn.Flags |= OFN_HIDEREADONLY;
    if (dlgFile.DoModal() != IDOK)
        return;

    CFile          file;
    CFileException ex;

    theApp.SetFileError( IDS_ERROR_OPEN, CFileException::none, dlgFile.GetPathName() );

    if (! file.Open( dlgFile.GetPathName(),
                     CFile::modeRead | CFile::typeBinary, &ex ))
        {
        theApp.SetFileError( IDS_ERROR_OPEN, ex.m_cause );
        return;
        }

    CHAR         cID[5];
    CHAR         cPalData[9];
    DWORD        dwRiffSize  = 0;
    DWORD        dwChunkSize = 0;
    COLORREF*    pColors     = NULL;
    int          iColors     = 0;
    int          index;

    if (file.Read(          cID         , sizeof( cID ) - 1 )      == (sizeof( cID         ) - 1)
    &&  file.Read( (void*)(&dwRiffSize ), sizeof( dwRiffSize ) )   ==  sizeof( dwRiffSize  )
    &&  file.Read(          cPalData    , sizeof( cPalData ) - 1 ) == (sizeof( cPalData    ) - 1)
    &&  file.Read( (void*)(&dwChunkSize), sizeof( dwChunkSize ) )  ==  sizeof( dwChunkSize ))
        {
        cID[4]      = '\0';
        cPalData[8] = '\0';

        BOOL bPal  = lstrcmpA( cID     , "RIFF" );
             bPal |= lstrcmpA( cPalData, "PAL data" );

        if (! bPal)
            {
            LPLOGPALETTE pLogPal = (LPLOGPALETTE) new BYTE[dwChunkSize];

            if (pLogPal)
                {
                if ((DWORD)file.Read( pLogPal, (UINT)dwChunkSize )
                                                  == dwChunkSize)
                    {
                    iColors = pLogPal->palNumEntries;

                    ASSERT( iColors == (int)((dwChunkSize - sizeof( LOGPALETTE )) / sizeof( PALETTEENTRY ) + 1) );

                    pColors = (COLORREF*)new BYTE[sizeof( COLORREF ) * iColors];

                    if (pColors)
                        {
                        for (index = 0; index < iColors; index++)
                            pColors[index] = RGB( pLogPal->palPalEntry[index].peRed,
                                                  pLogPal->palPalEntry[index].peGreen,
                                                  pLogPal->palPalEntry[index].peBlue );
                        }
                    else
                        {
                        theApp.SetMemoryEmergency();
                        iColors = 0;
                        }
                    }
                else
                    theApp.SetFileError( IDS_ERROR_OPEN, ferrReadFailed );

                delete [] (BYTE*)pLogPal;
                }
            else
                theApp.SetMemoryEmergency();
            }
        else
            theApp.SetFileError( IDS_ERROR_OPEN, ferrIllformedFile );
        }
    else
        theApp.SetFileError( IDS_ERROR_OPEN, ferrReadFailed );

    if (! iColors)
        return;

    if (theApp.m_bPaletted)
        {
        CPalette* ppalNew = CreatePalette( pColors, iColors );

        if (ppalNew)
            {
            CPBView*    pView      = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();
            CPBDoc*     pDoc       = (pView? pView->GetDocument(): NULL);
            CBitmapObj* pBitmapObj = ( pDoc?  pDoc->m_pBitmapObj: NULL);

            if (pBitmapObj)
                {
                if (pBitmapObj->m_pImg != pView->m_pImgWnd->m_pImg)
                    CommitSelection( TRUE );

                if (pBitmapObj->SaveResource( FALSE )) // get packed dib
                    {
                    int   iAdds;
                    LPSTR lpDib        = (LPSTR)pBitmapObj->GetData();
                    IMG*  pImg         = pBitmapObj->m_pImg; // merge palettes can handle null pointers
                    CPalette* ppalMrgd = MergePalettes( ppalNew,
                                                        pImg->m_pPalette,
                                                        iAdds );
                    if (ppalMrgd) // got a new palette.
                        {
                        delete ppalNew;
                        ppalNew = ppalMrgd;
                        }

                    LPBITMAPINFO  lpDibInfo  = (LPBITMAPINFO)lpDib;
                    RGBQUAD*      prgbColors = &(lpDibInfo->bmiColors[0]);
                    unsigned short* puColors = (unsigned short*)prgbColors;
                    int           iDibColors = DIBNumColors( lpDib );

                    for (int iLoop = 0; iLoop < iDibColors; iLoop++, puColors++, prgbColors++)
                        *puColors = (unsigned short)ppalNew->GetNearestPaletteIndex(
                                           PALETTERGB( prgbColors->rgbRed,
                                                       prgbColors->rgbGreen,
                                                       prgbColors->rgbBlue ) );
                    CleanupImgUndo();
                    CleanupImgRubber();

                    ::SelectObject  ( pImg->hDC, pImg->hBitmapOld );
                    ::SelectPalette ( pImg->hDC, (HPALETTE)(ppalNew->m_hObject), FALSE );
                    ::RealizePalette( pImg->hDC );

                    int iLinesDone = SetDIBits( pImg->hDC, pImg->hBitmap, 0,
                                                pImg->cyHeight,
                                                FindDIBBits( lpDib ),
                                                lpDibInfo, DIB_PAL_COLORS );
                    if (iLinesDone != pImg->cyHeight)
                        theApp.SetGdiEmergency();

                    ::SelectObject( pImg->hDC, pImg->hBitmap );

                    if (pImg->m_pPalette)
                        delete pImg->m_pPalette;

                     pImg->m_pPalette = ppalNew;
                    theApp.m_pPalette = ppalNew;

                    ppalNew = NULL;

                    pRubberImg = NULL;

                    SetupRubber( pImg );

                    InvalImgRect( pImg, NULL );

                    for (index = 0; index < iColors; index++)
                        pColors[index] |= 0x02000000;
                    }
                }
            }
        else
            theApp.SetMemoryEmergency();

        if (ppalNew)
            delete ppalNew;
        }

    for (index = 0; index < m_nColorCount && index < iColors; index++)
        SetColor( index, pColors[index] );

    if (pColors)
        delete [] ((BYTE*)pColors);

    InvalColorWnd();
    }

/***************************************************************************/

void CColors::CmdSaveColors()
    {
    DWORD lFlags =  OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    #ifndef _DEBUG
    lFlags |= OFN_EXPLORER  ;
    #endif

        CString strFileTypes;
        strFileTypes.LoadString(IDS_PAL_FILETYPES);

        CString strDefName;
        strDefName.LoadString(IDS_PAL_UNTITLED);

    CFileDialog dlgFile( FALSE, TEXT("pal"), strDefName, lFlags, strFileTypes);

    dlgFile.m_ofn.lpstrDefExt = TEXT("pal");
    CString dlgtitle;
    dlgtitle.LoadString(IDS_SAVE_PALETTE_COLORS);
    dlgFile.m_ofn.lpstrTitle  = dlgtitle;
    dlgFile.m_ofn.Flags      &= ~OFN_SHOWHELP;  // Get rid of Help flag

    if (dlgFile.DoModal() != IDOK)
        return;

//  GetParent()->UpdateWindow(); // to erase the dialog box while we save...

    CFile           file;
    CFileException  ex;

    theApp.SetFileError( IDS_ERROR_OPEN, CFileException::none, dlgFile.GetPathName() );

    if (! file.Open( dlgFile.GetPathName(),
                     CFile::modeCreate | CFile::modeWrite | CFile::typeBinary,
                     &ex ))
    {
       theApp.SetFileError( IDS_ERROR_OPEN, ex.m_cause );
       return;
    }

    LOGPALETTE LogPal;

    LogPal.palVersion    = 0x300;
    LogPal.palNumEntries = GetColorCount();

    DWORD dwDataSize = sizeof( LogPal )
                     + (LogPal.palNumEntries - 1) * sizeof( COLORREF );
    TRY
        {
        DWORD dwRiff = dwDataSize + 12;

        file.Write( "RIFF", 4 );
        file.Write( &dwRiff, sizeof( DWORD ) );
        file.Write( "PAL data", 8 );

        file.Write( &dwDataSize, sizeof( DWORD ) );
        file.Write( &LogPal, sizeof( LogPal ) - sizeof( COLORREF ) );
        file.Write( (m_bMono? m_monoColors: m_colors),
                         LogPal.palNumEntries * sizeof( COLORREF ) );
        }
    CATCH( CFileException, pex )
        {
        theApp.SetFileError( IDS_ERROR_EXPORT, pex->m_cause );
        }
    END_CATCH
    }

/***************************************************************************/
#endif // unused code

void CColors::ResetColors(int nColors)
    {

    COLORREF *pColors;
    m_nColorCount = (int)min (nColors, sizeof(colorColorsDef) / sizeof(COLORREF));
    if (m_nColorCount == 16)
    {
       pColors = colorColors16;
    }
    else
    {
       pColors = colorColorsDef;
    }

    if (theApp.m_bPaletted)
        {
        int iRed;
        int iGreen;
        int iBlue;

        for (int i = 0; i < m_nColorCount; i++)
            {
            iRed   = GetRValue( pColors[i] );
            iGreen = GetGValue( pColors[i] );
            iBlue  = GetBValue( pColors[i] );

            m_colors[i] = PALETTERGB( iRed, iGreen, iBlue );
            }
        }
     else
        memcpy( m_colors,    pColors, m_nColorCount * sizeof(COLORREF) );
    memcpy( m_monoColors,    bwColorsDef, sizeof(    bwColorsDef ) );

    InvalColorWnd();
    if (g_pImgColorsWnd && IsWindow(g_pImgColorsWnd->m_hWnd))
       g_pImgColorsWnd->UpdateWindow();
    SetDrawColor (  0 ); // position  0 in color palette is black
    SetEraseColor( m_nColorCount==16?8:14 ); // white
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\cmpmsg.cpp ===
#include "stdafx.h"

#include <stdarg.h>

#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "cmpmsg.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

//
//
// CmpCenterParent retrieves a window to which a modal dialog should
// be centered (relative center).
//
// NOTE: The return value may be temporary!
//
CWnd* CmpCenterParent()
    {
    CWnd* pPopupWnd = AfxGetMainWnd();;

    ASSERT(pPopupWnd != NULL);

    if (pPopupWnd->IsKindOf(RUNTIME_CLASS(CMiniFrmWnd)))
        {
        // don't center relative to mini-frame windows
        CWnd* pParentWnd = pPopupWnd->GetParent();

        // instead use parent or main window...
        if (pParentWnd != NULL)
            pPopupWnd = pParentWnd;
        else
            pPopupWnd = theApp.m_pMainWnd;
        }

    return pPopupWnd;
    }

//
// composer message box, same interface as windows, but you give
// string id's not strings
//
// example: CmpMessageBox( IDS_OUTOFMEMORY, IDS_ERROR, MB_OK );
//
int CmpMessageBox(  WORD    wTextStringID,      // string id of text
                    WORD    wCaptionID,         // string id of caption
                    UINT    nType )             // same as message box
    {
    TCHAR FAR*   lpText;
    TCHAR FAR*   lpCaption;
    CString     sText, sCaption;

    if( wCaptionID == CMPNOSTRING )
        lpCaption = NULL;
    else
        {
        VERIFY( sCaption.LoadString( wCaptionID ) );

        lpCaption = (TCHAR FAR*)(const TCHAR *)sCaption;
        }

    if( wTextStringID == CMPNOSTRING )
        lpText = TEXT("");
    else
        {
        VERIFY( sText.LoadString( wTextStringID ) );

        lpText = (TCHAR FAR*)(const TCHAR *)sText;
        }

    CWnd *pcWnd = AfxGetMainWnd();

    if (pcWnd != NULL)
        {
        return  pcWnd->MessageBox(lpText, lpCaption, nType | MB_TASKMODAL);
        }
    else
        {
        return  ::MessageBox(NULL, lpText, lpCaption,nType | MB_TASKMODAL);
        }
    }

int CmpMessageBoxString( CString&   s,
                         WORD       wCaptionID,
                         UINT       nType )
    {
    TCHAR FAR*   lpCaption;
    CString     sText, sCaption;

    if( wCaptionID == CMPNOSTRING )
        lpCaption = NULL;
    else
        {
        VERIFY( sCaption.LoadString( wCaptionID ) );

        lpCaption = (TCHAR FAR*)(const TCHAR *)sCaption;
        }

    CWnd *pcWnd = AfxGetMainWnd();

    if (pcWnd != NULL)
        {
        return  pcWnd->MessageBox((const TCHAR *)s, lpCaption,nType | MB_TASKMODAL);
        }
    else
        {
        return  ::MessageBox(NULL, (const TCHAR *)s, lpCaption,nType | MB_TASKMODAL);
        }
    }

int CmpMessageBox2(  WORD    wTextStringID,
                     WORD    wCaptionID,
                     UINT    nType,
                     LPCTSTR szParam1,
                     LPCTSTR szParam2 )
    {
    TCHAR FAR*   lpText;
    TCHAR FAR*   lpCaption;
    CString     sText, sCaption;

    if( wCaptionID == CMPNOSTRING )
        lpCaption = NULL;
    else
        {
        VERIFY( sCaption.LoadString( wCaptionID ) );

        lpCaption = (TCHAR FAR*)(const TCHAR *)sCaption;
        }

    if( wTextStringID == CMPNOSTRING )
        lpText = TEXT("");
    else
        {
        AfxFormatString2( sText, wTextStringID, szParam1, szParam2);

        lpText = (TCHAR FAR*)(const TCHAR *)sText;
        }

    CWnd *pcWnd = AfxGetMainWnd();

    if (pcWnd != NULL)
        {
        return  pcWnd->MessageBox(lpText, lpCaption, nType | MB_TASKMODAL);
        }
    else
        {
        return  ::MessageBox(NULL, lpText, lpCaption,nType | MB_TASKMODAL);
        }
    }

//
// composer message box, combines wsprintf, you continue to
// use string ids
//
// example:
//
// CmpMessageBoxPrintf( IDS_CANTOPEN, IDS_ERROR, MB_OK, lpszFileName );
//

#define nLocalBuf 512

extern "C" int CDECL
    CmpMessageBoxPrintf(WORD    wTextStringID,  // string id of text (format)
                        WORD    wCaptionID,     // string id of caption
                        UINT    nType,          // same as message box
                        ... )                   // wsprintf arguments
    {
    TCHAR FAR*   lpText;
    TCHAR FAR*   lpCaption;
    CString     sText, sCaption;
    int         nBuf;
    TCHAR        szBuffer[nLocalBuf];

    va_list args;
    va_start( args, nType );

    if( wCaptionID == CMPNOSTRING )
        lpCaption = NULL;
    else
        {
        VERIFY( sCaption.LoadString( wCaptionID ) );

        lpCaption = (TCHAR FAR*)(const TCHAR *)sCaption;
        }

    if( wTextStringID == CMPNOSTRING )
        lpText = TEXT("");
    else
        {
        VERIFY( sText.LoadString( wTextStringID ) );

        lpText = (TCHAR FAR*)(const TCHAR *)sText;
        }

    nBuf = wvsprintf( szBuffer, lpText, args );

    ASSERT( nBuf < nLocalBuf );
    CWnd *pcWnd = AfxGetMainWnd();

    if (pcWnd != NULL)
        {
        return  pcWnd->MessageBox(szBuffer, lpCaption,nType | MB_TASKMODAL);
        }
    else
        {
        return  ::MessageBox(NULL, szBuffer, lpCaption,nType | MB_TASKMODAL);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\cmpmsg.h ===
//////////////////////////////////////////////////////////////////////////
//
//                                CMPMSG.H
//
//  Owner:     HenryB
//  Created:   Dec 9, 1991
//  Revision:
//
//////////////////////////////////////////////////////////////////////////

//
// Composer Message Box routines
//

#define CMPNOSTRING     (WORD)(-1)              // empty/no string

// CmpCenterParent retrieves a window to which a modal dialog should
// be centered (relative center).
//
// NOTE: The return value may be temporary!
//
CWnd* CmpCenterParent();

//
// composer message box, same interface as windows, but you give
// string id's not strings
//
// example: CmpMessageBox( IDS_OUTOFMEMORY, IDS_ERROR, MB_OK );
//
int CmpMessageBox(  WORD    wTextStringID,      // string id of text
                    WORD    wCaptionID,         // string id of caption
                    UINT    nType );            // same as message box

//
// composer message box wrapper for parameterized strings
//
// example: CmpMessageBox2( IDS_NOCONVERT, IDS_ERROR, MB_OK, lpszFrom, lpszInto );
//
int CmpMessageBox2(  WORD    wTextStringID,     // string id of text
                     WORD    wCaptionID,        // string id of caption
                     UINT    nType,             // same as message box
                     LPCTSTR szParam1,           // string for %1 param
                     LPCTSTR szParam2 );         // string for %2 param

//
// composer message box, combines wsprintf, you continue to
// use string ids
//
// example:
//
// CmpMessageBoxPrintf( IDS_CANTOPEN, IDS_ERROR, MB_OK, lpszFileName );
//

extern "C" int CDECL
    CmpMessageBoxPrintf(WORD    wTextStrinID,   // string id of text (format)
                        WORD    wCaptionID,     // string id of caption
                        UINT    nType,          // same as message box
                        ... );                  // wsprintf arguments


int CmpMessageBoxString( CString&   s,
                         WORD       wCaptionID,
                         UINT       nType );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\ferr.h ===
// File Error Identifiers
//
// When adding error ids here, be sure to add an entry in the mpidserr
// table in mytlab.cpp to indicate what string to display to the user!

#define ferrFirst           1000

#define ferrIllformedGroup      1000
#define ferrReadFailed          1001
#define ferrIllformedFile       1002
#define ferrCantProcNewExeHdr   1003
#define ferrCantProcOldExeHdr   1004
#define ferrBadMagicNewExe      1005
#define ferrBadMagicOldExe      1006
#define ferrNotWindowsExe       1007
#define ferrExeWinVer3          1008
#define ferrNotValidRc          1009
#define ferrNotValidExe         1010
#define ferrNotValidRes         1011
#define ferrNotValidBmp         1012
#define ferrNotValidIco         1013
#define ferrNotValidCur         1014
#define ferrRcInvalidExt        1015
#define ferrFileAlreadyOpen     1016
#define ferrExeTooLarge         1017
#define ferrCantCopyOldToNew    1018
#define ferrReadLoad            1019
#define ferrExeAlloc            1020
#define ferrExeInUse            1021
#define ferrExeEmpty            1022
#define ferrGroup               1023
#define ferrResSave             1024
#define ferrSaveOverOpen        1025
#define ferrSaveOverReadOnly    1026
#define ferrCantDetermineType   1027
#define ferrSameName            1028
#define ferrSaveAborted         1029
#define ferrLooksLikeNtRes      1030
#define ferrCantSaveReadOnly    1031
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\docking.cpp ===
// docking.cpp : implementation of the CDocking class
//

#include "stdafx.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "imgwell.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "docking.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CDocking, CObject )

#include "memtrace.h"

/***************************************************************************/
// CDocking implementation

CDocking::CDocking()
    {
    m_bStarted   = FALSE;
    m_bDocking   = FALSE;
    m_iDockingX  = ::GetSystemMetrics( SM_CXICON );
    m_iDockingY  = ::GetSystemMetrics( SM_CYICON );
    m_iDockingX += m_iDockingX / 2;
    m_iDockingY += m_iDockingY / 2;
    }

/***************************************************************************/

BOOL CDocking::Create( CPoint ptDrop, CRect& rectCurrent, BOOL bDocked, CPBView::DOCKERS tool )
    {
    ASSERT( ! m_bStarted );

    m_Tool     = tool;
    m_bDocked  = bDocked;
    m_ptLast   = ptDrop;
    m_bDocking = ! bDocked;

    CRect rectTool;
    CRect rect = rectCurrent;
    CSize size = rectCurrent.Size();

    if (bDocked)
        {
        switch (tool)
            {
            case CPBView::toolbox:
            case CPBView::colorbox:
                rect.InflateRect( theApp.m_cxBorder, theApp.m_cyBorder );
                break;


            }

        rect.bottom += theApp.m_cyCaption;
        m_rectDocked = rectCurrent;
        m_rectFree   = rect;
        }
    else
        {
        switch (tool)
            {
            case CPBView::toolbox:
                g_pImgToolWnd->GetWindowRect( &rectTool );

                rect.right  = rect.left + rectTool.Width();
                rect.bottom = rect.top  + rectTool.Height();
                break;

            case CPBView::colorbox:
                g_pImgColorsWnd->GetWindowRect( &rectTool );

                rect.right  = rect.left + rectTool.Width();
                rect.bottom = rect.top  + rectTool.Height();
                break;

            }
        m_rectDocked = rect;
        m_rectFree   = rectCurrent;
        }

    CPBView* pView = (CPBView*)(((CFrameWnd*)AfxGetMainWnd())->GetActiveView());

    ASSERT( pView != NULL );

    if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        {
        m_ptDocking = pView->GetDockedPos( tool, size );
        m_bStarted  = DrawFocusRect();

        m_rectDockingPort.SetRect( m_ptDocking.x - m_iDockingX,
                                   m_ptDocking.y - m_iDockingY,
                                   m_ptDocking.x + m_iDockingX,
                                   m_ptDocking.y + m_iDockingY );
        }
    return m_bStarted;
    }

/***************************************************************************/

BOOL CDocking::Move( CPoint ptNew, CRect& rectFrame )
    {
    Move( ptNew );

    rectFrame = m_bDocked? m_rectDocked: m_rectFree;

    return m_bDocked;
    }

/***************************************************************************/

void CDocking::Move( CPoint ptNew )
    {
    ASSERT( m_bStarted );

    if (DrawFocusRect())
        {
        CPoint pt = ptNew - m_ptLast;

        m_rectDocked.OffsetRect( pt );
        m_rectFree.OffsetRect( pt );

        pt = m_bDocked? m_rectDocked.TopLeft(): m_rectFree.TopLeft();

        m_bDocked = m_rectDockingPort.PtInRect( pt );

        m_ptLast = ptNew;

        DrawFocusRect();
        }
    }

/***************************************************************************/

BOOL CDocking::Clear( CRect* prectLast )
    {
    ASSERT( m_bStarted );

    DrawFocusRect();
    m_bStarted = FALSE;

    if (prectLast)
       *prectLast = m_bDocked? m_rectDocked: m_rectFree;

    if (!m_bDocked)
        {
        CPBView* pView = (CPBView*)(((CFrameWnd*)AfxGetMainWnd())->GetActiveView());

        if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
            pView->SetFloatPos( m_Tool, m_rectFree );
        }

    return m_bDocked;
    }

/***************************************************************************/

BOOL CDocking::DrawFocusRect()
    {
    if (m_bDocking)
        return TRUE;

    BOOL bReturn = FALSE;

    HDC hdc = ::GetDC( NULL );

    if (hdc)
        {
        ::DrawFocusRect( hdc, (m_bDocked? &m_rectDocked: &m_rectFree) );
        ::ReleaseDC( NULL, hdc );

        bReturn = TRUE;
        }

    return bReturn;
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\fixhelp.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

extern BOOL g_fDisableStandardHelp ;

extern HHOOK g_HelpFixHook ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc);

void SetHelpFixHook(void) ;

void RemoveHelpFixHook(void) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\hlpcntxt.h ===
// The following identifiers are used to invoke help for
// particular controls or groups of controls in MSPAINT

// Help Contexts for "Image | Attributes..." dialog
#define IDH_PAINT_IMAGE_ATTR_WIDTH                              30000
#define IDH_PAINT_IMAGE_ATTR_HEIGHT                             30010
// #define      IDH_PAINT_IMAGE_ATTR_UNITS_GROUP                30020
#define IDH_PAINT_IMAGE_ATTR_UNITS_INCHES               30021
#define IDH_PAINT_IMAGE_ATTR_UNITS_CM                   30022
#define IDH_PAINT_IMAGE_ATTR_UNITS_PELS                 30023
// #define      IDH_PAINT_IMAGE_ATTR_COLORS_GROUP               30030
#define IDH_PAINT_IMAGE_ATTR_COLORS_BW                  30031
#define IDH_PAINT_IMAGE_ATTR_COLORS_COLORS              30032
#define IDH_PAINT_IMAGE_ATTR_DEFAULT                    30040
#define IDH_PAINT_IMAGE_ATTR_LASTSAVED                  30050
#define IDH_PAINT_IMAGE_ATTR_SIZE                       30051
#define IDH_PAINT_IMAGE_ATTR_USE_TRANSP                 30052
#define IDH_PAINT_IMAGE_ATTR_SEL_COLOR                  30053
#define IDH_PAINT_IMAGE_ATTR_PREVIEW                    30054

// Help Contexts for "Image | Flip and Rotate" dialog
// #define IDH_PAINT_IMAGE_FLIP_GROUP                           30100
#define IDH_PAINT_IMAGE_FLIP_HORIZ                              30101
#define IDH_PAINT_IMAGE_FLIP_VERT                               30102
#define IDH_PAINT_IMAGE_FLIP_ROTATE                             30103

// Help Contexts for "Image | Stretch and Skew" dialog
// #define IDH_PAINT_IMAGE_STRETCH_GROUP                        30200
#define IDH_PAINT_IMAGE_STRETCH_HORIZ                           30201
#define IDH_PAINT_IMAGE_STRETCH_VERT                    30202
// #define IDH_PAINT_IMAGE_SKEW_GROUP                           30210
#define IDH_PAINT_IMAGE_SKEW_HOR                                30211
#define IDH_PAINT_IMAGE_SKEW_VERT                               30212

// Help Contexts for "View | Zoom" dialog
#define IDH_PAINT_ZOOM_CURRENT                                  30300
#define IDH_PAINT_ZOOM_SET_GROUP                                30310

// Help Contexts for common things
#define IDH_COMM_GROUPBOX                                       30400
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\fixhelp.cpp ===
// fixhelp.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "fixhelp.h"

BOOL g_fDisableStandardHelp = FALSE ;

HHOOK g_HelpFixHook = (HHOOK) 0 ;

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam) ;

class CWordPadCWnd : public CWnd
{
public:

	LRESULT CallDWP(UINT nMsg, WPARAM wParam, LPARAM lParam)
   {
	    return DefWindowProc(nMsg, wParam, lParam) ;
   }
} ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc)
{
    //
    // Subclass the main window proc if we are supposed to
	// and if MFC has alread subclassed it
    //

    if (fFixWndProc)
    {
        if (GetWindowLongPtr(pWnd->m_hWnd, GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
	     {
              SetWindowLongPtr(pWnd->m_hWnd, GWLP_WNDPROC,
                               (LONG_PTR)HelpFixDialogProc);
	     }
    }

	//
    // Search all child windows.  If their window proc
    // is AfxWndProc, then subclass with our window proc
	//

    CWnd* pWndChild = pWnd->GetWindow(GW_CHILD);
    while(pWndChild != NULL)
    {
        if (GetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
        {
            SetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC,
                              (LONG_PTR)HelpFixControlProc);
        }
        pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
    }
}

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		//
        // bypass MFC's handler, message will be sent to
		// parent of the control
		//

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		CWordPadCWnd* pWnd = (CWordPadCWnd *) CWnd::FromHandlePermanent(hwnd) ;

		//
        // bypass MFC's handler, message will be sent to window proc for
		// the dialog box
		//

		if (NULL != pWnd)
		{
            return pWnd->CallDWP(uMsg, wParam, lParam) ;
		}
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}


void SetHelpFixHook(void)
{
   g_HelpFixHook = ::SetWindowsHookEx(
                        WH_CALLWNDPROC,
                        (HOOKPROC) HelpFixHook,
                        NULL,
                        ::GetCurrentThreadId());
}

void RemoveHelpFixHook(void)
{
    ::UnhookWindowsHookEx(g_HelpFixHook) ;

    g_HelpFixHook = (HHOOK) 0 ;
}

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam)
{
    if (code < 0)
    {
        return ::CallNextHookEx(
                   g_HelpFixHook,
                   code,
                   wParam,
                   lParam) ;
    }

    CWPSTRUCT *pcwps = (CWPSTRUCT *) lParam ;

    if (pcwps->message == WM_INITDIALOG)
    {
        CWnd *pWnd = CWnd::FromHandlePermanent(pcwps->hwnd) ;

        if (pWnd != NULL)
        {
            FixHelp(pWnd, TRUE) ;
        }
    }

    return ::CallNextHookEx(
                g_HelpFixHook,
                code,
                wParam,
                lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\filtapi.h ===
/*----------------------------------------------------------------------------
	%%File: FILTAPI.H
	%%Unit: FILTER32
	%%Contact: rlittle@microsoft.com

	This header is distributed as part of the 32 bit Filter SDK.
	
	Changes to this header file should be sent to rlittle@microsoft.com
	or doneill@microsoft.com

	Revision History: (Current=1.03)

	1/12/96 Created
	1/23/96 Renamed grt values and synchronized with grfSupport values
	1/24/96 Extra SetFilterPref arguments (smueller)
	1/25/96 Correct packing (rlittle)
----------------------------------------------------------------------------*/

#ifndef FILTAPI_H
#define FILTAPI_H

// Definitions

#ifdef MAC
#include "macos\types.h"
#include "macos\files.h"

// Mac type equivalents

typedef Handle HANDLE;
typedef Handle HMETAFILE;
typedef Handle HENHMETAFILE;
typedef Rect RECT;
typedef long HDC;	// unused
typedef short FH;
#endif // MAC

#ifdef WIN16
typedef HANDLE HENHMETAFILE;	// win16 doesn't support enhanced metafiles
typedef HFILE FH;
#endif // WIN16

#ifdef WIN32
typedef HANDLE FH;
#endif // WIN32

// useful macros (mainly for Mac; windows.h defines most of these, so this
// will just be a failsafe.

typedef unsigned short ushort;
typedef unsigned long ulong;
typedef unsigned char uchar;
typedef int BOOL;

// these are the graphics definitions for Version 2 & Version 3

#ifdef WIN16
#define cchMaxGrName	124	   // max file path length for graphics filter
#else // !WIN16
#define cchMaxGrName    260	   // max file path length for graphics filter
#endif

#define cchMaxGrExt       4	   // chars + end-of-string mark ('\0')

#pragma pack(2)
typedef struct _FILESPEC {
	union 
		{
		struct 
			{
			ushort slippery: 1;	// True if file may disappear.
			ushort write : 1;	// True if open for write.
			ushort unnamed: 1;	// True if unnamed.
			ushort linked : 1;	// Linked to an FS FCB.
			ushort mark : 1;	// Generic mark bit.
			ushort unused : 11;
			};
		ushort wFlags;
		};
	union
		{
		char rgchExt[cchMaxGrExt];	// file extension, not used on MacPPC
		FH hfEmbed;					// embedded file handle
		};
		
	ushort wUnused;	
#ifdef MACPPC
	FSSpec fsSpec;
#else
	char szName[cchMaxGrName];		// fully qualified path
#endif // MACPPC
	ulong dcbFile;					// file position in hfEmbed
	
	/*** END VERSION 2 FIELDS
	 *** 
	 *** Fields above this point are IMMUTABLE.  They are guaranteed
	 *** to be in the above format for backwards compatibility with
	 *** existing Version 2 filters.
	 ***/
	 
	ulong dcbFileHigh;
	} FILESPEC;

// NOTE:  the client application will arbitrarily decide which type to
// send if the filter returns multiple support types

#define GrfSupportFromGrt(grt)		(ulong)(1 << ((grt) + 15))
#define grfSupportEMF	GrfSupportFromGrt(grtEMF)	// 0x00010000
#define grfSupportWMF	GrfSupportFromGrt(grtWMF)	// 0x00020000
#define grfSupportPNG	GrfSupportFromGrt(grtPNG)	// 0x00040000
#define grfSupportPICT	GrfSupportFromGrt(grtPICT)	// 0x00080000
#define grfSupportJFIF	GrfSupportFromGrt(grtJFIF)	// 0x00100000

// NOTE:  grfImport/grfExport are not mutually exclusive.  They can be
// OR'ed together for a filter that does both.  Values 2 and 4 cannot be
// used as they would be indistinguishable from version 2 return values.

#define grfImport		0x00000008
#define grfExport		0x00000010


// Version 2 support:

typedef struct _GRPI {	// GRaPhic Interface
	HMETAFILE hmf;	// metafile
	RECT   bbox;	// tightly bounds the image (in metafile units)
	ushort inch;	// metafile units per inch
} GRPI;


// Version 3 support:

#define grtEMF			0x01
#define grtWMF			0x02
#define grtPNG			0x03
#define grtPICT			0x04
#define grtJFIF			0x05

// NOTE: 
// if fPointer is fTrue, then the information is represented as
// a pointer to data rather than a handle to data.  This is not
// valid for HMETAFILE and HENHMETAFILE (as there is no pointer
// equivalent)

typedef struct _GRPIX { 	// GRaPhic Interface Extended
	ushort cbGrpix;	// size of this structure
	uchar grt;		// GRaphic Type
	ulong cbData;	// number of bytes in the graphic
	BOOL fPointer;
	union
		{
		HMETAFILE hmf;		// metafile 
		HENHMETAFILE hemf;	// enhanced metafile
		HANDLE hPng;		// handle to PNG bits
		void *pPng;			// pointer to PNG bits	(fPointer = fTrue)
		HANDLE hPict;		// handle to MacPict
		void *pPict;		// pointer to MacPict	(fPointer = fTrue)
		HANDLE hJpeg;		// handle to JPEG/JFIF
		void *pJpeg;		// pointer to JPEG/JFIF (fPointer = fTrue)
		};
	RECT bbox;			// tightly bounds the image (in metafile units)
	ulong inch;			// metafile units per inch
} GRPIX;


#ifndef WIN16

// Update the percent complete (if return value is fTrue, then
// abort the conversion) lPct is the percent
// pfnPctComplete MUST be called frequently (every 2 or 3 percent)

typedef BOOL (*PFN_PCTCOMPLETE)(long lPct, void *pvData);

#if defined(RISC)	// mips,alpha,ibm ppc,mac ppc
#define FILTAPI _cdecl
#else
#define FILTAPI PASCAL
#endif


// NOTE:  For version 3 handling, pgrpi should be cast as
//		  pgrpix = (GRPIX *)pgrpi

typedef int  (FILTAPI *PFNGetFilterInfo)(short, char *, HANDLE *, ulong);
typedef void (FILTAPI *PFNGetFilterPref)(HANDLE, HANDLE, HANDLE, ushort);
typedef int  (FILTAPI *PFNExportGr)(FILESPEC *, GRPI *, HANDLE);
typedef int  (FILTAPI *PFNExportEmbeddedGr)(FILESPEC *, GRPI *, HANDLE, ulong);
typedef int  (FILTAPI *PFNImportGr)(HDC, FILESPEC *, GRPI *, HANDLE);
typedef int  (FILTAPI *PFNImportEmbeddedGr)(HDC, FILESPEC *, GRPI *, HANDLE, ulong, char *);
typedef int  (FILTAPI *PFNRegisterPercentCallback)(HANDLE, PFN_PCTCOMPLETE, void *);
typedef int  (FILTAPI *PFNSetFilterPref)(HANDLE, char *, void *, ulong, ulong);

int  FILTAPI GetFilterInfo(short wVersion, char *pIni, 
						   HANDLE *phPrefMem, ulong lFlags);
						   
void FILTAPI GetFilterPref(HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, 
						   ushort wFlags);
						   
int  FILTAPI ExportGr(FILESPEC *pFileSpec, GRPI *pgrpi, HANDLE hPrefMem);

int  FILTAPI ExportEmbeddedGr(FILESPEC *pFileSpec, GRPI *pgrpi, HANDLE hPrefMem, ulong *pdwSize);

int  FILTAPI ImportGr(HDC hdcPrint, FILESPEC *pFileSpec, GRPI *pgrpi, 
					  HANDLE hPrefMem);
					  
int  FILTAPI ImportEmbeddedGr(HDC hdcPrint, FILESPEC *pFileSpec, GRPI *pgrpi, 
							  HANDLE hPrefMem, ulong ulSize, char *szMetaFileName);

int  FILTAPI RegisterPercentCallback(HANDLE hPrefMem, PFN_PCTCOMPLETE pfnPctComplete, void *pvData);

int  FILTAPI SetFilterPref(HANDLE hPrefMem, char *szOption, void *pvValue, ulong dwSize, ulong dwType);

#endif // WIN16


// Definitions of ordinal values for entry points
// backwards compatibility only
#define ordGetFilterInfo ((DWORD)1)
#define ordImportGr ((DWORD)2)


// SetFilterPref data types
// these exactly parallel a subset of Win32 registry value data types
#if !defined(REG_NONE) || !defined(REG_SZ) || !defined(REG_BINARY) || !defined(REG_DWORD)
#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // '\0' terminated string
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#endif


// ERROR RETURN VALUES
#define IE_NO_ERROR				0
#define IE_INTERNAL_ERROR		(-1)

#define IE_BASE				0x14B4
#define IE(err)				(IE_BASE + err)

// IMPORT/EXPORT ERRORS
#define IE_NOT_MY_FILE		IE(0x0001)	// generic not my file error
#define IE_TOO_BIG			IE(0x0002)	// bitmap or pict too big error
#define IE_DUMB_BITMAP		IE(0x0003)	// bitmap all white
#define IE_BAD_VCHAR		IE(0x0004)	// bad vchar in ImportString
#define IE_BAD_TOKEN		IE(0x0005)	// illegal wp token
#define IE_NO_VERIFY		IE(0x0006)	// failed to verify imported story
#define IE_UNKNOWN_TYPE		IE(0x0007)	// unknown file type
#define IE_NOT_WP_FILE		IE(0x0008)	// not a wp file
#define IE_BAD_FILE_DATA	IE(0x0009)	// current file data is bad
#define IE_IMPORT_ABORT		IE(0x000A)	// import abort alert
#define IE_MEM_FULL			IE(0x000B)	// ran out of memory during import
#define IE_MSNG_FONTS		IE(0x000C)	// system font not found
#define IE_META_TOO_BIG		IE(0x000D)	// metafile too big
#define IE_MEM_FAIL			IE(0x000F)	// couldn't lock memory during import
#define IE_NO_FILTER		IE(0x0012)	// expected filter not found

#define IE_UNSUPP_COMPR		IE(0x0029)	// unsupported compress style
#define IE_UNSUPP_VERSION	IE(0x002A)	// unsupported file version
#define IE_UNSUPP_COLOR		IE(0x002B)	// unsupported color style

#define IE_ERROR_NOMSG		IE(0x0037)	// dialog box cancel
#define IE_FILE_NOT_FOUND	IE(0x003C)	// file not found
#define IE_BUG				IE(0x0051)
#define IE_BAD_METAFILE		IE(0x0053)	// inconsistent metafile data
#define IE_BAD_METAFILE2	0xCCCC		// inconsistent metafile data

#define IE_BAD_PARAM		IE(0x0100)	// bad parameter passed by client
#define IE_UNSUPP_FORMAT	IE(0x0101)	// cannot provide/accept format
#define FA_DISK_ERROR		7015


// values for WPG-specific PRF fields (for GetFilterPref)
// backwards compatibility only
#define bBGIni			0	// do what the mstxtcnv.ini file says
#define bBGDiscard		1	// discard the background
#define bBGKeep			2	// keep the background

#define bCCNone			0
#define bCCOutline		1	// convert black to black, all others to white
#define bCCBlackWhite	2	// convert white to white, all others to black
#define bCCInvert		3	// invert all colours, except black and white
#define bCCOutline6		4	// true outline
#define bCCSilhouette	5	// everything to black
#define bCCInvert6		6	// invert all colours, including black<->white

#define bMRNone			0
#define bMRHorizontal	1	// flip image horizontally, across y-axis
#define bMRVertical		2	// flip image vertically, across x-axis

typedef struct _PRF
	{
	uchar fSilent;
	uchar bBackground;
	uchar bColorChange;
	uchar bMirror;	// formerly fMirror
	unsigned dgRotate;
	} PRF;
#pragma pack()

#endif // !FILTAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\global.h ===
// global.h
//

#ifndef __GLOBAL_H__
#define __GLOBAL_H__

// hard-coded colors to be used instead of COLOR_BTNFACE, _BTNTEXT, etc.
//  - hese are for access via MyGetSysColor() - and GetSysBrush()
#define CMP_COLOR_HILITE    25  // RGB(255, 255, 255)
#define CMP_COLOR_LTGRAY    26  // RGB(192, 192, 192) - instead of BtnFace
#define CMP_COLOR_DKGRAY    27  // RGB(128, 128, 128)
#define CMP_COLOR_BLACK     28  // RGB(0, 0, 0) - instead of frame

// - these are for when all you need is a RGB value)
#define CMP_RGB_HILITE      RGB(255, 255, 255)
#define CMP_RGB_LTGRAY      RGB(192, 192, 192)  // instead of BtnFace
#define CMP_RGB_DKGRAY      RGB(128, 128, 128)
#define CMP_RGB_BLACK       RGB(0, 0, 0)        // instead of frame

#define HID_BASE_BUTTON    0x00070000UL        // IDMB and IDMY

extern CBrush*  GetHalftoneBrush();
extern CBrush*  GetSysBrush(UINT nSysColor);
extern void     ResetSysBrushes();
extern COLORREF MyGetSysColor(UINT nSysColor);

// Remove the drive and directory from a file name...
//
CString StripPath(const TCHAR* szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
//
CString StripName(const TCHAR* szFilePath);

// Remove the name part of a file path.  Return just the drive and directory, and name.
//
CString StripExtension(const TCHAR* szFilePath);

// Get only the extension of a file path.
//
CString GetExtension(const TCHAR* szFilePath);

// Get the name of a file path.
//
CString GetName(const TCHAR* szFilePath);

// Return the path to szFilePath relative to szDirectory.  (E.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(const TCHAR* szFilePath, const TCHAR* szDirectory = NULL);

void PreTerminateList( CObList* pList );

#endif // __GLOBAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imageatt.cpp ===
// imageatt.cpp : implementation file
//

#include "stdafx.h"
#include "pbrush.h"
#include "imageatt.h"
#include "hlpcntxt.h"
#include "pbrusdoc.h"
#include "bmobject.h"
#include "imgsuprt.h" // for InvalColorWnd()
#include "image.h"
#ifndef UNICODE
#include <sys\stat.h>
#endif
#include <wchar.h>
#include <tchar.h>
#include <winnls.h>
#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

#define FIXED_FLOATPT_MULTDIV 1000
#define DECIMAL_POSITIONS 2

/************************* CImageAttr dialog *******************************/
/*

There are a few things to note about the way this object/dialog functions.
It  tries not to convert the currently displayed value unless it notices the
user has modified it.  In all other cases, it works with PIXELS, the value
passed in. If the user modified the width or height,  it does 1 conversion and
then works with pixels.

For the conversion to display the different unit values, it uses the saved
pixel value.

The reason for all of this is due to only n decimal place of accuracy in the
display

The member Vars m_lWidth  and m_lHeight are in the current units (store in
the member variable m_eUnitsCurrent).

The member Vars m_lWidthPixels and m_lHeightPixels are always in Pixels and
these are what are used to convert for the display when changing the units.
*/

CImageAttr::CImageAttr(CWnd* pParent /*=NULL*/)
           : CDialog(CImageAttr::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CImageAttr)
    m_cStringWidth  = TEXT("");
    m_cStringHeight = TEXT("");
        //}}AFX_DATA_INIT

    m_eUnitsCurrent = (eUNITS)theApp.m_iCurrentUnits;

    bEditFieldModified = FALSE;

    m_bMonochrome   = FALSE;

    m_ulHeightPixels = 0;
    m_ulWidthPixels  = 0;
    m_ulHeight       = 0;
    m_ulWidth        = 0;
    m_cXPelsPerMeter = 0;
    m_cYPelsPerMeter = 0;
    }

/***************************************************************************/

void CImageAttr::DoDataExchange(CDataExchange* pDX)
    {
    // saving must be done before the generic dodataexchange below.

    if (! pDX->m_bSaveAndValidate)  // saving to dialog
        {
        FixedFloatPtToString( m_cStringWidth,  m_ulWidth  );
        FixedFloatPtToString( m_cStringHeight, m_ulHeight );
        }

    CDialog::DoDataExchange( pDX );

    //{{AFX_DATA_MAP(CImageAttr)
    DDX_Text(pDX, IDC_WIDTH, m_cStringWidth);
    DDV_MaxChars(pDX, m_cStringWidth, 5);
    DDX_Text(pDX, IDC_HEIGHT, m_cStringHeight);
    DDV_MaxChars(pDX, m_cStringHeight, 5);
        //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate) // retrieving from dialog
        {
        m_ulWidth  = StringToFixedFloatPt( m_cStringWidth  );
        m_ulHeight = StringToFixedFloatPt( m_cStringHeight );
        }
    }

/***************************************************************************/

ULONG CImageAttr::StringToFixedFloatPt( CString& sString )
    {
    ULONG iInteger = 0;
    ULONG iDecimal = 0;

    TCHAR chDecimal[2] = TEXT("."); // default to period in case GetLocaleInfo
                           // messes up somehow
    GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, chDecimal, 2);
    if (! sString.IsEmpty())
        {
        int     iPos = sString.Find( chDecimal[0] );
        LPTSTR szTmp = sString.GetBuffer( 1 );

        iInteger = FIXED_FLOATPT_MULTDIV * Atoi( szTmp );

        if (iPos++ >= 0)
            {
            LPTSTR szDecimal = szTmp + iPos;

            if (lstrlen( szDecimal ) > DECIMAL_POSITIONS)
                szDecimal[DECIMAL_POSITIONS] = 0;

            iDecimal = Atoi( szDecimal ) * 10;

            for (int i = lstrlen( szDecimal ); i < DECIMAL_POSITIONS; ++i)
                iDecimal *= 10;
            }
        }

    return ( iInteger + iDecimal );
    }

/***************************************************************************/

void CImageAttr::FixedFloatPtToString( CString& sString, ULONG ulFixedFloatPt )
    {
    ULONG iInteger =  (ulFixedFloatPt + 5) / FIXED_FLOATPT_MULTDIV;
    ULONG iDecimal = ((ulFixedFloatPt + 5) % FIXED_FLOATPT_MULTDIV) / 10;

    TCHAR chDecimal[2] = TEXT("."); // default to period in case GetLocaleInfo
                           // messes up somehow
    GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, chDecimal, 2);
    LPTSTR psz = sString.GetBufferSetLength( 24 );

    if (iDecimal)
        wsprintf( psz, TEXT("%u%s%02u"), iInteger, chDecimal,iDecimal );
    else
        wsprintf( psz,    TEXT("%u"), iInteger );

    sString.ReleaseBuffer();
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CImageAttr, CDialog)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
    //{{AFX_MSG_MAP(CImageAttr)
    ON_BN_CLICKED(IDC_INCHES, OnInches)
    ON_BN_CLICKED(IDC_CENTIMETERS, OnCentimeters)
    ON_BN_CLICKED(IDC_PIXELS, OnPixels)
    ON_EN_CHANGE(IDC_HEIGHT, OnChangeHeight)
    ON_EN_CHANGE(IDC_WIDTH, OnChangeWidth)
    ON_BN_CLICKED(IDC_DEFAULT, OnDefault)
    ON_BN_CLICKED(IDC_USE_TRANS, OnUseTrans)
    ON_BN_CLICKED(IDC_SELECT_COLOR, OnSelectColor)
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/************************ CImageAttr message handlers **********************/

static DWORD ImageAttrHelpIds[] =
        {
        IDC_WIDTH_STATIC,       IDH_PAINT_IMAGE_ATTR_WIDTH,
        IDC_WIDTH,                      IDH_PAINT_IMAGE_ATTR_WIDTH,
        IDC_HEIGHT_STATIC,      IDH_PAINT_IMAGE_ATTR_HEIGHT,
        IDC_HEIGHT,                     IDH_PAINT_IMAGE_ATTR_HEIGHT,
        IDC_UNITS_GROUP,        IDH_COMM_GROUPBOX,
        IDC_INCHES,                     IDH_PAINT_IMAGE_ATTR_UNITS_INCHES,
        IDC_CENTIMETERS,        IDH_PAINT_IMAGE_ATTR_UNITS_CM,
        IDC_PIXELS,                     IDH_PAINT_IMAGE_ATTR_UNITS_PELS,
        IDC_COLORS_GROUP,       IDH_COMM_GROUPBOX,
        IDC_MONOCHROME,         IDH_PAINT_IMAGE_ATTR_COLORS_BW,
        IDC_COLORS,                     IDH_PAINT_IMAGE_ATTR_COLORS_COLORS,
        IDC_DEFAULT,            IDH_PAINT_IMAGE_ATTR_DEFAULT,
        IDC_FILEDATE_STATIC,    IDH_PAINT_IMAGE_ATTR_LASTSAVED,
        IDC_FILESIZE_STATIC,    IDH_PAINT_IMAGE_ATTR_SIZE,
        IDC_USE_TRANS,          IDH_PAINT_IMAGE_ATTR_USE_TRANSP,
        IDC_SELECT_COLOR,       IDH_PAINT_IMAGE_ATTR_SEL_COLOR,
        IDC_TRANS_PAINT,        IDH_PAINT_IMAGE_ATTR_PREVIEW,
        0, 0
        };

/***************************************************************************/

LONG
CImageAttr::OnHelp(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle), TEXT("mspaint.hlp"),
                  HELP_WM_HELP, (ULONG_PTR)(LPTSTR)ImageAttrHelpIds);
return lResult;
}

/***************************************************************************/

LONG
CImageAttr::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)wParam, TEXT("mspaint.hlp"),
                  HELP_CONTEXTMENU,(ULONG_PTR)(LPVOID)ImageAttrHelpIds);
return lResult;
}

/***************************************************************************/

void CImageAttr::PaintTransBox( COLORREF cr )
{
        CWnd * pWnd = GetDlgItem(IDC_TRANS_PAINT);
        CDC  * pDC  = pWnd->GetDC();

        RECT rect;
        pWnd->GetClientRect( &rect );

        CBrush newBrush( m_crTrans & 0xFFFFFF); // disregard palette-relative
        pDC->FillRect (&rect, &newBrush);
    //  CBrush * pOldBrush = pDC->SelectObject( &newBrush );
    //  pDC->Rectangle( &rect );
    //  DeleteObject( pDC->SelectObject( pOldBrush ) );

        pWnd->ReleaseDC( pDC );
}

/***************************************************************************/
#define MAX_SEP_LEN 6
#define MAX_INT_LEN 16
// convert a number into a string with commas in the right place
CString CImageAttr::ReformatSizeString(DWORD dwNumber)
        {

        NUMBERFMT nmf;
        CString strRet;
        TCHAR szSep[MAX_SEP_LEN];
        TCHAR szDec[MAX_SEP_LEN];
        CString sNumber;
        TCHAR szInt[MAX_INT_LEN];
        ZeroMemory (&nmf, sizeof(nmf));
        //
        // Fill in the NUMBERFMT with defaults for the user locale,
        // except for "fractional digits" being 0
        //
        GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_ILZERO,
                       szInt, MAX_INT_LEN);
        nmf.LeadingZero = _ttol (szInt);
        nmf.Grouping = 3;
        nmf.lpDecimalSep = (LPTSTR)szDec;
        nmf.lpThousandSep = (LPTSTR)szSep;
        GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,  nmf.lpDecimalSep,
                       MAX_SEP_LEN);
        GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_STHOUSAND,  nmf.lpThousandSep,
                       MAX_SEP_LEN);
        GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_INEGNUMBER,
                       szInt,MAX_INT_LEN);
        nmf.NegativeOrder = _ttol (szInt);

        _ltot(dwNumber, sNumber.GetBuffer(20), 10);
        sNumber.ReleaseBuffer();
        int nChar = GetNumberFormat (LOCALE_USER_DEFAULT, 0, sNumber,
                                     &nmf, (LPTSTR)NULL, 0);
        if (nChar)
        {
           GetNumberFormat (LOCALE_USER_DEFAULT, 0, sNumber,
                            &nmf, strRet.GetBuffer(nChar), nChar);
           strRet.ReleaseBuffer();
           return strRet;
        }
        return CString(TEXT("0"));
}

/***************************************************************************/

void CImageAttr::UpdateResolutionString()
{
    CString cstrResolution;

    if (m_cXPelsPerMeter == 0 || m_cYPelsPerMeter == 0)
    {
        VERIFY(cstrResolution.LoadString(IDS_RESOLUTION_NA));
    }
    else
    {
        CString cstrResolutionFormat;

        VERIFY(cstrResolutionFormat.LoadString(IDS_RESOLUTION));

        cstrResolution.Format(cstrResolutionFormat, 
            MulDiv(m_cXPelsPerMeter, 254, 10000), 
            MulDiv(m_cYPelsPerMeter, 254, 10000));
    }

    CWnd *pResolution = GetDlgItem(IDC_RESOLUTION_STATIC);

    pResolution->SetWindowText(cstrResolution);
}

/***************************************************************************/

BOOL CImageAttr::OnInitDialog()
{
    CDialog::OnInitDialog();
    CWnd * pFileDate = GetDlgItem(IDC_FILEDATE_STATIC);
    CWnd * pFileSize = GetDlgItem(IDC_FILESIZE_STATIC);
    CString cstrFileDate;
    CString cstrFileSize;

    if (((CPBApp *)AfxGetApp())->m_sCurFile.IsEmpty())
    {
        VERIFY(cstrFileDate.LoadString(IDS_FILEDATE_NA));
        VERIFY(cstrFileSize.LoadString(IDS_FILESIZE_NA));

        pFileDate->SetWindowText(cstrFileDate);
        pFileSize->SetWindowText(cstrFileSize);
    }
    else
    {
        DWORD dwSize = 0L;
        CString fn = ((CPBApp *)AfxGetApp())->m_sCurFile;
        HANDLE hFile;
        CString date;
        CString time;
        SYSTEMTIME sysTime;
        FILETIME   ftSaved;
        FILETIME   ftLocal;
        int dSize;
        //
        // Open a handle to the file, use GetFileTime to
        // get the FILETIME, convert to a SYSTEMTIME and
        // call GetDateFormat and GetTimeFormat
        //
        hFile = ::CreateFile (fn,GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,OPEN_EXISTING,
                            0,NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            // If your bitmap is bigger than 2GB, too bad.
            dwSize = ::GetFileSize (hFile, NULL);
            ::GetFileTime (hFile, NULL, NULL, &ftSaved);
            ::FileTimeToLocalFileTime (&ftSaved, &ftLocal);
            ::FileTimeToSystemTime (&ftLocal, &sysTime);
            dSize = ::GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &sysTime, NULL,
                                NULL, 0);
            ::GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &sysTime, NULL,
                        date.GetBuffer (dSize), dSize);
            dSize = ::GetTimeFormat (LOCALE_USER_DEFAULT, TIME_NOSECONDS, &sysTime, NULL,
                                  NULL, 0);
            ::GetTimeFormat (LOCALE_USER_DEFAULT, TIME_NOSECONDS, &sysTime, NULL,
                                  time.GetBuffer (dSize), dSize);
            date.ReleaseBuffer();
            time.ReleaseBuffer();

            VERIFY(cstrFileDate.LoadString(IDS_FILEDATE));
            VERIFY(cstrFileSize.LoadString(IDS_FILESIZE));
            TCHAR szFileDate[96];
            TCHAR szFileSize[64];

            // Display the date, followed by the time
            date+=TEXT(" ");
            date+=time;
            ::wsprintf( szFileDate, cstrFileDate, date );
            ::wsprintf( szFileSize, cstrFileSize, ReformatSizeString(dwSize) );
            ::CloseHandle (hFile);
            pFileDate->SetWindowText(szFileDate);
            pFileSize->SetWindowText(szFileSize);
        }
        else
        {
            VERIFY(cstrFileDate.LoadString(IDS_FILEDATE_NA));
            VERIFY(cstrFileSize.LoadString(IDS_FILESIZE_NA));
            pFileDate->SetWindowText(cstrFileDate);
            pFileSize->SetWindowText(cstrFileSize);
        }
    }

    UpdateResolutionString();

    int idButton = IDC_PIXELS;

    if (m_eUnitsCurrent != ePIXELS)
        idButton = (m_eUnitsCurrent == eINCHES)? IDC_INCHES: IDC_CENTIMETERS;

    CheckRadioButton( IDC_INCHES, IDC_PIXELS, idButton );
    CheckRadioButton( IDC_MONOCHROME, IDC_COLORS,
                      (m_bMonochrome? IDC_MONOCHROME: IDC_COLORS) );

    //
    // We enable the transparent color UI only if modifying a GIF
    //
    GetDlgItem (IDC_USE_TRANS )->EnableWindow (WiaImgFmt_GIF == theApp.m_guidFltTypeUsed );

    CheckDlgButton( IDC_USE_TRANS, g_bUseTrans);

    CWnd* pSelectColorButton = GetDlgItem(IDC_SELECT_COLOR);
    pSelectColorButton->EnableWindow(g_bUseTrans);

    m_crTrans = crTrans;

    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CImageAttr::OnOK()
    {
    ConvertWidthHeight();

    theApp.m_iCurrentUnits = m_eUnitsCurrent;
    m_bMonochrome = (GetCheckedRadioButton( IDC_MONOCHROME, IDC_COLORS )
                                         == IDC_MONOCHROME);
    if (g_bUseTrans = IsDlgButtonChecked( IDC_USE_TRANS ))
    {
       crTrans = m_crTrans;
    }
    InvalColorWnd();

    CDialog::OnOK();
    }

/***************************************************************************/

void CImageAttr::OnDefault()
    {
    int nWidth, nHeight;

    PBGetDefDims(nWidth, nHeight);

    SetWidthHeight( nWidth, nHeight, 0, 0 );
    }

/***************************************************************************/

void CImageAttr::SetWidthHeight(ULONG nWidthPixels, ULONG nHeightPixels, ULONG cXPelsPerMeter, ULONG cYPelsPerMeter)
    {
    m_ulWidthPixels  = nWidthPixels  * FIXED_FLOATPT_MULTDIV;
    m_ulHeightPixels = nHeightPixels * FIXED_FLOATPT_MULTDIV;
    m_cXPelsPerMeter = cXPelsPerMeter;
    m_cYPelsPerMeter = cYPelsPerMeter;

    if (m_cXPelsPerMeter == 0)
        {
        m_cXPelsPerMeter = theApp.ScreenDeviceInfo.ixPelsPerDM * 10;
        }
        
    if (m_cYPelsPerMeter == 0)
        {
        m_cYPelsPerMeter = theApp.ScreenDeviceInfo.iyPelsPerDM * 10;
        }

    PelsToCurrentUnit();

    // only call updatedata if dialog exists...
    if (m_hWnd && ::IsWindow( m_hWnd ))
        {
        UpdateData( FALSE );
        UpdateResolutionString();
        }
    }

/***************************************************************************/

void  CImageAttr::ConvertWidthHeight(void)
    {
    // if user modified the edit field Width/Height then get new data and
    // convert to pixel format.  Else use stored pixel format.
    if (bEditFieldModified)
        {
        UpdateData( TRUE );

        switch (m_eUnitsCurrent)
            {
            case eINCHES:
                 m_ulWidthPixels  = MulDiv(m_ulWidth,  m_cXPelsPerMeter * 254, 10000);
                 m_ulHeightPixels = MulDiv(m_ulHeight, m_cYPelsPerMeter * 254, 10000);
                 break;

            case eCM:
                 m_ulWidthPixels  = MulDiv(m_ulWidth,  m_cXPelsPerMeter, 100);
                 m_ulHeightPixels = MulDiv(m_ulHeight, m_cYPelsPerMeter, 100);
                 break;

            case ePIXELS:
            default: // ePIXELS and all other assumed to be pixel
                 m_ulWidthPixels  = m_ulWidth;
                 m_ulHeightPixels = m_ulHeight;
                 break;
            }

        bEditFieldModified = FALSE;
        }
    }

/***************************************************************************/

void CImageAttr::PelsToCurrentUnit()
    {
    switch (m_eUnitsCurrent)
        {
        case eINCHES:
            m_ulWidth  = MulDiv(m_ulWidthPixels,  10000, m_cXPelsPerMeter * 254);
            m_ulHeight = MulDiv(m_ulHeightPixels, 10000, m_cYPelsPerMeter * 254);
            break;

        case eCM:
            m_ulWidth  = MulDiv(m_ulWidthPixels,  100, m_cXPelsPerMeter);
            m_ulHeight = MulDiv(m_ulHeightPixels, 100, m_cYPelsPerMeter);
            break;

        case ePIXELS:
        default:
            //Pixels cannot be partial
            //make sure whole number when converted to string (truncate! now).
            m_ulWidth  = (m_ulWidthPixels  / FIXED_FLOATPT_MULTDIV) * FIXED_FLOATPT_MULTDIV;
            m_ulHeight = (m_ulHeightPixels / FIXED_FLOATPT_MULTDIV) * FIXED_FLOATPT_MULTDIV;
            break;
        }
    }

/***************************************************************************/

CSize CImageAttr::GetWidthHeight(void)
    {
    return CSize( (int)(( m_ulWidthPixels + (FIXED_FLOATPT_MULTDIV / 2)) / FIXED_FLOATPT_MULTDIV),
                  (int)((m_ulHeightPixels + (FIXED_FLOATPT_MULTDIV / 2)) / FIXED_FLOATPT_MULTDIV));
    }

/***************************************************************************/

void CImageAttr::OnInches()
    {
    SetNewUnits( eINCHES );
    }

/***************************************************************************/

void CImageAttr::OnCentimeters()
    {
    SetNewUnits( eCM );
    }

/***************************************************************************/

void CImageAttr::OnPixels()
    {
    SetNewUnits( ePIXELS );
    }

/***************************************************************************/

void CImageAttr::SetNewUnits( eUNITS NewUnit )
    {
    if (NewUnit == m_eUnitsCurrent)
        return;

    // must call getwidthheight before  setting to new mode
    ConvertWidthHeight(); // get in a common form of pixels.

    m_eUnitsCurrent = NewUnit;

    PelsToCurrentUnit();

    UpdateData( FALSE );
    }

/***************************************************************************/

void CImageAttr::OnChangeHeight()
    {
    bEditFieldModified = TRUE;
    }

/***************************************************************************/

void CImageAttr::OnChangeWidth()
    {
    bEditFieldModified = TRUE;
    }

/************************ CZoomViewDlg dialog ******************************/

CZoomViewDlg::CZoomViewDlg(CWnd* pParent /*=NULL*/)
             : CDialog(CZoomViewDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CZoomViewDlg)
    //}}AFX_DATA_INIT

    m_nCurrent = 0;
    }

/***************************************************************************/

void CZoomViewDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CZoomViewDlg)
    //}}AFX_DATA_MAP
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CZoomViewDlg, CDialog)
        ON_MESSAGE(WM_HELP, OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
    //{{AFX_MSG_MAP(CZoomViewDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/************************ CZoomViewDlg message handlers **********************/

static DWORD ZoomViewHelpIds[] =
        {
        IDC_CURRENT_ZOOM_STATIC,        IDH_PAINT_ZOOM_CURRENT,
        IDC_CURRENT_ZOOM,                       IDH_PAINT_ZOOM_CURRENT,
        IDC_ZOOM_GROUP,                         IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_100,                           IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_200,                           IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_400,                           IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_600,                           IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_800,                           IDH_PAINT_ZOOM_SET_GROUP,
        0, 0
        };

/***************************************************************************/

LONG
CZoomViewDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle), TEXT("mspaint.hlp"),
                  HELP_WM_HELP, (ULONG_PTR)(LPTSTR)ZoomViewHelpIds);
return lResult;
}

/***************************************************************************/

LONG
CZoomViewDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)wParam, TEXT("mspaint.hlp"),
                  HELP_CONTEXTMENU,(ULONG_PTR)(LPVOID)ZoomViewHelpIds);
return lResult;
}

/***************************************************************************/

BOOL CZoomViewDlg::OnInitDialog()
    {
    CDialog::OnInitDialog();

    TCHAR* pZoom = TEXT("100%");
    UINT nButton = IDC_ZOOM_100;

    if (m_nCurrent < 8)
        if (m_nCurrent < 6)
            if (m_nCurrent < 4)
                if (m_nCurrent < 2)
                    ;
                else
                    {
                    pZoom = TEXT("200%");
                    nButton = IDC_ZOOM_200;
                    }
            else
                {
                pZoom = TEXT("400%");
                nButton = IDC_ZOOM_400;
                }
        else
            {
            pZoom = TEXT("600%");
            nButton = IDC_ZOOM_600;
            }
    else
        {
        pZoom = TEXT("800%");
        nButton = IDC_ZOOM_800;
        }

    SetDlgItemText( IDC_CURRENT_ZOOM, pZoom );
    CheckRadioButton( IDC_ZOOM_100, IDC_ZOOM_800, nButton );

    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CZoomViewDlg::OnOK()
    {
    m_nCurrent = GetCheckedRadioButton( IDC_ZOOM_100, IDC_ZOOM_800 ) - IDC_ZOOM_100;

    if (m_nCurrent < 1)
        m_nCurrent  = 1;
    else
        m_nCurrent *= 2;

    CDialog::OnOK();
    }

/************************ CFlipRotateDlg dialog ****************************/

CFlipRotateDlg::CFlipRotateDlg(CWnd* pParent /*=NULL*/)
               : CDialog(CFlipRotateDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CFlipRotateDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_bHorz  = TRUE;
    m_bAngle = FALSE;
    m_nAngle = 90;
    }

/***************************************************************************/

void CFlipRotateDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFlipRotateDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CFlipRotateDlg, CDialog)
        ON_MESSAGE(WM_HELP, OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
    //{{AFX_MSG_MAP(CFlipRotateDlg)
    ON_BN_CLICKED(IDC_BY_ANGLE, OnByAngle)
    ON_BN_CLICKED(IDC_HORIZONTAL, OnNotByAngle)
    ON_BN_CLICKED(IDC_VERTICAL, OnNotByAngle)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/************************ CFlipRotateDlg message handlers **********************/

static DWORD FlipRotateHelpIds[] =
        {
        IDC_PAINT_FLIP_GROUP,   IDH_COMM_GROUPBOX,
        IDC_HORIZONTAL,                 IDH_PAINT_IMAGE_FLIP_HORIZ,
        IDC_VERTICAL,                   IDH_PAINT_IMAGE_FLIP_VERT,
        IDC_BY_ANGLE,                   IDH_PAINT_IMAGE_FLIP_ROTATE,
        IDC_90_DEG,                             IDH_PAINT_IMAGE_FLIP_ROTATE,
        IDC_180_DEG,                    IDH_PAINT_IMAGE_FLIP_ROTATE,
        IDC_270_DEG,                    IDH_PAINT_IMAGE_FLIP_ROTATE,
        0, 0
        };

/***************************************************************************/

LONG
CFlipRotateDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle), TEXT("mspaint.hlp"),
                  HELP_WM_HELP, (ULONG_PTR)(LPTSTR)FlipRotateHelpIds);
return lResult;
}

/***************************************************************************/

LONG
CFlipRotateDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)wParam, TEXT("mspaint.hlp"),
                  HELP_CONTEXTMENU,(ULONG_PTR)(LPVOID)FlipRotateHelpIds);
return lResult;
}

/***************************************************************************/

BOOL CFlipRotateDlg::OnInitDialog()
    {
    CDialog::OnInitDialog();

    CheckRadioButton( IDC_90_DEG, IDC_270_DEG, IDC_90_DEG );

    UINT uButton = (m_bAngle? IDC_BY_ANGLE: (m_bHorz? IDC_HORIZONTAL: IDC_VERTICAL));

    CheckRadioButton( IDC_HORIZONTAL, IDC_BY_ANGLE, uButton );

    if (uButton != IDC_BY_ANGLE)
        OnNotByAngle();

    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CFlipRotateDlg::OnByAngle()
    {
    GetDlgItem( IDC_90_DEG  )->EnableWindow( TRUE );
    GetDlgItem( IDC_180_DEG )->EnableWindow( TRUE );
    GetDlgItem( IDC_270_DEG )->EnableWindow( TRUE );
    }

/***************************************************************************/

void CFlipRotateDlg::OnNotByAngle()
    {
    GetDlgItem( IDC_90_DEG  )->EnableWindow( FALSE );
    GetDlgItem( IDC_180_DEG )->EnableWindow( FALSE );
    GetDlgItem( IDC_270_DEG )->EnableWindow( FALSE );
    }

/***************************************************************************/

void CFlipRotateDlg::OnOK()
    {
    UINT uButton = GetCheckedRadioButton( IDC_HORIZONTAL, IDC_BY_ANGLE );

    m_bHorz  = (uButton == IDC_HORIZONTAL);
    m_bAngle = (uButton == IDC_BY_ANGLE);

    switch (GetCheckedRadioButton( IDC_90_DEG, IDC_270_DEG ))
        {
        case IDC_90_DEG:
            m_nAngle = 90;
            break;

        case IDC_180_DEG:
            m_nAngle = 180;
            break;

        case IDC_270_DEG:
            m_nAngle = 270;
            break;
        }

    CDialog::OnOK();
    }

/************************* CStretchSkewDlg dialog **************************/

CStretchSkewDlg::CStretchSkewDlg(CWnd* pParent /*=NULL*/)
                : CDialog(CStretchSkewDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CStretchSkewDlg)
    m_wSkewHorz = 0;
    m_wSkewVert = 0;
    m_iStretchVert = 100;
    m_iStretchHorz = 100;
    //}}AFX_DATA_INIT

    //m_bStretchHorz = TRUE;
    //m_bSkewHorz    = TRUE;
    }

/***************************************************************************/

void CStretchSkewDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CStretchSkewDlg)
    DDX_Text(pDX, IDC_STRETCH_VERT_PERCENT, m_iStretchVert);
    DDV_MinMaxInt(pDX, m_iStretchVert, 1, 500);
    DDX_Text(pDX, IDC_STRETCH_HORZ_PERCENT, m_iStretchHorz);
    DDV_MinMaxInt(pDX, m_iStretchHorz, 1, 500);
    DDX_Text(pDX, IDC_SKEW_HORZ_DEGREES, m_wSkewHorz);
    DDV_MinMaxInt(pDX, m_wSkewHorz, -89, 89);
    DDX_Text(pDX, IDC_SKEW_VERT_DEGREES, m_wSkewVert);
    DDV_MinMaxInt(pDX, m_wSkewVert, -89, 89);

    //}}AFX_DATA_MAP
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CStretchSkewDlg, CDialog)
        ON_MESSAGE(WM_HELP, OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
    //{{AFX_MSG_MAP(CStretchSkewDlg)
    /*
    ON_BN_CLICKED(IDC_SKEW_HORZ, OnSkewHorz)
    ON_BN_CLICKED(IDC_SKEW_VERT, OnSkewVert)
    ON_BN_CLICKED(IDC_STRETCH_HORZ, OnStretchHorz)
    ON_BN_CLICKED(IDC_STRETCH_VERT, OnStretchVert)
    */
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/************************ CStretchSkewDlg message handlers **********************/

static DWORD StretchSkewHelpIds[] =
        {
        IDC_STRETCH_GROUP,                      IDH_COMM_GROUPBOX,
        IDC_STRETCH_HORZ_ICON,          IDH_PAINT_IMAGE_STRETCH_HORIZ,
        IDC_STRETCH_HORZ,                       IDH_PAINT_IMAGE_STRETCH_HORIZ,
        IDC_STRETCH_HORZ_PERCENT,       IDH_PAINT_IMAGE_STRETCH_HORIZ,
        IDC_STRETCH_HORZ_SUFFIX,        IDH_PAINT_IMAGE_STRETCH_HORIZ,
        IDC_STRETCH_VERT_ICON,          IDH_PAINT_IMAGE_STRETCH_VERT,
        IDC_STRETCH_VERT,                       IDH_PAINT_IMAGE_STRETCH_VERT,
        IDC_STRETCH_VERT_PERCENT,       IDH_PAINT_IMAGE_STRETCH_VERT,
        IDC_STRETCH_VERT_SUFFIX,        IDH_PAINT_IMAGE_STRETCH_VERT,
        IDC_SKEW_GROUP,                         IDH_COMM_GROUPBOX,
        IDC_SKEW_HORZ_ICON,                     IDH_PAINT_IMAGE_SKEW_HOR,
        IDC_SKEW_HORZ,                          IDH_PAINT_IMAGE_SKEW_HOR,
        IDC_SKEW_HORZ_DEGREES,          IDH_PAINT_IMAGE_SKEW_HOR,
        IDC_SKEW_HORZ_SUFFIX,           IDH_PAINT_IMAGE_SKEW_HOR,
        IDC_SKEW_VERT_ICON,                     IDH_PAINT_IMAGE_SKEW_VERT,
        IDC_SKEW_VERT,                          IDH_PAINT_IMAGE_SKEW_VERT,
        IDC_SKEW_VERT_DEGREES,          IDH_PAINT_IMAGE_SKEW_VERT,
        IDC_SKEW_VERT_SUFFIX,           IDH_PAINT_IMAGE_SKEW_VERT,
        0, 0
        };

/***************************************************************************/

LONG
CStretchSkewDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle), TEXT("mspaint.hlp"),
                  HELP_WM_HELP, (ULONG_PTR)(LPTSTR)StretchSkewHelpIds);
return lResult;
}

/***************************************************************************/

LONG
CStretchSkewDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)wParam, TEXT("mspaint.hlp"),
                  HELP_CONTEXTMENU,(ULONG_PTR)(LPVOID)StretchSkewHelpIds);
return lResult;
}

/***************************************************************************/


BOOL CStretchSkewDlg::OnInitDialog()
    {
    CDialog::OnInitDialog();

    CheckRadioButton( IDC_STRETCH_HORZ, IDC_STRETCH_VERT, IDC_STRETCH_HORZ );
    CheckRadioButton( IDC_SKEW_HORZ   , IDC_SKEW_VERT   , IDC_SKEW_HORZ    );

   /* GetDlgItem( IDC_STRETCH_HORZ_PERCENT )->EnableWindow(   m_iStretchHorz );
    GetDlgItem( IDC_STRETCH_VERT_PERCENT )->EnableWindow( ! m_iStretchHorz );
    GetDlgItem( IDC_SKEW_HORZ_DEGREES )->EnableWindow(   m_bSkewHorz );
    GetDlgItem( IDC_SKEW_VERT_DEGREES )->EnableWindow( ! m_bSkewHorz );
*/
    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CStretchSkewDlg::OnStretchHorz()
    {
    m_bStretchHorz = TRUE;

    GetDlgItem( IDC_STRETCH_HORZ_PERCENT )->EnableWindow( TRUE  );
    GetDlgItem( IDC_STRETCH_VERT_PERCENT )->EnableWindow( FALSE );
    CheckRadioButton( IDC_STRETCH_HORZ, IDC_STRETCH_VERT, IDC_STRETCH_HORZ );
    }

/***************************************************************************/

void CStretchSkewDlg::OnStretchVert()
    {
    m_bStretchHorz = FALSE;

    GetDlgItem( IDC_STRETCH_HORZ_PERCENT )->EnableWindow( FALSE );
    GetDlgItem( IDC_STRETCH_VERT_PERCENT )->EnableWindow( TRUE  );
    CheckRadioButton( IDC_STRETCH_HORZ, IDC_STRETCH_VERT, IDC_STRETCH_VERT );
    }

/***************************************************************************/

void CStretchSkewDlg::OnSkewHorz()
    {
    m_bSkewHorz = TRUE;

    GetDlgItem( IDC_SKEW_HORZ_DEGREES )->EnableWindow( TRUE  );
    GetDlgItem( IDC_SKEW_VERT_DEGREES )->EnableWindow( FALSE );
    CheckRadioButton( IDC_SKEW_HORZ, IDC_SKEW_VERT, IDC_SKEW_HORZ );
    }

/***************************************************************************/

void CStretchSkewDlg::OnSkewVert()
    {
    m_bSkewHorz = FALSE;

    GetDlgItem( IDC_SKEW_HORZ_DEGREES )->EnableWindow( FALSE );
    GetDlgItem( IDC_SKEW_VERT_DEGREES )->EnableWindow( TRUE  );
    CheckRadioButton( IDC_SKEW_HORZ, IDC_SKEW_VERT, IDC_SKEW_VERT );
    }

/***************************************************************************/

void CStretchSkewDlg::OnOK()
    {
    if (GetCheckedRadioButton( IDC_STRETCH_HORZ, IDC_STRETCH_VERT )
                            == IDC_STRETCH_HORZ)
        m_iStretchVert = 0;
    else
        m_iStretchHorz = 0;

    if (GetCheckedRadioButton( IDC_SKEW_HORZ, IDC_SKEW_VERT )
                            == IDC_SKEW_HORZ)
        m_wSkewVert = 0;
    else
        m_wSkewHorz = 0;

    CDialog::OnOK();
    }

/***************************************************************************/

void CImageAttr::OnUseTrans()
{
   CWnd* pSelectColorButton = GetDlgItem(IDC_SELECT_COLOR);
   pSelectColorButton->EnableWindow(IsDlgButtonChecked(IDC_USE_TRANS));
}

extern INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);

static UINT_PTR CALLBACK /*LPCCHOOKPROC*/
SelectColorHook(HWND hColorDlg, UINT nMessage, WPARAM wParam, LPARAM lParam)
{
// Are we initializing the dialog window?
if ( nMessage == WM_INITDIALOG )
        {
        // Reset the common dialog title
        CString strDialogTitle;
        VERIFY(strDialogTitle.LoadString(IDS_SELECT_COLOR));
        SetWindowText( hColorDlg, strDialogTitle );
        }
// Pass All Messages Along to Common Dialog
return (UINT)AfxDlgProc(hColorDlg, nMessage, wParam, lParam );
}

void CImageAttr::OnSelectColor()
{
   // for default color selection, disregard palette-relative
    CColorDialog dlg( m_crTrans & 0xFFFFFF, CC_FULLOPEN );
        dlg.m_cc.lpfnHook = SelectColorHook;

    if (dlg.DoModal() != IDOK)
        return;

        PaintTransBox( m_crTrans = dlg.GetColor() );
}

void CImageAttr::OnPaint()
{
        CPaintDC dc(this); // device context for painting

        if (m_crTrans != TRANS_COLOR_NONE)    // not default
                PaintTransBox( m_crTrans );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\image.h ===
//***************************************************************************
//
//	IMAGE.h
//
// Proposed new interface!
//
//		Include file for the Image API Library.
//    This is the external containing header data required
//    by the outside world.
//
//	Revision History
//		17-Nov-95	TerryJ		Original
//    04-Jan-96   TerryJ      Code cleaned up. Memory mode added.
//    16-Jan-96   TerryJ      Registry validation capacity added.
//    
//
//***************************************************************************

#ifndef  _IMAGEFILELIB_H
#define  _IMAGEFILELIB_H

#include "msffdefs.h"   //include platform dependent defs

#ifdef _MAC
#include <Macname1.h>
#include "Types.h"
#include "Files.h"
#include <Macname2.h>
#endif // _MAC

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif   // __cplusplus

/***********
| IFLMODE:	Open modes
\***********/
typedef enum
   {
   IFLM_READ	    =0x00,
   IFLM_WRITE	    =0x01,
   IFLM_MEMORY     =0x80,    // OR to operate in memory
   IFLM_EXTRACT_ALPHA  =0x40,    // OR to extract separate image and alpha channel info
   IFLM_CHUNKY_ALPHA   =0x20,    //OR to extract RGBA chunky data
   } IFLMODE;

/***********
| IFLCLASS:	Image classes
\***********/
typedef enum
   {
   IFLCL_BILEVEL     = 0,   // 1 BPP
   IFLCL_GRAY        = 1,   // 2,4,6,8 BPP
   IFLCL_GRAYA       =11,   // 16 BPP chunky 
   IFLCL_PALETTE     = 2,   // 2,4,6,8 BPP
   IFLCL_RGB         = 3,   // 24 BPP chunky
   IFLCL_RGBPLANAR   = 4,   // 24 BPP in 8 bit planes
   IFLCL_RGBA        = 5,   // 32 BPP chunky
   IFLCL_RGBAPLANAR  = 6,   // 32 BPP in four 8 bit planes
   IFLCL_CMYK        = 7,
   IFLCL_YCC         = 8,
   IFLCL_CIELAB      = 9,
   IFLCL_NONE        =10   // no class set! (error)
   } IFLCLASS;

typedef enum
   {
   IFLTF_NONE     =0,
   IFLTF_STRIPS   =1,
   IFLTF_TILES    =2
   } IFLTILEFORMAT;

/***********
| IFLCOMMAND:	 Commands to IFL_Control
\***********/
typedef enum
   {
   IFLCMD_GETERROR      =0,   // get error code
   IFLCMD_GETLINESIZE   =1,   // compute line size
   IFLCMD_PALETTE       =2,   // get or set palette or map
   IFLCMD_SETPACKMODE   =3,   // set mode for packing/unpacking pixels
   IFLCMD_RESOLUTION    =7,   // get dots per meter
   IFLCMD_GETNUMIMAGES  =10,  // get the number of images
   IFLCMD_IMAGESEEK     =11,  // seek to the next image
   IFLCMD_DELETE        =12,  // delete current image
   IFLCMD_TILEFORMAT    =13,  // set/get the tiling format
   IFLCMD_YCCINFO       =14,  // set/get YCC information
   IFLCMD_YCCRGBCONVERT =15,  // set/get YCC/RGB conversion state
   IFLCMD_COLORIMETRY   =16,  // set/get Colorimetry info
   IFLCMD_CMYKINFO      =17,  // set/get CMYK specific data

   IFLCMD_BKGD_IDX      =18,  // set/get background color by index
   IFLCMD_BKGD_RGB      =19,  // set/get background color
   IFLCMD_TRANS_IDX     =20,  // set/get transparency color index
   IFLCMD_TRANS_RGB     =21,  // set/get transparency color
   IFLCMD_TRANS_MASK_INFO     =22,  // set/get transparency mask info
   IFLCMD_TRANS_MASK          =23,  // set/get transparency mask
   IFLCMD_ALPHA_PALETTE_INFO  =24,  // set/get alpha palette info
   IFLCMD_ALPHA_PALETTE       =25,  // set/get alpha palette
   IFLCMD_ALPHA_CHANNEL_INFO  =26,  // set/get alpha channel info
   IFLCMD_ALPHA_CHANNEL       =27,  // set/get alpha channel
   IFLCMD_GAMMA_VALUE         =28,  // set/get gamma value

   IFLCMD_FIRST_TEXT          =29,  // get first text string
   IFLCMD_NEXT_TEXT           =30,  // get next text strings.
   IFLCMD_DATETIME_STRUCT     =31,  // retrieve date/time as a structure.

   IFLCMD_TIFF          =0x4000,    // TIFF specific commands
   IFLCMD_TIFFTAG       =0x4001,
   IFLCMD_TIFFTAGDATA   =0x4002,
   IFLCMD_PCX           =0x4200,    // PCX specific commands
   IFLCMD_BMP           =0x4400,    // BMP specific commands
   IFLCMD_BMP_VERSION   =0x4401,    // Windows os2 1.2 os2 2.0 versions
   IFLCMD_TGA           =0x4800,    // TGA specific commands
   IFLCMD_GIF           =0x4E00,    // GIF specific commands
   IFLCMD_GIF_WHITE_IS_ZERO =0x4E01,   // White == 0 in GIF file
   IFLCMD_JPEG          =0x5700,    // WPG specific commands
   IFLCMD_JPEGQ         =0x5701,    // Quality
   IFLCMD_PCD           =0x5800,    // Kodak PCD specific commands
   IFLCMD_PCDGETTRANSFORM  =0x5801,
   IFLCMD_PCDSETTRANSFORM  =0x5802,
   IFLCMD_PCDSETCLASS      =0x5803,
   IFLCMD_PNG           =0x5900,    // PNG specific commands
   IFLCMD_PNG_SET_FILTER   =0x590A, // Set PNG filter type
   IFLCMD_PNG_sBIT         =0x590B, // set/get PNG sBIT chunk

   IFLCMD_GETDATASIZE      =0x8000  // OR with this to get the size
   } IFLCOMMAND;

typedef IFLCOMMAND IFLCMD;    // this is done as backwards 
                              // compatibility and may be able
                              // to be eliminated eventually

/***********
| IFLDESC:	 Available description strings (use as bitfields)
\***********/
typedef enum
   {
   IFLDESC_NONE          =0,   // no descriptions supported
   IFLDESC_DESCRIPTION   =1,   // image description field (TIFF TGA PNG)
   IFLDESC_SOFTWARENAME  =2,   // software name (TIFF TGA)  Software (PNG)
   IFLDESC_ARTISTNAME    =4,   // artist name (TIFF TGA)    Author (PNG)
   IFLDESC_DOCUMENTNAME  =8,   // the document name field   Title (PNG)
   IFLDESC_DATETIME      =16,  // the date/time field
   IFLDESC_COPYRIGHT     =32,  // copyright notice (PNG)
   IFLDESC_DISCLAIMER    =64,  // Legal disclaimer (PNG)
   IFLDESC_WARNING       =128, // content warning (PNG)
   IFLDESC_SOURCE        =256, // source device (PNG)
   IFLDESC_COMMENT       =512, // misc comment (PNG)
   } IFLDESC;

/***********
| IFLPACKMODE:	 Packing modes
\***********/
typedef enum
   {
   IFLPM_PACKED         =0,
   IFLPM_UNPACKED       =1,
   IFLPM_LEFTJUSTIFIED  =2,
   IFLPM_NORMALIZED     =3,
   IFLPM_RAW            =4
   } IFLPACKMODE;

/***********
| IFLSEQUENCE:	Line sequences
\***********/
typedef enum
   {
   IFLSEQ_TOPDOWN    =0,         // most
   IFLSEQ_BOTTOMUP   =1,         // BMP and TGA compressed
   IFLSEQ_GIF_INTERLACED =2,     // for GIF
   IFLSEQ_ADAM7_INTERLACED = 3   // for PNG
   } IFLSEQUENCE;

/***********
| IFLERROR:	Possible errors
\***********/
typedef enum
   {
   IFLERR_NONE          =0,   // no error
   IFLERR_HANDLELIMIT   =1,   // too many open files
   IFLERR_PARAMETER     =2,   // programmer error
   IFLERR_NOTSUPPORTED  =3,   // feature not supported by format
   IFLERR_NOTAVAILABLE  =4,   // item not available
   IFLERR_MEMORY        =5,   // insufficient memory
   IFLERR_IMAGE         =6,   // bad image data (decompression error)
   IFLERR_HEADER        =7,   // header has bad fields
   IFLERR_IO_OPEN       =8,   // error on open()
   IFLERR_IO_CLOSE      =9,   // error on close()
   IFLERR_IO_READ       =10,  // error on read()
   IFLERR_IO_WRITE      =11,  // error on write()
   IFLERR_IO_SEEK       =12,  // error on lseek()
   } IFLERROR;

 typedef enum    // new error messages to go here. This error
                  // info is maintained here rather than IFLERROR
                  // to retain backwards compatibility
 
   {
   IFLEXTERR_NONE,
   IFLEXTERR_NO_DLL,             // open
   IFLEXTERR_NO_LIBRARY,         // open: no library specified
   IFLEXTERR_BAD_DLL,            // DLL doesn't have right entry points
   IFLEXTERR_CANNOT_IMPORT,      // open
   IFLEXTERR_CANNOT_EXPORT,      // open
   IFLEXTERR_CANNOT_COMPRESS,    // open
   IFLEXTERR_BAD_FORMAT,         // read
   IFLEXTERR_UNKNOWN_VARIANT,    // open/read: for example, JFIFs and
                                 // BMPs have many variants - some may
                                 // not be supported
   IFLEXTERR_SHARING_VIOLATION,        // read
   IFLEXTERR_NO_BACKGROUND_COLOR,      // read: no background color specified
                                       // when doing transparencies
   IFLEXTERR_BACKGROUND_NOT_SUPPORTED, // background colors not supported
                                       // (currently) by this format
   IFLEXTERR_NO_FILE,            // file doesn't exist
   IFLEXTERR_END_OF_FILE,        // read
   IFLEXTERR_MEMORY,             // insufficient memory
   IFLEXTERR_DESC_CANNOT_GET,    // file is write mode: can't get descriptions
   IFLEXTERR_DESC_CANNOT_SET,    // file is read mode: can't set descriptions
   IFLEXTERR_NO_PATH_IN_REGISTRY,   // the filter path isn't in the registry
   IFLEXTERR_NOT_IFL_HANDLE,     // the pointer passed isn't an IFLHANDLE
   IFLEXTERR_REGISTRY_DAMAGED,   // entry in registry not correct format
   IFLEXTERR_BAD_COMPRESSION,    // error in data compression; cannot read.
   } IFLEXTERROR;


/***********
| IFLCOMPRESSION:	Compression options
\***********/
typedef enum
   {
   IFLCOMP_NONE      =0,   // no compression
   IFLCOMP_DEFAULT   =1,   // whatever is defined for the format
   IFLCOMP_RLE       =2,   // various RLE schemes (PACKBITS in TIFF)
   IFLCOMP_CCITT1D   =3,   // TIFF modified G3
   IFLCOMP_CCITTG3   =4,   // TIFF raw G3
   IFLCOMP_CCITTG4   =5,   // TIFF G4
   IFLCOMP_LZW       =6,   // Lempel-Zif
   IFLCOMP_LZWHPRED  =7,   // LZW with TIFF horizontal differencing
   IFLCOMP_JPEG      =8    // JPEG compression
   } IFLCOMPRESSION;

/***********
| Date Time structure for IFL
\***********/
typedef struct
   {
   short Year;
   short Month;
   short Day;
   short Hour;
   short Minute;
   short Second;
   } IFL_DATETIME;

/***********
| RGB color structure for IFL
\***********/
typedef struct  // rgb color values
   {
   BYTE  bRed;
   BYTE  bGreen;
   BYTE  bBlue;
   } IFLCOLORRGB;

typedef struct  // new color struct capable of 16 bit values. 
   {            
   WORD  wRed;
   WORD  wGreen;
   WORD  wBlue;
   }  IFLCOLOR;

/***********
| Types for multiple images
\***********/
typedef enum
   {
   IFLIT_PRIMARY     =0,
   IFLIT_THUMBNAIL   =1,
   IFLIT_MASK        =2
   } IFLIMAGETYPE;

/***********
| Bitmap types
\***********/
typedef enum
   {
   IFLBV_WIN_3    =0x10,   // Windows 3.x
   IFLBV_OS2_1    =0x20,   // OS2 1.2
   IFLBV_OS2_2S   =0x40,   // OS2 2.0 single image
   IFLBV_OS2_2M   =0x41    // OS2 2.0 multiple image
   } IFLBMPVERSION;


/***********
| Capabilities Type, for interpreting Registry info
\***********/
typedef enum
   {
   IFLCAP_NOT_AVAILABLE =0x0000,    // if option not available
      
      // ** compression options **
   IFLCAP_COMPNONE      =0x0001,
   IFLCAP_COMPRLE       =0x0002,
   IFLCAP_COMPG3        =0x0004,
   IFLCAP_COMPG4        =0x0008,
   IFLCAP_COMPLZW       =0x0010,
   IFLCAP_COMPLZWPRED   =0x0020,
   IFLCAP_COMPJPEG      =0x0040,
   IFLCAP_COMPDEFAULT   =0x0080,

      // ** bit plane options **     // note that for RGB, RGB QUAD
   IFLCAP_1BPP          =0x0001,     //  and RGBA bit plane depth must
   IFLCAP_2BPP          =0x0002,     //  be multiplied by 3, 4 and 4
   IFLCAP_3BPP          =0x0004,     //  respectively for the full
   IFLCAP_4BPP          =0x0008,     //  pixel depth size.
   IFLCAP_5BPP          =0x0010,
   IFLCAP_6BPP          =0x0020,
   IFLCAP_7BPP          =0x0040,
   IFLCAP_8BPP          =0x0080,
   IFLCAP_8BPP_QUAD     =0x0100,
   IFLCAP_12BPP         =0x0200,
   IFLCAP_16BPP         =0x0400,

      // ** Transparency options
   IFLCAP_NO_TRANS      =0x0000,
   IFLCAP_1BITMASK      =0x0001,
   IFLCAP_ALPHACHANNEL  =0x0002,
   IFLCAP_ALPHAPALETTE  =0x0004,
   IFLCAP_TRANSCOLOR    =0x0008,

   } IFLCAPABILITIES;


/***********
| Alpha/Transparency info structs
\***********/

typedef struct
   {
   DWORD dwWidth;
   DWORD dwHeight;
   }  IFL_TRANS_MASK_INFO;

typedef struct
   {
   DWORD dwWidth;
   DWORD dwHeight;
   WORD wBitsPerPixel;
   }  IFL_ALPHA_CHANNEL_INFO;

typedef struct
   {
   char  *szKey;
   char  *szText;
   } IFL_COMMENT_STRING;

typedef struct
   {
   unsigned char bPNGType;
   unsigned char bGrayBits;
   unsigned char bRedBits;
   unsigned char bGreenBits;
   unsigned char bBlueBits;
   unsigned char bAlphaBits;
   } IFLPNGsBIT;


/***********
| Handle types
| Use FILTERHANDLE to access filters
\***********/

typedef void far * IFLHANDLE;  // handle is a void pointer to hide the
                                 // details of the file handle from other
                                 // programmers. 

/* -------- new stuff   ---------------------- */

typedef enum
   {
   IFLT_UNKNOWN,     // unknown or unsupported file type
   IFLT_GIF,
   IFLT_BMP,
   IFLT_JPEG,
   IFLT_TIFF,
   IFLT_PNG,
   IFLT_PCD,
   IFLT_PCX,
   IFLT_TGA,
   IFLT_PICT
   } IFLTYPE;


/***********
| IFL virtual (memory) mode types
\***********/

// internal virtual (memory) file i/o routine pointers
typedef int	   (__cdecl _vopen)  (LPSTR, int, int);
typedef int    (__cdecl _vclose) (int);
typedef int	   (__cdecl _vread)  (int, LPVOID, int);
typedef int	   (__cdecl _vwrite) (int, LPVOID, int);
typedef long   (__cdecl _vlseek) (int, long, int);

// structure used to hold virtual (memory) i/o functions
// when using IFLM_MEMORY mode.
typedef struct ImageIOFuncs    
   {                           
   _vopen  *vopen;             
   _vclose *vclose;
   _vread  *vread;
   _vwrite *vwrite;
   _vlseek *vlseek;

   LPVOID  userdata;
   } IFLIOF, far * LPIFLIOF;

// structure used to hold virtual (memory) memory info
// when using IFLM_MEMORY mode.
typedef struct ImageMemStruct  
   {                           
   long    pos;                
   long    alloced;
   long    length;
   LPVOID  data;
   } IFLIOM, far * LPIFLIOM;


/***********
| IFL function prototypes
\***********/
IFLERROR HILAPI iflOpen(IFLHANDLE iflh, LPSTR FileName, IFLMODE Mode);
IFLERROR HILAPI iflClose(IFLHANDLE iflh);
IFLERROR HILAPI iflRead(IFLHANDLE iflh, LPBYTE Buffer, int NumLines);
IFLERROR HILAPI iflWrite(IFLHANDLE iflh, LPBYTE Buffer, int NumLines);
IFLERROR HILAPI iflSeek(IFLHANDLE iflh, int Line);
IFLERROR HILAPI iflControl(IFLHANDLE iflh, IFLCMD Command, short sParam, long lParam, LPVOID pParam);

   // new commands (general)

IFLERROR HILAPI iflImageType(LPSTR FileName, IFLTYPE *ImageType);
IFLTYPE  HILAPI iflTypeFromExtension (char far * Filename);
void            iflGetLibName(IFLTYPE fileType, LPSTR libName);
IFLERROR HILAPI iflFilterCap(IFLTYPE ImageType, IFLCLASS ImageClass,
                             WORD *Color, WORD *Compression,
                             WORD *Transparency);
IFLERROR HILAPI iflInstalledFilterQuery(IFLTYPE filterType,
                                        BOOL    *bImports,
                                        BOOL    *bExports);
IFLERROR HILAPI iflExtensionCount(IFLTYPE filterType,
                                  short   *sCount);
IFLERROR HILAPI iflExtensionQuery(IFLTYPE filterType,
                                  short   sExtNum,
                                  LPSTR   szExtension);
IFLERROR HILAPI iflFormatNameQuery(IFLTYPE filterType,
                                  LPSTR   szFormatName,
                                  short   sFormatNameSize);
IFLEXTERROR HILAPI iflGetExtendedError(IFLHANDLE iflh);

   // description manipulation

IFLERROR HILAPI iflGetDesc(IFLHANDLE iflh, IFLDESC DescType, LPSTR *pDescription);
IFLERROR HILAPI iflPutDesc(IFLHANDLE iflh, IFLDESC DescType, LPSTR Description);
IFLERROR HILAPI iflSupportedDesc(IFLHANDLE iflh, IFLDESC *Supports);

   // handle manipulation

IFLHANDLE HILAPI iflCreateReadHandle( IFLTYPE        ImageType);
IFLHANDLE HILAPI iflCreateWriteHandle(int           Width,         // Width of image in pixels
                                     int            Height,        // Height of image in pixels
                                     IFLCLASS       ImageClass,    // image class
                                     int            BitsPerSample, // Number of bits per sample
                                     IFLCOMPRESSION Compression,   // defined above
                                     IFLTYPE        ImageType      // Type of image (GIF, PCX, etc)
                                     );
IFLERROR HILAPI iflFreeHandle(IFLHANDLE iflh);

   // background manipulation
IFLERROR HILAPI iflGetBackgroundColor(IFLHANDLE iflh, IFLCOLOR *clBackColor);
IFLERROR HILAPI iflSetBackgroundColor(IFLHANDLE iflh, IFLCOLOR clBackColor);
IFLERROR HILAPI iflSetBackgroundColorByIndex(IFLHANDLE iflh, short iColorIndex);

   // accessors and manipulators

#ifdef _MAC
IFLERROR HILAPI iflSetMacCreator(OSType OSCreator);
#endif // _MAC
IFLCLASS    HILAPI iflGetClass(IFLHANDLE iflh);
int         HILAPI iflGetHeight(IFLHANDLE iflh);
int         HILAPI iflGetWidth(IFLHANDLE iflh);
int         HILAPI iflGetRasterLineCount(IFLHANDLE iflh);
IFLSEQUENCE HILAPI iflGetSequence(IFLHANDLE iflh);
IFLERROR    HILAPI iflSetSequence(IFLHANDLE iflh, IFLSEQUENCE iflsSeq);
IFLCOMPRESSION HILAPI iflGetCompression(IFLHANDLE iflh);
int         HILAPI iflGetBitsPerChannel(IFLHANDLE iflh);
int         HILAPI iflGetBitsPerPixel(IFLHANDLE iflh);
IFLTYPE     HILAPI iflGetImageType(IFLHANDLE iflh);

#ifdef __cplusplus
}
#endif   // __cplusplus

#endif   // _IMAGEFILELIB_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\global.cpp ===
#include "stdafx.h"


#include <direct.h>

#include <tchar.h>
#include "global.h"

#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif // _DEBUG

#include "memtrace.h"

/***************************************************************************/

//
// This function returns a pointer to a monochrome GDI brush with
// alternating "black" and "white" pixels.  This brush should NOT
// be deleted!
//
CBrush* GetHalftoneBrush()
    {
    static CBrush NEAR halftoneBrush;

    if (halftoneBrush.m_hObject == NULL)
        {
        static WORD NEAR rgwHalftone [] =
            {
            0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555
            };

        CBitmap bitmap;

        if (!bitmap.CreateBitmap(8, 8, 1, 1, rgwHalftone))
            return NULL;

        if (!halftoneBrush.CreatePatternBrush(&bitmap))
            return NULL;
        }

    return &halftoneBrush;
    }

/////////////////////////////////////////////////////////////////////////////
//
// The following code manages a cache of GDI brushes that correspond to
// the system defined colors.  The cache is flushed when the user changes
// any of the system colors using the control panel.  Using GetSysBrush()
// to get a system colored brush will be more efficient than creating the
// brush yourself.
//
void ResetSysBrushes()
    {
    //NOTE: we don't include our extensions to the "system" brushes, because
    //  often the brush handle is used as hbrBackground for a Window class!
    for (UINT nBrush = 0; nBrush < nSysBrushes + nOurBrushes; nBrush++)
        if (theApp.m_pbrSysColors[nBrush])
            {
            delete theApp.m_pbrSysColors[nBrush];
            theApp.m_pbrSysColors[nBrush] = NULL;
            }
    }

COLORREF MyGetSysColor(UINT nSysColor)
    {
    if (nSysColor < nSysBrushes)
        return ::GetSysColor( nSysColor );

    static COLORREF NEAR rgColors[nOurBrushes] =
        {
        CMP_RGB_HILITE, CMP_RGB_LTGRAY, CMP_RGB_DKGRAY, CMP_RGB_BLACK,
        };

    ASSERT((int)nSysColor - CMP_COLOR_HILITE >= 0);
    ASSERT((int)nSysColor - CMP_COLOR_HILITE < nOurBrushes);

    return rgColors[nSysColor - CMP_COLOR_HILITE];
    }

CBrush* GetSysBrush(UINT nSysColor)
    {
    ASSERT(nSysColor < nSysBrushes + nOurBrushes);

    if (! theApp.m_pbrSysColors[nSysColor])
        {
        COLORREF cr = MyGetSysColor(nSysColor);

        theApp.m_pbrSysColors[nSysColor] = new CBrush;

        if (theApp.m_pbrSysColors[nSysColor])
            {
            if (! theApp.m_pbrSysColors[nSysColor]->CreateSolidBrush( cr ))
                {
                TRACE( TEXT("GetSysBrush failed!\n") );
                theApp.SetGdiEmergency();

                delete theApp.m_pbrSysColors[nSysColor];
                theApp.m_pbrSysColors[nSysColor] = NULL;
                }
            }
        else
            theApp.SetMemoryEmergency();
        }

    return theApp.m_pbrSysColors[nSysColor];
    }


//
//      PreTerminateList
//              Helper function for deleting all objects in a list, and then
//              truncating the list.  Help stop leaks by using this, so your
//              objects don't get left in memory.
//

void PreTerminateList( CObList* pList )
    {
    if (pList == NULL || pList->IsEmpty())
        return;

    while (! pList->IsEmpty())
        {
        CObject* pObj = pList->RemoveHead();
        delete pObj;
        }
    }

/////////////////////////////////////////////////////////////////////////////


void MySplitPath (const TCHAR *szPath, TCHAR *szDrive, TCHAR *szDir, TCHAR *szName, TCHAR *szExt)
    {
       // Found this in tchar.h
       _tsplitpath (szPath, szDrive, szDir, szName, szExt);
    }

// Remove the drive and directory from a file name...
//
CString StripPath(const TCHAR* szFilePath)
    {
    TCHAR szName [_MAX_FNAME + _MAX_EXT];
    TCHAR szExt [_MAX_EXT];
    MySplitPath(szFilePath, NULL, NULL, szName, szExt);
    lstrcat(szName, szExt);
    return CString(szName);
    }

// Remove the name part of a file path.  Return just the drive and directory.
//
CString StripName(const TCHAR* szFilePath)
    {
    TCHAR szPath [_MAX_DRIVE + _MAX_DIR];
    TCHAR szDir [_MAX_DIR];
    MySplitPath(szFilePath, szPath, szDir, NULL, NULL);
    lstrcat(szPath, szDir);
    return CString(szPath);
    }

// Remove the name part of a file path.  Return just the drive and directory, and name.
//
CString StripExtension(const TCHAR* szFilePath)
    {
    TCHAR szPath [_MAX_DRIVE + _MAX_DIR + _MAX_FNAME];
    TCHAR szDir [_MAX_DIR];
    TCHAR szName [_MAX_FNAME];
    MySplitPath(szFilePath, szPath, szDir, szName, NULL);
    lstrcat(szPath, szDir);
    lstrcat(szPath, szName);
    return CString(szPath);
    }

// Get the extension of a file path.
//
CString GetExtension(const TCHAR* szFilePath)
    {
    TCHAR szExt [_MAX_EXT];
    MySplitPath(szFilePath, NULL, NULL, NULL, szExt);
    return CString(szExt);
    }

// Get the name of a file path.
//
CString GetName(const TCHAR* szFilePath)
    {
    TCHAR szName [_MAX_FNAME];
    MySplitPath(szFilePath, NULL, NULL, szName, NULL);
    return CString(szName);
    }


// Return the path to szFilePath relative to szDirectory.  (E.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
// If szDirectory is NULL, the current directory is used.
//
CString GetRelativeName(const TCHAR* szFilePath, const TCHAR* szDirectory /*= NULL*/)
    {
    CString strDir;

    if ( szDirectory == NULL )
        {
        GetCurrentDirectory(_MAX_DIR, strDir.GetBuffer(_MAX_DIR) );
        strDir.ReleaseBuffer();
        strDir += (TCHAR)TEXT('\\');
        szDirectory = strDir;
        }

    int cchDirectory = lstrlen(szDirectory);
    if (_tcsnicmp(szFilePath, szDirectory, cchDirectory) == 0)
        return CString(szFilePath + cchDirectory);
    else if ( szFilePath[0] == szDirectory[0] &&
              szFilePath[1] == TEXT(':') && szDirectory[1] == TEXT(':') )    // Remove drive if same.
        return CString(szFilePath + 2);

    return CString(szFilePath);
    }
#if 0
/////////////////////////////////////////////////////////////////////////////
//  Taken from windows system code.  Contains intl support.
/* Returns: 0x00 if no matching char,
 *      0x01 if menmonic char is matching,
 *      0x80 if first char is matching
 */

#define CH_PREFIX TEXT('&')

int FindMnemChar(LPTSTR lpstr, TCHAR ch, BOOL fFirst, BOOL fPrefix)

    {
    register TCHAR chc;
    register TCHAR chnext;
    TCHAR      chFirst;

    while (*lpstr == TEXT(' '))
        lpstr++;

    ch = (TCHAR)(DWORD)CharLower((LPTSTR)(DWORD)(BYTE)ch);
    chFirst = (TCHAR)(DWORD)CharLower((LPTSTR)(DWORD)(BYTE)(*lpstr));

    #ifndef DBCS
    if (fPrefix)
        {
        while (chc = *lpstr++)
            {
            if (((TCHAR)(DWORD)CharLower((LPTSTR)(DWORD)(BYTE)chc) == CH_PREFIX))
                {
                chnext = (TCHAR)(DWORD)CharLower((LPTSTR)(DWORD)(BYTE)*lpstr);

                if (chnext == CH_PREFIX)
                    lpstr++;
                  else
                      if (chnext == ch)
                          return(0x01);
                      else
                          {
                          return(0x00);
                            }
                }
            }
        }
    #else
    #ifdef JAPAN
    if (fPrefix)
        {
        WORD wvch, xvkey;

        // get OEM-dependent virtual key code
        if ((wvch = VkKeyScan((BYTE)ch)) != -1)
        wvch &= 0xFF;

        while (chc = *lpstr++)
            {
            if (IsDBCSLeadByte(chc))
                {
                lpstr++;
                continue;
                }

            if ( (chc == CH_PREFIX) ||
               (KanjiMenuMode == KMM_ENGLISH && chc == CH_ENGLISHPREFIX) ||
               (KanjiMenuMode == KMM_KANJI   && chc == CH_KANJIPREFIX))
                {
                chnext = (TCHAR)CharLower((LPTSTR)(DWORD)(BYTE)*lpstr);

                if (chnext == CH_PREFIX)
                    lpstr++;
                else
                    if (chnext == ch)
                        return(0x01);

                // Compare should be done with virtual key in Kanji menu mode
                // in order to accept Digit shortcut key and save English
                // windows applications!
                xvkey = VkKeyScan((BYTE)chnext);

                if (xvkey != 0xFFFF && (xvkey & 0xFF) == wvch)
                    return(0x01);
                else
                    return(0x00);
                }
            }
        }
    #else
    #ifdef KOREA
    if( fPrefix )
        {
        WORD  wHangeul;
        register TCHAR  chnext2;

        if( KanjiMenuMode != KMM_KANJI )
            {
            while (chc = *lpstr++)
                {
                if (IsDBCSLeadByte(chc))
                    {
                    lpstr++;
                    continue;
                    }
                if ( (chc == CH_PREFIX) ||
                     (KanjiMenuMode == KMM_ENGLISH && chc == CH_ENGLISHPREFIX))
                    {
                    chnext = (TCHAR)CharLower((LPTSTR)(DWORD)(BYTE)*lpstr);

                    if (chnext == CH_PREFIX)
                        lpstr++;
                    else
                        if (chnext == ch)
                            return(0x01);
                        else
                            return(0x00);
                    }
                }
            }
        else
            { //KMM_KANJI
            if( ch >= TEXT('0') && ch <= TEXT('9') )
                wHangeul = 0x0a3b0 | ( (BYTE)ch & 0x0f );   // junja 0 + offset
            else
                if( ch >= TEXT('a') && ch <= TEXT('z') )
                    wHangeul = TranslateHangeul( ch );
                else
                    return(0x00);

            while (chc = *lpstr++)
                {
                if (IsDBCSLeadByte(chc))
                    {
                    lpstr++;
                    continue;
                    }
                if(chc == CH_KANJIPREFIX)
                    {
                    chnext = *lpstr++;
                    chnext2 = *lpstr;

                    if(chnext == HIBYTE(wHangeul) && chnext2 == LOBYTE(wHangeul))
                        return(0x01);
                    else
                        return(0x00);
                    }
                }
            }
    #endif  //KOREA
    #endif  //JAPAN
    #endif  //!DBCS

    if (fFirst && (ch == chFirst))
        return(0x80);

    return(0x00);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imageatt.h ===
// imageatt.h : header file
//
#include "imgdlgs.h"

typedef enum
    {
        ePIXELS = 0,
        eINCHES = 1,
        eCM     = 2
    } eUNITS;

/*************************** CImageAttr dialog *****************************/

class CImageAttr : public CDialog
    {
    // Construction
    public:

    CImageAttr(CWnd* pParent = NULL);   // standard constructor

    void SetWidthHeight(ULONG nWidthPixels, ULONG nHeightPixels, ULONG cXPelsPerMeter, ULONG cYPelsPerMeter);
    CSize GetWidthHeight(void);
    // Dialog Data
    //{{AFX_DATA(CImageAttr)
        enum { IDD = IDD_IMAGE_ATTRIBUTES };
        CString m_cStringWidth;
        CString m_cStringHeight;
        //}}AFX_DATA

    BOOL   m_bMonochrome;

    // Implementation
    protected:
    eUNITS m_eUnitsCurrent;
    BOOL   bEditFieldModified;

    ULONG   m_ulHeightPixels;
    ULONG   m_ulWidthPixels;
    ULONG   m_ulHeight;
    ULONG   m_ulWidth;
    ULONG   m_cXPelsPerMeter;
    ULONG   m_cYPelsPerMeter;

    COLORREF m_crTrans;
    void PaintTransBox ( COLORREF  );

    void  FixedFloatPtToString( CString& sString, ULONG ulFixedFloatPt );
    ULONG StringToFixedFloatPt( CString& sString );
    void  ConvertWidthHeight( void );
    void  PelsToCurrentUnit( void );
    void  SetNewUnits( eUNITS NewUnit );

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        virtual LONG OnHelp(WPARAM wParam, LPARAM lParam);
        virtual LONG OnContextMenu(WPARAM wParam, LPARAM lParam);

    // Generated message map functions
    //{{AFX_MSG(CImageAttr)
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        afx_msg void OnInches();
        afx_msg void OnCentimeters();
        afx_msg void OnPixels();
        afx_msg void OnChangeHeight();
        afx_msg void OnChangeWidth();
        afx_msg void OnDefault();
        afx_msg void OnUseTrans();
        afx_msg void OnSelectColor ();
        afx_msg void OnPaint();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    CString ReformatSizeString (DWORD dwNumber);
    void UpdateResolutionString();
    };

/*************************** CZoomViewDlg dialog ***************************/

class CZoomViewDlg : public CDialog
    {
    // Construction
    public:

    CZoomViewDlg(CWnd* pParent = NULL); // standard constructor

    // Dialog Data

    UINT m_nCurrent;

    //{{AFX_DATA(CZoomViewDlg)
        enum { IDD = IDD_VIEW_ZOOM };
        //}}AFX_DATA

    // Implementation
    protected:

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        virtual LONG OnHelp(WPARAM wParam, LPARAM lParam);
        virtual LONG OnContextMenu(WPARAM wParam, LPARAM lParam);

    // Generated message map functions
    //{{AFX_MSG(CZoomViewDlg)
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    };

/************************* CFlipRotateDlg dialog ***************************/

class CFlipRotateDlg : public CDialog
    {
    // Construction
    public:

    CFlipRotateDlg(CWnd* pParent = NULL);       // standard constructor

    // Dialog Data

    BOOL m_bHorz;
    BOOL m_bAngle;
    UINT m_nAngle;

    //{{AFX_DATA(CFlipRotateDlg)
    enum { IDD = IDD_FLIP_ROTATE };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // Implementation
    protected:

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        virtual LONG OnHelp(WPARAM wParam, LPARAM lParam);
        virtual LONG OnContextMenu(WPARAM wParam, LPARAM lParam);

    // Generated message map functions
    //{{AFX_MSG(CFlipRotateDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
        afx_msg void OnByAngle();
        afx_msg void OnNotByAngle();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    };

/********************** CStretchSkewDlg dialog *****************************/

class CStretchSkewDlg : public CDialog
    {
    // Construction
    public:

    CStretchSkewDlg(CWnd* pParent = NULL);      // standard constructor

    // Check that the direction was specified and subtract 100 to make it
    // equivalent to the 0 based system
 //   GetStretchHorz() { return(m_bStretchHorz ? m_iStretchHorz - 100 : 0); }
 //   GetStretchVert() { return(m_bStretchHorz ? 0 : m_iStretchVert - 100); }
    int GetStretchHorz() {return (m_iStretchHorz-100);}
    int GetStretchVert() {return (m_iStretchVert-100);}


    // Check that the direction was specified
  //  GetSkewHorz() { return(m_bSkewHorz ? m_wSkewHorz : 0); }
   // GetSkewVert() { return(m_bSkewHorz ? 0 : m_wSkewVert); }
    int GetSkewHorz() { return(m_wSkewHorz); }
    int GetSkewVert() { return(m_wSkewVert); }

    private:

    // Dialog Data
    //{{AFX_DATA(CStretchSkewDlg)
        enum { IDD = IDD_STRETCH_SKEW };

    int    m_wSkewHorz;
    int    m_wSkewVert;
    int     m_iStretchVert;
    int     m_iStretchHorz;
        //}}AFX_DATA

    // Implementation
    protected:

    BOOL    m_bStretchHorz;
    BOOL    m_bSkewHorz;

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        virtual LONG OnHelp(WPARAM wParam, LPARAM lParam);
        virtual LONG OnContextMenu(WPARAM wParam, LPARAM lParam);

    // Generated message map functions
    //{{AFX_MSG(CStretchSkewDlg)
    // TODO
    // these are commented out of the message map. delete them?
    virtual void OnOK();
    virtual BOOL OnInitDialog();
        afx_msg void OnSkewHorz();
        afx_msg void OnSkewVert();
        afx_msg void OnStretchHorz();
        afx_msg void OnStretchVert();
        //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imaging.cpp ===
#include "stdafx.h"
#include "resource.h"

#include <process.h>

#include "bar.h"
#include "pbrush.h"
#include "imaging.h"

//////////////////////////////////////////////////////////////////////////
//
// Trace
//

#ifdef DBG

void AFX_CDECL Trace(PCTSTR pszFormat, ...)
{
    va_list argList;
    va_start(argList, pszFormat);

    CString strMessage;
    strMessage.FormatV(pszFormat, argList);

    OutputDebugString(strMessage);

    va_end(argList);
}

#else //DBG

inline void AFX_CDECL Trace(PCTSTR pszFormat, ...)
{
}

#endif DBG

//////////////////////////////////////////////////////////////////////////
//
//
//

CImagingMgr::~CImagingMgr()
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CWIAMgr::CWIAMgr()
{
    HRESULT hr;

    m_pEventCallback = new CEventCallback();

    if (m_pEventCallback)
    {
        hr = m_pEventCallback->Register();

        if (hr != S_OK)
        {
            m_pEventCallback.Release();
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CWIAMgr::SelectSource(
    HWND hWndParent,
    LONG lFlags
)
{
    HRESULT hr = S_FALSE;

    // Create a connection to the local WIA device manager

    CComPtr<IWiaDevMgr> pWiaDevMgr;

    hr = pWiaDevMgr.CoCreateInstance(CLSID_WiaDevMgr);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // clear the current selection (if any)

    m_bstrDeviceID.Empty();

    // display the device selection dialog

    hr = pWiaDevMgr->SelectDeviceDlgID(
        hWndParent,
        StiDeviceTypeDefault,
        lFlags,
        &m_bstrDeviceID
    );

    theApp.RestoreWaitCursor();

    if (hr != S_OK)
    {
        Trace(_T("SelectDeviceDlgID HRESULT=%08x\n"), hr);
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CWIAMgr::Select(
    LPCTSTR pDeviceId
)
{
    m_bstrDeviceID = pDeviceId;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT ReadPropertyLong(IWiaItem *pWiaItem, PROPID propid, LONG *lResult)
{
    if (!lResult)
    {
        return E_POINTER;
    }

    HRESULT hr = S_FALSE;

    CComQIPtr<IWiaPropertyStorage> pWiaPropertyStorage(pWiaItem);

    if (pWiaPropertyStorage == 0)
    {
        return E_NOINTERFACE;
    }

    PROPSPEC PropSpec;

    PropSpec.ulKind = PRSPEC_PROPID;
    PropSpec.propid = propid;

    PROPVARIANT PropVariant;

    PropVariantInit(&PropVariant);

    hr = pWiaPropertyStorage->ReadMultiple(1, &PropSpec, &PropVariant);

    if (hr != S_OK)
    {
        Trace(_T("ReadMultiple HRESULT=%08x\n"), hr);
        return hr;
    }

    switch (PropVariant.vt)
    {
        case VT_I1:   *lResult = (LONG) PropVariant.cVal;    break;
        case VT_UI1:  *lResult = (LONG) PropVariant.bVal;    break;
        case VT_I2:   *lResult = (LONG) PropVariant.iVal;    break;
        case VT_UI2:  *lResult = (LONG) PropVariant.uiVal;   break;
        case VT_I4:   *lResult = (LONG) PropVariant.lVal;    break;
        case VT_UI4:  *lResult = (LONG) PropVariant.ulVal;   break;
        case VT_INT:  *lResult = (LONG) PropVariant.intVal;  break;
        case VT_UINT: *lResult = (LONG) PropVariant.uintVal; break;
        case VT_R4:   *lResult = (LONG) (PropVariant.fltVal + 0.5); break;
        case VT_R8:   *lResult = (LONG) (PropVariant.dblVal + 0.5); break;
        default:      hr = S_FALSE; break;
    }

    PropVariantClear(&PropVariant);

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CWIAMgr::Acquire(
    HWND     hWndParent,
    HGLOBAL *phDib
)
{
    ASSERT(phDib != 0);

    HRESULT hr;

    // Create a connection to the local WIA device manager

    CComPtr<IWiaDevMgr> pWiaDevMgr;

    hr = pWiaDevMgr.CoCreateInstance(CLSID_WiaDevMgr);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // Create the device object.
    // Select the device first if
    //   no device has been selected before or
    //   we fail to create the device with the selected ID

    CComPtr<IWiaItem> pRootItem;

    if (!m_bstrDeviceID ||
        !SUCCEEDED(pWiaDevMgr->CreateDevice(m_bstrDeviceID, &pRootItem)))
    {
        // clear the current selection (if any)

        m_bstrDeviceID.Empty();

        // display the device selection dialog

        hr = pWiaDevMgr->SelectDeviceDlg(
            hWndParent,
            StiDeviceTypeDefault,
            0,
            &m_bstrDeviceID,
            &pRootItem
        );

        theApp.RestoreWaitCursor();

        if (hr != S_OK)
        {
            Trace(_T("SelectDeviceDlg HRESULT=%08x\n"), hr);
            return hr;
        }

#ifndef USE_SELECTSOURCE_MENUITEM

        // forget the current selection

        m_bstrDeviceID.Empty();

#endif //!USE_SELECTSOURCE_MENUITEM

        if (!SUCCEEDED(hr)) 
        {
            Trace(_T("CreateDevice HRESULT=%08x\n"), hr);
            return hr;
        }
    }

    // display the image selection dialog and let the user
    // select the item to be transferred

    CComPtrArray<IWiaItem> ppIWiaItem;

    hr = pRootItem->DeviceDlg(
        hWndParent,
        WIA_DEVICE_DIALOG_SINGLE_IMAGE,
        WIA_INTENT_NONE,
        &ppIWiaItem.ItemCount(),
        &ppIWiaItem
    );

    theApp.RestoreWaitCursor();

    if (hr != S_OK)
    {
        Trace(_T("DeviceDlg HRESULT=%08x\n"), hr);
        return hr;
    }

    if (ppIWiaItem.ItemCount() == 0)
    {
        Trace(_T("DeviceDlg returned 0 items\n"));
        return E_FAIL;
    }

    // set the image transfer properties; we want a DIB memory transfer

    TYMED tymed      = (TYMED) TYMED_CALLBACK;
    GUID  guidFormat = WiaImgFmt_MEMORYBMP;

    PROPSPEC    PropSpec[2]    = { 0 };
    PROPVARIANT PropVariant[2] = { 0 };

    PropSpec[0].ulKind   = PRSPEC_PROPID;
    PropSpec[0].propid   = WIA_IPA_TYMED;
    PropVariant[0].vt    = VT_I4;
    PropVariant[0].lVal  = tymed;

    PropSpec[1].ulKind   = PRSPEC_PROPID;
    PropSpec[1].propid   = WIA_IPA_FORMAT;
    PropVariant[1].vt    = VT_CLSID;
    PropVariant[1].puuid = &guidFormat;

    CComQIPtr<IWiaPropertyStorage> pWiaPropertyStorage(ppIWiaItem[0]);

    if (pWiaPropertyStorage == 0)
    {
        return E_NOINTERFACE;
    }

    hr = pWiaPropertyStorage->WriteMultiple(
        1,
        &(PropSpec[0]),
        &(PropVariant[0]),
        WIA_IPA_FIRST
    );

    if (hr != S_OK)
    {
        Trace(_T("WriteMultiple HRESULT=%08x\n"), hr);
        return hr;
    }

    hr = pWiaPropertyStorage->WriteMultiple(
        1,
        &(PropSpec[1]),
        &(PropVariant[1]),
        WIA_IPA_FIRST
    );

    if (hr != S_OK)
    {
        Trace(_T("WriteMultiple HRESULT=%08x\n"), hr);
        return hr;
    }

    // now, determine the transfer buffer size

    // 64k transfer size and double buffering seem to work fine;
    // a smaller buffer considerably slows down the memory transfer
    // and a larger buffer doesn't give much speed increase.
    // If the device minimum is larger than 64k though, use that size...

    LONG lBufferSize;

    hr = ReadPropertyLong(ppIWiaItem[0], WIA_IPA_MIN_BUFFER_SIZE, &lBufferSize);

    if (hr != S_OK || lBufferSize < 64*1024)
    {
        lBufferSize = 64*1024;
    }

    // setup the progress dialog 

    CComPtr<IWiaProgressDialog> pProgress;

    hr = CoCreateInstance( 
        CLSID_WiaDefaultUi, 
        0, 
        CLSCTX_INPROC_SERVER, 
        IID_IWiaProgressDialog, 
        (void**) &pProgress
    );

    if (hr != S_OK)
    {
        pProgress = new CProgressDialog;
    }

    LONG nDeviceType;

    hr = ReadPropertyLong(pRootItem, WIA_DIP_DEV_TYPE, &nDeviceType);
    
    if (hr != S_OK)
    {
        nDeviceType = 0;
    }

    LONG lAnimFlag;

    switch (GET_STIDEVICE_TYPE(nDeviceType))
    {
        case StiDeviceTypeScanner:
            lAnimFlag = WIA_PROGRESSDLG_ANIM_SCANNER_ACQUIRE;
            break;

        case StiDeviceTypeDigitalCamera:
            lAnimFlag = WIA_PROGRESSDLG_ANIM_CAMERA_ACQUIRE;
            break;

        case StiDeviceTypeStreamingVideo:
            lAnimFlag = WIA_PROGRESSDLG_ANIM_VIDEO_ACQUIRE;
            break;

        default:
            lAnimFlag = WIA_PROGRESSDLG_NO_ANIM;
            break;
    }

    pProgress->Create(hWndParent, lAnimFlag);

    CString strDownloading;
    strDownloading.LoadString(IDS_DOWNLOAD_IMAGE);

    USES_CONVERSION;
    pProgress->SetTitle(T2CW(strDownloading));

    pProgress->SetMessage(L"");

    pProgress->Show();

    // init the data callback interface

    CDataCallback *pDataCallback = new CDataCallback(pProgress);

    if (!pDataCallback)
    {
        theApp.SetMemoryEmergency(TRUE);
        return E_OUTOFMEMORY;
    }

    CComQIPtr<IWiaDataCallback> pIWiaDataCallback(pDataCallback);

    ASSERT(pIWiaDataCallback != 0);

    // initiate the transfer

    CComQIPtr<IWiaDataTransfer> pIWiaDataTransfer(ppIWiaItem[0]);

    if (pIWiaDataTransfer == 0)
    {
        return E_NOINTERFACE;
    }

    WIA_DATA_TRANSFER_INFO WiaDataTransferInfo = { 0 };

    WiaDataTransferInfo.ulSize        = sizeof(WIA_DATA_TRANSFER_INFO);
    WiaDataTransferInfo.ulBufferSize  = 2 * lBufferSize;
    WiaDataTransferInfo.bDoubleBuffer = TRUE;

    // This *easy* solution will cause the mspaint UI to freeze during
    // image transfer; this is possibly too long time to remain frozen.
    // So we will create a worker thread to do the data transfer.
    //
    //hr = pIWiaDataTransfer->idtGetBandedData(
    //    &WiaDataTransferInfo,
    //    pIWiaDataCallback
    //);

    EnableWindow(hWndParent, FALSE);

    hr = GetBandedData(CGetBandedDataThreadData(
        pIWiaDataTransfer,
        &WiaDataTransferInfo,
        pIWiaDataCallback
    ));

    EnableWindow(hWndParent, TRUE);

    // check if the user has pressed cancel

    if (pProgress)
    {
        BOOL bCancelled;

        if (pProgress->Cancelled(&bCancelled) == S_OK && bCancelled)
        {
            hr = S_FALSE;
        }

        pProgress->Destroy();
    }

    if (hr != S_OK)
    {
        Trace(_T("idtGetBandedData HRESULT=%08x\n"), hr);
        return hr;
    }

    // return the results

    pDataCallback->PrintTimes();

    *phDib = pDataCallback->GetBuffer();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CWIAMgr::CGetBandedDataThreadData::CGetBandedDataThreadData(
    IWiaDataTransfer       *pIWiaDataTransfer,
    WIA_DATA_TRANSFER_INFO *pWiaDataTransferInfo,
    IWiaDataCallback       *pIWiaDataCallback
) :
    m_pIWiaDataTransfer(pIWiaDataTransfer),
    m_pWiaDataTransferInfo(pWiaDataTransferInfo),
    m_pIWiaDataCallback(pIWiaDataCallback)
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CWIAMgr::CGetBandedDataThreadData::Marshal()
{
    HRESULT hr;

    // marshal the IWiaDataTransfer interface

    ASSERT(m_pIWiaDataTransfer != 0);

    hr = CoMarshalInterThreadInterfaceInStream(
        IID_IWiaDataTransfer,
        m_pIWiaDataTransfer,
        &m_pIWiaDataTransferStream
    );

    if (hr != S_OK)
    {
        Trace(_T("CoMarshalInterThreadInterfaceInStream HRESULT=%08x\n"), hr);
        return hr;
    }

    m_pIWiaDataTransfer.Release();

    // marshal the IWiaDataCallback interface

    ASSERT(m_pIWiaDataCallback != 0);

    hr = CoMarshalInterThreadInterfaceInStream(
        IID_IWiaDataCallback,
        m_pIWiaDataCallback,
        &m_pIWiaDataCallbackStream
    );

    if (hr != S_OK)
    {
        Trace(_T("CoMarshalInterThreadInterfaceInStream HRESULT=%08x\n"), hr);
        return hr;
    }

    m_pIWiaDataCallback.Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CWIAMgr::CGetBandedDataThreadData::Unmarshal()
{
    HRESULT hr;

    // unmarshal the IWiaDataTransfer interface

    ASSERT(m_pIWiaDataTransferStream != 0);

    hr = CoGetInterfaceAndReleaseStream(
        m_pIWiaDataTransferStream,
        IID_IWiaDataTransfer,
        (void **) &m_pIWiaDataTransfer
    );

    // CoGetInterfaceAndReleaseStream should already have
    // released the stream pointer, so set it to zero so that
    // ~CGetBandedDataThreadData will not try to release it again

    m_pIWiaDataTransferStream.Detach();

    if (hr != S_OK)
    {
        Trace(_T("CoGetInterfaceAndReleaseStream HRESULT=%08x\n"), hr);
        return hr;
    }

    // unmarshal the IWiaDataCallback interface

    ASSERT(m_pIWiaDataCallbackStream != 0);

    hr = CoGetInterfaceAndReleaseStream(
        m_pIWiaDataCallbackStream,
        IID_IWiaDataCallback,
        (void **) &m_pIWiaDataCallback
    );

    m_pIWiaDataCallbackStream.Detach();

    if (hr != S_OK)
    {
        Trace(_T("CoGetInterfaceAndReleaseStream HRESULT=%08x\n"), hr);
        return hr;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CWIAMgr::GetBandedData(CGetBandedDataThreadData &ThreadData)
{
    // marshal the interface pointers before passing them to another thread

    HRESULT hr = ThreadData.Marshal();

    if (hr != S_OK)
    {
        return hr;
    }

    // fire up the new thread

    unsigned nThreadId;

    HANDLE hThread = (HANDLE) _beginthreadex(
        0,
        0,
        GetBandedDataThread,
        &ThreadData,
        0,
        &nThreadId
    );

    if (hThread == 0)
    {
        Trace(_T("CreateThread LastError=%08x\n"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // enter a msg loop while waiting for the thread to complete;
    // this will keep the mspaint UI alive

    while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) == WAIT_OBJECT_0+1)
    {
        MSG msg;

        while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        theApp.RestoreWaitCursor();
    }

    // if we reach here, the thread must have ended; get the result

    DWORD dwExitCode = S_FALSE;

    GetExitCodeThread(hThread, &dwExitCode);

    // in case the thread is still alive (shouldn't happen), kill it

    if (dwExitCode == STILL_ACTIVE)
    {
        TerminateThread(hThread, 0);
        dwExitCode = E_FAIL;
    }

    CloseHandle(hThread);

    ASSERT(sizeof(DWORD) >= sizeof(HRESULT));
    return (HRESULT) dwExitCode;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

unsigned WINAPI CWIAMgr::GetBandedDataThread(PVOID pVoid)
{
    // Init COM for this thread

    HRESULT hr = CoInitialize(0);

    if (hr != S_OK)
    {
        Trace(_T("CoInitialize HRESULT=%08x\n"), hr);
        return (unsigned) hr;
    }

    CGetBandedDataThreadData *pThreadData = (CGetBandedDataThreadData *) pVoid;

    ASSERT(pThreadData != 0);

    if (pThreadData != 0)
    {
        // unmarshal the interface pointers before calling idtGetBandedData

        hr = pThreadData->Unmarshal();

        if (hr == S_OK)
        {
            hr = pThreadData->m_pIWiaDataTransfer->idtGetBandedData(
                pThreadData->m_pWiaDataTransferInfo,
                pThreadData->m_pIWiaDataCallback
            );
        }
    }

    CoUninitialize();

    ASSERT(sizeof(unsigned) >= sizeof(HRESULT));
    return (unsigned) hr;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

int CWIAMgr::NumDevices(HWND /*hWndParent*/)
{
    return m_pEventCallback ? m_pEventCallback->GetNumDevices() : 0;
}

#ifdef USE_TWAIN

//////////////////////////////////////////////////////////////////////////
//
//
//

CTwainMgr::CTwainMgr()
{
    m_TwainState = State_1_Pre_Session;

    // fill in the m_AppId struct with defaults

    m_AppId.Id = 0;
    m_AppId.Version.MajorNum = 1;
    m_AppId.Version.MinorNum = 0;
    m_AppId.Version.Language = TWLG_USA;
    m_AppId.Version.Country  = TWCY_USA;
    strcpy(m_AppId.Version.Info,  "FileDescription");
    m_AppId.ProtocolMajor   = TWON_PROTOCOLMAJOR;
    m_AppId.ProtocolMinor   = TWON_PROTOCOLMINOR;
    m_AppId.SupportedGroups = DG_IMAGE | DG_CONTROL;
    strcpy(m_AppId.Manufacturer,  "CompanyName");
    strcpy(m_AppId.ProductFamily, "ProductVersion");
    strcpy(m_AppId.ProductName,   "ProductName");

    // reset m_SrcId

    m_SrcId.Id = 0;
    m_SrcId.ProductName[0] = '\0';

    // Load TWAIN DLL

    m_hTwainDll = LoadLibrary(_T("TWAIN_32.DLL"));

    if (m_hTwainDll)
    {
        // Get the entry point

        m_DSM_Entry = (DSMENTRYPROC) GetProcAddress(m_hTwainDll, "DSM_Entry");

        if (m_DSM_Entry)
        {
            m_TwainState = State_2_Source_Manager_Loaded;
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CTwainMgr::~CTwainMgr()
{
    // Free the library if loaded

    if (m_TwainState >= State_1_Pre_Session)
    {
        FreeLibrary(m_hTwainDll);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CTwainMgr::SelectSource(
    HWND hWndParent,
    LONG /*lFlags*/
)
{
    HRESULT   hr = S_FALSE;
    TW_UINT16 rc = TWRC_FAILURE;

    if (m_TwainState >= State_2_Source_Manager_Loaded)
    {
        __try
        {
            if (m_TwainState == State_2_Source_Manager_Loaded)
            {
                // Open the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_OPENDSM,
                    (TW_MEMREF) &hWndParent
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_3_Source_Manager_Open;
            }

            // pop up the selection dialog

            rc = m_DSM_Entry(
                &m_AppId,
                0,
                DG_CONTROL,
                DAT_IDENTITY,
                MSG_USERSELECT,
                (TW_MEMREF) &m_SrcId
            );

            ASSERT(rc == TWRC_SUCCESS || rc == TWRC_CANCEL);

            if (rc == TWRC_SUCCESS)
            {
                hr = S_OK;
            }
        }
        __finally
        {
            if (m_TwainState == State_3_Source_Manager_Open)
            {
                // Close the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_CLOSEDSM,
                    (TW_MEMREF) &hWndParent
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_2_Source_Manager_Loaded;
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CTwainMgr::Select(
    LPCTSTR pDeviceId
)
{
#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, pDeviceId, -1,
        m_SrcId.ProductName, sizeof(m_SrcId.ProductName), 0, 0);
#else //UNICODE
    lstrcpyn(m_SrcId.ProductName, pDeviceId, sizeof(m_SrcId.ProductName));
#endif //UNICODE

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CTwainMgr::Acquire(
    HWND     hWndParent,
    HGLOBAL *phDib
)
{
    ASSERT(phDib);

    HRESULT   hr = S_FALSE;
    TW_UINT16 rc = TWRC_FAILURE;

    if (m_TwainState >= State_2_Source_Manager_Loaded)
    {
        __try
        {
            if (m_TwainState == State_2_Source_Manager_Loaded)
            {
                // Open the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_OPENDSM,
                    (TW_MEMREF) &hWndParent
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_3_Source_Manager_Open;
            }

#ifdef USE_SELECTSOURCE_MENUITEM

            if (m_SrcId.ProductName[0] == '\0')
            {
                // if no data source is selected yet, get the default

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_IDENTITY,
                    MSG_GETDEFAULT,
                    (TW_MEMREF) &m_SrcId
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }
            }

#else //USE_SELECTSOURCE_MENUITEM

            rc = m_DSM_Entry(
                &m_AppId,
                0,
                DG_CONTROL,
                DAT_IDENTITY,
                MSG_USERSELECT,
                (TW_MEMREF) &m_SrcId
            );

            ASSERT(rc == TWRC_SUCCESS || rc == TWRC_CANCEL);

            if (rc != TWRC_SUCCESS)
            {
                __leave;
            }

#endif //USE_SELECTSOURCE_MENUITEM

            if (m_TwainState == State_3_Source_Manager_Open)
            {
                // open the data source

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_IDENTITY,
                    MSG_OPENDS,
                    (TW_MEMREF) &m_SrcId
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_4_Source_Open;
            }

            // set the desired transfer options;
            // we want to transfer a single 8-bit RGB image

            SetCapability(CAP_XFERCOUNT, TWTY_INT16, 1);
            SetCapability(ICAP_PIXELTYPE, TWTY_UINT32, TWPT_RGB);
            SetCapability(ICAP_BITDEPTH, TWTY_UINT32, 8);

            if (m_TwainState == State_4_Source_Open)
            {
                // enable the data source

                TW_USERINTERFACE twUI;

                twUI.ShowUI  = TRUE;
                twUI.hParent = hWndParent;

                rc = m_DSM_Entry(
                    &m_AppId,
                    &m_SrcId,
                    DG_CONTROL,
                    DAT_USERINTERFACE,
                    MSG_ENABLEDS,
                    (TW_MEMREF) &twUI
                );

                theApp.RestoreWaitCursor();

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_5_Source_Enabled;
            }

            if (m_TwainState == State_5_Source_Enabled)
            {
                // Disable the parent window

                EnableWindow(hWndParent, FALSE);

                // Enter the message loop to transfer the image

                MSG   msg;
                BOOL  bDone = FALSE;

                while (!bDone && GetMessage(&msg, 0, 0, 0))
                {
                    // process the event through TWAIN

                    TW_EVENT twEvent;

                    twEvent.pEvent    = &msg;
                    twEvent.TWMessage = MSG_NULL;

                    rc = m_DSM_Entry(
                        &m_AppId,
                        &m_SrcId,
                        DG_CONTROL,
                        DAT_EVENT,
                        MSG_PROCESSEVENT,
                        (TW_MEMREF) &twEvent
                    );

                    if (twEvent.TWMessage == MSG_CLOSEDSREQ)
                    {
                        bDone = TRUE;
                        hr = S_FALSE;
                    }
                    else if (twEvent.TWMessage == MSG_XFERREADY)
                    {

                        m_TwainState = State_6_Transfer_Ready;

                        TW_PENDINGXFERS twPendingXfers;

                        do
                        {
                            m_TwainState = State_7_Transferring;

                            rc = m_DSM_Entry(
                                &m_AppId,
                                &m_SrcId,
                                DG_IMAGE,
                                DAT_IMAGENATIVEXFER,
                                MSG_GET,
                                (TW_MEMREF) phDib
                            );

                            if (rc != TWRC_XFERDONE)
                            {
                                if (*phDib)
                                {
                                    GlobalFree(*phDib);
                                }

                                __leave;
                            }

                            hr = S_OK;

                            // End the transfer

                            rc = m_DSM_Entry(
                                &m_AppId,
                                &m_SrcId,
                                DG_CONTROL,
                                DAT_PENDINGXFERS,
                                MSG_ENDXFER,
                                (TW_MEMREF) &twPendingXfers
                            );

                            if (rc != TWRC_SUCCESS)
                            {
                                __leave;
                            }

                            m_TwainState = State_6_Transfer_Ready;

                        } while (twPendingXfers.Count != 0);

                        m_TwainState = State_5_Source_Enabled;

                        //exit after a single image transfer

                        bDone = TRUE;
                    }

                    if (rc == TWRC_NOTDSEVENT)
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
        }
        __finally
        {
            // enable the parent window upon exiting the message loop

            EnableWindow(hWndParent, TRUE);

            ASSERT(m_TwainState <= State_6_Transfer_Ready);

            if (m_TwainState == State_6_Transfer_Ready)
            {
                TW_PENDINGXFERS twPendingXfers;

                rc = m_DSM_Entry(
                    &m_AppId,
                    &m_SrcId,
                    DG_CONTROL,
                    DAT_PENDINGXFERS,
                    MSG_RESET,
                    (TW_MEMREF) &twPendingXfers
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_5_Source_Enabled;
            }

            if (m_TwainState == State_5_Source_Enabled)
            {
                TW_USERINTERFACE twUI;

                rc = m_DSM_Entry(
                    &m_AppId,
                    &m_SrcId,
                    DG_CONTROL,
                    DAT_USERINTERFACE,
                    MSG_DISABLEDS,
                    (TW_MEMREF) &twUI
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_4_Source_Open;
            }

            if (m_TwainState == State_4_Source_Open)
            {
                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_IDENTITY,
                    MSG_CLOSEDS,
                    (TW_MEMREF) &m_SrcId
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_3_Source_Manager_Open;
            }

            if (m_TwainState == State_3_Source_Manager_Open)
            {
                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_CLOSEDSM,
                    (TW_MEMREF) &hWndParent
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_2_Source_Manager_Loaded;
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

int CTwainMgr::NumDevices(HWND hWndParent)
{
    return 1; // this is too slow, better lie...

    int nNumDevices = 0;

    TW_UINT16 rc = TWRC_FAILURE;

    // m_TwainState >= State_2 guarantees m_DSM_Entry != 0

    if (m_TwainState >= State_2_Source_Manager_Loaded)
    {
        __try
        {
            if (m_TwainState == State_2_Source_Manager_Loaded)
            {
                // Open the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_OPENDSM,
                    (TW_MEMREF) &hWndParent
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_3_Source_Manager_Open;
            }

            // Enumerate the devices one by one

            TW_IDENTITY SrcId;

            rc = m_DSM_Entry(
                &m_AppId,
                0,
                DG_CONTROL,
                DAT_IDENTITY,
                MSG_GETFIRST,
                (TW_MEMREF) &SrcId
            );

            while (rc == TWRC_SUCCESS)
            {
                ++nNumDevices;

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_IDENTITY,
                    MSG_GETNEXT,
                    (TW_MEMREF) &SrcId
                );
            }
        }
        __finally
        {
            if (m_TwainState == State_3_Source_Manager_Open)
            {
                // Close the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_CLOSEDSM,
                    (TW_MEMREF) &hWndParent
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_2_Source_Manager_Loaded;
            }
        }
    }

    return nNumDevices;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

TW_UINT16
CTwainMgr::SetCapability(
    TW_UINT16 Cap,
    TW_UINT16 ItemType,
    TW_UINT32 Item
)
{
    TW_UINT16 rc = TWRC_FAILURE;

    TW_CAPABILITY twCapability;

    twCapability.Cap        = Cap;
    twCapability.ConType    = TWON_ONEVALUE;
    twCapability.hContainer = 0;

    twCapability.hContainer = GlobalAlloc(
        GMEM_MOVEABLE | GMEM_ZEROINIT,
        sizeof(TW_ONEVALUE)
    );

    if (twCapability.hContainer) 
    {
        pTW_ONEVALUE pVal = (pTW_ONEVALUE) GlobalLock(twCapability.hContainer);

        if (pVal) 
        {
            pVal->ItemType = ItemType;
            pVal->Item     = Item;

            GlobalUnlock(twCapability.hContainer);

            rc = m_DSM_Entry(
                &m_AppId,
                &m_SrcId,
                DG_CONTROL,
                DAT_CAPABILITY,
                MSG_SET,
                (TW_MEMREF) &twCapability
            );
        }

        GlobalFree(twCapability.hContainer);
    }

    return rc;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

TW_UINT16
CTwainMgr::GetCapability(
    TW_UINT16   Cap,
    pTW_UINT16  pItemType,
    pTW_UINT32  pItem
)
{
    TW_CAPABILITY twCapability;

    twCapability.Cap        = Cap;
    twCapability.ConType    = TWON_DONTCARE16;
    twCapability.hContainer = 0;

    TW_UINT16 rc = m_DSM_Entry(
        &m_AppId,
        &m_SrcId,
        DG_CONTROL,
        DAT_CAPABILITY,
        MSG_GET,
        (TW_MEMREF) &twCapability
    );

    if (twCapability.hContainer) 
    {
        pTW_ONEVALUE pVal = (pTW_ONEVALUE) GlobalLock(twCapability.hContainer);

        if (pVal) 
        {
            if (pItemType) 
            {
                *pItemType = pVal->ItemType;
            }

            if (pItem) 
            {
                *pItem = pVal->Item;
            }
        }

        GlobalFree(twCapability.hContainer);
    }

    return rc;
}

#endif //USE_TWAIN

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT 
WiaGetNumDevices(
    IWiaDevMgr *_pWiaDevMgr,
    ULONG      *pulNumDevices
)
{
    HRESULT hr;

    // Validate and initialize output parameters

    if (pulNumDevices == 0)
    {
        return E_POINTER;
    }

    *pulNumDevices = 0;

    // Create a connection to the local WIA device manager

    CComPtr<IWiaDevMgr> pWiaDevMgr = _pWiaDevMgr;

    if (pWiaDevMgr == 0)
    {
        hr = pWiaDevMgr.CoCreateInstance(CLSID_WiaDevMgr);

        if (!SUCCEEDED(hr))
        {
            return hr;
        }
    }

    // Get a list of all the WIA devices on the system

    CComPtr<IEnumWIA_DEV_INFO> pIEnumWIA_DEV_INFO;

    hr = pWiaDevMgr->EnumDeviceInfo(
        0,
        &pIEnumWIA_DEV_INFO
    );

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // Get the number of WIA devices

    ULONG celt;

    hr = pIEnumWIA_DEV_INFO->GetCount(&celt);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    *pulNumDevices = celt;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

CEventCallback::CEventCallback()
{
    m_cRef = 0;
    m_nNumDevices = 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

HRESULT CEventCallback::Register()
{
    HRESULT hr;

    // Create a connection to the local WIA device manager

    CComPtr<IWiaDevMgr> pWiaDevMgr;

    hr = pWiaDevMgr.CoCreateInstance(CLSID_WiaDevMgr);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // Get the count of all the WIA devices on the system

    hr = WiaGetNumDevices(pWiaDevMgr, &m_nNumDevices);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // Register the callback interface

    hr = pWiaDevMgr->RegisterEventCallbackInterface(
        0,
        0,
        &WIA_EVENT_DEVICE_CONNECTED,
        this,
        &m_pConnectEventObject
    );

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pWiaDevMgr->RegisterEventCallbackInterface(
        0,
        0,
        &WIA_EVENT_DEVICE_DISCONNECTED,
        this,
        &m_pDisconnectEventObject
    );

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

ULONG CEventCallback::GetNumDevices() const
{
    return m_nNumDevices;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CEventCallback::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (ppvObj == 0)
    {
	    return E_POINTER;
    }

    if (iid == IID_IUnknown)
    {
	    AddRef();
	    *ppvObj = (IUnknown *) this;
	    return S_OK;
    }

    if (iid == IID_IWiaEventCallback)
    {
	    AddRef();
	    *ppvObj = (IWiaEventCallback *) this;
	    return S_OK;
    }

    *ppvObj = 0;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CEventCallback::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CEventCallback::Release()
{
    LONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CEventCallback::ImageEventCallback(
    LPCGUID pEventGuid,
    BSTR    bstrEventDescription,
    BSTR    bstrDeviceID,
    BSTR    bstrDeviceDescription,
    DWORD   dwDeviceType,
    BSTR    bstrFullItemName,
    ULONG  *pulEventType,
    ULONG   ulReserved
)
{
    return WiaGetNumDevices(0, &m_nNumDevices);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CDataCallback::CDataCallback(IWiaProgressDialog *pProgress)
{
    m_cRef        = 0;
    m_hBuffer     = 0;
    m_lBufferSize = 0;
    m_lDataSize   = 0;
    m_pProgress   = pProgress;

#ifdef DBG
    m_hDumpFile = CreateFile(_T("wiadump.bin"), GENERIC_WRITE, 
        FILE_SHARE_READ, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    m_TimeDeviceBegin.QuadPart  = 0;
    m_TimeDeviceEnd.QuadPart    = 0;
    m_TimeProcessBegin.QuadPart = 0;
    m_TimeProcessEnd.QuadPart   = 0;
    m_TimeClientBegin.QuadPart  = 0;
    m_TimeClientEnd.QuadPart    = 0;
#endif //DBG
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CDataCallback::~CDataCallback()
{
    if (m_hBuffer)
    {
        GlobalFree(m_hBuffer);
    }

#ifdef DBG
    CloseHandle(m_hDumpFile);
#endif //DBG
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HGLOBAL CDataCallback::GetBuffer()
{
    HGLOBAL hBuffer = m_hBuffer;

    m_hBuffer     = 0;
    m_lBufferSize = 0;
    m_lDataSize   = 0;

    return hBuffer;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CDataCallback::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (ppvObj == 0)
    {
        return E_POINTER;
    }

    if (iid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*) this;
        return S_OK;
    }

    if (iid == IID_IWiaDataCallback)
    {
        AddRef();
        *ppvObj = (IWiaDataCallback *) this;
        return S_OK;
    }

    *ppvObj = 0;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CDataCallback::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CDataCallback::Release()
{
    LONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CDataCallback::BandedDataCallback(
    LONG  lReason,
    LONG  lStatus,
    LONG  lPercentComplete,
    LONG  lOffset,
    LONG  lLength,
    LONG  lReserved,
    LONG  lResLength,
    PBYTE pbBuffer
)
{
    HRESULT hr;

    Trace(
        _T("DataCallback: Reason=%d Stat=%d %%=%d Offset=%d Length=%d Buf=%p\n"),
        lReason, lStatus, lPercentComplete, lOffset, lLength, pbBuffer
    );

    // check if the user has pressed cancel

    BOOL bCancelled;

    if (m_pProgress && m_pProgress->Cancelled(&bCancelled) == S_OK && bCancelled)
    {
        return S_FALSE;
    }

    switch (lReason)
    {
        case IT_MSG_DATA_HEADER:
        {
            // allocate memory for the image if the size is given in the header

            PWIA_DATA_CALLBACK_HEADER pHeader = (PWIA_DATA_CALLBACK_HEADER) pbBuffer;

            if (pHeader && pHeader->lBufferSize)
            {
                hr = ReAllocBuffer(pHeader->lBufferSize);

                if (hr != S_OK)
                {
                    return S_FALSE;
                }
            }
        
            break;
        }

        case IT_MSG_DATA:
        {
            QueryStartTimes(lStatus, lPercentComplete);

            UpdateStatus(lStatus, lPercentComplete);

            // if the buffer is not allocated yet and this is the first block, 
            // try to allocate a buffer according to the bitmap header info

            if (m_lBufferSize == 0 && lOffset == 0)
            {
                LONG lBufferSize = FindDibSize(pbBuffer);

                if (lBufferSize)
                {
                    hr = ReAllocBuffer(lBufferSize);

                    if (hr != S_OK)
                    {
                        return S_FALSE;
                    }
                }
            }

            // if the transfer goes past the buffer, try to expand it

            if (lOffset + lLength > m_lBufferSize)
            {
                hr = ReAllocBuffer(lOffset + 2*lLength);

                if (hr != S_OK)
                {
                    return S_FALSE;
                }
            }

            // keep track of data size

            if (lOffset + lLength > m_lDataSize)
            {
                m_lDataSize = lOffset + lLength;
            }

            // copy the transfer buffer

            PBYTE pBuffer = (PBYTE) GlobalLock(m_hBuffer);

            if (pBuffer)
            {
                CopyMemory(pBuffer + lOffset, pbBuffer, lLength);

                GlobalUnlock(m_hBuffer);
            }

#ifdef DBG
            DWORD nWritten;
            SetFilePointer(m_hDumpFile, lOffset, 0, FILE_BEGIN);
            WriteFile(m_hDumpFile, pbBuffer, lLength, &nWritten, 0);
#endif //DBG

            QueryStopTimes(lStatus, lPercentComplete);

            break;
        }

        case IT_MSG_STATUS:
        {
            // update the progress bar position

            QueryStartTimes(lStatus, lPercentComplete);

            UpdateStatus(lStatus, lPercentComplete);

            QueryStopTimes(lStatus, lPercentComplete);

            break;
        }

        case IT_MSG_TERMINATION:
        {
            PVOID pBuffer = GlobalLock(m_hBuffer);

            if (pBuffer)
            {
                FixDibHeader(pBuffer, m_lDataSize);

                GlobalUnlock(m_hBuffer);
            }

            break;
        }

        case IT_MSG_NEW_PAGE:
        {
            // mspaint should not get this message, but...

            PVOID pBuffer = GlobalLock(m_hBuffer);

            if (pBuffer)
            {
                FixDibHeader(pBuffer, m_lDataSize);

                GlobalUnlock(m_hBuffer);
            }

            break;
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CDataCallback::ReAllocBuffer(LONG lBufferSize)
{
    // try to allocate the new buffer

    Trace(_T("Allocating %d bytes for image data\n"), lBufferSize);

    HGLOBAL hBuffer;

    if (m_hBuffer == 0)
    {
        hBuffer = (PBYTE) GlobalAlloc(GMEM_MOVEABLE, lBufferSize);
    }
    else
    {
        hBuffer = (PBYTE) GlobalReAlloc(m_hBuffer, lBufferSize, 0);
    }

    if (hBuffer == 0)
    {
        theApp.SetMemoryEmergency(TRUE);
        return S_FALSE;
    }

    // store this new buffer

    m_hBuffer = hBuffer;

    m_lBufferSize = lBufferSize;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

inline ULONG LineWidth(ULONG nWidth, ULONG nBitCount)
{
    return (((nWidth * nBitCount) + 31) & ~31) >> 3;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

ULONG FindDibSize(LPCVOID pDib)
{
    ULONG nHeaderSize = *(PDWORD)pDib;

    // Do we recognize the header?

    if (nHeaderSize != sizeof(BITMAPCOREHEADER) &&
        nHeaderSize != sizeof(BITMAPINFOHEADER) &&
        nHeaderSize != sizeof(BITMAPV4HEADER)   &&
        nHeaderSize != sizeof(BITMAPV5HEADER))
    {
        return 0;
    }

    // Start the calculation with the header size

    ULONG nDibSize = nHeaderSize;

    // is this an old style BITMAPCOREHEADER?

    if (nHeaderSize == sizeof(BITMAPCOREHEADER))
    {
        PBITMAPCOREHEADER pbmch = (PBITMAPCOREHEADER) pDib;

        // Add the color table size

        if (pbmch->bcBitCount <= 8)
        {
            nDibSize += sizeof(RGBTRIPLE) * (1 << pbmch->bcBitCount);
        }

        // Add the bitmap size

        nDibSize += LineWidth(pbmch->bcWidth, pbmch->bcBitCount) * pbmch->bcHeight;
    }
    else
    {
        // this is at least a BITMAPINFOHEADER

        PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) pDib;

        // Add the color table size

        if (pbmih->biClrUsed != 0)
        {
            nDibSize += sizeof(RGBQUAD) * pbmih->biClrUsed;
        }
        else if (pbmih->biBitCount <= 8)
        {
            nDibSize += sizeof(RGBQUAD) * (1 << pbmih->biBitCount);
        }

        // Add the bitmap size

        if (pbmih->biSizeImage != 0)
        {
            nDibSize += pbmih->biSizeImage;
        }
        else
        {
            // biSizeImage must be specified for compressed bitmaps

            if (pbmih->biCompression != BI_RGB &&
                pbmih->biCompression != BI_BITFIELDS)
            {
                return 0;
            }

            nDibSize += LineWidth(pbmih->biWidth, pbmih->biBitCount) * abs(pbmih->biHeight);
        }

        // Consider special cases

        if (nHeaderSize == sizeof(BITMAPINFOHEADER))
        {     
            // If this is a 16 or 32 bit bitmap and BI_BITFIELDS is used, 
            // bmiColors member contains three DWORD color masks.
            // For V4 or V5 headers, this info is included the header

            if (pbmih->biCompression == BI_BITFIELDS)
            {
                nDibSize += 3 * sizeof(DWORD);
            }
        }
        else if (nHeaderSize >= sizeof(BITMAPV5HEADER))
        {
            // If this is a V5 header and an ICM profile is specified,
            // we need to consider the profile data size
            
            PBITMAPV5HEADER pbV5h = (PBITMAPV5HEADER) pDib;

            // if there is some padding before the profile data, add it

            if (pbV5h->bV5ProfileData > nDibSize)
            {
                nDibSize = pbV5h->bV5ProfileData;
            }

            // add the profile data size

            nDibSize += pbV5h->bV5ProfileSize;
        }
    }

    return nDibSize;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

ULONG FindDibOffBits(LPCVOID pDib)
{
    ULONG nHeaderSize = *(PDWORD)pDib;

    // Do we recognize the header?

    if (nHeaderSize != sizeof(BITMAPCOREHEADER) &&
        nHeaderSize != sizeof(BITMAPINFOHEADER) &&
        nHeaderSize != sizeof(BITMAPV4HEADER)   &&
        nHeaderSize != sizeof(BITMAPV5HEADER))
    {
        return 0;
    }

    // Start the calculation with the header size

    ULONG nOffBits = nHeaderSize;

    // is this an old style BITMAPCOREHEADER?

    if (nHeaderSize == sizeof(BITMAPCOREHEADER))
    {
        PBITMAPCOREHEADER pbmch = (PBITMAPCOREHEADER) pDib;

        // Add the color table size

        if (pbmch->bcBitCount <= 8)
        {
            nOffBits += sizeof(RGBTRIPLE) * (1 << pbmch->bcBitCount);
        }
    }
    else
    {
        // this is at least a BITMAPINFOHEADER

        PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) pDib;

        // Add the color table size

        if (pbmih->biClrUsed != 0)
        {
            nOffBits += sizeof(RGBQUAD) * pbmih->biClrUsed;
        }
        else if (pbmih->biBitCount <= 8)
        {
            nOffBits += sizeof(RGBQUAD) * (1 << pbmih->biBitCount);
        }

        // Consider special cases

        if (nHeaderSize == sizeof(BITMAPINFOHEADER))
        {     
            // If this is a 16 or 32 bit bitmap and BI_BITFIELDS is used, 
            // bmiColors member contains three DWORD color masks.
            // For V4 or V5 headers, this info is included the header

            if (pbmih->biCompression == BI_BITFIELDS)
            {
                nOffBits += 3 * sizeof(DWORD);
            }
        }
        else if (nHeaderSize >= sizeof(BITMAPV5HEADER))
        {
            // If this is a V5 header and an ICM profile is specified,
            // we need to consider the profile data size
            
            PBITMAPV5HEADER pbV5h = (PBITMAPV5HEADER) pDib;

            // if the profile data comes before the pixel data, add it

            if (pbV5h->bV5ProfileData <= nOffBits)
            {
                nOffBits += pbV5h->bV5ProfileSize;
            }
        }
    }

    return nOffBits;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void FixDibHeader(LPVOID pDib, DWORD dwSize)
{
    ULONG nHeaderSize = *(PDWORD)pDib;

    // Do we recognize the header?

    if (nHeaderSize != sizeof(BITMAPCOREHEADER) &&
        nHeaderSize != sizeof(BITMAPINFOHEADER) &&
        nHeaderSize != sizeof(BITMAPV4HEADER)   &&
        nHeaderSize != sizeof(BITMAPV5HEADER))
    {
        return;
    }

    // is this an old style BITMAPCOREHEADER?

    if (nHeaderSize == sizeof(BITMAPCOREHEADER))
    {
        PBITMAPCOREHEADER pbmch = (PBITMAPCOREHEADER) pDib;

        // fix the height value if necessary

        if (pbmch->bcHeight == 0)
        {
            // start the calculation with the header size

            DWORD dwSizeImage = dwSize - nHeaderSize;

            // subtract the color table size

            if (pbmch->bcBitCount <= 8)
            {
                dwSizeImage -= sizeof(RGBTRIPLE) * (1 << pbmch->bcBitCount);
            }

            // calculate the height

            pbmch->bcHeight = (WORD) (dwSizeImage / LineWidth(pbmch->bcWidth, pbmch->bcBitCount));
        }
    }
    else
    {
        // this is at least a BITMAPINFOHEADER

        PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) pDib;

        // fix the height value if necessary

        if (pbmih->biHeight == 0)
        {
            // find the size of the image data

            DWORD dwSizeImage;

            if (pbmih->biSizeImage != 0)
            {
                // if the size is specified in the header, take it

                dwSizeImage = pbmih->biSizeImage;
            }
            else
            {
                // start the calculation with the header size

                dwSizeImage = dwSize - nHeaderSize;

                // subtract the color table size

                if (pbmih->biClrUsed != 0)
                {
                    dwSizeImage -= sizeof(RGBQUAD) * pbmih->biClrUsed;
                }
                else if (pbmih->biBitCount <= 8)
                {
                    dwSizeImage -= sizeof(RGBQUAD) * (1 << pbmih->biBitCount);
                }

                // Consider special cases

                if (nHeaderSize == sizeof(BITMAPINFOHEADER))
                {     
                    // If this is a 16 or 32 bit bitmap and BI_BITFIELDS is used, 
                    // bmiColors member contains three DWORD color masks.
                    // For V4 or V5 headers, this info is included the header

                    if (pbmih->biCompression == BI_BITFIELDS)
                    {
                        dwSizeImage -= 3 * sizeof(DWORD);
                    }
                }
                else if (nHeaderSize >= sizeof(BITMAPV5HEADER))
                {
                    // If this is a V5 header and an ICM profile is specified,
                    // we need to consider the profile data size
            
                    PBITMAPV5HEADER pbV5h = (PBITMAPV5HEADER) pDib;

                    // add the profile data size

                    dwSizeImage -= pbV5h->bV5ProfileSize;
                }

                // store the image size

                pbmih->biSizeImage = dwSizeImage;
            }

            // finally, calculate the height

            pbmih->biHeight = -(LONG) (dwSizeImage / LineWidth(pbmih->biWidth, pbmih->biBitCount));
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CDataCallback::UpdateStatus(LONG lStatus, LONG lPercentComplete)
{
    if (m_pProgress)
    {
        m_pProgress->SetPercentComplete(lPercentComplete);

        CString strFormat;

        switch (lStatus)
        {
            case IT_STATUS_TRANSFER_FROM_DEVICE:
                strFormat.LoadString(IDS_STATUS_TRANSFER_FROM_DEVICE);
                break;

            case IT_STATUS_PROCESSING_DATA:
                strFormat.LoadString(IDS_STATUS_PROCESSING_DATA);
                break;

            case IT_STATUS_TRANSFER_TO_CLIENT:
                strFormat.LoadString(IDS_STATUS_TRANSFER_TO_CLIENT);
                break;
        }

        CString strStatusText;
        strStatusText.Format(strFormat, lPercentComplete);

        USES_CONVERSION;
        m_pProgress->SetMessage(T2CW(strStatusText));
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

#ifdef DBG

void CDataCallback::QueryStartTimes(LONG lStatus, LONG  lPercentComplete)
{
    if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE &&
        (lPercentComplete == 0 || m_TimeDeviceBegin.QuadPart == 0))
    {
        QueryPerformanceCounter(&m_TimeDeviceBegin);
    }

    if (lStatus & IT_STATUS_PROCESSING_DATA &&
        (lPercentComplete == 0 || m_TimeProcessBegin.QuadPart == 0))
    {
        QueryPerformanceCounter(&m_TimeProcessBegin);
    }

    if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT &&
        (lPercentComplete == 0 || m_TimeClientBegin.QuadPart == 0))
    {
        QueryPerformanceCounter(&m_TimeClientBegin);
    }
}

void CDataCallback::QueryStopTimes(LONG lStatus, LONG  lPercentComplete)
{
    if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE && lPercentComplete == 100)
    {
        QueryPerformanceCounter(&m_TimeDeviceEnd);
    }

    if (lStatus & IT_STATUS_PROCESSING_DATA && lPercentComplete == 100)
    {
        QueryPerformanceCounter(&m_TimeProcessEnd);
    }

    if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT && lPercentComplete == 100)
    {
        QueryPerformanceCounter(&m_TimeClientEnd);
    }
}

void CDataCallback::PrintTimes()
{
    LARGE_INTEGER Freq;
    QueryPerformanceFrequency(&Freq);

    double nTimeDevice =
        (double) (m_TimeDeviceEnd.QuadPart - m_TimeDeviceBegin.QuadPart) /
        (double) Freq.QuadPart;

    double nTimeProcess =
        (double) (m_TimeProcessEnd.QuadPart - m_TimeProcessBegin.QuadPart) /
        (double) Freq.QuadPart;

    double nTimeClient =
        (double) (m_TimeClientEnd.QuadPart - m_TimeClientBegin.QuadPart) /
        (double) Freq.QuadPart;

    Trace(
        _T("TRANSFER_FROM_DEVICE = %.02lf secs\n")
        _T("PROCESSING_DATA      = %.02lf secs\n")
        _T("TRANSFER_TO_CLIENT   = %.02lf secs\n")
        _T("\n"),
        nTimeDevice,
        nTimeProcess,
        nTimeClient
    );
}

#else //DBG

inline void CDataCallback::QueryStartTimes(LONG, LONG)
{
}

inline void CDataCallback::QueryStopTimes(LONG, LONG)
{
}

inline void CDataCallback::PrintTimes()
{
}

#endif //DBG

//////////////////////////////////////////////////////////////////////////
//
//
//

CProgressDialog::CProgressDialog()
{
    m_cRef = 0;
}

CProgressDialog::~CProgressDialog()
{
    // remove the "downloading..." message from the status bar

    if (g_pStatBarWnd)
    {
        g_pStatBarWnd->SetPaneText(0, _T(""));
    }
}

STDMETHODIMP CProgressDialog::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (ppvObj == 0)
    {
        return E_POINTER;
    }

    if (iid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*) this;
        return S_OK;
    }

    if (iid == IID_IWiaProgressDialog)
    {
        AddRef();
        *ppvObj = (IWiaProgressDialog *) this;
        return S_OK;
    }

    *ppvObj = 0;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProgressDialog::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CProgressDialog::Release()
{
    LONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

STDMETHODIMP CProgressDialog::Create(HWND hwndParent, LONG lFlags)
{
    if (g_pStatBarWnd)
    {
        RECT r;
        g_pStatBarWnd->GetItemRect(1, &r);

        m_ProgressCtrl.Create(WS_CHILD | WS_VISIBLE, r, g_pStatBarWnd, 1);
        m_ProgressCtrl.SetRange(0, 100);
    }

    return S_OK;
}

STDMETHODIMP CProgressDialog::Show()
{
    m_ProgressCtrl.UpdateWindow();

    return S_OK;
}

STDMETHODIMP CProgressDialog::Hide()
{
    return S_OK;
}

STDMETHODIMP CProgressDialog::Cancelled(BOOL *pbCancelled)
{
    *pbCancelled = FALSE;

    return S_OK;
}

STDMETHODIMP CProgressDialog::SetTitle(LPCWSTR pszMessage)
{
    return S_OK;
}

STDMETHODIMP CProgressDialog::SetMessage(LPCWSTR pszTitle)
{
    if (g_pStatBarWnd)
    {
        USES_CONVERSION;
        g_pStatBarWnd->SetPaneText(0, W2CT(pszTitle));
    }

    return S_OK;
}

STDMETHODIMP CProgressDialog::SetPercentComplete(UINT nPercent)
{
    m_ProgressCtrl.SetPos(nPercent);

    return S_OK;
}

STDMETHODIMP CProgressDialog::Destroy()
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgbrush.h ===
#ifndef __IMGBRUSH_H__
#define __IMGBRUSH_H__

class CImgBrush : public CObject
    {
    public: /******************************************************************/

    CImgBrush();
    virtual ~CImgBrush();


    BOOL CopyTo( CImgBrush& destImgBrush );

    CPalette* SetBrushPalette( CDC* pdc, BOOL bForce = FALSE );
    HPALETTE  SetBrushPalette( HDC  hdc, BOOL bForce = FALSE );

    BOOL SetSize   ( CSize newSize, BOOL bStretchToFit=TRUE );
    void ColorToMonoBitBlt(CDC* pdcMono, int xMono, int yMono, int cx, int cy,
        CDC *pdcColor, int xColor, int yColor, DWORD dwROP, COLORREF transparentColor);
    void RecalcMask( COLORREF transparentColor );

    void BltMatte  ( IMG* pimg, CPoint topLeft );
    void BltReplace( IMG* pimg, CPoint topLeft );
    void BltColor  ( IMG* pimg, CPoint topLeft, COLORREF color );

    void CenterHandle();
    void TopLeftHandle();

    CRgn      m_cRgnPolyFreeHandSelBorder;
    CRgn      m_cRgnPolyFreeHandSel;

    CDC       m_dc;
    CBitmap   m_bitmap;
    CSize     m_size;
    CDC       m_maskDC;
    CBitmap   m_maskBitmap;

    HBITMAP   m_hbmOld;
    HBITMAP   m_hbmMaskOld;

    BOOL      m_bFirstDrag;
    BOOL      m_bLastDragWasASmear;
    BOOL      m_bLastDragWasFirst;
    BOOL      m_bCuttingFromImage;
    BOOL      m_bMakingSelection;
    BOOL      m_bMoveSel;
    BOOL      m_bSmearSel;
    BOOL      m_bOpaque;

    CRect     m_rcDraggedFrom;
    CSize     m_dragOffset;

    IMG*      m_pImg;

    CRect     m_rcSelection;
    CSize     m_handle;
    };


extern CImgBrush NEAR theImgBrush;

void GetMonoBltColors(HDC hDC, HBITMAP hBM, COLORREF& crNewBk, COLORREF& crNewText);
BOOL QuickColorToMono(CDC* pdcMono, int xMono, int yMono, int cx, int cy,
	CDC *pdcColor, int xColor, int yColor, DWORD dwROP, COLORREF crTrans);

// #define DEBUGSHOWBITMAPS
#if defined(DEBUGSHOWBITMAPS)
void DebugShowBitmap(HDC hdcSrc, int x, int y, int wid, int hgt);
#else
#define DebugShowBitmap(hdc,x,y,w,h)
#endif

#endif // __IMGBRUSH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgcolor.cpp ===
/******************************************************************************/
/*                                                                            */
/* Class Implementations in this file                                         */
/*      CFloatImgColorsWnd                                                    */
/*      CImgColorsWnd                                                         */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "docking.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "imgwell.h"
#include "imgtools.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "props.h"
#include "colorsrc.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

#define cxColorBox 16
#define cyColorBox 16

#define TRYANYTHING



/******************************************************************************/

CImgColorsWnd* NEAR g_pImgColorsWnd = NULL;

/******************************************************************************/
//
// MonoRect -- draw a dithered monochrome rectangle with any intensity
//

BOOL MonoRect( CDC* pDC, const CRect& rect, COLORREF rgb, BOOL bFrame )
    {
    CDC      monoDC;
    CBitmap  monoBitmap;
    CBrush   brush;
    CBrush*  pOldBrush;
    CBitmap* pOldBitmap;
        CPen*    pOldPen = NULL;

        //REARCHITECT -This can leak DCs and Bitmaps
    if (! monoDC.CreateCompatibleDC( pDC )
    ||  ! monoBitmap.CreateBitmap( rect.Width(), rect.Height(), 1, 1, NULL )
    ||  ! brush.CreateSolidBrush( rgb ))
        {
        return FALSE;
        }

    pOldBitmap = monoDC.SelectObject( &monoBitmap );
    pOldBrush  = monoDC.SelectObject( &brush      );

    if (! bFrame)
        pOldPen = (CPen *)monoDC.SelectStockObject( NULL_PEN );

    monoDC.Rectangle( 0, 0, rect.Width(), rect.Height() );

    pDC->BitBlt( rect.left, rect.top, rect.Width(), rect.Height(),
                                         &monoDC, 0, 0, SRCCOPY );
    monoDC.SelectObject( pOldBrush  );
    monoDC.SelectObject( pOldBitmap );
        if ( pOldPen )
                monoDC.SelectObject(pOldPen);
    monoBitmap.DeleteObject();
    brush.DeleteObject();

    return TRUE;
    }

/******************************************************************************/


/******************************************************************************/

CImgColorsWnd::CImgColorsWnd()
{
    ASSERT( g_pColors );  // just to make sure

    m_nOffsetY       = cyColorBox / 2;
    m_nDisplayColorsInitial = 28;
    m_nDisplayColors = min( g_pColors->GetColorCount(), m_nDisplayColorsInitial );
    m_rectColors.SetRectEmpty();

    // Number of colors / 2 rows + 2 for fore/back area (which is size of 2 wide 2 high)
    //        * size of color  see below for + 3
    // 2 rows * hight for 1 row   +3 is 1 for border above 1st row, 1 for border 2nd row 1 for border on bottom
    m_rectColors.right  = (m_nDisplayColors / 2 + 2) * cxColorBox + 3;
    m_rectColors.bottom = 2 * cyColorBox + 3;

    m_nCols = m_rectColors.Width()  / cxColorBox;
    m_nRows = m_rectColors.Height() / cyColorBox;

}

/******************************************************************************/

BEGIN_MESSAGE_MAP(CImgColorsWnd, CControlBar)
    //{{AFX_MSG_MAP(CImgColorsWnd)
    ON_WM_ERASEBKGND()
    ON_WM_PAINT()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_LBUTTONDOWN()
    ON_WM_RBUTTONDBLCLK()
    ON_WM_RBUTTONDOWN()
    ON_WM_GETMINMAXINFO()
        ON_WM_MOUSEMOVE()
        ON_WM_KEYDOWN()
        ON_WM_LBUTTONUP()
        ON_WM_CLOSE()
        //}}AFX_MSG_MAP

    ON_WM_WINDOWPOSCHANGING()
END_MESSAGE_MAP()

/******************************************************************************/

BOOL CImgColorsWnd::Create( const TCHAR* pWindowName, DWORD dwStyle, CWnd* pParentWnd )
    {
        // save the style
        m_dwStyle  = (UINT)dwStyle;
      dwStyle &= ~WS_VISIBLE;

    m_rectColors.bottom += (2 * m_nOffsetY);

        // Create the window offscreen initially, since it will get moved to the
        // proper location later
        CRect rcInit(-m_rectColors.right, -m_rectColors.bottom, 0, 0);

        BOOL bCreate = CControlBar::Create( NULL, pWindowName, dwStyle, rcInit,
                                pParentWnd, ID_VIEW_COLOR_BOX, NULL );

        if (m_dwStyle & WS_VISIBLE)
        {
        g_pImgColorsWnd->ShowWindow(SW_SHOW);
        g_pImgColorsWnd->UpdateWindow();
        }

        return bCreate;
    }

/******************************************************************************/

void CImgColorsWnd::OnClose()
    {
#ifdef TRYANYTHING
        CControlBar::OnClose();
#endif
    }

/******************************************************************************/

void CImgColorsWnd::OnUpdateCmdUI( CFrameWnd* pTarget, BOOL bDisableIfNoHndler )
    {
    }

/******************************************************************************/

WORD CImgColorsWnd::GetHelpOffset()
    {
    return 0; // REVIEW: NYI!
    }

/******************************************************************************/

CImgColorsWnd::HitZone CImgColorsWnd::HitTest(const CPoint& point)
    {
    CRect rect;

    for (HitZone hitZone = curColor;
                 hitZone < (HitZone)(firstColor + m_nDisplayColors);
                 hitZone = (HitZone)(hitZone + 1))
        if (GetHitRect( hitZone, rect ) && rect.PtInRect( point ))
            return hitZone;

    return none;
    }

/******************************************************************************/

BOOL CImgColorsWnd::GetHitRect( HitZone hitZone, CRect& rect )
    {
    CRect client = m_rectColors;

    client.InflateRect( -1, -(m_nOffsetY + 1) );

    switch (hitZone)
        {
        case none:
            return FALSE;

        case curColor:
            rect.SetRect( client.left, client.top,
                          client.left + cxColorBox * 2 + 1,
                          client.top  + cyColorBox * 2 + 1);
            break;

        default:
            {
            int nColor = (int)hitZone;

            if (nColor < 0 || nColor > m_nDisplayColors)
                return FALSE;

            int row = nColor / (m_nCols - 2);
            int col = nColor % (m_nCols - 2);

            rect.SetRect( client.left + (2 + col    ) * cxColorBox,
                          client.top  +      row      * cyColorBox,
                          client.left + (2 + col + 1) * cxColorBox,
                          client.top  + (    row + 1) * cyColorBox );
            }
            break;
        }

    return TRUE;
    }

/******************************************************************************/

BOOL CImgColorsWnd::OnEraseBkgnd( CDC* pDC )
    {
    CRect rect;

    GetClientRect( rect );

    pDC->FillRect( rect, GetSysBrush( COLOR_BTNFACE ) );

    rect = m_rectColors;

    rect.InflateRect( -1, -(m_nOffsetY + 1) );

    pDC->FillRect( rect, GetSysBrush( COLOR_BTNSHADOW ) );

    GetHitRect( curColor, rect );

    pDC->FillRect(rect, GetSysBrush( COLOR_BTNFACE ) );

        return CControlBar::OnEraseBkgnd( pDC );
    }

/******************************************************************************/

void CImgColorsWnd::OnPaint()
    {
    CPaintDC dc( this );
    CPalette *pcOldPalette = NULL;
    m_nDisplayColors = min( g_pColors->GetColorCount(), m_nDisplayColorsInitial );
    m_rectColors.right  = (m_nDisplayColors / 2 + 2) * cxColorBox + 3;
    m_nCols = m_rectColors.Width()  / cxColorBox;

    if (! dc.m_hDC)
        {
        theApp.SetGdiEmergency();
        return;
        }

    if (theApp.m_pPalette)
        {
                BOOL bForce = FALSE;

                // If we do not realize as a background brush when in-place, we can get
                // an infinite recursion of the container and us trying to realize the
                // palette
                if (theApp.m_pwndInPlaceFrame)
                {
                        bForce = TRUE;
                }

        pcOldPalette = dc.SelectPalette( theApp.m_pPalette, bForce );
        dc.RealizePalette();
        }
    dc.FillRect( (CRect*)&dc.m_ps.rcPaint, GetSysBrush(COLOR_BTNFACE) );
    PaintCurColors( &dc, (CRect*)&dc.m_ps.rcPaint );
    PaintColors   ( &dc, (CRect*)&dc.m_ps.rcPaint );

    if (pcOldPalette)
        dc.SelectPalette( pcOldPalette, FALSE );
    }

/******************************************************************************/

CSize CImgColorsWnd::CalcFixedLayout( BOOL bStretch, BOOL bHorz )
    {
#ifdef TRYANYTHING
        return m_rectColors.Size();
#else
    CSize size = CControlBar::CalcFixedLayout( bStretch, bHorz );

    size.cy = m_rectColors.Height();

    return size;
#endif
    }

/******************************************************************************/

void CImgColorsWnd::OnLButtonDown(UINT nFlags, CPoint point)
    {
    HitZone hitZone = HitTest( point );

    switch (hitZone)
       {
       case none:
          CControlBar::OnLButtonDown(nFlags,point);
          break;

       case curColor:
          break;

       default:
          if (nFlags & MK_CONTROL)
          {
             SetTransColor (hitZone);
          }
          else
          {
             SetDrawColor( (int)hitZone );
          }

          break;
        }
    }

/******************************************************************************/

void CImgColorsWnd::OnRButtonDown(UINT nFlags, CPoint point)
 {
    if (GetCapture() == this)
        {
        CancelDrag();

        return;
        }

    HitZone hitZone = HitTest( point );

    switch (hitZone)
    {
       case none:
       case curColor:
          break;

       default:
          if (nFlags & MK_CONTROL)
          {
             SetTransColor( hitZone );
          }
          else
          {
             SetEraseColor( hitZone );
          }

            break;
    }
 }

/******************************************************************************/

void CImgColorsWnd::OnLButtonDblClk(UINT nFlags, CPoint point)
    {
    HitZone hitZone = HitTest( point );

    switch (hitZone)
        {
        case none:
        case curColor:
            break;

        default:
            if (g_pColors)
                g_pColors->EditColor( TRUE, nFlags&MK_CONTROL );
            break;
        }
    }

/******************************************************************************/

void CImgColorsWnd::OnRButtonDblClk(UINT nFlags, CPoint point)
    {
    HitZone hitZone = HitTest( point );

    switch (hitZone)
        {
        case none:
        case curColor:
            break;

        default:
            if (g_pColors)
                g_pColors->EditColor( FALSE, nFlags&MK_CONTROL );
            break;
        }
    }

/******************************************************************************/

void CImgColorsWnd::OnLButtonUp( UINT nFlags, CPoint point )
    {
    CControlBar::OnLButtonUp( nFlags, point );
    }

/******************************************************************************/

void CImgColorsWnd::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
    {
    CWnd::OnGetMinMaxInfo(lpMMI);

    lpMMI->ptMinTrackSize.x = 37;
    lpMMI->ptMinTrackSize.y = 37;
    lpMMI->ptMaxTrackSize.x = 37 + 128 * 16;
    lpMMI->ptMaxTrackSize.y = 37 + 128 * 16;
    }

/******************************************************************************/

void CImgColorsWnd::PaintCurColors(CDC* pDC, const CRect* pPaintRect)
    {
        CBrush  highlight(GetSysColor(COLOR_BTNHIGHLIGHT));
        CBrush  lowlight(GetSysColor(COLOR_BTNTEXT));
        CBrush  shadow(GetSysColor(COLOR_BTNSHADOW));
        CBrush  face(GetSysColor(COLOR_BTNFACE));

    CRect rect;

    GetHitRect( curColor, rect );

    // Draw current color indicators

#ifdef OLDBORDER
    // Box around colors
    rect.InflateRect( -2, -2 );

    Draw3dRect( pDC->m_hDC, &rect );
    CBrush* pOldBrush = (CBrush*)pDC->SelectStockObject( NULL_BRUSH );

    rect.InflateRect( -1, -1 );

    pDC->Rectangle( &rect );
    pDC->SelectObject( pOldBrush );

#else
    rect.InflateRect( -1, -1 ); rect.top--;
        pDC->FrameRect(&rect,&highlight);
        rect.right--; rect.bottom--;
        pDC->FrameRect(&rect,&shadow);
        rect.left++; rect.top++;
        pDC->FrameRect(&rect,&face);
        rect.right--; rect.bottom--;
        pDC->FrameRect(&rect,&lowlight);
        rect.left++; rect.top++;


        COLORREF        oldTextColor = pDC->SetTextColor(GetSysColor(COLOR_BTNFACE));
        COLORREF        oldBkColor = pDC->SetBkColor(GetSysColor(COLOR_BTNHIGHLIGHT));
        // Draw the transparent color box if set
        if (crTrans != TRANS_COLOR_NONE) // not default
        {
           if (g_pColors->GetMonoFlag())
           {
              MonoRect ( pDC, rect, crTrans, TRUE);
           }
           else
           {
              CBrush brTrans(crTrans);
              pDC->FillRect(&rect, &brTrans);
           }
        }
        else
        {
           pDC->FillRect(&rect,GetHalftoneBrush());
        }
        pDC->SetTextColor(oldTextColor);
        pDC->SetBkColor(oldBkColor);
#endif


    // Draw the overlapping foreground/background color boxes...

    PaintCurColorBox( pDC, TRUE  ); // Background color
    PaintCurColorBox( pDC, FALSE ); // Foreground color
    }

/******************************************************************************/

void CImgColorsWnd::PaintColors(CDC* pDC, const CRect* pPaintRect)
    {
    BOOL bMono = g_pColors->GetMonoFlag();

    CRect    r( 0, 0, 0, 0 );
    COLORREF color;

        CBrush  highlight(GetSysColor(COLOR_BTNHIGHLIGHT));
        CBrush  lowlight(GetSysColor(COLOR_BTNTEXT));
        CBrush  shadow(GetSysColor(COLOR_BTNSHADOW));
        CBrush  face(GetSysColor(COLOR_BTNFACE));

    for (int iLoop = 0; iLoop < m_nDisplayColors; iLoop++)
        if (GetHitRect( (HitZone)iLoop, r ))
            {
               color = g_pColors->GetColor( iLoop );

               pDC->FrameRect(&r,&highlight);
               r.right--; r.bottom--;
               pDC->FrameRect(&r,&shadow);
               r.left++; r.top++;
               pDC->FrameRect(&r,&face);
               r.right--; r.bottom--;
               pDC->FrameRect(&r,&lowlight);

            if (bMono)
                MonoRect( pDC, r, color, TRUE );
            else
                {
                   r.left++; r.top++;
                   CBrush   brush(color);
                   pDC->FillRect( &r, &brush );
                }
            }
    }

/******************************************************************************/

void CImgColorsWnd::InvalidateCurColors()
    {
    CRect rect;

    GetHitRect( curColor, rect );
    InvalidateRect( &rect, FALSE );

    if (CImgTool::GetCurrent()->IsFilled())
        g_pImgToolWnd->InvalidateOptions( FALSE );
    }

/******************************************************************************/

void CImgColorsWnd::PaintCurColorBox(CDC* pDC, BOOL bRight)
    {
    BOOL bMono = g_pColors->GetMonoFlag();

        CBrush  highlight(GetSysColor(COLOR_BTNHIGHLIGHT));
        CBrush  shadow(GetSysColor(COLOR_BTNSHADOW));
        CBrush  face(GetSysColor(COLOR_BTNFACE));

    CRect rc(0, 0, 15, 15);

    COLORREF rgb;
    CBrush   brush;
    CRect    curColorRect;

    GetHitRect( curColor, curColorRect );

    if (bRight)
        {
        rgb = crRight;
        rc.OffsetRect( curColorRect.left + 12, curColorRect.top + 12 );
        }
    else
        {
        rgb = crLeft;
        rc.OffsetRect( curColorRect.left + 5, curColorRect.top + 5 );
        }

        rc.right--; rc.bottom--;
        pDC->FrameRect(&rc,&highlight);
        rc.OffsetRect(1,1);
        pDC->FrameRect(&rc,&shadow);
        rc.right--; rc.bottom--;
        pDC->FrameRect(&rc,&face);
    rc.InflateRect( -1, -1 );

    if (bMono)
        {
        MonoRect( pDC, rc, rgb, TRUE );
                }
    else
                {
                CBrush  colorWell(rgb);
                pDC->FillRect(&rc,&colorWell);
                }
    }

/******************************************************************************/

void CImgColorsWnd::OnMouseMove(UINT nFlags, CPoint point)
    {
    CControlBar::OnMouseMove( nFlags, point );
    }

/******************************************************************************/

void CImgColorsWnd::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
    {
    CControlBar::OnKeyDown( nChar, nRepCnt, nFlags );
    }

/******************************************************************************/

void CImgColorsWnd::CancelDrag()
    {
    }

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imaging.h ===
#ifndef IMAGING_H
#define IMAGING_H

//////////////////////////////////////////////////////////////////////////
//
// CImagingMgr
//

class CImagingMgr
{
public:
    virtual ~CImagingMgr() = 0;

    virtual
    HRESULT
    SelectSource(
        HWND hWndParent,
        LONG lFlags
    ) = 0;

    virtual
    HRESULT
    Acquire(
        HWND     hWndParent,
        HGLOBAL *phDib
    ) = 0;

    virtual
    HRESULT
    Select(
        LPCTSTR pDeviceId
    ) = 0;

    virtual
    int
    NumDevices(
        HWND hWndParent
    ) = 0;

    virtual
    BOOL
    IsAvailable() = 0;
};

//////////////////////////////////////////////////////////////////////////
//
// TWAIN
//

#ifdef USE_TWAIN

#include <twain.h>

//////////////////////////////////////////////////////////////////////////
//
// CTwainMgr
//

class CTwainMgr : public CImagingMgr
{
public:
    CTwainMgr();
    ~CTwainMgr();

    HRESULT
    SelectSource(
        HWND hWndParent,
        LONG lFlags
    );

    HRESULT
    Acquire(
        HWND     hWndParent,
        HGLOBAL *phDib
    );

    HRESULT
    Select(
        LPCTSTR pDeviceId
    );

    int
    NumDevices(
        HWND hWndParent
    );

    BOOL
    IsAvailable()
    {
        return m_DSM_Entry != 0;
    }

private:
    TW_UINT16 SetCapability(TW_UINT16 Cap, TW_UINT16 ItemType, TW_UINT32 Item);
    TW_UINT16 GetCapability(TW_UINT16 Cap, pTW_UINT16 pItemType, pTW_UINT32 pItem);

private:
    enum eTwainState 
    {
        State_1_Pre_Session           = 1,
        State_2_Source_Manager_Loaded = 2,
        State_3_Source_Manager_Open   = 3,
        State_4_Source_Open           = 4,
        State_5_Source_Enabled        = 5,
        State_6_Transfer_Ready        = 6,
        State_7_Transferring          = 7
    };

private:
    eTwainState  m_TwainState;

    TW_IDENTITY  m_AppId;
    TW_IDENTITY  m_SrcId;

    HINSTANCE    m_hTwainDll;
    DSMENTRYPROC m_DSM_Entry;
};

#endif //USE_TWAIN

//////////////////////////////////////////////////////////////////////////
//
// WIA
//

#include <atlbase.h>

//////////////////////////////////////////////////////////////////////////
//
// CEventCallback
//

class CEventCallback : public IWiaEventCallback
{
public:
    CEventCallback();

    // IUnknown interface

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IWiaEventCallback interface

    STDMETHOD(ImageEventCallback)(
        LPCGUID pEventGuid,
        BSTR    bstrEventDescription,
        BSTR    bstrDeviceID,
        BSTR    bstrDeviceDescription,
        DWORD   dwDeviceType,
        BSTR    bstrFullItemName,
        ULONG  *pulEventType,
        ULONG   ulReserved
    );

    // CEventCallback methods

    HRESULT Register();

    ULONG GetNumDevices() const;

private:
    LONG               m_cRef;
    ULONG              m_nNumDevices;
    CComPtr<IUnknown>  m_pConnectEventObject;
    CComPtr<IUnknown>  m_pDisconnectEventObject;
};

//////////////////////////////////////////////////////////////////////////
//
// CDataCallback
//

class CDataCallback : public IWiaDataCallback
{
public:
    CDataCallback(IWiaProgressDialog *pProgress);
    ~CDataCallback();

    // IUnknown interface

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IWiaDataCallback interface

    STDMETHOD(BandedDataCallback) (
        LONG  lReason,
        LONG  lStatus,
        LONG  lPercentComplete,
        LONG  lOffset,
        LONG  lLength,
        LONG  lReserved,
        LONG  lResLength,
        PBYTE pbBuffer
    );

    // CDataCallback methods

    HGLOBAL GetBuffer();

    // Debugging / performance functions

    void QueryStartTimes(LONG lStatus, LONG lPercentComplete);
    void QueryStopTimes(LONG lStatus, LONG lPercentComplete);
    void PrintTimes();

private:
    HRESULT ReAllocBuffer(LONG lBufferSize);
    void    UpdateStatus(LONG lStatus, LONG lPercentComplete);

private:
    LONG                m_cRef;
    HGLOBAL             m_hBuffer;
    LONG                m_lBufferSize;
    LONG                m_lDataSize;
    IWiaProgressDialog *m_pProgress;

#ifdef DBG
    HANDLE              m_hDumpFile;
    LARGE_INTEGER       m_TimeDeviceBegin;
    LARGE_INTEGER       m_TimeDeviceEnd;
    LARGE_INTEGER       m_TimeProcessBegin;
    LARGE_INTEGER       m_TimeProcessEnd;
    LARGE_INTEGER       m_TimeClientBegin;
    LARGE_INTEGER       m_TimeClientEnd;
#endif //DBG
};

//////////////////////////////////////////////////////////////////////////
//
// CWIAMgr
//

class CWIAMgr : public CImagingMgr
{
public:
    CWIAMgr();

    HRESULT
    SelectSource(
        HWND hWndParent,
        LONG lFlags
    );

    HRESULT
    Acquire(
        HWND     hWndParent,
        HGLOBAL *phDib
    );

    HRESULT
    Select(
        LPCTSTR pDeviceId
    );

    int
    NumDevices(
        HWND hWndParent
    );

    BOOL
    IsAvailable()
    {
        return m_pEventCallback != 0;
    }

private:
    struct CGetBandedDataThreadData
    {
        CGetBandedDataThreadData(
            IWiaDataTransfer       *pIWiaDataTransfer,
            WIA_DATA_TRANSFER_INFO *pWiaDataTransferInfo,
            IWiaDataCallback       *pIWiaDataCallback
        );

        ~CGetBandedDataThreadData()
        {
        }

        HRESULT Marshal();
        HRESULT Unmarshal();

        CComPtr<IStream>          m_pIWiaDataTransferStream;
        CComPtr<IStream>          m_pIWiaDataCallbackStream;
        CComPtr<IWiaDataTransfer> m_pIWiaDataTransfer;
        PWIA_DATA_TRANSFER_INFO   m_pWiaDataTransferInfo;
        CComPtr<IWiaDataCallback> m_pIWiaDataCallback;
    };

    HRESULT GetBandedData(CGetBandedDataThreadData &ThreadData);

    static unsigned WINAPI GetBandedDataThread(PVOID pVoid);

private:
    CComPtr<CEventCallback>  m_pEventCallback;
    CComBSTR                 m_bstrDeviceID;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

class CProgressDialog : public IWiaProgressDialog
{
public:
    CProgressDialog();
    virtual ~CProgressDialog();

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    STDMETHOD(Create)(HWND hwndParent, LONG lFlags);
    STDMETHOD(Show)();
    STDMETHOD(Hide)();
    STDMETHOD(Cancelled)(BOOL *pbCancelled);
    STDMETHOD(SetTitle)(LPCWSTR pszMessage);
    STDMETHOD(SetMessage)(LPCWSTR pszTitle);
    STDMETHOD(SetPercentComplete)(UINT nPercent);
    STDMETHOD(Destroy)();

private:
    LONG           m_cRef;    
    CProgressCtrl  m_ProgressCtrl;
};

//////////////////////////////////////////////////////////////////////////
//
// CComPtrArray
//
// helper class for automatically releasing an array of interface pointers
//

template <class T>
class CComPtrArray
{
public:
    CComPtrArray()
    {
        m_pArray = 0;
        m_nItemCount = 0;
    }

    ~CComPtrArray()
    {
        if (m_pArray)
        {
            for (int i = 0; i < m_nItemCount; ++i)
            {
                if (m_pArray[i])
                {
                    m_pArray[i]->Release();
                }
            }

            CoTaskMemFree(m_pArray);
        }
    }

    operator T**()
    {
        return m_pArray;
    }

    bool operator!()
    {
        return m_pArray == 0;
    }

    T*** operator&()
    {
        ASSERT(m_pArray == 0);
        return &m_pArray;
    }

    LONG &ItemCount()
    {
        return m_nItemCount;
    }

private:
    T**  m_pArray;
    LONG m_nItemCount;
};

//////////////////////////////////////////////////////////////////////////
//
// 
//

ULONG FindDibSize(LPCVOID pDib);
ULONG FindDibOffBits(LPCVOID pDib);
VOID  FixDibHeader(LPVOID pDib, DWORD dwSize);

#endif //IMAGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgbrush.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "t_fhsel.h"
#include "toolbox.h"

#include "mmsystem.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

CImgBrush theImgBrush;

CImgBrush::CImgBrush() : m_bCuttingFromImage(FALSE), m_bOpaque(TRUE)
    {
    }

CImgBrush::~CImgBrush()
    {
    // cleanup old region if exists
    if (m_cRgnPolyFreeHandSel.GetSafeHandle() != NULL)
        m_cRgnPolyFreeHandSel.DeleteObject();

    if (m_cRgnPolyFreeHandSelBorder.GetSafeHandle() != NULL)
        m_cRgnPolyFreeHandSelBorder.DeleteObject();

    if (m_hbmOld)
        m_dc.SelectObject( CBitmap::FromHandle( m_hbmOld ) );

    if (m_hbmMaskOld)
        m_dc.SelectObject( CBitmap::FromHandle( m_hbmMaskOld ) );

    m_dc.DeleteDC();
    m_bitmap.DeleteObject();
    m_maskDC.DeleteDC();
    m_maskBitmap.DeleteObject();
    }

BOOL CImgBrush::CopyTo(CImgBrush& destBrush)
    {
    if (destBrush.m_hbmOld)
        destBrush.m_dc.SelectObject( CBitmap::FromHandle( destBrush.m_hbmOld ) );

    if (destBrush.m_hbmMaskOld)
        destBrush.m_maskDC.SelectObject( CBitmap::FromHandle( destBrush.m_hbmMaskOld ) );

    destBrush.m_hbmOld     = NULL;
    destBrush.m_hbmMaskOld = NULL;

    destBrush.m_dc.DeleteDC();
    destBrush.m_bitmap.DeleteObject();
    destBrush.m_maskDC.DeleteDC();
    destBrush.m_maskBitmap.DeleteObject();

    if (m_dc.m_hDC != NULL)
        {
        if (! destBrush.m_dc.CreateCompatibleDC( NULL )
        ||  ! destBrush.m_bitmap.CreateCompatibleBitmap(&m_dc, m_size.cx, m_size.cy))
            {
            theApp.SetGdiEmergency(FALSE);
            return FALSE;
            }

        destBrush.m_hbmOld = (HBITMAP)((destBrush.m_dc.SelectObject( &destBrush.m_bitmap ))->GetSafeHandle());

        CPalette* ppalOldSrc  = SetBrushPalette(           &m_dc, TRUE ); // Background ??
        CPalette* ppalOldDest = SetBrushPalette( &destBrush.m_dc, TRUE ); // Background ??

        destBrush.m_dc.BitBlt( 0, 0, m_size.cx, m_size.cy, &m_dc, 0, 0, SRCCOPY );

        if (ppalOldSrc)
            m_dc.SelectPalette( ppalOldSrc, TRUE ); // Background ??

        if (ppalOldDest)
            destBrush.m_dc.SelectPalette( ppalOldDest, TRUE ); // Background ??
        }

    if (m_maskDC.m_hDC != NULL)
        {
        if (! destBrush.m_maskDC.CreateCompatibleDC(NULL)
        ||  ! destBrush.m_maskBitmap.CreateCompatibleBitmap(&m_maskDC, m_size.cx,
                                                                       m_size.cy))
            {
            theApp.SetGdiEmergency(FALSE);
            return FALSE;
            }

        destBrush.m_hbmMaskOld = (HBITMAP)((destBrush.m_maskDC.SelectObject(
                                           &destBrush.m_maskBitmap))->GetSafeHandle());
        destBrush.m_maskDC.BitBlt(0, 0, m_size.cx, m_size.cy, &m_maskDC, 0, 0, SRCCOPY);
        }

    destBrush.m_size               = m_size;
    destBrush.m_bFirstDrag         = m_bFirstDrag;
    destBrush.m_bLastDragWasASmear = m_bLastDragWasASmear;
    destBrush.m_bLastDragWasFirst  = m_bLastDragWasFirst;
    destBrush.m_bMakingSelection   = m_bMakingSelection;
    destBrush.m_bMoveSel           = m_bMoveSel;
    destBrush.m_bSmearSel          = m_bSmearSel;
    destBrush.m_bOpaque            = m_bOpaque;
    destBrush.m_rcDraggedFrom      = m_rcDraggedFrom;
    destBrush.m_pImg               = m_pImg;
    destBrush.m_rcSelection        = m_rcSelection;
    destBrush.m_handle             = m_handle;

    return TRUE;
    }


void CImgBrush::CenterHandle()
    {
    m_handle.cx = m_size.cx / 2;
    m_handle.cy = m_size.cy / 2;
    }


void CImgBrush::TopLeftHandle()
    {
    m_handle.cx = 0;
    m_handle.cy = 0;
    }

CPalette* CImgBrush::SetBrushPalette( CDC* pdc, BOOL bForce )
    {
    CPalette* ppal    = NULL;
    CPalette* ppalOld = NULL;

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        ppal = theApp.m_pPalette;

    if (ppal != NULL)
        {
        ppalOld = pdc->SelectPalette( ppal, bForce );

        pdc->RealizePalette();
        }
    return ppalOld;
    }

HPALETTE CImgBrush::SetBrushPalette( HDC hdc, BOOL bForce )
    {
    CPalette* ppal    = NULL;
    HPALETTE  hpalOld = NULL;

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        ppal = theApp.m_pPalette;

    if (ppal != NULL)
        {
        hpalOld = ::SelectPalette( hdc, (HPALETTE)ppal->m_hObject, bForce );

        RealizePalette( hdc );
        }
    return hpalOld;
    }

BOOL CImgBrush::SetSize( CSize newSize, BOOL bStretchToFit )
    {
    BOOL bFlipX;
    BOOL bFlipY;

    if (newSize.cx == m_size.cx
    &&  newSize.cy == m_size.cy)
        return TRUE;

    if (bFlipX = (newSize.cx < 0))
        newSize.cx = -newSize.cx;

    if (bFlipY = (newSize.cy < 0))
        newSize.cy = -newSize.cy;

    if (newSize.cx == 0)
        newSize.cx  = 1;

    if (newSize.cy == 0)
        newSize.cy  = 1;

    if (CImgTool::GetCurrentID() != IDMX_TEXTTOOL)
        {
        CDC     newDC;
        CBitmap newBitmap;
        CDC     newMaskDC;
        CBitmap newMaskBitmap;

                //REARCHITECT Potential for DC && Bitmap leaks here on partial failure!!
        if (!         newDC.CreateCompatibleDC    ( &m_dc )
        ||  !     newBitmap.CreateCompatibleBitmap( &m_dc, newSize.cx, newSize.cy )
        ||  !     newMaskDC.CreateCompatibleDC    ( &m_dc )
        ||  ! newMaskBitmap.CreateBitmap(newSize.cx, newSize.cy, 1, 1, NULL ))
            return FALSE;

        CBitmap*  pbmOld      = newDC.SelectObject( &newBitmap );
        CPalette* ppalOldSrc  = SetBrushPalette(  &m_dc, FALSE );
        CPalette* ppalOldDest = SetBrushPalette( &newDC, FALSE );

        newDC.SetStretchBltMode(COLORONCOLOR);


        if (bStretchToFit)
            {
            StretchCopy( newDC.m_hDC, bFlipX ?  newSize.cx : 0,
                                      bFlipY ?  newSize.cy : 0,
                                      bFlipX ? -newSize.cx : newSize.cx,
                                      bFlipY ? -newSize.cy : newSize.cy,
                          m_dc.m_hDC, 0, 0, m_size.cx, m_size.cy );
            }
        else
            {
            StretchCopy( newDC.m_hDC, bFlipX ? newSize.cx : 0,
                                      bFlipY ? newSize.cy : 0,
                                      m_size.cx, m_size.cy,
                    m_dc.m_hDC, 0, 0, m_size.cx, m_size.cy );
            }


        COLORREF crOldBk    = newDC.SetBkColor( crRight );
        CBitmap* pbmOldMask = newMaskDC.SelectObject( &newMaskBitmap );

        if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
            {
            CFreehandSelectTool* pTool = (CFreehandSelectTool*)CImgTool::GetCurrent();

            if (pTool->ExpandPolyRegion( newSize.cx, newSize.cy ))
                {
                newMaskDC.PatBlt( 0, 0, newSize.cx, newSize.cy, BLACKNESS );

                if (m_cRgnPolyFreeHandSel.GetSafeHandle())
                    newMaskDC.FillRgn( &m_cRgnPolyFreeHandSel,
                                        CBrush::FromHandle( (HBRUSH)::GetStockObject( WHITE_BRUSH ) ) );
                }
            }
        else
            {
            newMaskDC.PatBlt( 0, 0, newSize.cx, newSize.cy, WHITENESS );
            }

        newMaskDC.BitBlt( 0, 0, newSize.cx, newSize.cy, &newDC, 0, 0, DSna );
        newDC.SetBkColor( crOldBk );

        if (ppalOldSrc)
            m_dc.SelectPalette( ppalOldSrc, FALSE );

        if (ppalOldDest)
            newDC.SelectPalette( ppalOldDest, FALSE );

        if (m_hbmOld)
            m_dc.SelectObject( CBitmap::FromHandle( m_hbmOld ) );

        if (m_hbmMaskOld)
            m_maskDC.SelectObject( CBitmap::FromHandle( m_hbmMaskOld ) );

                m_dc.DeleteDC();
            m_maskDC.DeleteDC();
            m_bitmap.DeleteObject();
        m_maskBitmap.DeleteObject();

                m_dc.Attach(         newDC.Detach() );
            m_bitmap.Attach(     newBitmap.Detach() );
            m_maskDC.Attach(     newMaskDC.Detach() );
        m_maskBitmap.Attach( newMaskBitmap.Detach() );

        m_hbmOld     = (HBITMAP)(pbmOld->GetSafeHandle());
        m_hbmMaskOld = (HBITMAP)(pbmOldMask->GetSafeHandle());
        }

    m_size.cx = newSize.cx;
    m_size.cy = newSize.cy;

    return TRUE;
    }


#if defined(DEBUGSHOWBITMAPS)
void DebugShowBitmap(HDC hdcSrc, int x, int y, int wid, int hgt)
{
        HDC hdcDst = GetDC(NULL);
        BitBlt(hdcDst, 0, 0, wid, hgt, hdcSrc, x, y, SRCCOPY);
        ReleaseDC(NULL, hdcDst);
}
#endif


BOOL QuickColorToMono(CDC* pdcMono, int xMono, int yMono, int cx, int cy,
        CDC *pdcColor, int xColor, int yColor, DWORD dwROP, COLORREF crTrans)
{
        RGBQUAD rgb[256];
        int nColors = GetDIBColorTable(pdcColor->m_hDC, 0, 256, &rgb[0]);
        if (nColors == 0)
        {
                return(FALSE);
        }

        RGBQUAD rgbWhite;
        rgbWhite.rgbRed   = 255;
        rgbWhite.rgbGreen = 255;
        rgbWhite.rgbBlue  = 255;
        rgbWhite.rgbReserved = 0;

        RGBQUAD rgbBlack;
        rgbBlack.rgbRed   = 0;
        rgbBlack.rgbGreen = 0;
        rgbBlack.rgbBlue  = 0;
        rgbBlack.rgbReserved = 0;

        RGBQUAD rgbTemp[256];

        switch ((BYTE)((crTrans)>>24))
        {
        case 0:
        case 2:
        {
                RGBQUAD rgbTrans;
                rgbTrans.rgbRed   = GetRValue(crTrans);
                rgbTrans.rgbGreen = GetGValue(crTrans);
                rgbTrans.rgbBlue  = GetBValue(crTrans);
                rgbTrans.rgbReserved = 0;

                for (int nColor=nColors-1; nColor>=0; --nColor)
                {
                        if (memcmp(&rgb[nColor], &rgbTrans, sizeof(rgbTrans)) == 0)
                        {
                                rgbTemp[nColor] = rgbWhite;
                        }
                        else
                        {
                                rgbTemp[nColor] = rgbBlack;
                        }
                }

                break;
        }

        // We can put support for different COLORREF formats here

        default:
                return(FALSE);
        }

        SetDIBColorTable(pdcColor->m_hDC, 0, nColors, &rgbTemp[0]);
        pdcMono->BitBlt(xMono, yMono, cx, cy, pdcColor, xColor, yColor, dwROP);
        SetDIBColorTable(pdcColor->m_hDC, 0, nColors, &rgb[0]);

        return(TRUE);
}


#define COLORTOMONOBUG
#ifdef  COLORTOMONOBUG
void CImgBrush::ColorToMonoBitBlt(CDC* pdcMono, int xMono, int yMono, int cx, int cy,
        CDC *pdcColor, int xColor, int yColor, DWORD dwROP, COLORREF transparentColor)
{
        if (QuickColorToMono(pdcMono, xMono, yMono, cx, cy,
                pdcColor, xColor, yColor, dwROP, transparentColor))
        {
                return;
        }

        CDC dcColor;
        CTempBitmap bmColor;
        CBitmap* pbmOldColor = NULL;

        // Use a moderate-sized intermediate bitmap
        int cyStep = 0xffff / cx;
        cyStep = max(1, min(cy, cyStep));

        HDC hdcScreen = GetDC(NULL);
        BOOL bError = (!dcColor.CreateCompatibleDC(NULL)
                        || !bmColor.CreateCompatibleBitmap(CDC::FromHandle(hdcScreen), cx, cyStep)
                        || (pbmOldColor = dcColor.SelectObject(&bmColor))==NULL);
        ReleaseDC(NULL, hdcScreen);

        if (bError)
        {
                theApp.SetGdiEmergency(FALSE);
                return;
        }

        CPalette* ppalOld  = SetBrushPalette( pdcColor, FALSE );
        CPalette* ppalOldColor  = SetBrushPalette( &dcColor, FALSE );
        dcColor.SetBkColor( transparentColor );

        int yStep;
        for (yStep=0; yStep<cy; yStep+=cyStep)
        {
                if (cyStep > cy - yStep)
                {
                        cyStep = cy - yStep;
                }

                dcColor.BitBlt(0, 0, cx, cyStep, pdcColor, xColor, yColor+yStep, SRCCOPY);
                pdcMono->BitBlt(xMono, yMono+yStep, cx, cyStep, &dcColor, 0, 0, dwROP);

                DebugShowBitmap(pdcMono->m_hDC, xMono, yMono, cx, cy);
        }

        if (ppalOld)
        {
                pdcColor->SelectPalette( ppalOld, FALSE );
        }

        dcColor.SelectObject(pbmOldColor);

        if (ppalOldColor)
        {
                dcColor.SelectPalette( ppalOldColor, FALSE );
        }
}
#endif  // COLORTOMONOBUG

void CImgBrush::RecalcMask( COLORREF transparentColor )
    {
    if (! m_dc.GetSafeHdc() || ! m_maskDC.m_hDC)
        return;

#ifndef COLORTOMONOBUG
    CPalette* ppalOld  = SetBrushPalette( &m_dc, FALSE );
    COLORREF oldBkColor = m_dc.SetBkColor( transparentColor );
#endif  // COLORTOMONOBUG

    if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        m_maskDC.PatBlt( 0, 0, m_size.cx, m_size.cy, BLACKNESS );

        if (m_cRgnPolyFreeHandSel.GetSafeHandle())
            m_maskDC.FillRgn( &m_cRgnPolyFreeHandSel,
                            CBrush::FromHandle( (HBRUSH)::GetStockObject( WHITE_BRUSH ) ) );

        if (! m_bOpaque) // can't test true, since bitfield
#ifdef  COLORTOMONOBUG
            ColorToMonoBitBlt(&m_maskDC, 0, 0, m_size.cx, m_size.cy,
                &m_dc, 0, 0, DSna, transparentColor);
#else   // COLORTOMONOBUG
            m_maskDC.BitBlt( 0, 0, m_size.cx, m_size.cy, &m_dc, 0, 0, DSna );
#endif  // COLORTOMONOBUG
        }
    else
        {
#ifdef  COLORTOMONOBUG
        ColorToMonoBitBlt(&m_maskDC, 0, 0, m_size.cx, m_size.cy,
            &m_dc, 0, 0, NOTSRCCOPY, transparentColor);
#else   // COLORTOMONOBUG
        m_maskDC.BitBlt( 0, 0, m_size.cx, m_size.cy, &m_dc, 0, 0, NOTSRCCOPY );
#endif  // COLORTOMONOBUG
        }

#ifndef COLORTOMONOBUG
    m_dc.SetBkColor( oldBkColor );

    if (ppalOld)
        m_dc.SelectPalette( ppalOld, FALSE );
#endif  // COLORTOMONOBUG
    }


void GetMonoBltColors(HDC hDC, HBITMAP hBM, COLORREF& crNewBk, COLORREF& crNewText)
{
        crNewBk   = RGB(0xff, 0xff, 0xff);
        crNewText = RGB(0x00, 0x00, 0x00);

        RGBQUAD rq;
        if (GetDIBColorTable(hDC, 0, 1, &rq) == 1)
        {
                if (hBM == NULL)
                {
                        hBM = (HBITMAP) GetCurrentObject(hDC, OBJ_BITMAP);
                }

                WORD nMaxIndex = 0xff;

                BITMAP bm;
                if (GetObject(hBM, sizeof(bm), &bm))
                {
                        nMaxIndex = (1 << bm.bmBitsPixel) - 1;
                }

                crNewBk   = DIBINDEX(nMaxIndex);
                crNewText = DIBINDEX(0x00);
        }
}


// This handles drawing the brush with Draw Opaque turned off.
//
void CImgBrush::BltMatte(IMG* pimg, CPoint topLeft)
    {
        COLORREF crNewBk, crNewText;
        GetMonoBltColors(pimg->hDC, pimg->hBitmap, crNewBk, crNewText);

    COLORREF crOldBk = SetBkColor(pimg->hDC, crNewBk);
    COLORREF crOldText = SetTextColor(pimg->hDC, crNewText);
    CPalette* ppalOld = SetBrushPalette( &m_dc, FALSE ); // Background ??

    // Copying from a bitmap...

DebugShowBitmap(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy);
    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
          m_dc.m_hDC, 0, 0, DSx);
DebugShowBitmap(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy);

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
      m_maskDC.m_hDC, 0, 0, DSna);
DebugShowBitmap(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy);

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
          m_dc.m_hDC, 0, 0, DSx);
DebugShowBitmap(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy);

    if (ppalOld)
        m_dc.SelectPalette( ppalOld, FALSE ); // Background ??

    SetBkColor(pimg->hDC, crOldBk);
    SetTextColor(pimg->hDC, crOldText);
    }

// This handles drawing the brush with Draw Opaque turned on.
//
void CImgBrush::BltReplace(IMG* pimg, CPoint topLeft)
    {
    int iToolID =  CImgTool::GetCurrentID();

    if (iToolID == IDMB_PICKRGNTOOL)
        {
        BltMatte( pimg, topLeft );
        }
    else
        {
        CPalette* ppalOld = SetBrushPalette( &m_dc, FALSE ); // Background ??

        BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
               m_dc.m_hDC, 0, 0, SRCCOPY);

        if (ppalOld)
            m_dc.SelectPalette( ppalOld, FALSE ); // Background ??
        }
    }


// This handles erasing with the brush (draws mask in solid color).
//
void CImgBrush::BltColor(IMG* pimg, CPoint topLeft, COLORREF color)
    {
    COLORREF crOldBk = SetBkColor(pimg->hDC, color);
    COLORREF crOldText = SetTextColor(pimg->hDC, RGB(0, 0, 0));

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
      m_maskDC.m_hDC, 0, 0, DSx);

    SetBkColor(pimg->hDC, RGB(255, 255, 255));

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
      m_maskDC.m_hDC, 0, 0, DSna);

    SetBkColor(pimg->hDC, color);

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
      m_maskDC.m_hDC, 0, 0, DSx);

    SetTextColor(pimg->hDC, crOldText);
    SetBkColor(pimg->hDC, crOldBk);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgcpyps.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "tedit.h"
#include "t_text.h"
#include "t_fhsel.h"
#include "toolbox.h"
#include "props.h"
#include "undo.h"
#include "srvritem.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

BOOL GetMFDimensions(
    HANDLE hMF,     /* handle to the CF_METAFILEPICT object from clipbrd */
    HDC hDC,        /* display context */
    long *pWidth,    /* width of picture in pixels, OUT param */
    long *pHeight,   /* height of picture in pixels, OUT param */
    long *pcXPelsPerMeter,    /* horizontal resolution, OUT param */
    long *pcYPelsPerMeter,    /* vertical resolution, OUT param */
    IMG* pImg)
    ;
BOOL PlayMetafileIntoDC(
    HANDLE hMF,
    RECT *pRect,
    HDC hDC)
    ;

/***************************************************************************/

void CImgWnd::OnDestroyClipboard()
    {
    if (m_hPoints)
        {
        ::GlobalFree( m_hPoints );
        m_hPoints = NULL;
        }
    }

/***************************************************************************/

void CImgWnd::CopyBMAndPal(HBITMAP *pBM, CPalette ** ppPal)
    {
    IMG* pImg = m_pImg;

    CRect copyRect;

    if (theImgBrush.m_pImg == NULL)
        {
        HideBrush();
        copyRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
        }
    else
        {
        copyRect = rcDragBrush;
        copyRect.right  -= 1;
        copyRect.bottom -= 1;
        }

    BOOL bRegion = (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL);

#ifdef FHSELCLIP
    if (bRegion)
        {
        if (! m_wClipboardFormat)
            m_wClipboardFormat = RegisterClipboardFormat( TEXT("MSPaintFreehand") );

        if (theImgBrush.m_bFirstDrag)
//          PickupSelection(); but no way to tell if we do it twice...
            PrepareForBrushChange( TRUE, FALSE );

        CFreehandSelectTool* pTool = (CFreehandSelectTool*)CImgTool::GetCurrent();

        ASSERT( pTool );

        if (m_wClipboardFormat && pTool)
            {
            CPoint* pptArray;
            int     iEntries;
            BOOL    bData = pTool->CopyPointsToMemArray( &pptArray, &iEntries );

            if (bData && iEntries)
                {
                HGLOBAL hMem = ::GlobalAlloc( GHND | GMEM_MOVEABLE | GMEM_DDESHARE,
                                                    iEntries * sizeof( POINT )
                                                             + sizeof( short ));
                if (hMem)
                    {
                    short* pShort = (short*)::GlobalLock( hMem );

                    *pShort++ = iEntries;

                    LPPOINT pPts = (LPPOINT)pShort;

                    for (int iPt = 0; iPt < iEntries; iPt++, pPts++)
                        {
                        pPts->x = pptArray[iPt].x - pTool->m_cRectBounding.left;
                        pPts->y = pptArray[iPt].y - pTool->m_cRectBounding.top;
                        }

                    ::GlobalUnlock( hMem );

                    if (m_hPoints)
                        {
                        ::GlobalFree( m_hPoints );
                        m_hPoints = NULL;
                        }

                    m_hPoints = SetClipboardData( m_wClipboardFormat, hMem );
                    }
                else
                    theApp.SetMemoryEmergency();

                delete [] pptArray;
                }
            }
        else
            theApp.SetGdiEmergency();
        }
#endif // FHSELCLIP

    if ( theImgBrush.m_pImg )
        {
        CPalette* ppalOld = SetImgPalette( &theImgBrush.m_dc );

        // Copy the selection...
        CRect rc( 0, 0, theImgBrush.m_size.cx, theImgBrush.m_size.cy );

        *pBM = CopyDC( &theImgBrush.m_dc, &rc );

        if (ppalOld)
            theImgBrush.m_dc.SelectPalette( ppalOld, TRUE );
        }
    else
        // Copy the whole image...
        *pBM = CopyDC( CDC::FromHandle( m_pImg->hDC ), &copyRect );

    if (theApp.m_pPalette && (*ppPal=new CPalette)!=NULL)
        {
        LOGPALETTE256 logPal;

        logPal.palVersion = 0x300;
        logPal.palNumEntries = (WORD)theApp.m_pPalette->GetPaletteEntries( 0, 256,
                                                     &logPal.palPalEntry[0]);

                if ( logPal.palNumEntries )
                        {
                theApp.m_pPalette->GetPaletteEntries( 0, logPal.palNumEntries,
                                                             &logPal.palPalEntry[0] );

                (*ppPal)->CreatePalette( (LPLOGPALETTE)&logPal );
                        }
        }
    }

void CImgWnd::CmdCopy()
{
        if (TextToolProcessed( ID_EDIT_COPY ))
        {
                return;
        }

        CBitmapObj* pResObject = new CBitmapObj;
        if (pResObject)
        {
                IMG* pImgStruct = new IMG;

                if (pImgStruct)
                {
                        if (FillBitmapObj(c_pImgWndCur, pResObject, pImgStruct))
                        {
                                pImgStruct->m_pFirstImgWnd = NULL;
                                pImgStruct->m_pBitmapObj = pResObject;

                                HDC hDCSave = pImgStruct->hDC;

                                pImgStruct->hDC = NULL;
                                pImgStruct->hMaskDC = NULL;

                                pImgStruct->hMaskBitmap = NULL;
                                pImgStruct->hMaskBitmapOld = NULL;

                                pImgStruct->hBitmap = NULL;
                                pImgStruct->m_pPalette = NULL;
                                CopyBMAndPal(&pImgStruct->hBitmap, &pImgStruct->m_pPalette);

                                if (pImgStruct->hBitmap)
                                {
                                        pImgStruct->hDC = CreateCompatibleDC(hDCSave);
                                        if (pImgStruct->hDC)
                                        {
                                                pImgStruct->hBitmapOld = (HBITMAP)SelectObject(
                                                        pImgStruct->hDC, pImgStruct->hBitmap);
                                                pImgStruct->m_hPalOld = pImgStruct->m_pPalette
                                                        ? SelectPalette(pImgStruct->hDC,
                                                        (HPALETTE)pImgStruct->m_pPalette->m_hObject, FALSE)
                                                        : NULL;

                                                // get a server item suitable to generate the clipboard data
                                                CPBView* pView = (CPBView*)
                                                        ((CFrameWnd*)AfxGetMainWnd())->GetActiveView();
                                                CPBSrvrItem* pItem = new CPBSrvrItem(pView->GetDocument(),
                                                        pResObject);

                                                if (pItem)
                                                {
                                                        pItem->CopyToClipboard(FALSE);

                                                        delete pItem;

                                                        return;
                                                }
                                        }
                                }
                        }
                        else
                        {
                                // the IMG and all it contains will get cleaned up when
                                // pResObject is deleted, but only if FillBitmapObj succeeded
                                delete pImgStruct;
                        }
                }

                delete pResObject;
        }
}

/***************************************************************************/

void CImgWnd::CmdCut()
    {
    if (TextToolProcessed( ID_EDIT_CUT ))
        return;

    // BOGUS:
    // CmdCopy doesn't just copy -- it can change the state of the selection
    // this forces the CmdClear to act in the context of the new state
    // save off a flag for CmdClear to special-case like 'first-drag'
    BOOL *pFlag;
    if (theImgBrush.m_pImg && theImgBrush.m_bFirstDrag)
        {
        pFlag = &theImgBrush.m_bCuttingFromImage;
        }
    else
        pFlag = NULL;

    CmdCopy();

    TRY
        {
        if (pFlag)
            *pFlag = TRUE;

        CmdClear();
        }
    CATCH_ALL(e)
        {
        // don't leave the flag set
        if (pFlag)
            *pFlag = FALSE;

        THROW_LAST();
        }
    END_CATCH_ALL

    // normal execution path
    if (pFlag)
        *pFlag = FALSE;
    }

/***************************************************************************/

void CImgWnd::CmdPaste()
    {
    if (TextToolProcessed( ID_EDIT_PASTE ))
        return;

    CancelToolMode(FALSE);

    CommitSelection(TRUE);

    HideBrush();
    SetupRubber( m_pImg );
    EraseTracker();
    theImgBrush.m_pImg = NULL;
    DrawTracker();
    SetUndo( m_pImg );

    if (! PasteImageClip())
        AfxMessageBox( IDS_ERROR_CLIPBOARD, MB_OK | MB_ICONHAND );
    }

/***************************************************************************/

HBITMAP CImgWnd::CopyDC( CDC* pImgDC, CRect* prcClip )
    {
    // BLOCK: copy the image to hStdBitmap for the clipboard
    CDC       dc;
    CBitmap   bm;
    CBitmap*  pOldStdBitmap;
    int       cxWidth  = prcClip->Width();
    int       cyHeight = prcClip->Height();

    if (! dc.CreateCompatibleDC    ( pImgDC                    )
    ||  ! bm.CreateCompatibleBitmap( pImgDC, cxWidth, cyHeight ))
        {
        theApp.SetGdiEmergency();
        return FALSE;
        }

    pOldStdBitmap = dc.SelectObject( &bm );

    CPalette* pOldPalette = SetImgPalette( &dc );

    dc.BitBlt( 0, 0, cxWidth, cyHeight, pImgDC, prcClip->left, prcClip->top, SRCCOPY );
    dc.SelectObject( pOldStdBitmap );

    if (pOldPalette)
        dc.SelectPalette( pOldPalette, FALSE );

    // return the standard format (bitmap) data
    return (HBITMAP)bm.Detach();
    }

/***************************************************************************/

BOOL CImgWnd::IsPasteAvailable()
    {
    BOOL bPasteIsAvailable = FALSE;
    BOOL bBitmapAvailable  = IsClipboardFormatAvailable( CF_BITMAP );
    BOOL bDIBAvailable     = IsClipboardFormatAvailable( CF_DIB );
    BOOL bTextAvailable    = IsClipboardFormatAvailable( CF_TEXT );
    BOOL bMFAvailable      = IsClipboardFormatAvailable( CF_METAFILEPICT );

    if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

        if (pTextTool                     != NULL
        &&  pTextTool->GetTextEditField() != NULL)
            bPasteIsAvailable = bTextAvailable;
        }
    else
        {
        bPasteIsAvailable = bBitmapAvailable || bDIBAvailable || bMFAvailable;
        }

    return bPasteIsAvailable;
    }

/***************************************************************************/

BOOL CImgWnd::IsSelectionAvailable( void )
    {
    if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

        if (pTextTool != NULL
        &&  pTextTool->IsKindOf( RUNTIME_CLASS( CTextTool ) ))
            {
            CTedit* pTextEdit = pTextTool->GetTextEditField();

            if (pTextEdit != NULL
            &&  pTextEdit->IsKindOf( RUNTIME_CLASS( CTedit ) ))
                {
                DWORD dwSel = pTextEdit->GetEditWindow()->GetSel();
                BOOL bReturn = (HIWORD( dwSel) != LOWORD( dwSel ));

                if (! bReturn)
                    bReturn = (pTextEdit->GetEditWindow()->GetWindowTextLength()
                           != (int)LOWORD( dwSel ));

                return bReturn;
                }
            }
        }

    if (CImgTool::GetCurrentID() == IDMB_PICKTOOL
    ||  CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        return (theImgBrush.m_pImg != NULL && ! g_bCustomBrush);
        }
    return FALSE;
    }

/***************************************************************************/

int PASCAL CheckPastedSize(int nWidth, int nHeight, IMG* pImg)
{
        int nRet = IDNO;

        // If the image is a bitmap and the bitmap in the clipboard is larger,
        // then give the suer the option2 of growing the image...
        if (nWidth  > pImg->cxWidth
                ||  nHeight > pImg->cyHeight)
        {
                CSize size( max(nWidth, pImg->cxWidth),
                        max(nHeight, pImg->cyHeight) );

                theUndo.BeginUndo( TEXT("Resize Bitmap") );
                VERIFY( pImg->m_pBitmapObj->SetSizeProp( P_Size, size ) );

                theUndo.EndUndo();

                // PSS says users don't want to see this dialog
#if 0
                // WARNING!!! MB_SYSTEMMODAL is _necessary_.  No message boxes should
                // be run while the clipboard is opened.  Loss of focus to other apps
                // can be disasterous! The clipboard will be hung or if the clipboard
                // is closed, the contents could be changed by another app.

                nRet = AfxMessageBox( IDS_ENLAGEBITMAPFORCLIP,
                        MB_YESNOCANCEL | MB_ICONQUESTION | MB_SYSTEMMODAL );
                switch (nRet)
                {
                        case IDYES:
                        {
                                CSize size( max(nWidth, pImg->cxWidth),
                                        max(nHeight, pImg->cyHeight) );

                                theUndo.BeginUndo( TEXT("Resize Bitmap") );
                                VERIFY( pImg->m_pBitmapObj->SetSizeProp( P_Size, size ) );

                                theUndo.EndUndo();
                        }
                        break;
                }
#endif
        }

        return(nRet);
}

struct CStgMedium : public STGMEDIUM
{
    CStgMedium()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~CStgMedium()
    {
        ReleaseStgMedium(this);
    }
};

HGLOBAL
_GetClipboardData (CLIPFORMAT cf, TYMED tymed, STGMEDIUM *pMedium)
{
    IDataObject *pdo = NULL;
    HANDLE hRet = NULL;

    if (SUCCEEDED(OleGetClipboard (&pdo)))
    {
        FORMATETC fmt = { 0 };

        fmt.cfFormat = cf;
        fmt.lindex   = -1;
        fmt.tymed    = tymed;
        fmt.dwAspect = DVASPECT_CONTENT;

        pMedium->tymed = tymed;

        if (SUCCEEDED(pdo->GetData (&fmt, pMedium)))
        {
            hRet = pMedium->hGlobal;
        }
        else
        {
            ReleaseStgMedium(pMedium);
        }

        pdo->Release ();
    }
    else
    {
        TRACE( TEXT("Cannot open clipboard!\n") );
    }

    return hRet;
}

BOOL CImgWnd::PasteImageClip()
    {
    CWaitCursor wait;
    /////////////////////////////////////////////////////////////////////////
    // Find out what format is available on the clipboard. if it is
    //   A. CF_BITMAP only - Set the mask bits opaque and blt the bitmap
    //      into ICimageDC
    // In both cases, if the destination bitmap differs in size from
    // source bitmap, user is asked if he/she wants the src bitmap
    // stretched/clipped to new size
    /////////////////////////////////////////////////////////////////////////
    if (! m_wClipboardFormat)
        m_wClipboardFormat = (WORD)RegisterClipboardFormat( TEXT("MSPaintFreehand") );


    // Enumerate the cliboard contents to determine what is available.
    // If a CF_BITMAP is seen, set a flag and proceed. If a SDKPAINT
    // private format is seen, stop looking further
    BOOL bBitmapAvailable  = FALSE;
#ifdef FHSELCLIP
    BOOL bPrivateAvailable = FALSE;
#endif // FHSELCLIP
    BOOL bPaletteAvailable = FALSE;
    BOOL bDIBAvailable     = FALSE;
    BOOL bMFAvailable      = FALSE;
    WORD wClipFmt          = 0;

    BITMAP    bmData;
    LONG      cXPelsPerMeter = 0;
    LONG      cYPelsPerMeter = 0;
    BOOL      bResizedBitmap = FALSE;
    CPalette* ppalClipboard  = NULL;
    CBitmap*  pbmClipboard   = NULL;
    LPSTR     lpDib          = NULL;
    HPALETTE  hPal           = NULL;
    HBITMAP   hBitmap        = NULL;
    HGLOBAL   hDIB           = NULL;
    HGLOBAL   hMF            = NULL;

    CStgMedium stgMedium;

        BOOL bGotClip = FALSE;

        hPal = (HPALETTE)_GetClipboardData( CF_PALETTE, TYMED_GDI, &stgMedium );
        if (hPal)
        {
                bPaletteAvailable = TRUE;
                ppalClipboard = CPalette::FromHandle( hPal );

                ReleaseStgMedium(&stgMedium);
        }

    if (!bGotClip)
        {
        hDIB = (HGLOBAL)_GetClipboardData( CF_DIB, TYMED_HGLOBAL, &stgMedium );

        if (hDIB)
            {
            lpDib = (LPSTR)::GlobalLock( hDIB );

            if (lpDib)
                {
                bmData.bmWidth  = DIBWidth ( lpDib );
                bmData.bmHeight = DIBHeight( lpDib );

                if (bmData.bmWidth && bmData.bmHeight)
                    {
                    bDIBAvailable = TRUE;
                    bPaletteAvailable = FALSE;

                    PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) lpDib;

                    if (pbmih->biSize >= sizeof(BITMAPINFOHEADER))
                        {
                        cXPelsPerMeter = pbmih->biXPelsPerMeter;
                        cYPelsPerMeter = pbmih->biYPelsPerMeter;
                        }
                    }
                }
            }
        #ifdef _DEBUG
        TRACE1( "Loaded the DIB %s.\n", (bDIBAvailable? TEXT("Yes"): TEXT("No")) );
        #endif

        bGotClip = bDIBAvailable;
        }

    if (!bGotClip)
        {
        hBitmap = (HBITMAP)_GetClipboardData( CF_BITMAP, TYMED_GDI, &stgMedium );

        if (hBitmap)
            {
            pbmClipboard = CBitmap::FromHandle( hBitmap );

            if (pbmClipboard->GetObject( sizeof( BITMAP ), &bmData ))
                {
                bBitmapAvailable = TRUE;

                DIBSECTION ds;

                if (pbmClipboard->GetObject( sizeof( ds ), &ds ))
                    {
                    cXPelsPerMeter = ds.dsBmih.biXPelsPerMeter;
                    cYPelsPerMeter = ds.dsBmih.biYPelsPerMeter;
                    }

                if (bPaletteAvailable)
                    {
                    if (!ppalClipboard)
                        bBitmapAvailable = FALSE;
                    }
                }
            }

        #ifdef _DEBUG
        TRACE1( "Loaded the Bitmap %s.\n", (bBitmapAvailable? TEXT("Yes"): TEXT("No")) );
        #endif

        bGotClip = bBitmapAvailable;
        }

        if (!bGotClip)
        {
                hMF = (HGLOBAL)_GetClipboardData(CF_METAFILEPICT, TYMED_MFPICT, &stgMedium);
                if (hMF)
                {
                        CDC dcMF;

                        if (dcMF.CreateCompatibleDC( NULL ))
                        {
                                if (GetMFDimensions(hMF, dcMF.m_hDC, &bmData.bmWidth,
                                        &bmData.bmHeight, &cXPelsPerMeter, &cYPelsPerMeter, m_pImg))
                                {
                                        bMFAvailable = TRUE;
                                }
                        }
                }

                bGotClip = bMFAvailable;
        }

    if (!bGotClip)
        {
        return FALSE;
        }

    switch (CheckPastedSize(bmData.bmWidth, bmData.bmHeight, m_pImg))
        {
        default:
            return TRUE;

        case IDYES:
            bResizedBitmap = TRUE;
            break;

        case IDNO:
            break;
        }

    CDC       stdDC;
    BOOL      bOkay   = FALSE;
    CBitmap*  pbmOld  = NULL;
    CPalette* ppalOld = NULL;

    if (bBitmapAvailable)
        {
        CBitmap   bmClipboard;
        CBitmap*  pbmOldCopy  = NULL;
        CPalette* ppalOldCopy = NULL;
        CDC*      pdcCopy     = NULL;

        if (! stdDC.CreateCompatibleDC( NULL ))
            {
            theApp.SetGdiEmergency();
            goto LReturn;
            }

        pbmOld = stdDC.SelectObject( pbmClipboard );

        if (! pbmOld)
            {
            theApp.SetGdiEmergency();
            goto LReturn;
            }

        if (ppalClipboard)
            {
            ppalOld = stdDC.SelectPalette( ppalClipboard, FALSE );
            stdDC.RealizePalette();
            }

        // duplicate the bitmap
        if (! bmClipboard.CreateBitmap( bmData.bmWidth, bmData.bmHeight,
                                        bmData.bmPlanes, bmData.bmBitsPixel, NULL ))
            {
            theApp.SetMemoryEmergency();
            goto LReturn;
            }

        pdcCopy = new CDC;

        if (pdcCopy == NULL)
            {
            theApp.SetMemoryEmergency();
            goto LReturn;
            }

        if (! pdcCopy->CreateCompatibleDC( NULL ))
            {
            delete pdcCopy;
            theApp.SetGdiEmergency();
            goto LReturn;
            }

        pbmOldCopy = pdcCopy->SelectObject( &bmClipboard );

        if (ppalClipboard)
            {
            ppalOldCopy = pdcCopy->SelectPalette( ppalClipboard, FALSE );
            pdcCopy->RealizePalette();
            }

        pdcCopy->BitBlt( 0, 0, bmData.bmWidth, bmData.bmHeight, &stdDC, 0, 0, SRCCOPY );

        if (ppalOldCopy)
            pdcCopy->SelectPalette( ppalOldCopy, FALSE );

        pdcCopy->SelectObject( pbmOldCopy );
        delete pdcCopy;

        stdDC.SelectObject( &bmClipboard );

        // Unload the bitmap
        stdDC.SelectObject( pbmOld );
        pbmOld = NULL;

        if (ppalOld)
            {
            stdDC.SelectPalette( ppalOld, FALSE );
            ppalOld = NULL;
            }

        // if we still do not know the image resolution, use the display resolution
        if (cXPelsPerMeter == 0 && cYPelsPerMeter == 0)
            {
            cXPelsPerMeter = MulDiv(::GetDeviceCaps(stdDC, LOGPIXELSX),10000, 254);
            cYPelsPerMeter = MulDiv(::GetDeviceCaps(stdDC, LOGPIXELSY),10000, 254);
            }

        stdDC.DeleteDC();
        // Now we convert our nice DDB to a DIB and back so we can
        // convert color bitmaps to monochrome nicely and deal with
        // palette differences...
        DWORD dwSize;

        lpDib = (LPSTR) DibFromBitmap( 
            (HBITMAP)bmClipboard.GetSafeHandle(), 
            BI_RGB, 
            0,                                     
            ppalClipboard, 
            NULL, 
            dwSize,
            cXPelsPerMeter, 
            cYPelsPerMeter );
        }

        if (bMFAvailable)
        {
                CDC dcMF;

                if (dcMF.CreateCompatibleDC(CDC::FromHandle(m_pImg->hDC)))
                {
                        CBitmap bmMF;

                        if (bmMF.CreateCompatibleBitmap(CDC::FromHandle(m_pImg->hDC),
                                bmData.bmWidth, bmData.bmHeight))
                        {
                                dcMF.SelectObject(&bmMF);
                                //not needed for DIBSection!!!
                                if (ppalClipboard)
                                {
                                        dcMF.SelectPalette(ppalClipboard, FALSE);
                                }

                                CRect rc(0, 0, bmData.bmWidth, bmData.bmHeight);

                                PlayMetafileIntoDC(hMF, &rc, dcMF.m_hDC);

                                // Select out the bitmap and palette
                                dcMF.DeleteDC();

                                DWORD dwSize;

                                lpDib = (LPSTR) DibFromBitmap(
                                    (HBITMAP)bmMF.m_hObject, BI_RGB, 0,
                                    ppalClipboard, NULL, dwSize,
                                    cXPelsPerMeter, cYPelsPerMeter );
                        }
                }
        }

    if (lpDib)
        {
        CPalette* ppalDib = CreateDIBPalette( lpDib );

        ppalDib = FixupDibPalette( lpDib, ppalDib );

        HBITMAP hbmDib = DIBToBitmap( lpDib, theApp.m_pPalette, m_pImg->hDC );

        if (bDIBAvailable)
            ::GlobalUnlock( hDIB );
        else
            FreeDib( lpDib );

        if (hbmDib != NULL
        && stdDC.CreateCompatibleDC( CDC::FromHandle( m_pImg->hDC ) ))
            {
            CRect   rtBrush( 0, 0, bmData.bmWidth, bmData.bmHeight );
            BOOL    bBrushMade = FALSE;
            CBitmap bmDib;

            bmDib.Attach( hbmDib );

            pbmOld = stdDC.SelectObject( &bmDib );

            if (m_pImg->m_pPalette)
                {
                ppalOld = stdDC.SelectPalette( m_pImg->m_pPalette, FALSE );
                stdDC.RealizePalette();
                }

#ifdef FHSELCLIP
            if (bPrivateAvailable)
                {
                HGLOBAL hPts = (HGLOBAL)_GetClipboardData( m_wClipboardFormat );

                if (hPts)
                    {
                    short* lpShort = (short*)::GlobalLock( hPts );

                    if (lpShort)
                        {
                        BOOL bError   = FALSE;
                        int  iEntries = *lpShort++;
                        LPPOINT lpPts = (LPPOINT)lpShort;

                        CImgTool::Select( IDMB_PICKRGNTOOL );
                        CFreehandSelectTool* pTool = (CFreehandSelectTool*)CImgTool::GetCurrent();

                        if (pTool)
                            {
                            if (pTool->CreatePolyRegion( GetZoom(), lpPts, iEntries )
                            &&  MakeBrush( stdDC.m_hDC, rtBrush ))
                                {
                                bBrushMade = TRUE;
                                }
                            }
                        ::GlobalUnlock( hPts );
                        }
                    }
                }
#endif // FHSELCLIP

            if (! bBrushMade)
                {
                if (CImgTool::GetCurrentID() != IDMB_PICKTOOL)
                    CImgTool::Select( IDMB_PICKTOOL );

                bBrushMade = MakeBrush( stdDC.m_hDC, rtBrush );
                }

            if (bBrushMade)
                {
                // We have to "move" the brush so it appears...
                CRect rect( 0, 0, theImgBrush.m_rcSelection.Width(),
                                  theImgBrush.m_rcSelection.Height() );

                if (! bResizedBitmap)
                    {
                    // Move the brush so that it is in the upper-left corner of
                    // the view (in case it's scrolled)...
                    rect.OffsetRect( -m_xScroll, -m_yScroll );
                    }
                MoveBrush( rect );

                DirtyImg( m_pImg );

                theImgBrush.m_bFirstDrag = FALSE;

                bOkay = TRUE;
                }
            else
                {
                TRACE( TEXT("Paste: MakeBrush failed!\n") );
                }
            if (ppalOld)
                {
                ppalOld = stdDC.SelectPalette( ppalOld, FALSE );
                ppalOld = NULL;
                }

            stdDC.SelectObject( pbmOld );
            pbmOld = NULL;
            bmDib.Detach();
            }

        if (hbmDib != NULL)
            ::DeleteObject( hbmDib );

        if (ppalDib != NULL)
            delete ppalDib;
        }
LReturn:
    if (pbmOld != NULL)
        stdDC.SelectObject( pbmOld );

    if (ppalOld != NULL)
        stdDC.SelectPalette( ppalOld, FALSE );

    return bOkay;
    }

/***************************************************************************/
/* very similar to PasteImageClip, but this will paste into an existing    */
/* selection (theImgBrush), resizing it if necessary, and not moving it    */
/***************************************************************************/

BOOL CImgWnd::PasteImageFile( LPSTR lpDib )
    {
    CDC   stdDC;
    CRect cRectSelection = theImgBrush.m_rcSelection;
    BOOL bOkay = FALSE;

    if (lpDib == NULL)
        return bOkay;

    int iWidth  = (int)DIBWidth ( lpDib );
    int iHeight = (int)DIBHeight( lpDib );

    if (CImgTool::GetCurrentID()==IDMB_PICKTOOL && theImgBrush.m_bFirstDrag)
    {
        if (iWidth < theImgBrush.m_size.cx)
            {
            cRectSelection.right = cRectSelection.left + iWidth - 1;
            }
        if (iHeight < theImgBrush.m_size.cy)
            {
            cRectSelection.bottom = cRectSelection.top + iHeight - 1;
            }

        // If the image is a bitmap and the bitmap in the clipboard is larger,
        // then give the user the option of growing the image...
        if (iWidth  > theImgBrush.m_size.cx
        ||  iHeight > theImgBrush.m_size.cy)
            {
                cRectSelection.right  = cRectSelection.left + iWidth  - 1;
                cRectSelection.bottom = cRectSelection.top  + iHeight - 1;

                // PSS says users don't want to see this dialog
#if 0
            switch (AfxMessageBox( IDS_ENLAGEBITMAPFORCLIP,
                                    MB_YESNOCANCEL | MB_ICONQUESTION ))
                {
                default:
                    return bOkay;
                    break;

                case IDYES:
                    cRectSelection.right  = cRectSelection.left + iWidth  - 1;
                    cRectSelection.bottom = cRectSelection.top  + iHeight - 1;
                    break;

                case IDNO:
                    break;
                }
#endif
            }
    }
    else
    {
                int xPos = -m_xScroll;
                int yPos = -m_yScroll;

                switch (CheckPastedSize(iWidth, iHeight, m_pImg))
                {
                case IDYES:
                        xPos = yPos = 0;
                        break;

                case IDNO:
                        break;

                default:
                        return(bOkay);
                }

                CImgTool::Select(IDMB_PICKTOOL);
                cRectSelection = CRect(xPos, yPos, xPos+iWidth, yPos+iHeight);
    }

    MakeBrush( m_pImg->hDC, cRectSelection );
    // MakeBrush sets this
    theImgBrush.m_bFirstDrag = FALSE;

    if (! stdDC.CreateCompatibleDC( CDC::FromHandle( m_pImg->hDC ) ))
        {
        theApp.SetGdiEmergency();
        return bOkay;
        }

    CPalette* ppalDib = CreateDIBPalette( lpDib );

    ppalDib = FixupDibPalette( lpDib, ppalDib );

    HBITMAP hbmDib = DIBToBitmap( lpDib, theApp.m_pPalette, m_pImg->hDC );

    SetUndo( m_pImg );

    if (hbmDib != NULL)
        {
        CBitmap   bmDib;
        CPalette* ppalOld = NULL;
        CBitmap*  pbmOld  = NULL;

        bmDib.Attach( hbmDib );

        pbmOld = stdDC.SelectObject( &bmDib );

        if (m_pImg->m_pPalette)
            {
            ppalOld = stdDC.SelectPalette( m_pImg->m_pPalette, FALSE );
            stdDC.RealizePalette();
            }

        if (MakeBrush( stdDC.m_hDC, CRect( CPoint( 0, 0 ), cRectSelection.Size() ) ))
            {
            theImgBrush.m_bFirstDrag = FALSE;

            // We have to "move" the brush so it appears...
            MoveBrush( cRectSelection );

            DirtyImg( m_pImg );

            bOkay = TRUE;
            }
        else
            {
            TRACE( TEXT("Paste: MakeBrush failed!\n") );
            }

        if (ppalOld != NULL)
            {
            ppalOld = stdDC.SelectPalette( ppalOld, FALSE );
            }

        stdDC.SelectObject( pbmOld );
        bmDib.Detach();

        ::DeleteObject( hbmDib );
        }

    if (ppalDib != NULL)
        delete ppalDib;

    return bOkay;
    }

/***************************************************************************/
// Stolen from PBrush
//
/****************************Module*Header******************************\
* Module Name: metafile.c                                               *
* Routines to paste a metafile as a bitmap.                             *
* Copyright (c) 1987 - 1991  Microsoft Corporation                      *
\***********************************************************************/

/* Computes dimensions of a metafile picture in pixels */
BOOL GetMFDimensions(
    HANDLE hMF,     /* handle to the CF_METAFILEPICT object from clipbrd */
    HDC hDC,        /* display context */
    long *pWidth,    /* width of picture in pixels, OUT param */
    long *pHeight,   /* height of picture in pixels, OUT param */
    long *pcXPelsPerMeter,    /* horizontal resolution, OUT param */
    long *pcYPelsPerMeter,    /* vertical resolution, OUT param */
    IMG* pImg)
{
    METAFILEPICT FAR *lpMfp, Picture;
    int MapModeOld=0;
    RECT Rect;
    long xScale, yScale, Scale;
    int hRes, vRes;     /* horz and vert resolution, in pixels */
    int hSize, vSize;   /* horz and vert size, in mm */
    int fResult = FALSE;

    if (!hMF || !(lpMfp = (METAFILEPICT FAR *)GlobalLock(hMF)))
        return FALSE;
    /* copy metafile picture hdr */
    Picture = *lpMfp;
    GlobalUnlock(hMF);

    /* Do not modify given DC's attributes */
    SaveDC(hDC);

    /* set the mapping mode */
    MapModeOld = SetMapMode(hDC, Picture.mm);
    if (Picture.mm != MM_ISOTROPIC && Picture.mm != MM_ANISOTROPIC)
    {
        /* For modes other than ISOTROPIC and ANISOTROPIC the picture
         * dimensions are given in logical units.
        /* Convert logical units to pixels. */
        Rect.left = 0; Rect.right = Picture.xExt;
        Rect.top = 0;  Rect.bottom = Picture.yExt;
        if (!LPtoDP(hDC, (LPPOINT)&Rect, 2))
            goto Error;
        *pWidth = Rect.right - Rect.left + 1;
        *pHeight = Rect.bottom - Rect.top + 1;
        fResult = TRUE;
    }
    else    /* ISOTROPIC or ANISOTROPIC mode,
             * using the xExt and yExt, determine pixel width and height of
             * the image */
    {
        hRes = GetDeviceCaps(hDC, HORZRES);
        vRes = GetDeviceCaps(hDC, VERTRES);
        hSize = GetDeviceCaps(hDC, HORZSIZE);
        vSize = GetDeviceCaps(hDC, VERTSIZE);
        *pcXPelsPerMeter = hRes * 1000 / hSize;
        *pcYPelsPerMeter = vRes * 1000 / vSize;
        if (Picture.xExt == 0)  /* assume default size, aspect ratio */
        {
            *pWidth = pImg->cxWidth;
            *pHeight = pImg->cyHeight;
        }
        else if (Picture.xExt > 0)  /* use suggested size in HIMETRIC units */
        {
            // convert suggested extents(in .01 mm units) for picture to pixel units.

            // xPixelsPermm = hRes/hSize;, yPixelsPermm = vRes/vSize;
            // Use Pixels Per logical unit.
            // *pWidth = Picture.xExt*xPixelsPermm/100;
            // *pHeight = Picture.yExt*yPixelsPermm/100;
            *pWidth = ((long)Picture.xExt * hRes/hSize/100);
            *pHeight = ((long)Picture.yExt * vRes/vSize/100);
        }
        else if (Picture.xExt < 0)  /* use suggested aspect ratio, default size */
        {
            // 1 log unit = .01 mm.
            // (# of log units in imageWid pixels)/xExt;
            xScale = 100L * (long) pImg->cxWidth *
                            hSize/hRes/-Picture.xExt;
            // (# of log units in imageHgt pixels)/yExt;
            yScale = 100L * (long) pImg->cyHeight *
                            vSize/vRes/-Picture.yExt;
            // choose the minimum to accomodate the entire image
            Scale = min(xScale, yScale);
            // use scaled Pixels Per log unit.
            *pWidth = ((long)-Picture.xExt * Scale *
                            hRes/hSize / 100);
            *pHeight = ((long)-Picture.yExt * Scale *
                            vRes/vSize / 100);
        }
        fResult = TRUE;
    }

Error:
    if (MapModeOld)
        SetMapMode(hDC, MapModeOld);    /* select the old mapping mode */
    RestoreDC(hDC, -1);
    return fResult;
}

BOOL PlayMetafileIntoDC(
    HANDLE hMF,
    RECT *pRect,
    HDC hDC)
{
    HBRUSH      hbrBackground;
    METAFILEPICT FAR *lpMfp;

    if (!(lpMfp = (METAFILEPICT FAR *)GlobalLock(hMF)))
        return FALSE;

    SaveDC(hDC);

        /* Setup background color for the bitmap */
    hbrBackground = CreateSolidBrush(crRight);

    if (hbrBackground)
    {
        FillRect(hDC, pRect, hbrBackground);
        DeleteObject(hbrBackground);
    }

    SetMapMode(hDC, lpMfp->mm);
    if (lpMfp->mm == MM_ISOTROPIC || lpMfp->mm == MM_ANISOTROPIC)
        SetViewportExtEx(hDC, pRect->right-pRect->left, pRect->bottom-pRect->top,
            NULL);
    PlayMetaFile(hDC, lpMfp->hMF);
    GlobalUnlock(hMF);
    RestoreDC(hDC, -1);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgdlgs.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "docking.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "colorsrc.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "cmpmsg.h"
#include "imgdlgs.h"
#include "ferr.h"

#include <colordlg.h>
#include <direct.h>

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

CSize NEAR g_defaultTileGridSize(16, 15);
BOOL  NEAR g_bDefaultTileGrid = FALSE;


BEGIN_MESSAGE_MAP(C3dDialog, CDialog)
    ON_COMMAND(IDOK, OnRobustOK)
    ON_WM_CTLCOLOR()
END_MESSAGE_MAP()

C3dDialog::C3dDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd)
          : CDialog(lpszTemplateName, pParentWnd)
    {
    }

C3dDialog::C3dDialog(UINT nTemplateID, CWnd* pParentWnd)
          : CDialog(nTemplateID, pParentWnd)
    {
    }


BOOL C3dDialog::OnInitDialog()
    {
    // automatically center the dialog relative to it's parent
    CenterWindow(CmpCenterParent());

    return CDialog::OnInitDialog();
    }

void C3dDialog::OnRobustOK()
    {
    OnOK(); // ok to call "real" OnOK
    }

HBRUSH C3dDialog::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
    {
    HBRUSH hbrush = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);

    return hbrush;
    }

BEGIN_MESSAGE_MAP(CImgGridDlg, C3dDialog)
    ON_BN_CLICKED(IDC_PIXELGRID, OnClickPixelGrid)
    ON_BN_CLICKED(IDC_TILEGRID, OnClickTileGrid)
END_MESSAGE_MAP()


CImgGridDlg::CImgGridDlg() : C3dDialog(IDD_IMGGRIDOPT)
    {
    m_bPixelGrid = theApp.m_bShowGrid;
    m_bTileGrid  = g_bDefaultTileGrid;
    m_nWidth     = g_defaultTileGridSize.cx;
    m_nHeight    = g_defaultTileGridSize.cy;
    }


BOOL CImgGridDlg::OnInitDialog()
    {
    C3dDialog::OnInitDialog();

    CheckDlgButton(IDC_PIXELGRID, m_bPixelGrid);
    CheckDlgButton(IDC_TILEGRID, m_bTileGrid);
    SetDlgItemInt(IDC_WIDTH, m_nWidth, FALSE);
    SetDlgItemInt(IDC_HEIGHT, m_nHeight, FALSE);

    GetDlgItem(IDC_TILEGRID)->EnableWindow(m_bPixelGrid);
    GetDlgItem(IDC_WIDTH)->EnableWindow(m_bPixelGrid && m_bTileGrid);
    GetDlgItem(IDC_HEIGHT)->EnableWindow(m_bPixelGrid && m_bTileGrid);

    return TRUE;
    }


void CImgGridDlg::OnClickPixelGrid()
    {
    m_bPixelGrid = !m_bPixelGrid;
    CheckDlgButton(IDC_PIXELGRID, m_bPixelGrid);

    GetDlgItem(IDC_TILEGRID)->EnableWindow(m_bPixelGrid);
    GetDlgItem(IDC_WIDTH)->EnableWindow(m_bPixelGrid);
    GetDlgItem(IDC_HEIGHT)->EnableWindow(m_bPixelGrid);
    }


void CImgGridDlg::OnClickTileGrid()
    {
    m_bTileGrid = !m_bTileGrid;
    CheckDlgButton(IDC_TILEGRID, m_bTileGrid);

    GetDlgItem(IDC_WIDTH)->EnableWindow(m_bTileGrid);
    GetDlgItem(IDC_HEIGHT)->EnableWindow(m_bTileGrid);
    }

void CImgGridDlg::OnOK()
    {
    m_bPixelGrid = IsDlgButtonChecked(IDC_PIXELGRID);
    m_bTileGrid = IsDlgButtonChecked(IDC_TILEGRID);

    if (m_bTileGrid)
        {
        BOOL bTranslated;

        if (GetDlgItem(IDC_WIDTH)->GetWindowTextLength() == 0)
            {
            m_nWidth = 1;
            }
        else
            {
            m_nWidth = GetDlgItemInt(IDC_WIDTH, &bTranslated, FALSE);
            if (!bTranslated || m_nWidth < GRIDMIN || m_nWidth > GRIDMAX)
                {
                CmpMessageBoxPrintf(IDS_ERROR_GRIDRANGE, AFX_IDS_APP_TITLE,
                    MB_OK | MB_ICONEXCLAMATION, GRIDMIN, GRIDMAX);      // LOCALIZATION
                GetDlgItem(IDC_WIDTH)->SetFocus();
                return;
                }
            }

        if (GetDlgItem(IDC_HEIGHT)->GetWindowTextLength() == 0)
            {
            m_nHeight = 1;
            }
        else
            {
            m_nHeight = GetDlgItemInt(IDC_HEIGHT, &bTranslated, FALSE);
            if (!bTranslated || m_nHeight < GRIDMIN || m_nHeight > GRIDMAX)
                {
                CmpMessageBoxPrintf(IDS_ERROR_GRIDRANGE, AFX_IDS_APP_TITLE,
                    MB_OK | MB_ICONEXCLAMATION, GRIDMIN, GRIDMAX);      // LOCALIZATION
                GetDlgItem(IDC_HEIGHT)->SetFocus();
                return;
                }
            }

        g_defaultTileGridSize.cx = m_nWidth;
        g_defaultTileGridSize.cy = m_nHeight;
        }

    g_bDefaultTileGrid = m_bTileGrid;

    C3dDialog::OnOK();
    }


/***************************************************************************/
// CColorTable dialog

CColorTable::CColorTable( CWnd* pParent /*=NULL*/ )
            : CDialog( CColorTable::IDD, pParent )
    {
    m_bLeft  = TRUE;
    m_iColor = 0;
    }

/***************************************************************************/

void CColorTable::DoDataExchange( CDataExchange* pDX )
    {
        CDialog::DoDataExchange( pDX );
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CColorTable, CDialog)
    //{{AFX_MSG_MAP(CColorTable)
    ON_WM_DRAWITEM()
    ON_WM_MEASUREITEM()
    ON_LBN_DBLCLK(IDC_COLORLIST, OnDblclkColorlist)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/***************************************************************************/
// CColorTable message handlers

void CColorTable::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct )
    {
    if ((int) lpDrawItemStruct->itemID >= 0)
        {
        CDC       dcCombo;
        CBrush    brColor;
        CPalette* pPalOld = NULL;
        CRect     rect    = lpDrawItemStruct->rcItem;

        dcCombo.Attach( lpDrawItemStruct->hDC );

        if (theApp.m_pPalette)
            {
            pPalOld = dcCombo.SelectPalette( theApp.m_pPalette, FALSE );
            dcCombo.RealizePalette();
            }

        brColor.CreateSolidBrush( (COLORREF)lpDrawItemStruct->itemData );

        if ((lpDrawItemStruct->itemState & ODS_SELECTED) == ODS_SELECTED)
            {
            dcCombo.FillRect( &(lpDrawItemStruct->rcItem), &brColor );
            rect.InflateRect( -theApp.m_cxFrame, -theApp.m_cyFrame );
            }

        dcCombo.FillRect( &(lpDrawItemStruct->rcItem), &brColor );

        brColor.DeleteObject();

        if ((lpDrawItemStruct->itemState & ODS_FOCUS) == ODS_FOCUS)
            dcCombo.DrawFocusRect( &(lpDrawItemStruct->rcItem) );

        if (pPalOld != NULL)
            dcCombo.SelectPalette( pPalOld, FALSE );
        }

    CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
    }

/***************************************************************************/

BOOL CColorTable::OnInitDialog()
    {
    CDialog::OnInitDialog();

    int iColorCnt   = g_pColors->GetColorCount();
    CListBox* pList = (CListBox*)GetDlgItem( IDC_COLORLIST );

    for (int iLoop = 0; iLoop < iColorCnt; iLoop++)
        {
        pList->AddString( TEXT("") );
        pList->SetItemData( iLoop, g_pColors->GetColor( iLoop ) );
        }


    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CColorTable::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
    {
    lpMeasureItemStruct->itemHeight = theApp.m_cyCaption;

    CDialog::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
    }

/***************************************************************************/

void CColorTable::OnDblclkColorlist()
    {


    }

/***************************************************************************/

void CColorTable::OnOK()
    {
//  m_iColor = ;

        CDialog::OnOK();
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgdlgs.h ===
#ifndef __IMGDLGS_H__
#define __IMGDLGS_H__

#define GRIDMIN     1           // Minimum grid coordinate value
#define GRIDMAX     1024        // Maximum grid coordinate value

// All App Studio dialog boxes should derive from this class...
//
class C3dDialog : public CDialog
    {
    public:

    C3dDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
    C3dDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);

    virtual BOOL OnInitDialog();
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    afx_msg void OnRobustOK();

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
// CColorTable dialog

class CColorTable : public CDialog
    {
    // Construction
    public:

    CColorTable(CWnd* pParent = NULL);    // standard constructor

	enum { IDD = IDD_COLORTABLE };

    void SetLeftFlag( BOOL bLeft) { m_bLeft = bLeft; }
    void SetColorIndex( int iColor ) { m_iColor = iColor; }
    int  GetColorIndex() { return m_iColor; }

    // Implementation

    protected:

    BOOL m_bLeft;
    int  m_iColor;

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(CColorTable)
    afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual BOOL OnInitDialog();
    afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    afx_msg void OnDblclkColorlist();
    virtual void OnOK();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/

class CImgGridDlg : public C3dDialog
    {
    public:

    CImgGridDlg();

    BOOL OnInitDialog();
    void OnOK();
    void OnClickPixelGrid();
    void OnClickTileGrid();

    BOOL m_bPixelGrid;
    BOOL m_bTileGrid;
    int m_nWidth;
    int m_nHeight;

    DECLARE_MESSAGE_MAP()
    };

extern CSize NEAR g_defaultTileGridSize;
extern BOOL  NEAR g_bDefaultTileGrid;

#endif // __IMGDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgcolor.h ===
#ifndef __IMGCOLOR_H__
#define __IMGCOLOR_H__

/******************************************************************************/

class CImgWnd;

#ifdef CUSTOMFLOAT
class CDocking;
#endif

/******************************************************************************/

class CImgColorsWnd : public CControlBar
    {
    public:

   
    CImgColorsWnd();

    enum HitZone
        {
        none       = -2,
        curColor   = -1,
        firstColor =  0
        };

    int         m_nDisplayColorsInitial;
    int         m_nDisplayColors;
    int         m_nOffsetY;
    int         m_nCols;
    int         m_nRows;
#ifdef CUSTOMFLOAT
    CDocking*   m_pDocking;
#endif
    CRect       m_rectColors;

    BOOL        Create( const TCHAR* pWindowName, DWORD dwStyle, CWnd* pParentWnd );

    void        InvalidateCurColors();

    WORD        GetHelpOffset();

    HitZone     HitTest(const CPoint& point);
    BOOL        GetHitRect(HitZone hitZone, CRect& rect);

    void        PaintCurColorBox(CDC* pDC, BOOL bRight);
    void        PaintCurColors(CDC* pDC, const CRect* pPaintRect);
    void        PaintColors(CDC* pDC, const CRect* pPaintRect);

    void        CancelDrag();

    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
    virtual void  OnUpdateCmdUI( CFrameWnd* pTarget, BOOL bDisableIfNoHndler );

#ifdef _DEBUG
    virtual void AssertValid() const
    {
	    CWnd::AssertValid();
    }
#endif //_DEBUG

    //{{AFX_MSG(CImgColorsWnd)
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnPaint();
        afx_msg void OnClose();
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    };

/******************************************************************************/

#ifdef CUSTOMFLOAT

class CFloatImgColorsWnd : public CMiniFrmWnd
    {
    DECLARE_DYNAMIC(CFloatImgColorsWnd)

    public:

    virtual ~CFloatImgColorsWnd(void);
    virtual BOOL Create(const TCHAR* pWindowName, DWORD dwStyle,
                        const RECT& rect, CWnd* pParentWnd);
    virtual WORD GetHelpOffset() { return ID_WND_GRAPHIC; }
    afx_msg void OnClose();

    DECLARE_MESSAGE_MAP()

    };
#endif

extern void InvalColorCache();

extern CImgColorsWnd* NEAR g_pImgColorsWnd;

/***************************************************************************/

#endif // __IMGCOLOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgfile.h ===
#ifndef __IMGFILE_H__
#define __IMGFILE_H__

// This is a little helper class for writing things to temporary files
// and giving them the correct name after the save suceeds...
//
class CFileSaver
    {
    public:

     CFileSaver(const TCHAR* szFileName); // setup and create temp names
    ~CFileSaver();                       // make sure temp files are gone

    BOOL CanSave() const;               // checks for R/O
    const TCHAR* GetSafeName() const     // return name of file to create
                                    { return m_strTempName; }
    const TCHAR* GetRealName() const     // return name of final file
                                    { return m_strName; }
    BOOL Finish();                      // rename new file as original

    private:

    CString m_strName;
    CString m_strBackupName;
    CString m_strTempName;

    static const TCHAR BASED_CODE c_szAps [];
    };

struct ICONFILEHEADER
    {
    WORD icoReserved;
    WORD icoResourceType;
    WORD icoResourceCount;
    };


struct ICONDIRENTRY
    {
    BYTE nWidth;
    BYTE nHeight;
    BYTE nColorCount;
    BYTE bReserved;
    WORD wReserved1;
    WORD wReserved2;
    DWORD icoDIBSize;
    DWORD icoDIBOffset;
    };

struct CURSORFILEHEADER
    {
    WORD curReserved;
    WORD curResourceType;
    WORD curResourceCount;
    };


struct CURSORDIRENTRY
    {
    BYTE nWidth;
    BYTE nHeight;
    WORD wReserved;
    WORD curXHotspot;
    WORD curYHotspot;
    DWORD curDIBSize;
    DWORD curDIBOffset;
    };



extern int MkPath(TCHAR *szPath);
extern void MkFullPath(CString& strFullPath, const CString& strRelPath,
    BOOL bPathOnly = FALSE);
extern BOOL OpenSubFile(CFile& file, const CFileSaver& saver, UINT nOpenFlags,
    CFileException* pError = NULL);



/////////////////////////////////////////////////////////////////////////

#endif // __IMGFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgsuprt.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "t_fhsel.h"
#include "toolbox.h"
#include "imgbrush.h"
#include "imgdlgs.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif // _DEBUG

#include "memtrace.h"

BOOL  g_bUseTrans = FALSE;
BOOL  g_bCustomBrush = FALSE;
BOOL  fDraggingBrush = FALSE;
IMG*  pImgCur = NULL;

#define NUM_DEF_COLORS 28
extern COLORREF  colorColorsDef[NUM_DEF_COLORS];

COLORREF  crLeft  = 0;
COLORREF  crRight = RGB( 0xff, 0xff, 0xff );
COLORREF  crTrans = TRANS_COLOR_NONE; // transparent color
int       theLeft;
int       theRight;
int       theTrans;
int       wCombineMode;

HDC       hRubberDC;
HBITMAP   hRubberBM;
int       cxRubberWidth;
int       cyRubberHeight;
IMG*      pRubberImg;

BOOL     EnsureUndoSize(IMG* pImg);

static int   cxUndoWidth, cyUndoHeight;
static BYTE  cUndoPlanes, cUndoBitCount;

HBITMAP   g_hUndoImgBitmap = NULL;
HPALETTE  g_hUndoPalette   = NULL;

COLORREF  std2Colors [] =
    {
    RGB(000, 000, 000), //  0 - black
    RGB(255, 255, 255)  //  1 - white
    };

COLORREF  std16Colors [] =
    {
    RGB(  0,   0,   0), // Black
    RGB(128,   0,   0), // Dark Red
    RGB(  0, 128,   0), // Dark Green
    RGB(128, 128,   0), // Pea Green
    RGB(  0,   0, 128), // Dark Blue
    RGB(128,   0, 128), // Lavender
    RGB(  0, 128, 128), // Slate
    RGB(192, 192, 192), // Light Gray
    RGB(128, 128, 128), // Dark Gray
    RGB(255,   0,   0), // Bright Red
    RGB(  0, 255,   0), // Bright Green
    RGB(255, 255,   0), // Yellow
    RGB(  0,   0, 255), // Bright Blue
    RGB(255,   0, 255), // Magenta
    RGB(  0, 255, 255), // Cyan
    RGB(255, 255, 255)  //  1 - white
    };

/***************************************************************************/

IMG* CreateImg(int cxWidth, int cyHeight, int cPlanes, int cBitCount, int cXPelsPerMeter, int cYPelsPerMeter, BOOL bPalette )
{
        IMG* pimg = NULL;
        CTempBitmap bmNew;
        HBITMAP hbmOld = NULL;

        CClientDC dcScreen(NULL);


        if (! cPlanes )
        {
                cPlanes = dcScreen.GetDeviceCaps( PLANES );
        }
        if (! cBitCount)
        {
                cBitCount = dcScreen.GetDeviceCaps( BITSPIXEL );
        }

        CDC cDC;
        cDC.CreateCompatibleDC( &dcScreen );
        if (!cDC.m_hDC)
        {
                return NULL;
        }

        if (cPlanes * cBitCount > 1)
        {
                cDC.SetStretchBltMode(HALFTONE);

        }

        // Set these to 0 to not create a bitmap
        if (cxWidth && cyHeight)
        {
                BOOL bMono = (cPlanes == 1 && cBitCount == 1);
                COLORREF* pcrColors = NULL;
                int nColors = 0;

                cBitCount *= cPlanes;
                if (cBitCount <= 1)
                {
                        cBitCount = 1;
                        pcrColors = std2Colors;
                        nColors = 2;
                }
                else if (cBitCount <= 4)
                {
                        cBitCount = 4;
                        pcrColors = std16Colors;
                        nColors = 16;
                }
                else if (cBitCount <= 8)
                {
                        cBitCount = 8;
                        pcrColors = colorColorsDef;
                        nColors = NUM_DEF_COLORS;
                }
                else
                {
                        // I don't want to deal with 15 or 16 bit images
                        cBitCount = 24;
                }

                HBITMAP hbmNew = NULL;

                if (cBitCount == 4)
                {
                        // Just create a DDB if in 16 colors
                        hbmNew = CreateCompatibleBitmap( dcScreen.m_hDC, cxWidth, cyHeight);
                }
                else
                {
                        struct BMHDR
                        {
                                BITMAPINFOHEADER bmInfo;
                                RGBQUAD          rgb[256];
                        } DIBHdr =
                        {
                                sizeof(BITMAPINFOHEADER),
                                cxWidth,
                                cyHeight,
                                1,
                                (WORD)cBitCount,
                                BI_RGB,
                                0,
                                0,
                                nColors,
                                nColors,
                        } ;

                        if (cBitCount <= 8)
                        {
                                RGBQUAD* prgb;
                                COLORREF* pcr;
                                int n;

                                pcr = pcrColors;
                                prgb = DIBHdr.rgb;

                                for (n=nColors; n>0; --n, ++pcr, ++prgb)
                                {
                                        prgb->rgbRed   = GetRValue(*pcr);
                                        prgb->rgbGreen = GetGValue(*pcr);
                                        prgb->rgbBlue  = GetBValue(*pcr);
                                        prgb->rgbReserved = 0;
                                }
                        }

                        LPVOID lpNewBits;
                        hbmNew = CreateDIBSection(cDC.m_hDC, (LPBITMAPINFO)&DIBHdr,
                                DIB_RGB_COLORS, &lpNewBits, NULL, 0);
                }

                if (!hbmNew)
                {
                        return NULL;
                }
                bmNew.Attach(hbmNew);
        }

        TRY
        {
                pimg = new IMG;
        }
        CATCH (CMemoryException, e)
        {
                TRACE( TEXT("CreateImg: Can't alloc an IMG\n") );
                return NULL;
        }
        END_CATCH

        pimg->cxWidth        = cxWidth;
        pimg->cyHeight       = cyHeight;
        pimg->cPlanes        = cPlanes;
        pimg->cBitCount      = cBitCount;
        pimg->cXPelsPerMeter = cXPelsPerMeter;
        pimg->cYPelsPerMeter = cYPelsPerMeter;
        pimg->hDC            = (HDC)cDC.Detach();
        pimg->hBitmap        = (HBITMAP)bmNew.Detach();
        pimg->hBitmapOld     = NULL;
        pimg->m_pFirstImgWnd = NULL;
        pimg->bDirty         = FALSE;
        pimg->m_hPalOld      = NULL;
        pimg->m_pPalette     = NULL;

        pimg->m_bTileGrid = g_bDefaultTileGrid;
        pimg->m_cxTile    = g_defaultTileGridSize.cx;
        pimg->m_cyTile    = g_defaultTileGridSize.cy;


        BYTE cRed   = GetRValue( crRight );
        BYTE cGreen = GetGValue( crRight );
        BYTE cBlue  = GetBValue( crRight );

        if (theApp.m_bPaletted)
        {
                crRight = PALETTERGB( cRed, cGreen, cBlue );
        }
        else
        {
                crRight =        RGB( cRed, cGreen, cBlue );
        }

        if (pimg->hBitmap)
        {
                pimg->hBitmapOld = (HBITMAP)SelectObject(pimg->hDC, pimg->hBitmap);
                ClearImg( pimg );
        }

        return(pimg);
}

/***************************************************************************/

BOOL ClearImg(IMG* pimg)
    {
#if 1
    HBRUSH   hNewBrush;
    HBRUSH   hOldBrush = NULL;
    HPALETTE hpalOld   = NULL;

    pimg->m_nLastChanged = -1;

    if ((hNewBrush = ::CreateSolidBrush( crRight )) == NULL)
        return FALSE;

    if (pimg->m_pPalette)
        {
        hpalOld = SelectPalette( pimg->hDC, (HPALETTE)pimg->m_pPalette->m_hObject, FALSE );
        RealizePalette( pimg->hDC );
        }

    hOldBrush = (HBRUSH)SelectObject( pimg->hDC, hNewBrush );

    PatBlt( pimg->hDC, 0, 0, pimg->cxWidth, pimg->cyHeight, PATCOPY );

    if (hOldBrush)
        SelectObject(pimg->hDC, hOldBrush);

    DeleteObject( hNewBrush );

    if (hpalOld)
        SelectPalette( pimg->hDC, hpalOld, FALSE );

    return TRUE;
#else
        BOOL    bResult = FALSE;
        HBRUSH  hNewBrush = ::CreateSolidBrush( crRight );

        if ( hNewBrush )
                {
                HBRUSH  hOldBrush = (HBRUSH)SelectObject( pimg->hDC, hNewBrush );
                if ( hOldBrush )
                        {
                        HPALETTE hpalOld = SelectPalette( pimg->hDC,
                                                                                          (HPALETTE)pimg->m_pPalette->m_hObject,
                                                                                          FALSE );
                        if ( hpalOld )
                                {
                                RealizePalette( pimg->hDC );

                            PatBlt( pimg->hDC, 0, 0, pimg->cxWidth, pimg->cyHeight, PATCOPY );
                                pimg->m_nLastChanged = -1;
                                bResult = TRUE;

                        SelectPalette( pimg->hDC, hpalOld, FALSE );
                                }
                SelectObject(pimg->hDC, hOldBrush);
                        }
                DeleteObject( hNewBrush );
                }
        return bResult;
#endif
    }

/***************************************************************************/

void FreeImg(IMG* pimg)
    {
    if (! pimg)
        return;

    if (pimg == theImgBrush.m_pImg)
        theImgBrush.m_pImg = NULL;

    if (pimg->hDC)
        {
        if (pimg->hBitmapOld)
            SelectObject( pimg->hDC, pimg->hBitmapOld );

        if (pimg->m_hPalOld)
            SelectPalette( pimg->hDC, pimg->m_hPalOld, FALSE ); // Background ??

        DeleteDC(pimg->hDC);
        }

    if (pimg->hBitmap)
        DeleteObject(pimg->hBitmap);

    if (theApp.m_pPalette == pimg->m_pPalette)
        theApp.m_pPalette = NULL;

    if (pimg->m_pPalette)
        delete pimg->m_pPalette;

    if (pimg->m_pBitmapObj->m_pImg == pimg)
        pimg->m_pBitmapObj->m_pImg = NULL;

    if (pImgCur == pimg)
        pImgCur = NULL;

    if (pRubberImg == pimg)
        pRubberImg = NULL;

    delete pimg;
    }

/***************************************************************************/

void SelectImg(IMG* pimg)
    {
    if (pimg == pImgCur)
        return;

    if (theImgBrush.m_pImg)
        HideBrush();

    pImgCur = pimg;

    SetupRubber(pimg);
    }

/***************************************************************************/

void DirtyImg( IMG* pimg )
    {
    CPBDoc* pDoc = (CPBDoc*)((CFrameWnd*)AfxGetMainWnd())->GetActiveDocument();

    if (pDoc)
        {
        pDoc->SetModifiedFlag( TRUE );

        if (theApp.m_bEmbedded)
            pDoc->NotifyChanged();
        }

    pimg->bDirty = TRUE;
    pimg->m_pBitmapObj->SetDirty( TRUE );
    }

/***************************************************************************/

void CleanupImages()
    {
    FreeImg( pImgCur );

    CleanupImgUndo();
    CleanupImgRubber();
    }

/***************************************************************************/

void InvalImgRect(IMG* pimg, CRect* prc)
    {
    CImgWnd* pImgWnd;
    CImgWnd* pNextImgWnd;

    CRect rc;

    rc.SetRect(0, 0, pimg->cxWidth, pimg->cyHeight);

    if (prc)
        rc &= *prc;

    for (pImgWnd = pimg->m_pFirstImgWnd; pImgWnd;
                                         pImgWnd = pNextImgWnd)
        {
        CRect rcWnd;

        pNextImgWnd = pImgWnd->m_pNextImgWnd;

        if (prc)
            {
            rcWnd = rc;
            pImgWnd->ImageToClient(rcWnd);

            if (pImgWnd->IsGridVisible())
                {
                rcWnd.right  += 1;
                rcWnd.bottom += 1;
                }
            }

        pImgWnd->InvalidateRect(prc == NULL ? NULL : &rcWnd, FALSE);
        }
    }

/***************************************************************************/

void CommitImgRect(IMG* pimg, CRect* prc)
    {
    ASSERT(hRubberDC);

    if (hRubberDC == NULL)
        return;

    CRect rc;

    if (prc == NULL)
        {
        SetRect( &rc, 0, 0, pimg->cxWidth, pimg->cyHeight );
        prc = &rc;
        }

    HPALETTE hpalOld = NULL;

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        {
        hpalOld = SelectPalette( hRubberDC, (HPALETTE)theApp.m_pPalette->m_hObject, FALSE ); // Background ??
        RealizePalette( hRubberDC );
        }

    BitBlt(hRubberDC, prc->left, prc->top,
                      prc->Width(), prc->Height(),
           pimg->hDC, prc->left, prc->top, SRCCOPY);

    if (hpalOld)
        SelectPalette( hRubberDC, hpalOld, FALSE ); // Background ??
    }

void SelInScreenFirst(CPalette* pPal)
{
        // HACK: Select into screen DC first for GDI bug
        CWindowDC hdcScreen(NULL);
        hdcScreen.SelectPalette(pPal, TRUE);
        hdcScreen.RealizePalette();
}

BOOL CreateSafePalette(CPalette* pPal, LPLOGPALETTE lpLogPal)
{
        if (!pPal->CreatePalette(lpLogPal))
        {
                return(FALSE);
        }

        SelInScreenFirst(pPal);
        return(TRUE);
}


/***************************************************************************/

BOOL ReplaceImgPalette( IMG* pImg, LPLOGPALETTE lpLogPal )
    {
    if (pImg->m_hPalOld)
        {
        ::SelectPalette( pImg->hDC, pImg->m_hPalOld, FALSE );
        pImg->m_hPalOld = NULL;
        }

    if (pImg->m_pPalette)
        delete pImg->m_pPalette;

    pImg->m_pPalette = new CPalette;

    if (pImg->m_pPalette
    &&  CreateSafePalette(pImg->m_pPalette, lpLogPal ))
        {
        pImg->m_hPalOld = ::SelectPalette( pImg->hDC,
                                 (HPALETTE)pImg->m_pPalette->GetSafeHandle(), FALSE );
        ::RealizePalette( pImg->hDC );
        InvalImgRect( pImg, NULL );
        }
    else
        {
        if (pImg->m_pPalette)
            delete pImg->m_pPalette;

        pImg->m_pPalette = NULL;
        }

    return (pImg->m_pPalette != NULL);
    }

/***************************************************************************/

void CleanupImgRubber()
    {
    if (hRubberDC)
        {
        DeleteDC(hRubberDC);
        hRubberDC = NULL;
        }

    if (hRubberBM)
        {
        DeleteObject(hRubberBM);
        hRubberBM = NULL;
        }

    pRubberImg = NULL;

    cxRubberWidth  = 0;
    cyRubberHeight = 0;
    }

/***************************************************************************/

void IdleImage()
    {
    if (g_pMouseImgWnd)
        {
        CRect rcImage(0, 0, g_pMouseImgWnd->GetImg()->cxWidth,
                            g_pMouseImgWnd->GetImg()->cyHeight);

        g_pMouseImgWnd->ImageToClient( rcImage );

        CRect rcClient;

        g_pMouseImgWnd->GetClientRect( &rcClient );

        rcClient &= rcImage;

        CPoint pt;
        GetCursorPos( &pt );

        CPoint ptClient = pt;

        g_pMouseImgWnd->ScreenToClient( &ptClient );

        if (CWnd::WindowFromPoint( pt ) != g_pMouseImgWnd
        ||  ! rcClient.PtInRect( ptClient ))
            {
            extern MTI  mti;

            CImgTool::GetCurrent()->OnLeave( g_pMouseImgWnd, &mti );

            g_pMouseImgWnd = NULL;

            if (! CImgTool::IsDragging() &&
                ::IsWindow(((CPBFrame*)theApp.m_pMainWnd)->m_statBar.m_hWnd) )
                ((CPBFrame*)theApp.m_pMainWnd)->m_statBar.ClearPosition();
            }
        }

    if (fDraggingBrush)
        {
        CPoint   pt;
        CRect    rcClient;
        CPoint   ptClient;
        CImgWnd* pImgWnd;

        GetCursorPos(&pt);

        pImgWnd = g_pDragBrushWnd;

        if (pImgWnd == NULL)
            return;

        CRect rcImage(0, 0, pImgWnd->GetImg()->cxWidth,
                            pImgWnd->GetImg()->cyHeight);

        pImgWnd->ImageToClient( rcImage   );
        pImgWnd->GetClientRect( &rcClient );

        rcClient &= rcImage;

        ptClient = pt;
        pImgWnd->ScreenToClient( &ptClient );

        if ( CWnd::WindowFromPoint(pt) != pImgWnd
        ||  ! rcClient.PtInRect(ptClient))
            {
            if (fDraggingBrush && theImgBrush.m_pImg == NULL)
                HideBrush();

            pImgWnd->UpdPos( CPoint(-1, -1) );
            }
        else
            if (GetCapture() == NULL)
                {
                CPoint imagePt = ptClient;

                pImgWnd->ClientToImage( imagePt );

                if (! g_bBrushVisible && fDraggingBrush
                &&    CImgTool::GetCurrent()->UsesBrush())
                    {
                    pImgWnd->ShowBrush( imagePt );
                    }
                }
        }
    }

/***************************************************************************/

void HideBrush()
    {
    if (! g_bBrushVisible)
        return;

    g_bBrushVisible = FALSE;

    CImgWnd* pImgWnd = g_pDragBrushWnd;

    ASSERT(pImgWnd);

    if (pImgWnd == NULL)
        return;

    IMG* pimg = pImgWnd->GetImg();

    if (pimg == NULL)
        return;

    HPALETTE hpalOld = pImgWnd->SetImgPalette( hRubberDC, FALSE ); // Background ??

    BitBlt( pimg->hDC, rcDragBrush.left,
                       rcDragBrush.top,
                       rcDragBrush.Width(),
                       rcDragBrush.Height(),
            hRubberDC, rcDragBrush.left,
                       rcDragBrush.top, SRCCOPY );

    if (hpalOld)
        SelectPalette( hRubberDC, hpalOld, FALSE ); // Background ??

    InvalImgRect( pimg, &rcDragBrush );
    }

/***************************************************************************/

void FixRect(RECT * prc)
    {
    int t;

    if (prc->left > prc->right)
        {
        t = prc->left;
        prc->left = prc->right;
        prc->right = t;
        }

    if (prc->top > prc->bottom)
        {
        t = prc->top;
        prc->top = prc->bottom;
        prc->bottom = t;
        }
    }

/***************************************************************************/

BOOL SetupRubber(IMG* pimg)
    {
    if (cxRubberWidth  < pimg->cxWidth
    ||  cyRubberHeight < pimg->cyHeight)
        {
        HBITMAP hOldBitmap, hNewBitmap;

        HideBrush();

        if (hRubberDC == NULL
        && (hRubberDC = CreateCompatibleDC( pimg->hDC )) == NULL)
            return FALSE;

        hNewBitmap = CreateCompatibleBitmap( pimg->hDC, pimg->cxWidth, pimg->cyHeight );

        if (hNewBitmap == NULL)
            {
            return FALSE;
            }

        hRubberBM = hNewBitmap;

        hOldBitmap = (HBITMAP) SelectObject( hRubberDC, hRubberBM );

        if (hOldBitmap)
            {
            DeleteObject( hOldBitmap );
            }

        cxRubberWidth  = pimg->cxWidth;
        cyRubberHeight = pimg->cyHeight;
        }

    if (pRubberImg != pimg)
        {
        HideBrush();

        HPALETTE hpalOld = NULL;

        if (theApp.m_pPalette
        &&  theApp.m_pPalette->m_hObject)
            {
            hpalOld = SelectPalette( hRubberDC, (HPALETTE)theApp.m_pPalette->m_hObject, FALSE );
            RealizePalette( hRubberDC );
            }

        BitBlt( hRubberDC, 0, 0, pimg->cxWidth,
                                 pimg->cyHeight, pimg->hDC, 0, 0, SRCCOPY );

        if (hpalOld)
            SelectPalette( hRubberDC, hpalOld, FALSE ); // Background ??
        }

    pRubberImg = pimg;

    return TRUE;
    }

/***************************************************************************/

CPalette* CreatePalette( const COLORREF* colors, int nColors )
    {
    CPalette* pPal = new CPalette;

    if (pPal)
        {
        LPLOGPALETTE pLogPal = (LPLOGPALETTE) LocalAlloc(
            LMEM_FIXED, sizeof (LOGPALETTE) + sizeof (PALETTEENTRY) * nColors);

        if (pLogPal)
            {
            pLogPal->palVersion    = 0x300;
            pLogPal->palNumEntries = (WORD)nColors;

            for (int i = 0; i < nColors; i++)
                {
                pLogPal->palPalEntry[i] = *(PALETTEENTRY*)colors++;
                pLogPal->palPalEntry[i].peFlags = 0;
                }

            if (! CreateSafePalette(pPal, pLogPal ))
                {
                theApp.SetGdiEmergency();
                delete pPal;
                pPal = NULL;
                }

            LocalFree(pLogPal);
            }
        else
            {
            theApp.SetMemoryEmergency();
            delete pPal;
            pPal = NULL;
            }
        }
    return pPal;
    }

/***************************************************************************/

CPalette* GetStd16Palette()
    {
    return CreatePalette( std16Colors, 16 );
    }

/***************************************************************************/

CPalette* GetStd2Palette()
    {
    return CreatePalette( std2Colors, 2 );
    }

/***************************************************************************/

CPalette* GetStd256Palette()
    {
    return CreatePalette( colorColorsDef, NUM_DEF_COLORS );
    }

/***************************************************************************/

CPalette *PaletteFromDS(HDC hdc)
{
    DWORD adw[257];
    int i,n;
        CPalette        *pPal = new CPalette;

    if ( n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]) )
                {
            for (i=1; i<=n; i++)
                adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));

            adw[0] = MAKELONG(0x300, n);

                CreateSafePalette(pPal, (LPLOGPALETTE)&adw[0]);
                }
        else
                {
                // No Palette in Bitmap! Use default half-tone palette
                pPal->Attach(CreateHalftonePalette( NULL ));
                }

        return pPal;
}

/////////////////////////////////////////////////////////////////////////////
//
// Packed-DIB Handling Functions
//
// A packed-DIB is a bucket of bits usually consisting of a BITMAPINFOHEADER
// structure followed by an array of RGBQUAD structures followed by the words
// that make up the image.  An alternate form consists of a BITMAPCOREHEADER
// structure followed by an array of RGBTRIPLE structures and the image words.
// This format is used by OS/2, but is supported by Windows.  The only way
// to tell which format the DIB is using is to check the first word against
// the sizes of the header structures (pretty clever eh?).
//
// This is very similar to a DIB as stored in a file.  In fact, a DIB file is
// a BITMAPFILEHEADER structure followed by a packed DIB.
//
// These functions make dealing with packed-DIBs in memory easier.
//
#define WIDTHBYTES(bits) ((((bits) + 31) / 32) * 4)

/***************************************************************************/

void FreeDib(HGLOBAL hDib)
    {
    ASSERT( hDib );

    if (hDib)
        GlobalFree(hDib);
    }

/***************************************************************************/

HGLOBAL DibFromBitmap( HBITMAP hBitmap, DWORD dwStyle, WORD wBits,
                       CPalette* pPal, HBITMAP hMaskBitmap, DWORD& dwLen, 
                       LONG cXPelsPerMeter, LONG cYPelsPerMeter )
    {
    ASSERT(hBitmap);

    if (hBitmap == NULL)
        return NULL;

     ASSERT(hMaskBitmap == NULL || dwStyle == BI_RGB);

    HBITMAP            hbm;
    BITMAP             bm;
    BITMAPINFOHEADER   bi;
    LPBITMAPINFOHEADER lpbi;
    HDC                hDC;
    DWORD              dwSmallLen;


    HPALETTE hPal = (HPALETTE)(pPal->GetSafeHandle());

    if (theApp.m_bPaletted && ! hPal)
        hPal = (HPALETTE)::GetStockObject( DEFAULT_PALETTE );

    GetObject( hBitmap, sizeof( bm ), (LPSTR)&bm );

    if (wBits == 0)
        wBits = bm.bmPlanes * bm.bmBitsPixel;

    if (wBits <= 1)
        wBits = 1;
    else
        if (wBits <= 4)
            wBits = 4;
        else
            if (wBits <= 8)
                wBits = 8;
            else
                wBits = 24;

    bi.biSize          = sizeof( BITMAPINFOHEADER );
    bi.biWidth         = bm.bmWidth;
    bi.biHeight        = bm.bmHeight;
    bi.biPlanes        = 1;
    bi.biBitCount      = wBits;
    bi.biCompression   = dwStyle;
    bi.biSizeImage     = 0;
//  bi.biXPelsPerMeter = theApp.ScreenDeviceInfo.ixPelsPerDM * 10;
//  bi.biYPelsPerMeter = theApp.ScreenDeviceInfo.iyPelsPerDM * 10;
//    HDC hdc = GetDC(NULL);
//    bi.biXPelsPerMeter = MulDiv(::GetDeviceCaps(hdc, LOGPIXELSX),10000, 254);
//    bi.biYPelsPerMeter = MulDiv(::GetDeviceCaps(hdc, LOGPIXELSY),10000, 254);
//    ReleaseDC (NULL, hdc);
    bi.biXPelsPerMeter = cXPelsPerMeter;
    bi.biYPelsPerMeter = cYPelsPerMeter;
    bi.biClrUsed       = 0;
    bi.biClrImportant  = 0;

    dwSmallLen = dwLen = bi.biSize + PaletteSize( (LPSTR) &bi );

    lpbi = (LPBITMAPINFOHEADER) GlobalAlloc(GPTR, dwLen);

    if (lpbi == NULL)
        {
        theApp.SetMemoryEmergency();
        return NULL;
        }

    *lpbi = bi;

    hbm = CreateBitmap( 2, 2, bm.bmPlanes, bm.bmBitsPixel, NULL );
    hDC = CreateCompatibleDC( NULL );

    if (hbm == NULL || hDC == NULL)
        {
        if (hbm)
            DeleteObject( hbm );

        theApp.SetGdiEmergency();
        return NULL;
        }
    HPALETTE hPalOld = NULL;
    HANDLE   hbmOld  = SelectObject( hDC, hbm );

    if (hPal)
        {
        hPalOld = SelectPalette( hDC, hPal, FALSE );
        RealizePalette( hDC );
        }

    // Compute the byte size of the DIB...
    GetDIBits( hDC, hBitmap, 0, (WORD)bi.biHeight, NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS );

    bi = *lpbi;

    // If the driver did not fill in the biSizeImage field, make one up
    // NOTE: This size will be too big if the bitmap is compressed!
    // NOTE: This happens with the Paradise 800x600x256 driver...
    if (bi.biSizeImage == 0)
        {
        TRACE( TEXT("Display driver bug!  We have to compute DIB size...") );

        bi.biSizeImage = WIDTHBYTES( (DWORD)bi.biWidth * wBits ) * bi.biHeight;

        if (dwStyle != BI_RGB)
            bi.biSizeImage = (bi.biSizeImage * 3) / 2;
        }

    dwLen = bi.biSize + PaletteSize( (LPSTR)&bi ) + bi.biSizeImage;

    if (hMaskBitmap)
        dwLen += (LONG)WIDTHBYTES( bi.biWidth ) * bi.biHeight;

    CHAR* hpv = (CHAR*) GlobalAlloc(GPTR, dwLen);

    if (! hpv)
        {
        theApp.SetMemoryEmergency();

        GlobalFree(lpbi);

        if (hbmOld)
            DeleteObject( SelectObject( hDC, hbmOld ) );

        if (hPalOld)
            SelectPalette( hDC, hPalOld, FALSE );

        DeleteDC( hDC );

        return NULL;
        }

    memcpy( hpv, (void*)lpbi, dwSmallLen );

    GlobalFree(lpbi);

    lpbi = (LPBITMAPINFOHEADER)hpv;

    LPSTR lpBits = (LPSTR)lpbi + lpbi->biSize + PaletteSize((LPSTR)lpbi);
    DWORD biSizeImage = lpbi->biSizeImage;

    if (hMaskBitmap)
        {
        // Do the mask first so the dib ends up with the main bitmap's
        // size and palette when we're done...
        LONG cbAdjust     = ((LONG)WIDTHBYTES( bi.biWidth * wBits )) * bi.biHeight;
              lpBits     += cbAdjust;
        WORD biBitCount   = lpbi->biBitCount;
        lpbi->biBitCount  = 1;
        lpbi->biSizeImage = 0;

        if (GetDIBits( hDC, hMaskBitmap, 0, (WORD)bi.biHeight, lpBits,
                            (LPBITMAPINFO)lpbi, DIB_RGB_COLORS ) == 0)
            {
            GlobalFree(hpv);

            if (hbmOld)
                DeleteObject( SelectObject( hDC, hbmOld ) );

            if (hPalOld)
                SelectPalette( hDC, hPalOld, FALSE );

            DeleteDC(hDC);

            return NULL;
            }

        biSizeImage     += lpbi->biSizeImage;
        lpbi->biBitCount = biBitCount;
        lpBits          -= cbAdjust;
        }

    if (GetDIBits( hDC, hBitmap, 0, (WORD)bi.biHeight, lpBits,
                    (LPBITMAPINFO)lpbi, DIB_RGB_COLORS ) == 0)
        {
        GlobalFree(hpv);

        if (hbmOld)
            DeleteObject( SelectObject( hDC, hbmOld ) );

        if (hPalOld)
            SelectPalette( hDC, hPalOld, FALSE );

        DeleteDC(hDC);

        return NULL;
        }

    lpbi->biSizeImage = biSizeImage;

    if (hMaskBitmap)
        lpbi->biHeight *= 2;

    if (hbmOld)
        DeleteObject( SelectObject( hDC, hbmOld ) );

    if (hPalOld)
        SelectPalette( hDC, hPalOld, FALSE );
    DeleteDC( hDC );

    return (LPSTR)lpbi;
    }

/***************************************************************************/

UINT DIBBitsPixel(LPSTR lpbi)
{
        // Calculate the number of colors in the color table based on
        //  the number of bits per pixel for the DIB.

        if (IS_WIN30_DIB(lpbi))
        {
                return(((LPBITMAPINFOHEADER)lpbi)->biBitCount);
        }
        else
        {
                return(((LPBITMAPCOREHEADER)lpbi)->bcBitCount);
        }
}

WORD DIBNumColors(LPSTR lpbi, BOOL bJustUsed)
    {
    WORD wBitCount;

    // If this is a Windows style DIB, the number of colors in the
    //  color table can be less than the number of bits per pixel
    //  allows for (i.e. lpbi->biClrUsed can be set to some value).
    //  If this is the case, return the appropriate value.

    if (IS_WIN30_DIB( lpbi ) && bJustUsed)
        {
        DWORD dwClrUsed = ((LPBITMAPINFOHEADER)lpbi)->biClrUsed;

        if (dwClrUsed != 0)
            return (WORD)dwClrUsed;
        }


    // Calculate the number of colors in the color table based on
    //  the number of bits per pixel for the DIB.

    wBitCount = (WORD)DIBBitsPixel(lpbi);

    switch (wBitCount)
        {
        case 1:
            return 2;

        case 4:
            return 16;

        case 8:
            return 256;

        default:
            return 0;
        }
    }


/***************************************************************************/

WORD PaletteSize(LPSTR lpbi)
    {


    if (IS_WIN30_DIB(lpbi) &&
                ((LPBITMAPINFOHEADER)lpbi)->biCompression==BI_BITFIELDS)
    {
            // Images with bitfields have 3 DWORD's that specify the RGB components
            // (respectively) of each pixel.
            if (((LPBITMAPINFOHEADER)lpbi)->biSize >= sizeof(BITMAPV4HEADER))
            {
               return 0;
            }
            else
               return(3 * sizeof(DWORD));
    }

    return DIBNumColors(lpbi,TRUE) *
        (IS_WIN30_DIB(lpbi) ? sizeof(RGBQUAD) : sizeof(RGBTRIPLE));
    }


/***************************************************************************/

LPSTR FindDIBBits(LPSTR lpbi, DWORD dwOffBits)
    {
    DWORD dwAfterHdr = *(LPDWORD)lpbi + PaletteSize(lpbi);
    DWORD dwOff;
#if 0
        if (dwOffBits && dwAfterHdr != dwOffBits)
        {
                MessageBeep(0);
        }
#endif
    dwOff = max(dwOffBits, dwAfterHdr);
    return(lpbi + dwOff);
    }


/***************************************************************************/

DWORD DIBWidth(LPSTR lpDIB)
    {

    LPBITMAPINFOHEADER lpbmi = (LPBITMAPINFOHEADER)lpDIB;
    LPBITMAPCOREHEADER lpbmc = (LPBITMAPCOREHEADER)lpDIB;

    if (lpbmi->biSize >= sizeof (BITMAPINFOHEADER))
        return (DWORD) abs(lpbmi->biWidth);
    else
        return (DWORD) abs(lpbmc->bcWidth);
    }


/***************************************************************************/

DWORD DIBHeight(LPSTR lpDIB)
    {
    LPBITMAPINFOHEADER lpbmi = (LPBITMAPINFOHEADER)lpDIB;
    LPBITMAPCOREHEADER lpbmc = (LPBITMAPCOREHEADER)lpDIB;

    if (lpbmi->biSize >= sizeof (BITMAPINFOHEADER))
        return (DWORD) abs(lpbmi->biHeight);
    else
        return (DWORD) abs(lpbmc->bcHeight);
    }


/***************************************************************************/

HBITMAP DIBToBitmap( LPSTR lpDIBHdr, CPalette* pPal, HDC hdc )
    {
    ASSERT( lpDIBHdr );
    ASSERT( hdc );

    if (! lpDIBHdr || ! hdc)
        return NULL;

    LPBYTE    lpDIBBits = (LPBYTE)FindDIBBits( lpDIBHdr,0 );
    CPalette* ppalOld = NULL;
    CBitmap*  pbmOld  = NULL;
    CBitmap   bmTemp;
    CDC       dc;

    dc.Attach( hdc );

    if (bmTemp.CreateCompatibleBitmap( &dc, 2, 2 ))
        pbmOld = dc.SelectObject( &bmTemp );

    if (pPal)
        {
        ASSERT( pPal->m_hObject );

#ifdef FORCEBACKPALETTE
        ppalOld = dc.SelectPalette( pPal, TRUE );
#else
        ppalOld = dc.SelectPalette( pPal, FALSE );
#endif

        dc.RealizePalette();
        }

    HBITMAP hBitmap = CreateDIBitmap( dc.m_hDC, (LPBITMAPINFOHEADER)lpDIBHdr,
                                      CBM_INIT, lpDIBBits,
                                      (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS );
    if (ppalOld)
        dc.SelectPalette( ppalOld, FALSE );

    if (pbmOld)
        dc.SelectObject( pbmOld );

    if (bmTemp.m_hObject)
        bmTemp.DeleteObject();

    dc.Detach();

    return hBitmap;
    }

/***************************************************************************/

BOOL ShouldUseDDB(HDC hdc, LPBITMAPINFO lpDIBHdr)
{
        if (!IS_WIN30_DIB(lpDIBHdr))
        {
                // I don't want to write special code to deal with this case
                return(FALSE);
        }

        if (lpDIBHdr->bmiHeader.biPlanes*lpDIBHdr->bmiHeader.biBitCount != 4)
        {
                // No DDB for mono or 8bit or more
                return(FALSE);
        }

        UINT cBitCount = GetDeviceCaps( hdc, BITSPIXEL )
                * GetDeviceCaps( hdc, PLANES );
        if (cBitCount > 4)
        {
                return(FALSE);
        }

        RGBQUAD *lpPal = lpDIBHdr->bmiColors;

        for (int i=DIBNumColors((LPSTR)lpDIBHdr, TRUE); i>0; --i, ++lpPal)
        {
                COLORREF cr = RGB(lpPal->rgbRed, lpPal->rgbGreen, lpPal->rgbBlue);
                if (GetNearestColor(hdc, cr) != cr)
                {
                        return(FALSE);
                }
        }

        // OK, so this is a WIN30 DIB, the screen is 16 or less colors, it is
        // either an uncompressed or RLE DIB, and all the colors in the DIB can
        // be shown on the screen.  I guess we can use a DDB.
        return(TRUE);
}

/***************************************************************************/


HBITMAP DIBToDS( LPSTR lpDIB, DWORD dwOffBits, HDC hdc )
{
        ASSERT( lpDIB );
        ASSERT( hdc );

        if (! lpDIB || ! hdc)
        {
                return NULL;
        }

        LPVOID lpNewBits;
        LPBITMAPINFO lpDIBHdr = (LPBITMAPINFO)lpDIB;
        LPBYTE lpDIBBits = (LPBYTE)FindDIBBits( lpDIB, dwOffBits );

        {
                // New block just to scope dcScreen
                CClientDC dcScreen(NULL);

                if (ShouldUseDDB(dcScreen.m_hDC, lpDIBHdr))
                {
                        return(CreateDIBitmap( dcScreen.m_hDC, &lpDIBHdr->bmiHeader,
                                CBM_INIT, lpDIBBits, lpDIBHdr, DIB_RGB_COLORS ));
                }
        }

        // Compressed DIB sections are not allowed
        DWORD dwCompression = lpDIBHdr->bmiHeader.biCompression;
        if (IS_WIN30_DIB(lpDIB))
        {
                lpDIBHdr->bmiHeader.biCompression = BI_RGB;
        }
        HBITMAP hBitmap = CreateDIBSection( hdc, lpDIBHdr, DIB_RGB_COLORS,
                &lpNewBits, NULL, 0);

        if (IS_WIN30_DIB(lpDIB))
        {
                lpDIBHdr->bmiHeader.biCompression = dwCompression;
        }

        if (hBitmap)
        {
                HBITMAP hbmOld = (HBITMAP)SelectObject(hdc, hBitmap);
                if (hbmOld)
                {
                        UINT uWid = DIBWidth(lpDIB);
                        UINT uHgt = DIBHeight(lpDIB);

                        // Fill with white in case the bitmap has any jumps in it.
                        PatBlt(hdc, 0, 0, uWid, uHgt, WHITENESS);

//                        StretchDIBits(hdc, 0, 0, uWid, uHgt, 0, 0, uWid, uHgt, lpDIBBits,
//                                (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS, SRCCOPY);
                        SetDIBitsToDevice (hdc,0,0,uWid, uHgt,0,0,0,abs(uHgt),lpDIBBits,
                                           (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS);
                        SelectObject(hdc, hbmOld);

                        return(hBitmap);
                }

                DeleteObject(hBitmap);
        }

        return(NULL);
}

//------------------------------------------------------------------------------
// SetNewPalette - Used solely by GetRainbowPalette below for initialization.
//------------------------------------------------------------------------------

static void SetNewPalette( PALETTEENTRY* const pPal, PWORD pwRainbowColors,
                                                     UINT R, UINT G, UINT B )
    {
    if (*pwRainbowColors < 256)
        {
        WORD wC;

        for (wC = 0;  wC < *pwRainbowColors;  wC++)
            if (((UINT)GetRValue( *(DWORD*)&pPal[ wC ] ) /* + 1 & ~1 */ ) == (R /* + 1 & ~1 */ )
            &&  ((UINT)GetGValue( *(DWORD*)&pPal[ wC ] ) /* + 1 & ~1 */ ) == (G /* + 1 & ~1 */ )
            &&  ((UINT)GetBValue( *(DWORD*)&pPal[ wC ] ) /* + 1 & ~1 */ ) == (B /* + 1 & ~1 */ ))
                return;

        pPal[*pwRainbowColors].peRed   = (BYTE)R;
        pPal[*pwRainbowColors].peGreen = (BYTE)G;
        pPal[*pwRainbowColors].peBlue  = (BYTE)B;
        pPal[*pwRainbowColors].peFlags = 0;

        (*pwRainbowColors)++;
        }
    }

/***************************************************************************/

CPalette* CreateDIBPalette(LPSTR lpbi)
    {
    LPLOGPALETTE     lpPal;
    CPalette*        pPal = NULL;
    int              iLoop;
    int              wNumColors;
    LPBITMAPINFO     lpbmi;
    LPBITMAPCOREINFO lpbmc;
    BOOL             bWinStyleDIB;
    BOOL             bGetDriverDefaults = FALSE;

    ASSERT( lpbi );

    if (lpbi == NULL)
        return NULL;

    lpbmi = (LPBITMAPINFO)lpbi;
    lpbmc = (LPBITMAPCOREINFO)lpbi;
    wNumColors = (int)DIBNumColors(lpbi, TRUE);
    bWinStyleDIB = IS_WIN30_DIB(lpbi);

    if (! wNumColors)
        {
        if (! theApp.m_bPaletted)
            return NULL;

        bGetDriverDefaults = TRUE;
        wNumColors = 256;
        }

    lpPal = (LPLOGPALETTE)new CHAR [sizeof( LOGPALETTE ) + sizeof( PALETTEENTRY ) * (wNumColors - 1)];

    if (lpPal == NULL)
        {
        theApp.SetMemoryEmergency();
        return NULL;
        }

    if (bGetDriverDefaults)
        {
        #define DIM( X ) (sizeof(X) / sizeof(X[0]))

        // GetRainbowPalette - Based on
        // Fran Finnegan's column in Microsoft Systems Journal, Sept.-Oct., 1991 (#5).
        static BYTE C[] = { 255, 238, 221,
                            204, 187, 170,
                            153, 136, 119,
                            102,  85,  68,
                             51,  34,  17,
                              0
                          };
        PALETTEENTRY* pPal = &(lpPal->palPalEntry[0]);
        WORD wColors = 0;
        int iC;
        int iR;
        int iG;
        int iB;

        for (iC = 0;  iC < DIM( C );  iC++)
            SetNewPalette( pPal, &wColors, C[ iC ], C[ iC ], C[ iC ] );
        for (iR = 0;  iR < DIM( C );  iR += 3)
        for (iG = 0;  iG < DIM( C );  iG += 3)
        for (iB = 0;  iB < DIM( C );  iB += 3)
            SetNewPalette( pPal, &wColors, C[ iR ], C[ iG ], C[ iB ] );
        for (iC = 0;  iC < DIM( C );  iC++)
            {
            SetNewPalette( pPal, &wColors, C[ iC ],       0,       0 );
            SetNewPalette( pPal, &wColors,       0, C[ iC ],       0 );
            SetNewPalette( pPal, &wColors,       0,       0, C[ iC ] );
            }
        }
    else
        for (iLoop = 0; iLoop < wNumColors; iLoop++)
            {
            if (bWinStyleDIB)
                {
                lpPal->palPalEntry[iLoop].peRed   = lpbmi->bmiColors[iLoop].rgbRed;
                lpPal->palPalEntry[iLoop].peGreen = lpbmi->bmiColors[iLoop].rgbGreen;
                lpPal->palPalEntry[iLoop].peBlue  = lpbmi->bmiColors[iLoop].rgbBlue;
                lpPal->palPalEntry[iLoop].peFlags = 0;
                }
            else
                {
                lpPal->palPalEntry[iLoop].peRed   = lpbmc->bmciColors[iLoop].rgbtRed;
                lpPal->palPalEntry[iLoop].peGreen = lpbmc->bmciColors[iLoop].rgbtGreen;
                lpPal->palPalEntry[iLoop].peBlue  = lpbmc->bmciColors[iLoop].rgbtBlue;
                lpPal->palPalEntry[iLoop].peFlags = 0;
                }
            }
    lpPal->palVersion = 0x300;
    lpPal->palNumEntries = (WORD)wNumColors;

    pPal = new CPalette;

    if (pPal == NULL || ! CreateSafePalette(pPal, lpPal ))
        {
        if (pPal)
            delete pPal;
        pPal = NULL;
        }

    delete [] (CHAR*)lpPal;

    return pPal;
    }

/***************************************************************************/

void Draw3dRect(HDC hDC, RECT * prc)
    {
    CDC* pDC = CDC::FromHandle(hDC);
    CBrush* pOldBrush = pDC->SelectObject( GetSysBrush( COLOR_BTNSHADOW ) );

    pDC->PatBlt(prc->left, prc->top, prc->right - prc->left - 1, 1, PATCOPY);
    pDC->PatBlt(prc->left, prc->top + 1, 1, prc->bottom - prc->top - 2, PATCOPY);

    pDC->SelectObject(GetSysBrush( COLOR_BTNHIGHLIGHT ));

    pDC->PatBlt(prc->left + 1, prc->bottom - 1,
                               prc->right - prc->left - 1, 1, PATCOPY);
    pDC->PatBlt(prc->right - 1, prc->top + 1,
                             1, prc->bottom - prc->top - 1, PATCOPY);

    pDC->SelectObject(pOldBrush);
    }

/***************************************************************************/
// DrawBitmap:
// See header file for usage.

void DrawBitmap(CDC* dc, CBitmap* bmSrc, CRect* rc,
    DWORD dwROP /* = SRCCOPY */, CDC* memdc /* = NULL */)
    {
    CBitmap* obm;
    CDC* odc = (memdc? memdc : (new CDC));

    if (!memdc)
        odc->CreateCompatibleDC(dc);

    obm = odc->SelectObject(bmSrc);

    BITMAP bms;
    bmSrc->GetObject(sizeof (BITMAP), (LPSTR)(LPBITMAP)(&bms));

    if (rc)
        {
        dc->BitBlt(rc->left + ((rc->right - rc->left - bms.bmWidth) >> 1),
            rc->top + ((rc->bottom - rc->top - bms.bmHeight) >> 1),
            bms.bmWidth, bms.bmHeight, odc, 0, 0, dwROP);
        }
    else
        {
        dc->BitBlt(0, 0, bms.bmWidth, bms.bmHeight, odc, 0, 0, dwROP);
        }

    odc->SelectObject(obm);
    if (!memdc)
        {
        odc->DeleteDC();
        delete odc;
        }
    }

/***************************************************************************/

BOOL EnsureUndoSize(IMG* pimg)
    {
    if (cxUndoWidth < pimg->cxWidth || cyUndoHeight < pimg->cyHeight ||
            (int)cUndoPlanes != pimg->cPlanes ||
            (int)cUndoBitCount != pimg->cBitCount)
        {
        HBITMAP  hNewUndoImgBitmap  = NULL;
 //       HBITMAP  hNewUndoMaskBitmap = NULL;
        HPALETTE hNewUndoPalette    = NULL;

        hNewUndoImgBitmap = CreateCompatibleBitmap( pimg->hDC, pimg->cxWidth, pimg->cyHeight );

        if (hNewUndoImgBitmap == NULL)
            {
            TRACE(TEXT("EnsureUndoSize: Create image bitmap failed!\n"));
            return FALSE;
            }

//        hNewUndoMaskBitmap = CreateBitmap( pimg->cxWidth, pimg->cyHeight, 1, 1, NULL );

//        if (hNewUndoMaskBitmap == NULL)
 //           {
//            TRACE(TEXT("EnsureUndoSize: Create mask bitmap failed!\n"));

//            DeleteObject( hNewUndoImgBitmap );

 //           return FALSE;
   //         }

//      if (theApp.m_pPalette)
//          {
//          LOGPALETTE256 logPal;

//          logPal.palVersion    = 0x300;
//          logPal.palNumEntries = theApp.m_pPalette->GetPaletteEntries( 0, 256,
//                                                                &logPal.palPalEntry[0] );
//          theApp.m_pPalette->GetPaletteEntries( 0, logPal.palNumEntries,
//                                                                &logPal.palPalEntry[0] );
//          hNewUndoPalette = ::CreatePalette( (LPLOGPALETTE)&logPal );

//          if (! hNewUndoPalette)
//              {
//              TRACE("EnsureUndoSize: Create palette bitmap failed!\n");

//              DeleteObject( hNewUndoImgBitmap  );
//              DeleteObject( hNewUndoMaskBitmap );

//              return FALSE;
//              }
//          }

        if (g_hUndoImgBitmap)
            DeleteObject(g_hUndoImgBitmap);

//      if (g_hUndoPalette)
//          DeleteObject(g_hUndoPalette);

        g_hUndoImgBitmap = hNewUndoImgBitmap;
//      g_hUndoPalette   = hNewUndoPalette;
        cxUndoWidth      = pimg->cxWidth;
        cyUndoHeight     = pimg->cyHeight;
        cUndoPlanes      = (BYTE)pimg->cPlanes;
        cUndoBitCount    = (BYTE)pimg->cBitCount;
        }

    return TRUE;
    }

/***************************************************************************/

void CleanupImgUndo()
    {
    if (g_hUndoImgBitmap)
        DeleteObject(g_hUndoImgBitmap);

    if (g_hUndoPalette)
        DeleteObject(g_hUndoPalette);

    g_hUndoImgBitmap = NULL;
    g_hUndoPalette   = NULL;
    cxUndoWidth      = 0;
    cyUndoHeight     = 0;
    cUndoPlanes      = 0;
    cUndoBitCount    = 0;
    }

/***************************************************************************/

BOOL SetUndo(IMG* pimg)
    {
    BOOL    bSuccess   = FALSE;
    HDC     hTempDC    = NULL;
    HBITMAP hOldBitmap = NULL;
    CRect   rect;

    if (! EnsureUndoSize( pimg ))
        goto LReturn;

    rect.SetRect( 0, 0, pimg->cxWidth, pimg->cyHeight );

    hTempDC = CreateCompatibleDC( pimg->hDC );

    if (hTempDC == NULL)
        {
        TRACE( TEXT("SetUndo: CreateCompatibleDC failed\n") );
        goto LReturn;
        }

    hOldBitmap = (HBITMAP)SelectObject( hTempDC, g_hUndoImgBitmap );

    BitBlt( hTempDC, 0, 0, rect.Width(), rect.Height(),
                pimg->hDC, rect.left, rect.top, SRCCOPY );

    SelectObject( hTempDC, hOldBitmap );
    DeleteDC( hTempDC );

    bSuccess = TRUE;

    LReturn:

    return bSuccess;
    }

/***************************************************************************/

void DrawBrush(IMG* pimg, CPoint pt, BOOL bDraw)
    {
    int nStrokeWidth = CImgTool::GetCurrent()->GetStrokeWidth();

    if (g_bCustomBrush)
        {
        CRect rc(pt.x, pt.y,
                pt.x + theImgBrush.m_size.cx, pt.y + theImgBrush.m_size.cy);
        rc -= (CPoint)theImgBrush.m_handle;

        theImgBrush.m_rcSelection = rc;

        int nCombineMode;
        COLORREF cr;

        if (bDraw)
            {
            nCombineMode = (theImgBrush.m_bOpaque) ? combineReplace : combineMatte;
            cr = crLeft;
            }
        else
            {
            nCombineMode = combineColor;
            cr = crRight;
            }

        if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
//          extern CTextTool  g_textTool;
//          g_textTool.Render(CDC::FromHandle(pimg->hDC), rc, TRUE, TRUE);
            }
        else
            {
            switch (nCombineMode)
                {
#ifdef DEBUG
                default:
                    ASSERT(FALSE);
#endif

                case combineColor:
                    theImgBrush.BltColor(pimg, rc.TopLeft(), cr);
                    break;

                case combineMatte:
                    theImgBrush.BltMatte(pimg, rc.TopLeft());
                    break;

                case combineReplace:
                    theImgBrush.BltReplace(pimg, rc.TopLeft());
                    break;
                }
            }

            InvalImgRect (pimg, &rc);
            CommitImgRect(pimg, &rc);
        }
    else
        {
        DrawImgLine(pimg, pt, pt, bDraw ? crLeft : crRight,
                    CImgTool::GetCurrent()->GetStrokeWidth(),
                    CImgTool::GetCurrent()->GetStrokeShape(), TRUE);
        rcDragBrush.left = pt.x - nStrokeWidth / 2;
        rcDragBrush.top = pt.y - nStrokeWidth / 2;
        rcDragBrush.right = rcDragBrush.left + nStrokeWidth;
        rcDragBrush.bottom = rcDragBrush.top + nStrokeWidth;
        }
    }

/***************************************************************************/

void DrawDCLine(HDC hDC, CPoint pt1, CPoint pt2,
                 COLORREF color, int nWidth, int nShape,
                 CRect& rc)
{
        HPEN   hOldPen;
        HBRUSH hBrush;
        HBRUSH hOldBrush;
        int    sx;
        int    sy;
        int    ex;
        int    ey;
        int    nWidthD2 = nWidth / 2;

        sx = pt1.x;
        sy = pt1.y;
        ex = pt2.x;
        ey = pt2.y;

        if (hDC)
        {
                hBrush    = ::CreateSolidBrush( color );
                hOldBrush = (HBRUSH)SelectObject( hDC, hBrush );

                if (nWidth == 1)
                {
                        HPEN hPen = CreatePen(PS_SOLID, 1, (COLORREF)color);

                        if (hPen)
                        {
                            hOldPen = (HPEN)SelectObject(hDC, hPen);

                            ::MoveToEx(hDC, sx, sy, NULL);
                            LineTo(hDC, ex, ey);
                            SetPixel(hDC, ex, ey, color);
                            SelectObject(hDC, hOldPen);
                            DeleteObject(hPen);
                        }
                }
                else
                {
//                      hOldPen = (HPEN)SelectObject(hDC, GetStockObject( NULL_PEN ));

                        BrushLine( CDC::FromHandle(hDC),
                                CPoint(sx - nWidthD2, sy - nWidthD2),
                                CPoint(ex - nWidthD2, ey - nWidthD2), nWidth, nShape);
//                      SelectObject( hDC, hOldPen );
                }

                SelectObject(hDC, hOldBrush);
                DeleteObject(hBrush);
        }

        if (sx < ex)
        {
                rc.left = sx;
                rc.right = ex + 1;
        }
        else
        {
                rc.left = ex;
                rc.right = sx + 1;
        }

        if (sy < ey)
        {
                rc.top = sy;
                rc.bottom = ey + 1;
        }
        else
        {
                rc.top = ey;
                rc.bottom = sy + 1;
        }

        rc.left   -= nWidth * 2;
        rc.top    -= nWidth * 2;
        rc.right  += nWidth * 2;
        rc.bottom += nWidth * 2;
}


void DrawImgLine(IMG* pimg, CPoint pt1, CPoint pt2,
                 COLORREF color, int nWidth, int nShape,
                 BOOL bCommit)
{
        CRect  rc;

        DrawDCLine(pimg->hDC, pt1, pt2, color, nWidth, nShape, rc);

        InvalImgRect(pimg, &rc);

        if (bCommit)
        {
                CommitImgRect(pimg, &rc);
        }
}

/***************************************************************************/

void FillImgRect( HDC hDC, CRect* prc, COLORREF cr )
    {
    FixRect( prc );

    CPoint pt1 = prc->TopLeft();
    CPoint pt2 = prc->BottomRight();

    StandardiseCoords( &pt1, &pt2 );

    int sx = pt1.x;
    int sy = pt1.y;
    int ex = pt2.x;
    int ey = pt2.y;

    CRect rc( sx, sy, ex, ey );

    HBRUSH hBr = ::CreateSolidBrush( cr );

    if (! hBr)
        {
        theApp.SetGdiEmergency();
        return;
        }

    if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        if (theImgBrush.m_cRgnPolyFreeHandSel.GetSafeHandle())
            {
            // offset bitmap in the imgwnd from selection boundary
            theImgBrush.m_cRgnPolyFreeHandSel.OffsetRgn( rc.left, rc.top );

            ::FillRgn( hDC, (HRGN)theImgBrush.m_cRgnPolyFreeHandSel.m_hObject,
                                                                        hBr );
            // offset back to selection boundary
            theImgBrush.m_cRgnPolyFreeHandSel.OffsetRgn( -rc.left, -rc.top );
            }
        }
    else
        {

        HPEN hPen = CreatePen( PS_NULL, 0, 0 );

        if (hPen)
            {
            HPEN   hOldPen =   (HPEN)SelectObject( hDC, hPen );
            HBRUSH hOldBr  = (HBRUSH)SelectObject( hDC, hBr );

            Rectangle( hDC, sx, sy, ex, ey );

            SelectObject( hDC, hOldPen);
            DeleteObject( hPen );
            SelectObject( hDC, hOldBr );
            }
        }

    DeleteObject( hBr );

    *prc = rc;
    }

/***************************************************************************/

void BrushLine(CDC* pDC, CPoint fromPt, CPoint toPt, int nWidth, int nShape)
    {
    CPen* pOldPen = (CPen*) pDC->SelectStockObject(NULL_PEN);
    CSize brushSize(nWidth, nWidth);

    int octant;

    if (nShape == slantedRightBrush || nShape == slantedLeftBrush)
        {
        int dx = abs(toPt.x - fromPt.x);
        int dy = abs(toPt.y - fromPt.y);

        if (toPt.x > fromPt.x)
            {
            if (toPt.y < fromPt.y)
                octant = (dx > dy) ? 0 : 1;
            else
                octant = (dx > dy) ? 7 : 6;
            }
        else
            {
            if (toPt.y < fromPt.y)
                octant = (dx > dy) ? 3 : 2;
            else
                octant = (dx > dy) ? 4 : 5;
            }
        }

    switch (nShape)
        {
        case squareBrush:
            PolyTo(pDC, fromPt, toPt, brushSize);
            break;

        case roundBrush:
            if (toPt != fromPt)
                {
                CRect tan;
                CPoint polyPts [4];

                if (!GetTanPt(brushSize, (CPoint)(toPt - fromPt), tan))
                    return;

                polyPts[0].x = fromPt.x + tan.left;
                polyPts[1].x = fromPt.x + tan.right;
                polyPts[2].x = toPt.x + tan.right;
                polyPts[3].x = toPt.x + tan.left;

                polyPts[0].y = fromPt.y + tan.top;
                polyPts[1].y = fromPt.y + tan.bottom;
                polyPts[2].y = toPt.y + tan.bottom;
                polyPts[3].y = toPt.y + tan.top;

                pDC->Polygon(polyPts, 4);

                Mylipse(pDC->m_hDC, fromPt.x, fromPt.y,
                        fromPt.x + brushSize.cx, fromPt.y + brushSize.cy, TRUE);
                }

            Mylipse(pDC->m_hDC, toPt.x, toPt.y,
                    toPt.x + brushSize.cx, toPt.y + brushSize.cy, TRUE);
            break;

        case slantedLeftBrush:
            {
            CPoint polyPts [6];

            fromPt.x -= 1;
            toPt.x -= 1;

            switch (octant)
                {
                case 0:
                    polyPts[0].x = fromPt.x;
                    polyPts[1].x = fromPt.x + 1;
                    polyPts[2].x = toPt.x + 1;
                    polyPts[3].x = toPt.x + brushSize.cy + 1;
                    polyPts[4].x = toPt.x + brushSize.cy;
                    polyPts[5].x = fromPt.x + brushSize.cy;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = toPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = fromPt.y;
                    break;

                case 1:
                    polyPts[0].x = fromPt.x;
                    polyPts[1].x = fromPt.x + 1;
                    polyPts[2].x = fromPt.x + brushSize.cy + 1;
                    polyPts[3].x = toPt.x + brushSize.cy + 1;
                    polyPts[4].x = toPt.x + brushSize.cy;
                    polyPts[5].x = toPt.x;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = fromPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = toPt.y + brushSize.cy;
                    break;

                case 2:
                case 3:
                    polyPts[0].x = fromPt.x + 1;
                    polyPts[1].x = fromPt.x;
                    polyPts[2].x = toPt.x;
                    polyPts[3].x = toPt.x + brushSize.cy;
                    polyPts[4].x = toPt.x + brushSize.cy + 1;
                    polyPts[5].x = fromPt.x + brushSize.cy + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = toPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = fromPt.y;
                    break;

                case 4:
                    polyPts[0].x = fromPt.x + brushSize.cy + 1;
                    polyPts[1].x = fromPt.x + brushSize.cy;
                    polyPts[2].x = toPt.x + brushSize.cy;
                    polyPts[3].x = toPt.x;
                    polyPts[4].x = toPt.x + 1;
                    polyPts[5].x = fromPt.x + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = toPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = fromPt.y + brushSize.cy;
                    break;

                case 5:
                    polyPts[0].x = fromPt.x + brushSize.cy + 1;
                    polyPts[1].x = fromPt.x + brushSize.cy;
                    polyPts[2].x = fromPt.x;
                    polyPts[3].x = toPt.x;
                    polyPts[4].x = toPt.x + 1;
                    polyPts[5].x = toPt.x + brushSize.cy + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = fromPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = toPt.y;
                    break;

                default:
                    polyPts[0].x = fromPt.x + brushSize.cy;
                    polyPts[1].x = fromPt.x + brushSize.cy + 1;
                    polyPts[2].x = toPt.x + brushSize.cy + 1;
                    polyPts[3].x = toPt.x + 1;
                    polyPts[4].x = toPt.x;
                    polyPts[5].x = fromPt.x;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = toPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = fromPt.y + brushSize.cy;
                    break;
                }

            pDC->Polygon(polyPts, 6);
            }
            break;

        case slantedRightBrush:
            {
            CPoint polyPts [6];

            switch (octant)
                {
                case 0:
                case 1:
                    polyPts[0].x = fromPt.x + brushSize.cy;
                    polyPts[1].x = fromPt.x + brushSize.cy + 1;
                    polyPts[2].x = toPt.x + brushSize.cy + 1;
                    polyPts[3].x = toPt.x + 1;
                    polyPts[4].x = toPt.x;
                    polyPts[5].x = fromPt.x;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = toPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = fromPt.y;
                    break;

                case 2 :
                    polyPts[0].x = fromPt.x + brushSize.cy + 1;
                    polyPts[1].x = fromPt.x + brushSize.cy;
                    polyPts[2].x = fromPt.x;
                    polyPts[3].x = toPt.x;
                    polyPts[4].x = toPt.x + 1;
                    polyPts[5].x = toPt.x + brushSize.cy + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = fromPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = toPt.y + brushSize.cy;
                    break;

                case 3 :
                    polyPts[0].x = fromPt.x + brushSize.cy + 1;
                    polyPts[1].x = fromPt.x + brushSize.cy;
                    polyPts[2].x = toPt.x + brushSize.cy;
                    polyPts[3].x = toPt.x;
                    polyPts[4].x = toPt.x + 1;
                    polyPts[5].x = fromPt.x + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = toPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = fromPt.y;
                    break;

                case 4 :
                case 5 :
                    polyPts[0].x = fromPt.x + 1;
                    polyPts[1].x = fromPt.x;
                    polyPts[2].x = toPt.x;
                    polyPts[3].x = toPt.x + brushSize.cy;
                    polyPts[4].x = toPt.x + brushSize.cy + 1;
                    polyPts[5].x = fromPt.x + brushSize.cy + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = toPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = fromPt.y + brushSize.cy;
                    break;

                case 6 :
                    polyPts[0].x = fromPt.x;
                    polyPts[1].x = fromPt.x + 1;
                    polyPts[2].x = fromPt.x + brushSize.cy + 1;
                    polyPts[3].x = toPt.x + brushSize.cy + 1;
                    polyPts[4].x = toPt.x + brushSize.cy;
                    polyPts[5].x = toPt.x;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = fromPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = toPt.y;
                    break;

                default :
                    polyPts[0].x = fromPt.x;
                    polyPts[1].x = fromPt.x + 1;
                    polyPts[2].x = toPt.x + 1;
                    polyPts[3].x = toPt.x + brushSize.cy + 1;
                    polyPts[4].x = toPt.x + brushSize.cy;
                    polyPts[5].x = fromPt.x + brushSize.cy;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = toPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = fromPt.y + brushSize.cy;
                    break;
                }

            pDC->Polygon(polyPts, 6);
            }
            break;
        }

    pDC->SelectObject(pOldPen);
    }

/***************************************************************************/

void SetCombineMode(int wNewCombineMode)
    {
    wCombineMode = wNewCombineMode;
    }

/***************************************************************************/

static int      cxLastShape;
static int      cyLastShape;
static int      cxShapeBitmap;
static int      cyShapeBitmap;
static CBitmap  shapeBitmap;
static enum { ellipse, roundRect }  nLastShape;

void Mylipse(HDC hDC, int x1, int y1, int x2, int y2, BOOL bFilled)
    {
        COLORREF crNewBk, crNewText;
        GetMonoBltColors(hDC, NULL, crNewBk, crNewText);

    COLORREF crOldText = SetTextColor(hDC, crNewText);
    COLORREF crOldBk   = SetBkColor  (hDC, crNewBk);

    int cx = x2 - x1;
    int cy = y2 - y1;

    if (!bFilled)
        {
        Ellipse(hDC, x1, y1, x2, y2);
        }
    else
        if (cx == cy && cx > 0 && cx <= 8)
            {
            // HACK: The Windows Ellipse function is no good for small ellipses, so I
            // use some little bitmaps here for filled circles 1 to 8 pixels in
            // diameter.

            static CBitmap  g_ellipses [8];

            if (g_ellipses[cx - 1].m_hObject == NULL &&
                    ! g_ellipses[cx - 1].LoadBitmap(IDB_ELLIPSE1 + cx - 1))
                {
                theApp.SetMemoryEmergency();
                SetTextColor(hDC, crOldText);
                SetBkColor(hDC, crOldBk);
                return;
                }

            HDC hTempDC = CreateCompatibleDC(hDC);
            if (hTempDC == NULL)
                {
                theApp.SetGdiEmergency();
                SetTextColor(hDC, crOldText);
                SetBkColor(hDC, crOldBk);
                return;
                }

            HBITMAP hOldBitmap = (HBITMAP) SelectObject(hTempDC,
                    g_ellipses[cx - 1].m_hObject);
            BitBlt(hDC, x1, y1, cx, cy, hTempDC, 0, 0, DSPDxax);
            SelectObject(hTempDC, hOldBitmap);
            DeleteDC(hTempDC);
            }
        else
            if (cx > 0 && cy > 0)
                {
                // Actually, Ellipse() is just no good...  Let's do as much
                // as possible our selves to fix it!  Here we draw the ellipse
                // into a monochrome bitmap to get the shape and then use that
                // as a mask to get the current pattern into the imge.

                HDC hTempDC = CreateCompatibleDC(hDC);
                if (hTempDC == NULL)
                    {
                    theApp.SetGdiEmergency();
                    SetTextColor(hDC, crOldText);
                    SetBkColor(hDC, crOldBk);
                    return;
                    }

                BOOL bRefill = FALSE;

                if (cx > cxShapeBitmap || cy > cyShapeBitmap)
                    {
                    shapeBitmap.DeleteObject();
                    if (shapeBitmap.CreateBitmap(cx, cy, 1, 1, NULL))
                        {
                        cxShapeBitmap = cx;
                        cyShapeBitmap = cy;
                        bRefill = TRUE;
                        }
                    }

                if (shapeBitmap.m_hObject == NULL)
                    {
                    theApp.SetMemoryEmergency();
                    DeleteDC(hTempDC);
                    SetTextColor(hDC, crOldText);
                    SetBkColor(hDC, crOldBk);
                    return;
                    }

                if (cx != cxLastShape || cy != cyLastShape || nLastShape != ellipse)
                    {
                    cxLastShape = cx;
                    cyLastShape = cy;
                    nLastShape = ellipse;
                    bRefill = TRUE;
                    }

                HBITMAP hOldBitmap = (HBITMAP)SelectObject(hTempDC,
                        shapeBitmap.m_hObject);

                if (bRefill)
                    {
                    PatBlt(hTempDC, 0, 0, cx, cy, BLACKNESS);
                    SelectObject(hTempDC, GetStockObject(WHITE_BRUSH));
                    SelectObject(hTempDC, GetStockObject(WHITE_PEN));
                    Ellipse(hTempDC, 0, 0, cx, cy);
                    }

                BitBlt(hDC, x1, y1, cx, cy, hTempDC, 0, 0, DSPDxax);

                SelectObject(hTempDC, hOldBitmap);
                DeleteDC(hTempDC);
                }

    SetTextColor(hDC, crOldText);
    SetBkColor(hDC, crOldBk);
    }

/***************************************************************************/
#ifdef XYZZYZ
void MyRoundRect(HDC hDC, int x1, int y1, int x2, int y2,
                 int nEllipseWidth, int nEllipseHeight, BOOL bFilled)
    {
    int cx = x2 - x1;
    int cy = y2 - y1;

    if (!bFilled)
        {
        RoundRect(hDC, x1, y1, x2, y2, nEllipseWidth, nEllipseHeight);
        return;
        }

    if (cx > 0 && cy > 0)
        {
        HDC hTempDC = CreateCompatibleDC(hDC);

        if (hTempDC == NULL)
            {
            theApp.SetGdiEmergency();
            return;
            }

        BOOL bRefill = FALSE;

        if (cx > cxShapeBitmap || cy > cyShapeBitmap)
            {
            shapeBitmap.DeleteObject();
            if (shapeBitmap.CreateBitmap(cx, cy, 1, 1, NULL))
                {
                cxShapeBitmap = cx;
                cyShapeBitmap = cy;
                bRefill = TRUE;
                }
            }

        if (shapeBitmap.m_hObject == NULL)
            {
            theApp.SetMemoryEmergency();
            DeleteDC(hTempDC);
            return;
            }

        if (cx != cxLastShape || cy != cyLastShape || nLastShape != roundRect)
            {
            cxLastShape = cx;
            cyLastShape = cy;
            nLastShape = roundRect;
            bRefill = TRUE;
            }

        HBITMAP hOldBitmap = (HBITMAP)SelectObject(hTempDC,
                shapeBitmap.m_hObject);

        if (bRefill)
            {
            PatBlt(hTempDC, 0, 0, cx, cy, BLACKNESS);
            SelectObject(hTempDC, GetStockObject(WHITE_BRUSH));
            SelectObject(hTempDC, GetStockObject(WHITE_PEN));
            RoundRect(hTempDC, 0, 0, cx, cy, nEllipseWidth, nEllipseHeight);
            }

        BitBlt(hDC, x1, y1, cx, cy, hTempDC, 0, 0, DSna);
        BitBlt(hDC, x1, y1, cx, cy, hTempDC, 0, 0, DSPao);

        SelectObject(hTempDC, hOldBitmap);
        DeleteDC(hTempDC);
        }
    }
#endif
/***************************************************************************/

void PolyTo(CDC* pDC, CPoint fromPt, CPoint toPt, CSize size)
    {
    CPoint polyPts [6];

    if (toPt.x > fromPt.x)
        {
        polyPts[0].x = polyPts[1].x = fromPt.x;
        polyPts[2].x = toPt.x;
        polyPts[3].x = polyPts[4].x = toPt.x + size.cx;
        polyPts[5].x = fromPt.x + size.cx;
        }
    else
        {
        polyPts[0].x = polyPts[1].x = fromPt.x + size.cx;
        polyPts[2].x = toPt.x + size.cx;
        polyPts[3].x = polyPts[4].x = toPt.x;
        polyPts[5].x = fromPt.x;
        }

    if (toPt.y > fromPt.y)
        {
        polyPts[0].y = polyPts[5].y = fromPt.y;
        polyPts[1].y = fromPt.y + size.cy;
        polyPts[2].y = polyPts[3].y = toPt.y + size.cy;
        polyPts[4].y = toPt.y;
        }
    else
        {
        polyPts[0].y = polyPts[5].y = fromPt.y + size.cy;
        polyPts[1].y = fromPt.y;
        polyPts[2].y = polyPts[3].y = toPt.y;
        polyPts[4].y = toPt.y + size.cy;
        }

    if (pDC)
        pDC->Polygon(polyPts, 6);
    }

/***************************************************************************/

BOOL GetTanPt(CSize size, CPoint delta, CRect& tan)
    {
    int x, y;
    int xExt, yExt, theExt, xTemp;
    CDC dc;
    CBitmap* pOldBitmap, bitmap;

    size.cx += 1;
    size.cy += 1;

    tan.SetRect(0, 0, 0, 0);

    if (!dc.CreateCompatibleDC(NULL))
        {
        theApp.SetGdiEmergency();
        return FALSE;
        }

    if (!bitmap.CreateCompatibleBitmap(&dc, size.cx, size.cy))
        {
        theApp.SetMemoryEmergency();
        return FALSE;
        }

    VERIFY((pOldBitmap = dc.SelectObject(&bitmap)));

    TRY
        {
        CBrush cBrushWhite(PALETTERGB(0xff, 0xff, 0xff));
        CRect cRectTmp(0,0,size.cx, size.cy);
        dc.FillRect(&cRectTmp, &cBrushWhite);
//    dc.PatBlt(0, 0, size.cx, size.cy, WHITENESS);
        }
    CATCH(CResourceException, e)
        {
        }
    END_CATCH
    dc.SelectStockObject(NULL_PEN);
    dc.SelectStockObject(BLACK_BRUSH);
    Mylipse(dc.m_hDC, 0, 0, size.cx, size.cy, TRUE);

    yExt = 0;
    for (xExt = 0; xExt < size.cx - 1; xExt++)
        {
        if (dc.GetPixel(xExt, 0) == 0)
            break;
        }
    theExt = 10 * xExt;

    if (delta.y == 0)
        {
        tan.SetRect(xExt, 0, xExt, size.cy - 1);
        }
    else
        {
        for (y = 0; y < size.cy; y++)
            {
            for (x = 0; x < size.cx - 1; x++)
                {
                if (dc.GetPixel(x, y) == 0)
                    break;
                }

            xTemp = 10 * x - 10 * y * delta.x / delta.y;
            if (theExt > xTemp)
                {
                xExt = x;
                yExt = y;
                theExt = xTemp;
                }
            else
                if (theExt < xTemp)
                    {
                    break;
                    }
            }

        tan.left = xExt;
        tan.top = yExt;

        for (y = 0; y < size.cy; y++)
            {
            for (x = size.cx - 1; x > 0; x--)
                {
                if (dc.GetPixel(x, y) == 0)
                    break;
                }
            xTemp = 10 * x - 10 * y * delta.x / delta.y;
            if (theExt < xTemp)
                {
                xExt = x;
                yExt = y;
                theExt = xTemp;
                }
            else
                if (theExt > xTemp)
                    {
                    break;
                    }
            }

        tan.right = xExt;
        tan.bottom = yExt;
        }

    dc.SelectObject(pOldBitmap);

    return TRUE;
    }

/***************************************************************************/

void PickupSelection()
    {
    // Time to pick up the bits!
    ASSERT(theImgBrush.m_pImg);

    if (theImgBrush.m_pImg == NULL)
        return;

    CPalette* ppalOld = theImgBrush.SetBrushPalette( &theImgBrush.m_dc, FALSE ); // Background ??
    CDC* pImgDC = CDC::FromHandle( theImgBrush.m_pImg->hDC );

    if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        TRY {
            CBrush cBrushBk( crRight );
            CRect  cRectTmp( 0, 0, theImgBrush.m_size.cx,
                                   theImgBrush.m_size.cy );

            theImgBrush.m_dc.FillRect( &cRectTmp, &cBrushBk );
            }
        CATCH(CResourceException, e)
            {
            theApp.SetGdiEmergency();
            return;
            }
        END_CATCH

        if (theImgBrush.m_cRgnPolyFreeHandSel.GetSafeHandle())
            {
            theImgBrush.m_dc.SelectClipRgn(&theImgBrush.m_cRgnPolyFreeHandSel);

            theImgBrush.m_dc.StretchBlt( 0, 0, theImgBrush.m_size.cx,
                                               theImgBrush.m_size.cy,
                                       pImgDC, theImgBrush.m_rcSelection.left,
                                               theImgBrush.m_rcSelection.top,
                                               theImgBrush.m_rcSelection.Width(),
                                               theImgBrush.m_rcSelection.Height(),
                                               SRCCOPY );

            theImgBrush.m_dc.SelectClipRgn(NULL);
            }
        }
    else
        {
        theImgBrush.m_dc.BitBlt( 0, 0, theImgBrush.m_size.cx,
                                       theImgBrush.m_size.cy,
                               pImgDC, theImgBrush.m_rcSelection.left,
                                       theImgBrush.m_rcSelection.top, SRCCOPY );
        }

    if (ppalOld)
        theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

    theImgBrush.RecalcMask( crRight );
    }

/***************************************************************************/

void CommitSelection(BOOL bSetUndo)
    {
    if (theImgBrush.m_bMakingSelection)
        return;

    if (! theImgBrush.m_bSmearSel
    &&  ( theImgBrush.m_pImg == NULL
       || theImgBrush.m_bFirstDrag
       || theImgBrush.m_bLastDragWasASmear))
        {
        return;
        }

    if (theImgBrush.m_bLastDragWasFirst
    && (theImgBrush.m_bMoveSel
     || theImgBrush.m_bSmearSel))
        {
        return;
        }

    TRACE1( "CommitSelection(%d)\n", bSetUndo );

    if (bSetUndo)
        {
        HideBrush();
        CRect rectUndo = theImgBrush.m_rcSelection;

        if (theImgBrush.m_bLastDragWasFirst)
            {
            theImgBrush.m_bLastDragWasFirst = FALSE;
            rectUndo |= theImgBrush.m_rcDraggedFrom;
            }
        else
            {
            SetUndo(theImgBrush.m_pImg);
            }

        CImgWnd::c_pImgWndCur->FinishUndo(rectUndo);
        }

    if (CImgTool::GetCurrentID() != IDMX_TEXTTOOL)
        {
        if (theImgBrush.m_bOpaque)
            {
            theImgBrush.BltReplace( theImgBrush.m_pImg,
                                    theImgBrush.m_rcSelection.TopLeft() );
            }
        else
            {
            theImgBrush.BltMatte( theImgBrush.m_pImg,
                                  theImgBrush.m_rcSelection.TopLeft() );
            }
        }

    InvalImgRect ( theImgBrush.m_pImg, &theImgBrush.m_rcSelection );
    CommitImgRect( theImgBrush.m_pImg, &theImgBrush.m_rcSelection );

    DirtyImg( theImgBrush.m_pImg );
    }

/***************************************************************************/

void AddImgWnd(IMG* pimg, CImgWnd* pImgWnd)
    {
    ASSERT(pImgWnd->m_pNextImgWnd == NULL);
    pImgWnd->m_pNextImgWnd = pimg->m_pFirstImgWnd;
    pimg->m_pFirstImgWnd = pImgWnd;
    }

/***************************************************************************/

void GetImgSize(IMG* pImg, CSize& size)
    {
    size.cx = pImg->cxWidth;
    size.cy = pImg->cyHeight;
    }

/***************************************************************************/

BOOL SetImgSize(IMG* pImg, CSize newSize, BOOL bStretch)
    {
    if (newSize.cx != pImg->cxWidth
    ||  newSize.cy != pImg->cyHeight)
        {
        HBITMAP hNewBitmap = CreateCompatibleBitmap( pImg->hDC,
                                                     newSize.cx, newSize.cy );
        if (hNewBitmap == NULL)
            {
            return FALSE;
            }
        HDC hDC = CreateCompatibleDC( pImg->hDC );

        if (hDC == NULL)
            {
            DeleteObject( hNewBitmap );
            return FALSE;
            }
        HBITMAP hOldBitmap = (HBITMAP)SelectObject( hDC, hNewBitmap );

        ASSERT( hOldBitmap );

        HPALETTE hpalOld = NULL;

        if (theApp.m_pPalette
        &&  theApp.m_pPalette->m_hObject)
            {
            hpalOld = SelectPalette( hDC, (HPALETTE)theApp.m_pPalette->m_hObject, FALSE ); // Background ??
            RealizePalette( hDC );
            }

        if (bStretch)
            {
            UINT uStretch = HALFTONE;


            if (pImg->cPlanes * pImg->cBitCount == 1)
                {
                uStretch = BLACKONWHITE;

                if (GetRValue( crLeft )
                ||  GetGValue( crLeft )
                ||  GetBValue( crLeft ))
                    uStretch = WHITEONBLACK;
                }

            SetStretchBltMode( hDC, uStretch );

            StretchCopy( hDC, 0, 0, newSize.cx, newSize.cy,
                   pImg->hDC, 0, 0, pImg->cxWidth, pImg->cyHeight );
            }
        else
            {
            // Fill it with the background color first!
            HBRUSH hBrush  = ::CreateSolidBrush(crRight);

            ASSERT(hBrush);

            if (hBrush)
                {
                HBRUSH hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);

                ASSERT(hOldBrush);

                PatBlt(hDC, 0, 0, newSize.cx, newSize.cy, PATCOPY);

                VERIFY(SelectObject(hDC, hOldBrush) == hBrush);

                DeleteObject(hBrush);
                }

            BitBlt(hDC, 0, 0, newSize.cx, newSize.cy, pImg->hDC, 0, 0, SRCCOPY);
            }

        if (hpalOld)
            SelectPalette( hDC, hpalOld, FALSE ); // Background ??

        VERIFY( SelectObject(       hDC, hOldBitmap) ==    hNewBitmap );
        VERIFY( SelectObject( pImg->hDC, hNewBitmap) == pImg->hBitmap );

        DeleteObject( pImg->hBitmap );
        DeleteDC( hDC );

        pImg->hBitmap  = hNewBitmap;
        pImg->cxWidth  = newSize.cx;
        pImg->cyHeight = newSize.cy;

        pRubberImg = NULL;

        SetupRubber( pImg );

        InvalImgRect(pImg, NULL);

        CImgWnd* pImgWnd = pImg->m_pFirstImgWnd;

        while (pImgWnd)
            {
            pImgWnd->Invalidate( FALSE );
            pImgWnd->CheckScrollBars();

            pImgWnd = pImgWnd->m_pNextImgWnd;
            }
        }

    return TRUE;
    }

/***************************************************************************/

// This may be set to TRUE via the "DriverCanStretch" entry in the INI file.
// Doing so will speed up the graphics editor, but will cause some device
// drivers to crash (hence the FALSE default).
//
BOOL  g_bDriverCanStretch = TRUE;

void StretchCopy( HDC hdcDest, int xDest, int yDest, int cxDest, int cyDest,
                  HDC hdcSrc , int xSrc , int ySrc , int cxSrc , int cySrc )
    {
    if (cxDest == cxSrc && cyDest == cySrc)
        {
        // No point in using the trick if we're not really stretching...

        BitBlt(hdcDest, xDest, yDest, cxDest, cyDest,
               hdcSrc,  xSrc,  ySrc, SRCCOPY);
        }
    else
        if (g_bDriverCanStretch ||
            cxDest < 0 || cyDest < 0 || cxSrc < 0 || cySrc < 0)
            {
            // We can't use the following trick when flipping, but the
            // driver will usually pass things on to GDI here anyway...

            StretchBlt(hdcDest, xDest, yDest, cxDest, cyDest,
                       hdcSrc, xSrc, ySrc, cxSrc, cySrc, SRCCOPY);
            }
        else
            {
            // Some drivers (e.g. Paradise) crash on memory to memory stretches,
            // so we trick them into just using GDI here by not using SRCCOPY...

            PatBlt(hdcDest, xDest, yDest, cxDest, cyDest, BLACKNESS);

            StretchBlt(hdcDest, xDest, yDest, cxDest, cyDest,
                        hdcSrc, xSrc, ySrc, cxSrc, cySrc, DSo);
            }
    }

/***************************************************************************/

void StandardiseCoords(CPoint* s, CPoint* e)
    {
    if (s->x > e->x)
        {
        int tx;

        tx = s->x;
        s->x = e->x;
        e->x = tx;
        }

    if (s->y > e->y)
        {
        int ty;

        ty = s->y;
        s->y = e->y;
        e->y = ty;
        }
    }

/***************************************************************************/

CPalette* MergePalettes( CPalette *pPal1, CPalette *pPal2, int& iAdds )
    {
    int           iPal1NumEntries;
    int           iPal2NumEntries;
    LOGPALETTE256 LogPal1;
    LOGPALETTE256 LogPal2;
    CPalette*     pPalMerged = NULL;

    iAdds = 0;

    if (pPal1 == NULL ||  pPal2 == NULL)
        return NULL;

    iPal1NumEntries = pPal1->GetPaletteEntries( 0, 256, &LogPal1.palPalEntry[0] );
    pPal1->GetPaletteEntries( 0, iPal1NumEntries, &LogPal1.palPalEntry[0] );

    iPal2NumEntries = pPal2->GetPaletteEntries( 0, 256, &LogPal2.palPalEntry[0] );
    pPal2->GetPaletteEntries( 0, iPal2NumEntries, &LogPal2.palPalEntry[0] );

    // check if room left in 1st palette to merge.  If no room, then use 1st palette
    for (int i = 0; i < iPal2NumEntries
                     && iPal1NumEntries < MAX_PALETTE_COLORS; i++)
        {
        for (int j = 0; j < iPal1NumEntries; j++)
            {
            if (LogPal1.palPalEntry[j].peRed   == LogPal2.palPalEntry[i].peRed
            &&  LogPal1.palPalEntry[j].peGreen == LogPal2.palPalEntry[i].peGreen
            &&  LogPal1.palPalEntry[j].peBlue  == LogPal2.palPalEntry[i].peBlue)
                break;
            }

        if (j < iPal1NumEntries)
            continue;  // found one

        // color was not found in 1st palette add it if room
        LogPal1.palPalEntry[iPal1NumEntries++] = LogPal2.palPalEntry[i];
        iAdds++;
        }

    LogPal1.palVersion    = 0x300;
    LogPal1.palNumEntries = (WORD)iPal1NumEntries;

    pPalMerged = new CPalette();

    if (pPalMerged)
        if (! CreateSafePalette(pPalMerged, (LPLOGPALETTE)&LogPal1 ))
            {
            delete pPalMerged;
            pPalMerged = NULL;
            }

    return pPalMerged;
    }

/******************************************************************************/

void AdjustPointForGrid(CPoint *ptPointLocation)
    {
    if (theApp.m_iSnapToGrid != 0)
        {
        int iNextGridOffset;

        iNextGridOffset = ptPointLocation->x % theApp.m_iGridExtent;
        // if distance to next grid is less than 1/2 distance between grids
        // closer to previous grid
        if (iNextGridOffset <= theApp.m_iGridExtent/2)
            {
            iNextGridOffset *= -1; // closer to previous grid location
            }
        else
            {
            iNextGridOffset = theApp.m_iGridExtent -iNextGridOffset; // closer to next grid location
            }
        ptPointLocation->x = ptPointLocation->x + iNextGridOffset;

        // if distance to next grid is less than 1/2 distance between grids
        // closer to previous grid
        iNextGridOffset = ptPointLocation->y % theApp.m_iGridExtent;
        if (iNextGridOffset <= theApp.m_iGridExtent/2)
            {
            iNextGridOffset *= -1; // closer to previous grid location
            }
        else
            {
            iNextGridOffset = theApp.m_iGridExtent -iNextGridOffset; // closer to next grid location
            }

        ptPointLocation->y = ptPointLocation->y + iNextGridOffset;
        }
    }

static unsigned short  bmapHorzBorder [] =
                                { 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0 };

static unsigned short  bmapVertBorder [] =
                                { 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00 };

       CBrush   g_brSelectHorz;
       CBrush   g_brSelectVert;
static CBitmap  m_bmSelectHorz;
static CBitmap  m_bmSelectVert;

void InitCustomData()                           // called once in main
    {
    //
    // no windows critical error message box, return errors to open call
    //
    if (m_bmSelectHorz.CreateBitmap( 8, 8, 1, 1, (LPSTR)bmapHorzBorder ))
        g_brSelectHorz.CreatePatternBrush( &m_bmSelectHorz );

    if (m_bmSelectVert.CreateBitmap( 8, 8, 1, 1, (LPSTR)bmapVertBorder ))
        g_brSelectVert.CreatePatternBrush( &m_bmSelectVert );

    SetErrorMode( SEM_FAILCRITICALERRORS );
    }

//
// make sure global resoures are freed
//
void CustomExit()
    {
    if (g_brSelectHorz.m_hObject)
        g_brSelectHorz.DeleteObject();

    if (m_bmSelectHorz.m_hObject)
        m_bmSelectHorz.DeleteObject();

    if (g_brSelectVert.m_hObject)
        g_brSelectVert.DeleteObject();

    if (m_bmSelectVert.m_hObject)
        m_bmSelectVert.DeleteObject();
    }

/*
int FileTypeFromExtension( const TCHAR far* lpcExt )
    {
    if (*lpcExt == TEXT('.'))        // skip the . in .*
        lpcExt++;

    // must be redone
    return NULL;
    }
*/

CPalette *PBSelectPalette(CDC *pDC, CPalette *pPalette, BOOL bForceBk)
{
        if (!pPalette)
        {
                return(NULL);
        }

        if (IsInPlace())
        {
                bForceBk = TRUE;
        }

        CPalette *ppalOld = pDC->SelectPalette( theApp.m_pPalette, bForceBk );
        pDC->RealizePalette();

        return(ppalOld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgtools.h ===
#ifndef __IMGTOOLS_H__
#define __IMGTOOLS_H__

extern BOOL  g_bBrushVisible;
extern BOOL  g_bPickingColor;
extern UINT  g_nStrokeWidth;

typedef enum
    {
    eFREEHAND,
    eEAST_WEST,   //HORIZONTAL
    eNORTH_SOUTH, //VERTICAL
    eNORTH_WEST,  // 45 degree up to left
    eSOUTH_EAST,  // 45 degree down to right
    eNORTH_EAST,  // 45 degree up to right
    eSOUTH_WEST   // 45 degree down to left
    } eDRAWCONSTRAINTDIRECTION;

class CImgTool : public CObject
    {
    DECLARE_DYNAMIC( CImgTool )

    protected:

    eDRAWCONSTRAINTDIRECTION DetermineDrawDirection(MTI *pmti);
    virtual void AdjustPointsForConstraint(MTI *pmti);
    virtual void PreProcessPoints(MTI *pmti);

    eDRAWCONSTRAINTDIRECTION m_eDrawDirection;

    public:

    CImgTool();

    virtual void OnEnter        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnLeave        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnStartDrag    ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnEndDrag      ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnDrag         ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnMove         ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnTimer        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnCancel       ( CImgWnd* pImgWnd);
    virtual void OnActivate     ( BOOL bActivate );
    virtual void OnShowDragger  ( CImgWnd* pImgWnd, BOOL bShow );
    virtual void OnPaintOptions ( CDC* pDC, const CRect& paintRect,
                                            const CRect& optionsRect );
    virtual void OnClickOptions ( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                     const CPoint& clickPoint );
    virtual void OnUpdateColors (CImgWnd* pImgWnd);
    virtual BOOL CanEndMultiptOperation(MTI* pmti );
    virtual void EndMultiptOperation(BOOL bAbort = FALSE);

    virtual BOOL IsToolModal(void);
    virtual BOOL SetupPenBrush(HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown);

    void PaintStdBrushes( CDC* pDC, const CRect& paintRect,
                          const CRect& optionsRect );


    void PaintStdPattern( CDC* pDC, const CRect& paintRect,
                                    const CRect& optionsRect );

    void ClickStdBrushes(CImgToolWnd* pWnd, const CRect& optionsRect,
                         const CPoint& clickPoint);

    void ClickStdPattern(CImgToolWnd* pWnd, const CRect& optionsRect,
                         const CPoint& clickPoint);

    static void   HideDragger(CImgWnd* pImgWnd);
    static void   ShowDragger(CImgWnd* pImgWnd);

    inline BOOL   UsesBrush()const { return m_bUsesBrush; }
    inline BOOL   IsToggle() const { return m_bToggleWithPrev; }
    inline BOOL   IsFilled() const { return m_bFilled; }
    inline BOOL   HasBorder()const { return m_bBorder; }
    inline UINT   GetCmdID() const { return m_nCmdID; }
    inline BOOL   IsMultPtOpInProgress() const { return m_bMultPtOpInProgress; }

    virtual BOOL   IsUndoable();
    virtual UINT  GetCursorID();

    void  SetStrokeWidth(UINT nNewStrokeWidth);

    inline UINT   GetStrokeWidth() const { return m_nStrokeWidth; }
    inline UINT   GetStrokeShape() const { return m_nStrokeShape; }
           void   SetStrokeShape(UINT nNewStrokeShape);

    static inline CImgTool* GetCurrent() { return c_pCurrentImgTool; }
    static inline UINT GetCurrentID()    { return c_pCurrentImgTool->m_nCmdID; }
    static inline BOOL IsDragging()      { return c_bDragging; }

    void   Select();

    static void Select(UINT nCmdID);
    static inline void SelectPrevious()     {
                                            ASSERT(c_pPreviousImgTool != NULL);
                                            c_pPreviousImgTool->Select();
                                            }
    static CImgTool* FromID(UINT nCmdID);

    protected:

    BOOL      m_bUsesBrush;
    BOOL      m_bIsUndoable;
    BOOL      m_bCanBePrevTool;
    BOOL      m_bToggleWithPrev;
    BOOL      m_bFilled;
    BOOL      m_bBorder;
    BOOL      m_bMultPtOpInProgress;

    UINT      m_nStrokeWidth;
    UINT      m_nStrokeShape;

    UINT      m_nCursorID;
    UINT      m_nCmdID;
    CImgTool* m_pNextImgTool;

    static CImgTool*  c_pHeadImgTool;
    static CImgTool*  c_pCurrentImgTool;
    static CImgTool*  c_pPreviousImgTool;
    static BOOL       c_bDragging;
    static int        c_nHideCount;
    };


class CRubberTool : public CImgTool
    {
    DECLARE_DYNAMIC(CRubberTool)

    protected:

    virtual void AdjustPointsForConstraint(MTI *pmti);
 //   virtual BOOL SetupMaskPenBrush(HDC hDC, BOOL bLeftButton, BOOL bSetup);

    public:

    CRubberTool();

    virtual void OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                           const CRect& optionsRect );

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);

    virtual void Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown);
    virtual void OnActivate    ( BOOL bActivate );

    static CRect  rcPrev;
    };

class CClosedFormTool : public CRubberTool
    {
    DECLARE_DYNAMIC(CClosedFormTool)

    public:

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    };


class CRectTool : public CClosedFormTool
    {
    DECLARE_DYNAMIC(CRectTool)

    public:

    CRectTool();
    };

class CRoundRectTool : public CClosedFormTool
    {
    DECLARE_DYNAMIC(CRoundRectTool)

    public:

    CRoundRectTool();
    };

class CEllipseTool : public CClosedFormTool
    {
    DECLARE_DYNAMIC(CEllipseTool)

    public:

    CEllipseTool();
    };

class CLineTool : public CRubberTool
    {
    DECLARE_DYNAMIC(CLineTool)

    protected:

    virtual void AdjustPointsForConstraint(MTI *pmti);
    friend class CPolygonTool; // need to call AdjustPointsForContstraint from cPolygonTool
    friend class CCurveTool; // need to call AdjustPointsForContstraint from cPolygonTool

    public:

    CLineTool();

    virtual void Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown);
    };


class CSelectTool : public CImgTool
    {
    DECLARE_DYNAMIC(CSelectTool)

    protected:

    friend class CFreehandSelectTool; // need to call OnClickOptions and OnPaintOptions

    public:

    CSelectTool();

    virtual void OnActivate(BOOL bActivate);

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnCancel(CImgWnd* pImgWnd);
    virtual void OnShowDragger(CImgWnd* pImgWnd, BOOL bShow);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual BOOL IsToolModal(void);

    void InvertSelectRect(CImgWnd* pImgWnd);

    UINT GetCursorID();

    static CRect       c_selectRect;
    static CImageWell  c_imageWell;
    };


class CFreehandTool : public CImgTool
    {
    DECLARE_DYNAMIC(CFreehandTool)

    public:

    CFreehandTool();

    void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);

    static CRect  c_undoRect;
    };

class CSketchTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CSketchTool)

    public:

    CSketchTool();

    virtual void OnDrag  ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnCancel( CImgWnd* pImgWnd );
    };


class CBrushTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CBrushTool)

    public:

    CBrushTool();

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnMove(CImgWnd* pImgWnd, MTI* pmti);
    };


class CPencilTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CPencilTool)
    protected:
        virtual void AdjustPointsForConstraint(MTI *pmti);

    public:

    CPencilTool();

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    };


class CEraserTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CEraserTool)

    public:

    CEraserTool();

    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnMove(CImgWnd* pImgWnd, MTI* pmti);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual void OnShowDragger(CImgWnd* pImgWnd, BOOL bShow);
    virtual UINT GetCursorID();
    };


class CAirBrushTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CAirBrushTool)

    public:

    CAirBrushTool();

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnTimer(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnCancel(CImgWnd* pImgWnd);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    static CImageWell  c_imageWell;
    private:

    BOOL m_bCtrlDown;
    };


class CFloodTool : public CImgTool
    {
    DECLARE_DYNAMIC(CFloodTool)

    public:

    CFloodTool();

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    };


class CPickColorTool : public CImgTool
    {
    DECLARE_DYNAMIC(CPickColorTool)

    public:

    COLORREF m_Color;

    CPickColorTool();

    virtual void OnActivate(BOOL bActivate);
    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnCancel(CImgWnd* pImgWnd);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);
    };


class CZoomTool : public CImgTool
    {
    DECLARE_DYNAMIC(CZoomTool)

    protected:

    void InvertZoomRect();

    static CRect  c_zoomRect;
    static CImgWnd* c_pImgWnd;
    static CImageWell  c_imageWell;

    public:

    CZoomTool();

    virtual void OnLeave(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnMove(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnCancel(CImgWnd* pImgWnd);
    virtual void OnShowDragger(CImgWnd* pImgWnd, BOOL bShow);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);
    };

#endif // __IMGTOOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgtools.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "t_text.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "undo.h"
#include "props.h"
#include "colorsrc.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CImgTool, CObject)
IMPLEMENT_DYNAMIC(CRubberTool, CImgTool)
IMPLEMENT_DYNAMIC(CClosedFormTool, CRubberTool)
IMPLEMENT_DYNAMIC(CFreehandTool, CImgTool)
IMPLEMENT_DYNAMIC(CSketchTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CBrushTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CPencilTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CEraserTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CAirBrushTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CLineTool, CRubberTool)
IMPLEMENT_DYNAMIC(CRectTool, CClosedFormTool)
IMPLEMENT_DYNAMIC(CRoundRectTool, CClosedFormTool)
IMPLEMENT_DYNAMIC(CEllipseTool, CClosedFormTool)
IMPLEMENT_DYNAMIC(CPickColorTool, CImgTool)
IMPLEMENT_DYNAMIC(CFloodTool, CImgTool)
IMPLEMENT_DYNAMIC(CSelectTool, CImgTool)
IMPLEMENT_DYNAMIC(CZoomTool, CImgTool)

#include "memtrace.h"

extern CRect  rcDragBrush;

extern HDC  hRubberDC;


BOOL  g_bBrushVisible;
BOOL  g_bPickingColor;
UINT  g_nStrokeWidth = 1;

/***************************************************************************/
//
// Drawing Tool Classes
//

CRectTool             g_rectTool;
CRoundRectTool        g_roundRectTool;
CEllipseTool          g_ellipseTool;
CLineTool             g_lineTool;
CSelectTool           g_selectTool;
CBrushTool            g_brushTool;
CSketchTool           g_sketchTool;
CPencilTool           g_pencilTool;
CEraserTool           g_eraserTool;
CAirBrushTool         g_airBrushTool;
CFloodTool            g_floodTool;
CPickColorTool        g_pickColorTool;
CZoomTool             g_zoomTool;

/***************************************************************************/

CImgTool*  CImgTool::c_pHeadImgTool     = NULL;
CImgTool*  CImgTool::c_pCurrentImgTool  = &g_pencilTool;
CImgTool*  CImgTool::c_pPreviousImgTool = &g_pencilTool;
BOOL       CImgTool::c_bDragging        = FALSE;
int        CImgTool::c_nHideCount       = 0;

/***************************************************************************/

CImgTool::CImgTool()
    {
    m_bUsesBrush          = FALSE;
    m_bIsUndoable         = TRUE;
    m_bCanBePrevTool      = TRUE;
    m_bToggleWithPrev     = FALSE;
    m_bFilled             = FALSE;
    m_bBorder             = TRUE;
    m_bMultPtOpInProgress = FALSE;
    m_eDrawDirection      = eFREEHAND;

    m_nStrokeWidth = 0;
    m_nStrokeShape = roundBrush;

    m_nCursorID = LOWORD(IDC_CROSSHAIR);
    m_nCmdID    = NULL;

    // Link into the list of tools...
    m_pNextImgTool = c_pHeadImgTool;
    c_pHeadImgTool = this;
    }

/******************************************************************************/

eDRAWCONSTRAINTDIRECTION CImgTool::DetermineDrawDirection(MTI *pmti)
    {
    eDRAWCONSTRAINTDIRECTION eDrawDirection;

    // 45 is dominant, test first
    if ( (pmti->pt.x > pmti->ptPrev.x) &&
         (pmti->pt.y > pmti->ptPrev.y) )
        {
            eDrawDirection = eSOUTH_EAST;
        }
    else
        {
        if ( (pmti->pt.x > pmti->ptPrev.x) &&
             (pmti->pt.y < pmti->ptPrev.y) )
            {
                eDrawDirection = eNORTH_EAST;
            }
        else
            {
            if ( (pmti->pt.x < pmti->ptPrev.x) &&
                 (pmti->pt.y > pmti->ptPrev.y) )
                {
                    eDrawDirection = eSOUTH_WEST;
                }
            else
                {
                if ( (pmti->pt.x < pmti->ptPrev.x) &&
                     (pmti->pt.y < pmti->ptPrev.y) )
                    {
                        eDrawDirection = eNORTH_WEST;
                    }
                else
                    {
                    // Horizontal is the next dominant, test before vertical
                    if (pmti->ptPrev.x != pmti->pt.x)
                        {
                        eDrawDirection = eEAST_WEST;
                        pmti->pt.y = pmti->ptPrev.y;
                        }
                    else
                        {
                        if (pmti->ptPrev.y != pmti->pt.y)
                            {
                            eDrawDirection = eNORTH_SOUTH;
                            pmti->pt.x = pmti->ptPrev.x;
                            }
                        else
                            {
                            // we should never fall into here, but in any case...
                            eDrawDirection = eFREEHAND;
                            }
                        }
                    }
                }
            }
        }
    return eDrawDirection;
    }

/******************************************************************************/

void CImgTool::AdjustPointsForConstraint(MTI *pmti)
    {
    }

/******************************************************************************/

void CImgTool::PreProcessPoints(MTI *pmti)
    {
    if (pmti != NULL)
        {
        if ((GetKeyState(VK_SHIFT) & 0x8000) != 0) //still in constrain mode
            {
            switch (m_eDrawDirection)
                {
                case eEAST_WEST:
                case eNORTH_SOUTH:
                case eNORTH_WEST:
                case eSOUTH_EAST:
                case eNORTH_EAST:
                case eSOUTH_WEST:
                     AdjustPointsForConstraint(pmti);
                     break;
                default: // not in constraint mode yet If shift down, check for
                         // mode and save mode else nothing.  Default is freehand
                     m_eDrawDirection = DetermineDrawDirection(pmti);
                     AdjustPointsForConstraint(pmti);
                    break;
                }
            }
        else
            {
            // shift not down
            m_eDrawDirection = eFREEHAND;
            }
        }
    }

/***************************************************************************/

void CImgTool::HideDragger(CImgWnd* pImgWnd)
    {
    ASSERT(c_pCurrentImgTool != NULL);

    if (c_nHideCount == 0)
        c_pCurrentImgTool->OnShowDragger(pImgWnd, FALSE);
    c_nHideCount++;
    }

/***************************************************************************/

void CImgTool::ShowDragger(CImgWnd* pImgWnd)
    {
    ASSERT(c_pCurrentImgTool != NULL);

    if (--c_nHideCount == 0)
        c_pCurrentImgTool->OnShowDragger(pImgWnd, TRUE);
    }

/***************************************************************************/

void CImgTool::Select(UINT nCmdID)
    {
    CImgTool* p = FromID(nCmdID);
    if (p)
        {
        p->Select();
        }
    }

/***************************************************************************/

void CImgTool::Select()
    {
    ASSERT(this != NULL);

    if (this == c_pCurrentImgTool && m_bToggleWithPrev)
        {
        SelectPrevious();
        return;
        }

    if (g_bCustomBrush)
        {
        g_bCustomBrush = FALSE;
        SetCombineMode(combineColor);
        }

    HideBrush();

    if (c_pCurrentImgTool->m_bCanBePrevTool && c_pCurrentImgTool != this)
        c_pPreviousImgTool = c_pCurrentImgTool;

    // Make sure to Deactivate the old one BEFORE activating the new one, so
    // globals (like g_nStrokeWidth) get set correctly
    if (c_pCurrentImgTool != NULL)
        c_pCurrentImgTool->OnActivate(FALSE);

    c_pCurrentImgTool = this;

    OnActivate(TRUE);

    if (c_pCurrentImgTool != this)
        {
        // Some tools may give up activation...
        ASSERT(!m_bCanBePrevTool);
        return;
        }

    SetCombineMode(combineColor);

    if (g_pImgToolWnd)
    {
        g_pImgToolWnd->SelectTool( (WORD)m_nCmdID );

        if (g_pImgToolWnd->m_hWnd)
            g_pImgToolWnd->InvalidateOptions();
    }

    CImgWnd::SetToolCursor();
    }

/***************************************************************************/

CImgTool* CImgTool::FromID(UINT nCmdID)
    {
    CImgTool* pImgTool = c_pHeadImgTool;
    while (pImgTool != NULL && pImgTool->m_nCmdID != nCmdID)
        pImgTool = pImgTool->m_pNextImgTool;
    return pImgTool;
    }

/***************************************************************************/

void CImgTool::SetStrokeWidth(UINT nNewStrokeWidth)
    {
    if (nNewStrokeWidth == m_nStrokeWidth)
        return;

    HideBrush();
    g_bCustomBrush = FALSE;
    m_nStrokeWidth = nNewStrokeWidth;
    g_pImgToolWnd->InvalidateOptions();

    extern MTI  mti;

    if (mti.fLeft || mti.fRight)
        OnDrag(CImgWnd::GetCurrent(), &mti);
    }

/***************************************************************************/

void CImgTool::SetStrokeShape(UINT nNewStrokeShape)
    {
    if (m_nStrokeShape == nNewStrokeShape)
        return;

    HideBrush();
    g_bCustomBrush = FALSE;
    m_nStrokeShape = nNewStrokeShape;
    g_pImgToolWnd->InvalidateOptions(FALSE);
    }

/***************************************************************************/

void CImgTool::OnActivate(BOOL bActivate)
    {
    if (bActivate)
        OnShowDragger(CImgWnd::GetCurrent(), TRUE);
    }

/***************************************************************************/

void CImgTool::OnEnter(CImgWnd* pImgWnd, MTI* pmti)
    {
    // No default action
    }

/***************************************************************************/

void CImgTool::OnLeave(CImgWnd* pImgWnd, MTI* pmti)
    {
    // No default action
    }

/***************************************************************************/

void CImgTool::OnShowDragger(CImgWnd* pImgWnd, BOOL bShowDragger)
    {
    // No default action
    }

/***************************************************************************/

void CImgTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    c_bDragging = TRUE;
    }

/***************************************************************************/

void CImgTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    c_bDragging = FALSE;

    if (m_bIsUndoable)
        DirtyImg(pImgWnd->m_pImg);
    }

/***************************************************************************/

void CImgTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    ASSERT(c_bDragging);
    }

/***************************************************************************/

void CImgTool::OnMove(CImgWnd* pImgWnd, MTI* pmti)
    {
//   ASSERT(!c_bDragging);

    if (UsesBrush())
        {
        fDraggingBrush = TRUE;
        pImgWnd->ShowBrush(pmti->pt);
        }

    SetStatusBarPosition(pmti->pt);
    }

/***************************************************************************/

void CImgTool::OnTimer(CImgWnd* pImgWnd, MTI* pmti)
    {
    // Tools should not have started a timer unless it overrides this!
    ASSERT(FALSE);
    }

/***************************************************************************/

void CImgTool::OnCancel(CImgWnd* pImgWnd)
    {
    c_bDragging = FALSE;
    }

/***************************************************************************/

void CImgTool::OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                        const CRect& optionsRect)
    {
    }

/***************************************************************************/

void CImgTool::PaintStdPattern(CDC* pDC, const CRect& paintRect,
                                         const CRect& optionsRect)
    {
    CBrush brush;
    CPalette *pcPaletteOld = NULL;
    CPalette *pcPaletteOld2 = NULL;

    CDC dc;
    if (!dc.CreateCompatibleDC(pDC))
        return;

    CBitmap bitmap, * pOldBitmap;
    if (!bitmap.CreateCompatibleBitmap(pDC, 8, 8))
        return;

    pOldBitmap = dc.SelectObject(&bitmap);

    if (theApp.m_pPalette)
        {
        pcPaletteOld = pDC->SelectPalette( theApp.m_pPalette, FALSE );
        pDC->RealizePalette();

        pcPaletteOld2 = dc.SelectPalette( theApp.m_pPalette, FALSE );
        dc.RealizePalette();
        }

    CBrush* pOldBrush = NULL;

    COLORREF rgb = crLeft;

    if (pImgCur->m_pBitmapObj->m_nColors == 0)
        {
        BOOL MonoRect(CDC* pDC, const CRect& rect, COLORREF rgb, BOOL bFrame);
        MonoRect(&dc, CRect(0, 0, 9, 9), rgb, FALSE);
        }
    else
        {
        brush.CreateSolidBrush(rgb);
        pOldBrush = dc.SelectObject(&brush);
        dc.PatBlt(0, 0, 8, 8, PATCOPY);
        dc.SelectObject(pOldBrush);
        brush.DeleteObject();
        }


    // Draw a black grid...
    for (int i = 0; i < 9; i++)
        {
        pDC->PatBlt(optionsRect.left + 2 + i * 7, optionsRect.top + 3,
            1, 8 * 7 + 1, BLACKNESS);
        pDC->PatBlt(optionsRect.left + 2, optionsRect.top + 3 + i * 7,
            8 * 7 + 1, 1, BLACKNESS);
        }


    // Fill in the boxes...
    COLORREF curColor = (COLORREF)0xffffffff;

    for (int y = 0; y < 8; y++)
        {
        for (int x = 0; x < 8; x++)
            {
            COLORREF color = dc.GetPixel(x, y) | 0x02000000L;

            if (color != curColor)
                {
                if (pOldBrush != NULL)
                    pDC->SelectObject(pOldBrush);

                brush.DeleteObject();
                brush.CreateSolidBrush(color);

                pOldBrush = pDC->SelectObject(&brush);
                curColor = color;
                }

            pDC->PatBlt(optionsRect.left + 2 + 1 + x * 7,
                        optionsRect.top  + 3 + 1 + y * 7, 6, 6, PATCOPY);
            }
        }

    ASSERT(pOldBrush != NULL);
    pDC->SelectObject(pOldBrush);

    dc.SelectObject(pOldBitmap);

    if (pcPaletteOld)
        pDC->SelectPalette(pcPaletteOld, FALSE);

    if (pcPaletteOld2)
        dc.SelectPalette(pcPaletteOld2, FALSE);
    }

/***************************************************************************/

void CImgTool::ClickStdPattern(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    CImgTool::OnClickOptions(pWnd, optionsRect, clickPoint);
    }

/***************************************************************************/

void CImgTool::PaintStdBrushes(CDC* pDC, const CRect& paintRect,
                                         const CRect& optionsRect)
    {
    int cxBrush = optionsRect.Width() / 3;
    int cyBrush = optionsRect.Height() / 4;

    for (UINT nBrushShape = 0; nBrushShape < 4; nBrushShape++)
        {
        int x = 0;
        for (UINT nStrokeWidth = 8 - (nBrushShape == 0);
            (int)nStrokeWidth > 0; nStrokeWidth -= 3, x += cxBrush)
            {
            CRect rect;
            rect.left = optionsRect.left + x;
            rect.top = optionsRect.top + cyBrush * nBrushShape;
            rect.right = rect.left + cxBrush;
            rect.bottom = rect.top + cyBrush;
            rect.InflateRect(-3, -3);

            if ((paintRect & rect).IsRectEmpty())
                continue;

            BOOL bCur = (nStrokeWidth == m_nStrokeWidth
                       && nBrushShape == m_nStrokeShape);

            CBrush* pOldBrush = pDC->SelectObject(GetSysBrush(bCur ?
                                        COLOR_HIGHLIGHT : COLOR_BTNFACE));
            if ((nStrokeWidth & 1) != 0)
                {
                // Adjust hilight rect so brush will be centered
                rect.right -= 1;
                rect.bottom -= 1;
                }
            pDC->PatBlt(rect.left + 1, rect.top - 1,
                rect.Width() - 2, rect.Height() + 2, PATCOPY);
            pDC->SelectObject(pOldBrush);

            CPoint pt(optionsRect.left + (cxBrush - nStrokeWidth) / 2 + x,
                      optionsRect.top +
                      (cyBrush - nStrokeWidth) / 2 + nBrushShape * cyBrush);

            pOldBrush = pDC->SelectObject(GetSysBrush(bCur ?
                                      COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
            BrushLine(pDC, pt, pt, nStrokeWidth, nBrushShape);
            pDC->SelectObject(pOldBrush);
            }
        }
    }

/***************************************************************************/

void CImgTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    MessageBeep(0);
    }

/******************************************************************************/

void CImgTool::OnUpdateColors (CImgWnd* pImgWnd)
    {
    }

/******************************************************************************/

BOOL CImgTool::CanEndMultiptOperation(MTI* pmti )
    {
    return (! m_bMultPtOpInProgress);  // if not in progress (FALSE) => can end (TRUE)
    }

/******************************************************************************/

void CImgTool::EndMultiptOperation(BOOL bAbort)
    {
    m_bMultPtOpInProgress = FALSE;
    }

/******************************************************************************/

BOOL CImgTool::IsToolModal(void)
{
        return(IsDragging() || m_bMultPtOpInProgress || m_bToggleWithPrev);
}

/******************************************************************************/

BOOL CImgTool::IsUndoable()
    {
    if (m_bMultPtOpInProgress)
        {
        return FALSE;  // cannot undo in the middle of a multi-point operation.
        }
    else
        {
        return m_bIsUndoable;
        }
    }

/******************************************************************************/

void CImgTool::ClickStdBrushes(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    HideBrush();

    g_bCustomBrush = FALSE;
    m_nStrokeWidth = 2 + 3 * (2 - (clickPoint.x / (optionsRect.Width() / 3)));
    m_nStrokeShape = clickPoint.y / (optionsRect.Height() / 4);

    if (m_nStrokeShape == 0)
        m_nStrokeWidth -= 1;

    pWnd->InvalidateOptions(FALSE);
    }

/******************************************************************************/

UINT CImgTool::GetCursorID()
    {
    return m_nCursorID;
    }

/******************************************************************************/

CRect  CRubberTool::rcPrev;
// UINT       CRubberTool::m_nStrokeWidth;

CRubberTool::CRubberTool()
    {
    }

/******************************************************************************/

void CRubberTool::OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                           const CRect& optionsRect)
    {
    if (m_bFilled)
        {
        PaintStdPattern(pDC, paintRect, optionsRect);
        return;
        }

    #define nLineWidths 5

    int cyEach = (optionsRect.Height() - 4) / nLineWidths;

    for (int i = 0; i < nLineWidths; i++)
        {
        UINT cyHeight = i + 1;

        CBrush* pOldBrush;
        BOOL bCur = (cyHeight == GetStrokeWidth());

        pOldBrush = pDC->SelectObject( GetSysBrush(bCur ?
                                       COLOR_HIGHLIGHT : COLOR_BTNFACE));
        pDC->PatBlt(optionsRect.left + 2,
                    optionsRect.top  + 3 + i * cyEach,
                    optionsRect.Width() - 4, cyEach - 2, PATCOPY);
        pDC->SelectObject(pOldBrush);

        pOldBrush = pDC->SelectObject(GetSysBrush(bCur ?
                                      COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
        pDC->PatBlt(optionsRect.left + 6,
                    optionsRect.top + 2 + cyEach * i + (cyEach - cyHeight) / 2,
                    optionsRect.Width() - 12, cyHeight, PATCOPY);

        pDC->SelectObject(pOldBrush);
        }
    }

/******************************************************************************/

void CRubberTool::OnClickOptions( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                     const CPoint& clickPoint )
    {
    if (m_bFilled)
        {
        CImgTool::OnClickOptions( pWnd, optionsRect, clickPoint );
        return;
        }

    m_nStrokeWidth =  1 + clickPoint.y /
        ((optionsRect.Height() - 4) / nLineWidths);

    // fix for rounding errors
    if (m_nStrokeWidth > nLineWidths)
        {
        m_nStrokeWidth = nLineWidths;
        }

    pWnd->InvalidateOptions(FALSE);
    }

/******************************************************************************/

void CClosedFormTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                                const CRect& optionsRect )
    {

    // Option 0 is Outlined Shape (border and no fill)
    // Option 1 is Filled Shape with border
    // Option 2 is Filled Shape NO border

    #define NUM_CLOSED_FORM_OPTIONS 3 //number of options high

    //*DK* Select Palette into DC
    CBrush*   pOldBrush;
    CRect     cRectOptionSel; // selection rectangle
    CRect     cRectOption;    //rectangle
    int       cyEach = (optionsRect.Height() - 4) / NUM_CLOSED_FORM_OPTIONS; // max height of each option
    int       cyHeight = cyEach - cyEach/2;  //rectangle is 1/2 max height
    int       bCurrSelected = FALSE;
    BOOL      bFilled = CImgTool::GetCurrent()->IsFilled();
    BOOL      bBorder = CImgTool::GetCurrent()->HasBorder();
    int       i;

    for (i = 0; i < NUM_CLOSED_FORM_OPTIONS; i++)
        {
        // Setup the Rectangles for painting and for selection
        //Selection Rectangle
        cRectOptionSel.SetRect(optionsRect.left + 2,
                               optionsRect.top  + 3  + (i * cyEach),
                              (optionsRect.left + 2) + optionsRect.Width() - 4,
                              (optionsRect.top  + 3  + (i* cyEach)) + cyEach - 2);

        //Option Rectangle
        cRectOption.SetRect(optionsRect.left + 6,
                  optionsRect.top  + 2  + i * cyEach + (cyEach - cyHeight) / 2,
                 (optionsRect.left + 6) + optionsRect.Width() - 12,
                 (optionsRect.top  + 2  + i * cyEach + (cyEach - cyHeight) / 2)
                         + cyHeight);

        // Determine the Selection state for the current item.
        bCurrSelected = FALSE;

        switch (i)
            {
            case 0: //Outlined Shape (border, no fill)
                if (! bFilled && bBorder)
                    {
                    bCurrSelected = TRUE;
                    }
                break;

            case 1: // Filled Shape (border and fill)
                if ( (bFilled) && (bBorder) )
                    {
                    bCurrSelected = TRUE;
                    }
                break;
            case 2: // Filled Shape No Border (no border, fill)
                if (bFilled && ! bBorder)
                    {
                    bCurrSelected = TRUE;
                    }
                break;
            default:
                bCurrSelected = FALSE;
                break;
            }
        // Draw the selection State
        // If selected, use COLOR_HIGHLIGHT else use CMP_COLOR_LTGRAY
        pOldBrush = pDC->SelectObject( GetSysBrush( bCurrSelected ?
                                       COLOR_HIGHLIGHT : COLOR_BTNFACE ) );
        pDC->PatBlt( cRectOptionSel.left, cRectOptionSel.top,
                     cRectOptionSel.Width(),cRectOptionSel.Height(), PATCOPY );
        pDC->SelectObject(pOldBrush);


        CBrush* pborderBrush;
        CBrush* pfillBrush;

        pborderBrush = GetSysBrush(bCurrSelected ?
                                   COLOR_BTNHIGHLIGHT : COLOR_BTNTEXT);
        pfillBrush = GetSysBrush(COLOR_BTNSHADOW);

        // Draw the Option
        switch (i)
            {
            case 0: //Outlined Shape (no border, no fill)
                pDC->FrameRect(&cRectOption, pborderBrush);
                break;

            case 1: // Filled Shape (border and fill)
                // using fillrect then frame rect instead of rectangle, since
                // don't have getsyspen facility in this program.
                pDC->FillRect(&cRectOption, pfillBrush);
                pDC->FrameRect(&cRectOption, pborderBrush);
                break;

            case 2: // Filled Shape No Border (no border, fill)
                pDC->FillRect(&cRectOption, pfillBrush);
                break;

            default:
                break;
            }
        }
    }


/******************************************************************************/
// clickpoint is from top of optionsrect (i.e. clickpoint if from 0 to optionsrect.height()
// and thus clickpoint is always less than optionsrec.top

void CClosedFormTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                     const CPoint& clickPoint)
    {
    int  cyEach = (optionsRect.Height() - 4) / NUM_CLOSED_FORM_OPTIONS; // max height of each option
//  BOOL bCurrSelected = FALSE;
    int       i;

    for (i = 0; i < NUM_CLOSED_FORM_OPTIONS; i++)
        {
        if ( clickPoint.y <  3 + ((i+1) * cyEach) )
            {
//          bCurrSelected = TRUE;

            switch (i)
                {
                default: // default is same as initial
                case 0: //Outlined Shape (border, no fill)
                    m_bFilled = FALSE;
                    m_bBorder = TRUE;
                    break;

                case 1: // Filled Shape (border and fill)
                    m_bFilled = TRUE;
                    m_bBorder = TRUE;
                    break;

                case 2: // Filled Shape No Border (no border, fill)
                    m_bFilled = TRUE;
                    m_bBorder = FALSE;
                    break;
                }

            break;   // point found, break out of loop test
            }
        }

    pWnd->InvalidateOptions(FALSE);
    }

/******************************************************************************/

void CRubberTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);

    SetupRubber(pImgWnd->m_pImg);
    OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CRubberTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    OnDrag(pImgWnd, pmti);


    CRect rc(pmti->ptDown.x, pmti->ptDown.y, pmti->pt.x, pmti->pt.y);

    Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), rc, pmti->fLeft, TRUE, pmti->fCtrlDown);
    InvalImgRect(pImgWnd->m_pImg, &rc);
    CommitImgRect(pImgWnd->m_pImg, &rc);
    pImgWnd->FinishUndo(rc);

    ClearStatusBarSize();

    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CRubberTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    HPALETTE hpalOld = NULL;

    if (theApp.m_pPalette &&  theApp.m_pPalette->m_hObject)
        {
        hpalOld = SelectPalette( hRubberDC,
                       (HPALETTE)theApp.m_pPalette->m_hObject, FALSE ); // Background ??
        RealizePalette( hRubberDC );
        }

    BitBlt(pImgWnd->m_pImg->hDC, rcPrev.left   , rcPrev.top,
                                 rcPrev.Width(), rcPrev.Height(),
                      hRubberDC, rcPrev.left   , rcPrev.top, SRCCOPY);

    if (hpalOld != NULL)
        SelectPalette( hRubberDC, hpalOld, FALSE ); // Background ??

    InvalImgRect(pImgWnd->m_pImg, &rcPrev);

    PreProcessPoints(pmti);

    CRect rc(pmti->ptDown.x, pmti->ptDown.y, pmti->pt.x, pmti->pt.y);

    Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), rc, pmti->fLeft, FALSE, pmti->fCtrlDown);
    InvalImgRect(pImgWnd->m_pImg, &rc);
    rcPrev = rc;

    if (m_nCmdID != IDMB_POLYGONTOOL)
        {
        CSize size( pmti->pt - pmti->ptDown );

        if (size.cx < 0)
            size.cx -= 1;
        else
            size.cx += 1;
        if (size.cy < 0)
            size.cy -= 1;
        else
            size.cy += 1;

        SetStatusBarPosition( pmti->ptDown );
        SetStatusBarSize    ( size );
        }
    }

/******************************************************************************/

void CRubberTool::AdjustPointsForConstraint(MTI *pmti)
    {
    if (pmti != NULL)
        {
        int iWidthHeight = min( abs(pmti->ptDown.x - pmti->pt.x),
                                abs(pmti->ptDown.y - pmti->pt.y));
        // Set the x value
        if (pmti->pt.x < pmti->ptDown.x)
            {
            pmti->pt.x = pmti->ptDown.x - iWidthHeight;
            }
        else
            {
            pmti->pt.x = pmti->ptDown.x + iWidthHeight;
            }

        // Set the y value
        if (pmti->pt.y < pmti->ptDown.y)
            {
            pmti->pt.y = pmti->ptDown.y - iWidthHeight;
            }
        else
            {
            pmti->pt.y = pmti->ptDown.y + iWidthHeight;
            }

        }
    }

/******************************************************************************/

void CRubberTool::Render( CDC* pDC, CRect& rect, BOOL bLeft, BOOL bCommit, BOOL bCtrlDown )
    {
    int    sx;
    int    sy;
    int    ex;
    int    ey;
    HBRUSH hBr     = NULL;
    HPEN   hPen    = NULL;
    HPEN   hOldPen = NULL;
    HBRUSH hOldBr  = NULL;
    CPoint pt1;
    CPoint pt2;
    HDC    hDC = pDC->m_hDC;

    enum SHAPE { rectangle, roundRect, ellipse } shape;

    switch (m_nCmdID)
        {
        default:
            ASSERT(FALSE);

        case IDMB_RECTTOOL:
            shape = rectangle;
            break;

        case IDMB_FRECTTOOL:
            shape = rectangle;
            break;

        case IDMB_RNDRECTTOOL:
            shape = roundRect;
            break;

        case IDMB_FRNDRECTTOOL:
            shape = roundRect;
            break;

        case IDMB_ELLIPSETOOL:
            shape = ellipse;
            break;

        case IDMB_FELLIPSETOOL:
            shape = ellipse;
            break;
        }

    FixRect(&rect);

    pt1.x = rect.left;
    pt1.y = rect.top;
    pt2.x = rect.right;
    pt2.y = rect.bottom;

    StandardiseCoords(&pt1, &pt2);

    sx = pt1.x;
    sy = pt1.y;
    ex = pt2.x;
    ey = pt2.y;

    SetupPenBrush(hDC, bLeft, TRUE, bCtrlDown);

    CRect rc(sx, sy, ex, ey);

    switch (shape)
        {
        case rectangle:
            Rectangle(hDC, sx, sy, ex, ey);
            break;

        case roundRect:
            RoundRect(hDC, sx, sy, ex, ey, 16, 16);
// The below draws an RoundRect with a mask first then bitblt
//          MyRoundRect(hDC, sx, sy, ex, ey, 16, 16, m_bFilled);
//          // if border and fill, draw border after fill
//          if ( (m_bBorder) && (m_bFilled) )
//          {
//              MyRoundRect(hDC, sx, sy, ex, ey, 16, 16, !m_bFilled);
//          }
            break;

        case ellipse:
            Ellipse(hDC, sx, sy, ex, ey);
// The below draws an Elipse with a mask first then bitblt
//          Mylipse(hDC, sx, sy, ex, ey, m_bFilled);
//          // if border and fill, draw border after fill
//          if ( (m_bBorder) && (m_bFilled) )
//          {
//              Mylipse(hDC, sx, sy, ex, ey, !m_bFilled);
//          }
            break;
        }

    SetupPenBrush(hDC, bLeft, FALSE, bCtrlDown);
    }


void CRubberTool::OnActivate( BOOL bActivate )
    {
        if (bActivate)
        {
                m_nStrokeWidth = g_nStrokeWidth;
        }
        else
        {
                g_nStrokeWidth = m_nStrokeWidth;
        }

    CImgTool::OnActivate( bActivate );
    }


/******************************************************************************/
/*bSetup is true to setup, False to Cleanup                                   */

BOOL CImgTool::SetupPenBrush(HDC hDC, BOOL bLeft, BOOL bSetup, BOOL bCtrlDown)
    {

    COLORREF colorBorder;
    COLORREF colorFill;

    if (bCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       if (HasBorder ())
       {
          colorBorder = bLeft ? crTrans : crRight;
          colorFill   = bLeft ? crRight : crTrans;
       }
       else
       {
          colorBorder = bLeft ? crRight : crTrans;
          colorFill   = bLeft ? crTrans : crRight;
       }

    }
    else
    {
       if (HasBorder())
       {
          colorBorder = bLeft ? crLeft : crRight;
          colorFill   = bLeft ? crRight: crLeft;
       }
       else
       {
          colorBorder = bLeft ? crRight : crLeft;
          colorFill   = bLeft ? crLeft: crRight;
       }

    }

    static HBRUSH hBr             = NULL;
    static HPEN   hPen            = NULL;
    static HPEN   hOldPen         = NULL;
    static HBRUSH hOldBr          = NULL;
    static BOOL   bCurrentlySetup = FALSE;
    BOOL bRC = TRUE;

    if (bSetup)
        {
        if (! bCurrentlySetup)
            {
            bCurrentlySetup = TRUE;
            // select null objects into DC.  Depending on drawing mode,
            // either or both will be re-selected in to override
            hPen    = NULL;
            hBr     = NULL;
            hOldPen =   (HPEN)SelectObject( hDC, GetStockObject( NULL_PEN ) );
            hOldBr  = (HBRUSH)SelectObject( hDC, GetStockObject( NULL_BRUSH ) );

            if (m_bFilled)
                {
                hBr = CreateSolidBrush( colorFill );
                SelectObject( hDC, hBr );
                }

            if (m_bBorder)
                {
                hPen = CreatePen( PS_INSIDEFRAME, m_nStrokeWidth, colorBorder );
                SelectObject(hDC, hPen);
                }
            else
                {
                //simulate no border by drawing the border the same as the fill.
                // since GDI does not draw small elipses, roundrects correctly
                // with NULL brush for no border.
                // Note the width is 2 so we will dither correctly
                hPen = CreatePen(PS_INSIDEFRAME, 2, colorFill);
                SelectObject(hDC, hPen);
                }
            }
        else
            {
            // Error: Will lose allocated Brush/Pen
            bRC = FALSE;
            }
        }
    else
        {
        if (bCurrentlySetup)
            {
            bCurrentlySetup = FALSE;

            SelectObject(hDC, hOldPen);

            if (hPen != NULL)
                {
                DeleteObject(hPen);
                }

            SelectObject(hDC, hOldBr);

            if (hBr != NULL)
                {
                DeleteObject( hBr );
                }
            }
        else
            {
            // Error: Cannot Free/cleanup Brush/Pen -- Never allocated.
            bRC = FALSE;
            }
        }

    return bRC;
    }

#if 0 // unused code
/******************************************************************************/
/*bSetup is true to setup, False to Cleanup                                   */

BOOL CRubberTool::SetupMaskPenBrush(HDC hDC, BOOL bLeft, BOOL bSetup)
    {
    BOOL bRC = TRUE;

    static HBRUSH hBr = NULL;
    static HPEN hPen = NULL;
    static HPEN hOldPen = NULL;
    static HBRUSH hOldBr = NULL;
    static BOOL bCurrentlySetup = FALSE;

    if (bSetup)
        {
        if (bCurrentlySetup)
            {
            // Error: Will lose allocated Brush/Pen
            bRC = FALSE;
            }
        else
            {
            bCurrentlySetup = TRUE;
            // draw the shape on the mask:
            // select null objects into DC.  Depending on drawing mode,
            // either or both will be re-selected in to override
            hPen = NULL;
            hBr  = NULL;
            hOldPen = (HPEN)SelectObject(hDC, GetStockObject(NULL_PEN));
            hOldBr  = (HBRUSH)SelectObject(hDC, GetStockObject(NULL_BRUSH));


            if (m_bFilled)
                {
                SelectObject(hDC, GetStockObject( BLACK_BRUSH ));
                }
            if (m_bBorder)
                {
                hPen = CreatePen(PS_INSIDEFRAME, m_nStrokeWidth, (COLORREF)0L );
                SelectObject(hDC, hPen);
                }
            }
        }
    else
        {
        if (bCurrentlySetup)
            {
            bCurrentlySetup = FALSE;

            SelectObject(hDC, hOldPen);
            if (hPen != NULL)
                {
                DeleteObject(hPen);
                }

            SelectObject(hDC, hOldBr);
            if (hBr != NULL)
                {
                DeleteObject(hBr);
                }
            }
        else
            {
            // Error: Cannot Free/cleanup Brush/Pen -- Never allocated.
            bRC = FALSE;
            }
        }

    return bRC;
    }
  #endif // unused code
/******************************************************************************/

CRect  CFreehandTool::c_undoRect;

/***************************************************************************/

CFreehandTool::CFreehandTool()
    {
    m_bUsesBrush = TRUE;
    }

/******************************************************************************/

void CFreehandTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);

    c_undoRect.TopLeft() = c_undoRect.BottomRight() = pmti->pt;
    OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CFreehandTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    if (g_bCustomBrush)
        {
        c_undoRect.left   -= theImgBrush.m_size.cx + theImgBrush.m_handle.cx;
        c_undoRect.top    -= theImgBrush.m_size.cy + theImgBrush.m_handle.cy;
        c_undoRect.right  += theImgBrush.m_size.cx - theImgBrush.m_handle.cx;
        c_undoRect.bottom += theImgBrush.m_size.cy - theImgBrush.m_handle.cy;
        }
    else
        {
        // HACK: +1s are to cover bug in slanted line brushes
        c_undoRect.left   -=  m_nStrokeWidth / 2 + 1;
        c_undoRect.top    -=  m_nStrokeWidth / 2 + 1;
        c_undoRect.right  += (m_nStrokeWidth + 1) / 2 + 1;
        c_undoRect.bottom += (m_nStrokeWidth + 1) / 2 + 1;
        }

    pImgWnd->FinishUndo(c_undoRect);

    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/******************************************************************************/

CSketchTool::CSketchTool()
    {
    m_nCursorID      = IDC_BRUSH;
    m_nCmdID         = IDMZ_BRUSHTOOL;
    m_bCanBePrevTool = FALSE;
    }

/******************************************************************************/

void CSketchTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    fDraggingBrush = FALSE;

    DrawBrush( pImgWnd->m_pImg, pmti->pt, pmti->fLeft );

    if (pmti->pt.x < c_undoRect.left)
        c_undoRect.left = pmti->pt.x;
    else
        if (pmti->pt.x > c_undoRect.right)
            c_undoRect.right = pmti->pt.x;

    if (pmti->pt.y < c_undoRect.top)
        c_undoRect.top = pmti->pt.y;
    else
        if (pmti->pt.y > c_undoRect.bottom)
            c_undoRect.bottom = pmti->pt.y;

    SetStatusBarPosition( pmti->pt );
    }

/******************************************************************************/

void CSketchTool::OnCancel(CImgWnd* pImgWnd)
    {
    HideBrush();
    g_bCustomBrush = FALSE;
    SelectPrevious();
    CImgTool::OnCancel( pImgWnd );
    }

/******************************************************************************/

CBrushTool::CBrushTool()
    {
    m_nCursorID    = IDC_BRUSH;
    m_nCmdID       = IDMB_CBRUSHTOOL;
    m_nStrokeWidth = 4;
    }

/***************************************************************************/

void CBrushTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                           const CRect& optionsRect )
    {
    PaintStdBrushes(pDC, paintRect, optionsRect);
    }

/***************************************************************************/

void CBrushTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    ClickStdBrushes(pWnd, optionsRect, clickPoint);
    }

/***************************************************************************/

void CBrushTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    g_bCustomBrush = FALSE;

    CPoint pt1, pt2;

    fDraggingBrush = FALSE;

    pt1 = pmti->ptPrev;
    pt2 = pmti->pt;

    // use transparent color if defined
    if (pmti->fCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       DrawImgLine( pImgWnd->m_pImg, pt1, pt2, crTrans,
                    m_nStrokeWidth, m_nStrokeShape, TRUE);
    }
    else
    {
       DrawImgLine( pImgWnd->m_pImg, pt1, pt2,
                 pmti->fLeft ? crLeft : crRight,
                 m_nStrokeWidth, m_nStrokeShape, TRUE);

    }

    if (pmti->pt.x < c_undoRect.left)
        c_undoRect.left = pmti->pt.x;
    else if (pmti->pt.x > c_undoRect.right)
        c_undoRect.right = pmti->pt.x;
    if (pmti->pt.y < c_undoRect.top)
        c_undoRect.top = pmti->pt.y;
    else if (pmti->pt.y > c_undoRect.bottom)
        c_undoRect.bottom = pmti->pt.y;

    SetStatusBarPosition(pmti->pt);
    }

/***************************************************************************/

void CBrushTool::OnMove(CImgWnd* pImgWnd, MTI* pmti)
    {
    g_bCustomBrush = FALSE;
    CImgTool::OnMove(pImgWnd, pmti);
    }

/***************************************************************************/

CPencilTool::CPencilTool()
    {
    m_nCursorID    = IDC_PENCIL;
    m_nCmdID       = IDMB_PENCILTOOL;
    m_bUsesBrush   = FALSE;
    m_nStrokeWidth = 1;
    }

/***************************************************************************/

void CPencilTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CFreehandTool::OnStartDrag(pImgWnd, pmti);
    m_eDrawDirection = eFREEHAND; // initialize to not have a direction

    }

/***************************************************************************/

void CPencilTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    g_bCustomBrush = FALSE;
    fDraggingBrush = FALSE;


    PreProcessPoints(pmti);

    // use transparent color if defined
    if (pmti->fCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       DrawImgLine (pImgWnd->m_pImg, pmti->ptPrev, pmti->pt,
                    crTrans, m_nStrokeWidth, m_nStrokeShape, TRUE);
    }
    else
    {
       DrawImgLine(pImgWnd->m_pImg, pmti->ptPrev, pmti->pt,
                                 pmti->fLeft ? crLeft : crRight,
                          m_nStrokeWidth, m_nStrokeShape, TRUE);
    }

    if (pmti->pt.x < c_undoRect.left)
        c_undoRect.left = pmti->pt.x;
    else if (pmti->pt.x > c_undoRect.right)
        c_undoRect.right = pmti->pt.x;
    if (pmti->pt.y < c_undoRect.top)
        c_undoRect.top = pmti->pt.y;
    else if (pmti->pt.y > c_undoRect.bottom)
        c_undoRect.bottom = pmti->pt.y;

    SetStatusBarPosition(pmti->pt);
    }

/***************************************************************************/

void CPencilTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    c_undoRect.right += 1;
    c_undoRect.bottom += 1;
    pImgWnd->FinishUndo(c_undoRect);

    CImgTool::OnEndDrag(pImgWnd, pmti); // Bypass CFreehandTool
    }

/******************************************************************************/

void CPencilTool::AdjustPointsForConstraint(MTI *pmti)
    {
    eDRAWCONSTRAINTDIRECTION eDrawDirection = DetermineDrawDirection(pmti);
    int iWidthHeight = min( abs(pmti->ptPrev.x - pmti->pt.x),
                            abs(pmti->ptPrev.y - pmti->pt.y));


    switch (m_eDrawDirection)
        {
        case eEAST_WEST:
             pmti->pt.y = pmti->ptPrev.y;
             break;
        case eNORTH_SOUTH:
             pmti->pt.x = pmti->ptPrev.x;
             break;

        case eNORTH_WEST:
        case eSOUTH_EAST:
             // Set the SE movement
             if ( (pmti->pt.x > pmti->ptPrev.x) ||
                  (pmti->pt.y > pmti->ptPrev.y)    )
                 {
                 pmti->pt.x = pmti->ptPrev.x + iWidthHeight;
                 pmti->pt.y = pmti->ptPrev.y + iWidthHeight;
                 }
             else
                 {
                 // Set the NW movement
                 if ( (pmti->pt.x < pmti->ptPrev.x) ||
                      (pmti->pt.y < pmti->ptPrev.y)    )
                     {
                     pmti->pt.x = pmti->ptPrev.x - iWidthHeight;
                     pmti->pt.y = pmti->ptPrev.y - iWidthHeight;
                     }
                 else
                    {
                    //invalid movement, set to last known position
                    pmti->pt.x = pmti->ptPrev.x;
                    pmti->pt.y = pmti->ptPrev.y;
                    }
                 }
             break;

        case eNORTH_EAST:
        case eSOUTH_WEST:
             // Set the NE movement
             if ( (pmti->pt.x > pmti->ptPrev.x) ||
                  (pmti->pt.y < pmti->ptPrev.y)    )
                 {
                 pmti->pt.x = pmti->ptPrev.x + iWidthHeight;
                 pmti->pt.y = pmti->ptPrev.y - iWidthHeight;
                 }
             else
                 {
                 // Set the SW movement
                 if ( (pmti->pt.x < pmti->ptPrev.x) ||
                      (pmti->pt.y > pmti->ptPrev.y)    )
                     {
                     pmti->pt.x = pmti->ptPrev.x - iWidthHeight;
                     pmti->pt.y = pmti->ptPrev.y + iWidthHeight;
                     }
                 else
                    {
                    //invalid movement, set to last known position
                    pmti->pt.x = pmti->ptPrev.x;
                    pmti->pt.y = pmti->ptPrev.y;
                    }
                 }
             break;


        default: // not in constraint mode yet => do nothing.
                 // Default is freehand
            break;
        }
    }

/***************************************************************************/

CEraserTool::CEraserTool()
    {
    m_nCmdID       = IDMB_ERASERTOOL;
    m_nStrokeWidth = 8;
    m_nStrokeShape = squareBrush;
    m_nCursorID    = NULL;
    }

/***************************************************************************/

void CEraserTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                            const CRect& optionsRect )
    {
    CRect rect;
    int cxOctant = (optionsRect.Width() + 1);
    int cyOctant = (optionsRect.Height() + 1) / 4;

    rect.left = optionsRect.left;
    rect.top = optionsRect.top;
    rect.right = rect.left + cxOctant;
    rect.bottom = rect.top + cyOctant;

    for (UINT nSize = 4; nSize <= 10; nSize += 2)
        {
        CBrush* pOldBrush;

        if (nSize == m_nStrokeWidth)
            {
            pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
            pDC->PatBlt(rect.left + (cxOctant - 14) / 2,
                rect.top + (cyOctant - 14) / 2, 14, 14, PATCOPY);
            pDC->SelectObject(pOldBrush);
            }

        pOldBrush = pDC->SelectObject(GetSysBrush(nSize == m_nStrokeWidth ?
            COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
        pDC->PatBlt(rect.left + (cxOctant - nSize) / 2,
            rect.top + (cyOctant - nSize) / 2, nSize, nSize, PATCOPY);
        pDC->SelectObject(pOldBrush);

        rect.top += cyOctant;
        rect.bottom += cyOctant;
        }
    }

/***************************************************************************/

void CEraserTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    int iOptionNumber;
    int cyOctant = (optionsRect.Height() + 1) / 4;
    iOptionNumber = (clickPoint.y / cyOctant);
    if (iOptionNumber > 3)  // there are 4 options, numbered 0,1,2,3
        {
        iOptionNumber = 3;
        }

    m_nStrokeWidth = 4 + 2 * iOptionNumber;

//    int cyOctant = (optionsRect.Height() + 1) / 4;
//    m_nStrokeWidth = 4 + 2 * (clickPoint.y / cyOctant);
    pWnd->InvalidateOptions();
    }


void CEraserTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    if (pmti->fLeft)
        {
        COLORREF crRealLeftColor = crLeft;
        COLORREF crRealRightColor = crRight;

        crLeft = crRight;

        g_bCustomBrush = FALSE;
        fDraggingBrush = FALSE;

        DrawImgLine(pImgWnd->m_pImg, pmti->ptPrev, pmti->pt, crRight,
                                  m_nStrokeWidth, squareBrush, TRUE);

        crLeft  = crRealLeftColor;
        crRight = crRealRightColor;
        }
    else
        {
        // Just erase pixels that match the drawing color...

        g_bCustomBrush = FALSE;
        fDraggingBrush = FALSE;

        HideBrush();

        CDC* pImageDC = CDC::FromHandle(pImgWnd->m_pImg->hDC);

        CRect rc;

        // Call with NULL DC to get the CRect to use
        DrawDCLine(NULL, pmti->ptPrev, pmti->pt, RGB(255, 255, 255),
            m_nStrokeWidth, squareBrush, rc);

        CTempBitmap monoBitmap;
        CDC monoDc;

         // Create the mono DC and bitmap
        if (!monoDc.CreateCompatibleDC(NULL) ||
            !monoBitmap.CreateBitmap(rc.Width(), rc.Height(), 1, 1, NULL))
            {
            theApp.SetGdiEmergency();
            return;
            }

        // Select the bitmap and change the window origin so the mono DC has
        // the same coordinate system as the image
        CBitmap* pOldMonoBitmap = monoDc.SelectObject(&monoBitmap);
        monoDc.SetWindowOrg(rc.left, rc.top);

        // Clear the mono DC and then draw the area that will be changed
        monoDc.PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), BLACKNESS);
        DrawDCLine(monoDc.m_hDC, pmti->ptPrev, pmti->pt, RGB(255, 255, 255),
            m_nStrokeWidth, squareBrush, rc);
        DebugShowBitmap(monoDc.m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

        // Select the proper palette, and make sure the brush origin is set
        // correctly for pattern brushes
        CPalette* pcPaletteOld = theImgBrush.SetBrushPalette(pImageDC, FALSE);
        pImageDC->SetBrushOrg(0, 0);

        CBrush rightBrush;
        rightBrush.CreateSolidBrush(crRight);

        if (!QuickColorToMono(&monoDc, rc.left, rc.top, rc.Width(), rc.Height(),
            pImageDC, rc.left, rc.top, SRCAND, crLeft))
        {
            // We will get her for DDB's (in which case we could be using a
            // dithered brush) or for high color images (so no palette problems)

            // Create the brush to erase
            CBrush leftBrush;
            leftBrush.CreateSolidBrush(crLeft);
            leftBrush.UnrealizeObject();

//#define DPSxna  0x00820c49L
// #define PSDPxax 0x00B8074AL

            // XOR with the pattern so black is where the pattern was
            CBrush* pOldBrush = pImageDC->SelectObject(&leftBrush);
            pImageDC->PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATINVERT);
            DebugShowBitmap(pImageDC->m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

            // Color to mono bitblt to get the final mask
            // The ROP will take all pixels in the source that match the pattern
            // and and them with the white pixels in the dest
            theImgBrush.ColorToMonoBitBlt(&monoDc, rc.left, rc.top, rc.Width(), rc.Height(),
                pImageDC, rc.left, rc.top, SRCAND, RGB(0, 0, 0));
            DebugShowBitmap(monoDc.m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

            // XOR again to put the original back
            pImageDC->PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATINVERT);
            DebugShowBitmap(pImageDC->m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

            pImageDC->SelectObject(pOldBrush);
        }

        // Copy the pattern back into the image where the bitmap has white
        CBrush *pOldBrush = pImageDC->SelectObject(&rightBrush);

        COLORREF crNewBk, crNewText;
        GetMonoBltColors(pImageDC->m_hDC, NULL, crNewBk, crNewText);
        COLORREF crOldBk = pImageDC->SetBkColor(crNewBk);
        COLORREF crOldText = pImageDC->SetTextColor(crNewText);
        pImageDC->BitBlt(rc.left, rc.top, rc.Width(), rc.Height(),
            &monoDc, rc.left, rc.top, DSPDxax);
        pImageDC->SetBkColor(crOldBk);
        pImageDC->SetTextColor(crOldText);
        DebugShowBitmap(pImageDC->m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

        // Clean up stuff we have selected
        pImageDC->SelectObject(pOldBrush);

        monoDc.SelectObject(pOldMonoBitmap);

        if (pcPaletteOld)
            pImageDC->SelectPalette(pcPaletteOld, FALSE);

        InvalImgRect(pImgWnd->m_pImg, &rc);
        CommitImgRect(pImgWnd->m_pImg, &rc);
        }

    if (pmti->pt.x < c_undoRect.left)
        c_undoRect.left = pmti->pt.x;
    else if (pmti->pt.x > c_undoRect.right)
        c_undoRect.right = pmti->pt.x;
    if (pmti->pt.y < c_undoRect.top)
        c_undoRect.top = pmti->pt.y;
    else if (pmti->pt.y > c_undoRect.bottom)
        c_undoRect.bottom = pmti->pt.y;

    SetStatusBarPosition(pmti->pt);

    fDraggingBrush = TRUE;

    pImgWnd->ShowBrush(pmti->pt);
    }

/***************************************************************************/

void CEraserTool::OnMove(CImgWnd* pImgWnd, MTI* pmti)
    {
    COLORREF crRealLeftColor;
    COLORREF crRealRightColor;

    crRealLeftColor  = crLeft;
    crRealRightColor = crRight;

    crLeft = crRight;

    g_bCustomBrush = FALSE;

    CImgTool::OnMove(pImgWnd, pmti);

    crLeft  = crRealLeftColor;
    crRight = crRealRightColor;
    }

/***************************************************************************/

void CEraserTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    c_undoRect.left   -=  m_nStrokeWidth / 2;
    c_undoRect.top    -=  m_nStrokeWidth / 2;
    c_undoRect.right  += (m_nStrokeWidth + 1) / 2;
    c_undoRect.bottom += (m_nStrokeWidth + 1) / 2;
    pImgWnd->FinishUndo(c_undoRect);

    CImgTool::OnEndDrag(pImgWnd, pmti); // Bypass CFreehandTool
    }

/***************************************************************************/

void CEraserTool::OnShowDragger(CImgWnd* pImgWnd, BOOL bShow)
    {
    if (bShow && g_bBrushVisible)
        {
        CClientDC dc(pImgWnd);

        CRect imageRect;
        pImgWnd->GetImageRect(imageRect);
        dc.IntersectClipRect(&imageRect);

        BOOL bGrid = pImgWnd->IsGridVisible();

        CRect rect = rcDragBrush;
        pImgWnd->ImageToClient(rect);
        dc.PatBlt(rect.left, rect.top,
            rect.Width() + bGrid, 1, BLACKNESS);
        dc.PatBlt(rect.left, rect.top + 1,
            1, rect.Height() - 2 + bGrid, BLACKNESS);
        dc.PatBlt(rect.right - 1 + bGrid, rect.top + 1,
            1, rect.Height() - 2 + bGrid, BLACKNESS);
        dc.PatBlt(rect.left, rect.bottom - 1 + bGrid,
            rect.Width() + bGrid, 1, BLACKNESS);
        }
    }

/***************************************************************************/

UINT CEraserTool::GetCursorID()
    {
    CPoint point;
    GetCursorPos(&point);

    CRect rc;

    CPBView* pcbView = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();
    CImgWnd* pImgWnd = pcbView->m_pImgWnd;

    pImgWnd->ScreenToClient(&point);
    pImgWnd->GetClientRect(&rc);
    if (!rc.PtInRect(point))
    {
        // Return crosshair outside the client rect of the image window
        return LOWORD(IDC_CROSSHAIR);
    }

    pImgWnd->ClientToImage(point);
    if (point.x > pImgWnd->m_pImg->cxWidth ||
        point.y > pImgWnd->m_pImg->cyHeight)
    {
        // Return crosshair outside the drawing area
        return LOWORD(IDC_CROSSHAIR);
    }

    return m_nCursorID;
    }

/***************************************************************************/

CImageWell  CAirBrushTool::c_imageWell(IDB_AIROPT, CSize(24, 24));

CAirBrushTool::CAirBrushTool()
    {
    m_nCmdID       = IDMB_AIRBSHTOOL;
    m_nStrokeWidth = 8;
    m_nCursorID    = IDCUR_AIRBRUSH;
    m_bUsesBrush   = FALSE;
    m_bFilled      = TRUE;
    }

/***************************************************************************/

void CAirBrushTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                              const CRect& optionsRect )
    {
    CPoint pt(optionsRect.left + (optionsRect.Width() / 2 - 24) / 2,
        optionsRect.top + (optionsRect.Height() / 2 - 24) / 2);

    c_imageWell.Open();

    pDC->SetTextColor(GetSysColor(
        m_nStrokeWidth == 8 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        m_nStrokeWidth == 8 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 0, SRCCOPY);
    pt.x += optionsRect.Width() / 2;

    pDC->SetTextColor(GetSysColor(
        m_nStrokeWidth == 16 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        m_nStrokeWidth == 16 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 1, SRCCOPY);
    pt.x = optionsRect.left + (optionsRect.Width() - 24) / 2;

    pDC->SetTextColor(GetSysColor(
        m_nStrokeWidth == 24 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        m_nStrokeWidth == 24 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    pt.y += optionsRect.Height() / 2;
    c_imageWell.DrawImage(pDC, pt, 2, SRCCOPY);

    c_imageWell.Close();
    }

/***************************************************************************/

void CAirBrushTool::OnClickOptions(CImgToolWnd* pWnd,
    const CRect& optionsRect, const CPoint& clickPoint)
    {
    UINT nNewStrokeWidth;

    if (clickPoint.y > optionsRect.Height() / 2)
        nNewStrokeWidth = 24;
    else if (clickPoint.x > optionsRect.Width() / 2)
        nNewStrokeWidth = 16;
    else
        nNewStrokeWidth = 8;

    if (nNewStrokeWidth != m_nStrokeWidth)
        SetStrokeWidth(nNewStrokeWidth);
    }

/***************************************************************************/

void CAirBrushTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    pImgWnd->SetTimer(1, 0, NULL); // FUTURE: rate should be adjustable
    CFreehandTool::OnStartDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CAirBrushTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CPoint pt;
    CRect rect;

    fDraggingBrush = FALSE;

    int nDiam = (m_nStrokeWidth + 1) & ~1; // nDiam must be even
    if (nDiam < 4)
        nDiam = 4;
    int nRadius = nDiam / 2;
    int nRadiusSquared = (nDiam / 2) * (nDiam / 2);

    // Start a bounding rect for changes made in the following loop
    rect.left = rect.right = pmti->pt.x;
    rect.top = rect.bottom = pmti->pt.y;

    m_bCtrlDown = pmti->fCtrlDown; // save it for the timer
    SetupPenBrush(pImgWnd->m_pImg->hDC, !pmti->fLeft, TRUE, m_bCtrlDown);

    for (int i = 0; i < 10; i++)
        {
        // Loop here until we randomly pick a point inside a circle
        // centered around the mouse with a diameter of m_nStrokeWidth...
#ifdef _DEBUG
        int nTrys = 0;
#endif
        do
            {
#ifdef _DEBUG
            if (nTrys++ > 10)
                {
                TRACE(TEXT("The airbrush is clogged!\n"));
                break;
                }
#endif
            pt = pmti->pt;
            pt.x += (rand() % (nDiam + 1)) - nRadius;
            pt.y += (rand() % (nDiam + 1)) - nRadius;
            }
        while (((pt.x - pmti->pt.x) * (pt.x - pmti->pt.x) +
                (pt.y - pmti->pt.y) * (pt.y - pmti->pt.y)) > nRadiusSquared);

        PatBlt(pImgWnd->m_pImg->hDC, pt.x, pt.y, 1, 1, PATCOPY);

        if (pt.x < rect.left)
            rect.left = pt.x;
        else if (pt.x + 1 > rect.right)
            rect.right = pt.x + 1;
        if (pt.y < rect.top)
            rect.top = pt.y;
        else if (pt.y + 1 > rect.bottom)
            rect.bottom = pt.y + 1;
        }

    SetupPenBrush(pImgWnd->m_pImg->hDC, !pmti->fLeft, FALSE, m_bCtrlDown);

    c_undoRect |= rect;

    InvalImgRect(pImgWnd->m_pImg, &rect);
    CommitImgRect(pImgWnd->m_pImg, &rect);

    SetStatusBarPosition(pmti->pt);
    }

/***************************************************************************/

void CAirBrushTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    ::KillTimer(pImgWnd->GetSafeHwnd(), 1);
    CFreehandTool::OnEndDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CAirBrushTool::OnTimer(CImgWnd* pImgWnd, MTI* pmti)
    {
       pmti->fCtrlDown = m_bCtrlDown;
    OnDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CAirBrushTool::OnCancel(CImgWnd* pImgWnd)
    {
    ::KillTimer(pImgWnd->GetSafeHwnd(), 1);
    CImgTool::OnCancel(pImgWnd);
    }

/***************************************************************************/

CLineTool::CLineTool()
    {
    m_bUsesBrush   = FALSE;
    m_nStrokeWidth = 1;
    m_nCmdID       = IDMB_LINETOOL;
    }

/***************************************************************************/

void CLineTool::Render(CDC* pDC, CRect& rect, BOOL bLeft, BOOL bCommit, BOOL bCtrlDown)
    {

    COLORREF color;

    // use transparent color if defined
    if (bCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       color = crTrans;
    }
    else
    {
       color = bLeft ? crLeft : crRight;
    }

    int sx = rect.left;
    int sy = rect.top;
    int ex = rect.right;
    int ey = rect.bottom;

    DrawImgLine( pImgCur, rect.TopLeft(), rect.BottomRight(), color,
                  m_nStrokeWidth, m_nStrokeShape, FALSE );
    CRect rc;
    if (sx < ex)
        {
        rc.left = sx;
        rc.right = ex + 1;
        }
    else
        {
        rc.left = ex;
        rc.right = sx + 1;
        }

    if (sy < ey)
        {
        rc.top = sy;
        rc.bottom = ey + 1;
        }
    else
        {
        rc.top = ey;
        rc.bottom = sy + 1;
        }

    rc.left   -= m_nStrokeWidth;
    rc.top    -= m_nStrokeWidth;
    rc.right  += m_nStrokeWidth;
    rc.bottom += m_nStrokeWidth;

    rect = rc;
    }

/******************************************************************************/
// Given an x and y coordinate, we can calculate the angle from the x axis in
// the right triangle using the Tan(a) algorithm.  Where
// tan(a) = opposite/adjacent or y/x.
//
// In order to constrain the line drawing, we need to determine the angle
// from the x axis and constrain it to the nearest 45 degree line (0 degree,
// 45 degree, 90 degree,....).
//
// Thus we can use the following rule :
//
//         0 Degrees <=   Angle   <     45/2 Degrees  Constrained to  0 Degrees
//      45/2 Degrees <=   Angle   <  45+45/2 Degrees  Constrained to 45 Degrees
//   45+45/2 Degrees <=   Angle   <       90 Degrees  Constrained to 90 Degrees
//
//
// We can translate this rule into the below using tan(angle) = y/x and the
// fact that Tan(0) = 0, Tan(22.5) = .414, tan(67.5) = 2.414, tan(90) = infinity
//
//         0 <=   y/x   <     .414   Constrained to  0 Degrees
//      .414 <=   y/x   <    2.414   Constrained to 45 Degrees
//     2.414 <=   y/x                Constrained to 90 Degrees
//
// For more precision, we will multiply everything by 1000 to give us finally
// the following table
//
//         0 <=   (1000*y)/x  <     414   Constrained to  0 Degrees
//       414 <=   (1000*y)/x  <    2414   Constrained to 45 Degrees
//      2414 <=   (1000*y)/x              Constrained to 90 Degrees

void CLineTool::AdjustPointsForConstraint(MTI *pmti)
    {
    if (pmti != NULL)
        {
        int iAngle = 0;

        long lcy = abs( (pmti->ptDown).y - (pmti->pt).y );
        long lcx = abs( (pmti->ptDown).x - (pmti->pt).x );
        long lResult;

        if (lcx != 0)
            {
            lResult = (lcy*1000)/lcx;
            }
        else
            {
            lResult = 2414; // default to 90 degrees if x value is 0.
            }

        if (lResult >= 2414)
            {
            iAngle = 90;
            }
        else
            {
            if (lResult >= 414)
                {
                iAngle = 45;
                }
            else
                {
                iAngle = 0;
                }
            }


//      int iWidthHeight = min( abs(pmti->ptDown.x - pmti->pt.x),
//                              abs(pmti->ptDown.y - pmti->pt.y));
        int iWidthHeight = ( abs(pmti->ptDown.x - pmti->pt.x) +
                             abs(pmti->ptDown.y - pmti->pt.y) ) / 2 ;

        switch (iAngle)
            {
            default: //if for some reason, angle is not valid case, use 0
            case 0:
                pmti->pt.y = pmti->ptDown.y;
                break;

            case 45:
                if (pmti->pt.x < pmti->ptDown.x)
                    {
                    pmti->pt.x = pmti->ptDown.x - iWidthHeight;
                    }
                else
                    {
                    pmti->pt.x = pmti->ptDown.x + iWidthHeight;
                    }

                if (pmti->pt.y < pmti->ptDown.y)
                    {
                    pmti->pt.y = pmti->ptDown.y - iWidthHeight;
                    }
                else
                    {
                    pmti->pt.y = pmti->ptDown.y + iWidthHeight;
                    }

                break;

            case 90:
                pmti->pt.x = pmti->ptDown.x;
                break;
            }
        }
    }

/***************************************************************************/

CRectTool::CRectTool()
    {
    m_nCmdID = IDMB_RECTTOOL;
    }

/***************************************************************************/

CRoundRectTool::CRoundRectTool()
    {
    m_nCmdID = IDMB_RNDRECTTOOL;
    }

/***************************************************************************/

CEllipseTool::CEllipseTool()
    {
    m_nCmdID = IDMB_ELLIPSETOOL;
    }

/***************************************************************************/

CPickColorTool::CPickColorTool()
    {
    m_bIsUndoable     = FALSE;
    m_bCanBePrevTool  = FALSE;
    m_bToggleWithPrev = TRUE;
    m_Color           = ::GetSysColor( COLOR_BTNFACE );
    m_nCursorID       = IDC_EYEDROP;
    m_nCmdID          = IDMY_PICKCOLOR;
    }

/***************************************************************************/

void CPickColorTool::OnActivate(BOOL bActivate)
    {
    g_bPickingColor = bActivate;

    m_Color = ::GetSysColor( COLOR_BTNFACE );

    CImgTool::OnActivate(bActivate);
    }

/***************************************************************************/

void CPickColorTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);
    OnDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CPickColorTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    COLORREF cr = GetPixel(pImgWnd->m_pImg->hDC, pmti->pt.x, pmti->pt.y);

    BYTE red   = GetRValue( cr );
    BYTE green = GetGValue( cr );
    BYTE blue  = GetBValue( cr );

    if (theApp.m_bPaletted)
        m_Color = PALETTERGB( red, green, blue );
    else
        m_Color =        RGB( red, green, blue );

    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) )
        g_pImgToolWnd->InvalidateOptions();
    }

/***************************************************************************/

void CPickColorTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    if (pmti->fCtrlDown) // pick transparent color
    {
       SetTransColor (m_Color);
    }
    else if (pmti->fLeft)
        SetDrawColor ( m_Color );
    else
        SetEraseColor( m_Color );

    m_Color = ::GetSysColor( COLOR_BTNFACE );

    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) )
        g_pImgToolWnd->InvalidateOptions();

    SelectPrevious();
    CImgTool::OnEndDrag( pImgWnd, pmti );
    }

/***************************************************************************/

void CPickColorTool::OnCancel(CImgWnd* pImgWnd)
    {
    SelectPrevious();
    CImgTool::OnCancel(pImgWnd);
    }

/***************************************************************************/

void CPickColorTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                               const CRect& optionsRect )
    {
    CPalette* pOldPal = NULL;

    if (theApp.m_pPalette)
        {
        pOldPal = pDC->SelectPalette( theApp.m_pPalette, FALSE );
        pDC->RealizePalette();
        }

    CBrush br;

    if (br.CreateSolidBrush( m_Color ))
        {
        pDC->FillRect( &paintRect, &br );

        br.DeleteObject();
        }

    if (pOldPal)
        pDC->SelectPalette( pOldPal, FALSE );
    }

/***************************************************************************/

CFloodTool::CFloodTool()
    {
    m_nCursorID = IDC_FLOOD;
    m_nCmdID    = IDMB_FILLTOOL;
    m_bFilled   = TRUE;
    }

/***************************************************************************/

void CFloodTool::OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect)
    {
//  PaintStdPattern(pDC, paintRect, optionsRect);
    }

/***************************************************************************/

void CFloodTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    CImgTool::OnClickOptions(pWnd, optionsRect, clickPoint);
    }

/***************************************************************************/

void CFloodTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag( pImgWnd, pmti );

    CPalette *pcPaletteOld = NULL;


    IMG* pimg  = pImgWnd->m_pImg;

    CDC* pDC = CDC::FromHandle( pimg->hDC );

    CBrush  brush;
    CBrush* pOldBrush = NULL;

    COLORREF color;
    if (pmti->fCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       color = crTrans;
    }
    else
    {
       color = pmti->fLeft ? crLeft : crRight;
    }
    if (theApp.m_pPalette)
        {
        pcPaletteOld = pDC->SelectPalette( theApp.m_pPalette, FALSE );
        pDC->RealizePalette();
        }

    if (brush.CreateSolidBrush( color ))
        {
        pOldBrush = pDC->SelectObject( &brush );

        COLORREF crFillThis = pDC->GetPixel( pmti->pt.x, pmti->pt.y );

        BYTE iRed   = GetRValue( crFillThis );
        BYTE iGreen = GetGValue( crFillThis );
        BYTE iBlue  = GetBValue( crFillThis );

        if (theApp.m_bPaletted)
            crFillThis = PALETTERGB( iRed, iGreen, iBlue );
        else
            crFillThis =        RGB( iRed, iGreen, iBlue );

        pDC->ExtFloodFill( pmti->pt.x,
                           pmti->pt.y, crFillThis, FLOODFILLSURFACE );

        pDC->SelectObject( pOldBrush );

        InvalImgRect ( pimg, NULL );
        CommitImgRect( pimg, NULL );
        }
    else
        {
        theApp.SetGdiEmergency();
        }

    if (pcPaletteOld)
        pDC->SelectPalette( pcPaletteOld, FALSE );
    }

/***************************************************************************/

void CFloodTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    pImgWnd->FinishUndo(CRect(0, 0,
         pImgWnd->m_pImg->cxWidth, pImgWnd->m_pImg->cyHeight));

    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/***************************************************************************/

CRect  CSelectTool::c_selectRect;
CImageWell  CSelectTool::c_imageWell(IDB_SELOPT, CSize(37, 23));

CSelectTool::CSelectTool()
    {
    m_bIsUndoable    = FALSE;
    m_nCmdID         = IDMB_PICKTOOL;
    m_bCanBePrevTool = FALSE;
    }

/***************************************************************************/

void CSelectTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                            const CRect& optionsRect )
    {
    CPoint pt(optionsRect.left + (optionsRect.Width()      - 37) / 2,
              optionsRect.top  + (optionsRect.Height() / 2 - 23) / 2);

    CRect selRect(pt.x - 3, pt.y - 3, pt.x + 37 + 3, pt.y + 23 + 3);

    CBrush* pOldBrush;

    pOldBrush = pDC->SelectObject( GetSysBrush(theImgBrush.m_bOpaque ?
                                    COLOR_HIGHLIGHT : COLOR_BTNFACE));

    pDC->PatBlt(selRect.left, selRect.top,
                selRect.Width(), selRect.Height(), PATCOPY);

    pDC->SelectObject(pOldBrush);

    selRect.OffsetRect(0, optionsRect.Height() / 2);

    pOldBrush = pDC->SelectObject(GetSysBrush(theImgBrush.m_bOpaque ?
                                  COLOR_BTNFACE : COLOR_HIGHLIGHT));

    pDC->PatBlt(selRect.left, selRect.top,
                selRect.Width(), selRect.Height(), PATCOPY);

    pDC->SelectObject(pOldBrush);

    c_imageWell.Open();

    c_imageWell.DrawImage(pDC, pt, 0);

    pt.y += optionsRect.Height() / 2;

    c_imageWell.DrawImage(pDC, pt, 1);

    c_imageWell.Close();
    }

/***************************************************************************/

void CSelectTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                    const CPoint& clickPoint)
    {
    BOOL bNewOpaque = clickPoint.y < optionsRect.Height() / 2;

    if (bNewOpaque != theImgBrush.m_bOpaque)
        {
        HideBrush();

        theImgBrush.m_bOpaque = bNewOpaque;
        theImgBrush.RecalcMask(crRight);

        CImgWnd::GetCurrent()->MoveBrush(theImgBrush.m_rcSelection);

        pWnd->InvalidateOptions();
        }
    }

/***************************************************************************/

void CSelectTool::InvertSelectRect(CImgWnd* pImgWnd)
    {
    if (c_selectRect.IsRectEmpty())
        return;

    CClientDC dc( pImgWnd );

    CBrush* pOldBrush = NULL;
    int iLineWidth = pImgWnd->GetZoom();

    if (g_brSelectHorz.m_hObject != NULL)
        pOldBrush = dc.SelectObject( &g_brSelectHorz );
    else
        pOldBrush = (CBrush*)dc.SelectStockObject( BLACK_BRUSH );

    CRect invertRect = c_selectRect;

    pImgWnd->ImageToClient( invertRect );

    int iWidth  = invertRect.Width();
    int iHeight = invertRect.Height();

    dc.PatBlt( invertRect.left, invertRect.top, iWidth - iLineWidth, iLineWidth, PATINVERT );
    dc.PatBlt( invertRect.left, invertRect.top + iHeight - iLineWidth, iWidth - iLineWidth, iLineWidth, PATINVERT );

    if (g_brSelectVert.m_hObject != NULL)
        dc.SelectObject( &g_brSelectVert );

    dc.PatBlt( invertRect.left, invertRect.top + iLineWidth * 2, iLineWidth, iHeight - iLineWidth * 3, PATINVERT );
    dc.PatBlt( invertRect.right - iLineWidth, invertRect.top, iLineWidth, iHeight, PATINVERT );

    if (pOldBrush != NULL)
        dc.SelectObject( pOldBrush );
    }

/***************************************************************************/

void CSelectTool::OnShowDragger(CImgWnd* pImgWnd, BOOL bShow)
    {
    if (!bShow)
        {
        InvertSelectRect(pImgWnd);
        c_selectRect.SetRect(0, 0, 0, 0);
        }
    }

/***************************************************************************/

void CSelectTool::OnActivate(BOOL bActivate)
    {
    if (!bActivate)
        {
        if (theImgBrush.m_pImg != NULL)
            {
            if (! theImgBrush.m_bFirstDrag)
                CommitSelection(TRUE);

            InvalImgRect(theImgBrush.m_pImg, NULL); // erase selection tracker
            theImgBrush.m_pImg = NULL;
            }
        }

    CImgTool::OnActivate(bActivate);
    }

/***************************************************************************/

void CSelectTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);

    CommitSelection(TRUE);

    pImgWnd->EraseTracker();

    theImgBrush.m_bMakingSelection = TRUE;
    }

/***************************************************************************/

void CSelectTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CRect newSelectRect(pmti->ptDown.x, pmti->ptDown.y,
        pmti->pt.x, pmti->pt.y);
    FixRect(&newSelectRect);
    newSelectRect.right += 1;
    newSelectRect.bottom += 1;

    if (newSelectRect.left < 0)
        newSelectRect.left = 0;
    if (newSelectRect.top < 0)
        newSelectRect.top = 0;
    if (newSelectRect.right > pImgWnd->GetImg()->cxWidth)
        newSelectRect.right = pImgWnd->GetImg()->cxWidth;
    if (newSelectRect.bottom > pImgWnd->GetImg()->cyHeight)
        newSelectRect.bottom = pImgWnd->GetImg()->cyHeight;

    if (newSelectRect != c_selectRect)
        {
        InvertSelectRect(pImgWnd);
        c_selectRect = newSelectRect;
        InvertSelectRect(pImgWnd);
        }

    SetStatusBarPosition(pmti->ptDown);
    SetStatusBarSize(c_selectRect.Size());
    }

/***************************************************************************/

void CSelectTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    InvertSelectRect(pImgWnd);
    c_selectRect.SetRect(0, 0, 0, 0);

    CRect rcPick;

    theImgBrush.m_bMakingSelection = FALSE;

    if (pmti->ptDown.x > pmti->pt.x)
        {
        rcPick.left = pmti->pt.x;
        rcPick.right = pmti->ptDown.x;
        }
    else
        {
        rcPick.left = pmti->ptDown.x;
        rcPick.right = pmti->pt.x;
        }

    if (pmti->ptDown.y > pmti->pt.y)
        {
        rcPick.top = pmti->pt.y;
        rcPick.bottom = pmti->ptDown.y;
        }
    else
        {
        rcPick.top = pmti->ptDown.y;
        rcPick.bottom = pmti->pt.y;
        }

    if (rcPick.left < 0)
        rcPick.left = 0;
    if (rcPick.top < 0)
        rcPick.top = 0;
    if (rcPick.right > pImgWnd->m_pImg->cxWidth - 1)
        rcPick.right = pImgWnd->m_pImg->cxWidth - 1;
    if (rcPick.bottom > pImgWnd->m_pImg->cyHeight - 1)
        rcPick.bottom = pImgWnd->m_pImg->cyHeight - 1;

    if (rcPick.Width() == 0 || rcPick.Height() == 0)
        {
        theImgBrush.TopLeftHandle();

        theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
        g_bCustomBrush = FALSE;
        SetCombineMode(combineColor);

        InvalImgRect(pImgWnd->m_pImg, NULL);  // redraw selection
        theImgBrush.m_pImg = NULL;
        }
    else
        {
        rcPick.right += 1;
        rcPick.bottom += 1;

        pImgWnd->MakeBrush(pImgWnd->m_pImg->hDC, rcPick );
        }

    ClearStatusBarSize();

    CImgTool::OnEndDrag(pImgWnd, pmti);

    if (pmti->fRight && !pmti->fLeft)
    {
        CPoint pt = pmti->pt;

        pImgWnd->OnRButtonDownInSel(&pt);
    }

    }

/***************************************************************************/

void CSelectTool::OnCancel(CImgWnd* pImgWnd)
    {
    if (! theImgBrush.m_bMakingSelection && CWnd::GetCapture() != pImgWnd)
        {
        // We were not selecting or dragging, just cancel the select tool...
        CommitSelection(TRUE);

        theImgBrush.TopLeftHandle();

        theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
        g_bCustomBrush = FALSE;
        SetCombineMode(combineColor);

        if (theImgBrush.m_pImg != NULL)
            InvalImgRect(theImgBrush.m_pImg, NULL);  // redraw selection

        theImgBrush.m_pImg = NULL;
        CImgTool::OnCancel(pImgWnd);
        return;
        }

    if (!theImgBrush.m_bMakingSelection && CWnd::GetCapture() == pImgWnd)
        {
        HideBrush();

        if (!theImgBrush.m_bMoveSel && !theImgBrush.m_bSmearSel)
            {
            if (g_bCustomBrush)
                {
                theImgBrush.TopLeftHandle();

                g_bCustomBrush = FALSE;
                SetCombineMode(combineColor);
                }
            else
                {
                if (theImgBrush.m_pImg)
                    CommitSelection(TRUE);
                InvalImgRect(pImgWnd->m_pImg, NULL); // erase the dragger
                }
            }
        }

    InvertSelectRect(pImgWnd);
    c_selectRect.SetRect(0, 0, 0, 0);

    theImgBrush.TopLeftHandle();

    g_bCustomBrush = FALSE;
    theImgBrush.m_pImg = NULL;
    theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
    theImgBrush.m_bMakingSelection = FALSE;

    InvalImgRect(pImgWnd->m_pImg, NULL);

    CImgTool::OnCancel(pImgWnd);
    }

/***************************************************************************/

BOOL CSelectTool::IsToolModal(void)
{
        if (theImgBrush.m_pImg)
        {
                return(TRUE);
        }

        return(CImgTool::IsToolModal());
}

/***************************************************************************/

UINT CSelectTool::GetCursorID()
    {
    CPoint point;
    GetCursorPos(&point);
    CImgWnd* pImgWnd = (CImgWnd*)CWnd::WindowFromPoint(point);

    if (pImgWnd->IsKindOf(RUNTIME_CLASS(CImgWnd))
    &&  pImgWnd->GetImg() == pImgCur
    &&  theImgBrush.m_pImg != NULL)
        {
        pImgWnd->ScreenToClient(&point);
        pImgWnd->ClientToImage(point);

        if (theImgBrush.m_rcSelection.PtInRect(point))
            return IDCUR_MOVE;
        }

    return m_nCursorID;
    }

/***************************************************************************/

CRect  CZoomTool::c_zoomRect;
CImgWnd* CZoomTool::c_pImgWnd;
CImageWell  CZoomTool::c_imageWell(IDB_ZOOMOPT, CSize(23, 9));

/***************************************************************************/

CZoomTool::CZoomTool()
    {
    m_bIsUndoable     = FALSE;
    m_bCanBePrevTool  = FALSE;
    m_bToggleWithPrev = TRUE;

    m_nCursorID       = IDC_ZOOMIN;
    m_nCmdID          = IDMB_ZOOMTOOL;
    }

/***************************************************************************/

void CZoomTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect )
    {
    int nCurZoom = CImgWnd::GetCurrent()->GetZoom();
    int dy = optionsRect.Height() / 4;
    CPoint pt(optionsRect.left + (optionsRect.Width() - 23) / 2,
        optionsRect.top + optionsRect.Height() / dy);

    c_imageWell.Open();

    if (nCurZoom == 1)
        {
        CBrush* pOldBrush;
        pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
        pDC->PatBlt(pt.x - 8, pt.y - 2, 23 + 16, 9 + 4,
            PATCOPY);
        pDC->SelectObject(pOldBrush);
        }
    pDC->SetTextColor(GetSysColor(
        nCurZoom == 1 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        nCurZoom == 1 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 0, SRCCOPY);
    pt.y += dy;

    if (nCurZoom == 2)
        {
        CBrush* pOldBrush;
        pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
        pDC->PatBlt(pt.x - 8, pt.y - 2, 23 + 16, 9 + 4, PATCOPY);
        pDC->SelectObject(pOldBrush);
        }
    pDC->SetTextColor(GetSysColor(
        nCurZoom == 2 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        nCurZoom == 2 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 1, SRCCOPY);
    pt.y += dy;

    if (nCurZoom == 6)
        {
        CBrush* pOldBrush;
        pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
        pDC->PatBlt(pt.x - 8, pt.y - 2, 23 + 16, 9 + 4, PATCOPY);
        pDC->SelectObject(pOldBrush);
        }
    pDC->SetTextColor(GetSysColor(
        nCurZoom == 6 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        nCurZoom == 6 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 2, SRCCOPY);
    pt.y += dy;

    if (nCurZoom == 8)
        {
        CBrush* pOldBrush;
        pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
        pDC->PatBlt(pt.x - 8, pt.y - 2, 23 + 16, 9 + 4, PATCOPY);
        pDC->SelectObject(pOldBrush);
        }
    pDC->SetTextColor(GetSysColor(
        nCurZoom == 8 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        nCurZoom == 8 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));;
    c_imageWell.DrawImage(pDC, pt, 3, SRCCOPY);

    c_imageWell.Close();
    }

/***************************************************************************/

void CZoomTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    int nNewZoom = clickPoint.y / (optionsRect.Height() / 4) + 1;
    if (nNewZoom >= 3)
        nNewZoom *= 2;

    if (nNewZoom != CImgWnd::GetCurrent()->GetZoom())
        {
        CImgWnd::GetCurrent()->SetZoom(nNewZoom);
        CImgWnd::GetCurrent()->CheckScrollBars();

        pWnd->InvalidateOptions();
        }

    SelectPrevious();
    }

/***************************************************************************/

void CZoomTool::OnLeave(CImgWnd* pImgWnd, MTI* pmti)
    {
    InvertZoomRect();
    c_zoomRect.SetRect(0, 0, 0, 0);
    }

/***************************************************************************/

void CZoomTool::OnShowDragger(CImgWnd* pImgWnd, BOOL bShow)
    {
    InvertZoomRect();
    }

/***************************************************************************/

void CZoomTool::InvertZoomRect()
    {
    if (c_zoomRect.IsRectEmpty())
        return;

    CClientDC dc(c_pImgWnd);
    CBrush* pOldBrush = (CBrush*)dc.SelectStockObject(NULL_BRUSH);
    dc.SetROP2(R2_NOT);
    CRect invertRect = c_zoomRect;
    c_pImgWnd->ImageToClient(invertRect);
    dc.Rectangle(&invertRect);
    dc.SelectObject(pOldBrush);
    }

/***************************************************************************/

void CZoomTool::OnMove(CImgWnd* pImgWnd, MTI* pmti)
    {
    if (pImgWnd->GetZoom() > 1)
        return;

    CRect viewRect;
    pImgWnd->GetClientRect(&viewRect);
    int nPrevZoom = pImgWnd->GetPrevZoom();

    CRect newZoomRect;
    CSize viewSize = viewRect.Size();
    if (viewSize.cx > pImgWnd->m_pImg->cxWidth * nPrevZoom)
        viewSize.cx = pImgWnd->m_pImg->cxWidth * nPrevZoom;
    if (viewSize.cy > pImgWnd->m_pImg->cyHeight * nPrevZoom)
        viewSize.cy = pImgWnd->m_pImg->cyHeight * nPrevZoom;
    newZoomRect.left = pmti->pt.x;
    newZoomRect.top = pmti->pt.y;
    newZoomRect.right = newZoomRect.left + viewSize.cx / nPrevZoom;
    newZoomRect.bottom = newZoomRect.top + viewSize.cy / nPrevZoom;
    newZoomRect.OffsetRect(-newZoomRect.Width() / 2,
        -newZoomRect.Height() / 2);

    int xAdjust = 0;
    int yAdjust = 0;

    if (newZoomRect.left < 0)
        xAdjust = -newZoomRect.left;
    else if ((xAdjust = pImgWnd->m_pImg->cxWidth - newZoomRect.right) > 0)
        xAdjust = 0;

    if (newZoomRect.top < 0)
        yAdjust = -newZoomRect.top;
    else if ((yAdjust = pImgWnd->m_pImg->cyHeight - newZoomRect.bottom) > 0)
        yAdjust = 0;

    newZoomRect.OffsetRect(xAdjust, yAdjust);

    if (newZoomRect != c_zoomRect)
        {
        InvertZoomRect();
        c_pImgWnd = pImgWnd;
        c_zoomRect = newZoomRect;
        InvertZoomRect();
        }
    }

/***************************************************************************/

void CZoomTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);

    c_pImgWnd = pImgWnd;
    InvertZoomRect();

    if (pImgWnd->GetZoom() == 1)
        {
        pImgWnd->SetZoom( pImgWnd->GetPrevZoom() );
        pImgWnd->CheckScrollBars();
        pImgWnd->SetScroll(-c_zoomRect.left - 1, -c_zoomRect.top - 1);
        }
    else
        {
        pImgWnd->SetZoom(1);
        pImgWnd->CheckScrollBars();
        }

    c_zoomRect.SetRect(0, 0, 0, 0);
    }

/***************************************************************************/

void CZoomTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    SelectPrevious();
    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CZoomTool::OnCancel(CImgWnd* pImgWnd)
    {
    InvertZoomRect();
    c_zoomRect.SetRect(0, 0, 0, 0);
    SelectPrevious();
    CImgTool::OnCancel(pImgWnd);
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgfile.cpp ===
// File import/export for icons, cursors, and bitmaps

#include "stdafx.h"

#include <direct.h>
#include <sys\stat.h>

#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgfile.h"
#include "ferr.h"
#include "cmpmsg.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

// base for temp file names
const TCHAR BASED_CODE CFileSaver::c_szAps [] = TEXT("TMP");

/***************************************************************************/

BOOL FileExists(const TCHAR* szFileName)
    {
    CFileStatus fs;
    return CFile::GetStatus(szFileName, fs) != 0;
    }

/***************************************************************************/

BOOL RenameFile(const TCHAR* szOldName, const TCHAR* szNewName)
    {
    TRACE2("RenameFile: \"%s\" to \"%s\"\n", szOldName, szNewName);

    TRY
        {
        if (FileExists(szNewName))
            CFile::Remove(szNewName);
        CFile::Rename(szOldName, szNewName);
        }
    CATCH(CFileException, e)
        {
        TRACE(TEXT("Rename failed!\n"));
        theApp.SetFileError( IDS_ERROR_EXPORT, e->m_cause );
        return FALSE;
        }
    END_CATCH

    return TRUE;
    }

/***************************************************************************/

CFileSaver::CFileSaver(const TCHAR* szFileName)
    {
    CString strDir = StripName(szFileName);
    CString strTempDir;

    GetTempPath( _MAX_PATH, strTempDir.GetBuffer( _MAX_PATH ) );

    strTempDir.ReleaseBuffer();

    GetTempFileName( strTempDir, c_szAps, 0, m_strTempName.GetBuffer( _MAX_PATH ));
    GetTempFileName( strTempDir, c_szAps, 0, m_strBackupName.GetBuffer( _MAX_PATH ));

    CFile::Remove( m_strTempName );
    CFile::Remove( m_strBackupName );

    m_strName = szFileName;
    m_strTempName = strDir + StripPath( m_strTempName );
    m_strBackupName = strDir + StripPath( m_strBackupName );
    }

/***************************************************************************/

CFileSaver::~CFileSaver()
    {
    if (FileExists(m_strTempName))
        CFile::Remove(m_strTempName);

    if (FileExists(m_strBackupName))
        CFile::Remove(m_strBackupName);
    }

/***************************************************************************/

BOOL CFileSaver::CanSave() const
    {
    CFileStatus fs;

    if ( CFile::GetStatus(m_strName, fs) != 0 )
                {
                if ((fs.m_attribute & CFile::readOnly) != 0)
                {
                theApp.SetFileError( IDS_ERROR_SAVE, ferrCantSaveReadOnly);
                return FALSE;
                }
                }

    return TRUE;
    }

/***************************************************************************/

BOOL CFileSaver::Finish()
    {
    if (FileExists(m_strName) != 0)
        {
        if (!RenameFile(m_strName, m_strBackupName))
            {
            CFile::Remove(m_strTempName);
            return FALSE;
            }
        }
    else
        {
        // no backup was made since the "original" didn't exists,
        // wipe out the name so we don't delete the file later...

        m_strBackupName.Empty();
        }

    if (!RenameFile(m_strTempName, m_strName))
        {
        if (!m_strBackupName.IsEmpty() &&
            RenameFile(m_strBackupName, m_strName))
            {
            CFile::Remove(m_strTempName);
            }

        return FALSE;
        }

    if (!m_strBackupName.IsEmpty())
        CFile::Remove(m_strBackupName);

    return TRUE;
    }

/***************************************************************************/
/* strrchrs() -- find the last instance in a string of any one of
**  a set of characters.  Return a pointer into the string at
**  the matchpoint.  Analogous to strrchr() in the CRT.
*/

TCHAR *strrchrs(TCHAR *szText, TCHAR * szSSet)
    {
    register TCHAR *pchSSet;
    register TCHAR *pchStep;
    register TCHAR *pchLast = NULL;

    if ((NULL == szText) || (NULL == szSSet))
        return NULL;
    for (pchStep = szText; TEXT('\0') != *pchStep; pchStep = CharNext(pchStep))
        for (pchSSet = szSSet; TEXT('\0') != *pchSSet; pchSSet = CharNext(pchSSet))
            if ((pchSSet[0] == pchStep[0]) && (
               #ifndef UNICODE
                !IsDBCSLeadByte((CHAR)pchSSet[0]) ||
               #endif // UNICODE
               (pchSSet[1] == pchStep[1])))
                    pchLast = pchStep;
    return pchLast;
    }

/***************************************************************************/
/* MkPath() -- Make any directories necessary to ensure that a
**  directory name passed in exists.  Essentially, if the
**  argument exists and is a directory, return success.  If
**  not, strip off the last path component and recurse,
**  creating the directories on returning up the stack.
*/
int MkPath(TCHAR *szPath)
    {
    TCHAR *pchSlash;
    TCHAR chSep;
    DWORD dwAtts;

    //Does it exist?
    if ( (dwAtts = GetFileAttributes(szPath)) & FILE_ATTRIBUTE_DIRECTORY )
        {
        return 0;
        }
    else if (-1 != dwAtts)
        {
        return -1;
        }

    //Can we create it?
    else
        {
        if ( CreateDirectory(szPath, NULL))
            return 0;
        // are we out of path components?
        else
            {
            if (NULL == (pchSlash = strrchrs(szPath, TEXT("\\/"))))
                return -1;
            // Can we make its parent directory?
            else
                                {
                if ((chSep = *pchSlash), (*pchSlash = TEXT('\0')), MkPath(szPath))
                    {
                    #ifndef DEBUG
                    *pchSlash = chSep;
                    #endif
                    return -1;
                    }
                // Can we make it now that we've made its parent?
                else
                                        {
                    if ((*pchSlash = chSep), (TEXT('\0') != pchSlash[1]))
                        {
                        if (!CreateDirectory (szPath, NULL))
                        {
                           return -1;
                        }
                        return 0;
                        }
                    else //don't try trailing slash
                        return 0;
                                        }
                                }
                        }
                }
    }

/***************************************************************************/

void MkFullPath(CString& strFullPath, const CString& strRelPath,
    BOOL bPathOnly)
    {
    strFullPath.Empty();

    ASSERT(strRelPath.GetLength() > 0);
    if (strRelPath[0] != TEXT('\\') &&
        (strRelPath.GetLength() <= 1 || (
        #ifndef UNICODE
        !IsDBCSLeadByte((CHAR)strRelPath[0]) &&
        #endif // UNICODE
         strRelPath[1] != TEXT(':'))))
        {
        CHAR *szPathName = _getdcwd(0, NULL, 1);
        #ifdef UNICODE
        WCHAR *szPW = new WCHAR[lstrlenA (szPathName)+1];
        AtoW (szPathName, szPW);
        strFullPath = szPW;
        delete szPW;
        #else
        strFullPath = szPathName;
        #endif //UNICODE
        free(szPathName);

        if (strFullPath.Right(1) != TEXT('\\'))
            strFullPath += (TCHAR)TEXT('\\');
        }

    if (bPathOnly)
        {
        int iLastSep = strRelPath.ReverseFind(TEXT('\\'));
        if (iLastSep == -1)
            iLastSep = strRelPath.GetLength();
        strFullPath += strRelPath.Left(iLastSep);
        }
    else
        {
        strFullPath += strRelPath;
        }
    }

/***************************************************************************/

BOOL OpenSubFile(CFile& file, const CFileSaver& saver, UINT nOpenFlags,
                CFileException* pError)
    {
    BOOL bResult = file.Open(saver.GetSafeName(), nOpenFlags, pError);

    if (!bResult && (pError->m_cause == CFileException::badPath ||
            pError->m_cause == CFileException::accessDenied))
        {
        CString strFileName = saver.GetRealName();
        CString strPathName;

        MkFullPath(strPathName, strFileName, TRUE);
        strPathName.MakeUpper();

        // suppress the message box upon return, but keep error info!
        // (ie. user only needs one message box)
        pError->m_cause = -pError->m_cause;

        strFileName.MakeUpper();
        int nResult = CmpMessageBoxPrintf(IDS_QUERY_MKDIR, AFX_IDS_APP_TITLE,
            MB_YESNO | MB_ICONQUESTION,
            (LPCTSTR)strPathName, (LPCTSTR) strFileName);
        if (nResult == IDYES)
            {
            MkPath(strPathName.GetBuffer(strPathName.GetLength()));
            strPathName.ReleaseBuffer();
            bResult = file.Open(saver.GetSafeName(), nOpenFlags, pError);
            }
        }

    return bResult;
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgwell.h ===
#ifndef __IMGWELL_H__
#define __IMGWELL_H__

// The CImageWell class provides a convenient way to handle "tiled"
// bitmaps.

class CImageWell
    {
    public:

    CImageWell();
    CImageWell( UINT nBitmapID, CSize imageSize );

    ~CImageWell();
    
    BOOL Open  ();
    BOOL IsOpen() { return m_dc.m_hDC != NULL; }
    void Close ();
    BOOL Load  ( UINT nBitmapID, CSize imageSize );
    void Unload();
    
    BOOL CalculateMask();
    
    BOOL DrawImage( CDC* pDestDC, CPoint destPoint, UINT nImage, 
                    DWORD rop = 0); // rop==0 means image is drawn through a mask
    
    protected:

    UINT    m_nBitmapID;
    CSize   m_imageSize;
    
    CBitmap m_bitmap;
    CDC     m_dc;
    CBitmap m_mask;
    CDC     m_maskDC;
    };

#endif // __IMGWELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgsuprt.h ===
#ifndef __IMGSUPRT_H__
#define __IMGSUPRT_H__

#define MAX_PALETTE_COLORS 256

#define WM_CANCEL WM_USER + 0

// Brush Shapes
#define roundBrush          0
#define squareBrush         1
#define slantedLeftBrush    2
#define slantedRightBrush   3


// Combine Modes
#define combineColor        0
#define combineMatte        1
#define combineReplace      2


// Non-standard Raster Ops
#define DSx                 0x00660046L
#define DSa                 0x008800C6L
#define DSna                0x00220326L
#define DSPao               0x00ea02e9L
#define DSo                 0x00ee0086L
#define DSno                0x00bb0226L
#define DSPDxax             0x00e20746L
#define SPxn                0x00c3006aL

// Indices of the screen and inverse colors in color table.
#define IDScreen    -1
#define IDInvScreen -2

// NOTE: These structures mirror the LOGPALETTE structure in WINDOWS.H

struct LOGPALETTE16
    {
    WORD         palVersion;
    WORD         palNumEntries;
    PALETTEENTRY palPalEntry[16];
    };


struct LOGPALETTE256
    {
    WORD         palVersion;
    WORD         palNumEntries;
    PALETTEENTRY palPalEntry[MAX_PALETTE_COLORS];
    };

// Note: this bogus structure is not my fault!  It's stolen from
// the old Windows SDK ImagEdit program...
#pragma pack(1)

struct COLORFILEHEADER
    {
    char  tag; // this is a 'C'
    short colors;
    char  reserved[47]; // fill with 0
    // DWORD rgrgb [colors];
    };

#pragma pack()

/*************************************************************************/

//extern int FileTypeFromExtension( const TCHAR FAR* lpcExt );

void InitCustomData();          // see customiz.cpp
void CustomExit();

class CImgWnd;

// IMGSUPRT.CPP

extern IMG*     CreateImg          (int cxWidth, int cyHeight,
                                    int cPlanes, int cBitCount, 
                                    int cXPelsPerMeter, int cYPelsPerMeter,
                                    BOOL bPalette = TRUE );
extern void     SelectImg          (IMG* pImg);
extern BOOL     ClearImg           (IMG* pImg);
extern void     FreeImg            (IMG* pImg);
extern void     DirtyImg           (IMG* pImg);
extern void     AddImgWnd          (IMG* pImg, CImgWnd* pImgWnd);
extern BOOL     UpdateCurIcoImg    (IMG* pImg);
extern BOOL     ChangeICBackground (IMG* pImg, COLORREF rgbNewScr);
extern BOOL     SetImgSize         (IMG* pImg, CSize newSize, BOOL bStretch);
extern void     GetImgSize         (IMG* pImg, CSize& size);
extern BOOL     ReplaceImgPalette  (IMG* pImg, LPLOGPALETTE lpLogPal);
extern int      AddNewColor        (IMG* pImg,  COLORREF crNew );

// IMGED.CPP
extern void     Draw3dRect         (HDC hDC, RECT* prc);

// DRAW.CPP
extern void     InvalImgRect       (IMG* pImg, CRect* prc);
extern void     CommitImgRect      (IMG* pImg, CRect* prc);
extern void     FixRect            (RECT* prc);
extern void     StandardiseCoords  (CPoint* s, CPoint* e);
extern void     DrawBrush          (IMG* pImg, CPoint pt, BOOL bDraw);
extern void     HideBrush          ();
extern void     SetCombineMode     (int wNewCombineMode);
extern BOOL     SetupRubber        (IMG* pImg);
extern void     PolyTo             (CDC* pDC, CPoint fromPt,
                                              CPoint toPt, CSize size);
extern BOOL     GetTanPt           (CSize size, CPoint delta, CRect& tan);

extern void     SetDrawColor       (COLORREF cr);
extern void     SetEraseColor      (COLORREF cr);
extern void     SetTransColor      (COLORREF cr);
extern void     SetDrawColor       (int iColor);
extern void     SetEraseColor      (int iColor);
extern void     SetTransColor      (int iColor);
extern void     InvalColorWnd      ();
extern BOOL     SetUndo            (IMG* pImg);
extern void     SetLeftColor       (int nColor);
extern void     SetRightColor      (int nColor);
extern void     CommitSelection    (BOOL bSetUndo);
extern void     PickupSelection    ();

extern BOOL     EnsureUndoSize     (IMG* pimg);

extern void     CleanupImages   ();
extern void     CleanupImgRubber();
extern void     CleanupImgUndo  ();

extern IMG*      pImgCur;

#define TRANS_COLOR_NONE 0x87654321 // undefined

extern BOOL      fDraggingBrush;
extern BOOL      g_bCustomBrush;
extern BOOL      g_bDriverCanStretch;
extern BOOL      g_bUseTrans;

extern int       theLeft;
extern int       theRight;
extern int       theTrans;
extern COLORREF  crLeft;
extern COLORREF  crRight;
extern COLORREF  crTrans;
extern int       wCombineMode;

struct DINFO
    {
    TCHAR* m_szDesc;
    UINT  m_nColors;
    SIZE  m_size;
    };

extern COLORREF  std2Colors[];

extern CPalette* GetStd256Palette();
extern CPalette* GetStd16Palette();
extern CPalette* GetStd2Palette();
extern CPalette* PaletteFromDS(HDC hdc);

#define IS_WIN30_DIB(lpbi) ((*(LPDWORD)(lpbi)) >= sizeof (BITMAPINFOHEADER))

extern WORD      DIBNumColors      ( LPSTR lpbi, BOOL bJustUsed=TRUE );
extern DWORD     DIBWidth          ( LPSTR lpDIB );
extern DWORD     DIBHeight         ( LPSTR lpDIB );
extern CPalette* CreateDIBPalette  ( LPSTR lpbi );
extern HBITMAP   DIBToBitmap       ( LPSTR lpDIBHdr, CPalette* pPal, HDC hdc = NULL );
extern HBITMAP   DIBToDS           ( LPSTR lpDIBHdr, DWORD dwOffBits, HDC hdc );
extern HGLOBAL   DibFromBitmap     ( HBITMAP hBitmap, DWORD dwStyle, WORD wBits,
                                     CPalette* pPal, HBITMAP hMaskBitmap, DWORD& dwSize, 
                                     LONG cXPelsPerMeter, LONG cYPelsPerMeter );
extern LPSTR     FindDIBBits       ( LPSTR lpbi, DWORD dwOffBits = 0 );
extern WORD      PaletteSize       ( LPSTR lpbi );
extern void      FreeDib           ( HGLOBAL hDib );
extern CPalette* CreatePalette     ( const COLORREF* colors, int nColors );
extern CPalette* MergePalettes     ( CPalette *pPal1, CPalette *pPal2, int& iAdds );
extern void      AdjustPointForGrid( CPoint *ptPointLocation );

// drawing support functions
extern void      StretchCopy (HDC, int, int, int, int, HDC, int, int, int, int);
extern void      FillImgRect (HDC hDC, CRect * prc, COLORREF cr );
extern void      BrushLine   (CDC* pDC, CPoint fromPt, CPoint toPt,
                             int nWidth, int nShape);
extern void      DrawDCLine  (HDC hDC, CPoint pt1, CPoint pt2,
                              COLORREF color, int nWidth, int nShape,
                              CRect& rc);
extern void      DrawImgLine (IMG* pimg, CPoint pt1, CPoint pt2,
                              COLORREF color, int nWidth, int nShape,
                              BOOL bCommit);
extern void      Mylipse     (HDC hDC, int x1, int y1, int x2, int y2, BOOL bFilled);

// PATSTENCIL:
// This is a ternary raster operation, listed in the SDK ref as "PSDPxax",
// but I prefer to think of it as "DSaPSnao".  More practically, this rop
// is useful to apply the color of the current brush to only those pixels
// where the source bitmap is zero (black).  That is, a binary bitmap as the
// source will be drawn onto the destination in the color of the current
// brush.
//
#define PATSTENCIL 0xB8074AL

// DrawBitmap:
// This draws a bitmap on a display context with a given raster operation.
//   CDC* dc         The target display context.
//   CBitmap* bmSrc  The bitmap to be drawn.
//   CRect* rc       A position rectangle.
//                   If NULL, bitmap drawn with the upper-left at 0, 0.
//                   Otherwise, bitmap drawn centered in this rectangle.
//                   Result is not clipped to the rectangle.
//   DWORD dwROP     Raster operation.  See table 11.3 of the Win30 SDK ref.
//   CDC* memdc      A memory context for the BitBlt process to use.
//                   If NULL, DrawBitmap creates and destroys its own.
//
void DrawBitmap(CDC* dc, CBitmap* bmSrc, CRect* rc,
                DWORD dwROP = SRCCOPY, CDC* memdc = NULL);

extern HDC       hRubberDC;
extern HBITMAP   hRubberBM;
extern HBITMAP   g_hUndoImgBitmap;
extern HPALETTE  g_hUndoPalette;
extern int       cxRubberWidth;
extern int       cyRubberHeight;
extern IMG*      pRubberImg;
extern WORD      gwClipboardFormat;
extern CBrush    g_brSelectHorz;
extern CBrush    g_brSelectVert;

CPalette *PBSelectPalette(CDC *pDC, CPalette *pPalette, BOOL bForceBk);

class CTempBitmap : public CBitmap
{
public:
        ~CTempBitmap() { DeleteObject(); } // DeleteObject checks for NULL
} ;

#endif // __IMGSUPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgwell.cpp ===
#include "stdafx.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

#define DSx     0x00660046L
#define DSna    0x00220326L


CImageWell::CImageWell()
    : m_bitmap(), m_dc(), m_mask(), m_maskDC(), m_imageSize(0, 0)
{
    m_nBitmapID = 0;
}


CImageWell::CImageWell(UINT nBitmapID, CSize imageSize)
    : m_bitmap(), m_dc(), m_mask(), m_maskDC(), m_imageSize(imageSize)
{
    m_nBitmapID = nBitmapID;
}


CImageWell::~CImageWell()
{
    // Destructor needed to ensure the DC is deleted before the bitmap
    m_dc.DeleteDC();
    m_bitmap.DeleteObject();
    m_maskDC.DeleteDC();
    m_mask.DeleteObject();
}


BOOL CImageWell::Load(UINT nBitmapID, CSize imageSize)
{
    ASSERT(m_bitmap.m_hObject == NULL);

    if (!m_bitmap.LoadBitmap(nBitmapID))
    {
        TRACE1("Could not load image well %d\n", nBitmapID);
        return FALSE;
    }

    m_nBitmapID = nBitmapID;
    m_imageSize = imageSize;

    return TRUE;
}


void CImageWell::Unload()
{
    ASSERT(m_dc.m_hDC == NULL); // can't unload if it's open!
    ASSERT(m_maskDC.m_hDC == NULL);
    ASSERT(m_bitmap.m_hObject != NULL);

    m_bitmap.DeleteObject();
    m_mask.DeleteObject();
}


BOOL CImageWell::CalculateMask()
{
    ASSERT(m_maskDC.m_hDC == NULL);
    ASSERT(m_dc.m_hDC != NULL);
    ASSERT(m_bitmap.m_hObject != NULL);

    if (!m_maskDC.CreateCompatibleDC(NULL))
    {
        theApp.SetGdiEmergency(FALSE);
        return FALSE;
    }

    if (m_mask.m_hObject != NULL)
    {
        VERIFY(m_maskDC.SelectObject(&m_mask) != NULL);
        return TRUE;
    }

    BITMAP bmp;
    m_bitmap.GetObject(sizeof (BITMAP), &bmp);

    if (!m_mask.CreateBitmap(bmp.bmWidth, bmp.bmHeight*2, 1, 1, NULL))
    {
        m_maskDC.DeleteDC();
        theApp.SetMemoryEmergency(FALSE);
        return FALSE;
    }

    VERIFY(m_maskDC.SelectObject(&m_mask) != NULL);

    COLORREF oldBkColor = m_dc.SetBkColor(m_dc.GetPixel(0, 0));
    m_maskDC.BitBlt(0, 0, bmp.bmWidth, bmp.bmHeight,
        &m_dc, 0, 0, NOTSRCCOPY);
    
    // store the pixels in "button text" color in the second part of the mask
    
    m_dc.SetBkColor(RGB(0, 0, 0));
    m_maskDC.BitBlt(0, bmp.bmHeight, bmp.bmWidth, bmp.bmHeight,
        &m_dc, 0, 0, SRCCOPY);
    
    m_dc.SetBkColor(oldBkColor);

    return TRUE;
}


BOOL CImageWell::Open()
{
    ASSERT(m_dc.m_hDC == NULL); // make sure this is not already open
    ASSERT(m_nBitmapID != 0);

    if (m_bitmap.m_hObject == NULL && !Load(m_nBitmapID, m_imageSize))
        return FALSE;

    if (!m_dc.CreateCompatibleDC(NULL))
    {
        theApp.SetGdiEmergency(FALSE);
        return FALSE;
    }

    VERIFY(m_dc.SelectObject(&m_bitmap));

    return TRUE;
}


void CImageWell::Close()
{
    ASSERT(m_dc.m_hDC != NULL);

    m_dc.DeleteDC();
    m_maskDC.DeleteDC();
}

BOOL CImageWell::DrawImage(CDC* pDestDC, CPoint destPoint,
    UINT nImage, DWORD rop)
{
    BOOL bClose = FALSE;
    if (m_dc.m_hDC == NULL)
    {
        ASSERT(rop != NULL); // must open first and calc mask for rop==0!

        if (!Open())
        {
            TRACE(TEXT("Could not open image well!\n"));
            return FALSE;
        }

        bClose = TRUE;
    }

    if (rop == 0)
    {
        if (m_maskDC.m_hDC == NULL && !CalculateMask())
            return FALSE;

        COLORREF oldBkColor = pDestDC->SetBkColor(RGB(255, 255, 255));
        COLORREF oldTextColor = pDestDC->SetTextColor(RGB(0, 0, 0));

        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_dc, m_imageSize.cx * nImage, 0, DSx);

        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_maskDC, m_imageSize.cx * nImage, 0, DSna);

        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_dc, m_imageSize.cx * nImage, 0, DSx);

        pDestDC->SetBkColor(GetSysColor(COLOR_BTNTEXT));

        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_maskDC, m_imageSize.cx * nImage, m_imageSize.cy, SRCPAINT);

        pDestDC->SetBkColor(oldBkColor);
        pDestDC->SetTextColor(oldTextColor);
    }
    else
    {
        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_dc, m_imageSize.cx * nImage, 0, rop);
    }

    if (bClose)
        Close();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgwnd.h ===
#ifndef __IMGWND_H__
#define __IMGWND_H__

#include "tracker.h"

// #define GRIDOPTIONS

class CBitmapObj;

// helper fns
BOOL IsUserEditingText();
BOOL TextToolProcessed( UINT nMessage );

// Mouse Tracking Information

typedef struct _mti
    {
    CPoint ptDown;
    CPoint ptPrev;
    CPoint pt;
    BOOL   fLeft;
    BOOL   fRight;
    BOOL   fCtrlDown;
    } MTI;

class CImgWnd;
class CThumbNailView;

// Image
struct IMG
    {
    class CImgWnd* m_pFirstImgWnd;

    CBitmapObj* m_pBitmapObj;

    BOOL bDirty;

    HDC hDC;
    HDC hMaskDC; // May be NULL (for normal bitmaps)

    // These are usually selected into hDC and hMaskDC respecively
    HBITMAP hBitmap;
    HBITMAP hBitmapOld;
    HBITMAP hMaskBitmap;
    HBITMAP hMaskBitmapOld;

    CPalette* m_pPalette;
    HPALETTE  m_hPalOld;

    int cxWidth;
    int cyHeight;
    int cPlanes;
    int cBitCount;
    int cXPelsPerMeter;
    int cYPelsPerMeter;
    int nResType;
    int m_nLastChanged;

    BOOL m_bTileGrid;
    int  m_cxTile;
    int  m_cyTile;
    };

// Image Editor Window

class CImgWnd : public CWnd
    {
    protected:

    static CImgWnd*         c_pImgWndCur;
    static CDragger*        c_pResizeDragger;
    static CTracker::STATE  c_dragState;

    DECLARE_DYNAMIC( CImgWnd )

    public:

     CImgWnd( IMG* pImg );
     CImgWnd( CImgWnd *pImgWnd );
    ~CImgWnd();

    BOOL Create( DWORD dwStyle, const RECT& rect,
                 CWnd* pParentWnd, UINT nID = 0 );

    BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );

    void ClientToImage(CPoint& point );
    void ClientToImage(CRect&  rect  );
    void ImageToClient(CPoint& point );
    void ImageToClient(CRect&  rect  );

    IMG* m_pImg;

    inline IMG*  GetImg() { return m_pImg; }
           void  SetImg( IMG* pImg );
    inline CSize GetScrollPos() { return CSize( m_xScroll, m_yScroll ); }
           void  SetScroll( int xScroll, int yScroll );
           void  ShowBrush( CPoint ptHandle );
           void  PrepareForBrushChange( BOOL bPickup = TRUE, BOOL bErase = TRUE );
    inline int   GetZoom()           { return m_nZoom; }
    inline int   GetPrevZoom() const { return m_nZoomPrev; }
           void  SetZoom( int nZoom );
           BOOL  MakeBrush( HDC hSourceDC, CRect rcSource );
           void  UpdPos(const CPoint& pt) { m_ptDispPos = pt; }
    inline BOOL  IsGridVisible() { return theApp.m_bShowGrid && m_nZoom > 3; }
           void  FinishUndo( const CRect& rect );
           void  RubberBandRect( HDC hDC, MTI* pmti, BOOL bErase );
           void  EraseTracker();
           void  CheckScrollBars();
           void  GetImageRect( CRect& rect );
       CPalette* SetImgPalette( CDC* pdc, BOOL bForce = FALSE );
       HPALETTE  SetImgPalette( HDC hdc, BOOL bForce = FALSE );
       CPalette* FixupDibPalette( LPSTR lpDib, CPalette* ppalDib );
           BOOL  IsSelectionAvailable( void );
           BOOL  IsPasteAvailable( void );
           CRect GetDrawingRect( void );

    static        void     SetToolCursor();
    static inline CImgWnd* GetCurrent() { return c_pImgWndCur; }
    BOOL                   PtInTracker(CPoint cptLocation);

    protected:

    void RubberMouse         (unsigned code, MTI* pmti);
    void OnRButtonDownInSel  (CPoint *pcPointDown);
    void ZoomedInDP          ( unsigned code, unsigned mouseKeys, CPoint newPt );
    void StartSelectionDrag  ( unsigned code, CPoint newPt );
    void CancelSelectionDrag ();
    void SelectionDragHandler( unsigned code, CPoint newPt );
    void ResizeMouseHandler  ( unsigned code, CPoint newPt );
    void EndResizeOperation  ();
    void MoveBrush           ( const CRect& newSelRect );
    void OnScroll            ( BOOL bVert, UINT nSBCode, UINT nPos );
    BOOL OnMouseDown         ( UINT nFlags );
    BOOL OnMouseMessage      ( UINT nFlags );
    void CancelPainting      ();

    afx_msg int  OnCreate       ( LPCREATESTRUCT lpCreateStruct );
#if 0
    afx_msg void OnDestroy      ();
#endif
    afx_msg void OnSetFocus     ( CWnd* pOldWnd );
    afx_msg void OnKillFocus    ( CWnd* pNewWnd );
    afx_msg void OnSize         ( UINT nType, int cx, int cy );
    afx_msg void OnLButtonDown  ( UINT nFlags, CPoint point );
    afx_msg void OnLButtonDblClk( UINT nFlags, CPoint point );
    afx_msg void OnLButtonUp    ( UINT nFlags, CPoint point );
    afx_msg void OnRButtonDown  ( UINT nFlags, CPoint point );
    afx_msg void OnRButtonDblClk( UINT nFlags, CPoint point );
    afx_msg void OnRButtonUp    ( UINT nFlags, CPoint point );
    afx_msg void OnKeyDown      ( UINT nChar, UINT nRepCnt, UINT nFlags );
    afx_msg void OnKeyUp        ( UINT nChar, UINT nRepCnt, UINT nFlags );
    afx_msg void OnMouseMove    ( UINT nFlags, CPoint point );
    afx_msg void OnTimer        ( UINT nIDEvent );
    afx_msg void OnVScroll      ( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar );
    afx_msg void OnHScroll      ( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar );
    afx_msg void OnPaint        ();
    afx_msg void OnCancelMode   ();
    afx_msg void OnWindowPosChanging( WINDOWPOS FAR* lpwndpos );
    afx_msg void OnDestroyClipboard();
    afx_msg void OnPaletteChanged(CWnd *);
    afx_msg BOOL OnSetCursor        (CWnd *pWnd, UINT nHitTest, UINT message);
    afx_msg BOOL OnMouseWheel   (UINT nFlags, short zDelta, CPoint pt);
    void CmdSmallBrush();
    void CmdSmallerBrush();
    void CmdLargerBrush();
    void CmdClearImage();
    void CmdShowGrid();
#ifdef  GRIDOPTIONS
    void CmdGridOptions();
    void CmdShowTileGrid();
#endif  // GRIDOPTIONS
    void CmdInvMode();
    void CmdTransMode();

    void CmdCopy();
    void CmdCut();
    void CmdPaste();
    void CmdClear();

    void CmdInvertColors();
    void CmdTglOpaque();
    void CmdFlipBshH();
    void CmdFlipBshV();
    void CmdRot90();
    void CmdSkewBrush( int wAngle, BOOL bHorz );
    void CmdDoubleBsh();
    void CmdHalfBsh();
    void CmdSel2Bsh();

    void CmdExport();

    void CmdCancel();
    void CmdOK();

    void GetDrawRects(const CRect* pPaintRect, const CRect* pReqDestRect,
        CRect& srcRect, CRect& destRect);

    void DrawGrid(CDC* pDC, const CRect& srcRect, CRect& destRect);
    void DrawBackground(CDC* pDC, const CRect* pPaintRect = NULL);
    void DrawTracker(CDC* pDC = NULL, const CRect* pPaintRect = NULL);
    void DrawImage(CDC* pDC, const CRect* pPaintRect,
                                   CRect* pDestRect = NULL, BOOL bDoGrid = TRUE);
    void SetThumbnailView( CThumbNailView* pwndNewThumbnailView )
                   { m_pwndThumbNailView = pwndNewThumbnailView; }

    BOOL PasteImageClip();
    BOOL PasteImageFile( LPSTR lpDib );
    HBITMAP CopyDC( CDC* pImgDC, CRect* prcClip );
    void CopyBMAndPal(HBITMAP *pBM, CPalette ** ppPal);

    CImgWnd* m_pNextImgWnd; // next viewer link

    int      m_nZoom;
    int      m_nZoomPrev;

    int      m_xScroll;
    int      m_yScroll;
    int      m_LineX;     // this is 1/32 of the bitmap height
    int      m_LineY;     // this is 1/32 of the bitmap width

    CPoint   m_ptDispPos;

    WORD     m_wClipboardFormat;

    HGLOBAL  m_hPoints;

    CThumbNailView* m_pwndThumbNailView;

    DECLARE_MESSAGE_MAP()

    friend class CPBFrame;
    friend class CPBView;
    friend class CBitmapObj;
    friend class CSelectTool;
    friend class CTextTool;
    friend class CCurveTool;
    friend class CTedit;
    friend class CAttrEdit;
    friend class CImgToolWnd; // for key message forwarding
    friend class CImgColorsWnd;
    friend class CCursorIconToolWnd;
    friend BOOL  SetImgSize(IMG*, CSize, BOOL);
    friend void  SetDrawColor(COLORREF);
    friend void  SetEraseColor(COLORREF);
    friend void  SetTransColor(COLORREF);
    friend void  FreeImg(IMG* pImg);
    friend void  AddImgWnd(IMG*, CImgWnd*);
    friend void  InvalImgRect(IMG* pImg, CRect* prc);
    friend void  CommitSelection(BOOL);

    private:
    short m_WheelDelta;
    };

BOOL FillBitmapObj(CImgWnd* pImgWnd, CBitmapObj* pResObject, IMG* pImgStruct,
        int iColor = -1);

extern CImgWnd*  g_pMouseImgWnd;
extern CImgWnd*  g_pDragBrushWnd;

extern CRect   rcDragBrush;

#endif // __IMGWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\imgwnd.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "tedit.h"
#include "t_text.h"
#include "t_fhsel.h"
#include "toolbox.h"
#include "undo.h"
#include "props.h"
#include "cmpmsg.h"
#include "imgdlgs.h"
#include "ferr.h"
#include "thumnail.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CImgWnd, CWnd)

#include "memtrace.h"

/***************************************************************************/
// helper fns

static CTedit *_GetTextEdit()
{
    if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

        if ((pTextTool != NULL) &&
            pTextTool->IsKindOf(RUNTIME_CLASS( CTextTool )))
            {
            CTedit* pTextEdit = pTextTool->GetTextEditField();

            if ((pTextEdit != NULL) &&
                pTextEdit->IsKindOf(RUNTIME_CLASS( CTedit )))
                {
                    return pTextEdit;
                }
            }
        }
    return NULL;
}

BOOL IsUserEditingText()
    {
    return (_GetTextEdit() != NULL);
    }

BOOL TextToolProcessed( UINT nMessage )
    {
    CTedit *pTextEdit = _GetTextEdit();
    if (pTextEdit)
        {
        pTextEdit->SendMessage( WM_COMMAND, nMessage );
        return TRUE;
        }
    return FALSE;
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CImgWnd, CWnd)
    ON_WM_CREATE()
#if 0
    ON_WM_DESTROY()
#endif
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    ON_WM_PAINT()
    ON_WM_SIZE()
    ON_WM_HSCROLL()
    ON_WM_VSCROLL()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_LBUTTONUP()
    ON_WM_RBUTTONDOWN()
    ON_WM_RBUTTONDBLCLK()
    ON_WM_RBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_KEYDOWN()
    ON_WM_KEYUP()
    ON_WM_TIMER()
    ON_WM_CANCELMODE()
    ON_WM_WINDOWPOSCHANGING()
    ON_WM_DESTROYCLIPBOARD()
    ON_WM_PALETTECHANGED()
    ON_WM_SETCURSOR()
    ON_WM_MOUSEWHEEL ()
END_MESSAGE_MAP()

/***************************************************************************/

CRect  rcDragBrush;

CImgBrush  theBackupBrush;

CImgWnd*  g_pMouseImgWnd  = NULL;
CImgWnd*  g_pDragBrushWnd = NULL;

// Current Image Viewer
CImgWnd*          CImgWnd::c_pImgWndCur     = NULL;
CDragger*         CImgWnd::c_pResizeDragger = NULL;
CTracker::STATE   CImgWnd::c_dragState      = CTracker::nil;

// Mouse Tracking Information
MTI   mti;
BOOL  bIgnoreMouse;

/***************************************************************************/

CImgWnd::CImgWnd(IMG* pImg)
    {
    m_pNextImgWnd = NULL;
    m_nZoom       = 1;
    m_nZoomPrev   = 4;
    m_xScroll     = 0;
    m_yScroll     = 0;
    m_LineX       = 1;
    m_LineY       = 1;
    m_ptDispPos.x = -1;
    m_ptDispPos.y = -1;
    c_pImgWndCur  = this;
    m_pwndThumbNailView = NULL;
    m_wClipboardFormat = 0;
    m_hPoints     = NULL;
    m_WheelDelta = 0;
    ASSERT(pImg != NULL);
    m_pImg = pImg;
    m_pImg->m_nLastChanged = -1;
    }

/***************************************************************************/

CImgWnd::CImgWnd(CImgWnd *pImgWnd)
    {
    m_pImg        = pImgWnd->m_pImg;
    m_pNextImgWnd = pImgWnd->m_pNextImgWnd;
    m_nZoom       = pImgWnd->m_nZoom;
    m_nZoomPrev   = pImgWnd->m_nZoomPrev;
    m_xScroll     = pImgWnd->m_xScroll,
    m_yScroll     = pImgWnd->m_yScroll;
    m_ptDispPos   = pImgWnd->m_ptDispPos;
    m_pwndThumbNailView = NULL;
    m_wClipboardFormat = 0;
    m_hPoints     = NULL;
    }

/***************************************************************************/

CImgWnd::~CImgWnd()
    {
    if (c_pImgWndCur == this)
        c_pImgWndCur = NULL;

    if (g_pMouseImgWnd == this)
        g_pMouseImgWnd = NULL;

    HideBrush();
    fDraggingBrush = FALSE;

    g_bBrushVisible = FALSE;

    if (g_pDragBrushWnd == this)
        {
        g_pDragBrushWnd = NULL;
        }

    if (m_hPoints)
        {
        ::GlobalFree( m_hPoints );
        m_hPoints = NULL;
        }
    }

/***************************************************************************/

BOOL CImgWnd::Create( DWORD dwStyle, const RECT& rect,
                      CWnd* pParentWnd, UINT nID)
    {
    static CString  sImgWndClass;

    if (sImgWndClass.IsEmpty())
        sImgWndClass = AfxRegisterWndClass( CS_DBLCLKS );

    ASSERT( ! sImgWndClass.IsEmpty() );

    dwStyle |= WS_CLIPSIBLINGS;

    return CWnd::Create( sImgWndClass, NULL, dwStyle, rect, pParentWnd, nID );
    }

/***************************************************************************/

int CImgWnd::OnCreate( LPCREATESTRUCT lpCreateStruct )
    {
    if (m_pImg)
        AddImgWnd( m_pImg, this );

    return CWnd::OnCreate(lpCreateStruct);
    }

/***************************************************************************/

#if 0
void CImgWnd::OnDestroy()
    {
    if (c_pImgWndCur == this)
        c_pImgWndCur = NULL;

    HideBrush();
    fDraggingBrush = FALSE;

    CWnd::OnDestroy();
    }
#endif

/***************************************************************************/

void CImgWnd::OnPaletteChanged(CWnd *pPaletteWnd)
{
#if 0
    // obviously this never gets hit or somebody would have realized by now...
    CImgWnd::OnPaletteChanged(pPaletteWnd);
#endif
    Invalidate();
}


/***************************************************************************/

BOOL CImgWnd::OnSetCursor(CWnd *pWnd, UINT nHitTest, UINT message)
{
        if (nHitTest==HTCLIENT && pWnd->m_hWnd==m_hWnd)
        {
                // We do our own cursor stuff in our own client area, but not in the
                // text box
                return(TRUE);
        }

        return((BOOL)Default());
}

/***************************************************************************/

void CImgWnd::OnWindowPosChanging( WINDOWPOS FAR* lpwndpos )
    {
    CWnd::OnWindowPosChanging( lpwndpos );
    }

/***************************************************************************/
// Image View Painting Functions
//

void CImgWnd::OnPaint()
    {
    CPaintDC dc(this);

    if (dc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency();
        return;
        }

    if (m_pImg == NULL)
        return;

    if (g_pMouseImgWnd == this)
        CImgTool::HideDragger( this );

    CPalette* ppalOld = SetImgPalette( &dc, FALSE );

    DrawBackground( &dc, (CRect*)&dc.m_ps.rcPaint );
    DrawImage     ( &dc, (CRect*)&dc.m_ps.rcPaint );
    DrawTracker   ( &dc, (CRect*)&dc.m_ps.rcPaint );

    if (g_pMouseImgWnd == this)
        CImgTool::ShowDragger( this );

    if (m_pwndThumbNailView != NULL)
        m_pwndThumbNailView->RefreshImage();

    if (ppalOld)
        dc.SelectPalette( ppalOld, FALSE );
    }

/***************************************************************************/

BOOL CImgWnd::OnCmdMsg( UINT nID, int nCode, void* pExtra,
                        AFX_CMDHANDLERINFO* pHandlerInfo )
    {
    if (nCode == CN_COMMAND)
        {
        switch (nID)
            {
            case IDMX_VS_PAGEUP:
                SendMessage( WM_VSCROLL, SB_PAGEUP, 0L );
                return TRUE;


            case IDMX_VS_PAGEDOWN:
                SendMessage( WM_VSCROLL, SB_PAGEDOWN, 0L );
                return TRUE;


            case IDMX_HS_PAGEUP:
                SendMessage( WM_HSCROLL, SB_PAGEUP, 0L );
                return TRUE;


            case IDMX_HS_PAGEDOWN:
                SendMessage( WM_HSCROLL, SB_PAGEDOWN, 0L );
                return TRUE;

            }

        CImgTool* pImgTool = CImgTool::FromID( nID );

        if (pImgTool != NULL)
            {
            pImgTool->Select();
            return TRUE;
            }
        }
    return CWnd::OnCmdMsg( nID, nCode, pExtra, pHandlerInfo );
    }


void CImgWnd::GetDrawRects(const CRect* pPaintRect, const CRect* pReqDestRect,
                CRect& srcRect, CRect& destRect)
{
        // Find the sub-rectangle of srcRect that corresponds to
        // the pPaintRect sub-rectangle of destRect.
        srcRect         = *pPaintRect;
        srcRect.right  += m_nZoom - 1;
        srcRect.bottom += m_nZoom - 1;

        ClientToImage( srcRect );

        srcRect.left = max(0, srcRect.left);
        srcRect.top  = max(0, srcRect.top );

        srcRect.right  = min(m_pImg->cxWidth , srcRect.right );
        srcRect.bottom = min(m_pImg->cyHeight, srcRect.bottom);

        if (pReqDestRect == NULL)
        {
                destRect = srcRect;
                ImageToClient( destRect );
        }
        else
        {
                destRect = *pReqDestRect;
        }
}


/***************************************************************************/
// Draw the actual image 'a bitmap'.  Drawing is
// optimized to only deal with the pixels inside paintRect.  This function
// reduces flashing by drawing the image and optional grid in an off-screen
// bitmap and then transfering that bitmap to the screen.
//
void CImgWnd::DrawImage( CDC* pDC, const CRect* pPaintRect,
                                         CRect* pDestRect, BOOL bDoGrid )
    {
    ASSERT(    pDC != NULL );
    ASSERT( m_pImg != NULL );

    CRect destRect;
    CRect srcRect;

    GetDrawRects(pPaintRect, pDestRect, srcRect, destRect);

    if (srcRect.Width() <= 0 || srcRect.Height() <= 0)
        {
        // Nothing to paint...
        return;
        }

    if (! IsGridVisible() && m_nZoom == 1)
        {
        // Optimize the easy case...  (Can't speed up magnified views
        // because of the bogus hack we have to do in StretchCopy.)

        if (theApp.m_pPalette
        && ((m_pImg->cPlanes * m_pImg->cBitCount) == 1))
            {
            pDC->SetTextColor( PALETTEINDEX( 0 ) );
            pDC->SetBkColor  ( PALETTEINDEX( 1 ) );
            }


        BitBlt(pDC->m_hDC, destRect.left   , destRect.top,
                           destRect.Width(), destRect.Height(),
              m_pImg->hDC,  srcRect.left   , srcRect.top, SRCCOPY);

        return;
        }

    CDC tempDC;
    CBitmap      tempBitmap;
    CBitmap* pOldTempBitmap;

    if (! tempDC.CreateCompatibleDC(pDC)
    ||  ! tempBitmap.CreateCompatibleBitmap(pDC, destRect.Width() + 1,
                                                 destRect.Height() + 1))
        {
        theApp.SetGdiEmergency(FALSE);
        return;
        }

    pOldTempBitmap = tempDC.SelectObject(&tempBitmap);

    ASSERT(pOldTempBitmap != NULL);

    CPalette* pOldPalette = SetImgPalette( &tempDC, FALSE ); // Background ??

    // If we're zoomed in, use COLORONCOLOR for easy pixel-by-pixel editing
    // Otherwise use HALFTONE for nice appearance
    if (m_nZoom < 2)
    {
        tempDC.SetStretchBltMode(HALFTONE);
    }
    else
    {
        tempDC.SetStretchBltMode(COLORONCOLOR);
    }


    if (m_pImg->cPlanes * m_pImg->cBitCount == 1)
        {
        tempDC.SetTextColor( RGB( 0x00, 0x00, 0x00 ));
        tempDC.SetBkColor  ( RGB( 0xFF, 0xFF, 0xFF ));
        }

    // Bitmaps...
    StretchCopy(tempDC.m_hDC, 0, 0, destRect.Width(), destRect.Height(),
                 m_pImg->hDC,       srcRect.left, srcRect.top,
                                    srcRect.Width(), srcRect.Height());
    // Draw the grid...
    if (IsGridVisible() && bDoGrid)
        DrawGrid( &tempDC, srcRect, destRect );

    // Transfer to the screen...
    pDC->BitBlt(destRect.left, destRect.top, destRect.Width(),
                               destRect.Height(), &tempDC, 0, 0, SRCCOPY);
    // Cleanup...
    if (pOldPalette)
        tempDC.SelectPalette( pOldPalette, FALSE ); // Background ??

    tempDC.SelectObject(pOldTempBitmap);
    }

/***************************************************************************/
// Draw a border and bevel around the image and fill the rest of
// the window with gray.  If pPaintRect is not NULL, painting is
// optimized to only draw with the rectangle.
//
void CImgWnd::DrawBackground(CDC* pDC, const CRect* pPaintRect)
    {
    ASSERT( pDC != NULL );

    CRect clientRect;

    if (pPaintRect == NULL)
        {
        // Draw everything...
        GetClientRect( &clientRect );
        pPaintRect = &clientRect;
        }

    CRect srcRect;
    CRect imageRect;

    GetDrawRects(pPaintRect, NULL, srcRect, imageRect);

    // Erase area around image, border, and bevel...
    CBrush* pOldBrush = pDC->SelectObject( GetSysBrush( COLOR_APPWORKSPACE ) );

    if (imageRect.top > pPaintRect->top)
        {
        // Top...

        pDC->PatBlt(pPaintRect->left, pPaintRect->top, pPaintRect->Width(),
                      imageRect.top - pPaintRect->top, PATCOPY);
        }

    if (imageRect.left > pPaintRect->left)
        {
        // Left...

        pDC->PatBlt(pPaintRect->left, imageRect.top,
            imageRect.left - pPaintRect->left, imageRect.Height(), PATCOPY);
        }

    if (imageRect.right < pPaintRect->right)
        {
        // Right...

        pDC->PatBlt(imageRect.right, imageRect.top,
            pPaintRect->right - imageRect.right, imageRect.Height(), PATCOPY);
        }

    if (imageRect.bottom < pPaintRect->bottom)
        {
        // Bottom...

        pDC->PatBlt(pPaintRect->left, imageRect.bottom, pPaintRect->Width(),
            pPaintRect->bottom - imageRect.bottom, PATCOPY);
        }

    pDC->SelectObject(pOldBrush);
    }

/***************************************************************************/

void CImgWnd::SetImg(IMG* pImg)
    {
    m_pNextImgWnd = pImg->m_pFirstImgWnd;
    pImg->m_pFirstImgWnd = this;
    m_pImg = pImg;
    }

/***************************************************************************/

CPalette* CImgWnd::SetImgPalette( CDC* pdc, BOOL bForce )
    {
    CPalette* ppal = NULL;

        // If we do not realize as a background brush when in-place, we can get
        // an infinite recursion of the container and us trying to realize the
        // palette
        if (theApp.m_pwndInPlaceFrame)
        {
                bForce = TRUE;
        }

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        {
        ppal = pdc->SelectPalette( theApp.m_pPalette, bForce );

        pdc->RealizePalette();
        }
    return ppal;
    }

/***************************************************************************/

HPALETTE CImgWnd::SetImgPalette( HDC hdc, BOOL bForce )
    {
    HPALETTE hpal = NULL;

        // If we do not realize as a background brush when in-place, we can get
        // an infinite recursion of the container and us trying to realize the
        // palette
        if (theApp.m_pwndInPlaceFrame)
        {
                bForce = TRUE;
        }

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        {
        hpal = ::SelectPalette( hdc, (HPALETTE)theApp.m_pPalette->m_hObject, bForce );

        ::RealizePalette( hdc );
        }
    return hpal;
    }

/***************************************************************************/

void CImgWnd::SetZoom(int nZoom)
    {
    if (m_nZoom > 1)
        m_nZoomPrev = m_nZoom;

    CommitSelection(TRUE);

    if (nZoom > 1)
        {
        // deselect the text tool if it's around
        CImgTool* pImgTool = CImgTool::GetCurrent();

        if (pImgTool != NULL && CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
            CImgTool::Select(IDMB_PENCILTOOL);
            }
        }

    HideBrush();
    SetupRubber( m_pImg );
    EraseTracker();
    theImgBrush.m_pImg = NULL;
    DrawTracker();

    CPBView* pView = (CPBView*)GetParent();

    if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        if (nZoom == 1)
            pView->HideThumbNailView();
        else
            pView->ShowThumbNailView();

        Invalidate(FALSE);

    m_nZoom = nZoom;
    }

/***************************************************************************/

void CImgWnd::SetScroll(int xPos, int yPos)
    {
    if (xPos > 0)
        xPos = 0;
    else
        if (xPos < -m_pImg->cxWidth)
            xPos = -m_pImg->cxWidth;

    if (yPos > 0)
        yPos = 0;
    else
        if (yPos < -m_pImg->cyHeight)
            yPos = -m_pImg->cyHeight;

    m_xScroll = xPos;
    m_yScroll = yPos;

    Invalidate( FALSE );

    CheckScrollBars();
    }

/***************************************************************************/

void CImgWnd::CheckScrollBars()
    {
    // Tacky recursion blocker is required because this is called from
    // the OnSize handler and turning scroll bars on or off changes
    // the size of our window...
    static BOOL  bInHere = FALSE;

    if (bInHere)
        return;

    bInHere = TRUE;

    int cxVScrollBar = GetSystemMetrics( SM_CXVSCROLL );
    int cyHScrollBar = GetSystemMetrics( SM_CYHSCROLL );

    // Figure the client area size if there were no scroll bars...
    CRect clientRect;

    GetClientRect( &clientRect );

    int cxWidth  = clientRect.Width();
    int cyHeight = clientRect.Height();

    BOOL hHasHBar = ((GetStyle() & WS_HSCROLL) != 0);
    BOOL bHasVBar = ((GetStyle() & WS_VSCROLL) != 0);

    if (hHasHBar)
        cyHeight += cyHScrollBar;

    if (bHasVBar)
        cxWidth += cxVScrollBar;

    // Figure the size of the thing we are scrolling (the subject)...
    CSize subjectSize;

    GetImgSize( m_pImg, subjectSize );

    int iTrackerSize = 2 * CTracker::HANDLE_SIZE;

    subjectSize.cx = (subjectSize.cx * m_nZoom ) + iTrackerSize;
    subjectSize.cy = (subjectSize.cy * m_nZoom ) + iTrackerSize;

    m_LineX = (subjectSize.cx + 31) / 32;
    m_LineY = (subjectSize.cy + 31) / 32;

    // Nasty loop takes care of case where we only need a vertical
    // scroll bar because we added a horizontal scroll bar and
    // vice versa...  (Will only ever loop twice.)
    BOOL bNeedHBar = FALSE;
    BOOL bNeedVBar = FALSE;
    BOOL bChange;

    do  {
        bChange = FALSE;

        if (! bNeedVBar && subjectSize.cy > cyHeight)
            {
            bChange   = TRUE;
            bNeedVBar = TRUE;
            cxWidth  -= cxVScrollBar;
            }

        if (! bNeedHBar && subjectSize.cx > cxWidth)
            {
            bChange   = TRUE;
            bNeedHBar = TRUE;
            cyHeight -= cyHScrollBar;
            }
        } while (bChange);

    SetRedraw( FALSE );

    SCROLLINFO si;

    si.cbSize = sizeof( si );
    si.fMask  = SIF_RANGE | SIF_PAGE | SIF_POS;
    si.nMin   = 0;

    // We subtract 1 because subjectSize is the size we want, so the range
    // should be 0 to subjectSize-1
    si.nMax   = (subjectSize.cx - 1) / m_nZoom;
    si.nPage  = cxWidth / m_nZoom;
    si.nPos   = -m_xScroll;
    SetScrollInfo( SB_HORZ, &si, FALSE );

    si.nMax   = (subjectSize.cy - 1) / m_nZoom;
    si.nPage  = cyHeight / m_nZoom;
    si.nPos   = -m_yScroll;
    SetScrollInfo( SB_VERT, &si, FALSE );

        si.fMask = SIF_POS;
        GetScrollInfo( SB_HORZ, &si );
        if ( -m_xScroll != si.nPos )
                m_xScroll = -si.nPos ;
        GetScrollInfo( SB_VERT, &si );
        if ( -m_yScroll != si.nPos )
                m_yScroll = -si.nPos;

    SetRedraw ( TRUE  );
    Invalidate( FALSE );

    bInHere = FALSE;
    }

/***************************************************************************/

void CImgWnd::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar*)
    {
    OnScroll(FALSE, nSBCode, nPos);
    }

/***************************************************************************/

void CImgWnd::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar*)
    {
    OnScroll(TRUE, nSBCode, nPos);
    }

/***************************************************************************/

void CImgWnd::OnScroll(BOOL bVert, UINT nSBCode, UINT nPos)
    {
    SCROLLINFO ScrollInfo;

    ScrollInfo.cbSize = sizeof( ScrollInfo );
    ScrollInfo.fMask  = SIF_RANGE | SIF_PAGE | SIF_POS;

    GetScrollInfo( (bVert? SB_VERT: SB_HORZ), &ScrollInfo );
        int iScroll = ScrollInfo.nPage/4;
    int iNewPos = ScrollInfo.nPos;

    switch (nSBCode)
        {
        case SB_TOP:
            iNewPos = 0;
            break;

        case SB_BOTTOM:
            iNewPos = ScrollInfo.nMax;
            break;

        case SB_LINEDOWN:
            iNewPos += iScroll;
            break;

        case SB_LINEUP:
            iNewPos -= iScroll;
            break;

        case SB_PAGEDOWN:
            iNewPos += iScroll * 4;
            break;

        case SB_PAGEUP:
            iNewPos -= iScroll * 4;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            iNewPos = nPos;
            break;
        }

    if (iNewPos < ScrollInfo.nMin)
        iNewPos = 0;
    else
        if (iNewPos > ScrollInfo.nMax-(int)ScrollInfo.nPage+1)
            iNewPos = ScrollInfo.nMax-(int)ScrollInfo.nPage+1;

    iScroll = -(iNewPos - ScrollInfo.nPos);
        Invalidate(FALSE);

    if (bVert)
        m_yScroll = -iNewPos;
    else
        m_xScroll = -iNewPos;

    ScrollInfo.fMask = SIF_POS;
    ScrollInfo.nPos  = iNewPos;
    SetScrollInfo( (bVert? SB_VERT: SB_HORZ), &ScrollInfo, TRUE );
    }

/***************************************************************************/
BOOL CImgWnd::OnMouseWheel (UINT nFlags, short zDelta, CPoint pt)
    {
    //
    // Don't handle zoom and datazoom.
    //

    if (nFlags & (MK_SHIFT | MK_CONTROL))
        {
        return FALSE;
        }

    int nBar;
    int *pScroll;

    if (GetWindowLong(GetSafeHwnd(), GWL_STYLE) & WS_VSCROLL)
    {
        nBar = SB_VERT;
        pScroll = &m_yScroll;
    }
    else
    {
        nBar = SB_HORZ;
        pScroll = &m_xScroll;
    }

    SCROLLINFO ScrollInfo;

    ScrollInfo.cbSize = sizeof( ScrollInfo );
    ScrollInfo.fMask  = SIF_RANGE | SIF_PAGE | SIF_POS;

    GetScrollInfo( nBar, &ScrollInfo );
    m_WheelDelta -= zDelta;
    if (abs(m_WheelDelta) >= WHEEL_DELTA)
        {
        int iScroll = ScrollInfo.nPage/4 * (m_WheelDelta/WHEEL_DELTA);
        int iNewPos = ScrollInfo.nPos + iScroll;


        if (iNewPos < ScrollInfo.nMin)
           iNewPos = 0;
        else if (iNewPos > ScrollInfo.nMax-(int)ScrollInfo.nPage+1)
           iNewPos = ScrollInfo.nMax-(int)ScrollInfo.nPage+1;

        Invalidate(FALSE);

        *pScroll = -iNewPos;

        ScrollInfo.fMask = SIF_POS;
        ScrollInfo.nPos  = iNewPos;
        SetScrollInfo( nBar, &ScrollInfo, TRUE );
        m_WheelDelta= m_WheelDelta % WHEEL_DELTA;
        CImgTool* pImgTool = CImgTool::GetCurrent();
        mti.ptPrev = mti.pt;
        mti.pt = pt;
        pImgTool->OnMove (this, &mti);
    }


    return TRUE;
    }
/***************************************************************************/

void CImgWnd::PrepareForBrushChange(BOOL bPickup, BOOL bErase)
    {
    if (theImgBrush.m_pImg != NULL
    &&  theImgBrush.m_bFirstDrag)
        {
        if (bPickup)
            PickupSelection();

        SetUndo(m_pImg);

        theImgBrush.m_bLastDragWasFirst = TRUE;
        theImgBrush.m_bFirstDrag        = FALSE;
        theImgBrush.m_rcDraggedFrom     = rcDragBrush;

        if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
            HideBrush();
            bErase = FALSE;
            }

        if (bErase)
            {
            // Clear the background...
            HideBrush();

            FillImgRect( m_pImg->hDC, &theImgBrush.m_rcDraggedFrom, crRight );

            CommitImgRect(m_pImg, &theImgBrush.m_rcDraggedFrom);
            InvalImgRect (m_pImg, &theImgBrush.m_rcDraggedFrom);

            FinishUndo(theImgBrush.m_rcDraggedFrom);

            MoveBrush(theImgBrush.m_rcSelection);
            }
        }
    }

/***************************************************************************/

void CImgWnd::OnCancelMode()
    {
    CmdCancel();
    }

/***************************************************************************/

void CImgWnd::CmdCancel()
    {
    // This will:
    //  Erase the size indicator on the status bar.
    //  Reset the mouse cursor to an arrow.
    //  Release the capture.
    //  Cancel (and undo) any drawing operation in progress.
    //  Cancel the Pick Color command if it's active.
    //  If there's a selection, will set to whole image and select prev tool
    ClearStatusBarSize();

    mti.fLeft = mti.fRight = FALSE;

    if (c_pResizeDragger != NULL)
        {
        EndResizeOperation();
        bIgnoreMouse = TRUE;
        return;
        }

    CImgTool* pImgTool = CImgTool::GetCurrent();

    if (GetCapture() == this || pImgTool->IsMultPtOpInProgress())
        {
        // Cancel dragging or multi-point operation in progress
        BOOL bWasMakingSelection = theImgBrush.m_bMakingSelection;

        ZoomedInDP(WM_CANCEL, 0, CPoint(0, 0));

        SetCursor(LoadCursor(NULL, IDC_ARROW + 11));

        if (! bWasMakingSelection)
            CancelPainting();

        bIgnoreMouse = TRUE;
        }
    else
        if (pImgTool->IsToggle()
        ||  CImgTool::GetCurrentID() == IDMB_PICKTOOL
        ||  CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL
        ||  CImgTool::GetCurrentID() == IDMZ_BRUSHTOOL
        ||  CImgTool::GetCurrentID() == IDMB_POLYGONTOOL
        ||  CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
            pImgTool->OnCancel( this );
            }

    if (GetKeyState( VK_LBUTTON ) < 0 || GetKeyState( VK_RBUTTON) < 0 )
        bIgnoreMouse = TRUE;

    SetToolCursor();
    }

/***************************************************************************/

void CImgWnd::CmdSel2Bsh()
    {
    if (! g_bCustomBrush)
        {
        if (theImgBrush.m_pImg == NULL)
            {
            // No selection, turn the whole image into a brush!
            MakeBrush( m_pImg->hDC, CRect( 0, 0, m_pImg->cxWidth,
                                                 m_pImg->cyHeight ) );
            }

        if (theImgBrush.m_bFirstDrag)
            {
            // Time to pick up the bits!
            ASSERT(theImgBrush.m_pImg == m_pImg);

            PickupSelection();
            }

        InvalImgRect(theImgBrush.m_pImg, NULL); // erase the selection tracker
        CImgTool::Select(IDMZ_BRUSHTOOL);
        SetCombineMode(combineMatte);

        g_bCustomBrush = TRUE;

        theImgBrush.m_pImg = NULL;
        theImgBrush.CenterHandle();
        }
    else
        if (CImgTool::GetCurrentID() == IDMZ_BRUSHTOOL)
            {
            CImgTool::GetCurrent()->OnCancel(this);
            }
    }

/***************************************************************************/
// Coordinate Translation and Calculation Functions
//
//
// Convert a point or rect in image view client coordinates to image
// coordinates taking magnification and scrolling into account.
//
void CImgWnd::ClientToImage(CPoint& point)
    {
    int iHandleSize = CTracker::HANDLE_SIZE;

    point.x = (point.x - iHandleSize) / m_nZoom - m_xScroll;
    point.y = (point.y - iHandleSize) / m_nZoom - m_yScroll;
    }

/***************************************************************************/

void CImgWnd::ClientToImage(CRect& rect)
    {
    ClientToImage(rect.TopLeft());
    ClientToImage(rect.BottomRight());
    }

/***************************************************************************/
// Convert a point or rect in image coordinates to image view client
// coordinates taking magnification and scrolling into account.
//
void CImgWnd::ImageToClient(CPoint& point)
    {
    int iHandleSize = CTracker::HANDLE_SIZE;

    point.x = (point.x + m_xScroll) * m_nZoom + iHandleSize;
    point.y = (point.y + m_yScroll) * m_nZoom + iHandleSize;
    }

/***************************************************************************/

void CImgWnd::ImageToClient(CRect& rect)
    {
    ImageToClient(rect.TopLeft());
    ImageToClient(rect.BottomRight());
    }

/***************************************************************************/
// Return a rectangle in image view coordinates surrounding the image
// taking magnification, scrolling, and the grid into account.

void CImgWnd::GetImageRect( CRect& imageRect )
    {
    imageRect.SetRect( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight );

    ImageToClient( imageRect );

    if (IsGridVisible())
        {
        imageRect.right  += 1;
        imageRect.bottom += 1;
        }
    }

/***************************************************************************/

CRect CImgWnd::GetDrawingRect( void )
    {
    CRect rectImage;
    CRect rectClient;

    GetImageRect (  rectImage );
    GetClientRect( &rectClient );

    rectImage &= rectClient;
    rectImage.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

    return ( rectImage );
    }

/***************************************************************************/

void CImgWnd::OnSetFocus(CWnd* pOldWnd)
    {
    if (m_pImg == NULL)
        {
        // Time to die...  (Our img was deleted, so we'll be disappearing
        // soon.  Don't bother to do any of the rest of this function...
        return;
        }

        Invalidate();
        BringWindowToTop(); // so updates happen here first

    if (c_pImgWndCur != this
    &&  c_pImgWndCur != NULL)
        c_pImgWndCur->EraseTracker();

    c_pImgWndCur = this;

    SelectImg( m_pImg );
        UpdateWindow();

    CWnd::OnSetFocus( pOldWnd );

    DrawTracker();
    }

/***************************************************************************/

void CImgWnd::OnKillFocus(CWnd* pNewWnd)
    {
        Invalidate();

    if (theImgBrush.m_pImg == NULL)
        HideBrush();

    if (GetCapture() == this)
        CmdCancel();

    CWnd::OnKillFocus(pNewWnd);
    }

/***************************************************************************/

void CImgWnd::OnSize(UINT nType, int cx, int cy)
    {
    CheckScrollBars();

    CWnd::OnSize(nType, cx, cy);
    }

/***************************************************************************/

BOOL CImgWnd::OnMouseDown(UINT nFlags)
    {
    if (GetFocus() != this)
        {
        SetFocus();
        SetActiveWindow();
        }

    if ((nFlags & (MK_LBUTTON | MK_RBUTTON)) == (MK_LBUTTON | MK_RBUTTON))
        {
        ClearStatusBarSize();

        BOOL bWasMakingSelection = theImgBrush.m_bMakingSelection;

        ZoomedInDP(WM_CANCEL, 0, CPoint(0, 0));

        SetCursor(LoadCursor(NULL, IDC_ARROW + 11));

        if (! bWasMakingSelection)
            CancelPainting();

        bIgnoreMouse = TRUE;
        return FALSE;
        }

    return TRUE;
    }

/***************************************************************************/

BOOL CImgWnd::OnMouseMessage( UINT nFlags )
    {
    if (bIgnoreMouse /*|| GetFocus() != this*/)
        {
        if ((nFlags & (MK_LBUTTON | MK_RBUTTON)) == 0)
            {
            bIgnoreMouse = FALSE;
            SetToolCursor();
            }
        else
            {
            SetCursor( LoadCursor( NULL, IDC_ARROW ) );
            }

        return FALSE;
        }

    if ((CImgTool::GetCurrentID() != IDMB_PICKTOOL)
    &&  (CImgTool::GetCurrentID() != IDMB_PICKRGNTOOL))
        SetupRubber(m_pImg);

    const MSG* pMsg = GetCurrentMessage();
    mti.fCtrlDown = (nFlags & MK_CONTROL);
    ZoomedInDP( pMsg->message, (DWORD)pMsg->wParam, CPoint( (DWORD)pMsg->lParam ) );

    return TRUE;
    }

/***************************************************************************/

void CImgWnd::OnLButtonDown( UINT nFlags, CPoint point )
    {
    CWnd::OnLButtonDown( nFlags, point );

    if (OnMouseDown( nFlags ))
        {
        OnMouseMessage( nFlags );
        }
    }

/***************************************************************************/

void CImgWnd::OnLButtonDblClk(UINT nFlags, CPoint point)
    {
    CRect rect;
    GetImageRect(rect);

    // When inside the image, a double click is the same as a single click
    OnLButtonDown(nFlags, point);
    }

/***************************************************************************/

void CImgWnd::OnLButtonUp(UINT nFlags, CPoint point)
    {
    CWnd::OnLButtonUp(nFlags, point);

    OnMouseMessage(nFlags);
    }

/***************************************************************************/

void CImgWnd::OnRButtonDown(UINT nFlags, CPoint point)
    {
    CWnd::OnRButtonDown(nFlags, point);

    if (OnMouseDown(nFlags))
        {
        OnMouseMessage(nFlags);
        }
    }


/***************************************************************************/

void CImgWnd::OnRButtonDblClk(UINT nFlags, CPoint point)
    {
    // A right button double click is the same as a right button single click
    OnRButtonDown(nFlags, point);
    }


/***************************************************************************/

void CImgWnd::OnRButtonUp(UINT nFlags, CPoint point)
    {
    CWnd::OnRButtonUp(nFlags, point);

    OnMouseMessage(nFlags);
    }


/***************************************************************************/

void CImgWnd::OnMouseMove(UINT nFlags, CPoint point)
    {
    CWnd::OnMouseMove(nFlags, point);

    if (g_pMouseImgWnd != this
    &&  g_pMouseImgWnd != NULL)
        {
        CImgTool::GetCurrent()->OnLeave( g_pMouseImgWnd, &mti );
        g_pMouseImgWnd = NULL;
        }

    ClientToImage( point );
    m_ptDispPos = point;

    if (g_pMouseImgWnd == NULL)
        {
        MTI mtiEnter;

        mtiEnter.pt        = point;
        mtiEnter.ptDown    = point;
        mtiEnter.ptPrev    = point;
        mtiEnter.fLeft     = FALSE;
        mtiEnter.fRight    = FALSE;
        mtiEnter.fCtrlDown = FALSE;

        CImgTool::GetCurrent()->OnEnter( g_pMouseImgWnd, &mtiEnter );

        g_pMouseImgWnd  = this;
        }
    OnMouseMessage( nFlags );
    }

/***************************************************************************/

void CImgWnd::OnTimer(UINT nIDEvent)
    {
    OnMouseMessage( 0 );
    }

/***************************************************************************/

void CImgWnd::SetToolCursor()
    {
    UINT nCursorID = CImgTool::GetCurrent()->GetCursorID();
    HCURSOR hCursor = NULL;

    if (nCursorID != 0)
        {
        hCursor = LoadCursor(nCursorID < 32512 ?
            AfxGetResourceHandle() : NULL, MAKEINTRESOURCE( nCursorID ));
        }

    SetCursor(hCursor);
    }


/***************************************************************************/

void CImgWnd::EndResizeOperation()
    {
    ReleaseCapture();
    delete c_pResizeDragger;
    c_pResizeDragger = NULL;
    c_dragState = CTracker::nil;
    ClearStatusBarSize();
    }


/***************************************************************************/

void CImgWnd::ResizeMouseHandler(unsigned code, CPoint imagePt)
    {
    CRect imageRect = c_pResizeDragger->m_rect;
    ClientToImage(imageRect);

    switch (code)
        {
        case WM_CANCEL:
            EndResizeOperation();
            return;

        case WM_LBUTTONUP:
            // resizing whole bitmap
            if  (m_pImg != theImgBrush.m_pImg
            &&   m_pwndThumbNailView)
                {
                m_pwndThumbNailView->Invalidate();
                }

            EndResizeOperation();

            if (theImgBrush.m_pImg == NULL)
                {
                // User was resizing the whole image...
                CPBView* pView = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();
                CPBDoc*  pDoc  = (pView == NULL)? NULL: pView->GetDocument();

                if (pDoc != NULL)
                    {
                    theUndo.BeginUndo( TEXT("Property Edit") );

                    if (GetKeyState( VK_SHIFT ) < 0)
                        pDoc->m_pBitmapObj->SetIntProp( P_Shrink, 1 );

                    theApp.m_sizeBitmap = imageRect.Size();

                    pDoc->m_pBitmapObj->SetSizeProp( P_Size, theApp.m_sizeBitmap );
                    pDoc->m_pBitmapObj->SetIntProp ( P_Shrink, 0 );

                    theUndo.EndUndo();
                    }
                }
            else
                {
                // User was resizing the selection...
                HideBrush();
                theImgBrush.SetSize( imageRect.Size(), TRUE );
                MoveBrush( imageRect );
                }
            return;

        case WM_MOUSEMOVE:
            switch (c_dragState)
                {
                default:
                    ASSERT(FALSE);

                case CTracker::resizingTop:
                    imageRect.top = imagePt.y;
                    if (imageRect.top >= imageRect.bottom)
                        imageRect.top = imageRect.bottom - 1;
                    break;

                case CTracker::resizingLeft:
                    imageRect.left = imagePt.x;
                    if (imageRect.left >= imageRect.right)
                        imageRect.left = imageRect.right - 1;
                    break;

                case CTracker::resizingRight:
                    imageRect.right = imagePt.x;
                    if (imageRect.right <= imageRect.left)
                        imageRect.right = imageRect.left + 1;
                    break;

                case CTracker::resizingBottom:
                    imageRect.bottom = imagePt.y;
                    if (imageRect.bottom <= imageRect.top)
                        imageRect.bottom = imageRect.top + 1;
                    break;

                case CTracker::resizingTopLeft:
                    imageRect.left = imagePt.x;
                    imageRect.top = imagePt.y;
                    if (imageRect.top >= imageRect.bottom)
                        imageRect.top = imageRect.bottom - 1;
                    if (imageRect.left >= imageRect.right)
                        imageRect.left = imageRect.right - 1;
                    break;

                case CTracker::resizingTopRight:
                    imageRect.top = imagePt.y;
                    imageRect.right = imagePt.x;
                    if (imageRect.top >= imageRect.bottom)
                        imageRect.top = imageRect.bottom - 1;
                    if (imageRect.right <= imageRect.left)
                        imageRect.right = imageRect.left + 1;
                    break;

                case CTracker::resizingBottomLeft:
                    imageRect.left = imagePt.x;
                    imageRect.bottom = imagePt.y;
                    if (imageRect.left >= imageRect.right)
                        imageRect.left = imageRect.right - 1;
                    if (imageRect.bottom <= imageRect.top)
                        imageRect.bottom = imageRect.top + 1;
                    break;

                case CTracker::resizingBottomRight:
                    imageRect.right = imagePt.x;
                    imageRect.bottom = imagePt.y;
                    if (imageRect.right <= imageRect.left)
                        imageRect.right = imageRect.left + 1;
                    if (imageRect.bottom <= imageRect.top)
                        imageRect.bottom = imageRect.top + 1;
                    break;
                }

            if (theImgBrush.m_pImg == NULL && m_pImg->m_bTileGrid)
                {
                // Snap to tile grid...

                int cxTile = m_pImg->m_cxTile;
                if (cxTile != 1 && cxTile <= m_pImg->cxWidth)
                    {
                    imageRect.right = ((imageRect.right + cxTile / 2) /
                        cxTile) * cxTile;
                    }

                int cyTile = m_pImg->m_cyTile;
                if (cyTile != 1 && cyTile <= m_pImg->cyHeight)
                    {
                    imageRect.bottom = ((imageRect.bottom + cyTile / 2) /
                        cyTile) * cyTile;
                    }
                }

            SetStatusBarSize(imageRect.Size());

            ImageToClient(imageRect);

            c_pResizeDragger->Move(imageRect, TRUE);
            break;
        }
    }


/***************************************************************************/

void CImgWnd::StartSelectionDrag(unsigned code, CPoint newPt)
    {
    theImgBrush.CopyTo(theBackupBrush);

    newPt.x /= m_nZoom;
    newPt.y /= m_nZoom;

    mti.pt = mti.ptDown = mti.ptPrev = newPt;

    SetCapture();
    SetCombineMode(theImgBrush.m_bOpaque ? combineReplace : combineMatte);

    if (theImgBrush.m_bFirstDrag)
        {
        ASSERT(theImgBrush.m_pImg == m_pImg);

        PickupSelection();
        }
    else
        if (! theImgBrush.m_bOpaque)
            theImgBrush.RecalcMask( crRight );

    theImgBrush.TopLeftHandle();
    theImgBrush.m_dragOffset = mti.pt - theImgBrush.m_rcSelection.TopLeft();

    EraseTracker();

    if (GetKeyState(VK_CONTROL) < 0)
        {
        // Copy the selection and start moving...

        if (theImgBrush.m_bFirstDrag)
            {
            // The first time, the bits are already in
            // the bitmap, so just copy them to the
            // selection (which has already been done).

            theImgBrush.m_bFirstDrag = FALSE;
            theImgBrush.m_bLastDragWasFirst = TRUE;
            }
        else
            {
            CommitSelection(TRUE);
            }

        theImgBrush.m_bMoveSel = TRUE;
        }
    else
        if (GetKeyState(VK_SHIFT) < 0)
            {
            // Start a smear operation...
            HideBrush();

            if (theImgBrush.m_bLastDragWasFirst)
                CommitSelection(TRUE);

            SetUndo(m_pImg);
            theImgBrush.m_bSmearSel = TRUE;
            theImgBrush.m_bFirstDrag = FALSE;
            theImgBrush.m_bLastDragWasFirst = TRUE;
            }
        else
            {
            // Start a move operation...
            theImgBrush.m_bMoveSel = TRUE;
            }

    g_bCustomBrush = TRUE;
    }

/***************************************************************************/

void CImgWnd::CancelSelectionDrag()
    {
    if (!theImgBrush.m_bSmearSel && !theImgBrush.m_bMoveSel)
        {
        TRACE(TEXT("Extraneous CancelSelectionDrag!\n"));
        return;
        }

    ReleaseCapture();

    theImgBrush.m_rcSelection = theImgBrush.m_rcDraggedFrom;

    theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
    g_bCustomBrush = FALSE;
    SetCombineMode(combineColor);

    theBackupBrush.CopyTo(theImgBrush);
    rcDragBrush = theImgBrush.m_rcSelection;
    rcDragBrush.right += 1;
    rcDragBrush.bottom += 1;

    CancelPainting();

    InvalImgRect(theImgBrush.m_pImg, NULL); // draw selection tracker

    // "Opaque" mode may have changed...
    if ((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
    ||  (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
        g_pImgToolWnd->InvalidateOptions(FALSE);

    // Cancel all the way now...
    theImgBrush.m_pImg = NULL;
    }


/***************************************************************************/

void CImgWnd::SelectionDragHandler(unsigned code, CPoint newPt)
    {
    switch (code)
        {
        case WM_CANCEL:
            CancelSelectionDrag();
            break;

        case WM_MOUSEMOVE:
            if (theImgBrush.m_bMoveSel)
                PrepareForBrushChange(FALSE);

            mti.ptPrev = mti.pt;
            mti.pt = newPt;

            theImgBrush.m_rcSelection.OffsetRect(
                        -theImgBrush.m_rcSelection.TopLeft()
                           + (CSize)mti.pt - theImgBrush.m_dragOffset);

            // Make sure the selection stays at least along the edge
            // of the actual image so we don't lose the tracker...
            if (theImgBrush.m_rcSelection.left > m_pImg->cxWidth)
                theImgBrush.m_rcSelection.OffsetRect(-theImgBrush.m_rcSelection.left + m_pImg->cxWidth, 0);
            if (theImgBrush.m_rcSelection.top > m_pImg->cyHeight)
                theImgBrush.m_rcSelection.OffsetRect(0, -theImgBrush.m_rcSelection.top + m_pImg->cyHeight);
            if (theImgBrush.m_rcSelection.right < 0)
                theImgBrush.m_rcSelection.OffsetRect(-theImgBrush.m_rcSelection.right, 0);
            if (theImgBrush.m_rcSelection.bottom < 0)
                theImgBrush.m_rcSelection.OffsetRect(0, -theImgBrush.m_rcSelection.bottom);

            if (theImgBrush.m_bSmearSel)
                DrawBrush(m_pImg, theImgBrush.m_rcSelection.TopLeft(), TRUE);
            else
                ShowBrush(theImgBrush.m_rcSelection.TopLeft());
            break;

        case WM_LBUTTONUP:
            theImgBrush.m_bLastDragWasASmear = theImgBrush.m_bSmearSel;

            if (theImgBrush.m_bSmearSel)
                {
                IMG* pImg = m_pImg;

                CommitSelection(FALSE);

                FinishUndo(CRect(0, 0, pImg->cxWidth, pImg->cyHeight));
                }
            ReleaseCapture();

            theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;

            g_bCustomBrush = FALSE;
            SetCombineMode(combineColor);

            InvalImgRect(theImgBrush.m_pImg, NULL); // draw selection tracker
            break;
        }
    }

/******************************************************************************/

BOOL CImgWnd::PtInTracker( CPoint cptLocation )
    {
    CRect selRect = theImgBrush.m_rcSelection;
    BOOL  bPtInTracker = FALSE;

    selRect.left   *= m_nZoom;
    selRect.top    *= m_nZoom;
    selRect.right  *= m_nZoom;
    selRect.bottom *= m_nZoom;

    selRect.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

    bPtInTracker = selRect.PtInRect( cptLocation );

    return bPtInTracker;
    }

/******************************************************************************/

void CImgWnd::OnRButtonDownInSel(CPoint *pcPointDown)
    {
    CMenu cMenuPopup;
    BOOL bRC = cMenuPopup.LoadMenu(IDR_SELECTION_POPUP);

    ASSERT(bRC);
    if (bRC)
        {
        CMenu *pcContextMenu = cMenuPopup.GetSubMenu(0);
        ASSERT(pcContextMenu != NULL);
        if (pcContextMenu != NULL)
            {
            CPoint cPointDown = *pcPointDown;
            ImageToClient(cPointDown);
            ClientToScreen(&cPointDown);

            CRect cRectClient;
            GetClientRect(&cRectClient);
            ClientToScreen(&cRectClient);

            // the frame actually has a clue about what items to enable...
            CWnd *notify = GetParentFrame();

            if (!notify)
                notify = GetParent(); // oh well...

            pcContextMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                cPointDown.x, cPointDown.y, notify, &cRectClient);
            }
        }
    }

/***************************************************************************/

void CImgWnd::ZoomedInDP(unsigned code, unsigned mouseKeys, CPoint newPt)
    {
    CPoint clientPt = newPt;
    CPoint imagePt  = clientPt;

    ClientToImage( imagePt );

    if (c_pResizeDragger != NULL)
        {
        ResizeMouseHandler( code, imagePt );
        return;
        }

    int iHandleSize = CTracker::HANDLE_SIZE;

    newPt.x -= iHandleSize + m_xScroll * m_nZoom;
    newPt.y -= iHandleSize + m_yScroll * m_nZoom;

//  AdjustPointForGrid(&newPt);

    IMG* pImg = m_pImg;

    int cxImage = pImg->cxWidth;
    int cyImage = pImg->cyHeight;

    CRect imageRect;

    GetImageRect( imageRect );

    // Check for selection manipulations...
    if (GetCapture() != this
    &&  c_pImgWndCur == this
    &&  theImgBrush.m_pImg == m_pImg)
        {
        CRect selRect = theImgBrush.m_rcSelection;
        BOOL bPtInTracker = FALSE;

        selRect.left   *= m_nZoom;
        selRect.top    *= m_nZoom;
        selRect.right  *= m_nZoom;
        selRect.bottom *= m_nZoom;

        selRect.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

        bPtInTracker = PtInTracker(newPt);

        if (bPtInTracker)
            {
            // Mouse is within the outer border of the tracker...


            // We don't set the rubber for every mouse message when the
            // selection tool is active, but we'd better set it up now!
            if (pRubberImg != m_pImg)
                SetupRubber(m_pImg);

            ClearStatusBarPosition();

            CTracker::STATE state;

            selRect.InflateRect( -CTracker::HANDLE_SIZE,
                                 -CTracker::HANDLE_SIZE );

            state = CTracker::HitTest(selRect, newPt, CTracker::nil);

            if (bPtInTracker && state == CTracker::nil)
                {
                // Actually inside the selection...
                SetCursor(theApp.LoadCursor(IDCUR_MOVE));

                if (code == WM_LBUTTONDOWN || code == WM_LBUTTONDBLCLK)
                    {
                    StartSelectionDrag(code, newPt);
                    }
                else
                    {
                    if (code == WM_RBUTTONDOWN || code == WM_RBUTTONDBLCLK)
                        // some of the menu commands don't work for free form selections
                        OnRButtonDownInSel( &imagePt );
                    }
                }
            else
                {
                // In the tracker frame...

                SetCursor(HCursorFromTrackerState(state));

                if (code == WM_LBUTTONDOWN || code == WM_LBUTTONDBLCLK)
                    {
                    // Start a resize operation...
                    SetCapture();
                    PrepareForBrushChange();

                    ASSERT(c_pResizeDragger == NULL);
                    CRect rect = theImgBrush.m_rcSelection;
                    ImageToClient(rect);

                    c_pResizeDragger = new CDragger(this, &rect);
                    ASSERT(c_pResizeDragger != NULL);
                    c_dragState = state;
                    }
                }

            return;
            }
        }

    if (! imageRect.PtInRect( clientPt )
    &&    code         != WM_CANCEL
    &&    GetCapture() == NULL)
        {
        // The mouse is not inside the image and we're not in any
        // special mode, so hide the brush...
        if (g_pDragBrushWnd    == this
        &&  theImgBrush.m_pImg == NULL)
            HideBrush();

        CRect selRect = imageRect;

        selRect.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

        if (theImgBrush.m_pImg != NULL || ! selRect.PtInRect( clientPt ))
            {
            // The mouse is not in the whole image tracker
            if (WM_LBUTTONDOWN == code)
            {
               if (CImgTool::GetCurrentID() != IDMX_TEXTTOOL)
               {
                  CmdCancel ();
               }

            }
            else
            {
               SetCursor( LoadCursor(NULL, IDC_ARROW ));
            }

            return;
            }

        // The mouse is in the whole image tracker, so set the cursor
        // as appropriate
        CTracker::STATE state = CTracker::nil;

        if (c_pImgWndCur == this)
            state = CTracker::HitTest(imageRect, clientPt, CTracker::nil);

        switch (state)
            {
            case CTracker::resizingTop:
            case CTracker::resizingLeft:
            case CTracker::resizingTopLeft:
            case CTracker::resizingTopRight:
            case CTracker::resizingBottomLeft:
               state = CTracker::nil;
               break;
            }

        SetCursor( HCursorFromTrackerState( state ) );

        // Handle mouse messages for tracker...
        if (state != CTracker::nil
        &&  (code == WM_LBUTTONDOWN || code == WM_LBUTTONDBLCLK))
            {
            SetCapture();

            ASSERT( c_pResizeDragger == NULL );

            c_pResizeDragger = new CDragger( this, &imageRect );

            ASSERT( c_pResizeDragger != NULL );

            c_dragState = state;
            }

        return;
        }

    newPt.x /= m_nZoom;
    newPt.y /= m_nZoom;

    if (! CImgTool::IsDragging())
        SetStatusBarPosition( m_ptDispPos );

    // Moving the selection??

    if (theImgBrush.m_bMoveSel
    ||  theImgBrush.m_bSmearSel)
        {
        SelectionDragHandler( code, newPt );

        return;
        }

    AdjustPointForGrid( &newPt );

    // Dispatch the event off to the current tool...

    CImgTool* pImgTool = CImgTool::GetCurrent();

    switch (code)
        {
        case WM_CANCEL:
            ReleaseCapture();
            pImgTool->OnCancel(this);
            mti.fLeft = mti.fRight = FALSE;
            break;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONDBLCLK:
            // We don't set the rubber for every mouse message when the
            // selection tool is active, but we'd better set it up now!
            if (pRubberImg != m_pImg)
                SetupRubber( m_pImg );

            mti.fLeft  = (code == WM_LBUTTONDOWN || code == WM_LBUTTONDBLCLK);
            mti.fRight = (code == WM_RBUTTONDOWN || code == WM_RBUTTONDBLCLK);

            mti.pt = mti.ptDown = mti.ptPrev = newPt;

            // if in the polygon tool, double clicks will end operation

            if (CImgTool::GetCurrentID() == IDMB_POLYGONTOOL
            &&  ((code == WM_LBUTTONDBLCLK) || (code == WM_RBUTTONDBLCLK)))
                {
                mti.ptPrev = mti.pt;
                mti.pt     = newPt;

                pImgTool->EndMultiptOperation(); // end the multipt operation
                pImgTool->OnEndDrag( this, &mti );

                mti.fLeft  = FALSE;
                mti.fRight = FALSE;

                break;
                }

            SetCapture();

            if (CImgTool::GetCurrentID() != IDMB_PICKRGNTOOL)
                HideBrush();

            if (pImgTool->IsUndoable())
                SetUndo(m_pImg);

            pImgTool->OnStartDrag( this, &mti );
            break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            mti.ptPrev = mti.pt;
            mti.pt     = newPt;

            if (GetCapture() != this)
                break;

            ReleaseCapture();

            pImgTool->CanEndMultiptOperation( &mti );
            pImgTool->OnEndDrag( this, &mti );

            if (code == WM_LBUTTONUP)
                {
                mti.fLeft = FALSE;
                }
            if (code == WM_RBUTTONUP)
                {
                mti.fRight = FALSE;
                }
            break;

        case WM_MOUSEMOVE:
            mti.ptPrev = mti.pt;
            mti.pt = newPt;

            if (mti.fLeft || mti.fRight)
                pImgTool->OnDrag(this, &mti);
            else
                pImgTool->OnMove(this, &mti);
            break;

        case WM_TIMER:
            pImgTool->OnTimer( this, &mti );
            break;
        }

    UpdateWindow(); // For immediate feedback in active window
    SetToolCursor();
    }

/***************************************************************************/

void CImgWnd::FinishUndo(const CRect& rectUndo)
    {
        if ( EnsureUndoSize(m_pImg) )
        m_pImg->m_pBitmapObj->FinishUndo(&rectUndo);
        else
        {
        TRACE(TEXT("Problem: Can NOT ensure undo capability!\n"));
        MessageBeep(0);
        }
    }

/***************************************************************************/

void CImgWnd::CancelPainting()
    {
    if (g_hUndoImgBitmap == NULL)
        return; // nothing to cancel!

    IMG*     pimg;
    HDC      hTempDC;
    HBITMAP  hOldBM;
    HPALETTE hOldPalette = NULL;

    pimg = m_pImg;

    if ((hTempDC = CreateCompatibleDC( pimg->hDC )) == NULL)
        {
        TRACE(TEXT("Not enough memory to undo!\n"));
        MessageBeep(0);
        return;
        }

    HideBrush();

    if (g_hUndoPalette)
        {
        if (pimg->m_hPalOld)
            {
            ::SelectPalette( pimg->hDC, pimg->m_hPalOld, FALSE );
            pimg->m_hPalOld = NULL;
            }

        if (pimg->m_pPalette)
            pimg->m_pPalette->DeleteObject();

        pimg->m_pPalette->Attach( g_hUndoPalette );
        g_hUndoPalette = NULL;

        pimg->m_hPalOld = ::SelectPalette( pimg->hDC,
                                 (HPALETTE)pimg->m_pPalette->GetSafeHandle(), FALSE );
        ::RealizePalette( pimg->hDC );
        }

    hOldBM = (HBITMAP)SelectObject( hTempDC, g_hUndoImgBitmap );

    if (pimg->m_pPalette)
        {
        hOldPalette = ::SelectPalette( hTempDC,
                            (HPALETTE)pimg->m_pPalette->GetSafeHandle(), FALSE );
        ::RealizePalette( hTempDC );
        }

    ASSERT( hOldBM != NULL );

    BitBlt( pimg->hDC, 0, 0, pimg->cxWidth, pimg->cyHeight, hTempDC, 0, 0, SRCCOPY );

    if (hOldPalette != NULL)
        ::SelectPalette( hTempDC,  hOldPalette, FALSE );

    SelectObject( hTempDC, hOldBM );
    DeleteDC    ( hTempDC );

    InvalImgRect ( m_pImg, NULL );
    CommitImgRect( m_pImg, NULL );
    }

#ifdef  GRIDOPTIONS
/***************************************************************************/

void CImgWnd::CmdGridOptions()
    {
    CImgGridDlg dlg;

    dlg.m_bPixelGrid = theApp.m_bShowGrid;
    dlg.m_bTileGrid  = m_pImg->m_bTileGrid;
    dlg.m_nWidth     = m_pImg->m_cxTile;
    dlg.m_nHeight    = m_pImg->m_cyTile;

    if (dlg.DoModal() != IDOK)
        return;

    // Hide the current is dependant on the state of the grid...

    BOOL bOldShowGrid = theApp.m_bShowGrid;
    theApp.m_bShowGrid = dlg.m_bPixelGrid;
    m_pImg->m_bTileGrid = dlg.m_bTileGrid;
    m_pImg->m_cxTile = dlg.m_nWidth;
    m_pImg->m_cyTile = dlg.m_nHeight;

    InvalImgRect(m_pImg, NULL);

    if (bOldShowGrid != theApp.m_bShowGrid)
        {
        if (c_pImgWndCur != NULL)
            c_pImgWndCur->Invalidate(FALSE); // Redraw tracker
        }
    }
#endif  // GRIDOPTIONS

/***************************************************************************/

void CImgWnd::CmdShowGrid()
    {
    // Hide the current cross hair since the width of the lines
    // is dependant on the state of the grid...
    theApp.m_bShowGrid = ! theApp.m_bShowGrid;

    InvalImgRect(m_pImg, NULL);

    if (c_pImgWndCur != NULL)
        c_pImgWndCur->Invalidate(FALSE); // Redraw tracker
    }

/***************************************************************************/
// Draw a grid over the image already in the bitmap in pDC.  Drawing
// is optimized by restricting it to destRect.
//
void CImgWnd::DrawGrid(CDC* pDC, const CRect& srcRect, CRect& destRect)
    {
    ASSERT(pDC != NULL);
    ASSERT(m_pImg != NULL);

    pDC->SetTextColor(RGB(192, 192, 192));
    pDC->SetBkColor(RGB(128, 128, 128));

    CBrush* pOldBrush = pDC->SelectObject(GetHalftoneBrush());

    CRect gridRect(0, 0, m_pImg->cxWidth * m_nZoom + 1,
        m_pImg->cyHeight * m_nZoom + 1);

    for (int x = gridRect.left; x <= gridRect.right; x += m_nZoom)
        pDC->PatBlt(x, gridRect.top, 1, gridRect.Height(), PATCOPY);

    for (int y = gridRect.top; y <= gridRect.bottom; y += m_nZoom)
        pDC->PatBlt(gridRect.left, y, gridRect.Width(), 1, PATCOPY);

    if (m_pImg->m_bTileGrid)
        {
        pDC->SetTextColor(RGB(0, 0, 255));
        pDC->SetBkColor(RGB(0, 0, 128));

        int nWidth = destRect.Width();
        int nHeight = destRect.Height();
        int nStep;

        if (m_pImg->m_cxTile > 1 && m_pImg->m_cxTile <= m_pImg->cxWidth)
            {
            nStep = m_nZoom * m_pImg->m_cxTile;
            for (x = (m_pImg->m_cxTile - srcRect.left % m_pImg->m_cxTile -
                m_pImg->m_cxTile) * m_nZoom; x <= nWidth; x += nStep)
                {
                pDC->PatBlt(x, 0, 1, nHeight, PATCOPY);
                }
            }

        if (m_pImg->m_cyTile > 1 && m_pImg->m_cyTile <= m_pImg->cyHeight)
            {
            nStep = m_nZoom * m_pImg->m_cyTile;
            for (y = (m_pImg->m_cyTile - srcRect.top % m_pImg->m_cyTile -
            m_pImg->m_cyTile) * m_nZoom; y <= nHeight; y += nStep)
                {
                pDC->PatBlt(0, y, nWidth, 1, PATCOPY);
                }
            }
        }

    pDC->SelectObject(pOldBrush);

    destRect.right += 1;
    destRect.bottom += 1;
    }

#ifdef  GRIDOPTIONS
/***************************************************************************/

void CImgWnd::CmdShowTileGrid()
    {
    extern BOOL  g_bDefaultTileGrid;
    // If neither grid is visible, show both.  Otherwise leave the pixel
    // grid alone and toggle the tile grid.

    if (! theApp.m_bShowGrid)
        {
        m_pImg->m_bTileGrid = TRUE;
        theApp.m_bShowGrid = TRUE;
        }
    else
        {
        m_pImg->m_bTileGrid = !m_pImg->m_bTileGrid;
        }

    g_bDefaultTileGrid = m_pImg->m_bTileGrid;

    InvalImgRect(m_pImg, NULL);

    if (c_pImgWndCur != NULL)
        c_pImgWndCur->Invalidate(FALSE); // Redraw tracker
    }
#endif  // GRIDOPTIONS

/***************************************************************************/

void CImgWnd::MoveBrush( const CRect& newSelRect )
    {
    if (! theImgBrush.m_pImg)
        return;

    theImgBrush.m_rcSelection = newSelRect;
    InvalImgRect( theImgBrush.m_pImg, NULL );


    theImgBrush.m_handle.cx = theImgBrush.m_handle.cy = 0;

    BOOL bOldCustomBrush = g_bCustomBrush;

    g_bCustomBrush = TRUE;

    int wOldCombineMode = wCombineMode;

    SetCombineMode( theImgBrush.m_bOpaque ? combineReplace : combineMatte );
    ShowBrush( theImgBrush.m_rcSelection.TopLeft() );

    g_bCustomBrush = bOldCustomBrush;

    SetCombineMode( wOldCombineMode );
    }

/***************************************************************************/

BOOL CImgWnd::MakeBrush( HDC hSourceDC, CRect rcSource )
    {
    int       cxWidth;
    int       cyHeight;
    int       iToolID = CImgTool::GetCurrentID();


    if (rcSource.IsRectEmpty())
        {
        ASSERT( FALSE );

        return FALSE;
        }

    theImgBrush.m_size = rcSource.Size();

    cxWidth  = theImgBrush.m_size.cx;
    cyHeight = theImgBrush.m_size.cy;

    if (theImgBrush.m_hbmOld)
        ::SelectObject( theImgBrush.m_dc.m_hDC, theImgBrush.m_hbmOld );

    if (theImgBrush.m_hbmMaskOld)
        ::SelectObject( theImgBrush.m_dc.m_hDC, theImgBrush.m_hbmMaskOld );

    theImgBrush.m_hbmOld     = NULL;
    theImgBrush.m_hbmMaskOld = NULL;

    theImgBrush.m_dc.DeleteDC();
    theImgBrush.m_bitmap.DeleteObject();
    theImgBrush.m_maskDC.DeleteDC();
    theImgBrush.m_maskBitmap.DeleteObject();

    CDC* pdcSource = CDC::FromHandle( hSourceDC );
    CDC* pdcBitmap = CDC::FromHandle( m_pImg->hDC );

    if (! theImgBrush.m_bitmap.CreateCompatibleBitmap( pdcBitmap, cxWidth, cyHeight )
    ||  ! theImgBrush.m_dc.CreateCompatibleDC        ( pdcBitmap )
    ||  ! theImgBrush.m_maskBitmap.CreateBitmap      (            cxWidth, cyHeight, 1, 1, NULL)
    ||  ! theImgBrush.m_maskDC.CreateCompatibleDC    ( pdcBitmap ))
        {
        theApp.SetGdiEmergency();
        return FALSE;
        }

    theImgBrush.m_pImg       = m_pImg;
    theImgBrush.m_hbmOld     = (HBITMAP)((theImgBrush.m_dc.SelectObject(
                                         &theImgBrush.m_bitmap ))->GetSafeHandle());
    theImgBrush.m_hbmMaskOld = (HBITMAP)((theImgBrush.m_maskDC.SelectObject(
                                         &theImgBrush.m_maskBitmap ))->GetSafeHandle());

    CPalette* pcOldPalette = SetImgPalette( &theImgBrush.m_dc, FALSE );

    if (iToolID == IDMB_PICKRGNTOOL)
        {
        // Using StretchBlt to ensure palette mapping occurs
        TRY {
            CBrush cBrushWhite( PALETTERGB( 0xff, 0xff, 0xff ) );
            CRect  cRectTmp( 0, 0, cxWidth, cyHeight );

            theImgBrush.m_dc.FillRect( &cRectTmp, &cBrushWhite );
            }
        CATCH(CResourceException, e)
            {
            theApp.SetGdiEmergency();
            return FALSE;
            }
        END_CATCH

        if (theImgBrush.m_cRgnPolyFreeHandSel.GetSafeHandle())
            theImgBrush.m_dc.FillRgn( &theImgBrush.m_cRgnPolyFreeHandSel,
                                      CBrush::FromHandle( (HBRUSH)::GetStockObject( BLACK_BRUSH ) ) );

        theImgBrush.m_dc.StretchBlt( 0, 0, cxWidth, cyHeight,
                                        pdcSource,
                                        rcSource.left, rcSource.top,
                                        cxWidth, cyHeight, SRCERASE);
        }
    else
        {
        // Using StretchBlt to ensure palette mapping occurs
        theImgBrush.m_dc.StretchBlt( 0, 0, cxWidth, cyHeight,
                                           pdcSource,
                                           rcSource.left, rcSource.top,
                                           cxWidth, cyHeight, SRCCOPY );
        }

    theImgBrush.RecalcMask( crRight );

    if (pcOldPalette)
        theImgBrush.m_dc.SelectPalette( pcOldPalette, FALSE );

    theImgBrush.m_rcSelection = rcSource;

    rcSource.right  += 1;
    rcSource.bottom += 1;

    InvalImgRect( m_pImg, NULL ); // Redraw selection tracker

    rcDragBrush     = rcSource;
    g_bBrushVisible = TRUE;
    g_pDragBrushWnd = this;

    theImgBrush.m_bFirstDrag        = TRUE;
    theImgBrush.m_bLastDragWasFirst = FALSE;

    return TRUE;
    }

/***************************************************************************/

void CImgWnd::CmdClear()
    {
    if (TextToolProcessed( ID_EDIT_CLEAR ))
        return;

    HPALETTE hOldPalette = NULL;
    HBRUSH hNewBrush, hOldBrush;
    IMG* pImg = m_pImg;

    if ((hNewBrush = CreateSolidBrush( crRight )) == NULL)
        {
        theApp.SetGdiEmergency();
        return;
        }

    HideBrush();

    CRect clearRect;

    if (theImgBrush.m_pImg == NULL)
        clearRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
    else
        {
        clearRect         = rcDragBrush;
        clearRect.right  -= 1;
        clearRect.bottom -= 1;
        }

    BOOL bUndo = FALSE;

    if (!theImgBrush.m_pImg || theImgBrush.m_bFirstDrag
            || theImgBrush.m_bCuttingFromImage)
        {
        bUndo = TRUE;
        SetUndo(m_pImg);

        if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
            {
            int     iPoints;
            CPoint* pptArray;
            BOOL    bData = ((CFreehandSelectTool*)CImgTool::GetCurrent())->CopyPointsToMemArray( &pptArray, &iPoints );
            if (bData && iPoints)
                {

                HRGN hrgn = ::CreatePolygonRgn( pptArray, iPoints, ALTERNATE );

                if (hrgn)
                    ::FillRgn( pImg->hDC, hrgn, hNewBrush );

                delete [] pptArray;
                }
            else
                {
                DeleteObject ( hNewBrush );
                theApp.SetMemoryEmergency();
                return;
                }
            }
        else
            {
            hOldBrush = (HBRUSH)SelectObject(pImg->hDC, hNewBrush);

            PatBlt( pImg->hDC, clearRect.left,
                            clearRect.top,
                            clearRect.Width(),
                            clearRect.Height(), PATCOPY );
            SelectObject( pImg->hDC, hOldBrush );
            }
        }

    InvalImgRect ( m_pImg, &clearRect );
    CommitImgRect( m_pImg, &clearRect );

    if (bUndo)
        FinishUndo(clearRect);

    DirtyImg     ( m_pImg );
    DeleteObject ( hNewBrush );

    // If we have a selection, nuke it since it's useless now...
    if (theImgBrush.m_pImg != NULL)
        {
        if (theImgBrush.m_bLastDragWasFirst)
            {
            theImgBrush.m_bLastDragWasFirst = FALSE;
            FinishUndo(theImgBrush.m_rcDraggedFrom);
            }

        theImgBrush.m_handle.cx = 0;
        theImgBrush.m_handle.cy = 0;
        theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
        g_bCustomBrush = FALSE;
        SetCombineMode(combineColor);

        InvalImgRect(theImgBrush.m_pImg, NULL);  // redraw selection
        theImgBrush.m_pImg = NULL;
        }
    }


/***************************************************************************/

void CImgWnd::CmdFlipBshH()
    {
    IMG* pImg = m_pImg;

    HideBrush();

    CRect flipRect;

    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        {
        flipRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
        }
    else
        {
        flipRect = rcDragBrush;
        flipRect.right -= 1;
        flipRect.bottom -= 1;
        }

    if (  theImgBrush.m_pImg != NULL
    &&  ! theImgBrush.m_bFirstDrag || g_bCustomBrush)
        {
        CPalette* ppal = SetImgPalette( &theImgBrush.m_dc, FALSE );
        //
        // Don't do halftone blts when just moving bits around
        //
        theImgBrush.m_dc.SetStretchBltMode (COLORONCOLOR);

        StretchCopy(theImgBrush.m_dc.m_hDC, 0, 0,
                    theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy,
                    theImgBrush.m_dc.m_hDC,
                    theImgBrush.m_size.cx - 1, 0,
                   -theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy);

        StretchCopy(theImgBrush.m_maskDC.m_hDC, 0, 0,
                    theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy,
                    theImgBrush.m_maskDC.m_hDC,
                    theImgBrush.m_size.cx - 1, 0,
                   -theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy);

        if (ppal)
            theImgBrush.m_dc.SelectPalette( ppal, FALSE ); // Background ??

        MoveBrush(theImgBrush.m_rcSelection);
        }
    else
        {
        SetUndo(m_pImg);
        SetStretchBltMode (pImg->hDC, COLORONCOLOR);
        StretchCopy(pImg->hDC, flipRect.left,
                               flipRect.top,
                               flipRect.Width(),
                               flipRect.Height(),
                    pImg->hDC, flipRect.left + flipRect.Width() - 1,
                               flipRect.top,
                              -flipRect.Width(),
                               flipRect.Height());

        InvalImgRect (m_pImg, &flipRect);
        CommitImgRect(m_pImg, &flipRect);
        FinishUndo   (flipRect);
        DirtyImg     (m_pImg);
        }
    }

/***************************************************************************/

void CImgWnd::CmdFlipBshV()
    {
    IMG* pImg = m_pImg;

    HideBrush();

    CRect flipRect;

    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        {
        flipRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
        }
    else
        {
        flipRect = rcDragBrush;
        flipRect.right -= 1;
        flipRect.bottom -= 1;
        }

    if (  theImgBrush.m_pImg != NULL
    &&  ! theImgBrush.m_bFirstDrag || g_bCustomBrush)
        {
        CPalette* ppal = SetImgPalette( &theImgBrush.m_dc, FALSE ); // Background ??
        theImgBrush.m_dc.SetStretchBltMode (COLORONCOLOR);
        StretchCopy(theImgBrush.m_dc.m_hDC, 0, 0,
                    theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy,
                    theImgBrush.m_dc.m_hDC, 0,
                    theImgBrush.m_size.cy - 1,
                    theImgBrush.m_size.cx,
                   -theImgBrush.m_size.cy);

        StretchCopy(theImgBrush.m_maskDC.m_hDC, 0, 0,
                    theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy,
                    theImgBrush.m_maskDC.m_hDC, 0,
                    theImgBrush.m_size.cy - 1,
                    theImgBrush.m_size.cx,
                   -theImgBrush.m_size.cy);

        if (ppal)
            theImgBrush.m_dc.SelectPalette( ppal, FALSE ); // Background ??

        MoveBrush(theImgBrush.m_rcSelection);
        }
    else
        {
        SetUndo(m_pImg);
        SetStretchBltMode (pImg->hDC, COLORONCOLOR);
        StretchCopy(pImg->hDC, flipRect.left,    flipRect.top,
                               flipRect.Width(), flipRect.Height(),
                    pImg->hDC, flipRect.left,    flipRect.top + flipRect.Height() - 1,
                               flipRect.Width(), -flipRect.Height());

        InvalImgRect (m_pImg, &flipRect);
        CommitImgRect(m_pImg, &flipRect);
        FinishUndo   (flipRect);
        DirtyImg     (m_pImg);
        }
    }

/***************************************************************************/

void CImgWnd::CmdDoubleBsh()
    {
    if (!g_bCustomBrush && theImgBrush.m_pImg == NULL)
        {
        MessageBeep(0);
        return;
        }

    PrepareForBrushChange(TRUE, FALSE);

    CRect rc  =           theImgBrush.m_rcSelection;
    rc.left  -=           theImgBrush.m_size.cx / 2;
    rc.right  = rc.left + theImgBrush.m_size.cx * 2;
    rc.top   -=           theImgBrush.m_size.cy / 2;
    rc.bottom = rc.top  + theImgBrush.m_size.cy * 2;

    HideBrush();

    theImgBrush.SetSize( CSize( theImgBrush.m_size.cx * 2,
                                theImgBrush.m_size.cy * 2 ) );
    MoveBrush(rc);

    if (g_bCustomBrush)
        theImgBrush.CenterHandle();
    }

/***************************************************************************/

void CImgWnd::CmdHalfBsh()
    {
    if (! g_bCustomBrush
    &&  ! theImgBrush.m_pImg)
        {
        MessageBeep(0);
        return;
        }

    PrepareForBrushChange( TRUE, FALSE );

    CRect rc  =            theImgBrush.m_rcSelection;
    rc.left  +=            theImgBrush.m_size.cx / 4;
    rc.right  = rc.left + (theImgBrush.m_size.cx + 1) / 2;
    rc.top   +=            theImgBrush.m_size.cy / 4;
    rc.bottom = rc.top  + (theImgBrush.m_size.cy + 1) / 2;

    HideBrush();

    theImgBrush.SetSize( CSize( (theImgBrush.m_size.cx + 1) / 2,
                                (theImgBrush.m_size.cy + 1) / 2 ) );
    MoveBrush( rc );

    if (g_bCustomBrush)
        theImgBrush.CenterHandle();
    }

/***************************************************************************/

CPalette* CImgWnd::FixupDibPalette( LPSTR lpDib, CPalette* ppalDib )
    {
    CPBView* pView = (CPBView*)GetParent();
    CPBDoc*  pDoc  = pView->GetDocument();

    if (pDoc == NULL || lpDib == NULL || ppalDib == NULL || pDoc->m_pBitmapObj->m_pImg == NULL)
        return ppalDib;

    IMG* pImg         = pDoc->m_pBitmapObj->m_pImg;
    int  iColorBits   = pImg->cBitCount * pImg->cPlanes;
    BOOL bFixupDib    = TRUE;
    BOOL bSwapPalette = TRUE;

    // only if dealing with palettes
    if (iColorBits != 8)
        return ppalDib;

    CPalette* ppalPic = theApp.m_pPalette;
    CPalette* ppalNew = NULL;
        BOOL      bMergedPalette = FALSE;

    if (ppalPic)
        {
        int iAdds;

        if ( ppalNew = MergePalettes( ppalPic, ppalDib, iAdds ) )
                        bMergedPalette = TRUE;

        if (ppalNew)
            {
            if (! iAdds)
                {
                bSwapPalette = FALSE;
                                if ( bMergedPalette )
                                        {
                                        delete ppalNew;
                                        ppalNew = FALSE;
                                        bMergedPalette = FALSE;
                                        }
                ppalNew = ppalPic;
                }
            }
        else
            {
            bSwapPalette = FALSE;
                        if ( bMergedPalette )
                                {
                                delete ppalNew;
                                ppalNew = FALSE;
                                bMergedPalette = FALSE;
                                }
            ppalNew = ppalPic;
            }
        }
    else
        {
                if ( bMergedPalette )
                        {
                        delete ppalNew;
                        ppalNew = FALSE;
                        bMergedPalette = FALSE;
                        }
        ppalNew   = ppalDib;
        bFixupDib = FALSE;
        }

    if (bFixupDib)
        {
        LOGPALETTE256    palette;
        COLORREF         crCurColor;
        UINT             uColorIndex;
        int              iDibColors   = DIBNumColors( lpDib );
        BOOL             bWinStyleDIB = IS_WIN30_DIB( lpDib );
        LPBITMAPINFO     lpDibInfo    = (LPBITMAPINFO)lpDib;
        LPBITMAPCOREINFO lpCoreInfo   = (LPBITMAPCOREINFO)lpDib;

        palette.palVersion    = 0x300;
        palette.palNumEntries = (WORD)ppalNew->GetPaletteEntries( 0, 256,
                                                              &palette.palPalEntry[0] );
                                ppalNew->GetPaletteEntries( 0, palette.palNumEntries,
                                                              &palette.palPalEntry[0] );
        for (int iLoop = 0; iLoop < iDibColors; iLoop++)
            {
            if (bWinStyleDIB)
                {
                crCurColor = PALETTERGB( lpDibInfo->bmiColors[iLoop].rgbRed,
                                         lpDibInfo->bmiColors[iLoop].rgbGreen,
                                         lpDibInfo->bmiColors[iLoop].rgbBlue );
                }
            else
                {
                crCurColor = PALETTERGB( lpCoreInfo->bmciColors[iLoop].rgbtRed,
                                         lpCoreInfo->bmciColors[iLoop].rgbtGreen,
                                         lpCoreInfo->bmciColors[iLoop].rgbtBlue );
                }
            uColorIndex = ppalNew->GetNearestPaletteIndex( crCurColor );

            if (bWinStyleDIB)
                {
                lpDibInfo->bmiColors[iLoop].rgbRed   = palette.palPalEntry[uColorIndex].peRed;
                lpDibInfo->bmiColors[iLoop].rgbGreen = palette.palPalEntry[uColorIndex].peGreen;
                lpDibInfo->bmiColors[iLoop].rgbBlue  = palette.palPalEntry[uColorIndex].peBlue;
                }
            else
                {
                lpCoreInfo->bmciColors[iLoop].rgbtRed   = palette.palPalEntry[uColorIndex].peRed;
                lpCoreInfo->bmciColors[iLoop].rgbtGreen = palette.palPalEntry[uColorIndex].peGreen;
                lpCoreInfo->bmciColors[iLoop].rgbtBlue  = palette.palPalEntry[uColorIndex].peBlue;
                }
            }
        if (! bSwapPalette)
                        {
                        if ( bMergedPalette )
                                {
                                delete ppalNew;
                                bMergedPalette = FALSE;
                                }
            ppalNew = NULL;
                        }
        }

    if (bSwapPalette)
        {
        if (pImg->m_hPalOld)
            {
            ::SelectPalette( pImg->hDC, pImg->m_hPalOld, FALSE );
            pImg->m_hPalOld = NULL;
            }

        if (pImg->m_pPalette)
            delete pImg->m_pPalette;

        pImg->m_pPalette = ppalNew;
        pImg->m_hPalOld  = ::SelectPalette( pImg->hDC,
                                     (HPALETTE)ppalNew->GetSafeHandle(), FALSE );
        ::RealizePalette( pImg->hDC );
        InvalImgRect( pImg, NULL );

        // Return NULL since we swapped the new palette into the pImg!
        ppalNew = NULL;

        theApp.m_pPalette = pImg->m_pPalette;

        //
        // now that we changed the app palette update the DIB Section
        // color table too.
        //
        DWORD rgb[256];
        int i,n;

        n = theApp.m_pPalette->GetPaletteEntries(0, 256, (LPPALETTEENTRY)rgb);
        for (i=0; i<n; i++)
            rgb[i] = RGB(GetBValue(rgb[i]),GetGValue(rgb[i]),GetRValue(rgb[i]));
        SetDIBColorTable(pImg->hDC, 0, n, (LPRGBQUAD)rgb);
        }

        // Delete any orphaned ppalDib pointers.
        if ( ppalDib && ppalDib != ppalNew )
                delete ppalDib;

    return ppalNew;
    }

/***************************************************************************/

void CImgWnd::ShowBrush(CPoint ptHandle)
    {
    IMG * pimg = m_pImg;

    HideBrush();

    COLORREF crRealLeftColor;
    COLORREF crRealRightColor;

    int nStrokeWidth = CImgTool::GetCurrent()->GetStrokeWidth();
    int nStrokeShape = CImgTool::GetCurrent()->GetStrokeShape();

    if (CImgTool::GetCurrentID() == IDMB_ERASERTOOL)
        {
        crRealRightColor = crRight;
        crRealLeftColor  = crLeft;

        crLeft = crRight;
        }

    g_pDragBrushWnd = this;

    if (g_bCustomBrush)
        {
        int nCombineMode = (theImgBrush.m_bOpaque) ? combineReplace : combineMatte;

        rcDragBrush.SetRect(ptHandle.x, ptHandle.y,
                            ptHandle.x + theImgBrush.m_size.cx,
                            ptHandle.y + theImgBrush.m_size.cy);
        rcDragBrush -= (CPoint)theImgBrush.m_handle;

        theImgBrush.m_rcSelection = rcDragBrush;
        rcDragBrush.right  += 1;
        rcDragBrush.bottom += 1;

        if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
//          extern CTextTool g_textTool;
//          g_textTool.Render(CDC::FromHandle(pimg->hDC),
//                          rcDragBrush, TRUE, FALSE);
            }
        else
            {
            switch (nCombineMode)
                {
                case combineColor:
                    theImgBrush.BltColor(pimg, rcDragBrush.TopLeft(), crLeft);
                    break;

                case combineMatte:
                    theImgBrush.BltMatte(pimg, rcDragBrush.TopLeft());
                    break;

                case combineReplace:
                    theImgBrush.BltReplace(pimg, rcDragBrush.TopLeft());
                    break;
                }
            }

        InvalImgRect(m_pImg, &rcDragBrush);
        }
    else
        {
        DrawImgLine(m_pImg, ptHandle, ptHandle, crLeft,
                                          nStrokeWidth, nStrokeShape, FALSE);
        rcDragBrush.left   = ptHandle.x - nStrokeWidth / 2;
        rcDragBrush.top    = ptHandle.y - nStrokeWidth / 2;
        rcDragBrush.right  = rcDragBrush.left + nStrokeWidth;
        rcDragBrush.bottom = rcDragBrush.top  + nStrokeWidth;
        }

    if (CImgTool::GetCurrentID() == IDMB_ERASERTOOL)
        {
        crLeft  = crRealLeftColor;
        crRight = crRealRightColor;
        }

    g_bBrushVisible = TRUE;
    }

/***************************************************************************/

void CImgWnd::CmdSmallBrush()
    {
    if (CImgTool::GetCurrent()->GetStrokeWidth() != 0)
        CImgTool::GetCurrent()->SetStrokeWidth(1);
    }

/***************************************************************************/

void CImgWnd::CmdSmallerBrush()
    {
    if (theImgBrush.m_pImg != NULL || g_bCustomBrush)
        {
        CmdHalfBsh();
        return;
        }

    UINT nStrokeWidth = CImgTool::GetCurrent()->GetStrokeWidth();

    if (nStrokeWidth > 1)
        CImgTool::GetCurrent()->SetStrokeWidth(nStrokeWidth - 1);
    }

/***************************************************************************/

void CImgWnd::CmdLargerBrush()
    {
    if (theImgBrush.m_pImg != NULL || g_bCustomBrush)
        {
        CmdDoubleBsh();
        return;
        }

    UINT nStrokeWidth = CImgTool::GetCurrent()->GetStrokeWidth();

    CImgTool::GetCurrent()->SetStrokeWidth(nStrokeWidth + 1);
    }

/***************************************************************************/

void CImgWnd::CmdOK()
    {
    if (GetCapture() != NULL)
        {
        MessageBeep(0);
        return;
        }
    }

/***************************************************************************/
// Draw the tracker for this view (if it's the active one) into pDC.
// If pDC is NULL, one will be provided.  Optimize drawing by limiting
// it to pPaintRect.  If pPaintRect is NULL, draw the whole tracker.
//
void CImgWnd::DrawTracker( CDC* pDC, const CRect* pPaintRect )
    {
    BOOL bDrawTrackerRgn = FALSE;

    if (c_pImgWndCur != this
    ||  theImgBrush.m_bMoveSel
    ||  theImgBrush.m_bSmearSel
    ||  theImgBrush.m_bMakingSelection)
        {
        // This is not the active view, or the user is doing something
        // to prevent the tracker from appearing.
        return;
        }

    BOOL bReleaseDC = FALSE;
    CRect clientRect;

    if (pDC == NULL)
        {
        pDC = GetDC();

        if (pDC == NULL)
            {
            theApp.SetGdiEmergency(FALSE);
            return;
            }
        bReleaseDC = TRUE;
        }

   if (pPaintRect == NULL)
        {
        GetClientRect(&clientRect);
        pPaintRect = &clientRect;
        }

    CRect trackerRect;

    GetImageRect( trackerRect );

    trackerRect.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

    CTracker::EDGES edges = (CTracker::EDGES)(CTracker::right | CTracker::bottom);

    if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        bDrawTrackerRgn = TRUE;
        }

    if (m_pImg == theImgBrush.m_pImg)
        {
        edges = CTracker::all;

        trackerRect = theImgBrush.m_rcSelection;

        trackerRect.left   *= m_nZoom;
        trackerRect.top    *= m_nZoom;
        trackerRect.right  *= m_nZoom;
        trackerRect.bottom *= m_nZoom;

        trackerRect.InflateRect( CTracker::HANDLE_SIZE,
                                 CTracker::HANDLE_SIZE);
        trackerRect.OffsetRect(  CTracker::HANDLE_SIZE + m_xScroll * m_nZoom,
                                 CTracker::HANDLE_SIZE + m_yScroll * m_nZoom);

        if (IsGridVisible())
            {
            trackerRect.right  += 1;
            trackerRect.bottom += 1;
            }
        }

    CTracker::DrawBorder (pDC, trackerRect, edges );
    CTracker::DrawHandles(pDC, trackerRect, edges );

    if (bReleaseDC)
        ReleaseDC(pDC);
    }

/***************************************************************************/
// Erase the tracker from this window.  Handles whole image as well
// as selection trackers.
//
void CImgWnd::EraseTracker()
    {
    if (m_pImg == NULL)
        return;

    CClientDC dc(this);

    if (dc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency(FALSE);
        return;
        }

    CRect trackerRect;

    if (m_pImg == theImgBrush.m_pImg)
        {
        // Tracker is a selection within the image

        trackerRect = theImgBrush.m_rcSelection;
        ImageToClient(trackerRect);
        trackerRect.InflateRect(CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE);

        if (IsGridVisible())
            {
            trackerRect.right += 1;
            trackerRect.bottom += 1;
            }

        InvalidateRect( &trackerRect, FALSE );
        }
    else
        {
        // Tracker is around entire image

        GetImageRect(trackerRect);
        trackerRect.InflateRect(CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE);
        DrawBackground(&dc, &trackerRect);
        }
    }

/***************************************************************************/

void CImgWnd::CmdTglOpaque()
    {
    HideBrush();
    theImgBrush.m_bOpaque = !theImgBrush.m_bOpaque;
    theImgBrush.RecalcMask( crRight );

    MoveBrush( theImgBrush.m_rcSelection );

    if ((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
    ||  (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
        g_pImgToolWnd->InvalidateOptions( FALSE );
    }

/***************************************************************************/

void CImgWnd::CmdInvertColors()
    {
    IMG* pImg = m_pImg;

    HideBrush();

    CRect invertRect;
    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        {
        invertRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
        }
    else
        {
        invertRect = rcDragBrush;
        invertRect.right -= 1;
        invertRect.bottom -= 1;
        }

    if (theImgBrush.m_pImg != NULL && ! theImgBrush.m_bFirstDrag || g_bCustomBrush)
        {
        CPalette* ppal = SetImgPalette( &theImgBrush.m_dc, FALSE );

        theImgBrush.m_dc.PatBlt(0, 0, theImgBrush.m_size.cx,
                                      theImgBrush.m_size.cy, DSTINVERT);

        if (ppal)
            theImgBrush.m_dc.SelectPalette( ppal, FALSE ); // Background ??

        theImgBrush.RecalcMask( crRight );
        MoveBrush( theImgBrush.m_rcSelection );
        }
    else
        {
        SetUndo( m_pImg );

        PatBlt( pImg->hDC, invertRect.left, invertRect.top,
                invertRect.Width(), invertRect.Height(), DSTINVERT );

        InvalImgRect ( m_pImg, &invertRect );
        CommitImgRect( m_pImg, &invertRect );
        FinishUndo( invertRect );
        DirtyImg( m_pImg );
        }
    }

/***************************************************************************/

void CImgWnd::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags )
    {
    CWnd::OnKeyDown( nChar, nRepCnt, nFlags );
    }

/***************************************************************************/

void CImgWnd::OnKeyUp( UINT nChar, UINT nRepCnt, UINT nFlags )
    {
    CWnd::OnKeyUp( nChar, nRepCnt, nFlags );
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\ipframe.h ===
// ipframe.h : interface of the CInPlaceFrame class
//

class CInPlaceFrame : public COleIPFrameWnd
    {
    DECLARE_DYNCREATE(CInPlaceFrame)

    public:

    CInPlaceFrame();

    // Attributes
    public:

    // Operations
    public:

    // Implementation
    public:

    virtual ~CInPlaceFrame();

	virtual CWnd* GetMessageBar();
    virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
    virtual void RepositionFrame( LPCRECT lpPosRect, LPCRECT lpClipRect );

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    #endif

    protected:

    CStatBar    	m_statBar;
    CImgToolWnd 	m_toolBar;
	CImgColorsWnd 	m_colorBar;

    COleResizeBar	m_wndResizeBar;
    COleDropTarget	m_dropTarget;

    // Generated message map functions
    protected:

    //{{AFX_MSG(CInPlaceFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSysColorChange();
	afx_msg void OnClose();
	afx_msg void OnHelpIndex();
	//}}AFX_MSG

	afx_msg LRESULT OnContextMenu(WPARAM wParam, LPARAM lParam);

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\interlac.cpp ===
/*********************************************************************
   Interlace.cpp

   Definition file for interlace module.
 *********************************************************************/
#include "stdafx.h"
#include "Image.h"
#include "Interlac.h"

/*--------------------------------------------------------------------
            Data Structures and Definitions.
 --------------------------------------------------------------------*/
#define  ADAM7_BLOCK_SIZE    8

short kgacPassScanLines[NUM_PASSES] = { 1, 1, 1, 2, 2, 4, 4 };
short kgacPassStartHorzPosn[NUM_PASSES] = { 0, 4, 0, 2, 0, 1, 0 };
short kgacPassStartVertPosn[NUM_PASSES] = { 0, 0, 4, 0, 2, 0, 1 };
short kgacPassVertIncrements[NUM_PASSES] = { 8, 8, 8, 4, 4, 2, 2 };
short kgacPassHorzIncrements[NUM_PASSES] = { 8, 8, 4, 4, 2, 2, 1 };

/*--------------------------------------------------------------------
            Local Function Prototypes.
 --------------------------------------------------------------------*/

long iFindPass(pADAM7_STRUCT);
long iFindImageLine(pADAM7_STRUCT);

/*--------------------------------------------------------------------
            Export Function Definitions.
 --------------------------------------------------------------------*/

//************************************************************************************
// Given an image described by the parameters of the ADAM7_STRUCT, calculate the
// number of scan lines in the image file which has been interlaced using the Adam7
// scheme.
//************************************************************************************
int iADAM7CalculateNumberOfScanLines(pADAM7_STRUCT ptAdam7)
{
   if (ptAdam7 == NULL)
   {
      return 0;
   }

   if (ptAdam7->iImageHeight == 0 || ptAdam7->iImageWidth == 0)
   {
      return 0;
   }

   if (ptAdam7->iImageHeight < ADAM7_BLOCK_SIZE)
   {
      switch(ptAdam7->iImageHeight)
      {
      case 1:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 1;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 1;
         ptAdam7->cPassScanLines[6] = 0;
         ptAdam7->cTotalScanLines  =  6;
         break;

      case 2:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 1;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 1;
         ptAdam7->cPassScanLines[6] = 1;
         ptAdam7->cTotalScanLines  =  7;
         break;

      case 3:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 1;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 2;
         ptAdam7->cPassScanLines[6] = 1;
         ptAdam7->cTotalScanLines  =  8;
         break;

      case 4:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 1;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 2;
         ptAdam7->cPassScanLines[6] = 2;
         ptAdam7->cTotalScanLines  =  9;
         break;

      case 5:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 2;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 3;
         ptAdam7->cPassScanLines[6] = 2;
         ptAdam7->cTotalScanLines  = 11;
         break;

      case 6:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 2;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 3;
         ptAdam7->cPassScanLines[6] = 3;
         ptAdam7->cTotalScanLines  = 12;
         break;

      case 7:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 2;
         ptAdam7->cPassScanLines[4] = 2;
         ptAdam7->cPassScanLines[5] = 4;
         ptAdam7->cPassScanLines[6] = 3;
         ptAdam7->cTotalScanLines  = 14;
         break;
      }

      return ptAdam7->cTotalScanLines;
   }


   ptAdam7->cScanBlocks = ptAdam7->iImageHeight / ADAM7_BLOCK_SIZE;
   int iExtraLines = ptAdam7->iImageHeight % ADAM7_BLOCK_SIZE;

   ptAdam7->cTotalScanLines = 0;

   for (int i = 0; i < NUM_PASSES; i++)
   {
      ptAdam7->cPassScanLines[i] = ptAdam7->cScanBlocks * kgacPassScanLines[i];
      ptAdam7->cTotalScanLines += ptAdam7->cPassScanLines[i];
   }

   switch(iExtraLines)
   {
   case 0:
      break;

   case 1:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 0;  // Yes, I could have left these out: hopefully
      ptAdam7->cPassScanLines[3] += 1;
      ptAdam7->cPassScanLines[4] += 0;  // these will help someone else figure out the
      ptAdam7->cPassScanLines[5] += 1;
      ptAdam7->cPassScanLines[6] += 0;  // Adam7 de-interlacing scheme.
      ptAdam7->cTotalScanLines +=  4;
      break;

   case 2:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 0;
      ptAdam7->cPassScanLines[3] += 1;
      ptAdam7->cPassScanLines[4] += 0;
      ptAdam7->cPassScanLines[5] += 1;
      ptAdam7->cPassScanLines[6] += 1;
      ptAdam7->cTotalScanLines +=  5;
      break;

   case 3:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 0;
      ptAdam7->cPassScanLines[3] += 1;
      ptAdam7->cPassScanLines[4] += 1;
      ptAdam7->cPassScanLines[5] += 2;
      ptAdam7->cPassScanLines[6] += 1;
      ptAdam7->cTotalScanLines += 7;
      break;

  case 4:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 0;
      ptAdam7->cPassScanLines[3] += 1;
      ptAdam7->cPassScanLines[4] += 1;
      ptAdam7->cPassScanLines[5] += 2;
      ptAdam7->cPassScanLines[6] += 2;
      ptAdam7->cTotalScanLines += 8;
      break;

   case 5:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 1;
      ptAdam7->cPassScanLines[3] += 2;
      ptAdam7->cPassScanLines[4] += 1;
      ptAdam7->cPassScanLines[5] += 3;
      ptAdam7->cPassScanLines[6] += 2;
      ptAdam7->cTotalScanLines += 11;
      break;

   case 6:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 1;
      ptAdam7->cPassScanLines[3] += 2;
      ptAdam7->cPassScanLines[4] += 1;
      ptAdam7->cPassScanLines[5] += 3;
      ptAdam7->cPassScanLines[6] += 3;
      ptAdam7->cTotalScanLines += 12;
      break;

   case 7:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 1;
      ptAdam7->cPassScanLines[3] += 2;
      ptAdam7->cPassScanLines[4] += 2;
      ptAdam7->cPassScanLines[5] += 4;
      ptAdam7->cPassScanLines[6] += 3;
      ptAdam7->cTotalScanLines += 14;
      break;

   default: /* Should never, ever get here!  */
      break;
   }

   return ptAdam7->cTotalScanLines;
}


//************************************************************************************
// Functions to generate a deinterlaced DIB; i.e., each pixel is in BGR in the case
// of RGB/RGBA image classes, and raster line data is stored in a contiguous block.
//************************************************************************************
LPBYTE *ppbADAM7InitDIBPointers(LPBYTE pbDIB, pADAM7_STRUCT ptAdam7, DWORD cbImageLine)
{
   if (ptAdam7 == NULL)
   {
      return NULL;
   }

   if (ptAdam7->iImageHeight == 0 || ptAdam7->iImageWidth == 0)
   {
      return NULL;
   }

   BYTE **ppbRowPtrs = (BYTE **)HeapAlloc(GetProcessHeap(),
           0, sizeof(BYTE *) * ptAdam7->iImageHeight);
   if (ppbRowPtrs == NULL)
   {
      return NULL;
   }

   /*  DIBs are bottom up  */
   for (int i = 0; i < ptAdam7->iImageHeight; i++)
   {
      ppbRowPtrs[i] = pbDIB +
                         ((DWORD)(ptAdam7->iImageHeight - i - 1) * (DWORD)cbImageLine);
   }

   int iScanLines = iADAM7CalculateNumberOfScanLines(ptAdam7);

   ptAdam7->iPassLine = 0;

   return ppbRowPtrs;
}

// The following returns TRUE if the scan line was an empty scan line.
BOOL ADAM7AddRowToDIB(LPBYTE *ppbDIBPtrs, LPBYTE pbScanLine, pADAM7_STRUCT ptAdam7)
{
   BYTE *pbScan;
   BYTE *pbImage;
   BYTE *pbCurrentImageLine;

   long iCurrentPass = iFindPass(ptAdam7);
   long iImageLine = iFindImageLine(ptAdam7);
   long  i;
   if (iImageLine < ptAdam7->iImageHeight)
   {

      pbCurrentImageLine = ppbDIBPtrs[iImageLine];
      for (pbImage = pbCurrentImageLine + (kgacPassStartHorzPosn[iCurrentPass] * ptAdam7->cbPixelSize),
           pbScan = pbScanLine, i = kgacPassStartHorzPosn[iCurrentPass];
           i < ptAdam7->iImageWidth;
           pbImage += (kgacPassHorzIncrements[iCurrentPass] * ptAdam7->cbPixelSize),
           pbScan += ptAdam7->cbPixelSize,
           i += kgacPassHorzIncrements[iCurrentPass])
      {
         {
            switch (ptAdam7->Class)
            {
               case IFLCL_GRAY:
               case IFLCL_GRAYA:
               case IFLCL_PALETTE:
                                 memcpy(pbImage, pbScan, ptAdam7->cbPixelSize);
                                 break;
               case IFLCL_RGBA:
                  *(pbImage + 3) = *(pbScan + 3); // And fall through . . .
               case IFLCL_RGB:
                  *pbImage = *(pbScan + 2);
                  *(pbImage + 1) = *(pbScan + 1);
                  *(pbImage + 2) = *pbScan;
                            break;
               default:
                  return TRUE;
            }
         }
      }
      return FALSE;
   }
   else
   {
      return TRUE;
   }
}

//************************************************************************************
// Generate a deinterlaced image; i.e., each pixel is in RGB in the case
// of RGB/RGBA image classes, and raster line data may not necessarily be stored
// in one contiguous block of memory.
//************************************************************************************

// The following returns TRUE if the scan line was an empty scan line.
BOOL ADAM7AddRowToImageBuffer(LPBYTE ppbImageBuffer[], LPBYTE pbScanLine, pADAM7_STRUCT ptAdam7)
{
   BYTE *pbScan;
   BYTE *pbImage;
   BYTE *pbCurrentImageLine;

   long iCurrentPass = iFindPass(ptAdam7);
   long iImageLine = iFindImageLine(ptAdam7);
   long i;
   if (iImageLine < ptAdam7->iImageHeight)
   {

      pbCurrentImageLine = ppbImageBuffer[iImageLine];
      for (pbImage = pbCurrentImageLine + (kgacPassStartHorzPosn[iCurrentPass] * ptAdam7->cbPixelSize),
           pbScan = pbScanLine, i = kgacPassStartHorzPosn[iCurrentPass];
           i < ptAdam7->iImageWidth;
           pbImage += (kgacPassHorzIncrements[iCurrentPass] * ptAdam7->cbPixelSize),
           pbScan += ptAdam7->cbPixelSize,
           i += kgacPassHorzIncrements[iCurrentPass])
      {
         {
            switch (ptAdam7->Class)
            {
               case IFLCL_GRAY:
               case IFLCL_GRAYA:
               case IFLCL_PALETTE:
                                 memcpy(pbImage, pbScan, ptAdam7->cbPixelSize);
                                 break;
                       case IFLCL_RGBA:
                  *(pbImage + 3) = *(pbScan + 3); // And fall through . . .
               case IFLCL_RGB:
                  *pbImage = *pbScan;
                  *(pbImage + 1) = *(pbScan + 1);
                  *(pbImage + 2) = *(pbScan + 2);
                            break;
               default:
                  return TRUE;
            }
         }
      }
      return FALSE;
   }
   else
   {
      return TRUE;
   }
}

//************************************************************************************
// Generate a deinterlaced alpha channel data block.
//************************************************************************************
BOOL ADAM7RMFDeinterlaceAlpha(LPWORD *ppwInterlaced, LPWORD *ppwDeinterlaced,
                              IFL_ALPHA_CHANNEL_INFO  *ptAlphaInfo)
{
   ADAM7_STRUCT tAdam7;

   if (ppwInterlaced == NULL || ppwDeinterlaced == NULL || ptAlphaInfo == NULL)
   {
      return FALSE;
   }

   tAdam7.iImageHeight = ptAlphaInfo->dwHeight;
   tAdam7.iImageWidth = ptAlphaInfo->dwWidth;
   tAdam7.cbPixelSize = sizeof(WORD);
   tAdam7.iPassLine = 0;
   /* Simulate a class so we can use the AddRowToDIB function above. */
   tAdam7.Class = IFLCL_GRAYA;

   tAdam7.cTotalScanLines = iADAM7CalculateNumberOfScanLines(&tAdam7);

   for (tAdam7.iScanLine = 0; tAdam7.iScanLine < tAdam7.cTotalScanLines; tAdam7.iScanLine++)
   {
      ADAM7AddRowToDIB((BYTE **)ppwDeinterlaced, (BYTE *)(ppwInterlaced[tAdam7.iScanLine]), &tAdam7);
   }

   return TRUE;
}

/*--------------------------------------------------------------------
            Local Function Definitions.
 --------------------------------------------------------------------*/

long iFindPass(pADAM7_STRUCT ptAdam7)
{
   BOOL fFound = FALSE;

   ptAdam7->iPass = 0;
   int iSubTotal = ptAdam7->cPassScanLines[ptAdam7->iPass];
   while (!fFound)
   {
      if (ptAdam7->iScanLine < iSubTotal)
      {
         fFound = TRUE;
         ptAdam7->iPassLine = ptAdam7->iScanLine -
                             (iSubTotal - ptAdam7->cPassScanLines[ptAdam7->iPass]);
      }
      else
      {
         ptAdam7->iPass += 1;
         iSubTotal += ptAdam7->cPassScanLines[ptAdam7->iPass];
      }
   }

   return ptAdam7->iPass;
}

long iFindImageLine(pADAM7_STRUCT ptAdam7)
{
   if (kgacPassStartHorzPosn[ptAdam7->iPass] >= ptAdam7->iImageWidth)
   {
      return (ptAdam7->iImageHeight + 1);
   }

   ptAdam7->iImageLine = kgacPassStartVertPosn[ptAdam7->iPass] +
                         ptAdam7->iPassLine * kgacPassVertIncrements[ptAdam7->iPass];
   return ptAdam7->iImageLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\loadimag.cpp ===
//
// loadimag.cpp
//
// implementation of loading a file from disk via an installed graphic filter
//

#include "stdafx.h"
#include "pbrush.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "loadimag.h"
#include "bmpstrm.h"
#include "imaging.h"

#include <atlbase.h>

// must define one of the following:
//#define _USE_FLT_API
#ifdef _X86_
#define _USE_IFL_API
#endif

#ifdef _USE_FLT_API
#include "filtapi.h"
#endif

#ifdef _USE_IFL_API
#include "image.h"
#include "interlac.h"
#define MAX_PAL_SIZE 256

#ifdef PNG_SUPPORT // for Portable Network Graphics. As of 12/10/1996 the support was broken

//----------------------------------------------------------------------------
//    Places a line of image data from an ADAM 7 interlaced file (i.e., currently
//    a PNG file) into its correct position in a memory buffer: this memory
//    buffer is essentially an array of pointers to the rows of the image in
//    which the pixel data is to be set.
//----------------------------------------------------------------------------
 IFLERROR ReadADAM7InterlacedImage(LPBYTE apbImageBuffer[], IFLHANDLE pfpbFROM,
                                         int ImageHeight, int ImageWidth, int cbPixelSize,
                                         IFLCLASS ImageClass)
{


        int cRasterLines = iflGetRasterLineCount(pfpbFROM);

        ADAM7_STRUCT stAdam7;
        stAdam7.iImageHeight = ImageHeight;
        stAdam7.iImageWidth = ImageWidth;
        stAdam7.Class = ImageClass;
        stAdam7.cbPixelSize = iflGetBitsPerPixel (pfpbFROM)/8;//cbPixelSize;
        stAdam7.iPassLine = 0;
        LPBYTE pbScanLine = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, ImageWidth * stAdam7.cbPixelSize);
        wsprintf (buf, TEXT("Pixel size: %d, Size of a scan line: %d\n"), stAdam7.cbPixelSize,
                          ImageWidth*stAdam7.cbPixelSize);

        if (pbScanLine == NULL)
                return IFLERR_MEMORY;

        int cTotalScanLines = iADAM7CalculateNumberOfScanLines(&stAdam7);

        int iLine;
        IFLERROR idErr;
        BOOL fEmptyLine;

        for (iLine = 0, idErr = IFLERR_NONE, fEmptyLine = FALSE;
                idErr == IFLERR_NONE && iLine < (int)cRasterLines;
                iLine++)
        {
                if (!fEmptyLine)
                        idErr = iflRead(pfpbFROM, pbScanLine, 1);

                stAdam7.iScanLine = iLine;
                fEmptyLine = ADAM7AddRowToImageBuffer(apbImageBuffer, pbScanLine, &stAdam7);
        }

        HeapFree(GetProcessHeap(), 0, pbScanLine);
        return idErr;
}

//----------------------------------------------------------------------------
//    Deallocates the image space allocated in the function AllocateImageSpace()
//----------------------------------------------------------------------------
 LPBYTE *FreeImageSpace(HANDLE hHeap, LPBYTE ppImageSpace[], int height)
{
        if (ppImageSpace != NULL)
        {
                for (int i = 0; i < height; i++)
                {
                        if (ppImageSpace[i] != NULL)
                        {
                                HeapFree(hHeap, 0, ppImageSpace[i]);
                                ppImageSpace[i] = NULL;
                        }
                }

                HeapFree(hHeap, 0, ppImageSpace);
                ppImageSpace = NULL;
        }

        return ppImageSpace;
}

//----------------------------------------------------------------------------
//    Allocate some image space: this function will create a dynamic array
//    of "height" pointers which each point to an allocated row of bytes of
//    size "width".
//----------------------------------------------------------------------------
 LPBYTE *AllocateImageSpace(HANDLE hHeap, int height, int width, int cbSize)
{
        LPBYTE *ppImageSpace = (LPBYTE *)HeapAlloc(hHeap, 0, height * sizeof(void *));
        TCHAR buf[200];
        wsprintf (buf, TEXT("Size of image line: %d\n"), width*cbSize);


        if (ppImageSpace != NULL)
        {
                // Init the pointers to NULL: this makes error recovery easier
                for (int i = 0; i < height; i++)
                        ppImageSpace[i] = NULL;

                // NOW allocate the pointer space for the image
                for (i = 0; i < height; i++)
                {
                        ppImageSpace[i] = (LPBYTE)HeapAlloc(hHeap, 0, width * cbSize);
                        if (ppImageSpace[i] == NULL)
                                break;
                }

                if (i < height) // We weren't able to allocate the required space
                        ppImageSpace = FreeImageSpace(hHeap, ppImageSpace, height);
        }

        return ppImageSpace;
}
#endif // PNG_SUPPORT

#endif // _USE_IFL_API



// returns a pointer to the extension of a file.
//
// in:
//      qualified or unqualfied file name
//
// returns:
//      pointer to the extension of this file.  if there is no extension
//      as in "foo" we return a pointer to the NULL at the end
//      of the file
//
//      foo.txt     ==> ".txt"
//      foo         ==> ""
//      foo.        ==> "."
//

LPCTSTR FindExtension(LPCTSTR pszPath)
{
        for (LPCTSTR pszDot = NULL; *pszPath; pszPath = CharNext(pszPath))
        {
                switch (*pszPath)
                {
                        case TEXT('.'):
                                pszDot = pszPath;       // remember the last dot
                                break;
                        case TEXT('\\'):
                        case TEXT(' '):                               // extensions can't have spaces
                                pszDot = NULL;          // forget last dot, it was in a directory
                                break;
                }
        }

        // if we found the extension, return ptr to the dot, else
        // ptr to end of the string (NULL extension)
        return pszDot ? pszDot : pszPath;
}

//
// GetFilterInfo
//
//  32-bit import filters are listed in the registry...
//
//  HKLM\SOFTWARE\Microsoft\Shared Tools\Graphics Filters\Import\XXX
//      Path        = filename
//      Name        = friendly name
//      Extenstions = file extenstion list
//
#pragma data_seg(".text")
static const TCHAR c_szImpHandlerKey[] = TEXT("SOFTWARE\\Microsoft\\Shared Tools\\Graphics Filters\\Import");
static const TCHAR c_szExpHandlerKey[] = TEXT("SOFTWARE\\Microsoft\\Shared Tools\\Graphics Filters\\Export");
static const TCHAR c_szName[] = TEXT("Name");
static const TCHAR c_szPath[] = TEXT("Path");
static const TCHAR c_szExts[] = TEXT("Extensions");
static const TCHAR c_szImageAPI[] = TEXT("Image API Enabled Filters");
#pragma data_seg()

BOOL GetInstalledFilters(BOOL bOpenFileDialog, int i, LPTSTR szName, UINT cbName,
                LPTSTR szExt, UINT cbExt, LPTSTR szHandler, UINT cbHandler, BOOL& bImageAPI)
{
        HKEY hkey;
        HKEY hkeyT;
        TCHAR ach[80];
        BOOL rc = FALSE;        // return code

        bImageAPI = FALSE;

        if (RegOpenKey(HKEY_LOCAL_MACHINE,
                bOpenFileDialog ? c_szImpHandlerKey : c_szExpHandlerKey, &hkey) == 0)
        {
                if (RegEnumKey(hkey, i, ach, sizeof(ach)/sizeof(ach[0]))==0)
                {
                        if (RegOpenKey(hkey, ach, &hkeyT) == 0)
                        {
                                if (szName)
                                {
                                        szName[0] = 0;
                                        RegQueryValueEx(hkeyT, c_szName, NULL, NULL,
                                                (LPBYTE)szName, (LPDWORD)&cbName);
                                }
                                if (szExt)
                                {
                                        szExt[0] = 0;
                                        RegQueryValueEx(hkeyT, c_szExts, NULL, NULL,
                                                (LPBYTE)szExt, (LPDWORD)&cbExt);
                                }
                                if (szHandler)
                                {
                                        szHandler[0] = 0;
                                        RegQueryValueEx(hkeyT, c_szPath, NULL, NULL,
                                                (LPBYTE)szHandler, (LPDWORD)&cbHandler);
                                }

                                RegCloseKey(hkeyT);
                                rc = TRUE;
                        }

                        TCHAR szEnabledFilters[1024];
                        DWORD dwEnabledFiltersSize = sizeof(szEnabledFilters);

                        // Does the filter support Image Library Files API ?

                        if (RegQueryValueEx(hkey, c_szImageAPI, NULL, NULL,
                                (LPBYTE)szEnabledFilters, &dwEnabledFiltersSize) == 0)
                        {
                            for (
                                LPCTSTR pExt = _tcstok(szEnabledFilters, _T(" "));
                                pExt != NULL && bImageAPI != TRUE;
                                pExt = _tcstok(NULL, _T(" "))) 
                            {
                                if (_tcsicmp(pExt, ach) == 0) 
                                {
                                    bImageAPI = TRUE;
                                }
                            }
                        }
                }
                RegCloseKey(hkey);
        }

        return rc;
}

#ifdef _USE_FLT_API
//
//  GetHandlerForFile
//
//  find an import/export filter for the given file.
//
BOOL GetHandlerForFile(BOOL bImport, LPCTSTR szFile, LPTSTR szHandler, UINT cb)
{
        TCHAR    buf[40];
        BOOL    rc = FALSE;     // return code

        *szHandler = 0;

        if (szFile == NULL)
                return FALSE;

        // find the extension
        LPCTSTR ext = FindExtension(szFile);

        BOOL bImageAPI;

        for (int i = 0;
                GetInstalledFilters(bImport, i, NULL, 0, buf, sizeof(buf), szHandler, cb, bImageAPI);
                i++)
        {
                if (lstrcmpi(ext+1, buf) == 0)
                        break;
                else
                        *szHandler = 0;
        }

        // make sure the handler file does exist
        if (*szHandler && GetFileAttributes(szHandler) != -1)
                rc = TRUE;

        return rc;
}

//
// FindBitmapInfo
//
// find the DIB bitmap in a memory meta file...
//
LPBITMAPINFOHEADER FindBitmapInfo(LPMETAHEADER pmh)
{
        for (LPMETARECORD pmr = (LPMETARECORD)((LPBYTE)pmh + pmh->mtHeaderSize*2);
                pmr < (LPMETARECORD)((LPBYTE)pmh + pmh->mtSize*2);
                pmr = (LPMETARECORD)((LPBYTE)pmr + pmr->rdSize*2))
        {
                switch (pmr->rdFunction)
                {
                        case META_DIBBITBLT:
                                return (LPBITMAPINFOHEADER)&(pmr->rdParm[8]);

                        case META_DIBSTRETCHBLT:
                                return (LPBITMAPINFOHEADER)&(pmr->rdParm[10]);

                        case META_STRETCHDIB:
                                return (LPBITMAPINFOHEADER)&(pmr->rdParm[11]);

                        case META_SETDIBTODEV:
                                return (LPBITMAPINFOHEADER)&(pmr->rdParm[9]);
                }
        }

        return NULL;
}

#endif // _USE_FLT_API

#ifdef _USE_IFL_API
  IFLERROR ReadGIFInterlacedImage(BYTE *ppbImageBuffer,
                                      IFLHANDLE pfpbFROM,
                                      int ImageHeight, DWORD dwWidthInBytes)
{
    int          iLine, iPass, iIntLine, iTempLine;
    IFLERROR   idErr;


    WORD       InterlaceMultiplier[] = { 8, 8, 4, 2 };
    WORD       InterlaceOffset[]     = { 0, 4, 2, 1 };

    idErr = IFLERR_NONE;

    iPass = 0;
    iIntLine = InterlaceOffset[iPass];
    iLine = 0;
    while (idErr == IFLERR_NONE && iLine < ImageHeight)
    {
       iTempLine = InterlaceMultiplier[iPass] * iIntLine + InterlaceOffset[iPass];
       if (iTempLine >= ImageHeight)
       {
           iPass++;
           iIntLine = 0;
           iTempLine = InterlaceOffset[iPass];
       }

       if (iTempLine < ImageHeight)
       {
           idErr = iflRead(pfpbFROM,
                     (LPBYTE)ppbImageBuffer+((ImageHeight-iTempLine-1)*dwWidthInBytes),
                           1);
           iLine++;
       }
       iIntLine++;
    }

    return idErr;
}
#endif // _USE_IFL_API

//
//  LoadDIBFromFile
//
//  load a image file using a image import filter. The filters use ANSI strings.
//

HGLOBAL LoadDIBFromFileA(LPCSTR szFileName, GUID *pguidFltTypeUsed)
{
#ifdef _USE_IFL_API

        IFLTYPE iflType;

        iflImageType((LPSTR)szFileName, &iflType);

        // make sure the image is of a type we know how to import
        if (iflType == IFLT_PNG)
        {
           return NULL;
        }

        IFLHANDLE iflHandle = iflCreateReadHandle(iflType);
        if (!iflHandle)
        {
           //
           // No filter installed for this type
           //
           return NULL;
        }

        LPBYTE lpStart = 0;

    __try 
    {

        IFLERROR iflErr = iflOpen(iflHandle, (LPSTR)szFileName, IFLM_READ);
        if (iflErr != IFLERR_NONE)
        {
                iflFreeHandle(iflHandle);
                return NULL;
        }

        ASSERT(pguidFltTypeUsed);

        switch (iflType)
        {
            case IFLT_GIF:  *pguidFltTypeUsed = WiaImgFmt_GIF;       break;
            case IFLT_BMP:  *pguidFltTypeUsed = WiaImgFmt_BMP;       break;
            case IFLT_JPEG: *pguidFltTypeUsed = WiaImgFmt_JPEG;      break;
            case IFLT_TIFF: *pguidFltTypeUsed = WiaImgFmt_TIFF;      break;
            case IFLT_PNG:  *pguidFltTypeUsed = WiaImgFmt_PNG;       break;
            case IFLT_PCD:  *pguidFltTypeUsed = WiaImgFmt_PHOTOCD;   break;
            default:        *pguidFltTypeUsed = WiaImgFmt_UNDEFINED; break;
        }

        IFLCLASS        iflClass = iflGetClass(iflHandle);
        IFLSEQUENCE     iflSequence = iflGetSequence(iflHandle);
        IFLCOMPRESSION  iflCompression = iflGetCompression(iflHandle);
        WORD            iBPS = (WORD) iflGetBitsPerChannel(iflHandle);

        if (iflClass != IFLCL_RGB && iflClass != IFLCL_PALETTE &&
            iflClass != IFLCL_GRAY && iflClass != IFLCL_BILEVEL)
        {
#ifdef _DEBUG
           TRACE(TEXT("LoadDIBFromFile: Not a RGB/PALETTE/GRAY/BW image.\n"));
           MessageBox (NULL, TEXT("Not a RGB/PALETTE/GRAY/BW image."),
                             TEXT("Loadimag.cpp"), MB_OK);
#endif
           iflClose(iflHandle);
           iflFreeHandle(iflHandle);
           return NULL;
        }

        // get the transparent color
        if (iflClass == IFLCL_RGB)
        {
                IFLCOLOR iflTransColor;
                g_bUseTrans = (IFLERR_NONE ==
                        iflControl(iflHandle, IFLCMD_TRANS_RGB, 0, 0, &iflTransColor));
                if (g_bUseTrans)
                        crTrans = RGB(iflTransColor.wRed,
                                                  iflTransColor.wGreen,
                                                  iflTransColor.wBlue);
        }
        else // must be IFLCL_PALETTE or IFLCL_GRAY or IFLCL_BILEVEL
        {
                BYTE byTransIdx;
                g_bUseTrans = (IFLERR_NONE ==
                        iflControl(iflHandle, IFLCMD_TRANS_IDX, 0, 0, &byTransIdx));
                if (g_bUseTrans)
                        crTrans = byTransIdx; // need to convert to COLORREF below
        }

        BITMAPINFOHEADER bi;
        memset(&bi, 0, sizeof(BITMAPINFOHEADER));

        bi.biSize = sizeof(BITMAPINFOHEADER); // should be 0x28 or 40 decimal
        bi.biWidth = iflGetWidth(iflHandle);
        bi.biHeight = iflGetHeight(iflHandle);
        bi.biPlanes = 1;




        if (iflClass == IFLCL_RGB)
        {
#ifdef PNG_SUPPORT
           if (iflType == IFLT_PNG)
           {
              bi.biBitCount = iBPS*3;
           }
           else
#endif // PNG_SUPPORT
           {
              bi.biBitCount = (WORD) iflGetBitsPerPixel (iflHandle);
           }
        }
        else // must be IFLCL_PALETTE or IFLCL_GRAY or IFLCL_BILEVEL
        {
           bi.biBitCount = 8;
        }



        bi.biCompression = 0;
        // convert width in pixels to bytes after rounding it up first
        DWORD dwWidthInBytes = ((bi.biWidth * bi.biBitCount + 31) & ~31)/8;
        bi.biSizeImage = abs(bi.biHeight) * dwWidthInBytes;
//      bi.biXPelsPerMeter = 0;
//      bi.biYPelsPerMeter = 0;
        if (iflClass == IFLCL_PALETTE || iflClass == IFLCL_GRAY
             || iflClass == IFLCL_BILEVEL)
                bi.biClrUsed = MAX_PAL_SIZE;
//      bi.biClrImportant = 0;

        LPBYTE lpBMP;

        if ((lpBMP = lpStart = (LPBYTE) GlobalAlloc(GMEM_FIXED, 
                bi.biSize + bi.biClrUsed*sizeof(RGBQUAD) + bi.biSizeImage)) == NULL)
                goto exit;

        memcpy(lpBMP, &bi, bi.biSize);
        lpBMP += bi.biSize;

        BYTE    byTemp;
        int             i, j;

        switch (iflSequence)
        {
           case IFLSEQ_TOPDOWN:
              switch (iflClass)
              {
                 case IFLCL_RGB:

                    lpBMP += bi.biClrUsed*sizeof(RGBQUAD) + bi.biSizeImage -
                    dwWidthInBytes;
                    for (i = 0; i < abs(bi.biHeight); lpBMP-=dwWidthInBytes, i++)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                       // need to swap RED with BLUE for internal DIB display
                       for (j = 0; j < bi.biWidth*3; j+=3)
                       {
                          byTemp = *(lpBMP+j);
                          *(lpBMP+j) = *(lpBMP+j+2);
                          *(lpBMP+j+2) = byTemp;
                       }
                    }
                    break;

                 case IFLCL_PALETTE:

                    // get palette info first...
                    RGBTRIPLE Pal3[MAX_PAL_SIZE];
                    RGBQUAD   Pal4[MAX_PAL_SIZE];
                    ZeroMemory (Pal3, MAX_PAL_SIZE*(sizeof(RGBTRIPLE)));
                    iflErr = iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

                    for (i = 0; i < MAX_PAL_SIZE; i++)
                    {
                       Pal4[i].rgbBlue     = Pal3[i].rgbtRed;
                       Pal4[i].rgbGreen    = Pal3[i].rgbtGreen;
                       Pal4[i].rgbRed      = Pal3[i].rgbtBlue;
                       Pal4[i].rgbReserved = 0;
                    }
                    memcpy(lpBMP, Pal4, sizeof(Pal4));

                    if (g_bUseTrans)
                    // convert the transparent color index to COLORREF
                       crTrans = RGB(Pal4[crTrans].rgbRed,Pal4[crTrans].rgbGreen,
                                             Pal4[crTrans].rgbBlue);

                    lpBMP += sizeof(Pal4) + bi.biSizeImage - dwWidthInBytes;

                    for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                    }

                    break;

                 case IFLCL_GRAY:

                    // get palette info first...
                    //BYTE PalGray[MAX_PAL_SIZE];
                    //iflErr = iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &PalGray);

                    for (i = 0; i < MAX_PAL_SIZE; i++)
                    {
                       Pal4[i].rgbBlue     = (BYTE) i;//PalGray[i];
                       Pal4[i].rgbGreen    = (BYTE) i;//PalGray[i];
                       Pal4[i].rgbRed      = (BYTE) i;//PalGray[i];
                       Pal4[i].rgbReserved = 0;
                    }
                    memcpy(lpBMP, Pal4, sizeof(Pal4));

                    if (g_bUseTrans)
                    // convert the transparent color index to COLORREF
                       crTrans = RGB(Pal4[crTrans].rgbRed, Pal4[crTrans].rgbGreen,
                                                   Pal4[crTrans].rgbBlue);

                    lpBMP += sizeof(Pal4) + bi.biSizeImage - dwWidthInBytes;

                    for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                    }

                    break;

                 case IFLCL_BILEVEL:

                    // set color Black
                    Pal4[0].rgbBlue     = 0;
                    Pal4[0].rgbGreen    = 0;
                    Pal4[0].rgbRed      = 0;
                    Pal4[0].rgbReserved = 0;

                    // set color White
                    Pal4[1].rgbBlue     = 255;
                    Pal4[1].rgbGreen    = 255;
                    Pal4[1].rgbRed      = 255;
                    Pal4[1].rgbReserved = 0;

                    memcpy(lpBMP, Pal4, sizeof(Pal4));

                    if (g_bUseTrans)
                       // convert the transparent color index to COLORREF
                       crTrans = RGB(Pal4[crTrans].rgbRed,
                                     Pal4[crTrans].rgbGreen,
                                     Pal4[crTrans].rgbBlue);

                    lpBMP += sizeof(Pal4) + bi.biSizeImage - dwWidthInBytes;

                    for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                    }
                    break;

                 default:
                 // currently not supported
                    break;
              }
              break;

           case IFLSEQ_BOTTOMUP:

              lpBMP += bi.biClrUsed*sizeof(RGBQUAD) + bi.biSizeImage - dwWidthInBytes;

              for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
              {
                 // read in one line at a time
                 iflRead(iflHandle, (LPBYTE)lpBMP, 1);

                 // need to swap RED with BLUE for internal DIB display
                 for (j = 0; j < bi.biWidth*3; j+=3)
                 {
                    byTemp = *(lpBMP+j);
                    *(lpBMP+j) = *(lpBMP+j+2);
                    *(lpBMP+j+2) = byTemp;
                 }
              }
              break;

           case IFLSEQ_GIF_INTERLACED:
           {

              // get color palette info first...
              RGBTRIPLE Pal3[MAX_PAL_SIZE];
              RGBQUAD   Pal4[MAX_PAL_SIZE];
              iflErr = iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

              for (i = 0; i < MAX_PAL_SIZE; i++)
                 {
                    Pal4[i].rgbBlue     = Pal3[i].rgbtRed;
                    Pal4[i].rgbGreen    = Pal3[i].rgbtGreen;
                    Pal4[i].rgbRed      = Pal3[i].rgbtBlue;
                    Pal4[i].rgbReserved = 0;
                 }
                 memcpy(lpBMP, Pal4, sizeof(Pal4));

                 if (g_bUseTrans)
                 // convert the transparent color index to COLORREF
                    crTrans = RGB(Pal4[crTrans].rgbRed,Pal4[crTrans].rgbGreen,
                                                       Pal4[crTrans].rgbBlue);

              LPBYTE lpTemp = lpBMP + sizeof(Pal4);
              ReadGIFInterlacedImage (lpTemp, iflHandle, bi.biHeight, dwWidthInBytes);

           }
           break;
/*         case 1010101:
              {

                 int IM[] = { 8, 8, 4, 2 }; // interlace multiplier
                 //int IO[] = { 1, 5, 3 ,2 }; // interface offset
                 int IO[] = { 0, 4, 2,1 };

                 for (j = 0; j < 4; j++)
                 {
                    lpBMP = lpTemp + bi.biSizeImage - dwWidthInBytes*IO[j];
                    for (i = 0; i < abs(bi.biHeight) && lpBMP >= lpTemp;
                                 lpBMP-=dwWidthInBytes*IM[j], i+=8)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                    }
                 }

                 break;
              }*/
#ifdef PNG_SUPPORT
           case IFLSEQ_ADAM7_INTERLACED:
           {

              // get color palette info first...
              RGBTRIPLE Pal3[MAX_PAL_SIZE];
              RGBQUAD   Pal4[MAX_PAL_SIZE];
              iflErr = iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

              for (i = 0; i < MAX_PAL_SIZE; i++)
              {
                 Pal4[i].rgbBlue     = Pal3[i].rgbtRed;
                 Pal4[i].rgbGreen    = Pal3[i].rgbtGreen;
                 Pal4[i].rgbRed      = Pal3[i].rgbtBlue;
                 Pal4[i].rgbReserved = 0;
              }
              memcpy(lpBMP, Pal4, sizeof(Pal4));

              if (g_bUseTrans)
                 // convert the transparent color index to COLORREF
                 crTrans = RGB(Pal4[crTrans].rgbRed,
                               Pal4[crTrans].rgbGreen,
                               Pal4[crTrans].rgbBlue);
/////////////////////////////
                HANDLE hHeap = GetProcessHeap();
                LPBYTE *ppbRGBRowPtrs =(LPBYTE *)AllocateImageSpace(hHeap,
                                      bi.biHeight, dwWidthInBytes, /*bi.biWidth, */sizeof(BYTE));

                if (ppbRGBRowPtrs != NULL)
                {
                // First get the image. This function will de-interlace the image
                // AND any alpha channel information: it will also resize the alpha
                // channel data structure to the image height from the number of
                // raster lines, if necessary.
                   iflErr = ReadADAM7InterlacedImage(ppbRGBRowPtrs, iflHandle,
                                                    bi.biHeight, bi.biWidth,
                                                    sizeof(BYTE)*3, iflClass);
/////////////////////////////

                   if (iflErr == IFLERR_NONE)
                   {
                      lpBMP += bi.biClrUsed*sizeof(RGBQUAD) + bi.biSizeImage -
                                             dwWidthInBytes;
                      for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
                      {
                         // read in one line at a time
                         memcpy((LPBYTE)lpBMP, ppbRGBRowPtrs[i], dwWidthInBytes);

                         // need to swap RED with BLUE for internal DIB display
                         for (j = 0; j < bi.biWidth*3; j+=3)
                         {
                            byTemp = *(lpBMP+j);
                            *(lpBMP+j) = *(lpBMP+j+2);
                            *(lpBMP+j+2) = byTemp;
                         }
                     }
                  }

                  ppbRGBRowPtrs = (LPBYTE *)FreeImageSpace(hHeap,
                                                           ppbRGBRowPtrs,
                                                           bi.biHeight);
                }
                break;

             }
#endif // PNG_SUPPORT
             default:
                break;
        }

    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

exit:
        iflClose(iflHandle);
        iflFreeHandle(iflHandle);

        return (HGLOBAL)lpStart;

#endif // _USE_IFL_API

//////////////////////////////////////////////////////////////////////////////

#ifdef _USE_FLT_API

        HINSTANCE           hLib = NULL;
        FILESPEC            fileSpec;               // file to load
        GRPI                            pict;
        UINT                rc;                     // return code
        HANDLE              hPrefMem = NULL;        // filter-supplied preferences
        UINT                wFilterType;            // 2 = graphics filter
        char                szHandler[128];
        HGLOBAL             hDib = NULL;

        PFNGetFilterInfo lpfnGetFilterInfo;
        PFNImportGr lpfnImportGr;

        if (!GetHandlerForFile(TRUE, szFileName, szHandler, sizeof(szHandler)))
        return FALSE;

    if (szHandler[0] == 0)
        return FALSE;

    if ((hLib = LoadLibrary(szHandler)) == NULL)
        goto exit;

    // get a pointer to the ImportGR function
    lpfnGetFilterInfo = (PFNGetFilterInfo)GetProcAddress(hLib, "GetFilterInfo");
    lpfnImportGr = (PFNImportGr)GetProcAddress(hLib, "ImportGr");

    if (lpfnGetFilterInfo == NULL)
        lpfnGetFilterInfo = (PFNGetFilterInfo)GetProcAddress(hLib, "GetFilterInfo@16");

    if (lpfnImportGr == NULL)
        lpfnImportGr = (PFNImportGr)GetProcAddress(hLib, "ImportGr@16");

    if (lpfnImportGr == NULL)
        goto exit;

    if (lpfnGetFilterInfo != NULL)
    {
        wFilterType = (*lpfnGetFilterInfo)
            ((short) 2,                 // interface version no.
            (char *)NULL,               // unused
            (HANDLE *) &hPrefMem,       // fill in: preferences
            (DWORD) 0x00020000);        // unused in Windows

        // the return value is the type of filter: 0=error,
        // 1=text-filter, 2=graphics-filter
        if (wFilterType != 2)
            goto exit;
    }

    fileSpec.slippery = FALSE;      // TRUE if file may disappear
    fileSpec.write = FALSE;         // TRUE if open for write
    fileSpec.unnamed = FALSE;       // TRUE if unnamed
    fileSpec.linked = FALSE;        // Linked to an FS FCB
    fileSpec.mark = FALSE;          // Generic mark bit
    fileSpec.dcbFile = 0L;
    //the converters need a pathname without spaces...

    GetShortPathName(szFileName, fileSpec.szName, sizeof(fileSpec.szName));

    pict.hmf = NULL;

    rc = (*lpfnImportGr)
        (NULL,                      // "the target DC" (printer?)
        (FILESPEC *) &fileSpec,     // file to read
        (GRPI *) &pict,             // fill in: result metafile
        (HANDLE) hPrefMem);         // preferences memory

    if (pict.hmf != NULL)
    {
        if (rc == 0)
        {
            // find the BITMAPINFO in the returned metafile

            LPMETAHEADER lpMetaHeader = (LPMETAHEADER) GlobalLock(pict.hmf);

            LPBITMAPINFOHEADER lpbi = FindBitmapInfo(lpMetaHeader);

            if (lpbi != NULL)
            {
                // copy the DIB

                SIZE_T nSize = FindDibSize(lpbi);

                hDib = GlobalAlloc(GMEM_FIXED, nSize);

                CopyMemory(hDib, lpbi, nSize);
            }

            GlobalUnlock(pict.hmf);
        }

        GlobalFree(pict.hmf);
    }

exit:
    if (hPrefMem != NULL)
        GlobalFree(hPrefMem);

    if (hLib)
        FreeLibrary(hLib);

    return hDib;

#endif // _USE_FLT_API
   return NULL;
}

CGdiplusInit::CGdiplusInit(
    Gdiplus::DebugEventProc debugEventCallback       /*= 0*/,
    BOOL                    suppressBackgroundThread /*= FALSE*/,
    BOOL                    suppressExternalCodecs   /*= FALSE*/
)
{
    Gdiplus::GdiplusStartupInput StartupInput(
        debugEventCallback,
        suppressBackgroundThread,
        suppressExternalCodecs
    );

    StartupStatus = GdiplusSafeStartup(&Token, &StartupInput, this);
}

CGdiplusInit::~CGdiplusInit()
{
    if (StartupStatus == Gdiplus::Ok)
    {
        Gdiplus::GdiplusShutdown(Token);
    }
}

Gdiplus::Status
CGdiplusInit::GdiplusSafeStartup(
    ULONG_PTR                          *token,
    const Gdiplus::GdiplusStartupInput *input,
    Gdiplus::GdiplusStartupOutput      *output
)
{
    __try
    {
        return Gdiplus::GdiplusStartup(token, input, output);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return Gdiplus::GdiplusNotInitialized;
    }
}

BOOL GetGdiplusDecoders(UINT *pnCodecs, Gdiplus::ImageCodecInfo **ppCodecs)
{
    ASSERT(pnCodecs);
    ASSERT(ppCodecs);

    *ppCodecs = 0;
    *pnCodecs = 0;

    if (theApp.GdiplusInit.StartupStatus == Gdiplus::Ok)
    {
        __try
        {
            UINT cbCodecs;

            if (Gdiplus::GetImageDecodersSize(pnCodecs, &cbCodecs) == Gdiplus::Ok)
            {
                if (*pnCodecs > 0)
                {
                    *ppCodecs = (Gdiplus::ImageCodecInfo *) LocalAlloc(LMEM_FIXED, cbCodecs);

                    if (*ppCodecs != 0)
                    {
                        if (Gdiplus::GetImageDecoders(*pnCodecs, cbCodecs, *ppCodecs) == Gdiplus::Ok)
                        {
                            return TRUE;
                        }
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }

        LocalFree(*ppCodecs);

        *ppCodecs = 0;
        *pnCodecs = 0;
    }

    return FALSE;
}

BOOL GetGdiplusEncoders(UINT *pnCodecs, Gdiplus::ImageCodecInfo **ppCodecs)
{
    ASSERT(pnCodecs);
    ASSERT(ppCodecs);

    *ppCodecs = 0;
    *pnCodecs = 0;

    if (theApp.GdiplusInit.StartupStatus == Gdiplus::Ok)
    {
        __try
        {
            UINT cbCodecs;

            if (Gdiplus::GetImageEncodersSize(pnCodecs, &cbCodecs) == Gdiplus::Ok)
            {
                if (*pnCodecs > 0)
                {
                    *ppCodecs = (Gdiplus::ImageCodecInfo *) LocalAlloc(LMEM_FIXED, cbCodecs);

                    if (*ppCodecs != 0)
                    {
                        if (Gdiplus::GetImageEncoders(*pnCodecs, cbCodecs, *ppCodecs) == Gdiplus::Ok)
                        {
                            return TRUE;
                        }
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }

        LocalFree(*ppCodecs);

        *ppCodecs = 0;
        *pnCodecs = 0;
    }

    return FALSE;
}

BOOL GetClsidOfEncoder(REFGUID guidFormatID, CLSID *pClsid)
{
    Gdiplus::ImageCodecInfo *pCodecs = 0;
    UINT                     nCodecs = 0;

    GetGdiplusEncoders(&nCodecs, &pCodecs);

    for (UINT i = 0; i < nCodecs; ++i)
    {
        if (pCodecs[i].FormatID == guidFormatID)
        {
            if (pClsid)
            {
                *pClsid = pCodecs[i].Clsid;
            }

            LocalFree(pCodecs);

            return TRUE;
        }
    }

    LocalFree(pCodecs);

    return FALSE;
}

HGLOBAL LoadDIBGdiplus(LPCTSTR szFileName, GUID *pguidFltTypeUsed)
{
    // check that the BMP encoder exists

    CLSID ClsidBmpEncoder;

    if (GetClsidOfEncoder(WiaImgFmt_BMP, &ClsidBmpEncoder))
    {
         // let GDI+ import the file

        USES_CONVERSION;

        Gdiplus::Bitmap image(T2CW(szFileName));

        if (image.GetLastStatus() == Gdiplus::Ok)
        {
            // read the image type

            ASSERT(pguidFltTypeUsed);

            image.GetRawFormat(pguidFltTypeUsed);

            // create a stream that emulates a bmp file

            CComPtr<CBmpStream> pStream;
            
            if (CBmpStream::Create(&pStream) == S_OK)
            {
                // convert the image into a BMP

                if (image.Save(pStream, &ClsidBmpEncoder, 0) == Gdiplus::Ok)
                {
                    return pStream->GetBuffer();
                }

                pStream->FreeBuffer();
            }
        }
    }

    return 0;
}

HGLOBAL LoadDIBFromFile(LPCTSTR szFileName, GUID *pguidFltTypeUsed)
{
    // Try GDI+ filters first. If it fails to convert the image or 
    // if it's not available, try the old method

    HGLOBAL hResult = 0;

    if (theApp.GdiplusInit.StartupStatus == Gdiplus::Ok)
    {
        __try
        {
            hResult = LoadDIBGdiplus(szFileName, pguidFltTypeUsed);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    if (!hResult)
    {
        USES_CONVERSION;

        hResult = LoadDIBFromFileA(T2CA(szFileName), pguidFltTypeUsed);
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\loadimag.h ===
//
//  LoadImag.h
//
//  routines to load and decompress a graphics file using a MS Office
//  graphic import filter.
//

#ifndef _LOADIMAG_H_ 
#define _LOADIMAG_H_ 

class CGdiplusInit : public Gdiplus::GdiplusStartupOutput
{
public:
    CGdiplusInit(
        Gdiplus::DebugEventProc debugEventCallback       = 0,
        BOOL                    suppressBackgroundThread = FALSE,
        BOOL                    suppressExternalCodecs   = FALSE
    );

    ~CGdiplusInit();

private:
    static
    Gdiplus::Status
    GdiplusSafeStartup(
        ULONG_PTR                          *token,
        const Gdiplus::GdiplusStartupInput *input,
        Gdiplus::GdiplusStartupOutput      *output
    );

public:
    Gdiplus::Status StartupStatus;

private:
    ULONG_PTR Token;
};


#define GIF_SUPPORT
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
//  GetClsidOfEncoder
//

BOOL GetClsidOfEncoder(REFGUID guidFormatID, CLSID *pClsid);

//
//  LoadDIBFromFile
//
//  load a image file using a image import filter.
//

HGLOBAL LoadDIBFromFile(LPCTSTR szFileName, GUID *pguidFltTypeUsed);

//
// GetFilterInfo
//
BOOL GetInstalledFilters (BOOL bOpenFileDialog,int i,
                          LPTSTR szName, UINT cbName,
                          LPTSTR szExt, UINT cbExt,
                          LPTSTR szHandler, UINT cbHandler,
                          BOOL& bImageAPI);

//
// Get GDI+ codecs
//

BOOL GetGdiplusDecoders(UINT *pnCodecs, Gdiplus::ImageCodecInfo **ppCodecs);
BOOL GetGdiplusEncoders(UINT *pnCodecs, Gdiplus::ImageCodecInfo **ppCodecs);


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif //_LOADIMAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\ipframe.cpp ===
// ipframe.cpp : implementation of the CInPlaceFrame class
//

#include "stdafx.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "ipframe.h"
#include "minifwnd.h"
#include "imgwell.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "global.h"
#include "colorsrc.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CInPlaceFrame, COleIPFrameWnd)

#include "memtrace.h"

/***************************************************************************/
// CInPlaceFrame

BEGIN_MESSAGE_MAP(CInPlaceFrame, COleIPFrameWnd)
    //{{AFX_MSG_MAP(CInPlaceFrame)
    ON_WM_CREATE()
        ON_WM_SIZE()
        ON_WM_SYSCOLORCHANGE()
        ON_WM_CLOSE()
        //}}AFX_MSG_MAP

    ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)

    // Global help commands
    ON_COMMAND(ID_HELP_INDEX, OnHelpIndex)
    ON_COMMAND(ID_HELP_USING, OnHelpUsing)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnHelpIndex)
    ON_COMMAND(ID_CONTEXT_HELP, OnContextHelp)
   

        ON_UPDATE_COMMAND_UI(ID_VIEW_TOOL_BOX, COleIPFrameWnd::OnUpdateControlBarMenu)
        ON_COMMAND_EX(ID_VIEW_TOOL_BOX, COleIPFrameWnd::OnBarCheck)
        ON_UPDATE_COMMAND_UI(ID_VIEW_COLOR_BOX, COleIPFrameWnd::OnUpdateControlBarMenu)
        ON_COMMAND_EX(ID_VIEW_COLOR_BOX, COleIPFrameWnd::OnBarCheck)
END_MESSAGE_MAP()

/***************************************************************************/
// CInPlaceFrame construction/destruction

CInPlaceFrame::CInPlaceFrame()
    {
    theApp.m_pwndInPlaceFrame = this;
    }

/***************************************************************************/

CInPlaceFrame::~CInPlaceFrame()
    {
    theApp.m_pwndInPlaceFrame = NULL;
    theApp.m_hwndInPlaceApp   = NULL;

    g_pStatBarWnd = 0;
    g_pImgToolWnd = 0;
    g_pImgColorsWnd = 0;
    }

/***************************************************************************/

CWnd* CInPlaceFrame::GetMessageBar()
    {
    CPBFrame* pwndMain = (CPBFrame*)theApp.m_pMainWnd;

    if (pwndMain                   != NULL
    &&  pwndMain->m_statBar.m_hWnd != NULL)
        return &(pwndMain->m_statBar);

    return NULL;
    }

/***************************************************************************/

int CInPlaceFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
    {
    if (COleIPFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    // CResizeBar implements in-place resizing.
    if (! m_wndResizeBar.Create( this ))
        {
        TRACE(TEXT("MSPaint Failed to create resize bar\n"));
        return -1;      // fail to create
        }

    // By default, it is a good idea to register a drop-target that does
    //  nothing with your frame window.  This prevents drops from
    //  "falling through" to a container that supports drag-drop.
    m_dropTarget.Register( this );

    return 0;
    }

/******************************************************************************/

BOOL CInPlaceFrame::OnCreateControlBars( CFrameWnd* pWndFrame, CFrameWnd* pWndDoc )
    {
    theApp.m_hwndInPlaceApp = pWndFrame->GetSafeHwnd();

    CPBView* pView = (CPBView*)GetActiveView();

    ASSERT( pView != NULL );

    if (pView == NULL || ! pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        return FALSE;

        g_pStatBarWnd = &m_statBar;
        g_pImgToolWnd = &m_toolBar;
        g_pImgColorsWnd = &m_colorBar;

    pView->SetTools();

    return TRUE;
    }

/***************************************************************************/

void CInPlaceFrame::RepositionFrame( LPCRECT lpPosRect, LPCRECT lpClipRect )
    {
    COleIPFrameWnd::RepositionFrame( lpPosRect, lpClipRect );

        // The other control bars can overlap and result in mispaints
    if ( IsWindow(m_wndResizeBar.m_hWnd) )
                m_wndResizeBar.Invalidate();
    }

/***************************************************************************/

void CInPlaceFrame::OnSize(UINT nType, int cx, int cy)
    {
    COleIPFrameWnd::OnSize( nType, cx, cy );


        TRACE( TEXT("MSPaint New Size %d x %d\n"), cx, cy );
    }

/***************************************************************************/
// CInPlaceFrame diagnostics

#ifdef _DEBUG
void CInPlaceFrame::AssertValid() const
    {
    COleIPFrameWnd::AssertValid();
    }

/***************************************************************************/

void CInPlaceFrame::Dump(CDumpContext& dc) const
    {
    COleIPFrameWnd::Dump(dc);
    }
#endif //_DEBUG

/***************************************************************************/

void CInPlaceFrame::OnSysColorChange()
{
        COleIPFrameWnd::OnSysColorChange();

        ResetSysBrushes();
}

/***************************************************************************/


void CInPlaceFrame::OnClose()
{
        // TODO: Add your message handler code here and/or call default
        SaveBarState(TEXT("General"));
        CancelToolMode (FALSE);
        COleIPFrameWnd::OnClose();
}

void CInPlaceFrame::OnHelpIndex()
{
    ::HtmlHelpA( ::GetDesktopWindow(), "mspaint.chm", HH_DISPLAY_TOPIC, 0L );
}

LRESULT CInPlaceFrame::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
        // Just make sure this message does not get passed to the parent
        return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\interlac.h ===
/*********************************************************************
   Interlace.h

   Header file for interlace module.
 *********************************************************************/
#ifndef  _INTERLACE_H
#define  _INTERLACE_H

#include "Image.h"

#define  NUM_PASSES  7

#pragma pack(2)      /* Apparently, this is reasonably important  */

/* The primary state data structure.           */
typedef struct
{
	IFLCLASS Class;
	long     iImageHeight;
	long     iImageWidth;
	long     cbPixelSize;

	long     cScanBlocks;
	long     cPassScanLines[NUM_PASSES];
	long     cTotalScanLines;
	long     iPass;
	long     iPassLine;
	long     iScanLine;
	long     iImageLine;

} ADAM7_STRUCT, *pADAM7_STRUCT;


//************************************************************************************
// Given an image described by the parameters of the ADAM7_STRUCT, calculate the
// number of scan lines in the image file which has been interlaced using the Adam7 
// scheme.
//************************************************************************************
int iADAM7CalculateNumberOfScanLines(pADAM7_STRUCT ptAdam7);

//************************************************************************************
// Generate a deinterlaced DIB; i.e., each pixel is in BGR in the case
// of RGB/RGBA image classes, and raster line data is stored in a contiguous block.
//************************************************************************************
// The CALLING application is responsible for deallocating the structure created by
// this function.
LPBYTE *ppbADAM7InitDIBPointers(LPBYTE pbDIB, pADAM7_STRUCT ptAdam7, DWORD cbImageLine);

// The following returns TRUE if the scan line was an empty scan line.
BOOL ADAM7AddRowToDIB(LPBYTE *ppbDIBPtrs, LPBYTE pbScanLine, pADAM7_STRUCT ptAdam7);

//************************************************************************************

//************************************************************************************
// Generate a deinterlaced image; i.e., each pixel is in RGB in the case
// of RGB/RGBA image classes, and raster line data may not necessarily be stored 
// in one contiguous block of memory.
//************************************************************************************

// The following returns TRUE if the scan line was an empty scan line.
BOOL ADAM7AddRowToImageBuffer(LPBYTE ppbInmageBuffer[], LPBYTE pbScanLine, pADAM7_STRUCT ptAdam7);
//************************************************************************************

//************************************************************************************
// Generate a deinterlaced alpha channel data block.
//************************************************************************************
BOOL ADAM7RMFDeinterlaceAlpha(LPWORD *ppwInterlaced, LPWORD *ppwDeinterlaced,
                              IFL_ALPHA_CHANNEL_INFO *ptIFLAlphaInfo);

#endif // _INTERLACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\ofn.h ===
#ifndef OFN_H
#define OFN_H

#pragma pack(push, 8)

class COpenFileName
{
public:

    COpenFileName(BOOL bOpenFileDialog);
    ~COpenFileName();

    int DoModal();

    BOOL m_bOpenFileDialog;

    OPENFILENAME *m_pofn;
};

#pragma pack(pop)

#endif //OFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\memtrace.h ===
// Enable memory leak detection in non-CObject based code.

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\minifwnd.h ===
// minifwnd.h : Declares the interface to the CMiniFrmWnd class.
//

#ifndef __MINIFWND_H__
#define __MINIFWND_H__

/////////////////////////////////////////////////////////////////////////////

class CDocking;

class CMiniFrmWnd : public CFrameWnd
    {
    DECLARE_DYNAMIC( CMiniFrmWnd )

    public:

    CMiniFrmWnd();

    BOOL Create( const TCHAR FAR* lpWindowName, DWORD dwStyle,
                 const RECT& rect, CWnd* pParentWnd );

    afx_msg void    OnNcLButtonDown( UINT nHitTest, CPoint pt );
    afx_msg void    OnLButtonUp    ( UINT nFlags, CPoint pt );
    afx_msg int     OnCreate       ( LPCREATESTRUCT lpCreateStruct);
    afx_msg void    OnSysCommand   ( UINT nID, LONG lParam);
    afx_msg LRESULT OnHelpHitTest  ( WPARAM wParam, LPARAM lParam);
    afx_msg void    OnRButtonDown  ( UINT nFlags, CPoint point);
    afx_msg void    OnKeyDown      ( UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg LRESULT OnMoving       ( WPARAM fwSide, LPARAM lprc );
    afx_msg void    OnMove         ( int x, int y );
    afx_msg BOOL    OnNcActivate   ( BOOL bActive );

    virtual BOOL OnCommand( UINT wParam, LONG lParam );

    virtual WORD GetHelpOffset() = 0;       // All of our minifwnds need help.

    DECLARE_MESSAGE_MAP()

    protected:

    CDocking*   m_pDocking;
    CPBView::DOCKERS m_Dockable;

    void CancelDrag();
    };

/////////////////////////////////////////////////////////////////////////////

#endif // __MINIFWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\msffdefs.h ===
/*----------------------------------------------------------------------------
| Module    : hildefs.h
|
| Purpose   : platform dependent include file for HALO Imaging Library for
|             Microsoft Windows NT
|
| History   : 4/21/94
|
| Copyright 1990-1994 Media Cybernetics, Inc.
|-----------------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*-----------------------------------------------------------------
| Define the platform
|------------------------------------------------------------------*/
#define HIL_WINDOWS32     1

#ifndef _WINDOWS_
#define	WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

#define	DllExport	__declspec(dllexport)
#define DllImport	__declspec(dllimport)

#ifdef	_X86_
#define FLTAPI			__stdcall
#else
#define FLTAPI			__cdecl
#endif
#define HILAPI			__cdecl

typedef float *                 LPFLOAT;
typedef double *                LPDOUBLE;
typedef void *                  HPVOID;
typedef LPBYTE *                LPLPBYTE;
#ifndef	LPBOOL
typedef BOOL *                  LPBOOL;
#endif

typedef short *                 LPSHORT;

#ifndef S_IRUSR
#define S_IRUSR		00400
#endif
#ifndef S_IWUSR
#define S_IWUSR		00200
#endif
#ifndef S_IRGRP
#define S_IRGRP		00040
#endif
#ifndef S_IWGRP
#define	S_IWGRP		00020
#endif
#ifndef S_IROTH
#define S_IROTH		00004
#endif
#ifndef S_IWOTH
#define S_IWOTH		00002
#endif	
#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\mapi.h ===
/*
 *  m a p i . h
 *    
 *  Messaging Applications Programming Interface.
 *    
 *  Copyright (c) 1992-1993, Microsoft Corporation.  All rights reserved.
 *    
 *  Purpose:
 *    This file defines the structures and constants used by
 *    that subset of the messaging applications programming
 *    interface which will be supported under Windows by
 *    Microsoft Mail for PC Networks vesion 3.2.
 */



/*
 *  Types.
 */



typedef unsigned long       ULONG;
typedef unsigned long FAR * LPULONG;
typedef unsigned long       FLAGS;
typedef unsigned long		LHANDLE, FAR *LPLHANDLE;
#define	lhSessionNull	((LHANDLE)0)

typedef struct
  {
    ULONG ulReserved;    /* Reserved for future use (must be 0) */
	ULONG flFlags;		 /* Flags */
    ULONG nPosition;     /* character in text to be replaced by attachment */
    LPTSTR lpszPathName;  /* Full path name of attachment file */
    LPTSTR lpszFileName;  /* Original file name (optional) */
    LPVOID lpFileType;   /* Attachment file type (optional) */
  } MapiFileDesc, FAR * lpMapiFileDesc;

#define	MAPI_OLE						0x00000001
#define	MAPI_OLE_STATIC					0x00000002




typedef struct
  {
    ULONG ulReserved;           /* Reserved for future use */
    ULONG ulRecipClass;         /* Recipient class */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG */
    LPTSTR lpszName;             /* Recipient name */
    LPTSTR lpszAddress;          /* Recipient address (optional) */
    ULONG ulEIDSize;	        /* Count in bytes of size of pEntryID */
    LPVOID lpEntryID;           /* System-specific recipient reference */
  } MapiRecipDesc, FAR * lpMapiRecipDesc;

#define MAPI_ORIG   0           /* Recipient is message originator */
#define MAPI_TO     1           /* Recipient is a primary recipient */
#define MAPI_CC     2           /* Recipient is a copy recipient */
#define MAPI_BCC    3           /* Recipient is blind copy recipient */



typedef struct
  {
    ULONG ulReserved;                   /* Reserved for future use (M.B. 0) */
    LPTSTR lpszSubject;                  /* Message Subject */
    LPTSTR lpszNoteText;                 /* Message Text */
    LPTSTR lpszMessageType;              /* Message Class */
    LPTSTR lpszDateReceived;             /* in YYYY/MM/DD HH:MM format    */
	LPTSTR lpszConversationID;			/* conversation thread ID */
    FLAGS flFlags;                      /* unread,return receipt */
    lpMapiRecipDesc lpOriginator;       /* Originator descriptor */
    ULONG nRecipCount;                  /* Number of recipients */
    lpMapiRecipDesc lpRecips;           /* Recipient descriptors */
    ULONG nFileCount;                   /* # of file attachments */
    lpMapiFileDesc lpFiles;             /* Attachment descriptors */
  } MapiMessage, FAR * lpMapiMessage;

#define MAPI_UNREAD             0x00000001
#define MAPI_RECEIPT_REQUESTED  0x00000002
#define MAPI_SENT               0x00000004



/*
 *  Entry points.
 */



#define MAPI_LOGON_UI                   0x00000001  /* Display logon UI */
#define MAPI_NEW_SESSION                0x00000002  /* Do not use default. */
#define MAPI_DIALOG                     0x00000008  /* Display a send note UI */
#define MAPI_UNREAD_ONLY                0x00000020  /* Only unread messages */
#define MAPI_ENVELOPE_ONLY              0x00000040  /* Only header information */
#define MAPI_PEEK                       0x00000080  /* Do not mark as read. */
#define MAPI_GUARANTEE_FIFO				0x00000100	/* use date order */
#define	MAPI_BODY_AS_FILE				0x00000200
#define MAPI_AB_NOMODIFY				0x00000400	/* Don't allow mods of AB entries */
#define	MAPI_SUPPRESS_ATTACH			0x00000800	/* header + body, no files */
#define	MAPI_FORCE_DOWNLOAD				0x00001000	/* force download of new mail during MAPILogon */

ULONG FAR PASCAL MAPILogon(ULONG ulUIParam, LPTSTR lpszName, LPTSTR lpszPassword,
                           FLAGS flFlags, ULONG ulReserved,
                           LPLHANDLE lplhSession);

ULONG FAR PASCAL MAPILogoff(LHANDLE lhSession, ULONG ulUIParam, FLAGS flFlags,
                            ULONG ulReserved);

ULONG FAR PASCAL MAPISendMail(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessage lpMessage, FLAGS flFlags,
                              ULONG ulReserved);

ULONG FAR PASCAL MAPISendDocuments(ULONG ulUIParam, LPTSTR lpszDelimChar,
                                   LPTSTR lpszFilePaths, LPTSTR lpszFileNames,
                                   ULONG ulReserved);

ULONG FAR PASCAL MAPIFindNext(LHANDLE lhSession, ULONG ulUIParam,
                              LPTSTR lpszMessageType, LPTSTR lpszSeedMessageID,
                              FLAGS flFlags, ULONG ulReserved,
                              LPTSTR lpszMessageID);

ULONG FAR PASCAL MAPIReadMail(LHANDLE lhSession, ULONG ulUIParam,
                              LPTSTR lpszMessageID, FLAGS flFlags,
                              ULONG ulReserved, lpMapiMessage FAR *lppMessageOut);

ULONG FAR PASCAL MAPISaveMail(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessage pMessage, FLAGS flFlags,
                              ULONG ulReserved, LPTSTR lpszMessageID);

ULONG FAR PASCAL MAPIDeleteMail(LHANDLE lhSession, ULONG ulUIParam,
                                LPTSTR lpszMessageID, FLAGS flFlags,
                                ULONG ulReserved);

ULONG FAR PASCAL MAPIFreeBuffer( LPVOID pv );
							
ULONG FAR PASCAL MAPIAddress(LHANDLE lhSession, ULONG ulUIParam,
					LPTSTR plszCaption, ULONG nEditFields,
					LPTSTR lpszLabels, ULONG nRecips,
					lpMapiRecipDesc lpRecips, FLAGS flFlags, ULONG ulReserved, 
					LPULONG lpnNewRecips, lpMapiRecipDesc FAR *lppNewRecips);

ULONG FAR PASCAL MAPIDetails(LHANDLE lhSession, ULONG ulUIParam,
					lpMapiRecipDesc lpRecip, FLAGS flFlags, ULONG ulReserved);

ULONG FAR PASCAL MAPIResolveName(LHANDLE lhSession, ULONG ulUIParam,
						LPTSTR lpszName, FLAGS flFlags,
						ULONG ulReserved, lpMapiRecipDesc FAR *lppRecip);



#define SUCCESS_SUCCESS                     0
#define MAPI_USER_ABORT                     1
#define MAPI_E_FAILURE                      2
#define MAPI_E_LOGIN_FAILURE                3
#define MAPI_E_DISK_FULL                    4
#define MAPI_E_INSUFFICIENT_MEMORY          5
#define MAPI_E_ACCESS_DENIED				6
#define MAPI_E_TOO_MANY_SESSIONS            8
#define MAPI_E_TOO_MANY_FILES               9
#define MAPI_E_TOO_MANY_RECIPIENTS          10
#define MAPI_E_ATTACHMENT_NOT_FOUND         11
#define MAPI_E_ATTACHMENT_OPEN_FAILURE      12
#define MAPI_E_ATTACHMENT_WRITE_FAILURE     13
#define MAPI_E_UNKNOWN_RECIPIENT            14
#define MAPI_E_BAD_RECIPTYPE                15
#define MAPI_E_NO_MESSAGES                  16
#define MAPI_E_INVALID_MESSAGE              17
#define MAPI_E_TEXT_TOO_LARGE               18
#define	MAPI_E_INVALID_SESSION				19
#define	MAPI_E_TYPE_NOT_SUPPORTED			20
#define	MAPI_E_AMBIGUOUS_RECIPIENT			21
#define MAPI_E_MESSAGE_IN_USE				22
#define MAPI_E_NETWORK_FAILURE				23
#define	MAPI_E_INVALID_EDITFIELDS			24
#define	MAPI_E_INVALID_RECIPS				25
#define	MAPI_E_NOT_SUPPORTED				26
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\minifwnd.cpp ===
// minifwnd.cpp : Defines the behaviors for the CMiniFrmWnd class.
//

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "docking.h"
#include "minifwnd.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CMiniFrmWnd, CFrameWnd )

#include "memtrace.h"

/***************************************************************************/

BEGIN_MESSAGE_MAP( CMiniFrmWnd, CFrameWnd )
    ON_WM_NCLBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_RBUTTONDOWN()
    ON_WM_KEYDOWN()
    ON_WM_CREATE()
    ON_WM_SYSCOMMAND()
    ON_WM_MOVE()
    ON_WM_NCACTIVATE()
    ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)
    ON_MESSAGE(WM_MOVING, OnMoving)
END_MESSAGE_MAP()

static CString NEAR szClass;

/***************************************************************************/

CMiniFrmWnd::CMiniFrmWnd()
    {
    if (szClass.IsEmpty())
        {
        // NOTE: we create this brush for use in WNDCLASS.hbrBackground.
        //      We intentionally don't delete it.  It will be deleted by Windows
        //      when the class gets deleted (after app termination).
//      HBRUSH hbrGrayBack = ::CreateSolidBrush( ::GetSysColor( COLOR_BTNTEXT ) );

        szClass = AfxRegisterWndClass( CS_DBLCLKS, ::LoadCursor( NULL, IDC_ARROW ),
                              (HBRUSH)(COLOR_BTNFACE + 1)/* hbrGrayBack */, NULL );
        }

    m_Dockable = CPBView::unknown;
    m_pDocking = NULL;
    }

/***************************************************************************/

BOOL CMiniFrmWnd::Create( const TCHAR FAR* lpWindowName, DWORD dwStyle,
                            const RECT& rect, CWnd* pParentWnd )
    {
    return CFrameWnd::Create( szClass, lpWindowName,
                              dwStyle | WS_POPUPWINDOW | WS_CAPTION,
                              rect, pParentWnd, NULL,
                              WS_EX_TOOLWINDOW | WS_EX_WINDOWEDGE, NULL );
    }

/***************************************************************************/

void CMiniFrmWnd::OnNcLButtonDown( UINT nHitTest, CPoint pt )
    {
    if (nHitTest  == HTCAPTION
    && m_Dockable != CPBView::unknown)
        {
        m_pDocking = new CDocking;

        ASSERT( m_pDocking );

        if (m_pDocking)
            {
            CRect rect;

            GetWindowRect( &rect );

            if (! m_pDocking->Create( pt, rect, FALSE, m_Dockable ))
                {
                delete m_pDocking;
                m_pDocking = NULL;
                }
            }
        }

    CFrameWnd::OnNcLButtonDown( nHitTest, pt );
    }

/***************************************************************************/

void CMiniFrmWnd::OnLButtonUp( UINT nFlags, CPoint pt )
    {
    CFrameWnd::OnLButtonUp( nFlags, pt );
    }

/***************************************************************************/

int CMiniFrmWnd::OnCreate( LPCREATESTRUCT lpCreateStruct )
    {
    CMenu* pMenu = GetSystemMenu(FALSE);

    if (pMenu != NULL)
        {
        pMenu->RemoveMenu(          7, MF_BYPOSITION);
        pMenu->RemoveMenu(          5, MF_BYPOSITION);
        pMenu->RemoveMenu(SC_RESTORE , MF_BYCOMMAND);
        pMenu->RemoveMenu(SC_MINIMIZE, MF_BYCOMMAND);
        pMenu->RemoveMenu(SC_MAXIMIZE, MF_BYCOMMAND);
        pMenu->RemoveMenu(SC_TASKLIST, MF_BYCOMMAND);
        }

    return CFrameWnd::OnCreate(lpCreateStruct);
    }

/***************************************************************************/

BOOL CMiniFrmWnd::OnCommand(UINT wParam, LONG lParam)
    {
    if (LOWORD(lParam) == 0 && wParam >= SC_SIZE)
        {
        PostMessage(WM_SYSCOMMAND, wParam, lParam);
        return TRUE;
        }

    return CFrameWnd::OnCommand(wParam, lParam);
    }

/***************************************************************************/

void CMiniFrmWnd::OnSysCommand(UINT nID, LONG lParam)
    {
    switch (nID & 0xfff0)
        {
        case SC_PREVWINDOW:
        case SC_NEXTWINDOW:
            if (LOWORD( lParam ) == VK_F6)
                {
                GetParent()->SetFocus();
                return;
                }
            break;

        case SC_KEYMENU:
            if (LOWORD(lParam) != TEXT('-'))
                {
                GetParent()->SetActiveWindow();
                GetParent()->SendMessage( WM_SYSCOMMAND, nID, lParam );
                SetActiveWindow();
                }
            return;
        }

    CFrameWnd::OnSysCommand( nID, lParam );
    }

/***************************************************************************/

LRESULT CMiniFrmWnd::OnHelpHitTest( WPARAM, LPARAM )
    {
    ASSERT( GetHelpOffset() );

    return HID_BASE_RESOURCE + GetHelpOffset();
    }

/******************************************************************************/

void CMiniFrmWnd::OnRButtonDown( UINT nFlags, CPoint point )
    {
    if (m_pDocking)
        PostMessage( WM_COMMAND, VK_ESCAPE );

    CFrameWnd::OnRButtonDown( nFlags, point );
    }

/******************************************************************************/

void CMiniFrmWnd::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags )
    {
    if (nChar == VK_ESCAPE && m_pDocking)
        CancelDrag();

    CFrameWnd::OnKeyDown( nChar, nRepCnt, nFlags );
    }

/***************************************************************************/

void CMiniFrmWnd::CancelDrag()
    {
    m_pDocking->Clear();

    delete m_pDocking;

    m_pDocking = NULL;
    }

/******************************************************************************/

LRESULT CMiniFrmWnd::OnMoving( WPARAM, LPARAM lprc )
    {
    LRESULT lResult = 0;

    if (m_pDocking)
        {
        CPoint pt;
        CRect  rect( (LPRECT)lprc );

        GetCursorPos( &pt );

        m_pDocking->Move( pt, rect );

        *((LPRECT)lprc) = rect;
        }

    return lResult;
    }

/******************************************************************************/

void CMiniFrmWnd::OnMove( int x, int y )
    {
    CFrameWnd::OnMove( x, y );

    if (! m_pDocking)
        return;

    CRect rect;
    BOOL bDocked = m_pDocking->Clear( &rect );

    delete m_pDocking;
    m_pDocking = NULL;

    CPBView* pView = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();

    if (pView == NULL || ! pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        return;

    if (! bDocked)
        {
        pView->SetFloatPos( m_Dockable, rect );
        return;
        }


    }

/******************************************************************************/

BOOL CMiniFrmWnd::OnNcActivate(BOOL bActive)
{
    //
    // Work-around MFC bug - CMiniFrmWnd inherits from CFrameWnd,
    // so it inherits the intentional bug in CFrameWnd::OnActivate
    // MFC's CMiniFrameWnd has this hack, so does CMiniFrmWnd now...
    //

    if (m_nFlags & WF_KEEPMINIACTIVE)
	    {
		return FALSE;
	    }

    return CFrameWnd::OnNcActivate(bActive);
}

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pbrusdoc.cpp ===
// pbrusdoc.cpp : implementation of the CPBDoc class
//

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "srvritem.h"
#include "bmobject.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgdlgs.h"
#include "tedit.h"
#include "t_text.h"
#include "undo.h"
#include "cmpmsg.h"
#include "ferr.h"
#include "loadimag.h"
#include "saveimag.h"
#include "colorsrc.h"
#include "props.h"
#include <shlobj.h>


#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CPBDoc, COleServerDoc)

#include "memtrace.h"


/***************************************************************************/
// CPBDoc

BEGIN_MESSAGE_MAP(CPBDoc, COleServerDoc)
    //{{AFX_MSG_MAP(CPBDoc)
        ON_COMMAND(ID_FILE_SAVE_COPY_AS, OnFileSaveCopyAs)
        ON_COMMAND(ID_FILE_SEND, OnFileSendMail)
        ON_COMMAND(ID_FILE_UPDATE, MyOnFileUpdate)
        ON_UPDATE_COMMAND_UI(ID_FILE_SEND, OnUpdateFileSendMail)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_INTERFACE_MAP(CPBDoc, COleServerDoc)
    INTERFACE_PART(CPBDoc, IID_IPersistStorage, PBPersistStg)
END_INTERFACE_MAP()

/***************************************************************************/
// CPBDoc construction/destruction

CPBDoc::CPBDoc()
    {
    m_bObjectLoaded = FALSE;
    m_pBitmapObj    = NULL;
    m_pBitmapObjNew = NULL;
    m_bNewDoc       = TRUE;
    m_bPaintFormat  = FALSE;
    m_bNonBitmapFile= FALSE;
    m_bSaveViaFilter= FALSE;
    m_bManualTruncate= FALSE;
    m_bHasSeenAFileError= FALSE;
    }

/***************************************************************************/

CPBDoc::~CPBDoc()
    {
    if (m_pBitmapObj)
        delete m_pBitmapObj;
    }

/***************************************************************************/
//
// SetDibHandle replaces the current image with the DIB
// indicated by hdib
//
void CPBDoc::SetDibHandle (HGLOBAL hDib)
{
     CWaitCursor DisplayWaitCursor;

     if (m_pBitmapObj->ReadResource (hDib)) 
     {
         m_pBitmapObj->ReLoadImage (this);

         LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER) GlobalLock(hDib);

         if (lpbi)
         {
             if (lpbi->biBitCount == 1)
             {
                 m_pBitmapObj->SetIntProp (P_Colors, 1);
             }

             GlobalUnlock(hDib);
         }
    
         m_pBitmapObj->SetDirty( TRUE );
         SetModifiedFlag( TRUE );

         if (theApp.m_bEmbedded)
            NotifyChanged();
     }
}

BOOL CPBDoc::OnNewDocument()
    {
    if (! Finish())
        return FALSE;

    m_bObjectLoaded = FALSE;
    m_bNewDoc       = TRUE;
    m_bNonBitmapFile= FALSE;
    m_bSaveViaFilter= FALSE;
    m_sName.Empty();
    g_bUseTrans = FALSE;
    crTrans = TRANS_COLOR_NONE;
    theApp.m_sCurFile.Empty();

    if (! CreateNewDocument()
    ||  ! COleServerDoc::OnNewDocument())
        {
        if (m_pBitmapObjNew)
            {
            delete m_pBitmapObjNew;
            m_pBitmapObjNew = 0;
            }
        return FALSE;
        }
    return TRUE;
    }

/***************************************************************************/

BOOL CPBDoc::OnOpenDocument( const TCHAR* pszPathName )
    {
    m_bObjectLoaded = FALSE;
    m_bNonBitmapFile= FALSE;
    m_bSaveViaFilter= FALSE;
    g_bUseTrans = FALSE;
    crTrans = TRANS_COLOR_NONE;
    theApp.m_sCurFile = pszPathName;


    if (pszPathName != NULL)
        {
        if (theApp.m_bEmbedded)
            theApp.m_bLinked = TRUE;

        m_bNewDoc = FALSE;
        m_sName   = pszPathName;

#ifdef PCX_SUPPORT
        if (! theApp.m_bPCXfile)
            {
            CString cStrExt = GetExtension( pszPathName );
            CString cStrPCXExt;

            cStrPCXExt.LoadString( IDS_EXTENSION_PCX );

            // is it a PCX extension?
            theApp.m_bPCXfile = ! cStrExt.CompareNoCase( cStrPCXExt );
            }
#endif

        // preset the file name in case of errors.
        theApp.SetFileError( IDS_ERROR_OPEN, CFileException::none, pszPathName );
        }
    else
        {
        m_bNewDoc = TRUE; /* not really but we don't have a name */
        m_sName.Empty();
        }

    #ifdef _DEBUG
    if (theApp.m_bEmbedded)
        TRACE( TEXT("MSPaint Open %s Document.\n"), (theApp.m_bLinked? TEXT("Linked"): TEXT("Embedded")) );
    #endif

    if (! CreateNewDocument())
        return FALSE;

    return COleServerDoc::OnOpenDocument( pszPathName );
    }

/***************************************************************************/

BOOL CPBDoc::OnSaveDocument( const TCHAR* pszPathName )
    {
    ASSERT( m_pBitmapObj != NULL );

    if (! Finish() || ! COleServerDoc::OnSaveDocument( pszPathName ))
        return FALSE;

    // Set the name if the thing doesn't have a name yet...
    if (m_pBitmapObj->m_bTempName && pszPathName != NULL)
        {
        m_pBitmapObj->m_bTempName   = FALSE;
        }

    m_pBitmapObj->SetDirty( FALSE );
    theApp.m_sCurFile = pszPathName;
    return TRUE;
    }

/***************************************************************************/

CFile* CPBDoc::GetFile(LPCTSTR lpszFileName, UINT nOpenFlags,
	CFileException* pError)
{
    // While saving a file, MFC opens the file with CREATE_ALWAYS flag.
    // But this wipes out the file summary info that the user has spent so much time editing (!)
    // We don't want that, so we will open the file with the OPEN_ALWAYS flag,
    // which does not disturb the summary info. But if the new file is shorter
    // than the old file, we need to manually truncate the file. So when we are 
    // done, we will SetEndOfFile() in CPBDoc::ReleaseFile()

    // modeCreate maps to CREATE_ALWAYS
    // modeCreate + modeNoTruncate maps to OPEN_ALWAYS
    // So if MFC calls us with modeCreate only, we will also set modeNoTruncate

    m_bManualTruncate = 
         (nOpenFlags & CFile::modeCreate) &&
        !(nOpenFlags & CFile::modeNoTruncate);

    if (m_bManualTruncate)
        nOpenFlags |= CFile::modeNoTruncate;

    // If we modify a file, the shell somehow cannot detect this and cannot
    // update the thumbnails view. So we will be nice and notify the shell

    if (nOpenFlags & (CFile::modeWrite | CFile::modeReadWrite))
    {
        // we should notify the shell if we are changing (writing to) a file

        // determine the type of notification

        WIN32_FIND_DATA fd;

        HANDLE hFind = FindFirstFile(lpszFileName, &fd);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            // If the file previously exists, this means we will be updating it

            m_wChangeNotifyEventId = SHCNE_UPDATEITEM;

            FindClose(hFind);
        }
        else
        {
            // otherwise we will be creating a new file

            m_wChangeNotifyEventId = SHCNE_CREATE;
        }
    }
    else
    {
        // if we are only reading the file, no need for a notification

        m_wChangeNotifyEventId = 0;
    }

    // Copy MFC's implementation of CDocument::GetFile()
    // With one exception, do not use the CMirrorFile mess...

	CFile* pFile = new CFile;
	ASSERT(pFile != NULL);

	if (!pFile->Open(lpszFileName, nOpenFlags, pError))
	{
		delete pFile;
		pFile = NULL;
	}

	return pFile;
}

void CPBDoc::ReleaseFile(CFile* pFile, BOOL bAbort)
{
    // manually set the end of file if needed

    if (m_bManualTruncate) 
    {
        SetEndOfFile((HANDLE) pFile->m_hFile);
    }

    // cache the file name before the file object gets deleted

    CString strFileName = pFile->GetFilePath();

    // call the parent

    CDocument::ReleaseFile(pFile, bAbort);

    // notify the shell if needed

    if (m_wChangeNotifyEventId != 0)
    {
        SHChangeNotify(m_wChangeNotifyEventId, SHCNF_PATH, strFileName, 0);
    }
}

/***************************************************************************/

void CPBDoc::ReportSaveLoadException(LPCTSTR lpszPathName, CException* e,
    BOOL bSaving, UINT nIDPDefault)
{
    if(m_bHasSeenAFileError) {

        m_bHasSeenAFileError = FALSE;

    } else {
        // the app doesn't know about the error so let mfc complain
        COleServerDoc::ReportSaveLoadException(lpszPathName, e, bSaving,
            nIDPDefault);
    }
}

/***************************************************************************/

BOOL CPBDoc::CanCloseFrame( CFrameWnd* pFrame )
    {
    TRACE3("CanCloseFrame: %d %s %s\n",m_bNonBitmapFile, (LPCTSTR)GetTitle(), (LPCTSTR)GetPathName());

    if (! Finish() || ! COleServerDoc::CanCloseFrame( pFrame ))
        return FALSE;

    theUndo.Flush();

    return TRUE;
    }

/***************************************************************************/

BOOL CPBDoc::SaveModified()
{
    TRACE2("SaveModified %d %s\n", IsModified(), (LPCTSTR)GetPathName());
    return COleServerDoc::SaveModified();
}

/***************************************************************************/

BOOL CPBDoc::DoSave(LPCTSTR lpszPathName, BOOL bReplace)
{
    CancelToolMode(FALSE);

    BOOL bCannotSaveInCurrentFormat = m_bNonBitmapFile && 
        !GetClsidOfEncoder(theApp.m_guidFltTypeUsed, NULL);

    int iColors = m_pBitmapObj->m_nColors;
    int iOldColors = iColors;

    CString newName = lpszPathName;
    if (bCannotSaveInCurrentFormat || newName.IsEmpty())
    {
        CDocTemplate* pTemplate = GetDocTemplate();
        ASSERT(pTemplate != NULL);

		newName = m_strPathName;
		if (bReplace && newName.IsEmpty())
		{
			newName = m_strTitle;
			// check for dubious filename
			int iBad = newName.FindOneOf(_T("#%;/\\"));
			if (iBad != -1)
				newName.ReleaseBuffer(iBad);

            // append the default suffix if there is one
            CString strExt;
			if (pTemplate->GetDocString(strExt, CDocTemplate::filterExt) &&
			  !strExt.IsEmpty())
			{
				ASSERT(strExt[0] == '.');
				newName += strExt;
			}
        }

        // If the filename is not null, 
        // drop the extension in prompt a la Internet Explorer, and let
        // the Save As dialog append one appropriately.
        if (GetName(newName) != _T(""))
        {
            newName = StripExtension(newName);
        }

		if (!theApp.DoPromptFileName(newName,
		  bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
		  OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, iColors, FALSE))
			return FALSE;       // don't even attempt to save

        // check if any color reduction will be performed, including the
        // case of saving any 24-bit image to 8 bit GIF.
        if (((iOldColors < 4 && iColors < iOldColors)||
            (iOldColors == 3 && iColors >=4 &&
            WiaImgFmt_GIF == theApp.m_guidFltType[iColors-4])) &&
            AfxMessageBox(IDS_WARNING_COLORSAVE, MB_YESNO|MB_ICONEXCLAMATION)==IDNO)
        {
            // abort immediately if the user didn't confirm the operation
            return FALSE;
        }

        if (iColors < 4 && iColors >= 0)
        {
           m_bNonBitmapFile = FALSE;
           m_bSaveViaFilter = FALSE;
           m_pBitmapObj->m_nSaveColors = iColors;
           theApp.m_guidFltTypeUsed = WiaImgFmt_UNDEFINED;
        }
        else
        {
           m_bNonBitmapFile = TRUE;
           m_bSaveViaFilter = TRUE;
           theApp.m_guidFltTypeUsed = theApp.m_guidFltType[iColors-4];
           //theApp.FixExtension (newName, theApp.m_guidFltTypeUsed);
        }
    }

    CWaitCursor wait;

#ifdef ICO_SUPPORT

    m_pBitmapObj->m_bSaveIcon = (iColors == 5);

    if (m_pBitmapObj->m_bSaveIcon)
    {
        m_pBitmapObj->Free();
        m_pBitmapObj->Export(newName);
        m_pBitmapObj->m_bSaveIcon = FALSE; // always reset after use
        m_pBitmapObj->Free();

        return TRUE;
    }

#endif

    BOOL bSavedDifferentFormat = (iColors != m_pBitmapObj->m_nColors);

    if (bSavedDifferentFormat)
        m_pBitmapObj->Free();

    if (!OnSaveDocument(newName))
    {
		if (lpszPathName == NULL)
		{
            // be sure to delete the file
            TRY
            {
                CFile::Remove( newName );
            }
            CATCH_ALL(e)
            {
                TRACE0( "Warning: failed to delete file after failed SaveAs\n" );
            }
            END_CATCH_ALL
		}
		return FALSE;
    }

    if (bSavedDifferentFormat)
    {
        m_pBitmapObj->ReLoadImage( this );
        //
        // We only want the first 16 color chips for 16 color images
        //
        g_pColors->ResetColors ((iColors==1)?16:256);
    }

    // reset the title and change the document name
    if (bReplace)
        SetPathName(newName);


    //
    // MFC sets the modified flag when user invokes OnFileSaveCopyAs.
    // Then if the user exits paint the storage in the container is never
    // updated because paint thinks it's already done it.
    // So after saving, set the dirty flag to true
    if (!lpszPathName && !bReplace)
    {
       SetModifiedFlag(TRUE);
    }

    return TRUE;
}

/***************************************************************************/
// CPBDoc server implementation

COleServerItem* CPBDoc::OnGetEmbeddedItem()
    {
    // OnGetEmbeddedItem is called by the framework to get the COleServerItem
    //  that is associated with the document.  It is only called when necessary.

    CPBSrvrItem* pItem = new CPBSrvrItem( this );

    ASSERT_VALID( pItem );

    return pItem;
    }

/***************************************************************************/

COleServerItem* CPBDoc::OnGetLinkedItem( LPCTSTR lpszItemName )
    {
    ASSERT_VALID( m_pBitmapObj );

    // look in current list first
    COleServerItem* pItem = COleServerDoc::OnGetLinkedItem( lpszItemName );

    if (pItem)
        return pItem;

    pItem = new CPBSrvrItem( this );

    ASSERT_VALID( pItem );

    // return new item that matches lpszItemName
    return pItem;
    }

/***************************************************************************/
// CPBDoc serialization

BOOL CPBDoc::SerializeBitmap(CArchive& ar, CBitmapObj* pBitmapCur,
        CBitmapObj* pBitmapNew, BOOL bOLEObject)
{
   BOOL success = FALSE;

   if (ar.IsStoring())
   {
      // Always write the PBrush OLE format
      CBitmapObj::PBResType rtType = !bOLEObject ? CBitmapObj::rtFile :
                       CBitmapObj::rtPBrushOLEObj;
      if (!m_bSaveViaFilter)
      {
         success = pBitmapCur->WriteResource( ar.GetFile(), rtType );
      }
      else if (!bOLEObject && theApp.m_guidFltTypeUsed != WiaImgFmt_UNDEFINED)
      {
         // in order for the filter export interface to work, here we
         // close the file first after saving its name, so that a filter
         // can open it later to do the export...
         CString str = ar.GetFile()->GetFilePath();
         ar.GetFile()->Close();
         success = SaveDIBToFile( str, theApp.m_guidFltTypeUsed, pBitmapCur );
         if (!success)
         {
            theApp.SetFileError (IDS_ERROR_SAVE, ferrSaveAborted);
         }
         // now reopen the file again as if nothing had really happened
         // (any mode option can be used since the file will be closed
         // immediately after return)
         CFileException fe;
         ar.GetFile()->Open(str, CFile::modeRead | CFile::shareExclusive, &fe);

      }


   }
   else
   {
      CBitmapObj::PBResType rtType = !bOLEObject ? CBitmapObj::rtFile :
                     m_bPaintFormat ? CBitmapObj::rtPaintOLEObj :
                     CBitmapObj::rtPBrushOLEObj;

      success = pBitmapNew->ReadResource( ar.GetFile(), rtType );

      //
      // if we cant open the file, lets try using a filter.
      //
      if (success)
      {
         m_bNonBitmapFile = FALSE;
         m_bSaveViaFilter = FALSE;
      }
      else if (!bOLEObject)
         {
            HGLOBAL hDib;

            if (hDib = LoadDIBFromFile(theApp.GetLastFile(), &theApp.m_guidFltTypeUsed))
            {
                success = pBitmapNew->ReadResource(hDib);

                if (success)
                {
                    // we loaded a non .bmp file
                    m_bNonBitmapFile = TRUE;
                    m_bSaveViaFilter = TRUE;
                    // set no error
                    theApp.SetFileError(0, CFileException::none);
                }
            }
            else
            {
               theApp.SetFileError(IDS_ERROR_READLOAD,
                                   ferrNotValidBmp);

            }

         }

    }


    return(success);
}

void CPBDoc::Serialize( CArchive& ar )
{
        m_bObjectLoaded = SerializeBitmap(ar, m_pBitmapObj, m_pBitmapObjNew, FALSE);

        if (!m_bObjectLoaded)  // much less than ideal but oh well
        {

                theApp.FileErrorMessageBox ();
                m_bHasSeenAFileError = TRUE;
                // let mfc know so it can tidy up internally...
                AfxThrowFileException(CFileException::invalidFile);

        }
}

void CPBDoc::OLESerialize( CArchive& ar )
{
        m_bObjectLoaded = SerializeBitmap(ar, m_pBitmapObj, m_pBitmapObjNew, TRUE);

        if (!m_bObjectLoaded)  // much less than ideal but oh well
        {
                // let mfc know so it can tidy up internally...
                AfxThrowFileException(CFileException::invalidFile);
        }
}


STDMETHODIMP CPBDoc::XPBPersistStg::QueryInterface(
        REFIID iid, LPVOID* ppvObj)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP_(ULONG) CPBDoc::XPBPersistStg::AddRef()
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CPBDoc::XPBPersistStg::Release()
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return pThis->ExternalRelease();
}

STDMETHODIMP CPBDoc::XPBPersistStg::GetClassID(LPCLSID pclsid)
{
        // Always return the CLSID for PBrush
        *pclsid = CLSID_PaintBrush;
        return(NOERROR);
}

STDMETHODIMP CPBDoc::XPBPersistStg::IsDirty()
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.IsDirty());
}

STDMETHODIMP CPBDoc::XPBPersistStg::InitNew(LPSTORAGE pstg)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.InitNew(pstg));
}

STDMETHODIMP CPBDoc::XPBPersistStg::Load(LPSTORAGE pstg)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.Load(pstg));
}

STDMETHODIMP CPBDoc::XPBPersistStg::Save(LPSTORAGE pstg, BOOL bSameAsLoad)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.Save(pstg, bSameAsLoad));
}

STDMETHODIMP CPBDoc::XPBPersistStg::SaveCompleted(LPSTORAGE pstg)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.SaveCompleted(pstg));
}

STDMETHODIMP CPBDoc::XPBPersistStg::HandsOffStorage()
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.HandsOffStorage());
}


#define NO_CPP_EXCEPTION(x) x
static const TCHAR szOle10Native[] = TEXT("\1Ole10Native");
static const TCHAR szOle10ItemName[] = TEXT("\1Ole10ItemName");

/////////////////////////////////////////////////////////////////////////////
// Helpers for saving to IStorage based files
//  (these are used in the 'docfile' implementation as well as for servers)

static const TCHAR szContents[] = TEXT("Contents");

void CPBDoc::SaveToStorage(CObject* pObject)
{
        ASSERT(m_lpRootStg != NULL);

        // create Contents stream
        COleStreamFile file;
        CFileException fe;
        if (!file.CreateStream(m_lpRootStg, szOle10Native,
                CFile::modeWrite|CFile::shareExclusive|CFile::modeCreate, &fe))
        {
                AfxThrowFileException(fe.m_cause, fe.m_lOsError);
        }

        // save to Contents stream
        CArchive saveArchive(&file, CArchive::store | CArchive::bNoFlushOnDelete);
        saveArchive.m_pDocument = this;
        saveArchive.m_bForceFlat = FALSE;

        TRY
        {
                // save the contents
                if (pObject != NULL)
                        pObject->Serialize(saveArchive);
                else
                        OLESerialize(saveArchive);
                saveArchive.Close();
                file.Close();

                if (pObject != NULL)
                {
                        if (file.CreateStream(m_lpRootStg, szOle10ItemName,
                                CFile::modeWrite|CFile::shareExclusive|CFile::modeCreate, &fe))
                        {
                                LPCTSTR szItemName;
                                DWORD dwLen;
                                CString strItemName = ((CPBSrvrItem*)pObject)->GetItemName();

                                if (strItemName.IsEmpty())
                                {
                                        szItemName = TEXT("");
                                        dwLen = 1;
                                }
                                else
                                {
                                        szItemName = strItemName;
                                        dwLen = lstrlen(szItemName) + 1;
                                }

                                file.Write( &dwLen, sizeof( dwLen ));
                                file.Write( &szItemName, dwLen);

                                file.Close();
                        }
                }

                SCODE sc;

                // Always write the CLSID for PBrush
                sc = WriteClassStg(m_lpRootStg, CLSID_PaintBrush);
                if (sc != NOERROR)
                        AfxThrowOleException(sc);

                sc = WriteFmtUserTypeStg(m_lpRootStg, (WORD)RegisterClipboardFormat(TEXT("PBrush")),
                    L"PBrush");
                if (sc != NOERROR)
                    AfxThrowOleException(sc);

                // commit the root storage
                sc = m_lpRootStg->Commit(STGC_ONLYIFCURRENT);
                if (sc != NOERROR)
                        AfxThrowOleException(sc);
        }
        CATCH_ALL(e)
        {
                file.Abort();   // will not throw an exception
                CommitItems(FALSE); // abort save in progress
                NO_CPP_EXCEPTION(saveArchive.Abort());
                THROW_LAST();
        }
        END_CATCH_ALL
}

void CPBDoc::LoadFromStorage()
{
        ASSERT(m_lpRootStg != NULL);

        // open Contents stream
        COleStreamFile file;
        CFileException fe;
        if (file.OpenStream(m_lpRootStg, szOle10Native,
                CFile::modeReadWrite|CFile::shareExclusive, &fe))
        {
                m_bPaintFormat = FALSE;
        }
        else if (file.OpenStream(m_lpRootStg, szContents,
                CFile::modeReadWrite|CFile::shareExclusive, &fe))
        {
                m_bPaintFormat = TRUE;
        }
        else
        {
                AfxThrowFileException(fe.m_cause, fe.m_lOsError);
        }


        // load it with CArchive (loads from Contents stream)
        CArchive loadArchive(&file, CArchive::load | CArchive::bNoFlushOnDelete);
        loadArchive.m_pDocument = this;
        loadArchive.m_bForceFlat = FALSE;

        TRY
        {
                OLESerialize(loadArchive);     // load main contents
                loadArchive.Close();
                file.Close();
        }
        CATCH_ALL(e)
        {
                file.Abort();   // will not throw an exception
                DeleteContents();   // removed failed contents
                NO_CPP_EXCEPTION(loadArchive.Abort());
                THROW_LAST();
        }
        END_CATCH_ALL
}

/***************************************************************************/
// CPBDoc diagnostics

#ifdef _DEBUG
void CPBDoc::AssertValid() const
    {
    COleServerDoc::AssertValid();
    }

void CPBDoc::Dump(CDumpContext& dc) const
    {
    COleServerDoc::Dump(dc);
    }
#endif //_DEBUG

/***************************************************************************/
// CPBDoc commands

BOOL CPBDoc::CreateNewDocument()
    {
    CBitmapObj* pBitmapObj = NULL;
    //
    // If we have a window already, reset the color squares.
    // every doc starts with a white background
    //


    pBitmapObj = new CBitmapObj;
    pBitmapObj->MakeEmpty();
    if (AfxGetMainWnd())
    {
       g_pColors->ResetColors(256);
    }
    if (! pBitmapObj)
        return FALSE;

    m_pBitmapObjNew = pBitmapObj;

    pBitmapObj->m_bTempName = m_bNewDoc;
    pBitmapObj->m_bDirty    = FALSE;

    theUndo.Flush();

    return TRUE;
    }

/***************************************************************************/

BOOL CPBDoc::Finish()
    {
    CImgTool* pImgTool = CImgTool::GetCurrent();

    if (pImgTool != NULL && CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        POSITION pos = GetFirstViewPosition();

        ((CTextTool*)pImgTool)->CloseTextTool( ((CPBView*)GetNextView( pos ))->m_pImgWnd );
        }

    CommitSelection( FALSE );

    if (m_pBitmapObj == NULL)
        return TRUE;

    if (! m_pBitmapObj->SaveResource( TRUE ))
        return FALSE;

    if (m_pBitmapObj->IsDirty())
        {
        SetModifiedFlag();

        if (theApp.m_bEmbedded)
                NotifyChanged();
        }
    return TRUE;
    }

/***************************************************************************/

BOOL CPBDoc::SaveTheDocument()
    {
    if (IsModified() || m_bNonBitmapFile)
        OnFileSave();
    return TRUE;
    }

/***************************************************************************/

void CPBDoc::OnShowControlBars(CFrameWnd *pFrame, BOOL bShow)
{
        POSITION pos = GetFirstViewPosition();
        CPBView* pView = (CPBView*)(GetNextView( pos ));

        if ( bShow )
        {
                pView->SetTools();
                if ( pView->m_pImgWnd &&
                         pView->m_pImgWnd->GetZoom() > 1 )
                        pView->ShowThumbNailView();
        }
        else
        {
                pView->HideThumbNailView();
        }

        // FEATURE: What I should do is add an OnShowControlBars member to
        // CImgTool, but that's too big a change for right now
        if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
                CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();
                pTextTool->OnShowControlBars(bShow);
        }

        COleServerDoc::OnShowControlBars(pFrame,bShow);
}

class CCB : public CControlBar
{
public:
        void ForceDelayed(void);
};

void CCB::ForceDelayed(void)
{
        if (!this)
        {
                return;
        }

        BOOL bVis = GetStyle() & WS_VISIBLE;
        UINT swpFlags = 0;
        if ((m_nStateFlags & delayHide) && bVis)
                swpFlags = SWP_HIDEWINDOW;
        else if ((m_nStateFlags & delayShow) && !bVis)
                swpFlags = SWP_SHOWWINDOW;
        m_nStateFlags &= ~(delayShow|delayHide);
        if (swpFlags != 0)
        {
                SetWindowPos(NULL, 0, 0, 0, 0, swpFlags|
                        SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
        }
}

class CFW : public CFrameWnd
{
public:
        void ForceDelayed(void);
};

void CFW::ForceDelayed(void)
{
        if (!this)
        {
                return;
        }

        POSITION pos = m_listControlBars.GetHeadPosition();
        while (pos != NULL)
        {
                // show/hide the next control bar
                CCB* pBar = (CCB*)m_listControlBars.GetNext(pos);
                pBar->ForceDelayed();
        }
}

class COIPF : public COleIPFrameWnd
{
public:
        void ForceDelayed(void);
};

void COIPF::ForceDelayed(void)
{
        if (!this)
        {
                return;
        }

        ((CFW*)m_pMainFrame)->ForceDelayed();
        ((CFW*)m_pDocFrame )->ForceDelayed();
}

void CPBDoc::OnDeactivateUI(BOOL bUndoable)
{
COleServerDoc::OnDeactivateUI(bUndoable);

POSITION pos = GetFirstViewPosition();
CPBView* pView = (CPBView*)(GetNextView( pos ));
CancelToolMode (FALSE);
if (pView != NULL)
    {


        pView->HideThumbNailView();

        COIPF* pFrame = (COIPF*)m_pInPlaceFrame;
        pFrame->ForceDelayed();
    }
}

//
// We override OnUpdateDocument to ignore the modified flag. Certain MFC paths
// set the modified flag inappropriately, causing data loss.
BOOL CPBDoc::OnUpdateDocument ()
{
   // save a server document -> update
   TRY
   {
        SaveEmbedding();
   }
   CATCH_ALL(e)
   {
        AfxMessageBox(AFX_IDP_FAILED_TO_UPDATE);
        #ifndef _AFX_OLD_EXCEPTIONS
        e->Delete();
        #endif
        return FALSE;
   }
   END_CATCH_ALL

   return TRUE;
}

void CPBDoc::MyOnFileUpdate ()
{
   CancelToolMode (FALSE);
   OnFileUpdate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\ofn.cpp ===
#if      !defined(WINVER) || (WINVER < 0x0500)
#undef   WINVER
#pragma message("Defining WINVER as 0x0500")
#define  WINVER 0x0500
#endif //WINVER

#if      !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)
#undef   _WIN32_WINNT
#pragma message("Defining _WIN32_WINNT as 0x0500")
#define  _WIN32_WINNT 0x0500
#endif //_WIN32_WINNT

#if      !defined(_WIN32_WINDOWS) || (_WIN32_WINDOWS < 0x0500)
#undef   _WIN32_WINDOWS
#pragma message("Defining _WIN32_WINDOWS as 0x0500")
#define  _WIN32_WINDOWS 0x0500
#endif //_WIN32_WINDOWS

#if      !defined(_WIN32_IE) || (_WIN32_IE < 0x0500)
#undef   _WIN32_IE
#pragma message("Defining _WIN32_IE as 0x0500")
#define  _WIN32_IE 0x0500
#endif //_WIN32_IE

#include <windows.h>
#include <commdlg.h>
#include <cderr.h>

#include "ofn.h"

////////////////////////////////////////////////////////////////////////////
// 

COpenFileName::COpenFileName(BOOL bOpenFileDialog)
{
    m_bOpenFileDialog = bOpenFileDialog;

    m_pofn = new OPENFILENAME;

    if (m_pofn) 
    {
        ZeroMemory(m_pofn, sizeof(OPENFILENAME));
        m_pofn->lStructSize = sizeof(OPENFILENAME);
    }
}

COpenFileName::~COpenFileName()
{
    delete m_pofn;
}

int COpenFileName::DoModal()
{
	int nResult;

	if (m_bOpenFileDialog)
    {
		nResult = ::GetOpenFileName(m_pofn);
    }
	else
    {
		nResult = ::GetSaveFileName(m_pofn);
    }

	if (!nResult && (CDERR_STRUCTSIZE == CommDlgExtendedError())) 
    {
        // if comdlg32 does not recognize the OPENFILENAME size 
        // retry with the old (ver 4) struct size

        m_pofn->lStructSize = OPENFILENAME_SIZE_VERSION_400;
		
	    if (m_bOpenFileDialog)
        {
		    nResult = ::GetOpenFileName(m_pofn);
        }
	    else
        {
		    nResult = ::GetSaveFileName(m_pofn);
        }
	}

	return nResult ? nResult : IDCANCEL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pbrusdoc.h ===
// pbrusdoc.h : interface of the CPBDoc class
//
/***************************************************************************/

class CPBSrvrItem;
class CBitmapObj;

class CPBDoc : public COleServerDoc
    {
    protected: // create from serialization only

    CPBDoc();

    DECLARE_DYNCREATE( CPBDoc )

    // Attributes

    public:

    CBitmapObj* m_pBitmapObj;
    CBitmapObj* m_pBitmapObjNew;
    CString     m_sName;
    BOOL        m_bNewDoc;
    BOOL        m_bObjectLoaded;
    BOOL        m_bPaintFormat;
    BOOL        m_bNonBitmapFile;   // TRUE if we loaded a non .BMP file.
    BOOL        m_bSaveViaFilter;   // TRUE if using an installed filter
    BOOL        m_bManualTruncate;
    BOOL        m_bHasSeenAFileError;
    LONG        m_wChangeNotifyEventId;
    // Operations
    public:

    CPBSrvrItem* GetEmbeddedItem()
                    { return (CPBSrvrItem*)COleServerDoc::GetEmbeddedItem(); }
    BOOL CreateNewDocument();
    BOOL SaveTheDocument();
    BOOL Finish();

    void OLESerialize(CArchive& ar);   // overridden for document i/o
    BOOL SerializeBitmap(CArchive& ar, CBitmapObj* pBitmapCur,
        CBitmapObj* pBitmapNew, BOOL bOLEObject);
    void SetDibHandle (HGLOBAL hDib);
    // Implementation
    public:

    virtual ~CPBDoc();
    virtual void Serialize(CArchive& ar);   // overridden for document i/o

    virtual void SaveToStorage(CObject* pObject);
    virtual void LoadFromStorage();
    virtual     BOOL OnOpenDocument( const TCHAR* pszPathName );
    virtual     BOOL OnSaveDocument( const TCHAR* pszPathName );
    virtual     CFile* GetFile(LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError);
    virtual     void ReleaseFile(CFile* pFile, BOOL bAbort);
    virtual BOOL CanCloseFrame( CFrameWnd* pFrame );
    virtual BOOL SaveModified(); // return TRUE if ok to continue
    virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace=TRUE);
    virtual BOOL OnUpdateDocument ();
    virtual COleServerItem* OnGetEmbeddedItem();
    virtual COleServerItem* OnGetLinkedItem( LPCTSTR lpszItemName );

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    #endif

        // Must be public so it can be called from Escape handler
        virtual void OnDeactivateUI(BOOL bUndoable);

protected:
        DECLARE_INTERFACE_MAP()

        BEGIN_INTERFACE_PART(PBPersistStg, IPersistStorage)
                INIT_INTERFACE_PART(CPBDoc, PBPersistStg)
                STDMETHOD(GetClassID)(LPCLSID);
                STDMETHOD(IsDirty)();
                STDMETHOD(InitNew)(LPSTORAGE);
                STDMETHOD(Load)(LPSTORAGE);
                STDMETHOD(Save)(LPSTORAGE, BOOL);
                STDMETHOD(SaveCompleted)(LPSTORAGE);
                STDMETHOD(HandsOffStorage)();
        END_INTERFACE_PART(PBPersistStg)

    protected:

    virtual BOOL OnNewDocument();
        virtual void OnShowControlBars(CFrameWnd *pFrame, BOOL bShow);

    // Generated message map functions
    protected:

    //{{AFX_MSG(CPBDoc)
        afx_msg void MyOnFileUpdate();
        //}}AFX_MSG

    virtual void ReportSaveLoadException(LPCTSTR, CException*, BOOL, UINT);

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pbrusfrm.h ===
#ifndef __PBRUSFRM_H__
#define __PBRUSFRM_H__

#include "toolbox.h"

class CImagingMgr;

// pbrusfrm.h : interface of the CPBFrame class
//
/***************************************************************************/

class CPBFrame : public CFrameWnd
    {
    protected: /****** create from serialization only *************************/

    CPBFrame();

    DECLARE_DYNCREATE( CPBFrame )

    public: /*** Attributes ***************************************************/

    CPoint      m_ptPosition;
    CSize       m_szFrame;
    CSize       m_szFrameMin;

    CStatBar            m_statBar;
    CImgToolWnd         m_toolBar;
        CImgColorsWnd   m_colorBar;

    CImagingMgr *m_pMgr;

    public: /*** Implementation ***********************************************/

    virtual ~CPBFrame();

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump( CDumpContext& dc ) const;
    #endif

    protected: /***************************************************************/

    virtual BOOL PreCreateWindow( CREATESTRUCT& cs );
        virtual CWnd* GetMessageBar();
    virtual void ActivateFrame( int nCmdShow = -1 );
//  virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    afx_msg LRESULT OnFileError( WPARAM wParam, LPARAM lParam );

    // Generated message map functions
    //{{AFX_MSG(CPBFrame)
    afx_msg void OnUpdateAcquire (CCmdUI *pCmdUI);
    afx_msg void OnAcquire ();
    afx_msg void OnUpdateSelectSource(CCmdUI* pCmdUI);
    afx_msg void OnSelectSource();
    afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg BOOL OnQueryNewPalette();
    afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
        afx_msg void OnMove(int x, int y);
        afx_msg void OnSize(UINT nType, int cx, int cy);
        afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
    afx_msg void OnWinIniChange(LPCTSTR lpszSection);
        afx_msg void OnHelp();
        afx_msg void OnSysColorChange();
        afx_msg void OnClose();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
#endif // __PBRUSHFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pbrusvw.cpp ===
// pbrusvw.cpp : implementation of the CPBView class
//

#include "stdafx.h"

#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "ipframe.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "imageatt.h"
#include "undo.h"
#include "props.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgdlgs.h"
#include "toolbox.h"
#include "thumnail.h"
#include "t_text.h"
#include "cmpmsg.h"
#include "printres.h"
#include "settings.h"
#include "colorsrc.h"
#include "cderr.h"
#include "srvritem.h"

#include <regstr.h>

#ifdef USE_PRINTDLGEX
#include <afxprntx.h>
#include <dlgprnt2.cpp>
#endif //USE_PRINTDLGEX

#if 0 // THIS_FILE is already declared in dlgprnt2.cpp

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#endif 

IMPLEMENT_DYNCREATE(CPBView, CView)

#include "memtrace.h"


/***************************************************************************/
// CPBView

BEGIN_MESSAGE_MAP(CPBView, CView)
    //{{AFX_MSG_MAP(CPBView)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
    ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_COMMAND(ID_VIEW_GRID, OnViewGrid)
    ON_COMMAND(ID_VIEW_ZOOM_100, OnViewZoom100)
    ON_COMMAND(ID_VIEW_ZOOM_400, OnViewZoom400)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOM_100, OnUpdateViewZoom100)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOM_400, OnUpdateViewZoom400)
    ON_UPDATE_COMMAND_UI(ID_VIEW_GRID, OnUpdateViewGrid)
    ON_COMMAND(ID_IMAGE_INVERT_COLORS, OnImageInvertColors)
    ON_UPDATE_COMMAND_UI(ID_IMAGE_INVERT_COLORS, OnUpdateImageInvertColors)
    ON_COMMAND(IDM_TGLOPAQUE, OnTglopaque)
    ON_UPDATE_COMMAND_UI(IDM_TGLOPAQUE, OnUpdateTglopaque)
    ON_COMMAND(ID_IMAGE_ATTRIBUTES, OnImageAttributes)
    ON_COMMAND(IDMX_SEL2BSH, OnSel2bsh)
    ON_COMMAND(IDMX_LARGERBRUSH, OnLargerbrush)
    ON_COMMAND(IDMX_SMALLERBRUSH, OnSmallerbrush)
    ON_COMMAND(ID_VIEW_ZOOM, OnViewZoom)
    ON_COMMAND(ID_IMAGE_FLIP_ROTATE, OnImageFlipRotate)
    ON_UPDATE_COMMAND_UI(ID_IMAGE_FLIP_ROTATE, OnUpdateImageFlipRotate)
    ON_COMMAND(IDM_EDITCOLORS, OnEditcolors)
    ON_UPDATE_COMMAND_UI(IDM_EDITCOLORS, OnUpdateEditcolors)
#if 0
    ON_COMMAND(IDM_LOADCOLORS, OnLoadcolors)
    ON_UPDATE_COMMAND_UI(IDM_LOADCOLORS, OnUpdateLoadcolors)
    ON_COMMAND(IDM_SAVECOLORS, OnSavecolors)
    ON_UPDATE_COMMAND_UI(IDM_SAVECOLORS, OnUpdateSavecolors)
#endif
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_COMMAND(ID_EDIT_PASTE_FROM, OnEditPasteFrom)
    ON_COMMAND(ID_EDIT_COPY_TO, OnEditCopyTo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY_TO, OnUpdateEditCopyTo)
    ON_COMMAND(ID_IMAGE_STRETCH_SKEW, OnImageStretchSkew)
    ON_UPDATE_COMMAND_UI(ID_IMAGE_STRETCH_SKEW, OnUpdateImageStretchSkew)
    ON_COMMAND(ID_VIEW_VIEW_PICTURE, OnViewViewPicture)
    ON_UPDATE_COMMAND_UI(ID_VIEW_VIEW_PICTURE, OnUpdateViewViewPicture)
    ON_COMMAND(ID_VIEW_TEXT_TOOLBAR, OnViewTextToolbar)
    ON_UPDATE_COMMAND_UI(ID_VIEW_TEXT_TOOLBAR, OnUpdateViewTextToolbar)
    ON_COMMAND(ID_FILE_SETASWALLPAPER_T, OnFileSetaswallpaperT)
    ON_UPDATE_COMMAND_UI(ID_FILE_SETASWALLPAPER_T, OnUpdateFileSetaswallpaperT)
    ON_COMMAND(ID_FILE_SETASWALLPAPER_C, OnFileSetaswallpaperC)
    ON_UPDATE_COMMAND_UI(ID_FILE_SETASWALLPAPER_C, OnUpdateFileSetaswallpaperC)
    ON_COMMAND(ID_VIEW_THUMBNAIL, OnViewThumbnail)
    ON_UPDATE_COMMAND_UI(ID_VIEW_THUMBNAIL, OnUpdateViewThumbnail)
    ON_UPDATE_COMMAND_UI(ID_IMAGE_ATTRIBUTES, OnUpdateImageAttributes)
    ON_COMMAND(ID_ESCAPE, OnEscape)
    ON_COMMAND(ID_ESCAPE_SERVER, OnEscapeServer)
    ON_WM_SHOWWINDOW()
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditSelection)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateEditClearSel)
        ON_COMMAND(ID_FILE_PAGE_SETUP, OnFilePageSetup)
        ON_COMMAND(ID_IMAGE_CLEAR_IMAGE, OnImageClearImage)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditClearSel)
        ON_UPDATE_COMMAND_UI(ID_IMAGE_CLEAR_IMAGE, OnUpdateImageClearImage)
        //}}AFX_MSG_MAP

        ON_WM_DESTROY()



    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, OnFilePrintPreview)

END_MESSAGE_MAP()

/***************************************************************************/
// CPBView construction/destruction

CPBView::CPBView()
    {
    m_pImgWnd             = NULL;

    m_pwndThumbNailFloat  = NULL;
    m_pwndThumbNailView   = NULL;
    }

/***************************************************************************/

CPBView::~CPBView()
    {
    // reset the toolbar
    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) )
    {
        g_pImgToolWnd->SelectTool( IDMB_ARROW );
        g_pImgToolWnd->InvalidateOptions();
    }

    DestroyThumbNailView();

    if (m_pImgWnd)
        {
        delete m_pImgWnd;
        m_pImgWnd = NULL;
        }
    }

/***************************************************************************/

BOOL CPBView::PreCreateWindow( CREATESTRUCT& cs )
    {
    cs.style     |= WS_CLIPCHILDREN;
    cs.dwExStyle |= WS_EX_CLIENTEDGE;

    return CView::PreCreateWindow( cs );
    }


/***************************************************************************/

BOOL CPBView::PreTranslateMessage(MSG *pMsg)
        {
        // Handle a bug in MFC regarding enabling of accelerators on Popup menus.
        if ( pMsg->message == WM_KEYDOWN )
                {
                // Find the app menu for this window.
                CWnd    *pWnd = this;
                CMenu   *pMenu = NULL;
                while( pWnd )
                        {
                        if ( (pMenu = pWnd->GetMenu()) && IsMenu(pMenu->m_hMenu) )
                                break;
                        else
                                pMenu = NULL;
                        pWnd = pWnd->GetParent();
                        }

                if ( pMenu )
                        {
                        pMenu->EnableMenuItem( ID_VIEW_ZOOM_100, MF_BYCOMMAND |
                                (m_pImgWnd && m_pImgWnd->GetZoom() != 1 ? MF_ENABLED : MF_DISABLED) );
                        pMenu->EnableMenuItem( ID_VIEW_ZOOM_400, MF_BYCOMMAND |
                                (m_pImgWnd && m_pImgWnd->GetZoom() != 4 ? MF_ENABLED : MF_DISABLED) );
                        pMenu->EnableMenuItem( ID_VIEW_GRID, MF_BYCOMMAND |
                                (m_pImgWnd && m_pImgWnd->GetZoom() > 2 ? MF_ENABLED : MF_DISABLED) );
                        }
                }

        return CView::PreTranslateMessage(pMsg);
        }

/***************************************************************************/
// CPBView drawing

void CPBView::OnDraw( CDC* pDC )
    {
    if (m_pImgWnd)
        {
        CRect rectPaint;
        CPalette* ppal = m_pImgWnd->SetImgPalette( pDC, FALSE );

        // if the dc passed in is a CPaint DC use the rcPaint rect to optimize
        // painting to only paint the invalid area.  ELSE use the whole image
        // size.
        if (pDC->IsKindOf( RUNTIME_CLASS( CPaintDC ) )  )
            {
            rectPaint = ((CPaintDC *)pDC)->m_ps.rcPaint;
            if ( theApp.m_bEmbedded )
                                m_pImgWnd->Invalidate();
            }
        else
            {
            m_pImgWnd->GetImageRect( rectPaint );
            }

        m_pImgWnd->DrawImage( pDC, &rectPaint );

        if (ppal)
            pDC->SelectPalette( ppal, FALSE );
        }
    }

/***************************************************************************/
// CPBView printing

BOOL CPBView::GetPrintToInfo(CPrintInfo* pInfo)
{

        ASSERT(pInfo != NULL);
        ASSERT(pInfo->m_pPD != NULL);

        if (theApp.m_strPrinterName.IsEmpty())
                return FALSE;

        ASSERT(pInfo->m_pPD->m_pd.hDC == NULL);
        pInfo->m_pPD->m_pd.hDC = ::CreateDC(NULL,
                                            theApp.m_strPrinterName,
                                            NULL, NULL);

        // set up From and To page range from Min and Max
        pInfo->m_pPD->m_pd.nFromPage = (WORD)pInfo->GetMinPage();
        pInfo->m_pPD->m_pd.nToPage = (WORD)pInfo->GetMaxPage();

        ASSERT(pInfo->m_pPD != NULL);
        ASSERT(pInfo->m_pPD->m_pd.hDC != NULL);

        pInfo->m_nNumPreviewPages = theApp.m_nNumPreviewPages;
        VERIFY(pInfo->m_strPageDesc.LoadString(AFX_IDS_PREVIEWPAGEDESC));
        return TRUE;
}

BOOL CPBView::OnPreparePrinting( CPrintInfo* pInfo )
    {
#ifdef USE_PRINTDLGEX


    //
    // Create a C_PrintDialogEx structure to replace the PrintDialog in the
    // CPrintInfo
    //


    m_pdRestore= pInfo->m_pPD;
    m_pdexSub = new C_PrintDialogEx (FALSE, PD_RETURNDC | 
        PD_ALLPAGES | PD_NOCURRENTPAGE | PD_NOPAGENUMS | 
        PD_NOSELECTION | PD_USEDEVMODECOPIESANDCOLLATE);
    pInfo->m_pPD = m_pdexSub;

    // These next 2 lines copied from mfc42 source to initialize the printdialog
    //
    pInfo->SetMinPage (1);
    pInfo->SetMaxPage (0xffff);

    pInfo->m_pPD->m_pd.nFromPage = 1;
    pInfo->m_pPD->m_pd.nToPage = 1;

#endif //USE_PRINTDLGEX

    new CPrintResObj( this, pInfo );

    if (pInfo->m_lpUserData == NULL)
        return FALSE;

    if (theApp.m_bPrintOnly)
        {
        if (GetPrintToInfo(pInfo))
        {
            return(TRUE);
        }

        if (! theApp.GetPrinterDeviceDefaults( &pInfo->m_pPD->m_pd ))
            {
            // bring up dialog to alert the user they need to install a printer.
            if (theApp.DoPrintDialog( pInfo->m_pPD ) != IDOK)
                return FALSE;
            }

        if (! pInfo->m_pPD->m_pd.hDC)
            {
            // call CreatePrinterDC if DC was not created by above
            if (! pInfo->m_pPD->CreatePrinterDC())
                return FALSE;
            }

        // set up From and To page range from Min and Max
        pInfo->m_pPD->m_pd.nFromPage = (WORD)pInfo->GetMinPage();
        pInfo->m_pPD->m_pd.nToPage   = (WORD)pInfo->GetMaxPage();
            pInfo->m_nNumPreviewPages    = theApp.m_nNumPreviewPages;
        return TRUE;
        }

    // default preparation
    if (! DoPreparePrinting( pInfo ))
        {
        ((CPrintResObj*)pInfo->m_lpUserData)->EndPrinting( NULL, pInfo );
        pInfo->m_lpUserData = NULL;
        return FALSE;
        }
    return TRUE;
    }

/***************************************************************************/

void CPBView::OnBeginPrinting( CDC* pDC, CPrintInfo* pInfo )
    {

    if (pInfo               != NULL
    &&  pInfo->m_lpUserData != NULL)
        ((CPrintResObj*)pInfo->m_lpUserData)->BeginPrinting( pDC, pInfo );
    else
        CView::OnBeginPrinting( pDC, pInfo );
    }

/***************************************************************************/

void CPBView::OnPrepareDC( CDC* pDC, CPrintInfo* pInfo )
    {

#ifdef USE_MIRRORING
    //
    // Disable RTL mirroring
    //
    if (PBGetLayout(pDC->GetSafeHdc()) & LAYOUT_RTL)
    {
        PBSetLayout(pDC->GetSafeHdc(), 0);
    }
#endif

    CView::OnPrepareDC( pDC, pInfo );

    if (pInfo               != NULL
    &&  pInfo->m_lpUserData != NULL)
        ((CPrintResObj*)pInfo->m_lpUserData)->PrepareDC( pDC, pInfo );
    }

/***************************************************************************/

void CPBView::OnPrint( CDC* pDC, CPrintInfo* pInfo )
    {

    BOOL bProcessed = FALSE;

    if (pInfo               != NULL
    &&  pInfo->m_lpUserData != NULL)
        bProcessed = ((CPrintResObj*)pInfo->m_lpUserData)->PrintPage( pDC, pInfo );

    if (! bProcessed)
        CView::OnPrint( pDC, pInfo );
    }

/***************************************************************************/

void CPBView::OnEndPrinting( CDC* pDC, CPrintInfo* pInfo )
    {

    if (pInfo == NULL)
        return;

    if (pInfo->m_lpUserData != NULL)
        {
        ((CPrintResObj*)pInfo->m_lpUserData)->EndPrinting( pDC, pInfo );
        pInfo->m_lpUserData = NULL;
        }
#ifdef USE_PRINTDLGEX
    //
    // Restore the original dialog pointer
    //
    pInfo->m_pPD = m_pdRestore;
    delete m_pdexSub;
#endif //USE_PRINTDLGEX
    }

/******************************************************************************/

// CPBView diagnostics

#ifdef _DEBUG
void CPBView::AssertValid() const
    {
    CView::AssertValid();
    }

/***************************************************************************/

void CPBView::Dump( CDumpContext& dc ) const
    {
    CView::Dump( dc );
    }

/***************************************************************************/

CPBDoc* CPBView::GetDocument() // non-debug version is inline
    {
    ASSERT( m_pDocument->IsKindOf( RUNTIME_CLASS( CPBDoc ) ) );
    return (CPBDoc*)m_pDocument;
    }
#endif //_DEBUG

/***************************************************************************/
// CPBView message handlers
int CPBView::OnCreate( LPCREATESTRUCT lpCreateStruct )
    {
    if (CView::OnCreate( lpCreateStruct ) == -1)
        return -1;

#ifdef USE_MIRRORING
    //
    // Disable RTL mirroring on client drawing area. [samera]
    //
    if (lpCreateStruct->dwExStyle & WS_EX_LAYOUTRTL)
    {
        SetWindowLong( GetSafeHwnd(), GWL_EXSTYLE, lpCreateStruct->dwExStyle & ~WS_EX_LAYOUTRTL );
    }
#endif

    return 0;
    }

/***************************************************************************/

void CPBView::OnShowWindow( BOOL bShow, UINT nStatus )
    {
    if (theApp.m_bPrintOnly)
        return;

    CView::OnShowWindow( bShow, nStatus );
    }

/***************************************************************************/

void CPBView::OnDestroy()
    {
    // reset the toolbar
    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) )
    {
        g_pImgToolWnd->SelectTool( IDMB_ARROW );
        g_pImgToolWnd->InvalidateOptions();
    }

    DestroyThumbNailView();

    if (m_pImgWnd)
        {
        if ( ::IsWindow(m_pImgWnd->m_hWnd) )
            m_pImgWnd->DestroyWindow();

        delete m_pImgWnd;
        m_pImgWnd = NULL;
        }

    CView::OnDestroy();
    }

/***************************************************************************/

void CPBView::OnInitialUpdate( void )
    {
    CPBDoc* pDoc = GetDocument();

    if (SetObject())
        {
        if (theApp.m_bPrintOnly)
            {
            if (pDoc->m_bObjectLoaded)
                {
                OnFilePrint();

                GetParentFrame()->PostMessage( WM_CLOSE );
                return;
                }
            theApp.m_bPrintOnly = FALSE;
            }

        theUndo.SetMaxLevels( 3 );

        SetTools();
                }
    else
        {
        if (pDoc->m_pBitmapObjNew != NULL)
            {
            delete pDoc->m_pBitmapObjNew;
            pDoc->m_pBitmapObjNew = NULL;
            }

        TRACE( TEXT("OnInitialUpdate SetObject Failed!\n") );
        }
    }

/***************************************************************************/

void CPBView::OnActivateView( BOOL bActivate, CView* pActivateView,
                                              CView* pDeactiveView )
    {
    CView::OnActivateView( bActivate, pActivateView, pDeactiveView );
    }

/***************************************************************************/

BOOL CPBView::OnCmdMsg( UINT nID, int nCode, void* pExtra,
                       AFX_CMDHANDLERINFO* pHandlerInfo )
    {
    if (nCode == CN_COMMAND)
        {
        if (m_pImgWnd
        &&  m_pImgWnd->OnCmdMsg( nID, nCode, pExtra, pHandlerInfo ))
            return TRUE;
        }

    return CView::OnCmdMsg( nID, nCode, pExtra, pHandlerInfo );
    }

/***************************************************************************/


void CPBView::OnSize(UINT nType, int cx, int cy)
    {
    CView::OnSize( nType, cx, cy );

    // TODO: Add your message handler code here
    if (m_pImgWnd)
        m_pImgWnd->MoveWindow( 0, 0, cx, cy );
    }

/***************************************************************************/

BOOL CPBView::SetObject()
    {
    CPBDoc* pDoc = GetDocument();

    ASSERT( pDoc );
    ASSERT( pDoc->m_pBitmapObjNew );

    if (! pDoc || ! pDoc->m_pBitmapObjNew)
        return FALSE;

    CBitmapObj* pBitmapObj = pDoc->m_pBitmapObjNew;

    // see if a bad file was loaded, but not an empty file, which is OK
    if (! pDoc->m_bObjectLoaded
    &&  ! pBitmapObj->m_bTempName
    &&    pBitmapObj->m_hThing
    &&    pBitmapObj->m_lMemSize)
        {
        delete pBitmapObj;
                pBitmapObj = NULL;

        CString strDocName;
        CString strFilterExt;

        if (! pDoc->GetDocTemplate()->GetDocString( strDocName, CDocTemplate::docName )
        ||                                          strDocName.IsEmpty())
            // use generic 'untitled'
            VERIFY( strDocName.LoadString( AFX_IDS_UNTITLED ) );

        if (! pDoc->GetDocTemplate()->GetDocString( strFilterExt, CDocTemplate::filterExt )
        ||                                          strFilterExt.IsEmpty())
            pDoc->SetPathName( strDocName );
        else
            pDoc->SetPathName( strDocName + strFilterExt );

        // do settitle after setpathname.
        pDoc->SetTitle( strDocName );

        pDoc->m_sName.Empty();
        pDoc->m_bNewDoc = TRUE;

        if (! pDoc->CreateNewDocument())
            return FALSE;

        pBitmapObj = pDoc->m_pBitmapObjNew;
        }

    if (! pBitmapObj->m_pImg
    &&  ! pBitmapObj->CreateImg())
        return FALSE;

    if (pBitmapObj->m_pImg->cxWidth  < 1
    ||  pBitmapObj->m_pImg->cyHeight < 1)
        {
        CmpMessageBox( IDS_ERROR_BITMAPSIZE, AFX_IDS_APP_TITLE, MB_OK | MB_ICONEXCLAMATION );
        return FALSE;
        }

    CleanupImgUndo();
    CleanupImgRubber();

    if (! SetView( pBitmapObj ))
        return FALSE;

    if (pDoc->m_pBitmapObj)
                {
        delete pDoc->m_pBitmapObj;
                pDoc->m_pBitmapObj = NULL;
                }

    pDoc->m_pBitmapObj    = pBitmapObj;
    pDoc->m_pBitmapObjNew = NULL;

    return TRUE;
    }

/***************************************************************************/

BOOL CPBView::SetView( CBitmapObj* pBitmapObj )
    {
    IMG* pImg = pBitmapObj->m_pImg;

    ASSERT( pImg );

    CImgWnd* pImgWnd = new CImgWnd( pImg );

    if (pImgWnd == NULL)
        {
        theApp.SetMemoryEmergency();

        TRACE( TEXT("Create CImgWnd faild\n") );

        return FALSE;
        }

    RECT rectPos;

    GetClientRect( &rectPos );

    if (! pImgWnd->Create( WS_CHILD | WS_VISIBLE, rectPos, this ))
        {
        TRACE( TEXT("Create img wnd failed\n") );
        return FALSE;
        }

    if (m_pImgWnd)
                {
                if ( ::IsWindow( m_pImgWnd->m_hWnd) )
                        m_pImgWnd->DestroyWindow();
        delete m_pImgWnd;
                m_pImgWnd = NULL;
                }

    m_pImgWnd = pImgWnd;

    if (m_pwndThumbNailView != NULL)
        {
        m_pImgWnd->SetThumbnailView( m_pwndThumbNailView );
        m_pwndThumbNailView->UpdateThumbNailView();
        }

    m_pImgWnd->SetZoom( 1 );
    // m_pImgWnd->SetFocus(); // Commented out to prevent focus problems w/OLE

    return TRUE;
    }

/***************************************************************************/

int CPBView::SetTools()
    {
    CFrameWnd* pOwnerWindow    = GetParentFrame();
    CFrameWnd* pParentWindow   = pOwnerWindow;
    BOOL       bRestoreState   = FALSE;

    ASSERT( pOwnerWindow != NULL );

    if (! theApp.m_bLinked && theApp.m_pwndInPlaceFrame != NULL)
        {
        pOwnerWindow = theApp.m_pwndInPlaceFrame;

        if (theApp.m_hwndInPlaceApp != NULL)
            pParentWindow = (CFrameWnd*)CFrameWnd::FromHandle( theApp.m_hwndInPlaceApp );
        }


        ASSERT(g_pStatBarWnd);
        ASSERT(g_pImgToolWnd);
        ASSERT(g_pImgColorsWnd);

        // Create the status bar
        if ( !g_pStatBarWnd->m_hWnd )
                {
                if ( g_pStatBarWnd->Create(pParentWindow) )
                        {
                        if (theApp.m_fntStatus.m_hObject != NULL)
                                g_pStatBarWnd->SetFont( &theApp.m_fntStatus, FALSE );
                        g_pStatBarWnd->SetOwner(pOwnerWindow);
                        ShowStatusBar(TRUE);

                        bRestoreState = TRUE;
                        }
                else
                        {
                        TRACE0("Failed to create status bar\n");
                        return -1;
                        }
                }

        pParentWindow->EnableDocking(CBRS_ALIGN_ANY);

        // Create and dock the tool bar
        if ( !g_pImgToolWnd->m_hWnd || !IsWindow(g_pImgToolWnd->m_hWnd) )
                {
        CString strToolWnd;
        strToolWnd.LoadString(IDS_PAINT_TOOL);
                if ( g_pImgToolWnd->Create( strToolWnd,
                                            WS_CHILD|WS_VISIBLE|CBRS_LEFT,
                                            CRect(0, 0, 0, 0),
                                            CPoint(25, 25),
                                            2,
                                            pParentWindow ) )
                        {
                        g_pImgToolWnd->SetOwner(pOwnerWindow);
                        g_pImgToolWnd->EnableDocking(CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT);
                        pParentWindow->DockControlBar(g_pImgToolWnd,
                                                      AFX_IDW_DOCKBAR_LEFT);

                        bRestoreState = TRUE;
                        }
                else
                {
                        TRACE0("Failed to create toolbar\n");
                        return -1;
                        }
                }

        // Create and dock the color bar
        if ( !g_pImgColorsWnd->m_hWnd || !IsWindow(g_pImgColorsWnd->m_hWnd) )
                {
        CString strColorsWnd;
        strColorsWnd.LoadString(IDS_COLORS);
                if ( g_pImgColorsWnd->Create(strColorsWnd,
                                            WS_CHILD|WS_VISIBLE|CBRS_BOTTOM,
                                            pParentWindow) )
                        {
                        g_pImgColorsWnd->SetOwner(pOwnerWindow);
                        g_pImgColorsWnd->EnableDocking(CBRS_ALIGN_BOTTOM|CBRS_ALIGN_TOP);
                        pParentWindow->DockControlBar(g_pImgColorsWnd,
                                                     AFX_IDW_DOCKBAR_BOTTOM);

                        bRestoreState = TRUE;
                        }
                else
                        {
                        TRACE0("Failed to create colorbar\n");
                        return -1;
                        }
                }

    if ( bRestoreState && !theApp.m_bLinked && !theApp.m_bEmbedded && !theApp.m_pwndInPlaceFrame )
        pOwnerWindow->LoadBarState(TEXT("General")); // Dangerous in-place!

    pOwnerWindow->DelayRecalcLayout( TRUE );
        return 0;
    }

/******************************************************************************/
BOOL CPBView::DestroyThumbNailView()
        {
        BOOL    bResult = FALSE;
        BOOL    bOriginalSetting = theApp.m_bShowThumbnail;

    theApp.m_bShowThumbnail = FALSE;

    if (m_pwndThumbNailFloat != NULL)
        {
        if ( ::IsWindow(m_pwndThumbNailFloat->m_hWnd) )
                m_pwndThumbNailFloat->DestroyWindow();
                delete m_pwndThumbNailFloat;
                m_pwndThumbNailFloat = NULL;
                bResult = TRUE;
                }


    theApp.m_bShowThumbnail = bOriginalSetting;
    m_pwndThumbNailView = NULL;

        if (m_pImgWnd)
        m_pImgWnd->SetThumbnailView( NULL );

        return bResult;
        }

BOOL CPBView::CreateThumbNailView()
    {
    if (m_pImgWnd == NULL)
        return FALSE;

        DestroyThumbNailView();


        m_pwndThumbNailFloat = new CFloatThumbNailView( m_pImgWnd );

        if (m_pwndThumbNailFloat != NULL)
            {
            if (m_pwndThumbNailFloat->Create( this ))
                m_pwndThumbNailView = m_pwndThumbNailFloat->GetThumbNailView();

            if (m_pwndThumbNailView)
                {
                m_pImgWnd->SetThumbnailView( m_pwndThumbNailView );
                m_pwndThumbNailFloat->ShowWindow( SW_SHOWNOACTIVATE );
                }
            else
                                {
                                delete m_pwndThumbNailFloat;
                m_pwndThumbNailFloat = NULL;
                                }
            }


    if (m_pwndThumbNailView == NULL)
        {
        theApp.m_bShowThumbnail = FALSE;
        theApp.SetMemoryEmergency();

        TRACE( TEXT("Create CThumbNailView failed\n") );
        return FALSE;
        }

    m_pwndThumbNailView->ShowWindow( SW_SHOWNOACTIVATE );
    m_pwndThumbNailView->UpdateWindow();
    UpdateWindow();

    return TRUE;
    }

/***************************************************************************/

void CPBView::ToggleThumbNailVisibility( void )
    {
        theApp.m_bShowThumbnail = !IsThumbNailVisible();

        if ( theApp.m_bShowThumbnail )
                ShowThumbNailView();
        else if (m_pwndThumbNailView)
                HideThumbNailView();
    }

/***************************************************************************/

void CPBView::HideThumbNailView(void)
    {
    if (IsThumbNailVisible())
                {
            if (m_pwndThumbNailFloat)
                m_pwndThumbNailFloat->ShowWindow( SW_HIDE );


            theApp.m_bShowThumbnail = FALSE;
                }
    }

/***************************************************************************/

void CPBView::ShowThumbNailView(void)
    {
        if ( theApp.m_bShowThumbnail
          && !IsThumbNailVisible() )
                {
                if ( m_pwndThumbNailView )
                        {
                    if (m_pwndThumbNailFloat)
                        m_pwndThumbNailFloat->ShowWindow( SW_SHOWNOACTIVATE );

                        }
                else
                        CreateThumbNailView();
                }
    }

/***************************************************************************/

BOOL CPBView::IsThumbNailVisible(void)
    {
    BOOL bVisible = FALSE;


    if (m_pwndThumbNailFloat != NULL)
        bVisible = m_pwndThumbNailFloat->IsWindowVisible();

    return bVisible;
    }


/***************************************************************************/

CPoint CPBView::GetDockedPos( DOCKERS tool, CSize& sizeTool )
    {
    CPoint      pt;
    CRect       rectClient;
    CRect       rectView;
    CFrameWnd*  pFrame = GetParentFrame();

    pFrame->GetClientRect( &rectClient );
    pFrame->NegotiateBorderSpace( CFrameWnd::borderGet, &rectView );

    switch (tool)
        {
        case toolbox:
                        ASSERT(0);
            break;

        case colorbox:
                        ASSERT(0);
            break;

        }
    pt = rectView.TopLeft();
    pFrame->ClientToScreen( &pt );
    return pt;
    }

/***************************************************************************/

void CPBView::GetFloatPos( DOCKERS tool, CRect& rectPos )
    {
       // removed docked thumbnail code
    }

/***************************************************************************/

void CPBView::SetFloatPos( DOCKERS tool, CRect& rectPos )
    {
       //removed docked thumbnail code
     }

/***************************************************************************/

void CPBView::OnViewThumbnail()
    {
    ToggleThumbNailVisibility();
    }

/***************************************************************************/

void CPBView::OnUpdateViewThumbnail(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL
    &&  m_pImgWnd->GetZoom() > 1)
        {
        bEnable = TRUE;
        }

    pCmdUI->Enable( bEnable );
    pCmdUI->SetCheck( theApp.m_bShowThumbnail );
    }

/***************************************************************************/

void CPBView::OnEditUndo()
    {
    if (!TextToolProcessed( ID_EDIT_UNDO ))
        {
        CancelToolMode(FALSE);

        CommitSelection(TRUE);

        theUndo.DoUndo();
        DirtyImg (m_pImgWnd->m_pImg);
        }
    }

/***************************************************************************/

void CPBView::OnEditRedo()
    {
    CancelToolMode(FALSE);

    theUndo.DoRedo();
    DirtyImg (m_pImgWnd->m_pImg);
    }

/***************************************************************************/

void CPBView::OnEditCut()
    {
    m_pImgWnd->CmdCut();
    }

/***************************************************************************/

void CPBView::OnEditClear()
    {
    m_pImgWnd->CmdClear();
    }


/***************************************************************************/

void CPBView::OnEditCopy()
{
        m_pImgWnd->CmdCopy();
}

/***************************************************************************/

void CPBView::OnEditPaste()
    {
    m_pImgWnd->CmdPaste();
    }

/***************************************************************************/


void CPBView::OnUpdateEditUndo(CCmdUI* pCmdUI)
    {
    // the text tool has no idea if it can undo and neither do we
    pCmdUI->Enable(IsUserEditingText() || theUndo.CanUndo());
    }

/***************************************************************************/

void CPBView::OnUpdateEditRedo(CCmdUI* pCmdUI)
    {
    // the text tool does not have a redo stack
    pCmdUI->Enable(!IsUserEditingText() && theUndo.CanRedo());
    }

/***************************************************************************/

void CPBView::OnUpdateEditSelection(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL)
        {
        bEnable = m_pImgWnd->IsSelectionAvailable();
        }

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnUpdateEditClearSel(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL)
        bEnable = m_pImgWnd->IsSelectionAvailable();

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnUpdateEditPaste(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL)
        {
        bEnable = m_pImgWnd->IsPasteAvailable();
        }

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnViewGrid()
    {
    m_pImgWnd->CmdShowGrid();
    }

/***************************************************************************/

void CPBView::OnViewZoom100()
    {
    if (m_pImgWnd->GetZoom() != 1)
                {
                m_pImgWnd->SetZoom        ( 1 );
            m_pImgWnd->CheckScrollBars();
                }
    }

/***************************************************************************/

void CPBView::OnViewZoom400()
    {
    if (m_pImgWnd->GetZoom() != 4)
                {
            m_pImgWnd->SetZoom        ( 4 );
            m_pImgWnd->CheckScrollBars();
                }
    }

/***************************************************************************/

void CPBView::OnViewZoom()
    {
    CZoomViewDlg dlg;

    dlg.m_nCurrent = m_pImgWnd->GetZoom();

    if (dlg.DoModal() != IDOK)
        return;

    m_pImgWnd->SetZoom( dlg.m_nCurrent );
    m_pImgWnd->CheckScrollBars();
    }

/***************************************************************************/

void CPBView::OnUpdateViewZoom100(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd)
        bEnable = (m_pImgWnd->GetZoom() != 1);

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnUpdateViewZoom400(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd)
        bEnable = (m_pImgWnd->GetZoom() != 4);

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnUpdateViewGrid(CCmdUI* pCmdUI)
    {
    BOOL bCheck  = FALSE;
    BOOL bEnable = FALSE;

    if (m_pImgWnd)
        {
        bEnable = (m_pImgWnd->GetZoom() > 2);
        bCheck  =  m_pImgWnd->IsGridVisible();
        }
    pCmdUI->Enable  ( bEnable );
    pCmdUI->SetCheck( bCheck  );
    }

/***************************************************************************/

void CPBView::OnImageInvertColors()
    {
    CancelToolMode(TRUE);

    m_pImgWnd->CmdInvertColors();
    }

/***************************************************************************/
// Don't show the Invert Colors menu item if we're using a palette
void CPBView::OnUpdateImageInvertColors(CCmdUI* pCmdUI)
    {

    BOOL bEnable = FALSE;

    if (m_pImgWnd)
       {
       bEnable = (!theApp.m_bPaletted);
       }
   pCmdUI->Enable  ( bEnable );
   }

/***************************************************************************/

void CPBView::OnTglopaque()
    {
    m_pImgWnd->CmdTglOpaque();
    }

/***************************************************************************/

void CPBView::OnUpdateTglopaque(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( m_pImgWnd != NULL );
    pCmdUI->SetCheck( theImgBrush.m_bOpaque );
    }

/***************************************************************************/

void CPBView::OnImageAttributes()
    {
    CancelToolMode(FALSE);

    CPBDoc* pDoc = GetDocument();

    ASSERT( pDoc );
    ASSERT( m_pImgWnd );

    CBitmapObj* pBitmapRes = pDoc->m_pBitmapObj;

    CImageAttr dlg;

    BOOL bMono = (pBitmapRes->m_pImg->cPlanes   == 1
               && pBitmapRes->m_pImg->cBitCount == 1);

    dlg.m_bMonochrome = bMono;
    dlg.SetWidthHeight( pBitmapRes->m_pImg->cxWidth,
                        pBitmapRes->m_pImg->cyHeight,
                        pBitmapRes->m_pImg->cXPelsPerMeter,
                        pBitmapRes->m_pImg->cYPelsPerMeter);

    if (dlg.DoModal() != IDOK)
        return;

    CSize size = dlg.GetWidthHeight();

    if (size.cx != pBitmapRes->m_pImg->cxWidth
    ||  size.cy != pBitmapRes->m_pImg->cyHeight)
        {
        theUndo.BeginUndo( TEXT("Property Edit") );

        BOOL bSuccess = pBitmapRes->SetSizeProp( P_Size, size );

        theUndo.EndUndo();

        if (bSuccess)
            theApp.m_sizeBitmap = size;
        }

    if (dlg.m_bMonochrome != bMono
        && (!dlg.m_bMonochrome
            || AfxMessageBox(IDS_WARNING_MONO, MB_YESNO|MB_ICONEXCLAMATION)==IDYES))
        {
        theUndo.BeginUndo( TEXT("Property Edit") );

        pBitmapRes->SetIntProp( P_Colors, dlg.m_bMonochrome );

        theUndo.EndUndo();
        }
    }

/***************************************************************************/

void CPBView::OnImageClearImage()
    {
    CancelToolMode(FALSE);

    m_pImgWnd->CmdClear();
    }

/***************************************************************************/

void CPBView::OnFilePrint()
    {
    CancelToolMode(FALSE);

    CView::OnFilePrint();

    }

/***************************************************************************/

void CPBView::OnFilePrintPreview()
    {
    CancelToolMode(FALSE);

    CView::OnFilePrintPreview();
    }

/***************************************************************************/

void CPBView::OnUpdateImageClearImage( CCmdUI* pCmdUI )
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd)
        bEnable = (CImgTool::GetCurrentID() != IDMX_TEXTTOOL
                      && ! m_pImgWnd->IsSelectionAvailable() );
    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnSel2bsh()
    {
    m_pImgWnd->CmdSel2Bsh();
    }

/***************************************************************************/

void CPBView::OnLargerbrush()
    {
    m_pImgWnd->CmdLargerBrush();
    }

/***************************************************************************/

void CPBView::OnSmallerbrush()
    {
    m_pImgWnd->CmdSmallerBrush();
    }

/***************************************************************************/

void CPBView::OnImageFlipRotate()
    {
    CancelToolMode(TRUE);

    CFlipRotateDlg dlg;

    if (dlg.DoModal() != IDOK)
        return;

    if (dlg.m_bAngle)
        {
        switch (dlg.m_nAngle)
            {
            case 90:
                m_pImgWnd->CmdRot90();
                break;

            case 180:
                theUndo.BeginUndo( TEXT("Rotate 180") );

                m_pImgWnd->CmdFlipBshH();
                m_pImgWnd->CmdFlipBshV();

                theUndo.EndUndo();
                break;

            case 270:
                theUndo.BeginUndo( TEXT("Rotate 270") );

                m_pImgWnd->CmdRot90();
                m_pImgWnd->CmdFlipBshH();
                m_pImgWnd->CmdFlipBshV();

                theUndo.EndUndo();
                break;
            }
        }
    else
        if (dlg.m_bHorz)
            m_pImgWnd->CmdFlipBshH();
        else
            m_pImgWnd->CmdFlipBshV();
    }

/***************************************************************************/

void CPBView::OnUpdateImageFlipRotate(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( m_pImgWnd != NULL );
    }

/***************************************************************************/

void CPBView::OnEditcolors()
    {
    g_pColors->CmdEditColor();
    }

/***************************************************************************/

void CPBView::OnUpdateEditcolors(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( g_pColors != NULL );
    }

/***************************************************************************/
#if 0
void CPBView::OnLoadcolors()
    {
    CancelToolMode(FALSE);

    g_pColors->CmdLoadColors();
    }

/***************************************************************************/

void CPBView::OnUpdateLoadcolors(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (g_pColors && m_pImgWnd && m_pImgWnd->m_pImg &&
        m_pImgWnd->m_pImg->m_pBitmapObj)
        {
        // not allowed except on 24 bit images
        bEnable = ( m_pImgWnd->m_pImg->m_pBitmapObj->m_nColors == 3 );
        }

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnSavecolors()
    {
    g_pColors->CmdSaveColors();
    }

/***************************************************************************/

void CPBView::OnUpdateSavecolors(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( g_pColors != NULL );
    }

/***************************************************************************/
#endif
void CPBView::OnEditSelectAll()
    {
    if (m_pImgWnd)
        {
        if (!TextToolProcessed( ID_EDIT_SELECT_ALL ))
            {
            IMG *img = m_pImgWnd? m_pImgWnd->GetImg() : NULL;

            if (img)
                {
                CImgTool::Select(IDMB_PICKTOOL);
                m_pImgWnd->MakeBrush( img->hDC,
                    CRect( 0, 0, img->cxWidth, img->cyHeight ) );
                }
            }
        }
    }

/***************************************************************************/

void CPBView::OnEditPasteFrom()
    {
    CBitmapObj *pResObject = new CBitmapObj();

    ASSERT(pResObject != NULL);

    if (pResObject != NULL)
        {
        ASSERT( m_pImgWnd != NULL );

        pResObject->MakeEmpty();

        CString newName;
        int iColor = 0;

        if (theApp.DoPromptFileName( newName, IDS_EDIT_PASTE_FROM,
                                     OFN_PATHMUSTEXIST, TRUE, iColor, FALSE ))
            {
            if (pResObject->Import( newName ))
                {
                LPSTR lpDib = (LPSTR) GlobalLock(pResObject->m_hThing);
                m_pImgWnd->PasteImageFile( lpDib );
                GlobalUnlock(pResObject->m_hThing);
                }
            }

        pResObject->m_pImg = NULL;
        delete pResObject;
                pResObject = NULL;
        }
    }


/***************************************************************************/

BOOL FillBitmapObj(CImgWnd* pImgWnd, CBitmapObj* pResObject, IMG* pImgStruct,
        int iColor)
{
        ASSERT(pImgWnd != NULL);

        pResObject->MakeEmpty();

        if (pImgWnd->m_pImg                           == NULL
                ||  pImgWnd->m_pImg->m_pBitmapObj         == NULL
                ||  pImgWnd->m_pImg->m_pBitmapObj->m_pImg == NULL)
        {
                return(FALSE);
        }

        if (iColor < 0)
        {
                iColor = pImgWnd->m_pImg->m_pBitmapObj->m_nColors;
        }

        if (theImgBrush.m_bFirstDrag)
        {
                PickupSelection();
        }

        *pImgStruct = *theImgBrush.m_pImg;

        pImgStruct->hDC        = theImgBrush.m_dc.GetSafeHdc();
        pImgStruct->hBitmap    = (HBITMAP)theImgBrush.m_bitmap.GetSafeHandle();
        pImgStruct->hBitmapOld = theImgBrush.m_hbmOld;
        pImgStruct->bDirty     = TRUE;
        pImgStruct->m_pPalette = theApp.m_pPalette;
        pImgStruct->cxWidth    = theImgBrush.m_size.cx;
        pImgStruct->cyHeight   = theImgBrush.m_size.cy;

        if (iColor < 4 && iColor >= 0)
        {
                pResObject->m_nSaveColors = iColor;
        }

#ifdef PCX_SUPPORT
        pResObject->m_bPCX        = (iColor == 4);
#endif
#ifdef ICO_SUPPORT
        pResObject->m_bSaveIcon   = (iColor == 5);
#endif
        pResObject->m_nWidth      = pImgStruct->cxWidth;
        pResObject->m_nHeight     = pImgStruct->cyHeight;
        pResObject->m_nColors     = pImgWnd->m_pImg->m_pBitmapObj->m_nColors;
        pResObject->m_bCompressed = pImgWnd->m_pImg->m_pBitmapObj->m_bCompressed;

        pResObject->m_pImg = pImgStruct;

        return(TRUE);
}

void CPBView::OnEditCopyTo()
{
        CString newName;
        int iColor = m_pImgWnd->m_pImg->m_pBitmapObj->m_nColors;

        if (theApp.DoPromptFileName( newName, IDS_EDIT_COPY_TO,
                OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, iColor, TRUE ))
        {
                BeginWaitCursor();

                CBitmapObj cResObject;

                IMG imgStruct;

                if (!FillBitmapObj(m_pImgWnd, &cResObject, &imgStruct, iColor))
                {
                        // FEATURE: Need an error message
                        // Actually, can this ever happen?
                        return;
                }

                cResObject.SaveResource( FALSE );
                cResObject.Export( newName );

                EndWaitCursor();

                // Don't delete this on destructor
                cResObject.m_pImg = NULL;
        }
}

/***************************************************************************/

void CPBView::OnUpdateEditCopyTo(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (CImgTool::GetCurrentID() == IDMB_PICKTOOL
    ||  CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        ASSERT( m_pImgWnd != NULL );

        if (m_pImgWnd != NULL)
            {
            if (m_pImgWnd->m_pImg != NULL)
                {
                if (m_pImgWnd->m_pImg == theImgBrush.m_pImg)
                    {
                    bEnable = TRUE;
                    }
                }
            }
        }

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnImageStretchSkew()
    {
    CancelToolMode(TRUE);

    CStretchSkewDlg dlg;

    if (dlg.DoModal() != IDOK)
        return;

    int iStretchHorz = dlg.GetStretchHorz();
    int iStretchVert = dlg.GetStretchVert();

    if (iStretchVert
    ||  iStretchHorz)
        {
        CPBDoc* pDoc = GetDocument();

        ASSERT( pDoc );

        int iWidthImg    = pDoc->m_pBitmapObj->m_pImg->cxWidth;
        int iHeightImg   = pDoc->m_pBitmapObj->m_pImg->cyHeight;

        if (theImgBrush.m_pImg == NULL)
            {
            int lX = iWidthImg  + (iWidthImg  * iStretchHorz) / 100;
            int lY = iHeightImg + (iHeightImg * iStretchVert) / 100;

            CBitmap bmWork;
            CDC     dcWork;
            CDC*    pdcImg = CDC::FromHandle( pDoc->m_pBitmapObj->m_pImg->hDC );
            CSize   sizeBMP( (UINT)lX, (UINT)lY );
            CRect   rect( 0, 0, lX, lY );

            if (! dcWork.CreateCompatibleDC    ( pdcImg )
            ||  ! bmWork.CreateCompatibleBitmap( pdcImg, iWidthImg, iHeightImg ))
                {
                theApp.SetGdiEmergency( TRUE );
                return;
                }

            CBitmap*   pbmOld = dcWork.SelectObject( &bmWork );
            CPalette* ppalOld = m_pImgWnd->SetImgPalette( &dcWork, FALSE );

            BeginWaitCursor();

            dcWork.BitBlt( 0, 0, iWidthImg, iHeightImg, pdcImg, 0, 0, SRCCOPY );

            theUndo.BeginUndo( TEXT("Property Edit") );

            pDoc->m_pBitmapObj->SetSizeProp( P_Size, sizeBMP );

            StretchCopy( pdcImg->m_hDC, 0, 0, lX, lY,
                          dcWork.m_hDC, 0, 0, iWidthImg, iHeightImg );

            InvalImgRect ( m_pImgWnd->m_pImg, NULL );
            CommitImgRect( m_pImgWnd->m_pImg, NULL );
            theUndo.EndUndo();
            DirtyImg(m_pImgWnd->m_pImg);

            dcWork.SelectObject( pbmOld );
            bmWork.DeleteObject();

            if (ppalOld)
                dcWork.SelectPalette( ppalOld, FALSE );

            dcWork.DeleteDC();

            theApp.m_sizeBitmap = sizeBMP;

            EndWaitCursor();
            }
        else
            {
            CRect rect = theImgBrush.m_rcSelection;
            long  lX   = theImgBrush.m_size.cx;
            long  lY   = theImgBrush.m_size.cy;

            lX += (lX * iStretchHorz) / 100;
            lY += (lY * iStretchVert) / 100;

            rect.right  = rect.left + (UINT)lX;
            rect.bottom = rect.top  + (UINT)lY;

            // If the image is a bitmap and the bitmap in the clipboard is larger,
            // then give the suer the option2 of growing the image...
//          if (lX > iWidthImg || lY > iHeightImg)
//              {
//              switch (AfxMessageBox( IDS_ENLAGEBITMAPFORSTRETCH,
//                                     MB_YESNOCANCEL | MB_ICONQUESTION ))
//                  {
//                  default:
//                      return;
//                      break;

//                  case IDYES:
//                      {
//                      CSize size( max( lX, iWidthImg  ),
//                                  max( lY, iHeightImg ) );

//                      theUndo.BeginUndo( "Resize Bitmap" );
//                      VERIFY( pDoc->m_pBitmapObj->SetSizeProp( P_Size, size ) );

//                      theUndo.EndUndo();
//                      }
//                      break;

//                  case IDNO:
//                      break;
//                  }
//              }

            m_pImgWnd->PrepareForBrushChange();

            HideBrush();

            theImgBrush.SetSize( CSize( (UINT)lX, (UINT)lY ) );

            SetCombineMode( combineColor );

            InvalImgRect( theImgBrush.m_pImg, NULL ); // draw selection tracker
            m_pImgWnd->MoveBrush( rect );
            }
        }

    int wSkewHorz = (int)dlg.GetSkewHorz();
    int wSkewVert = (int)dlg.GetSkewVert();

    if (wSkewHorz)
        m_pImgWnd->CmdSkewBrush( wSkewHorz, TRUE );

    if (wSkewVert)
        m_pImgWnd->CmdSkewBrush( wSkewVert, FALSE );
    }

/***************************************************************************/

void CPBView::OnUpdateImageStretchSkew(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( m_pImgWnd != NULL );
    }

/***************************************************************************/

void CPBView::OnViewViewPicture()
    {
    CPBDoc *pDoc;
    CString strCaption;

    ASSERT(! theApp.m_bEmbedded);
    pDoc = GetDocument();

    CFullScreenThumbNailView *pcThumbNailView = new CFullScreenThumbNailView( m_pImgWnd );

    if (  pcThumbNailView == NULL
    ||  ! pcThumbNailView->Create((LPCTSTR)pDoc->GetPathName()))
        {
        theApp.SetMemoryEmergency();

        TRACE( TEXT("Create CThumbNailView faild\n") );
        }
    }

/***************************************************************************/

void CPBView::OnUpdateViewViewPicture(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( m_pImgWnd != NULL );
    }

/***************************************************************************/

void CPBView::OnViewTextToolbar()
    {
    ASSERT( CImgTool::GetCurrentID() == IDMX_TEXTTOOL );

    CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

    ASSERT( pTextTool->IsKindOf( RUNTIME_CLASS( CTextTool ) ) );

    pTextTool->ToggleFontPalette();
    }

/***************************************************************************/

void CPBView::OnUpdateViewTextToolbar(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

        ASSERT( pTextTool );
        ASSERT( pTextTool->IsKindOf( RUNTIME_CLASS( CTextTool ) ) );

        if (pTextTool
        &&  pTextTool->IsSlectionVisible())
            bEnable = TRUE;
        }

    pCmdUI->SetCheck( theApp.m_bShowTextToolbar );
    pCmdUI->Enable  ( bEnable );
    }

/***************************************************************************/

void CPBView::OnFileSetaswallpaperT()
    {
    SetTheWallpaper( TRUE );
    }

/***************************************************************************/

void CPBView::OnUpdateFileSetaswallpaperT( CCmdUI* pCmdUI )
    {
    pCmdUI->Enable( CanSetWallpaper() );
    }

/***************************************************************************/

void CPBView::OnFileSetaswallpaperC()
    {
    SetTheWallpaper( FALSE );
    }

/***************************************************************************/

void CPBView::OnUpdateFileSetaswallpaperC(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( CanSetWallpaper() );
    }

/***************************************************************************/

BOOL CPBView::CanSetWallpaper()
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL)
        {
        CPBDoc* pDoc = GetDocument();

        ASSERT( pDoc );

        bEnable = (! pDoc->GetPathName().IsEmpty() || pDoc->IsModified());

        // read the user policy key to see whether we should disable wallpaper setting

        if (bEnable)
            {
            HKEY hKey = 0;

            if (RegOpenKeyEx( HKEY_CURRENT_USER, REGSTR_PATH_POLICIES _T("\\ActiveDesktop"), 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
                {
                BOOL  bNoChangingWallpaper = FALSE;
                DWORD cbData = sizeof(bNoChangingWallpaper);

                if (RegQueryValueEx(hKey, _T("NoChangingWallpaper"), 0, 0, (PBYTE) &bNoChangingWallpaper, &cbData) == ERROR_SUCCESS)
                    {
                    bEnable = !bNoChangingWallpaper;
                    }

                RegCloseKey(hKey);
                }            
            }
        }
    return bEnable;
    }

/***************************************************************************/

void CPBView::SetTheWallpaper( BOOL bTiled /* = FALSE */ )
    {
    CPBDoc* pDoc = GetDocument();
    ASSERT( pDoc != NULL );

    CString cStrFileName = pDoc->GetPathName();

    BOOL bSetWallpaper = ! (cStrFileName.IsEmpty() || pDoc->IsModified() || pDoc->m_bNonBitmapFile);

    if (! bSetWallpaper)
        switch (AfxMessageBox( IDS_MUST_SAVE_WALLPAPER, MB_OKCANCEL | MB_ICONEXCLAMATION ))
            {
            case IDOK:
                // If so, either Save or Update, as appropriate
                bSetWallpaper = pDoc->SaveTheDocument();
                cStrFileName = pDoc->GetPathName();
                break;

            case IDCANCEL:
                break;

            default:
                theApp.SetMemoryEmergency();
                break;
            }

    if (bSetWallpaper)
        {
        DWORD dwDisp;
        HKEY  hKey = 0;

        if (RegCreateKeyEx( HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"),
                            REG_OPTION_RESERVED, TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, NULL, &hKey, &dwDisp ) == ERROR_SUCCESS)
            {
            RegSetValueEx( hKey, TEXT("TileWallpaper"), 0, REG_SZ,
                            (BYTE *)(bTiled? TEXT("1"): TEXT("0")), 2*sizeof(TCHAR) );
            RegCloseKey( hKey );
            }

        SystemParametersInfo( SPI_SETDESKWALLPAPER, bTiled? 1: 0,
                         (LPVOID)(cStrFileName.GetBuffer( cStrFileName.GetLength() )),
                         SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );

        cStrFileName.ReleaseBuffer();
        }
    }

/***************************************************************************/

void CPBView::OnPaletteChanged(CWnd* pFocusWnd)
    {
    // If this application did not change the palette, select
    // and realize this application's palette
    if ((pFocusWnd         != m_pImgWnd)
    &&  (m_pImgWnd         != NULL)
    &&  (m_pImgWnd->m_pImg != NULL))
        {
        if (theApp.m_pPalette)
            {
            // Redraw the entire client area
            m_pImgWnd->InvalidateRect(NULL);
            m_pImgWnd->UpdateWindow();

                if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd))
                {
                InvalColorWnd();
                // g_pImgColorsWnd->UpdateWindow();
                }
            }
        }
    }

/***************************************************************************/

BOOL CPBView::OnQueryNewPalette()
    {
    HPALETTE hOldPal = NULL;

    if (m_pImgWnd && ::IsWindow(m_pImgWnd->m_hWnd)
    &&  m_pImgWnd->m_pImg)
        {
        if (theApp.m_pPalette)
            {
            // Redraw the entire client area
            m_pImgWnd->InvalidateRect(NULL);
            m_pImgWnd->UpdateWindow();

                if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd))
                {
                InvalColorWnd();
                g_pImgColorsWnd->UpdateWindow();
                }
            }
        }
    return TRUE;
    }

/***************************************************************************/

void CPBView::OnUpdateImageAttributes( CCmdUI* pCmdUI )
    {
    BOOL bEnable = (m_pImgWnd != NULL);

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnEscape()
{
        if (m_pImgWnd != NULL)
        {
                m_pImgWnd->CmdCancel();
        }

        OnCancelMode();
}

/***************************************************************************/

void CPBView::OnEscapeServer()
{
        CImgTool* pImgTool = CImgTool::GetCurrent();

        if (pImgTool->IsToolModal())
        {
                OnEscape();
                return;
        }
        else
        {
                // Tell the OLE client (if there is one) we are all done
                GetDocument()->OnDeactivateUI(FALSE);
        }
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pbrusvw.h ===
// pbrusvw.h : interface of the CPBView class
//



class CPBDoc;
class CImgWnd;

class CThumbNailView;
class CFloatThumbNailView;


class CBitmapObj;
class C_PrintDialogEx;
/***************************************************************************/

class CPBView : public CView
    {
    protected: // create from serialization only

    DECLARE_DYNCREATE( CPBView )

    CPBView();

    public: /* Attributes ***********************************************/

    enum DOCKERS
        {
        unknown,
        toolbox,
        colorbox,

        };

    CImgWnd*             m_pImgWnd;
    CThumbNailView*      m_pwndThumbNailView;
    CFloatThumbNailView* m_pwndThumbNailFloat;


    public: /* Operations ***********************************************/

    CPBDoc* GetDocument();

   void   OnPaletteChanged(CWnd* pFocusWnd);
    BOOL   OnQueryNewPalette();

    BOOL   SetObject();

    int     SetTools();
    CPoint GetDockedPos     ( DOCKERS tool, CSize& sizeTool );

    void   GetFloatPos      ( DOCKERS tool, CRect& rectPos );
    void   SetFloatPos      ( DOCKERS tool, CRect& rectPos );

    void   ShowThumbNailView( void );
    void   HideThumbNailView( void );



    private: /***************************************************************/
    C_PrintDialogEx *m_pdexSub; // substitute in for CPrintDialog
    CPrintDialog    *m_pdRestore; // dialog pointer to restore after printing

    BOOL    SetView( CBitmapObj* pBitmapObj );

    void    ToggleThumbNailVisibility( void );
    BOOL    IsThumbNailVisible       ( void );
    BOOL    CreateThumbNailView();
    BOOL    DestroyThumbNailView();

    BOOL    InitPageStruct( LPPAGESETUPDLGA );
    static  UINT APIENTRY PaintHookProc( HWND, UINT, WPARAM, LPARAM );
    BOOL    GetPrintToInfo(CPrintInfo* pInfo);

    public:  /* Implementation **********************************************/

    virtual     ~CPBView();

    virtual BOOL PreCreateWindow( CREATESTRUCT& cs );
    virtual void OnInitialUpdate( void );
    virtual void OnActivateView ( BOOL bActivate, CView* pActivateView, CView* pDeactiveView );
    virtual void OnDraw         ( CDC* pDC ); // overridden to draw this view
    virtual BOOL OnCmdMsg       ( UINT, int, void*, AFX_CMDHANDLERINFO*);
    virtual void OnPrepareDC    ( CDC* pDC, CPrintInfo* pInfo = NULL );


    // Printing support
    virtual BOOL OnPreparePrinting(           CPrintInfo* pInfo );
    virtual void OnBeginPrinting  ( CDC* pDC, CPrintInfo* pInfo );
    virtual void OnPrint          ( CDC* pDC, CPrintInfo* pInfo );
    virtual void OnEndPrinting    ( CDC* pDC, CPrintInfo* pInfo );

    BOOL CanSetWallpaper();
    void SetTheWallpaper( BOOL bTiled = FALSE );

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    #endif

    // Generated message map functions
    protected: /************************************************************/

    //{{AFX_MSG(CPBView)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnFilePrint();
    afx_msg void OnFilePrintPreview();
    afx_msg void OnEditUndo();
    afx_msg void OnEditRedo();
    afx_msg void OnEditCut();
    afx_msg void OnEditClear();
    afx_msg void OnEditCopy();
    afx_msg void OnEditPaste();
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnViewGrid();
    afx_msg void OnViewZoom100();
    afx_msg void OnViewZoom400();
    afx_msg void OnUpdateViewZoom100(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewZoom400(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewGrid(CCmdUI* pCmdUI);
    afx_msg void OnImageInvertColors();
    afx_msg void OnUpdateImageInvertColors(CCmdUI* pCmdUI);
    afx_msg void OnTglopaque();
    afx_msg void OnUpdateTglopaque(CCmdUI* pCmdUI);
    afx_msg void OnImageAttributes();
    afx_msg void OnSel2bsh();
    afx_msg void OnLargerbrush();
    afx_msg void OnSmallerbrush();
    afx_msg void OnViewZoom();
    afx_msg void OnImageFlipRotate();
    afx_msg void OnUpdateImageFlipRotate(CCmdUI* pCmdUI);
    afx_msg void OnEditcolors();
    afx_msg void OnUpdateEditcolors(CCmdUI* pCmdUI);

    #if 0 // unused features

    afx_msg void OnLoadcolors();
    afx_msg void OnUpdateLoadcolors(CCmdUI* pCmdUI);
    afx_msg void OnSavecolors();
    afx_msg void OnUpdateSavecolors(CCmdUI* pCmdUI);
    #endif
    afx_msg void OnEditSelectAll();
    afx_msg void OnEditPasteFrom();
    afx_msg void OnEditCopyTo();
    afx_msg void OnUpdateEditCopyTo(CCmdUI* pCmdUI);
    afx_msg void OnImageStretchSkew();
    afx_msg void OnUpdateImageStretchSkew(CCmdUI* pCmdUI);
    afx_msg void OnViewViewPicture();
    afx_msg void OnUpdateViewViewPicture(CCmdUI* pCmdUI);
    afx_msg void OnViewTextToolbar();
    afx_msg void OnUpdateViewTextToolbar(CCmdUI* pCmdUI);
    afx_msg void OnFileSetaswallpaperT();
    afx_msg void OnUpdateFileSetaswallpaperT(CCmdUI* pCmdUI);
    afx_msg void OnFileSetaswallpaperC();
    afx_msg void OnUpdateFileSetaswallpaperC(CCmdUI* pCmdUI);
    afx_msg void OnViewThumbnail();
    afx_msg void OnUpdateViewThumbnail(CCmdUI* pCmdUI);
   afx_msg void OnUpdateImageAttributes(CCmdUI* pCmdUI);
    afx_msg void OnEscape();
    afx_msg void OnEscapeServer();
   afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
   afx_msg void OnUpdateEditSelection(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditClearSel(CCmdUI* pCmdUI);
   afx_msg void OnFilePageSetup();
   afx_msg void OnImageClearImage();
   afx_msg void OnUpdateImageClearImage(CCmdUI* pCmdUI);
   //}}AFX_MSG
   afx_msg void OnDestroy();
   afx_msg BOOL PreTranslateMessage(MSG *pMsg);

#ifdef CUSTOMFLOAT
    afx_msg void OnUpdateViewColorBox(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewToolBox(CCmdUI* pCmdUI);
#endif



    DECLARE_MESSAGE_MAP()

    friend class CPrintResObj;
    };

#ifndef _DEBUG  // debug version in pbrusvw.cpp
inline CPBDoc* CPBView::GetDocument() { return (CPBDoc*)m_pDocument; }
#endif

#ifndef PD_NOCURRENTPAGE
#define PD_NOCURRENTPAGE               0x00800000
#endif //PD_NOCURRENTPAGE

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pcximage.cpp ===
//---------------------------------------------------------------
//  File: pcximage.cpp
//
//  Image manipulation functions for PCX format images.
//---------------------------------------------------------------
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "toolbox.h"
#include "imgfile.h"
#include "imgcolor.h"
#include "undo.h"
#include "props.h"
#include "ferr.h"
#include "ctype.h"
#include "cmpmsg.h"

#define COLORMAPLENGTH 48
#define FILLERLENGTH 58

#ifdef PCX_SUPPORT

struct PCXHeader
    {
    unsigned char   manufacturer;
    unsigned char   version;
    unsigned char   encoding;
    unsigned char   bits_per_pixel_per_plane;
    short           xmin;
    short           ymin;
    short           xmax;
    short           ymax;
    unsigned short  hresolution;
    unsigned short  vresolution;
    unsigned char   colormap[COLORMAPLENGTH];
    unsigned char   reserved;
    unsigned char   nplanes;
    unsigned short  bytes_per_line;
    short           palette_info;
    unsigned char   filler[FILLERLENGTH];   // Header is 128 bytes
    };

#endif

class CFileBuffer : public CObject
    {
    DECLARE_DYNCREATE( CFileBuffer )

    public:

    enum Type
        {
        READ,
        WRITE
        };


    CFileBuffer();
   ~CFileBuffer();

    BOOL  Create( CFile* pfile, Type IO );
    short Get   ( void );
    BOOL  Put   ( BYTE cByte );
    long  Seek  ( long lOff, UINT nFrom );
    BOOL  Flush ( void );

    private:

    void  Fill  ( void );

    enum { MAX_BUFFER = 2048 };

    CFile*      m_pFile;
    int         m_iBuffPos;
    int         m_iBuffSize;
    BYTE*       m_pBuffer;
    };

IMPLEMENT_DYNCREATE( CFileBuffer, CObject )

#include "memtrace.h"

/****************************************************************************/

CFileBuffer::CFileBuffer() : CObject()
    {
    m_pFile     = 0;
    m_iBuffPos  = 0;
    m_iBuffSize = 0;
    m_pBuffer   = 0;
    }

/****************************************************************************/

CFileBuffer::~CFileBuffer()
    {
    if (m_pBuffer)
        delete [] m_pBuffer;
    }

/****************************************************************************/

BOOL CFileBuffer::Create( CFile* pfile, Type IO )
    {
    ASSERT( pfile != NULL );

    if (pfile == NULL)
        return FALSE;

    m_pFile   = pfile;
    m_pBuffer = new BYTE[MAX_BUFFER];

    if (! m_pBuffer)
        {
        theApp.SetMemoryEmergency();
        return FALSE;
        }

    if (IO == READ)
        {
        Fill();

        if (! m_iBuffSize)
            {
            theApp.SetFileError( IDS_ERROR_READLOAD, ferrIllformedFile );
            return FALSE;
            }
        }
    return TRUE;
    }

/****************************************************************************/

short CFileBuffer::Get( void )
    {
    if (! m_iBuffSize)
        return EOF;

    short sByte = (short)(unsigned short)m_pBuffer[m_iBuffPos++];

    if (m_iBuffPos == m_iBuffSize)
        Fill();

    return sByte;
    }

/****************************************************************************/

BOOL CFileBuffer::Put( BYTE cByte )
    {
    m_pBuffer[m_iBuffSize++] = cByte;

    if (m_iBuffSize == MAX_BUFFER)
        return Flush();

    return TRUE;
    }

/****************************************************************************/

long CFileBuffer::Seek( long lOff, UINT nFrom )
    {
    long lPos = m_pFile->Seek( lOff, nFrom );

    Fill();

    return lPos;
    }

/****************************************************************************/

void CFileBuffer::Fill()
    {
    m_iBuffSize = m_pFile->Read( m_pBuffer, MAX_BUFFER );
    m_iBuffPos  = 0;
    }

/****************************************************************************/

BOOL CFileBuffer::Flush( void )
    {
    TRY {
        m_pFile->Write( m_pBuffer, m_iBuffSize );
        }
    CATCH( CFileException, ex )
        {
        m_pFile->Abort();
        theApp.SetFileError( IDS_ERROR_SAVE, ex->m_cause );

        return FALSE;
        }
    END_CATCH

    m_iBuffSize = 0;

    return TRUE;
    }

/****************************************************************************/
/****************************************************************************/
#ifdef PCX_SUPPORT

BOOL CBitmapObj::ReadPCX( CFile* pfile )
    {
    if (! pfile->GetLength())
        {
        if (m_hThing)
            Free();

        m_bDirty = TRUE;

        return TRUE;
        }

    // if  a PCX extension try to load this as a PCX image.
    PCXHeader hdr;
    PBITMAP   p_dib;   // Device independent bitmap

    short bytes_per_line;

    pfile->Read( (unsigned char*)&hdr, sizeof( PCXHeader ) );

    // Check if image file format is acceptable

    if (hdr.manufacturer != 0x0a)
        {
        theApp.SetFileError( IDS_ERROR_READLOAD, ferrCantDetermineType );
        return FALSE;
        }

    // We only handle 1, 4, 8, or 24-bit images

    short bits_per_pixel = hdr.nplanes * hdr.bits_per_pixel_per_plane;

    if (bits_per_pixel != 1
    &&  bits_per_pixel != 4
    &&  bits_per_pixel != 8
    &&  bits_per_pixel != 24)
        {
        theApp.SetFileError( IDS_ERROR_READLOAD, ferrCantDetermineType );
        return FALSE;
        }

    short image_width  = hdr.xmax - hdr.xmin + 1;
    short image_height = hdr.ymax - hdr.ymin + 1;

    // Allocate space where the PCX image will be unpacked.

    long pcx_image_size = (long) hdr.nplanes *
                          (long) image_height *
                          (long) hdr.bytes_per_line;

    BYTE* image = (BYTE*) new BYTE[pcx_image_size];

    if (image == NULL)
        {
        theApp.SetMemoryEmergency();
        return FALSE;
        }

    // Read in PCX image into this area.
    CFileBuffer FileBuffer;

    if (! FileBuffer.Create( pfile, CFileBuffer::READ ))
        {
        delete [] image;

        return FALSE;
        }

    // Decode run-length encoded image data
    short i;
    short byte;
    short count;
    long  pos = 0L;

    while ((byte = FileBuffer.Get()) != EOF)
        {
        if ((byte & 0xc0) == 0xc0)
            {
            count = byte & 0x3f;

            if ((byte = FileBuffer.Get()) != EOF)
                {
                for (i = 0; i < count; i++)
                    {
                    if (pos >= pcx_image_size)
                        break;

                    image[pos] = (CHAR)byte;
                    pos++;
                    }
                }
            }
        else
            {
            if (pos >= pcx_image_size)
                break;

            image[pos] = (CHAR)byte;
            pos++;
            }
        }

    // Allocate memory for the device independent bitmap (DIB)
    // Note that the number of bytes in each line of a DIB image
    // must be a multiple of 4.

    short bytes_per_line_per_plane = (image_width *
                       hdr.bits_per_pixel_per_plane + 7) / 8;

    short actual_bytes_per_line = (image_width *
                                   hdr.nplanes *
                       hdr.bits_per_pixel_per_plane + 7) / 8;
    bytes_per_line = actual_bytes_per_line;

    if ( bytes_per_line % 4)
         bytes_per_line = 4 * ( bytes_per_line / 4 + 1);

    // Make room for a palette

    short palettesize = 16;

    if (bits_per_pixel == 1)
        palettesize = 2;

    if (hdr.version >= 5
    && bits_per_pixel > 4)
        {
        // Go back 769 bytes from the end of the file

        FileBuffer.Seek( -769, CFile::end );

        if (FileBuffer.Get() == 12)
            {
            // There is a 256-color palette following this byte
            palettesize = 256;
            }
        }
    // If image has more than 256 colors then there is no palette

    if (bits_per_pixel > 8)
        palettesize = 0;

    // Allocate space for the bitmap
    if (m_hThing)
        Free();

    m_lMemSize = sizeof( BITMAPINFOHEADER ) + palettesize * sizeof( RGBQUAD )
                                   + (long)bytes_per_line * (long)image_height;
    if (! Alloc())
        return FALSE;

    p_dib = (PBITMAP) GlobalLock(m_hThing);

    // Set up bitmap info header

    LPBITMAPINFOHEADER p_bminfo = (LPBITMAPINFOHEADER)p_dib;

    p_bminfo->biSize          = sizeof(BITMAPINFOHEADER);
    p_bminfo->biWidth         = image_width;
    p_bminfo->biHeight        = image_height;
    p_bminfo->biPlanes        = 1;
    p_bminfo->biBitCount      = hdr.bits_per_pixel_per_plane * hdr.nplanes;
    p_bminfo->biCompression   = BI_RGB;
    p_bminfo->biSizeImage     = (long)image_height * (long) bytes_per_line;
    p_bminfo->biXPelsPerMeter = (long)hdr.hresolution;
    p_bminfo->biYPelsPerMeter = (long)hdr.vresolution;
    p_bminfo->biClrUsed       = 0;
    p_bminfo->biClrImportant  = 0;

    // Set up the color palette

    if (palettesize > 0)
        {
        //***** RGBQUAD *palette = (RGBQUAD*) ((LPSTR)imdata->p_dib

        LPRGBQUAD palette = LPRGBQUAD((LPSTR)p_dib + sizeof(BITMAPINFOHEADER));

        short palindex;

        for (palindex = 0; palindex < palettesize; palindex++)
            {
            if (palettesize == 256)
                {
                // Read palette from file

                palette[palindex].rgbRed       = (BYTE)FileBuffer.Get();
                palette[palindex].rgbGreen     = (BYTE)FileBuffer.Get();
                palette[palindex].rgbBlue      = (BYTE)FileBuffer.Get();
                palette[palindex].rgbReserved  = 0;
                }
            if (palettesize == 16)
                {
                // 16-color palette from PCX header

                palette[palindex].rgbRed      = (BYTE)hdr.colormap[3*palindex];
                palette[palindex].rgbGreen    = (BYTE)hdr.colormap[3*palindex+1];
                palette[palindex].rgbBlue     = (BYTE)hdr.colormap[3*palindex+2];
                palette[palindex].rgbReserved = 0;
                }
            if (palettesize == 2)
                {
                // Set up palette for black and white images

                palette[palindex].rgbRed      = palindex * 255;
                palette[palindex].rgbGreen    = palindex * 255;
                palette[palindex].rgbBlue     = palindex * 255;
                palette[palindex].rgbReserved = 0;
                }
            }
        }

    // Load image data into the DIB. Note the DIB image must be
    // stored "bottom to top" line order. That's why we position
    // data at the end of the array so that the image can be
    // stored backwards--from the last line to the first.

    BYTE* data = (BYTE*)p_dib + ((long)sizeof( BITMAPINFOHEADER )
                              + palettesize * sizeof( RGBQUAD )
                              + (image_height - 1) * bytes_per_line);

    // Define a macro to access bytes in the PCX image according
    // to specified line and plane index.

    short lineindex, byteindex, planeindex;

    #define bytepos(lineindex, planeindex, byteindex)  \
            ((long)(lineindex)*(long)hdr.bytes_per_line* \
             (long)hdr.nplanes + \
             (long)(planeindex)*(long)hdr.bytes_per_line + \
             (long)(byteindex))

    // Construct packed pixels out of decoded PCX image.

    short loc;
    unsigned short onebyte;
    unsigned short bits_copied;
    unsigned short few_bits;
    unsigned short k;
    unsigned short bbpb = 8/hdr.bits_per_pixel_per_plane;

    // Build a mask to pick out bits from each byte of the PCX image

    unsigned short himask = 0x80, mask;

    if (hdr.bits_per_pixel_per_plane > 1)
        for (i = 0; i < hdr.bits_per_pixel_per_plane - 1;
            i++) himask = 0x80 | (himask >> 1);

    for (lineindex = 0; lineindex < image_height;
         lineindex++, data -= bytes_per_line)
        {
        if (actual_bytes_per_line < bytes_per_line)
            for (loc = actual_bytes_per_line; loc < bytes_per_line; loc++)
                data[loc] = 0;

        loc         = 0;
        onebyte     = 0;
        bits_copied = 0;

        for (byteindex = 0; byteindex < bytes_per_line_per_plane; byteindex++)
            {
            for (k = 0, mask = himask; k < bbpb; k++,
                                        mask >>= hdr.bits_per_pixel_per_plane)
                {
                // Go through all scan line for all planes and copy bits into
                // the data array

                for (planeindex = 0; planeindex < hdr.nplanes; planeindex++)
                    {
                    few_bits = image[bytepos(lineindex,
                                            planeindex, byteindex)] & mask;

                    // Shift the selected bits to the most significant position

                    if (k > 0)
                        few_bits <<= (k*hdr.bits_per_pixel_per_plane);

                    // OR the bits with current pixel after shifting them right

                    if (bits_copied > 0)
                        few_bits >>= bits_copied;

                    onebyte |= few_bits;
                    bits_copied += hdr.bits_per_pixel_per_plane;

                    if (bits_copied >= 8)
                        {
                        data[loc] = (UCHAR)onebyte;
                        loc++;
                        bits_copied = 0;
                        onebyte = 0;
                        }
                    }
                }
            }
        }

    // Success!
    delete [] (BYTE*)image;

    GlobalUnlock(m_hThing);

    return TRUE;
    }

/****************************************************************************/
#define WIDTHBYTES(bits) ((((bits) + 31) / 32) * 4)

BOOL CBitmapObj::WritePCX( CFile* pfile )
    {
    if (m_pImg == NULL)
        {
        // The image has not been loaded, so we'll just copy the
        // original out to the file...
        ASSERT( m_hThing );

        if (! m_hThing)
            return FALSE;
        }
    else
        {
        // The image has been loaded and may have been edited, so
        // we'll convert it back to a dib to save...
        if (! m_hThing)
            SaveResource( FALSE );

        if (! m_hThing)
            return FALSE;
        }

    // build pcx file from the DIB
    PBITMAP   p_dib = (PBITMAP)GlobalLock(m_hThing);         // Device independent bitmap
    PCXHeader hdr;                                           // PCX bitmap header
    LPBITMAPINFOHEADER p_bminfo = (LPBITMAPINFOHEADER)p_dib; // Set up bitmap info header

    short palettesize = DIBNumColors( (LPSTR)p_dib);         // Get palette size

    hdr.manufacturer = 10;
//  hdr.version      = (char)((hPalette || (GetDeviceCaps(fileDC, RASTERCAPS) & RC_PALETTE)) ? 5 : 3);
    hdr.version      = (CHAR)( palettesize ? 5 : 3);
    hdr.encoding     = 1;
    hdr.xmin         = hdr.ymin = 0;
    hdr.xmax         = p_bminfo->biWidth - 1;
    hdr.ymax         = p_bminfo->biHeight- 1;
//  hdr.hresolution  = theApp.ScreenDeviceInfo.iWidthinPels;
//  hdr.vresolution  = theApp.ScreenDeviceInfo.iHeightinPels;
    hdr.hresolution  = (WORD)p_bminfo->biXPelsPerMeter;
    hdr.vresolution  = (WORD)p_bminfo->biYPelsPerMeter;
    hdr.reserved     = 0;
    hdr.nplanes      = (BYTE)p_bminfo->biPlanes; //biPlanes should always be 1
    hdr.palette_info = (BYTE)p_dib->bmWidthBytes;
    hdr.bits_per_pixel_per_plane = (CHAR) p_bminfo->biBitCount;

    hdr.bytes_per_line = WIDTHBYTES( (LONG) (p_bminfo->biBitCount * p_bminfo->biWidth) );

    // Clean up filler
    for (int index = FILLERLENGTH; index--; )
        hdr.filler[index] ='\0';

    //  If there are at most 16 colors place them in header
    LPRGBQUAD palette = LPRGBQUAD((LPSTR)p_dib + sizeof(BITMAPINFOHEADER));
    LPSTR       lpDst = (LPSTR)hdr.colormap;

    // Clean up colormap
    for (index = COLORMAPLENGTH; index--; )
        lpDst[index] ='\0';

    if (palettesize <= 16)
        for (index = palettesize; index--; )
            {
            *lpDst++ = palette->rgbRed;  /* swap RED and BLUE components */
            *lpDst++ = palette->rgbGreen;
            *lpDst++ = palette->rgbBlue;
            palette++;
            }

    pfile->Write( (unsigned char*)&hdr, sizeof( PCXHeader ) );

    // Now pack the image

    // Load image data from the DIB. Note the DIB image is
    // stored "bottom to top" line order. That's why we position
    // data at the end of the array so that the image can be
    // stored backwards--from the last line to the first.

    CFileBuffer FileBuffer;

    if (! FileBuffer.Create( pfile, CFileBuffer::WRITE ))
        {
        GlobalUnlock(m_hThing);
        return FALSE;
        }

    // find the start of the bitmap data then go to the end of the data
    // the PCX is stored in reverse order of the DIB
    int TopofData = sizeof( BITMAPINFOHEADER ) + palettesize * sizeof( RGBQUAD );
    BYTE* data = (BYTE*)p_dib + TopofData + hdr.bytes_per_line * (p_bminfo->biHeight );

    for (index = p_bminfo->biHeight; index--; )
        {
        data -= hdr.bytes_per_line;

        if (! PackBuff( &FileBuffer, data, hdr.bytes_per_line )) //convert to run length encoding.
            {
            GlobalUnlock(m_hThing);
            return FALSE;
            }
        }

    if (palettesize == 256) // Write palette to file
        {
        if (! FileBuffer.Put( 12 ))  // Tag number for palette information
            {
            GlobalUnlock(m_hThing);
            return FALSE;
            }

        for (index = 0; index < palettesize; index++)
            {
            if (! FileBuffer.Put( palette[index].rgbRed   )
            ||  ! FileBuffer.Put( palette[index].rgbGreen )
            ||  ! FileBuffer.Put( palette[index].rgbBlue  ))
                {
                GlobalUnlock(m_hThing);
                return FALSE;
                }
            }
        }

    GlobalUnlock(m_hThing);
    return FileBuffer.Flush();
    }

#endif //PCX_SUPPORT

/****************************************************************************/

/* run length encoding equates */
#define MINcount 2
#define MAXcount 63
#define ESCbits  0xC0
#define BUFFER_SIZE 1024

/* bitmaps are ordered <b, g, r, i> but PCX is ordered <r, g, b, i> ... */

BOOL CBitmapObj::PackBuff(CFileBuffer *FileBuffer, BYTE *PtrDib, int byteWidth )
    {
    BYTE  runChar;
    BYTE  runCount;
    BYTE* endPtr = PtrDib + byteWidth;

    for (runCount = 1, runChar = *PtrDib++; PtrDib <= endPtr; ++PtrDib)
        {
        if (PtrDib != endPtr && *PtrDib == runChar && runCount < MAXcount)
            ++runCount;
        else
            if (*PtrDib != runChar
            &&  runCount < MINcount
            && (runChar & ESCbits) != ESCbits)
                {
                while (runCount--)
                    if (! FileBuffer->Put( runChar ))
                        return FALSE;

                runCount = 1;
                runChar = *PtrDib;
                }
            else
                {
                runCount |= ESCbits;

                if (! FileBuffer->Put( runCount )
                ||  ! FileBuffer->Put( runChar  ))
                    return FALSE;

                runCount = 1;
                runChar  = *PtrDib;
                }
        }

    return TRUE;
    }

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pgsetup.cpp ===
//
// pgsetup.cpp
//
// implementation of the CPageSetupData class
//

#include "stdafx.h"
#include "resource.h"
#include "dlgs.h"
#include "pgsetup.h"

/***************************************************************************/

#define FIXED_FLOATPT_MULTDIV 100000

/***************************************************************************/

VOID CPageSetupData::UpdateControls(HWND hDlg)
{
    CheckDlgButton(hDlg, IDC_HORIZONTALLY, bCenterHorizontally);
    CheckDlgButton(hDlg, IDC_VERTICALLY, bCenterVertically);

    CheckDlgButton(hDlg, IDC_ADJUST_TO, !bScaleFitTo);
    SetDlgItemInt(hDlg, IDC_PERCENT_NORMAL_SIZE, nAdjustToPercent, FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PERCENT_NORMAL_SIZE), !bScaleFitTo);
    EnableWindow(GetDlgItem(hDlg, IDC_STR_PERCENT_NORMAL_SIZE), !bScaleFitTo);
    
    CheckDlgButton(hDlg, IDC_FIT_TO, bScaleFitTo);
    SetDlgItemInt(hDlg, IDC_PAGES_WIDE, nFitToPagesWide, FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PAGES_WIDE), bScaleFitTo);
    EnableWindow(GetDlgItem(hDlg, IDC_STR_PAGES_WIDE), bScaleFitTo);
    SetDlgItemInt(hDlg, IDC_PAGES_TALL, nFitToPagesTall, FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PAGES_TALL), bScaleFitTo);
    EnableWindow(GetDlgItem(hDlg, IDC_STR_PAGES_TALL), bScaleFitTo);

    InvalidateRect(GetDlgItem(hDlg, rct1), 0, TRUE);
}

/***************************************************************************/

VOID CPageSetupData::UpdateValue(HWND hDlg, int nIDDlgItem, UINT *pnResult)
{
    BOOL bTranslated;

    UINT nResult = GetDlgItemInt(hDlg, nIDDlgItem, &bTranslated, FALSE);

    if (bTranslated && nResult != 0)
    {
        *pnResult = nResult;

        InvalidateRect(GetDlgItem(hDlg, rct1), 0, TRUE);
    }
}

/***************************************************************************/

UINT_PTR APIENTRY CPageSetupData::PageSetupHook(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            LPPAGESETUPDLG ppsd = (LPPAGESETUPDLG) lParam;

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) lParam);

            CPageSetupData *that = (CPageSetupData *) ppsd->lCustData;

            SendDlgItemMessage(hDlg, IDC_PERCENT_NORMAL_SIZE, EM_LIMITTEXT, 4, 0);

            SendDlgItemMessage(hDlg, IDC_PAGES_WIDE, EM_LIMITTEXT, 2, 0);
            SendDlgItemMessage(hDlg, IDC_PAGES_TALL, EM_LIMITTEXT, 2, 0);
            
            that->UpdateControls(hDlg);
            
            break;
        }

        case WM_COMMAND:
        {
            LPPAGESETUPDLG ppsd = (LPPAGESETUPDLG) GetWindowLongPtr(hDlg, GWLP_USERDATA);

            CPageSetupData *that = ppsd ? (CPageSetupData *) ppsd->lCustData : 0;

            switch (LOWORD(wParam))
            {
                case IDC_HORIZONTALLY:
                {
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        that->bCenterHorizontally = !that->bCenterHorizontally;
                        that->UpdateControls(hDlg);
                    }

                    return TRUE;
                }

                case IDC_VERTICALLY:
                {
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        that->bCenterVertically = !that->bCenterVertically;
                        that->UpdateControls(hDlg);
                    }

                    return TRUE;
                }

                case IDC_ADJUST_TO:
                {
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        that->bScaleFitTo = FALSE;
                        that->UpdateControls(hDlg);
                    }

                    return TRUE;
                }

                case IDC_FIT_TO:
                {
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        that->bScaleFitTo = TRUE;
                        that->UpdateControls(hDlg);
                    }

                    return TRUE;
                }

                case IDC_PERCENT_NORMAL_SIZE:
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        UpdateValue(hDlg, IDC_PERCENT_NORMAL_SIZE, &that->nAdjustToPercent);
                    }
                    else if (HIWORD(wParam) == EN_KILLFOCUS)
                    {
                        SetDlgItemInt(hDlg, IDC_PERCENT_NORMAL_SIZE, that->nAdjustToPercent, FALSE);
                    }

                    return TRUE;
                }

                case IDC_PAGES_WIDE:
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        UpdateValue(hDlg, IDC_PAGES_WIDE, &that->nFitToPagesWide);
                    }
                    else if (HIWORD(wParam) == EN_KILLFOCUS)
                    {
                        SetDlgItemInt(hDlg, IDC_PAGES_WIDE, that->nFitToPagesWide, FALSE);
                    }

                    return TRUE;
                }

                case IDC_PAGES_TALL:
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        UpdateValue(hDlg, IDC_PAGES_TALL, &that->nFitToPagesTall);
                    }
                    else if (HIWORD(wParam) == EN_KILLFOCUS)
                    {
                        SetDlgItemInt(hDlg, IDC_PAGES_TALL, that->nFitToPagesTall, FALSE);
                    }

                    return TRUE;
                }
            }

            break;
        }
    }

    return FALSE;
}

/***************************************************************************/

VOID 
CPageSetupData::CalculateImageRect(
    const CSize &PhysicalPageSize, 
    CPoint      &PhysicalOrigin, 
    CSize       &PhysicalScaledImageSize
)
{
    // Find the scaled image size and the total page size required to print that image

    LONG nPhysicalTotalPageWidth;
    LONG nPhysicalTotalPageHeight;

    if (bScaleFitTo)
    {
        nPhysicalTotalPageWidth = PhysicalPageSize.cx * nFitToPagesWide;
        nPhysicalTotalPageHeight = PhysicalPageSize.cy * nFitToPagesTall;

        // Keep the aspect ratio; try the match the width first and if it fails, match the height

        PhysicalScaledImageSize.cx = nPhysicalTotalPageWidth;
        PhysicalScaledImageSize.cy = (LONG) (fPhysicalImageHeight * nPhysicalTotalPageWidth / fPhysicalImageWidth);

		if (PhysicalScaledImageSize.cy > nPhysicalTotalPageHeight)
        {
			PhysicalScaledImageSize.cx = (LONG) (fPhysicalImageWidth * nPhysicalTotalPageHeight / fPhysicalImageHeight);
			PhysicalScaledImageSize.cy = nPhysicalTotalPageHeight;
		}
    }
    else
    {
        PhysicalScaledImageSize.cx = (LONG) (fPhysicalImageWidth * nAdjustToPercent / 100);
        PhysicalScaledImageSize.cy = (LONG) (fPhysicalImageHeight * nAdjustToPercent / 100);

        nFitToPagesWide = (PhysicalScaledImageSize.cx + PhysicalPageSize.cx - 1) / PhysicalPageSize.cx;
        nFitToPagesTall = (PhysicalScaledImageSize.cy + PhysicalPageSize.cy - 1) / PhysicalPageSize.cy;

        nPhysicalTotalPageWidth = PhysicalPageSize.cx * nFitToPagesWide;
        nPhysicalTotalPageHeight = PhysicalPageSize.cy * nFitToPagesTall;
    }

    PhysicalOrigin.x = bCenterHorizontally ? (nPhysicalTotalPageWidth - PhysicalScaledImageSize.cx) / 2 : 0;

    PhysicalOrigin.y = bCenterVertically ? (nPhysicalTotalPageHeight - PhysicalScaledImageSize.cy) / 2 : 0;
}

/***************************************************************************/

UINT_PTR APIENTRY CPageSetupData::PagePaintHook(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_PSD_PAGESETUPDLG:
        {
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) lParam);
            break;
        }

        case WM_PSD_GREEKTEXTRECT:
        {
            LPPAGESETUPDLG ppsd = (LPPAGESETUPDLG) GetWindowLongPtr(hDlg, GWLP_USERDATA);
            
            CPageSetupData *that = (CPageSetupData *) ppsd->lCustData;

            CRect *pOutputWindowRect = (CRect *) lParam;

            // Find the physical size of the page

            CSize PhysicalPageSize;

            PhysicalPageSize.cx = ppsd->ptPaperSize.x - ppsd->rtMargin.left - ppsd->rtMargin.right;
            PhysicalPageSize.cy = ppsd->ptPaperSize.y - ppsd->rtMargin.top - ppsd->rtMargin.bottom;

            CPoint PhysicalOrigin;
            CSize  PhysicalScaledImageSize;

            that->CalculateImageRect(PhysicalPageSize, PhysicalOrigin, PhysicalScaledImageSize);

            // Find the scaling ratios for the preview window

            double fWidthRatio = (double) pOutputWindowRect->Width() / PhysicalPageSize.cx;
            double fHeightRatio = (double) pOutputWindowRect->Height() / PhysicalPageSize.cy;

            // Find the size of the image rectangle on the preview window

            CRect OutputImageRect;

            OutputImageRect.left   = pOutputWindowRect->left + (int) (fWidthRatio  * PhysicalOrigin.x);
            OutputImageRect.top    = pOutputWindowRect->top  + (int) (fHeightRatio * PhysicalOrigin.y);
            OutputImageRect.right  = OutputImageRect.left    + (int) (fWidthRatio  * PhysicalScaledImageSize.cx);
            OutputImageRect.bottom = OutputImageRect.top     + (int) (fHeightRatio * PhysicalScaledImageSize.cy);

            // Draw a rectangle with crossing lines

            CDC *pDC = CDC::FromHandle((HDC) wParam);

            CGdiObject *pOldPen = pDC->SelectStockObject(BLACK_PEN);

            CGdiObject *pOldBrush = pDC->SelectStockObject(LTGRAY_BRUSH);

            pDC->Rectangle(OutputImageRect);

            pDC->MoveTo(OutputImageRect.left, OutputImageRect.top);
            pDC->LineTo(OutputImageRect.right - 1, OutputImageRect.bottom - 1);

            pDC->MoveTo(OutputImageRect.left, OutputImageRect.bottom - 1);
            pDC->LineTo(OutputImageRect.right - 1, OutputImageRect.top);

            pDC->SelectObject(pOldPen);

            pDC->SelectObject(pOldBrush);

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pbrush.h ===
// pbrush.h : main header file for the PBRUSH application
//

#ifndef __AFXWIN_H__
#error include TEXT('stdafx.h') before including this file for PCH
#endif

#include "resource.h"       // main symbols

#include "loadimag.h"

#ifdef PNG_SUPPORT
#undef PNG_SUPPORT
#endif
// Bits for CTheApp::m_wEmergencyFlags
//
#define memoryEmergency 0x0001 // in a low free memory state
#define gdiEmergency    0x0002 // some GDI create failed
#define userEmergency   0x0004 // a CreateWindow failed
#define warnEmergency   0x0008 // still need to warn the user
#define failedEmergency 0x0010 // last operation actually failed

// This is the minimum delay between warning messages so the user doesn't
// get bombed by repetitious message boxes.  The value is in milli-seconds.

#define ticksBetweenWarnings (1000L * 60)

#define nSysBrushes 25
#define nOurBrushes 4

#if 0
// Pulling self-registration out. This is to be done once during setup only

class CPBTemplateServer : public COleTemplateServer
{
        public:

        void UpdateRegistry(OLE_APPTYPE nAppType,
                LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL);
} ;

#endif

/***************************************************************************/
// CPBApp:
// See pbrush.cpp for the implementation of this class
//

class CPBApp : public CWinApp
    {
    public:


    CPBApp();
    ~CPBApp();
    //
    // OnFileNew made public for scanning support
    //
    afx_msg void OnFileNew();
    // Overrides
    virtual BOOL InitInstance();
    virtual int  ExitInstance();

    virtual void WinHelp( DWORD dwData, UINT nCmd = HELP_CONTEXT ); // general
    virtual BOOL OnIdle(LONG);

    // error handling routines
    inline  BOOL InEmergencyState() const { return m_wEmergencyFlags != 0; }

    void    SetMemoryEmergency(BOOL bFailed = TRUE);
    void    SetGdiEmergency   (BOOL bFailed = TRUE);
    void    SetUserEmergency  (BOOL bFailed = TRUE);

    BOOL    CheckForEmergency() { return (m_wEmergencyFlags? TRUE: FALSE); }
    void    WarnUserOfEmergency();

    void    SetFileError( UINT uOperationint, int nCause, LPCTSTR lpszFile = NULL );
    void    FileErrorMessageBox( void );

    CString GetLastFile() {return m_sLastFile;}

    void    TryToFreeMemory();

    void    ParseCommandLine();

    // Patch to set the devmode and devname after pagesetup
    void    SetDeviceHandles(HANDLE hDevNames, HANDLE hDevMode);

    // setup routines
    void    LoadProfileSettings();
    void    SaveProfileSettings();
    void    GetSystemSettings( CDC* pdc );

    // Methods
    CPoint  CheckWindowPosition( CPoint ptPosition, CSize& sizeWindow );

    CDocument* OpenDocumentFile( LPCTSTR lpszFileName );

    BOOL    DoPromptFileName( CString& fileName, UINT nIDSTitle, DWORD lFlags,
                              BOOL bOpenFileDialog, int& iColors, BOOL bOnlyBmp );

#if 0
    // Pulling self-registration out. This is to be done once during setup only
    void    RegisterShell(CSingleDocTemplate *pDocTemplate);
#endif

    // Implementation
    COleTemplateServer m_server; // Server object for document creation

    // This is the minimum amount of free memory we like to have
    DWORD   m_dwLowMemoryBytes;
    UINT    m_nLowGdiPercent;
    UINT    m_nLowUserPercent;

    WORD    m_wEmergencyFlags;

    // General user settings
    BOOL    m_bShowStatusbar;

#ifdef CUSTOMFLOAT
    BOOL    m_bShowToolbar;
    BOOL    m_bShowColorbar;
#endif

    BOOL    m_bShowThumbnail;
    BOOL    m_bShowTextToolbar;
    BOOL    m_bShowIconToolbar;
    BOOL    m_bShowGrid;

#ifdef CUSTOMFLOAT
    BOOL    m_bToolsDocked;
    BOOL    m_bColorsDocked;
#endif //CUSTOMFLOAT


    BOOL    m_bEmbedded;
    BOOL    m_bLinked;
    BOOL    m_bHidden;
    BOOL    m_bActiveApp;
    BOOL    m_bPenSystem;
    BOOL    m_bMonoDevice;
    BOOL    m_bPaletted;

    BOOL    m_bPrintOnly;
    CString m_strDocName;
    CString m_strPrinterName;
    CString m_strDriverName;
    CString m_strPortName;

    BOOL    m_bWiaCallback;
    CString m_strWiaDeviceId;
    CString m_strWiaEventId;

#ifdef PCX_SUPPORT
    BOOL    m_bPCXfile;
#endif

    int     m_iCurrentUnits;

    // custom colors defined by the user
    COLORREF* m_pColors;
    int       m_iColors;

    // copy of the system wide palette
    CPalette* m_pPalette;

    CFont   m_fntStatus;

    int     m_nEmbeddedType;

    HWND    m_hwndInPlaceApp;

    class   CInPlaceFrame* m_pwndInPlaceFrame;

#ifdef CUSTOMFLOAT
    CRect   m_rectFloatTools;
    CRect   m_rectFloatColors;
#endif

    CRect   m_rectFloatThumbnail;

    CRect   m_rectMargins;

    BOOL    m_bCenterHorizontally;
    BOOL    m_bCenterVertically;
    BOOL    m_bScaleFitTo;
    int     m_nAdjustToPercent;
    int     m_nFitToPagesWide;
    int     m_nFitToPagesTall;

    WINDOWPLACEMENT m_wpPlacement;

    CSize   m_sizeBitmap;

    int     m_iPointSize;
    int     m_iPosTextX;
    int     m_iPosTextY;
    int     m_iBoldText;
    int     m_iUnderlineText;
    int     m_iItalicText;

    int     m_iVertEditText;

    int     m_iPenText;
    CString m_strTypeFaceName;
    int     m_iCharSet;

    int     m_iSnapToGrid;
    int     m_iGridExtent;

    // general system metrics. updated on system notification
    struct
        {
        int iWidthinPels;
        int iHeightinPels;
        int iWidthinMM;
        int iHeightinMM;
        int iWidthinINCH;
        int iHeightinINCH;
        int ixPelsPerDM;
        int iyPelsPerDM;
        int ixPelsPerMM;
        int iyPelsPerMM;
        int ixPelsPerINCH;
        int iyPelsPerINCH;
        int iBitsPixel;
        int iPlanes;
        } ScreenDeviceInfo;

    int     m_cxFrame;
    int     m_cyFrame;
    int     m_cxBorder;
    int     m_cyBorder;
    int     m_cyCaption;

    CBrush* m_pbrSysColors[nSysBrushes + nOurBrushes];
    CString m_sCurFile;
    int   m_nFilters;
    GUID *m_guidFltType; // export filter types available
    GUID  m_guidFltTypeUsed;
    int   m_nFilterInIdx;
    int   m_nFilterOutIdx;
    DWORD GetFilterIndex (REFGUID guidFltType);
    void FixExtension (CString& fileName, int iflFltType);

    CGdiplusInit GdiplusInit;

    #ifdef _DEBUG
    BOOL    m_bLogUndo;
    #endif

    private:

    int     m_nFileErrorCause;  // from CFileException::m_cause
    WORD    m_wEmergencyFlagss;
    DWORD   m_tickLastWarning;
    CString m_strEmergencyNoMem;
    CString m_strEmergencyLowMem;
    CString m_sLastFile;
    UINT    m_uOperation;

    afx_msg void OnFileOpen();


    //{{AFX_MSG(CPBApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    };

extern CPBApp theApp;

#define IsInPlace()     (theApp.m_pwndInPlaceFrame != NULL)

//#define SZ_MAPISENDDOC TEXT("MAPISendDocuments")
//#define MAPIDLL TEXT("MAPI32.DLL")

typedef ULONG (FAR PASCAL *LPFNMAPISENDDOCUMENTS)(ULONG, LPTSTR, LPTSTR, LPTSTR, ULONG);

void CancelToolMode(BOOL bSelectionCommand);

#if 0

// removing CRegKey - clashes with ATL class 

class CRegKey
{
public:
        CRegKey(HKEY hkParent, LPCTSTR pszSubKey) { if (RegCreateKey(hkParent, pszSubKey, &m_hk)!=ERROR_SUCCESS) m_hk=NULL; }
        ~CRegKey() { if (m_hk) RegCloseKey(m_hk); }
        operator HKEY() const { return(m_hk); }

private:
        HKEY m_hk;
};

#endif

extern const CLSID BASED_CODE CLSID_Paint;
extern const CLSID BASED_CODE CLSID_PaintBrush;

#define ARRAYSIZE(_x) sizeof(_x)/sizeof(_x[0])

// make atoi work if building unicode
//
#ifdef UNICODE
#define Atoi _wtoi
#define _Itoa _itow
#define Itoa _itow
#else
#define Atoi atoi
#define _Itoa _itoa
#define Itoa itoa
#endif


// macro-ize ansi/unicode conversions
#define AtoW(x, y) MultiByteToWideChar (CP_ACP, 0, (x), -1, (y), (lstrlenA ((x))+1))
#define WtoA(x,y) WideCharToMultiByte(CP_ACP, 0, (x), -1, (y), (lstrlenW((x))+1), NULL,NULL)


#ifdef USE_MIRRORING

////    REGetLayout - Get layout of DC
//
//      Returns layout flags from an NT5/W98 or later DC, or zero
//      on legacy platforms.

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL         0x00400000L
#endif
#ifndef WS_EX_NOINHERITLAYOUT
#define WS_EX_NOINHERITLAYOUT   0x00100000L
#endif
#ifndef LAYOUT_RTL
#define LAYOUT_RTL              0x01
#endif

DWORD WINAPI PBGetLayoutInit(HDC hdc);
DWORD WINAPI PBSetLayoutInit(HDC hdc, DWORD dwLayout);
extern DWORD (WINAPI *PBSetLayout) (HDC hdc, DWORD dwLayout);
extern DWORD (WINAPI *PBGetLayout) (HDC hdc);

#endif


/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pbrusfrm.cpp ===
// pbrusfrm.cpp : implementation of the CPBFrame class
//

#include "stdafx.h"
#include "resource.h"
#include "global.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "bmobject.h"
#include "docking.h"
#include "minifwnd.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgdlgs.h"
#include "cmpmsg.h"
#include "props.h"
#include "colorsrc.h"
#include <htmlhelp.h>
#include "imaging.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CPBFrame, CFrameWnd )

#include "memtrace.h"

#define UM_FILE_ERROR     WM_USER + 1001

/*************************** CPBFrame **************************************/

BEGIN_MESSAGE_MAP( CPBFrame, CFrameWnd )
    //{{AFX_MSG_MAP(CPBFrame)
        ON_WM_ACTIVATEAPP()
        ON_WM_CREATE()
        ON_WM_DESTROY()
        ON_WM_SETFOCUS()
        ON_WM_PALETTECHANGED()
        ON_WM_QUERYNEWPALETTE()
        ON_WM_GETMINMAXINFO()
        ON_WM_MOVE()
        ON_WM_SIZE()
        ON_WM_ERASEBKGND()
        ON_WM_DEVMODECHANGE()
        ON_WM_WININICHANGE()
        ON_COMMAND(ID_HELP, OnHelp)
        ON_WM_SYSCOLORCHANGE()
        ON_WM_CLOSE()
        ON_UPDATE_COMMAND_UI(ID_FILE_SCAN_NEW, OnUpdateAcquire)
        ON_COMMAND(ID_FILE_SCAN_NEW, OnAcquire)
        ON_UPDATE_COMMAND_UI(ID_FILE_SELECT_SOURCE, OnUpdateSelectSource)
        ON_COMMAND(ID_FILE_SELECT_SOURCE, OnSelectSource)
        //}}AFX_MSG_MAP

    ON_MESSAGE(UM_FILE_ERROR, OnFileError)

    // Global help commands
    ON_COMMAND(ID_HELP_INDEX, CFrameWnd::OnHelpIndex)
    ON_COMMAND(ID_HELP_USING, CFrameWnd::OnHelpUsing)
    ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpIndex)

        ON_UPDATE_COMMAND_UI(ID_VIEW_TOOL_BOX, CFrameWnd::OnUpdateControlBarMenu)
        ON_COMMAND_EX(ID_VIEW_TOOL_BOX, CFrameWnd::OnBarCheck)
        ON_UPDATE_COMMAND_UI(ID_VIEW_COLOR_BOX, CFrameWnd::OnUpdateControlBarMenu)
        ON_COMMAND_EX(ID_VIEW_COLOR_BOX, CFrameWnd::OnBarCheck)
END_MESSAGE_MAP()

/***************************************************************************/

/*********************** CPBFrame construction/destruction *****************/

CPBFrame::CPBFrame()
    {
    // Just small enough so that the control bars fit
    m_szFrameMin = CSize( 275, 410 );
    m_pMgr = new CWIAMgr;
#ifdef USE_TWAIN
    if (!m_pMgr || !m_pMgr->IsAvailable()) 
        {
        delete m_pMgr;
        m_pMgr = new CTwainMgr;
        }
#endif //USE_TWAIN
    }

/***************************************************************************/

CPBFrame::~CPBFrame()
    {
    // also can't delete objects  derived from class cframewnd, must destroy their
    // window => deletion indirectly
    delete m_pMgr;
    }

/*************************** CPBFrame diagnostics **************************/

#ifdef _DEBUG
void CPBFrame::AssertValid() const
    {
    CFrameWnd::AssertValid();
    }

/***************************************************************************/

void CPBFrame::Dump(CDumpContext& dc) const
    {
    CFrameWnd::Dump(dc);
    }

#endif //_DEBUG

/***************************************************************************/

TCHAR mszMSPaintClass[] = TEXT("MSPaintApp");

BOOL CPBFrame::PreCreateWindow( CREATESTRUCT& cs )
    {
        cs.dwExStyle |= WS_EX_WINDOWEDGE;
    cs.style |= WS_CLIPCHILDREN;
    BOOL bResult = CFrameWnd::PreCreateWindow( cs );

    if (bResult)
        {
        WINDOWPLACEMENT& wpSaved = theApp.m_wpPlacement;
        RECT& rcSaved = wpSaved.rcNormalPosition;

        CPoint ptPBrush(rcSaved.left, rcSaved.top);
        CSize sizePBrush(rcSaved.right - rcSaved.left, rcSaved.bottom - rcSaved.top);

        CPoint pt = theApp.CheckWindowPosition( ptPBrush, sizePBrush );
        if (pt.x || pt.y)
        {
            cs.x = pt.x;
            cs.y = pt.y;
        }

        sizePBrush.cx = max(sizePBrush.cx, m_szFrameMin.cx);
        sizePBrush.cy = max(sizePBrush.cy, m_szFrameMin.cy);
        if (sizePBrush.cx && sizePBrush.cy)
        {
            cs.cx = sizePBrush.cx;
            cs.cy = sizePBrush.cy;
        }

        rcSaved.left = cs.x;
        rcSaved.top  = cs.y;
        rcSaved.right = rcSaved.left + cs.cx;
        rcSaved.bottom = rcSaved.top + cs.cy;

        WNDCLASS  wndcls;
        HINSTANCE hInst = AfxGetInstanceHandle();

        // see if the class already exists
        if (! ::GetClassInfo( hInst, mszMSPaintClass, &wndcls ))
            {
            // get default stuff
            ::GetClassInfo( hInst, cs.lpszClass, &wndcls );

            // register a new class
            wndcls.lpszClassName = mszMSPaintClass;
            wndcls.hIcon         = ::LoadIcon( hInst, MAKEINTRESOURCE( ID_MAINFRAME ) );

            ASSERT( wndcls.hIcon != NULL );

            if (! AfxRegisterClass( &wndcls ))
                AfxThrowResourceException();
            }
        cs.lpszClass = mszMSPaintClass;
        }
    return bResult;
    }

/***************************************************************************/

CWnd* CPBFrame::GetMessageBar()
    {
    if (m_statBar.m_hWnd != NULL)
        return &m_statBar;

    return NULL;
    }

/***************************************************************************/

void CPBFrame::OnHelp()
    {
    if (m_dwPromptContext)
        CFrameWnd::OnHelp();
    else
        ::HtmlHelpA( ::GetDesktopWindow(), "mspaint.chm", HH_DISPLAY_TOPIC, 0L );
    }

/***************************************************************************/

int CPBFrame::OnCreate( LPCREATESTRUCT lpCreateStruct )
    {
    if (CFrameWnd::OnCreate( lpCreateStruct ) == -1)
        return -1;
    g_pStatBarWnd = &m_statBar;
    g_pImgToolWnd = &m_toolBar;
    g_pImgColorsWnd = &m_colorBar;
    return 0;
    }

/***************************************************************************/

void CPBFrame::OnDestroy()
    {
    CFrameWnd::OnDestroy();

    theApp.m_wpPlacement.length = sizeof(WINDOWPLACEMENT);
    GetWindowPlacement(&theApp.m_wpPlacement);

    theApp.SaveProfileSettings();
    }

/***************************************************************************/

BOOL CPBFrame::OnEraseBkgnd(CDC* pDC)
    {


        if ( !m_pViewActive )   //fix gray background on screen while IME disappear problem
        {


    CRect cRectClient;

    GetClientRect( &cRectClient );
    pDC->FillRect( &cRectClient, GetSysBrush( COLOR_BTNFACE ) );


    }


    return CFrameWnd::OnEraseBkgnd( pDC );
    }

/***************************************************************************/

void CPBFrame::OnActivateApp(BOOL bActive, HTASK hTask)
    {
    theApp.m_bActiveApp = bActive;

    CFrameWnd::OnActivateApp(bActive, hTask);
    }

/***************************************************************************/

void CPBFrame::OnMove( int x, int y )
    {
    CRect cRectWindow;

    GetWindowRect( &cRectWindow );
    m_ptPosition.x = cRectWindow.left;
    m_ptPosition.y = cRectWindow.top;

    CWnd::OnMove( x, y );
    }

/***************************************************************************/

void CPBFrame::OnSize( UINT nType, int cx, int cy )
    {
    CFrameWnd::OnSize( nType, cx, cy );

    CRect rect;

    GetWindowRect( &rect );

    m_szFrame = rect.Size();
    }

/***************************************************************************/

void CPBFrame::OnSetFocus(CWnd* pOldWnd)
    {
    CFrameWnd::OnSetFocus( pOldWnd );

        // We need to update the window here because the SetFocus below will update
        // the image window, and then some async paints can come after that which
        // will cause us to put the background color over parts of the window (see
        // WIN95C bug #4080).
    UpdateWindow();

    CPBView* pView = (CPBView*)GetActiveView();

    if (pView
    &&  pView->IsKindOf( RUNTIME_CLASS( CPBView ) )
    &&  pView->m_pImgWnd != NULL
    &&  ::IsWindow(pView->m_pImgWnd->m_hWnd) )
        pView->m_pImgWnd->SetFocus();
    }

/***************************************************************************/

void CPBFrame::OnPaletteChanged( CWnd* pFocusWnd )
    {
    CFrameWnd::OnPaletteChanged( pFocusWnd );

    CPBView* pView = (CPBView*)GetActiveView();

    if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        {
        pView->OnPaletteChanged( pFocusWnd );
        }
    }

/***************************************************************************/

BOOL CPBFrame::OnQueryNewPalette()
    {
    CPBView* pView = (CPBView*)GetActiveView();

    if (pView != NULL && ::IsWindow(pView->m_hWnd) && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        {
        pView->OnQueryNewPalette();
        }

    return CFrameWnd::OnQueryNewPalette();
    }

/***************************************************************************/

void CPBFrame::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
    {
    lpMMI->ptMinTrackSize.x = m_szFrameMin.cx;
    lpMMI->ptMinTrackSize.y = m_szFrameMin.cy;

    CFrameWnd::OnGetMinMaxInfo(lpMMI);
    }

/*****************************************************************************/

void CPBFrame::OnDevModeChange( LPTSTR lpDeviceName )
    {
    CClientDC dc( this );

    if (dc.m_hDC != NULL)
        theApp.GetSystemSettings( &dc );

    CFrameWnd::OnDevModeChange( lpDeviceName );
    }

/*****************************************************************************/

void CPBFrame::OnWinIniChange( LPCTSTR lpszSection )
    {
    CClientDC dc( this );
    CDocument *pDoc;

    if (dc.m_hDC != NULL)
        theApp.GetSystemSettings( &dc );

    if (         m_statBar.m_hWnd    != NULL
    &&  theApp.m_fntStatus.m_hObject != NULL)
        m_statBar.SetFont( &theApp.m_fntStatus, FALSE );

    CFrameWnd::OnWinIniChange( lpszSection );

    if (pDoc = GetActiveDocument())
         {
         pDoc->UpdateAllViews( NULL );
         GetActiveView()->UpdateWindow();
         }
    }

/*****************************************************************************/

void CPBFrame::ActivateFrame( int nCmdShow )
{
        WINDOWPLACEMENT& wpSaved = theApp.m_wpPlacement;

        if (theApp.m_bPrintOnly)
        {
                nCmdShow = SW_HIDE;
        }
        else if (!IsWindowVisible())
        {
                switch (nCmdShow)
                {
                case SW_SHOW:
                case SW_SHOWNORMAL:
                        switch (wpSaved.showCmd)
                        {
                        case SW_HIDE:
                        case SW_MINIMIZE:
                        case SW_SHOWMINIMIZED:
                        case SW_SHOWMINNOACTIVE:
                                break;

                        default:
                                nCmdShow = wpSaved.showCmd;
                                break;
                        }
                        break;
                }

                wpSaved.showCmd = nCmdShow;

                wpSaved.length = sizeof(WINDOWPLACEMENT);
                SetWindowPlacement(&wpSaved);
        }
        //
        // We have to reassign the global toolbar pointers here, in case
        // they were pointing to the inplace frame's toolbars and that window
        // was deleted.
        //
        g_pStatBarWnd = &m_statBar;
        g_pImgToolWnd = &m_toolBar;
        g_pImgColorsWnd = &m_colorBar;
        CFrameWnd::ActivateFrame( nCmdShow );
}

/*****************************************************************************/
#ifdef xyzzyz
void CPBFrame::OnUpdateFrameTitle( BOOL bAddToTitle )
    {
    if (theApp.m_bEmbedded && ! theApp.m_bLinked)
        {
        CFrameWnd::OnUpdateFrameTitle( bAddToTitle );
        return;
        }

    // get old text for comparison against new text
    CString sOld;
    CString sText;

    GetWindowText( sOld );

    CPBDoc* pDocument = (CPBDoc*)GetActiveDocument();

    if (bAddToTitle && pDocument != NULL)
        {
        const TCHAR* psTitle = pDocument->GetTitle();

        if (psTitle != NULL)
            {
            sText += GetName( psTitle );
            sText += TEXT(" - ");

            sText.MakeLower();
            }
        }
    sText += m_strTitle;

    // set title if changed, but don't remove completely
    if (sText != sOld)
        SetWindowText( sText );
    }
#endif
/*****************************************************************************/

LRESULT CPBFrame::OnFileError( WPARAM, LPARAM )
    {
    theApp.FileErrorMessageBox();

    return 0;
    }

/***************************************************************************/

void CPBFrame::OnSysColorChange()
{
        CFrameWnd ::OnSysColorChange();

        ResetSysBrushes();
}

void CPBFrame::OnClose()
{
        SaveBarState(TEXT("General"));
        CFrameWnd ::OnClose();
}

/***************************************************************************/

void CPBFrame::OnSelectSource()
{
    CWaitCursor DisplayWaitCursor;

    // if m_pMgr == 0, "Select Source" menu item will not be available anyway

    ASSERT(m_pMgr != 0); 

    HRESULT hr = m_pMgr->SelectSource(
        GetSafeHwnd(), 
        WIA_SELECT_DEVICE_NODEFAULT
    );

    if (!SUCCEEDED(hr)) 
    {
        CmpMessageBox(IDS_ERROR_SELECT_SCAN, 
            AFX_IDS_APP_TITLE, MB_OK | MB_ICONEXCLAMATION);
    }
}

void CPBFrame::OnAcquire()
{
    CWaitCursor DisplayWaitCursor;

    // if m_pMgr == 0, "Scan New" menu item will not be available anyway

    ASSERT(m_pMgr != 0); 

    // call the WIA interface to acquire the image

    HGLOBAL hDib = 0;

    HRESULT hr = m_pMgr->Acquire(GetSafeHwnd(), &hDib);

    if (!SUCCEEDED(hr)) 
    {
        // if the interface has failed, display the generic error message
        CmpMessageBox(IDS_ERROR_SCAN_NEW, 
            AFX_IDS_APP_TITLE, MB_OK | MB_ICONEXCLAMATION);
    }
    else if (hr == S_OK) 
    {
        // if the user has not cancelled the operation, get the image

        CPBView *pView = (CPBView*)GetActiveView();
        if (pView)
        {
            CPBDoc *pDoc = (CPBDoc *)pView->GetDocument();

            // prompt to save the current document if it was modified
            if (pDoc && pDoc->SaveModified()) 
            {
	            pDoc->SetModifiedFlag(FALSE);
                // and set this as the new image
                theApp.OnFileNew ();
                pDoc->SetDibHandle (hDib);
                pView->m_pImgWnd->Invalidate();
                pView->m_pImgWnd->CheckScrollBars();
            }
        }
    }
}

void CPBFrame::OnUpdateSelectSource(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_pMgr && m_pMgr->NumDevices(GetSafeHwnd()) > 0);
}

void CPBFrame::OnUpdateAcquire(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_pMgr && m_pMgr->NumDevices(GetSafeHwnd()) > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pbrush.cpp ===
// pbrush.cpp : Defines the class behaviors for the application.
//
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "ipframe.h"
#include "pbrusdoc.h"
#include "pbrusvw.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "ferr.h"
#include "cmpmsg.h"
#include "settings.h"
#include "undo.h"
#include "colorsrc.h"
#include "printres.h"
#include "loadimag.h"
#include "image.h"
#include <dlgs.h>
#include <shlobj.h>
#include "ofn.h"
#include "imaging.h"

// turn on visibility of GIF filter

#define GIF_SUPPORT

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


typedef BOOL(WINAPI* SHSPECPATH)(HWND,LPTSTR,int,BOOL);

#include "memtrace.h"

BOOL NEAR g_bShowAllFiles = FALSE;


#ifdef USE_MIRRORING
HINSTANCE ghInstGDI32=NULL;

DWORD WINAPI PBGetLayoutPreNT5(HDC hdc) {
    return 0;   // No mirroring on systems before NT5 or W98-CS
}

DWORD (WINAPI *PBGetLayout) (HDC hdc) = &PBGetLayoutInit;

DWORD WINAPI PBGetLayoutInit(HDC hdc) {

    PBGetLayout = (DWORD (WINAPI *) (HDC hdc)) GetProcAddress(ghInstGDI32, "GetLayout");

    if (!PBGetLayout) {
        PBGetLayout = PBGetLayoutPreNT5;
    }

    return PBGetLayout(hdc);

}


////    RESetLayout - Set layout of DC
//
//      Sets layout flags in an NT5/W98 or later DC.


DWORD WINAPI PBSetLayoutPreNT5(HDC hdc, DWORD dwLayout) {
    return 0;   // No mirroring on systems before NT5 or W98-CS
}

DWORD (WINAPI *PBSetLayout) (HDC hdc, DWORD dwLayout) = &PBSetLayoutInit;

DWORD WINAPI PBSetLayoutInit(HDC hdc, DWORD dwLayout) {

    PBSetLayout = (DWORD (WINAPI *) (HDC hdc, DWORD dwLayout)) GetProcAddress(ghInstGDI32, "SetLayout");

    if (!PBSetLayout) {
        PBSetLayout = PBSetLayoutPreNT5;
    }

    return PBSetLayout(hdc, dwLayout);

}
#endif

/***************************************************************************/
// CPBApp

BEGIN_MESSAGE_MAP(CPBApp, CWinApp)
    //{{AFX_MSG_MAP(CPBApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/***************************************************************************/
// CPBApp construction

CPBApp::CPBApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
    #ifdef _DEBUG
    m_bLogUndo = FALSE;
    #endif

    // This is the minimum amount of free memory we like to have
    // (NOTE: These are overwritten by ReadInitFile)
    m_dwLowMemoryBytes = 1024L * 2200;
    m_nLowGdiPercent   = 10;
    m_nLowUserPercent  = 10;

    m_nFileErrorCause  = 0;  // from CFileException::m_cause
    m_wEmergencyFlags  = 0;
    m_tickLastWarning  = 0;
    m_iCurrentUnits    = 0;

    m_bShowStatusbar   = TRUE;

    m_bShowThumbnail   = FALSE;
    m_bShowTextToolbar = TRUE;
    m_bShowIconToolbar = TRUE;


    m_bEmbedded        = FALSE;
    m_bLinked          = FALSE;
    m_bHidden          = FALSE;
    m_bActiveApp       = FALSE;
    m_bPenSystem       = FALSE;
    m_bPaletted        = FALSE;
    m_pPalette         = NULL;
    m_bPrintOnly       = FALSE;
#ifdef PCX_SUPPORT
    m_bPCXfile         = FALSE;
#endif

    m_rectFloatThumbnail.SetRectEmpty();

    m_rectMargins.SetRect(MARGINS_DEFAULT, MARGINS_DEFAULT, MARGINS_DEFAULT,
        MARGINS_DEFAULT);

    m_bCenterHorizontally = TRUE;
    m_bCenterVertically   = TRUE;
    m_bScaleFitTo         = FALSE;
    m_nAdjustToPercent    = 100;
    m_nFitToPagesWide     = 1;
    m_nFitToPagesTall     = 1;

    m_pwndInPlaceFrame = NULL;
    m_hwndInPlaceApp   = NULL;

    m_pColors = NULL;
    m_iColors = 0;

    for (int index = 0; index < nSysBrushes + nOurBrushes; index++)
    {
       m_pbrSysColors[index] = NULL;
    }

    m_nFilters        = 0;
    m_guidFltType     = NULL;
    m_guidFltTypeUsed = WiaImgFmt_UNDEFINED;
    m_nFilterInIdx    = -1; // default is All Pictures
    m_nFilterOutIdx   = 1;

#ifdef USE_MIRRORING
    ghInstGDI32 = GetModuleHandle(TEXT("gdi32.dll"));
#endif
}

/***************************************************************************/
// CPBApp destruction

CPBApp::~CPBApp()
{
    delete [] m_guidFltType;
}

/***************************************************************************/
// The one and only CPBApp object

CPBApp theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.
const CLSID BASED_CODE CLSID_Paint =
{ 0xd3e34b21, 0x9d75, 0x101a, { 0x8c, 0x3d, 0x0, 0xaa, 0x0, 0x1a, 0x16, 0x52 } };
const CLSID BASED_CODE CLSID_PaintBrush =
{ 0x0003000A, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };

/***************************************************************************/
// Stolen from WordPad
BOOL MatchOption(LPTSTR lpsz, LPTSTR lpszOption)
{
        if (lpsz[0] == TEXT('-') || lpsz[0] == TEXT('/'))
        {
                lpsz++;
                if (lstrcmpi(lpsz, lpszOption) == 0)
                        return TRUE;
        }
        return FALSE;
}

void CPBApp::ParseCommandLine()
{
        BOOL bPrintTo = FALSE;
   #ifdef UNICODE
        int argcw;
        LPWSTR *argvw;
        argvw = CommandLineToArgvW (GetCommandLine (), &argcw);
   #define ARGV argvw
   #define ARGC argcw
   #else
   #define ARGV __argv
   #define ARGC __argc
   #endif
        // start at 1 -- the first is the exe
        for (int i=1; i< ARGC; i++)
        {
                if (MatchOption(ARGV[i], TEXT("pt")))
                        bPrintTo = m_bPrintOnly = TRUE;
                else if (MatchOption(ARGV[i], TEXT("p")))
                        m_bPrintOnly = TRUE;
                else if (MatchOption(ARGV[i], TEXT("wia")))
                        m_bWiaCallback = TRUE;
                else if (m_bWiaCallback && m_strWiaDeviceId.IsEmpty())
                        m_strWiaDeviceId = ARGV[i];
                else if (m_bWiaCallback && m_strWiaEventId.IsEmpty())
                        m_strWiaEventId = ARGV[i];
//              else if (MatchOption(__argv[i], "t"))
//                      m_bForceTextMode = TRUE;
//              else if (MatchOption(__argv[i], "Embedding"))
//                      m_bEmbedded = TRUE;
//              else if (MatchOption(__argv[i], "Automation"))
//                      m_bEmbedded = TRUE;
                else if (m_strDocName.IsEmpty())
                        m_strDocName = ARGV[i];
                else if (bPrintTo && m_strPrinterName.IsEmpty())
                        m_strPrinterName = ARGV[i];
                else if (bPrintTo && m_strDriverName.IsEmpty())
                        m_strDriverName = ARGV[i];
                else if (bPrintTo && m_strPortName.IsEmpty())
                        m_strPortName = ARGV[i];
                else
                {
                        ASSERT(FALSE);
                }
        }
   #ifdef UNICODE
      GlobalFree (argvw);
   #endif
}


void GetShortModuleFileName(HINSTANCE hInst, LPTSTR pszName, UINT uLen)
{
        TCHAR szLongName[_MAX_PATH];

        GetModuleFileName(hInst, szLongName, _MAX_PATH);

        // APPCOMPAT GSPN sometimes fails on UNC's.  Try this until that is tracked down
        lstrcpyn(pszName, szLongName, uLen);

        if (!GetShortPathName(szLongName, pszName, uLen))
        {
                GetLastError();
        }
}


#if 0

// Pulling self-registration out. This is to be done once during setup only

void CPBApp::RegisterShell(CSingleDocTemplate *pDocTemplate)
{
        const struct
        {
                LPCTSTR pszActionID;
                LPCTSTR pszCommand;
        } aActions[] =
        {
                { TEXT("Open")   , TEXT("\"%s\" \"%%1\"") },
                { TEXT("Print")  , TEXT("\"%s\" /p \"%%1\"") },
                { TEXT("PrintTo"), TEXT("\"%s\" /pt \"%%1\" \"%%2\" \"%%3\" \"%%4\"") },
        } ;

        // We now need quotes around the file name, and MFC doesn't do this
        CString strTypeID;
        if (!pDocTemplate->GetDocString(strTypeID, CDocTemplate::regFileTypeId))
        {
                return;
        }

        strTypeID += TEXT("\\shell");

        CRegKey rkShellInfo(HKEY_CLASSES_ROOT, strTypeID);
        if (!(HKEY)rkShellInfo)
        {
                return;
        }

        TCHAR szFile[MAX_PATH];
        ::GetShortModuleFileName(AfxGetInstanceHandle(), szFile, ARRAYSIZE(szFile));

        int i;
        for (i=0; i<ARRAYSIZE(aActions); ++i)
        {
                CRegKey rkAction(rkShellInfo, aActions[i].pszActionID);
                if (!(HKEY)rkAction)
                {
                        continue;
                }

                // Note I do not set the name of the action;  I will need to add this
                // if I use anything other than "Open", "Print", or "PrintTo"

                TCHAR szCommand[MAX_PATH + 80];
                wsprintf(szCommand, aActions[i].pszCommand, szFile);

                RegSetValue(rkAction, TEXT("command"), REG_SZ, szCommand, 0);
        }

        // Set the OLE server for PBrush objects
        CRegKey rkPBrushInfo(HKEY_CLASSES_ROOT, TEXT("PBrush\\protocol\\StdFileEditing\\server"));
        if ((HKEY)rkPBrushInfo)
        {
                RegSetValue(rkPBrushInfo, TEXT(""), REG_SZ, szFile, 0);
        }
}

#endif

/***************************************************************************/
// CPBApp initialization

BOOL CPBApp::InitInstance()
    {
    SetRegistryKey( IDS_REGISTRY_PATH );
    if (m_pszProfileName)
    {
       free((void*)m_pszProfileName);
    }
    m_pszProfileName = _tcsdup(TEXT("Paint"));

    HDC hdc = ::GetDC( NULL );

    ASSERT( hdc != NULL );

    GetSystemSettings( CDC::FromHandle( hdc ) );

    ::ReleaseDC( NULL, hdc );

    // Because we cannot LoadString when these strings are needed (in
    // WarnUserOfEmergency) load them here in private member variables
    // of CTheApp...
    //
    m_strEmergencyNoMem.LoadString ( IDS_ERROR_NOMEMORY );
    m_strEmergencyLowMem.LoadString( IDS_ERROR_LOWMEMORY );

    // Initialize OLE 2.0 libraries
    if (! AfxOleInit())
        {
        AfxMessageBox( IDP_OLE_INIT_FAILED );
        return FALSE;
        }

    // disable the annoying "server busy" dialog that pops up
    // during long blocking WIA calls

    COleMessageFilter* pFilter = AfxOleGetMessageFilter();

    ASSERT( pFilter );

    if (pFilter)
        {
        pFilter->EnableNotRespondingDialog(FALSE); 
        pFilter->EnableBusyDialog(FALSE);
        }

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    // SetDialogBkColor();        // Set dialog background color to gray
    LoadProfileSettings();     // Load standard INI file options (including MRU)
    InitCustomData();

    if (! g_pColors)
            {
            g_pColors = new CColors;

            if (! g_pColors->GetColorCount())
                {
                theApp.SetMemoryEmergency();
                return -1;
                }
            }
    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;

    pDocTemplate = new CSingleDocTemplate( ID_MAINFRAME,
                                 RUNTIME_CLASS( CPBDoc ),
                                 RUNTIME_CLASS( CPBFrame ), // main SDI frame window
                                 RUNTIME_CLASS( CPBView ) );

    pDocTemplate->SetServerInfo( IDR_SRVR_EMBEDDED, IDR_SRVR_INPLACE,
                                 RUNTIME_CLASS( CInPlaceFrame ),
                                 RUNTIME_CLASS( CPBView ) );

    AddDocTemplate( pDocTemplate );

    // Connect the COleTemplateServer to the document template.
    //  The COleTemplateServer creates new documents on behalf
    //  of requesting OLE containers by using information
    //  specified in the document template.
    m_server.ConnectTemplate( CLSID_Paint, pDocTemplate, TRUE );
        // Note: SDI applications register server objects only if /Embedding
        //   or /Automation is present on the command line.

#if 0
    // Pulling self-registration out. This is to be done once during setup only
    RegisterShell(pDocTemplate);
#endif

    m_bEmbedded = RunEmbedded();

    // Parse the command line to see if launched as OLE server
    if (m_bEmbedded || RunAutomated())
        {
        // Register all OLE server (factories) as running.  This enables the
        //  OLE 2.0 libraries to create objects from other applications.
        COleTemplateServer::RegisterAll();

        // Application was run with /Embedding or /Automation.  Don't show the
        //  main window in this case.
        return TRUE;
        }

#if 0
    // Pulling self-registration out. This is to be done once during setup only

    // When a server application is launched stand-alone, it is a good idea
    //  to update the system registry in case it has been damaged.
    m_server.UpdateRegistry( OAT_INPLACE_SERVER );
#endif

    ParseCommandLine();

    if (m_bWiaCallback)
    {
        USES_CONVERSION;
        GUID guidEventId;

        ASSERT(!m_strWiaEventId.IsEmpty() && !m_strWiaDeviceId.IsEmpty());

        // check that we have received the WIA_EVENT_DEVICE_CONNECTED event and
        // a valid device id. If not, we should exit before going any further

        if (m_strWiaEventId.IsEmpty() ||
            m_strWiaDeviceId.IsEmpty() ||
            CLSIDFromString((LPOLESTR) T2COLE(m_strWiaEventId), &guidEventId) != S_OK ||
            guidEventId != WIA_EVENT_DEVICE_CONNECTED)
        {
            return FALSE;
        }
    }

    // simple command line parsing
    if (m_strDocName.IsEmpty())
        {
        // create a new (empty) document
        OnFileNew();
        }
    else
        {
        CString sExt = GetExtension( m_strDocName );

        if (sExt.IsEmpty())
            {
            if (pDocTemplate->GetDocString( sExt, CDocTemplate::filterExt )
            &&                            ! sExt.IsEmpty())
                m_strDocName += sExt;
            }

        WIN32_FIND_DATA finddata;
        HANDLE hFind = FindFirstFile(m_strDocName, &finddata);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

            // Find the file name and replace it with the long file name
            int iBS = m_strDocName.ReverseFind(TEXT('\\'));
            if (iBS == -1)
            {
                iBS = m_strDocName.ReverseFind(TEXT(':'));
            }

            // HACK: Notice this is correct even if iBS==-1
            ++iBS;

            // Resize the memory string
            m_strDocName.GetBuffer(iBS);
            m_strDocName.ReleaseBuffer(iBS);

            m_strDocName += finddata.cFileName;
        }

        OpenDocumentFile( m_strDocName );
        }

    if (m_pMainWnd)
    {
        m_pMainWnd->DragAcceptFiles();

        if (m_bWiaCallback)
        {
            // select the device and post a message to popup the WIA dialog
            ((CPBFrame*)m_pMainWnd)->m_pMgr->Select(m_strWiaDeviceId);
            m_pMainWnd->PostMessage(WM_COMMAND, ID_FILE_SCAN_NEW, 0);
        }
    }


    return TRUE;
    }

/***************************************************************************/

int CPBApp::ExitInstance()
    {
    CustomExit();   // clean up in customiz
    CleanupImages();

    if (g_pColors)
        {
        delete g_pColors;
        g_pColors = NULL;
        }

    if (m_fntStatus.m_hObject != NULL)
        m_fntStatus.DeleteObject();

    ResetSysBrushes();

    CTracker::CleanUpTracker();

    return CWinApp::ExitInstance();
    }

/***************************************************************************/

void CPBApp::GetSystemSettings( CDC* pdc )
    {
    NONCLIENTMETRICS ncMetrics;

    ncMetrics.cbSize = sizeof( NONCLIENTMETRICS );

    if (SystemParametersInfo( SPI_GETNONCLIENTMETRICS,
                              sizeof( NONCLIENTMETRICS ),
                              &ncMetrics, 0 ))
        {
        if (m_fntStatus.m_hObject != NULL)
            m_fntStatus.DeleteObject();

        m_fntStatus.CreateFontIndirect( &ncMetrics.lfMenuFont );
        }

    ScreenDeviceInfo.iWidthinMM    = pdc->GetDeviceCaps( HORZSIZE   );
    ScreenDeviceInfo.iHeightinMM   = pdc->GetDeviceCaps( VERTSIZE   );
    ScreenDeviceInfo.iWidthinPels  = pdc->GetDeviceCaps( HORZRES    );
    ScreenDeviceInfo.iHeightinPels = pdc->GetDeviceCaps( VERTRES    );
    ScreenDeviceInfo.ixPelsPerINCH = pdc->GetDeviceCaps( LOGPIXELSX );
    ScreenDeviceInfo.iyPelsPerINCH = pdc->GetDeviceCaps( LOGPIXELSY );

    /* get the pels per decameter '.1' rounded */
    ScreenDeviceInfo.ixPelsPerDM   = (int)(((((long)ScreenDeviceInfo.iWidthinPels  * 1000L) / (long)ScreenDeviceInfo.iWidthinMM ) + 5L) / 10);
    ScreenDeviceInfo.iyPelsPerDM   = (int)(((((long)ScreenDeviceInfo.iHeightinPels * 1000L) / (long)ScreenDeviceInfo.iHeightinMM) + 5L) / 10);
    ScreenDeviceInfo.ixPelsPerMM   = (ScreenDeviceInfo.ixPelsPerDM + 50) / 100;
    ScreenDeviceInfo.iyPelsPerMM   = (ScreenDeviceInfo.iyPelsPerDM + 50) / 100;
    ScreenDeviceInfo.iWidthinINCH  = (int)(((long)ScreenDeviceInfo.iWidthinMM  * 100L / 245L + 5L) / 10L);  //24.5 mm to the inch
    ScreenDeviceInfo.iHeightinINCH = (int)(((long)ScreenDeviceInfo.iHeightinMM * 100L / 245L + 5L) / 10L);

    ScreenDeviceInfo.iBitsPixel    = pdc->GetDeviceCaps( BITSPIXEL );
    ScreenDeviceInfo.iPlanes       = pdc->GetDeviceCaps( PLANES    );

    m_cxFrame    = GetSystemMetrics( SM_CXFRAME );
    m_cyFrame    = GetSystemMetrics( SM_CYFRAME );
    m_cxBorder   = GetSystemMetrics( SM_CXBORDER );
    m_cyBorder   = GetSystemMetrics( SM_CYBORDER );
    m_cyCaption  = GetSystemMetrics( SM_CYSMCAPTION );
    m_bPenSystem = GetSystemMetrics( SM_PENWINDOWS )? TRUE: FALSE;
    m_bPaletted  = (pdc->GetDeviceCaps( RASTERCAPS ) & RC_PALETTE);

    m_bMonoDevice = ((ScreenDeviceInfo.iBitsPixel
                  *   ScreenDeviceInfo.iPlanes) == 1);

    SetErrorMode( SEM_NOOPENFILEERRORBOX );
    }

/***************************************************************************/

CPoint CPBApp::CheckWindowPosition( CPoint ptPosition, CSize& sizeWindow )
    {
    CPoint ptNew = ptPosition;

    sizeWindow.cx = max( sizeWindow.cx, 0 );
    sizeWindow.cy = max( sizeWindow.cy, 0 );

    if (sizeWindow.cx
    &&  sizeWindow.cy)
        {
        sizeWindow.cx = min( sizeWindow.cx, ScreenDeviceInfo.iWidthinPels  );
        sizeWindow.cy = min( sizeWindow.cy, ScreenDeviceInfo.iHeightinPels );
        }

    ptNew.x = max( ptNew.x, 0 );
    ptNew.y = max( ptNew.y, 0 );

    if (ptNew.x
    &&  ptNew.y)
        {
        if (ptNew.x >= ScreenDeviceInfo.iWidthinPels)
            ptNew.x  = ScreenDeviceInfo.iWidthinPels - sizeWindow.cx;

        if (ptNew.y >= ScreenDeviceInfo.iHeightinPels)
            ptNew.y  = ScreenDeviceInfo.iHeightinPels - sizeWindow.cy;
        }

    return ptNew;
    }

/***************************************************************************/

void CPBApp::WinHelp( DWORD dwData, UINT nCmd /* = HELP_CONTEXT */ )
    {
    // This app has been converted to use HtmlHelp.  This is a safety to prevent someone
    // from accidentally adding WinHelp calls for proceedural help
    ASSERT( (nCmd != HELP_FINDER) && (nCmd != HELP_INDEX) && (nCmd != HELP_CONTENTS) );

    CWinApp::WinHelp( dwData, nCmd );
    }

/***************************************************************************/

BOOL CPBApp::OnIdle( LONG lCount )
    {
    if (m_bHidden)
        return CWinApp::OnIdle( lCount );

    if (! lCount)
        {
        if (CheckForEmergency())
            {
            TryToFreeMemory();
            WarnUserOfEmergency();
            }
        if (m_nFileErrorCause != CFileException::none && m_pMainWnd)
            {
            CWnd* pWnd = AfxGetMainWnd();

            pWnd->PostMessage( WM_USER + 1001 );
            }
        }
    extern void IdleImage();

    IdleImage();

    return CWinApp::OnIdle(lCount) || lCount <= 4;
    }

/***************************************************************************/
// Map a file error code to a string id.

struct FERRID
    {
    int ferr;
    int ids;
    } mpidsferr[] =
    {
        { ferrIllformedGroup,    IDS_ERROR_BOGUSFILE    },
        { ferrReadFailed,        IDS_ERROR_BOGUSFILE    }, // error while reading a file or file corupt
        { ferrIllformedFile,     IDS_ERROR_BOGUSFILE    }, // not a valid palette file or zero length pcx file
        { ferrCantProcNewExeHdr, IDS_ERROR_EXE_HDR      },
        { ferrCantProcOldExeHdr, IDS_ERROR_EXE_HDR      },
        { ferrBadMagicNewExe,    IDS_ERROR_EXE_HDRMZ    },
        { ferrBadMagicOldExe,    IDS_ERROR_EXE_HDRMZ    },
        { ferrNotWindowsExe,     IDS_ERROR_EXE_HDRNW    },
        { ferrExeWinVer3,        IDS_ERROR_EXE_HDRWV    },
        { ferrNotValidRc,        IDS_ERROR_NOTVALID_RC  },
        { ferrNotValidExe,       IDS_ERROR_NOTVALID_EXE },
        { ferrNotValidRes,       IDS_ERROR_NOTVALID_RES },
        { ferrNotValidBmp,       IDS_ERROR_NOTVALID_BMP }, // invalid bitmap
        { ferrNotValidIco,       IDS_ERROR_NOTVALID_ICO },
        { ferrNotValidCur,       IDS_ERROR_NOTVALID_CUR },
        { ferrRcInvalidExt,      IDS_ERROR_RCPROB       },
        { ferrFileAlreadyOpen,   IDS_ERROR_COMPEX       },
        { ferrExeTooLarge,       IDS_ERROR_EXE_ALIGN    },
        { ferrCantCopyOldToNew,  IDS_ERROR_EXE_SAVE     },
        { ferrReadLoad,          IDS_ERROR_READLOAD     },
        { ferrExeAlloc,          IDS_ERROR_EXE_ALLOC    },
        { ferrExeInUse,          IDS_ERROR_EXE_INUSE    },
        { ferrExeEmpty,          IDS_ERROR_EXE_EMPTY    },
        { ferrGroup,             IDS_ERROR_GROUP        },
        { ferrResSave,           IDS_ERROR_RES_SAVE     },
        { ferrSaveOverOpen,      IDS_ERROR_SAVEOVEROPEN },
        { ferrSaveOverReadOnly,  IDS_ERROR_SAVERO       },
        { ferrCantDetermineType, IDS_ERROR_WHAAAT       }, // bad pcx file
        { ferrSameName,          IDS_ERROR_SAMENAME     },
        { ferrSaveAborted,       IDS_ERROR_SAVE_ABORTED },
        { ferrLooksLikeNtRes,    IDS_ERROR_NT_RES       },
        { ferrCantSaveReadOnly,  IDS_ERROR_CANT_SAVERO  }, // trying to save over a read only file
    };

int IdsFromFerr(int ferr)
    {
    if (ferr < ferrFirst)
        return IDS_ERROR_FILE + ferr; // was an exception cause

    for (int i = 0; i < sizeof (mpidsferr) / sizeof (FERRID); i++)
        {
        if (mpidsferr[i].ferr == ferr)
            return mpidsferr[i].ids;
        }

    ASSERT(FALSE); // You forgot to stick an entry in the above table!
    return 0;
    }

/***************************************************************************/
// Display a message box informing the user of a file related exception.
// The format of the box is something like:
//
//     <file name>
//     <operation failed>
//     <reason>
//
// <file name> describes what file has the problem, <operation files>
// indicated what kind of thing failed (e.g. "Cannot save file"), and
// <reason> provides more information about why the operation failed
// (e.g. "Disk full").
//
// All the parameters must have been setup previously via a call to
// CWinApp::SetFileError().
//
void CPBApp::FileErrorMessageBox( void )
    {
    static BOOL bInUse = FALSE;

    if (m_nFileErrorCause != CFileException::none && ! bInUse)
        {
        bInUse = TRUE;

        CString strOperation;
        VERIFY( strOperation.LoadString( m_uOperation ) );

        CString strReason;
        VERIFY( strReason.LoadString( IdsFromFerr( m_nFileErrorCause ) ) );

        CString strFmt;
        CString strMsg;

        if (m_sLastFile.IsEmpty())
            { 
            strFmt.LoadString(IDS_FORMATERR_NOFILE);
            strMsg.Format(strFmt, (LPCTSTR)strOperation, (LPCTSTR)strReason);
            }
        else
            {
            strFmt.LoadString(IDS_FORMATERR_FILE);
            strMsg.Format(strFmt, (LPCTSTR)m_sLastFile, (LPCTSTR)strOperation, (LPCTSTR)strReason);
            }
        AfxMessageBox( strMsg, MB_TASKMODAL | MB_OK | MB_ICONEXCLAMATION );

        bInUse = FALSE;
        }
    m_nFileErrorCause = CFileException::none;
    }

/***************************************************************************/

void CPBApp::SetFileError( UINT uOperation, int nCause, LPCTSTR lpszFile )
    {
    m_nFileErrorCause = nCause;
    m_uOperation      = uOperation;

    if (lpszFile)
        m_sLastFile = lpszFile;
    }

/***************************************************************************/
//  Memory/resource emergency handling functions

void CPBApp::SetMemoryEmergency(BOOL bFailed)
    {
    TRACE(TEXT("Memory emergency!\n"));

    m_wEmergencyFlags |= memoryEmergency | warnEmergency;

    if (bFailed)
        m_wEmergencyFlags |= failedEmergency;
    }

/***************************************************************************/

void CPBApp::SetGdiEmergency(BOOL bFailed)
    {
    TRACE(TEXT("GDI emergency!\n"));

    m_wEmergencyFlags |= gdiEmergency | warnEmergency;

    if (bFailed)
        m_wEmergencyFlags |= failedEmergency;
    }

/***************************************************************************/

void CPBApp::SetUserEmergency(BOOL bFailed)
    {
    TRACE(TEXT("USER emergency!\n"));

    m_wEmergencyFlags |= userEmergency | warnEmergency;

    if (bFailed)
        m_wEmergencyFlags |= failedEmergency;
    }

/***************************************************************************/

void CPBApp::WarnUserOfEmergency()
    {
    if ((m_wEmergencyFlags & warnEmergency) == 0)
        {
        // We have nothing to warn the user about!
        return;
        }

    if ((m_wEmergencyFlags & failedEmergency) == 0 &&
         GetTickCount() < m_tickLastWarning + ticksBetweenWarnings)
        {
        // We've warned the user recently, so keep quiet for now...
        // The warning flag is cleared so we don't just warn the
        // user after the delay is up unless another emergency
        // occurs AFTER then...

        m_wEmergencyFlags &= ~warnEmergency;
        return;
        }

    // Don't go invoking message boxes when we're not the active app!
    if (! m_bActiveApp)
        return;

    const TCHAR* szMsg = (m_wEmergencyFlags & failedEmergency) != 0 ?
        m_strEmergencyNoMem : m_strEmergencyLowMem;

    if (AfxMessageBox(szMsg, MB_TASKMODAL | MB_OK | MB_ICONSTOP) == IDOK)
        {
        m_wEmergencyFlags &= ~(warnEmergency | failedEmergency);
        m_tickLastWarning = GetTickCount();
        }
    #ifdef _DEBUG
    else
        TRACE(TEXT("Emergency warning message box failed!\n"));
    #endif

    // Update status bar warning message...
    if ( ::IsWindow( ((CPBFrame*)m_pMainWnd)->m_statBar.m_hWnd ) )
        ((CPBFrame*)m_pMainWnd)->m_statBar.Invalidate(FALSE);
    }

/***************************************************************************/

void CPBApp::TryToFreeMemory()
    {
    // We are in a memory/resource emergency state!  Add things to this
    // function to flush caches and do anything else to free up memory
    // we don't really need to be using right now...
    if (m_wEmergencyFlags & memoryEmergency)
        {
        CPBDoc* pDoc = (CPBDoc*)((CFrameWnd*)AfxGetMainWnd())->GetActiveDocument();

        if (pDoc && pDoc->m_pBitmapObj && ! pDoc->m_pBitmapObj->IsDirty()
                                       &&   pDoc->m_pBitmapObj->m_hThing)
            pDoc->m_pBitmapObj->Free();
        }

    if (m_wEmergencyFlags & gdiEmergency)
        {
//      theUndo.Flush();
        ResetSysBrushes();
        }
    }

/***************************************************************************/

// App command to run the dialog
void CPBApp::OnAppAbout()
    {
    CString sTitle;
    CString sBrag;
    HICON   hIcon = LoadIcon( ID_MAINFRAME );

    sTitle.LoadString( AFX_IDS_APP_TITLE );
    sBrag.LoadString( IDS_PerContractSoDontChange );

    ShellAbout( AfxGetMainWnd()->GetSafeHwnd(), sTitle, sBrag, hIcon );

    if (hIcon != NULL)
        ::DestroyIcon( hIcon );
    }

/***************************************************************************/

void CPBApp::SetDeviceHandles(HANDLE hDevNames, HANDLE hDevMode)
{
        // The old ones should already be freed
        m_hDevNames = hDevNames;
        m_hDevMode = hDevMode;
}

/***************************************************************************/

#if 0 

class CFileOpenSaveDlg : public CFileDialog
    {
    public:

    BOOL m_bOpenFile;

    CFileOpenSaveDlg( BOOL bOpenFileDialog );

    virtual void OnLBSelChangedNotify( UINT nIDBox, UINT iCurSel, UINT nCode );

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/

BEGIN_MESSAGE_MAP(CFileOpenSaveDlg, CFileDialog)
END_MESSAGE_MAP()

/***************************************************************************/

CFileOpenSaveDlg::CFileOpenSaveDlg( BOOL bOpenFileDialog )
                           :CFileDialog( bOpenFileDialog )
    {
    m_bOpenFile = bOpenFileDialog;
    }

/***************************************************************************/

void CFileOpenSaveDlg::OnLBSelChangedNotify( UINT nIDBox, UINT iCurSel, UINT nCode )
    {
    if (! m_bOpenFile && iCurSel <= 5 && nIDBox == cmb1
                                      &&  nCode == CD_LBSELCHANGE)
        {
        // change in the file type
        CWnd* pText = GetDlgItem( edt1 );
        CWnd* pType = GetDlgItem( cmb1 );
        CString sFname;
        CString sDfltExt;

        switch (iCurSel)
            {
#ifdef PCX_SUPPORT
            case 4:
                sDfltExt.LoadString( IDS_EXTENSION_PCX );
                break;
#endif
            case 5:
                sDfltExt.LoadString( IDS_EXTENSION_ICO );
                break;

            default:
                sDfltExt.LoadString( IDS_EXTENSION_BMP );
                break;
            }
        pText->GetWindowText( sFname );

        if (sDfltExt.CompareNoCase( GetExtension( sFname ) ))
            {
            sFname = StripExtension( sFname ) + sDfltExt;
            pText->SetWindowText( sFname );
            }
        }
    }

#endif //0

/***************************************************************************/

extern BOOL AFXAPI AfxFullPath( LPTSTR lpszPathOut, LPCTSTR lpszFileIn );

CDocument*
CPBApp::OpenDocumentFile(
    LPCTSTR lpszFileName
    )
{
    CancelToolMode(FALSE);

    TCHAR szPath[_MAX_PATH];

    AfxFullPath( szPath, lpszFileName );

    return(m_pDocManager->OpenDocumentFile(szPath));

//    CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetHead();
//
//    ASSERT( pTemplate->IsKindOf( RUNTIME_CLASS( CDocTemplate ) ) );
//
//    return pTemplate->OpenDocumentFile( szPath );
}

void CancelToolMode(BOOL bSelectionCommand)
{
        if (bSelectionCommand)
        {
                // Check if a selection tool is the current one
                if ((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
                        || (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
                {
                        // Don't try canceling the mode, since the command works on a
                        // selection
                        return;
                }
        }

        // Just select the current tool again to reset everything
        CImgTool *pImgTool = CImgTool::GetCurrent();
        if (pImgTool)
        {
                pImgTool->Select();
        }
}

/***************************************************************************/
// CPBApp commands

void CPBApp::OnFileNew()
{
    CancelToolMode(FALSE);

    CWinApp::OnFileNew();
    }

void CPBApp::OnFileOpen()
    {
    CancelToolMode(FALSE);

    // prompt the user (with all document templates)
    CString newName;

    int iColor = 0;

    if (! DoPromptFileName( newName, AFX_IDS_OPENFILE,
                                     OFN_HIDEREADONLY | OFN_FILEMUSTEXIST,
                                     TRUE, iColor, FALSE ))
        return; // open cancelled

#ifdef PCX_SUPPORT
    m_bPCXfile = (iColor == 4);
#endif

    CPBDoc* pDoc = (CPBDoc*)((CFrameWnd*)AfxGetMainWnd())->GetActiveDocument();

    // prompt to save the current document if it was modified
    if (pDoc && pDoc->SaveModified()) 
    {
        pDoc->SetModifiedFlag(FALSE);

        if (OpenDocumentFile( newName )==NULL)
        {
           // attempt to open a file failed, so make sure any new doc just
           // created in the process gets destroyed
           POSITION tPos = GetFirstDocTemplatePosition();
           CDocTemplate* pTemplate = GetNextDocTemplate(tPos);
           POSITION dPos = pTemplate->GetFirstDocPosition ();
           CPBDoc *pDoc= (CPBDoc *)(pTemplate->GetNextDoc(dPos));

           if (pDoc->m_pBitmapObjNew)
           {
              delete pDoc->m_pBitmapObjNew;
              pDoc->m_pBitmapObjNew =NULL;
           }
           OnFileNew(); // then start anew...
        }
    }
}

/****************************************************************************/
// prompt for file name - used for open and save as

BOOL CPBApp::DoPromptFileName( CString& fileName, UINT nIDSTitle, DWORD lFlags,
                               BOOL bOpenFileDialog, int& iColors, BOOL bOnlyBmp )
    {
    COpenFileName dlgFile( bOpenFileDialog );

    ASSERT(dlgFile.m_pofn);

    if (!dlgFile.m_pofn)
        return FALSE;

    CString title;

    VERIFY( title.LoadString( nIDSTitle ) );

    lFlags |= OFN_EXPLORER;

    if (!bOpenFileDialog)
        lFlags |= OFN_OVERWRITEPROMPT;

    dlgFile.m_pofn->Flags |= lFlags;
    dlgFile.m_pofn->Flags &= ~OFN_SHOWHELP;

    CString strFilter;
//    CString strDefault;

    CDocTemplate* pTemplate = NULL;
    POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();

    if (pos != NULL)
        pTemplate = m_pDocManager->GetNextDocTemplate(pos);

    CString strFilterExt;
    CString strFilterName;
    CString strAllPictureFiles;

    ASSERT(pTemplate != NULL);

    pTemplate->GetDocString( strFilterExt , CDocTemplate::filterExt  );
    pTemplate->GetDocString( strFilterName, CDocTemplate::filterName );

    ASSERT( strFilterExt[0] == TEXT('.') );

    // set the default extension
//    strDefault = ((const TCHAR*)strFilterExt) + 1;  // skip the '.'
//    dlgFile.m_pofn->nFilterIndex = iColors + 1; // 1 based number
    dlgFile.m_pofn->lpstrDefExt = ((LPCTSTR)strFilterExt) + 1; // skip the '.'

    if (bOpenFileDialog)
    {
        // add to filter
        strFilter = strFilterName;
        strFilter += _T('\0');       // next string please
        strFilter += _T("*") + strFilterExt;
        VERIFY(strFilterExt.LoadString(IDS_EXTENSION_DIB));
        strFilter += _T(";*") + strFilterExt;
        strAllPictureFiles += _T(";*") + strFilterExt;
        VERIFY(strFilterExt.LoadString(IDS_EXTENSION_BMP));
        strAllPictureFiles += _T(";*") + strFilterExt;
        VERIFY(strFilterExt.LoadString(IDS_EXTENSION_RLE));
        strFilter += _T(";*") + strFilterExt;
        strFilter += _T('\0');       // next string please

        dlgFile.m_pofn->nMaxCustFilter++;
    }
    else
    {
        for (int i = IDS_BMP_MONO; i <= IDS_BMP_TRUECOLOR; i++)
        {
            strFilterName.LoadString( i );

            // add to filter
            strFilter += strFilterName;

            strFilter += _T('\0');       // next string please
            strFilter += _T("*") + strFilterExt;
            strFilter += _T('\0');       // next string please

            dlgFile.m_pofn->nMaxCustFilter++;
        }
    }

    // get a list of GDI+ codecs (if available)

    Gdiplus::ImageCodecInfo *pCodecs = 0;
    UINT                     nCodecs = 0;

    if (bOpenFileDialog)
    {
        GetGdiplusDecoders(&nCodecs, &pCodecs);
    }
    else
    {
        GetGdiplusEncoders(&nCodecs, &pCodecs);
    }

    if (nCodecs && !bOnlyBmp)
    {
        delete [] m_guidFltType;
        m_guidFltType = new GUID[nCodecs];
        
        m_nFilters = 0;

        for (UINT i = 0; i < nCodecs; ++i)
        {
            if (pCodecs[i].FormatID != WiaImgFmt_BMP &&
                pCodecs[i].FormatID != WiaImgFmt_EMF &&
                pCodecs[i].FormatID != WiaImgFmt_WMF)  // GDI+ does not handle WMF/EMF well
            {
                m_guidFltType[m_nFilters++] = pCodecs[i].FormatID;

                strFilter += pCodecs[i].FormatDescription;
                strFilter += _T(" (");
                strFilter += pCodecs[i].FilenameExtension;
                strFilter += _T(')');
                strFilter += _T('\0');       // next string please
                strFilter += pCodecs[i].FilenameExtension;
                strFilter += _T('\0');       // next string please

                strAllPictureFiles += _T(';');
                strAllPictureFiles += pCodecs[i].FilenameExtension;

                dlgFile.m_pofn->nMaxCustFilter++;
            }
        }

        LocalFree(pCodecs);
    }
    else
    {
        //
        // get list of all installed filters and add those to the list...
        //

        delete [] m_guidFltType;
        m_guidFltType = new GUID[16]; // max # of filters

        TCHAR name[128];
        TCHAR ext[sizeof("jpg;*.jpeg") + 1];
        BOOL bImageAPI;

        for (int i=0, j=0; !bOnlyBmp && GetInstalledFilters(bOpenFileDialog,
            i, name, sizeof(name), ext, sizeof(ext), NULL, 0, bImageAPI); i++)
        {
            if (!bImageAPI)
            {
               continue;
            }
            if (ext[0] == 0 || name[0] == 0)
                continue;

            // if there are multiple extensions, take the first one...
            PTSTR pComma = _tcschr(ext, _T(','));
            
            if (pComma)
                *pComma = 0;

            PTSTR pSemiColon = _tcschr(ext, _T(';'));
            
            if (pSemiColon)
                *pSemiColon = 0;

            PTSTR pSpace = _tcschr(ext, _T(' '));
            
            if (pSpace)
                *pSpace = 0;

            if (lstrlen(ext) > 3)
                continue;

            // dont show these, we already handle these
            if (lstrcmpi(ext,_T("bmp")) == 0 ||
                lstrcmpi(ext,_T("dib")) == 0 ||
                lstrcmpi(ext,_T("rle")) == 0)
                continue;
            #ifndef GIF_SUPPORT
            if (lstrcmpi(ext, _T("gif") == 0)
            {
               continue;
            }

            #endif
#if 0 // only use known good filters
            if (!g_bShowAllFiles &&
                (GetKeyState(VK_SHIFT) & 0x8000) == 0 &&
                lstrcmpi(ext,_T("pcx")) != 0)
                continue;
#endif
            // save a list of available filter types
            if (lstrcmpi(ext,_T("gif")) == 0)
            {
               m_guidFltType[j++] = WiaImgFmt_GIF;
            }
            else if (lstrcmpi(ext,_T("jpg")) == 0)
            {
               m_guidFltType[j++] = WiaImgFmt_JPEG;
               _tcscat (ext, _T(";*.jpeg"));
            }
#ifdef SUPPORT_ALL_FILTERS
            else if (lstrcmpi(ext,_T("png")) == 0)
            {
#ifdef PNG_SUPPORT
               m_guidFltType[j++] = WiaImgFmt_PNG;
#else
               continue;
#endif // PNG_SUPPORT
            }

            else if (lstrcmpi(ext,_T("pcd")) == 0)
            {
               m_guidFltType[j++] = WiaImgFmt_PHOTOCD;
            }
            /*else if (lstrcmpi(ext,_T("pic")) == 0)
            {
               m_guidFltType[j++] = IFLT_PICT;
               _tcscat(ext, _T(";*.pict"));
            }
            else if (lstrcmpi(ext,_T("tga")) == 0)
            {
               m_iflFltType[j++] = IFLT_TGA;
            }*/
            else if (lstrcmpi(ext,_T("tif")) == 0)
            {
               m_guidFltType[j++] = WiaImgFmt_TIFF;
               _tcscat(ext, _T(";*.tiff"));
            }
            else
            {
               m_guidFltType[j++] = WiaImgFmt_UNDEFINED;
            }
#else
            else continue;
#endif


            // add to filter
            strFilter += name;
            strFilter += _T(" ( *.");
            strFilter += ext;
            strFilter += _T(" )");
            strFilter += _T('\0');       // next string please
            strFilter += _T("*.");
            strFilter += ext;
            strFilter += _T('\0');       // next string please

            strAllPictureFiles = strAllPictureFiles + _T(";*.")+ext;
            dlgFile.m_pofn->nMaxCustFilter++;
        }
    }

    if (!bOnlyBmp && bOpenFileDialog)
    {
        // append "All Picture Files" only if opening a file
        VERIFY(strFilterName.LoadString(IDS_TYPE_ALLPICTURES));
        strFilter+= strFilterName;
        strFilter += _T('\0');
        strFilter += strAllPictureFiles;
        strFilter += _T('\0');
        dlgFile.m_pofn->nMaxCustFilter++;

        if (m_nFilterInIdx == -1)
        {
            m_nFilterInIdx = dlgFile.m_pofn->nMaxCustFilter;
        }

       // append the  "*.*" filter only if "Open"ing a file
        VERIFY( strFilterName.LoadString( IDS_TYPE_ALLFILES ) );

        strFilter += strFilterName;
        strFilter += _T('\0');        // next string please
        strFilter += _T("*.*");
        strFilter += _T('\0');        // last string

        dlgFile.m_pofn->nMaxCustFilter++;

    }

    // prompt the user with the appropriate filter pre-selected
    if (bOpenFileDialog)
    {
       dlgFile.m_pofn->nFilterIndex = m_nFilterInIdx;
    }
    else
    {
       DWORD dwIndex;
       if (m_guidFltTypeUsed != WiaImgFmt_UNDEFINED &&
                        (dwIndex = GetFilterIndex(m_guidFltTypeUsed))) // has an export filter?
            dlgFile.m_pofn->nFilterIndex = dwIndex + 4; // skip the first 4 BMP types
        else if (m_nFilterOutIdx >= 4)
            dlgFile.m_pofn->nFilterIndex = m_nFilterOutIdx;
        else
            dlgFile.m_pofn->nFilterIndex = iColors + 1; // 1 based number

    }
    dlgFile.m_pofn->lpstrFilter = strFilter;
    dlgFile.m_pofn->hwndOwner   = AfxGetMainWnd()->GetSafeHwnd();
    dlgFile.m_pofn->hInstance   = AfxGetResourceHandle();
    dlgFile.m_pofn->lpstrTitle  = title;
    dlgFile.m_pofn->lpstrFile   = fileName.GetBuffer(_MAX_PATH);
    dlgFile.m_pofn->nMaxFile    = _MAX_PATH;
    TCHAR szInitPath[MAX_PATH];
    ::LoadString (GetModuleHandle (NULL), AFX_IDS_UNTITLED, szInitPath, MAX_PATH);
    //
    // Look in "My Documents" on NT 5, Win98, and later.
    //
    if (!theApp.GetLastFile() || !*(theApp.GetLastFile()))
    {
       static SHSPECPATH pfnSpecialPath = NULL;
       if (!pfnSpecialPath)
       {

          #ifdef UNICODE
          pfnSpecialPath = (SHSPECPATH)GetProcAddress (
                                           GetModuleHandle(_T("shell32.dll")),
                                           "SHGetSpecialFolderPathW");
          #else
          pfnSpecialPath = (SHSPECPATH)GetProcAddress (
                                           GetModuleHandle(_T("shell32.dll")),
                                           "SHGetSpecialFolderPathA");
          #endif //UNICODE

       }
       if (pfnSpecialPath)
       {
          (pfnSpecialPath)(NULL, szInitPath, CSIDL_MYPICTURES, FALSE);
          dlgFile.m_pofn->lpstrInitialDir = szInitPath;
       }

    }

    BOOL bRet = dlgFile.DoModal() == IDOK? TRUE : FALSE;
    fileName.ReleaseBuffer();

    // keep track of the filter selected by the user
    if (bOpenFileDialog)
        m_nFilterInIdx = dlgFile.m_pofn->nFilterIndex;
    else
        m_nFilterOutIdx = dlgFile.m_pofn->nFilterIndex;

    iColors = (int)dlgFile.m_pofn->nFilterIndex - 1;

    CString sExt = dlgFile.m_pofn->lpstrFile + dlgFile.m_pofn->nFileExtension;

#ifdef ICO_SUPPORT
    if (! bOpenFileDialog && dlgFile.m_pofn->nFileExtension)
        // did the user try to sneak a icon extension past us
        if (! sExt.CompareNoCase( ((const TCHAR *)strFilterExt) + 1 ))
            iColors = 5;
#endif

    return bRet;
    }

DWORD CPBApp::GetFilterIndex( REFGUID guidFltType )
{
    for (int i = 0; i < m_nFilters; i++)
        if (m_guidFltType[i] == guidFltType)
                        return i+1;

        return 0;
}

// fix the file extension based on export filter selected - used for save as

void CPBApp::FixExtension( CString& fileName, int iflFltType )
{
        CString sDfltExt;

        switch (iflFltType)
        {
                case IFLT_GIF:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_GIF ));
                        break;

                case IFLT_JPEG:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_JPEG ));
                        break;

                case IFLT_PCD:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_PCD ));
                        break;


                case IFLT_PCX:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_PCX ));
                        break;


                case IFLT_PICT:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_PICT ));
                        break;
#ifdef PNG_SUPPORT
                case IFLT_PNG:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_PNG ));
                        break;
#endif // PNG_SUPPORT
                case IFLT_TGA:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_TGA ));
                        break;

                case IFLT_TIFF:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_TIFF ));
                        break;

                case IFLT_UNKNOWN:      // unknown or unsupported file type
                default:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_BMP ));
                        break;
        }

        if (sDfltExt.CompareNoCase( GetExtension( (LPCTSTR)fileName ) ))
        {
                fileName = StripExtension( fileName ) + sDfltExt;
        }
}

#if 0
// Pulling self-registration out. This is to be done once during setup only

/***************************************************************************/

// Mostly stolen from MFC
// I made no attempt to strip out stuff I do not actually use
// I just modified this so it used short module file name
//

//////////////////////////////////////////////////////////////////////////////
// data for UpdateRegistry functionality

// %1 - class ID
// %2 - class name
// %3 - executable path
// %4 - short type name
// %5 - long type name
// %6 - long application name
// %7 - icon index

static const TCHAR sz00[] = TEXT("%2\0") TEXT("%5");
static const TCHAR sz01[] = TEXT("%2\\CLSID\0") TEXT("%1");
static const TCHAR sz02[] = TEXT("%2\\Insertable\0") TEXT("");
static const TCHAR sz03[] = TEXT("%2\\protocol\\StdFileEditing\\verb\\0\0") TEXT("&Edit");
static const TCHAR sz04[] = TEXT("%2\\protocol\\StdFileEditing\\server\0") TEXT("%3");
static const TCHAR sz05[] = TEXT("CLSID\\%1\0") TEXT("%5");
static const TCHAR sz06[] = TEXT("CLSID\\%1\\ProgID\0") TEXT("%2");
#ifndef _USRDLL
static const TCHAR sz07[] = TEXT("CLSID\\%1\\InprocHandler32\0") TEXT("ole32.dll");
static const TCHAR sz08[] = TEXT("CLSID\\%1\\LocalServer32\0") TEXT("%3");
#else
static const TCHAR sz07[] = TEXT("\0") TEXT("");
static const TCHAR sz08[] = TEXT("CLSID\\%1\\InProcServer32\0") TEXT("%3");
#endif
static const TCHAR sz09[] = TEXT("CLSID\\%1\\Verb\\0\0") TEXT("&Edit,0,2");
static const TCHAR sz10[] = TEXT("CLSID\\%1\\Verb\\1\0") TEXT("&Open,0,2");
static const TCHAR sz11[] = TEXT("CLSID\\%1\\Insertable\0") TEXT("");
static const TCHAR sz12[] = TEXT("CLSID\\%1\\AuxUserType\\2\0") TEXT("%4");
static const TCHAR sz13[] = TEXT("CLSID\\%1\\AuxUserType\\3\0") TEXT("%6");
static const TCHAR sz14[] = TEXT("CLSID\\%1\\DefaultIcon\0") TEXT("%3,%7");
static const TCHAR sz15[] = TEXT("CLSID\\%1\\MiscStatus\0") TEXT("32");

// registration for OAT_INPLACE_SERVER
static const LPCTSTR rglpszInPlaceRegister[] =
{
        sz00, sz02, sz03, sz05, sz09, sz10, sz11, sz12,
        sz13, sz15, NULL
};

// registration for OAT_SERVER
static const LPCTSTR rglpszServerRegister[] =
{
        sz00, sz02, sz03, sz05, sz09, sz11, sz12,
        sz13, sz15, NULL
};
// overwrite entries for OAT_SERVER & OAT_INPLACE_SERVER
static const LPCTSTR rglpszServerOverwrite[] =
{
        sz01, sz04, sz06, sz07, sz08, sz14, NULL
};

// registration for OAT_CONTAINER
static const LPCTSTR rglpszContainerRegister[] =
{
        sz00, sz05, NULL
};
// overwrite entries for OAT_CONTAINER
static const LPCTSTR rglpszContainerOverwrite[] =
{
        sz01, sz06, sz07, sz08, sz14, NULL
};

// registration for OAT_DISPATCH_OBJECT
static const LPCTSTR rglpszDispatchRegister[] =
{
        sz00, sz05, NULL
};
// overwrite entries for OAT_CONTAINER
static const LPCTSTR rglpszDispatchOverwrite[] =
{
        sz01, sz06, sz08, NULL
};

struct STANDARD_ENTRY
{
        const LPCTSTR* rglpszRegister;
        const LPCTSTR* rglpszOverwrite;
};

static const STANDARD_ENTRY rgStdEntries[] =
{
        { rglpszInPlaceRegister, rglpszServerOverwrite },
        { rglpszServerRegister, rglpszServerOverwrite },
        { rglpszContainerRegister, rglpszContainerOverwrite },
        { rglpszDispatchRegister, rglpszDispatchOverwrite }
};

/////////////////////////////////////////////////////////////////////////////
// Special registration for apps that wish not to use REGLOAD

BOOL AFXAPI PBOleRegisterServerClass(
        REFCLSID clsid, LPCTSTR lpszClassName,
        LPCTSTR lpszShortTypeName, LPCTSTR lpszLongTypeName,
        OLE_APPTYPE nAppType, LPCTSTR* rglpszRegister, LPCTSTR* rglpszOverwrite)
{
        ASSERT(AfxIsValidString(lpszClassName));
        ASSERT(AfxIsValidString(lpszShortTypeName));
        ASSERT(*lpszShortTypeName != 0);
        ASSERT(AfxIsValidString(lpszLongTypeName));
        ASSERT(*lpszLongTypeName != 0);
        ASSERT(nAppType == OAT_INPLACE_SERVER || nAppType == OAT_SERVER ||
                nAppType == OAT_CONTAINER || nAppType == OAT_DISPATCH_OBJECT);

        // use standard registration entries if non given
        if (rglpszRegister == NULL)
                rglpszRegister = (LPCTSTR*)rgStdEntries[nAppType].rglpszRegister;
        if (rglpszOverwrite == NULL)
                rglpszOverwrite = (LPCTSTR*)rgStdEntries[nAppType].rglpszOverwrite;

        LPTSTR rglpszSymbols[7];
                // 0 - class ID
                // 1 - class name
                // 2 - executable path
                // 3 - short type name
                // 4 - long type name
                // 5 - long application name
                // 6 - icon index

        // convert the CLSID to a string
        LPWSTR lpszClassID;
        ::StringFromCLSID(clsid, &lpszClassID);
        if (lpszClassID == NULL)
        {
                TRACE0("Warning: StringFromCLSID failed in AfxOleRegisterServerName --\n");
                TRACE0("\tperhaps AfxOleInit() has not been called.\n");
                return FALSE;
        }
        #ifdef UNICODE
        rglpszSymbols[0] = lpszClassID;
        #else
        int cc = WideCharToMultiByte (CP_ACP, 0, lpszClassID, -1,
                                      (LPSTR)&rglpszSymbols[0], 0,
                                      NULL, NULL);
        rglpszSymbols[0] = (LPSTR)new char[cc];
        WideCharToMultiByte (CP_ACP, 0, lpszClassID, -1,
                             rglpszSymbols[0], cc,
                             NULL, NULL);

        #endif // UNICODE
        rglpszSymbols[1] = (LPTSTR)lpszClassName;

        // get path name to server
        TCHAR szPathName[_MAX_PATH];
        LPTSTR pszTemp = szPathName;
        ::GetShortModuleFileName(AfxGetInstanceHandle(), pszTemp, _MAX_PATH);
        rglpszSymbols[2] = szPathName;

        // fill in rest of symbols
        rglpszSymbols[3] = (LPTSTR)lpszShortTypeName;
        rglpszSymbols[4] = (LPTSTR)lpszLongTypeName;
        rglpszSymbols[5] = (LPTSTR)AfxGetAppName(); // will usually be long, readable name

        LPCTSTR lpszIconIndex;
        HICON hIcon = ExtractIcon(AfxGetInstanceHandle(), szPathName, 1);
        if (hIcon != NULL)
        {
                lpszIconIndex = TEXT("1");
                DestroyIcon(hIcon);
        }
        else
        {
                lpszIconIndex = TEXT("0");
        }
        rglpszSymbols[6] = (LPTSTR)lpszIconIndex;

        // update the registry with helper function
        BOOL bResult;
        bResult = AfxOleRegisterHelper(rglpszRegister, (LPCTSTR*)rglpszSymbols, 7, FALSE);
        if (bResult && rglpszOverwrite != NULL)
                bResult = AfxOleRegisterHelper(rglpszOverwrite, (LPCTSTR*)rglpszSymbols, 7, TRUE);

        // free memory for class ID
        ASSERT(lpszClassID != NULL);
        AfxFreeTaskMem(lpszClassID);
        #ifndef UNICODE
        delete[](LPSTR)rglpszSymbols[0];
        #endif
        return bResult;
}

void CPBTemplateServer::UpdateRegistry(OLE_APPTYPE nAppType,
        LPCTSTR* rglpszRegister, LPCTSTR* rglpszOverwrite)
{
        ASSERT(m_pDocTemplate != NULL);

        // get registration info from doc template string
        CString strServerName;
        CString strLocalServerName;
        CString strLocalShortName;

        if (!m_pDocTemplate->GetDocString(strServerName,
           CDocTemplate::regFileTypeId) || strServerName.IsEmpty())
        {
                TRACE0("Error: not enough information in DocTemplate to register OLE server.\n");
                return;
        }
        if (!m_pDocTemplate->GetDocString(strLocalServerName,
           CDocTemplate::regFileTypeName))
                strLocalServerName = strServerName;     // use non-localized name
        if (!m_pDocTemplate->GetDocString(strLocalShortName,
                CDocTemplate::fileNewName))
                strLocalShortName = strLocalServerName; // use long name

        ASSERT(strServerName.Find(TEXT(' ')) == -1);  // no spaces allowed

        // place entries in system registry
        if (!PBOleRegisterServerClass(m_clsid, strServerName, strLocalShortName,
                strLocalServerName, nAppType, rglpszRegister, rglpszOverwrite))
        {
                // not fatal (don't fail just warn)
                TRACE0("mspaint: Unable to register server class.\n");
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pgsetup.h ===
#ifndef _PGSETUP_H_
#define _PGSETUP_H_

/***************************************************************************/

class CPageSetupData
{
public:
    VOID UpdateControls(HWND hDlg);
    static VOID UpdateValue(HWND hDlg, int nIDDlgItem, UINT *pnResult);
    VOID CalculateImageRect(const CSize &PhysicalPageSize, CPoint &PhysicalOrigin, CSize &PhysicalImageSize);

    static UINT_PTR APIENTRY PageSetupHook(HWND, UINT, WPARAM, LPARAM);
    static UINT_PTR APIENTRY PagePaintHook(HWND, UINT, WPARAM, LPARAM);

public:
    BOOL bCenterHorizontally;
    BOOL bCenterVertically;
    BOOL bScaleFitTo;
    UINT nAdjustToPercent;
    UINT nFitToPagesWide;
    UINT nFitToPagesTall;

    double fPhysicalImageWidth;
    double fPhysicalImageHeight;
};

#endif //_PGSETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pictures.h ===
// pictures.h : this is the header file for the picture object
//

#ifndef __PICTURES_H__
#define __PICTURES_H__

/****************************************************************************/

class CPic : public CDC
    {
    public:

    DECLARE_DYNAMIC( CPic )

    protected:

    CBitmap     mBitmap;
    CBitmap     mMask;
    HBITMAP     mhBitmapOld;
    CSize       mSize;
    int         miCnt;
    BOOL        mbReady;

    public:

                CPic();
               ~CPic();

    BOOL        PictureSet(LPCTSTR lpszResourceName, int iCnt=1 );
    BOOL        PictureSet(UINT nIDResource, int iCnt=1 );
    void        Picture( CDC* pDC, int iX, int iY, int iPic=0 );
    CSize       PictureSize() { return mSize; }

    private:

    BOOL        InstallPicture();

    };

/****************************************************************************/

#endif // __PICTURES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\printres.h ===
// printres.h : interface of the Cprintres class
//

#define MARGINS_UNITS 2540 // Store hundredths of MM
#define MARGINS_DEFAULT (MARGINS_UNITS * 3/4) // 3/4 inch default margins

class CImgWnd;

/***************************************************************************/

class CPrintResObj : public CObject
{
    DECLARE_DYNAMIC( CPrintResObj )

    public:

    CPrintResObj( CPBView* pView, CPrintInfo* pInfo );
    ~CPrintResObj();

    void BeginPrinting( CDC* pDC, CPrintInfo* pInfo );
    void PrepareDC    ( CDC* pDC, CPrintInfo* pInfo );
    BOOL PrintPage    ( CDC* pDC, CPrintInfo* pInfo );
    void EndPrinting  ( CDC* pDC, CPrintInfo* pInfo );

    // Attributes

    CPBView*  m_pView;
    LPVOID    m_pDIB;
    LPVOID    m_pDIBits;
    int       m_iZoom;
    CPalette* m_pDIBpalette;
    CSize     m_cSizeScroll;
    int       m_iPicWidth;
    int       m_iPicHeight;
    CRect     m_rtMargins;
    CPoint    m_PhysicalOrigin;
    CSize     m_PhysicalScaledImageSize;
    CSize     m_PhysicalPageSize;
    int       m_nPagesWide;
};

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mspaint.rc
//
#define ID_EBOX_POPUPMENU_POS           0
#define ID_TOOL_POPUPMENU_POS           1
#define ID_MAINFRAME                    2
#define IDI_PAINT_DOC                   3
#define IDR_SRVR_INPLACE                4
#define IDR_SRVR_EMBEDDED               5
#define IDS_EXTENSION_BMP               6
#define IDS_EXTENSION_GIF               7
#define IDS_EXTENSION_JPEG              8
#define IDS_EXTENSION_ICO               9
#define IDS_EXTENSION_PCX               10
#define IDS_PCX_FILTER_NAME             11
#define IDS_ICO_FILTER_NAME             12
#define IDS_BMP_MONO                    13
#define IDS_BMP_16COLOR                 14
#define IDS_BMP_256COLOR                15
#define IDS_BMP_TRUECOLOR               16
#define IDS_EXTENSION_PCD               17
#define IDS_EXTENSION_PICT              18
#define IDS_TYPE_ALLFILES               19
#define IDS_PAL_FILETYPES               20
#define IDS_EXTENSION_PNG               21
#define IDS_EXTENSION_TGA               22
#define IDS_EXTENSION_TIFF              23
#define IDS_EXTENSION_PAL               24
#define IDS_PAL_UNTITLED                25
#define IDC_DITHER                      27
#define IDS_EXTENSION_DIB               28
#define IDS_EXTENSION_RLE               29
#define IDP_OLE_INIT_FAILED             30
#define ID_LISTCAPTION                  31
#define ID_LIST                         32
#define IDS_TYPE_ALLPICTURES            33
#define IDD_TEXT_FONT_DLG               37
#define IDB_TEXT_TBAR                   102
#define IDC_POINTSIZE                   103
#define IDC_TYPEFACE                    104
#define IDD_IMAGE_ATTRIBUTES            105
#define IDC_BOLD                        106
#define FONT_TT_BMP                     107
#define IDD_VIEW_ZOOM                   108
#define IDC_ITALIC                      109
#define ID_TEXT_PLACE                   110
#define FONT_PRN_BMP                    111
#define IDD_FLIP_ROTATE                 112
#define IDC_UNDERLINE                   112
#define IDC_SHADOW                      113
#define IDD_STRETCH_SKEW                113
#define IDR_TEXT_POPUP                  113
#define IDI_STRETCH_HORZ                114
#define IDC_ATTREDIT                    114
#define IDI_STRETCH_VERT                115
#define IDI_SKEW_HORZ                   116
#define IDI_SKEW_VERT                   117
#define IDR_SELECTION_POPUP             118
#define IDR_THUMBNAIL_POPUP             119
#define IDC_PENEXT                      120
#define IDC_EDITTEXT                    121
#define IDC_KEYBOARD                    122
#define IDC_INS_SPACE                   123
#define IDC_BACKSPACE                   124
#define IDC_NEWLINE                     125
#define IDR_PBRUSHTYPE                  129
#define IDD_COLORTABLE                  132
#define IDD_PAGESETUPDLG                133
#define IDBM_COMPWELL                   134
#define IDC_HSPLIT                      135
#define IDC_VERTEDIT                    136
#define TT_OPENTYPE_BMP                 137
#define PS_OPENTYPE_BMP                 138
#define TYPE1_BMP                       139
#define IDC_CHARSET                     140
#define STRINGARRAYSIZE                 240
#define IDC_WIDTH                       264
#define IDC_HEIGHT                      266
#define IDC_DEFAULT                     280
#define IDC_3STATE                      293
#define IDMB_ARROW                      599
#define IDMB_PICKTOOL                   620
#define IDMB_PICKRGNTOOL                621
#define IDMX_TEXTTOOL                   622
#define IDMB_FILLTOOL                   623
#define IDMB_LINETOOL                   624
#define IDMB_AIRBSHTOOL                 627
#define IDMB_CURVETOOL                  628
#define IDMB_POLYGONTOOL                632
#define IDMB_RNDRECTTOOL                634
#define IDMB_FRNDRECTTOOL               635
#define IDMB_PENCILTOOL                 636
#define IDMB_ERASERTOOL                 637
#define IDMB_ZOOMTOOL                   638
#define IDMY_PICKCOLOR                  639
#define IDMB_CBRUSHTOOL                 640
#define IDMB_RECTTOOL                   641
#define IDMB_FRECTTOOL                  642
#define IDMB_ELLIPSETOOL                643
#define IDMB_FELLIPSETOOL               644
#define IDMB_USERBTN                    700
#define IDC_CMDMESSAGE_CAP              722
#define IDC_TILEGRID                    727
#define IDC_PIXELGRID                   728
#define IDB_ELLIPSE1                    851
#define IDB_ELLIPSE2                    852
#define IDB_ELLIPSE3                    853
#define IDB_ELLIPSE4                    854
#define IDB_ELLIPSE5                    855
#define IDB_ELLIPSE6                    856
#define IDB_ELLIPSE7                    857
#define IDB_ELLIPSE8                    858
#define IDB_IMGTOOLS                    859
#define IDB_MAINTOOLS                   860
#define IDB_ZOOMOPT                     862
#define IDB_SELOPT                      863
#define IDB_AIROPT                      864
#define IDS_UNABLE_TO_PASTE             1000
#define IDC_STRETCH_HORZ_PERCENT        1019
#define IDC_STRETCH_VERT_PERCENT        1020
#define IDC_SKEW_HORZ_DEGREES           1021
#define IDC_SKEW_VERT_DEGREES           1022
#define IDC_INCHES                      1028
#define IDC_CENTIMETERS                 1029
#define IDC_PIXELS                      1030
#define IDC_WIDTH_STATIC                1050
#define IDC_HEIGHT_STATIC               1051
#define IDC_UNITS_GROUP                 1052
#define IDC_COLORS_GROUP                1053
#define IDC_PAINT_FLIP_GROUP            1054
#define IDC_STRETCH_HORZ_ICON           1055
#define IDC_STRETCH_VERT_ICON           1056
#define IDC_SKEW_HORZ_ICON              1057
#define IDC_SKEW_VERT_ICON              1058
#define IDC_SKEW_GROUP                  1059
#define IDC_STRETCH_GROUP               1060
#define IDC_STRETCH_HORZ_SUFFIX         1061
#define IDC_STRETCH_VERT_SUFFIX         1062
#define IDC_SKEW_HORZ_SUFFIX            1063
#define IDC_SKEW_VERT_SUFFIX            1064
#define IDC_CURRENT_ZOOM_STATIC         1065
#define IDC_ZOOM_GROUP                  1066
#define IDC_TRANS_GROUP                 1067
#define IDC_USE_TRANS                   1068
#define IDC_SELECT_COLOR                1069
#define IDC_TRANS_PAINT                 1070
#define IDC_FILEDATE_STATIC             1071
#define IDC_FILESIZE_STATIC             1072
#define IDC_RESOLUTION_STATIC           1073
#define IDC_MONOCHROME                  1079
#define IDC_COLORS                      1080
#define IDC_CURRENT_ZOOM                1081
#define IDC_ZOOM_100                    1082
#define IDC_ZOOM_200                    1083
#define IDC_ZOOM_400                    1084
#define IDC_ZOOM_600                    1085
#define IDC_ZOOM_800                    1086
#define IDC_HORIZONTAL                  1087
#define IDC_VERTICAL                    1088
#define IDC_BY_ANGLE                    1089
#define IDC_90_DEG                      1090
#define IDC_180_DEG                     1091
#define IDC_270_DEG                     1092
#define IDC_STRETCH_HORZ                1093
#define IDC_STRETCH_VERT                1094
#define IDC_SKEW_HORZ                   1095
#define IDC_SKEW_VERT                   1096
#define IDC_COLORLIST                   1099
#define IDC_DRAGTOOL                    1100
#define IDC_BRUSH                       1201
#define IDC_BULLSEYE                    1202
#define IDC_CROSSHAIR                   1203
#define IDC_EYEDROP                     1204
#define IDC_FLOOD                       1205
#define IDC_PENCIL                      1206
#define IDC_ZOOMIN                      1207
#define IDC_CENTER                      1210
#define IDC_HORIZONTALLY                1211
#define IDC_VERTICALLY                  1212
#define IDC_SCALING                     1213
#define IDC_ADJUST_TO                   1214
#define IDC_FIT_TO                      1215
#define IDC_PERCENT_NORMAL_SIZE         1216
#define IDC_STR_PERCENT_NORMAL_SIZE     1217
#define IDC_PAGES_WIDE                  1218
#define IDC_STR_PAGES_WIDE              1219
#define IDC_PAGES_TALL                  1220
#define IDC_STR_PAGES_TALL              1221
#define IDS_ERROR_OPEN                  2051
#define IDS_ERROR_READLOAD              2052
#define IDS_ERROR_SAVERO                2054
#define IDS_ERROR_COMPEX                2056
#define IDS_ERROR_RCPROB                2062
#define IDS_ERROR_WHAAAT                2064
#define IDS_ERROR_SAVEOVEROPEN          2067
#define IDS_ERROR_NOTVALID_RC           2080
#define IDS_ERROR_NOTVALID_EXE          2081
#define IDS_ERROR_NOTVALID_RES          2082
#define IDS_ERROR_NOTVALID_BMP          2083
#define IDS_ERROR_NOTVALID_ICO          2084
#define IDS_ERROR_NOTVALID_CUR          2085
#define IDS_ERROR_SAVE_ABORTED          2090
#define IDS_ERROR_NT_RES                2091
#define IDS_ERROR_CANT_SAVERO           2092
#define IDS_ERROR_EXE_INUSE             2096
#define IDS_ERROR_EXE_EMPTY             2097
#define IDS_ERROR_EXE_HDR               2100
#define IDS_ERROR_EXE_HDRMZ             2102
#define IDS_ERROR_EXE_HDRWV             2104
#define IDS_ERROR_EXE_HDRNW             2105
#define IDS_ERROR_EXE_SAVE              2106
#define IDS_ERROR_EXE_ALIGN             2107
#define IDS_ERROR_EXE_ALLOC             2108
#define IDS_ERROR_RES_SAVE              2109
#define IDS_ERROR_SAVE                  2110
#define IDS_ERROR_SAMENAME              2152
#define IDS_ERROR_GRIDRANGE             2210
#define IDS_ERROR_NOMEMORY              2240
#define IDS_ERROR_LOWMEMORY             2241
#define IDS_ERROR_GROUP                 2247
#define IDS_ERROR_PRINTING              2248
#define IDS_WARNING_COLORSAVE           2297
#define IDS_WARNING_MONO                2298
#define IDS_ERROR_BITMAPSIZE            2299
#define IDS_ERROR_FILE                  2300
#define IDS_ERROR_CLIPBOARD             2445
#define IDS_ERROR_NOPRINTER             2446
#define IDS_ERROR_SELECT_SCAN           2447
#define IDS_ERROR_SCAN_NEW              2448
#define IDS_DOWNLOAD_IMAGE              2449
#define IDS_STATUS_TRANSFER_FROM_DEVICE 2450
#define IDS_STATUS_PROCESSING_DATA      2451
#define IDS_STATUS_TRANSFER_TO_CLIENT   2452
#define IDB_SBSIZE                      3550
#define IDB_SBPOS                       3551
#define IDD_IMGGRIDOPT                  4001
#define IDD_GETPALETTE                  4007
#define IDS_UNDO                        4013
#define IDS_REDO                        4014
#define IDMX_SMALLERBRUSH               6810
#define IDMX_LARGERBRUSH                6811
#define IDMZ_BRUSHTOOL                  6816
#define IDMX_SEL2BSH                    6861
#define IDM_TGLOPAQUE                   6868
#define IDM_EDITCOLORS                  6869
#define IDM_LOADCOLORS                  6870
#define IDM_SAVECOLORS                  6871
#define IDS_MUST_SAVE_WALLPAPER         7057
#define IDMX_VS_PAGEDOWN                8000
#define IDMX_HS_PAGEDOWN                8001
#define IDMX_VS_PAGEUP                  8002
#define IDMX_HS_PAGEUP                  8003
#define IDCUR_MOVE                      8012
#define IDBM_DRAGHANDLE                 8021
#define IDBM_DRAGHANDLE2                8022
#define IDB_EMPTYPALETTE                8023
#define IDB_BUTTONBAR                   8024
#define IDCUR_SIZENWSE                  8025
#define IDCUR_SIZENESW                  8026
#define IDCUR_SIZEWE                    8027
#define IDCUR_SIZENS                    8028
#define IDCUR_AIRBRUSH                  8029
#define IDCUR_HIBEAM                    8030
#define IDS_ENLAGEBITMAPFORSTRETCH      9233
#define IDS_ENLAGEBITMAPFORCLIP         9234
#define IDC_EDIT                        9235
#define IDC_ADJUST                      9236
#define IDC_REDUCE                      9237
#define IDC_RED                         9238
#define IDC_GREEN                       9239
#define IDC_BLUE                        9240
#define IDC_HUE                         9241
#define IDC_SAT                         9242
#define IDC_LUM                         9243
#define IDD_COLORMAKER                  9244
#define IDC_RAINBOW                     9245
#define IDC_LUMSCROLL                   9246
#define IDC_CURRENT                     9247
#define IDS_ERROR_BOGUSFILE             10015
#define ID_WND_GRAPHIC                  32514
#define ID_TEXT_PLAIN                   32776
#define ID_TEXT_BOLD                    32777
#define ID_TEXT_ITALIC                  32778
#define ID_TEXT_SELECTFONT              32780
#define ID_TEXT_SELECTPOINTSIZE         32781
#define ID_TEXT_UNDERLINE               32789
#define ID_TOOLBAR_SHOWTOOLTIPS         32791
#define ID_TOOLBAR_HELP                 32792
#define ID_FILE_CHOOSE_PRINTER          37661
#define ID_FILE_SEND                    37662
#define ID_EDIT_COPY_TO                 37663
#define ID_EDIT_PASTE_FROM              37664
#define ID_FILE_SELECT_SOURCE           37665
#define ID_FILE_SCAN_NEW                37666
#define ID_VIEW_ZOOM_100                37670
#define ID_VIEW_ZOOM_400                37671
#define ID_VIEW_ZOOM                    37672
#define ID_VIEW_VIEW_PICTURE            37673
#define ID_VIEW_THUMBNAIL               37676
#define ID_VIEW_GRID                    37677
#define ID_VIEW_TEXT_TOOLBAR            37678
#define ID_IMAGE_FLIP_ROTATE            37680
#define ID_IMAGE_STRETCH_SKEW           37681
#define ID_IMAGE_INVERT_COLORS          37682
#define ID_IMAGE_ATTRIBUTES             37683
#define ID_IMAGE_CLEAR_IMAGE            37684
#define IDS_ERROR_FONTSIZENUMERIC       37685
#define IDS_FILEMENUHELP                37686
#define IDS_EDITMENUHELP                37687
#define IDS_VIEWMENUHELP                37688
#define IDS_IMAGEMENUHELP               37689
#define IDS_OPTIONSMENUHELP             37690
#define IDS_HELPMENUHELP                37691
#define IDS_ERROR_EXPORT                41747
#define IDS_ERROR_CANTREMOVE            41748
#define IDS_LOAD_PALETTE_COLORS         41749
#define IDS_QUERY_MKDIR                 41750
#define IDS_SAVE_PALETTE_COLORS         41750
#define IDS_EDIT_COLORS                 41751
#define IDS_EDIT_COPY_TO                41752
#define IDS_EDIT_PASTE_FROM             41753
#define IDS_SELECT_COLOR                41754
#define IDS_FILEDATE_NA                 41755
#define IDS_FILESIZE_NA                 41756
#define IDS_FILEDATE                    41757
#define IDS_FILESIZE                    41758
#define IDS_RESOLUTION_NA               41759
#define IDS_RESOLUTION                  41760
#define IDS_UNDO_PAINTING               42047
#define IDCS_BITMAP                     44036
#define IDS_COLORS                      44108
#define IDS_FONT_TOOL                   44109
#define IDS_VIEW                        44111
#define IDS_PAINT_TOOL                  44112
#define IDS_PerContractSoDontChange     44227
#define IDS_PerContractSoDontChange2    44228
#define IDS_SIZE_SEPARATOR              44700
#define IDS_POS_SEPARATOR               44701
#define ID_FILE_SETASWALLPAPER_C        57675
#define ID_FILE_SETASWALLPAPER_T        57677
#define ID_SELECTION_SENDTO             57683
#define ID_SELECTION_PRINTTO            57684
#define ID_THUMBNAIL_THUMBNAIL          57689
#define ID_THUMBNAIL_HELP               57690
#define IDS_REGISTRY_PATH               57691
#define ID_ESCAPE                       57692
#define ID_ESCAPE_SERVER                57693
#define ID_VIEW_TOOL_BOX                59415
#define ID_VIEW_COLOR_BOX               59416
#define IDS_ERROR_DBCSFONTONLY          59417
#define IDS_PAINTBRUSHPICTURE           59418
#define IDS_BITMAPIMAGE                 59419
#define IDS_HOTKEY_EDIT                 59420
#define IDS_HOTKEY_OPEN                 59421
#define IDS_FORMATERR_FILE              59500
#define IDS_FORMATERR_NOFILE            59501

#define ID_STATIC                       -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        142
#define _APS_NEXT_COMMAND_VALUE         59502
#define _APS_NEXT_CONTROL_VALUE         1074
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\printres.cpp ===
// printres.cpp : implementation of the CPrintResObj class
//
// #define PAGESETUP

#include "stdafx.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "pbrusdoc.h"
#include "imgwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "printres.h"
#include "cmpmsg.h"
#include "imageatt.h"
#include "pgsetup.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CPrintResObj, CObject )

#include "memtrace.h"

void MulDivRect(LPRECT r1, LPRECT r2, int num, int div)
{
        r1->left = MulDiv(r2->left, num, div);
        r1->top = MulDiv(r2->top, num, div);
        r1->right = MulDiv(r2->right, num, div);
        r1->bottom = MulDiv(r2->bottom, num, div);
}

/***************************************************************************/
// CPrintResObj implementation

CPrintResObj::CPrintResObj( CPBView* pView, CPrintInfo* pInfo )
{
    m_pDIB        = NULL;
    m_pDIBpalette = NULL;

    if (pInfo                                  == NULL
    ||  pView                                  == NULL
    ||  pView->m_pImgWnd                       == NULL
    ||  pView->m_pImgWnd->m_pImg               == NULL
    ||  pView->m_pImgWnd->m_pImg->m_pBitmapObj == NULL)
        return;

    m_pView = pView;

    m_iPicWidth  = m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_nWidth;
    m_iPicHeight = m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_nHeight;

    //  force the resource to save itself then use the dib to print
    BOOL bOldFlag = m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_bDirty;
    m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_bDirty = TRUE;
    m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->SaveResource( TRUE );
    m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_bDirty = bOldFlag;

    m_pDIB = GlobalLock(m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_hThing);

    if (m_pDIB == NULL)
        return;

    m_pDIBpalette = CreateDIBPalette( (LPSTR)m_pDIB );
    m_pDIBits     = FindDIBBits     ( (LPSTR)m_pDIB );

    // save the scroll value off, then set to 0,0
    m_cSizeScroll = m_pView->m_pImgWnd->GetScrollPos();

    // save the zoom value off, then set to 100%
    m_iZoom      = m_pView->m_pImgWnd->GetZoom();
    m_rtMargins.SetRectEmpty();

    pInfo->m_nNumPreviewPages = 1;
    pInfo->m_lpUserData       = this;
}

/***************************************************************************/

CPrintResObj::~CPrintResObj()
{
    GlobalUnlock(m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_hThing);
}

/***************************************************************************/

void CPrintResObj::BeginPrinting( CDC* pDC, CPrintInfo* pInfo )
{
    if (pDC               == NULL
    ||  pDC->GetSafeHdc() == NULL)
        return;

    m_pView->m_pImgWnd->SetScroll( 0, 0 );
    m_pView->m_pImgWnd->SetZoom  ( 1 );

    // get device sizes

    int nHorzRes = pDC->GetDeviceCaps(HORZRES);
    int nVertRes = pDC->GetDeviceCaps(VERTRES);

    int nHorzSize = pDC->GetDeviceCaps(HORZSIZE);
    int nVertSize = pDC->GetDeviceCaps(VERTSIZE);

    int nPhysicalWidth = pDC->GetDeviceCaps(PHYSICALWIDTH);
    int nPhysicalHeight = pDC->GetDeviceCaps(PHYSICALHEIGHT);

    int nPhysicalOffsetX = pDC->GetDeviceCaps(PHYSICALOFFSETX);
    int nPhysicalOffsetY = pDC->GetDeviceCaps(PHYSICALOFFSETY);

    // calculate min margins in pixels

    double cOutputXPelsPerMeter = (double) nHorzRes * 1000 / nHorzSize;
    double cOutputYPelsPerMeter = (double) nVertRes * 1000 / nVertSize;

    CRect rcMinMargins;

    rcMinMargins.left   = nPhysicalOffsetX;
    rcMinMargins.top    = nPhysicalOffsetY;
    rcMinMargins.right  = nPhysicalWidth  - nHorzRes - nPhysicalOffsetX;
    rcMinMargins.bottom = nPhysicalHeight - nVertRes - nPhysicalOffsetY;

    m_rtMargins.left   = max(0, (LONG) (theApp.m_rectMargins.left * cOutputXPelsPerMeter / 100000)   - rcMinMargins.left  );
    m_rtMargins.top    = max(0, (LONG) (theApp.m_rectMargins.top * cOutputYPelsPerMeter / 100000)    - rcMinMargins.top   );
    m_rtMargins.right  = max(0, (LONG) (theApp.m_rectMargins.right * cOutputXPelsPerMeter / 100000)  - rcMinMargins.right );
    m_rtMargins.bottom = max(0, (LONG) (theApp.m_rectMargins.bottom * cOutputYPelsPerMeter / 100000) - rcMinMargins.bottom);

    // Quick sanity check

    if (m_rtMargins.left + m_rtMargins.right >= nHorzRes)
    {
        m_rtMargins.left = m_rtMargins.right = 0;
    }

    if (m_rtMargins.top + m_rtMargins.bottom >= nVertRes)
    {
        m_rtMargins.top = m_rtMargins.bottom = 0;
    }

    CPageSetupData PageSetupData;

    PageSetupData.bCenterHorizontally = theApp.m_bCenterHorizontally;
    PageSetupData.bCenterVertically   = theApp.m_bCenterVertically;
    PageSetupData.bScaleFitTo         = theApp.m_bScaleFitTo;
    PageSetupData.nAdjustToPercent    = theApp.m_nAdjustToPercent;
    PageSetupData.nFitToPagesWide     = theApp.m_nFitToPagesWide;
    PageSetupData.nFitToPagesTall     = theApp.m_nFitToPagesTall;

    double cInputXPelsPerMeter = m_pView->m_pImgWnd->m_pImg->cXPelsPerMeter ? 
        m_pView->m_pImgWnd->m_pImg->cXPelsPerMeter : theApp.ScreenDeviceInfo.ixPelsPerDM * 10;

    double cInputYPelsPerMeter = m_pView->m_pImgWnd->m_pImg->cYPelsPerMeter ? 
        m_pView->m_pImgWnd->m_pImg->cYPelsPerMeter : theApp.ScreenDeviceInfo.iyPelsPerDM * 10;

    PageSetupData.fPhysicalImageWidth  = (double) m_iPicWidth * cOutputXPelsPerMeter / cInputXPelsPerMeter;
    PageSetupData.fPhysicalImageHeight = (double) m_iPicHeight * cOutputYPelsPerMeter / cInputYPelsPerMeter;

    m_PhysicalPageSize.cx = pDC->GetDeviceCaps(HORZRES) - m_rtMargins.left - m_rtMargins.right;
    m_PhysicalPageSize.cy = pDC->GetDeviceCaps(VERTRES) - m_rtMargins.top - m_rtMargins.bottom;

    PageSetupData.CalculateImageRect(m_PhysicalPageSize, m_PhysicalOrigin, m_PhysicalScaledImageSize);

    m_nPagesWide = PageSetupData.nFitToPagesWide;

    int nPages = PageSetupData.nFitToPagesWide * PageSetupData.nFitToPagesTall;

    pInfo->SetMaxPage(nPages);

    // If only printing 1 page, should not be in 2 page mode
    if (nPages == 1)
    {
        pInfo->m_nNumPreviewPages = 1;
    }
}

/******************************************************************************/
/* We not only move the window origin to allow us to print multiple pages      */
/* wide but we also scale both the viewport and window extents to make them   */
/* proportional (i.e. a line on the screen is the same size as on             */
/* the printer). The pages to print are numbered across.  For      +---+---+  */
/* example, if there  were 4 pages to print, then the first row    | 1 | 2 |  */
/* would have pages 1,2 and the second row would  have pages 3,4.  +---+---+  */
/*                                                                 | 3 | 4 |  */
/*                                                                 +---+---+  */
/*                                                                            */
/******************************************************************************/

void CPrintResObj::PrepareDC( CDC* pDC, CPrintInfo* pInfo )
{
    if (pDC == NULL || pInfo == NULL)
        return;

    pDC->SetMapMode( MM_TEXT );
    pDC->SetStretchBltMode( HALFTONE );
}

/***************************************************************************/

BOOL CPrintResObj::PrintPage( CDC* pDC, CPrintInfo* pInfo )
{
    if (m_pDIB == NULL)
        return FALSE;

    int nPageCol = (pInfo->m_nCurPage - 1) % m_nPagesWide;
    int nPageRow = (pInfo->m_nCurPage - 1) / m_nPagesWide;

    int nX0 = m_PhysicalOrigin.x - nPageCol * m_PhysicalPageSize.cx;
    int nY0 = m_PhysicalOrigin.y - nPageRow * m_PhysicalPageSize.cy;

    CRect OutputImageRect;

    OutputImageRect.left   = max(nX0, 0);
    OutputImageRect.top    = max(nY0, 0);
    OutputImageRect.right  = min(nX0 + m_PhysicalScaledImageSize.cx, m_PhysicalPageSize.cx);
    OutputImageRect.bottom = min(nY0 + m_PhysicalScaledImageSize.cy, m_PhysicalPageSize.cy);

    if (OutputImageRect.right < 0 || OutputImageRect.bottom < 0)
    {
        return TRUE;
    }

    CRect InputImageRect;

    InputImageRect.left   = MulDiv(OutputImageRect.left - nX0,   m_iPicWidth,  m_PhysicalScaledImageSize.cx);
    InputImageRect.top    = MulDiv(OutputImageRect.top - nY0,    m_iPicHeight, m_PhysicalScaledImageSize.cy);
    InputImageRect.right  = MulDiv(OutputImageRect.right - nX0,  m_iPicWidth,  m_PhysicalScaledImageSize.cx);
    InputImageRect.bottom = MulDiv(OutputImageRect.bottom - nY0, m_iPicHeight, m_PhysicalScaledImageSize.cy);

    if (InputImageRect.right < 0 || InputImageRect.bottom < 0)
    {
        return TRUE;
    }

    CPalette* ppalOld = NULL;

    if (m_pDIBpalette != NULL)
    {
        ppalOld = pDC->SelectPalette( m_pDIBpalette, FALSE );
        pDC->RealizePalette();
    }

    int nResult = StretchDIBits(
        pDC->m_hDC, 
        m_rtMargins.left + OutputImageRect.left, 
        m_rtMargins.top + OutputImageRect.top,
        OutputImageRect.Width(), 
        OutputImageRect.Height(),
        InputImageRect.left, 
        m_iPicHeight - InputImageRect.bottom, // DIB's are upside down
        InputImageRect.Width(), 
        InputImageRect.Height(),
        m_pDIBits, (LPBITMAPINFO)m_pDIB, 
        DIB_RGB_COLORS, SRCCOPY
    );

    if (nResult == GDI_ERROR)
    {
        CmpMessageBox( IDS_ERROR_PRINTING, AFX_IDS_APP_TITLE, MB_OK | MB_ICONEXCLAMATION );
    }

    if (ppalOld != NULL)
    {
        pDC->SelectPalette( ppalOld, FALSE );
    }

    return TRUE;
}

/***************************************************************************/

void CPrintResObj::EndPrinting( CDC* pDC, CPrintInfo* pInfo )
{
    if (pDC != NULL)
    {
        m_pView->m_pImgWnd->SetScroll( m_cSizeScroll.cx, m_cSizeScroll.cy );

        // restore the zoom value
        m_pView->m_pImgWnd->SetZoom( m_iZoom );
    }

    if (m_pDIBpalette != NULL)
        delete m_pDIBpalette;

    delete this;
}

/***************************************************************************/

inline int roundleast(int n)
{
        int mod = n%10;
        n -= mod;
        if (mod >= 5)
                n += 10;
        else if (mod <= -5)
                n -= 10;
        return n;
}

static void RoundRect(LPRECT r1)
{
        r1->left = roundleast(r1->left);
        r1->right = roundleast(r1->right);
        r1->top = roundleast(r1->top);
        r1->bottom = roundleast(r1->bottom);
}

void CPBView::OnFilePageSetup()
{
    CPageSetupDialog dlg;
    PAGESETUPDLG& psd = dlg.m_psd;
    TCHAR szMetric[2];
    BOOL bMetric;
    LCID lcidThread;
    //
    // We should use metric if the user has chosen CM in the
    // Image Attributes dialog, OR if using Pels and the NLS
    // setting is for metric
    //
    if (theApp.m_iCurrentUnits == ePIXELS)
    {
       lcidThread = GetThreadLocale();
       GetLocaleInfo (lcidThread, LOCALE_IMEASURE, szMetric, 2);
       bMetric = (szMetric[0] == TEXT('0'));
    }
    else
    {
       bMetric = ((eUNITS)theApp.m_iCurrentUnits == eCM); //centimeters
    }

    CPageSetupData PageSetupData;

    PageSetupData.bCenterHorizontally = theApp.m_bCenterHorizontally;
    PageSetupData.bCenterVertically   = theApp.m_bCenterVertically;
    PageSetupData.bScaleFitTo         = theApp.m_bScaleFitTo;
    PageSetupData.nAdjustToPercent    = theApp.m_nAdjustToPercent;
    PageSetupData.nFitToPagesWide     = theApp.m_nFitToPagesWide;
    PageSetupData.nFitToPagesTall     = theApp.m_nFitToPagesTall;

    double cXPelsPerMeter = m_pImgWnd->m_pImg->cXPelsPerMeter ? 
        m_pImgWnd->m_pImg->cXPelsPerMeter : theApp.ScreenDeviceInfo.ixPelsPerDM * 10;
    double cYPelsPerMeter = m_pImgWnd->m_pImg->cYPelsPerMeter ? 
        m_pImgWnd->m_pImg->cYPelsPerMeter : theApp.ScreenDeviceInfo.iyPelsPerDM * 10;

    PageSetupData.fPhysicalImageWidth = (double)m_pImgWnd->m_pImg->cxWidth * 100000 / cXPelsPerMeter;
    PageSetupData.fPhysicalImageHeight = (double)m_pImgWnd->m_pImg->cyHeight * 100000 / cYPelsPerMeter;

    if (!bMetric)
    {
        PageSetupData.fPhysicalImageWidth /= 2.54;
        PageSetupData.fPhysicalImageHeight /= 2.54;
    }

    psd.Flags |= PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGEPAINTHOOK | PSD_ENABLEPAGESETUPTEMPLATE | 
        PSD_MARGINS | (bMetric ? PSD_INHUNDREDTHSOFMILLIMETERS : PSD_INTHOUSANDTHSOFINCHES);
    int nUnitsPerInch = bMetric ? 2540 : 1000;
    MulDivRect(&psd.rtMargin, theApp.m_rectMargins, nUnitsPerInch, MARGINS_UNITS);
    RoundRect(&psd.rtMargin);
// get the current device from the app
    PRINTDLG pd;
    pd.hDevNames = NULL;
    pd.hDevMode = NULL;
    theApp.GetPrinterDeviceDefaults(&pd);
    psd.hDevNames = pd.hDevNames;
    psd.hDevMode = pd.hDevMode;
    psd.hInstance = AfxGetInstanceHandle();
    psd.lCustData = (LPARAM) &PageSetupData;
    psd.lpfnPagePaintHook = CPageSetupData::PagePaintHook;
    psd.lpfnPageSetupHook = CPageSetupData::PageSetupHook;
    psd.lpPageSetupTemplateName = MAKEINTRESOURCE(IDD_PAGESETUPDLG);

    if (dlg.DoModal() == IDOK)
    {
        RoundRect(&psd.rtMargin);
        MulDivRect(theApp.m_rectMargins, &psd.rtMargin, MARGINS_UNITS, nUnitsPerInch);
        //theApp.m_rectPageMargin = m_rectMargin;
        theApp.SelectPrinter(psd.hDevNames, psd.hDevMode);

        theApp.m_bCenterHorizontally = PageSetupData.bCenterHorizontally;
        theApp.m_bCenterVertically   = PageSetupData.bCenterVertically;
        theApp.m_bScaleFitTo         = PageSetupData.bScaleFitTo;
        theApp.m_nAdjustToPercent    = PageSetupData.nAdjustToPercent;
        theApp.m_nFitToPagesWide     = PageSetupData.nFitToPagesWide;
        theApp.m_nFitToPagesTall     = PageSetupData.nFitToPagesTall;
    }

    // PageSetupDlg failed
//    if (CommDlgExtendedError() != 0)
//    {
       //
       //  nothing to handle this failure
       //
//    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\rotate.cpp ===
/****************************************************************************
 ROTATE.c

 The ROTATE module handles rotating a rectangular object.

****************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgsuprt.h"
#include "bmobject.h"
#include "undo.h"
#include "props.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

/***************************************************************************/

void CImgWnd::CmdRot90()
    {
    HideBrush();

    CRect     rotRect;
    HDC       hdcSrc;
    CPalette* ppalOld = NULL;

    if (! theImgBrush.m_pImg && ! g_bCustomBrush)
        {
        rotRect.SetRect( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight );

        hdcSrc = m_pImg->hDC;
        }
    else
        {
        PrepareForBrushChange( TRUE, TRUE );

        ppalOld = SetImgPalette( &theImgBrush.m_dc );

        hdcSrc = theImgBrush.m_dc.GetSafeHdc();

        rotRect         = rcDragBrush;
        rotRect.right  -= 1;
        rotRect.bottom -= 1;
        }

    ASSERT( hdcSrc != NULL);

    if (rotRect.IsRectEmpty() || ! hdcSrc)
        {
        if (ppalOld)
            theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

        return;
        }

    int iWidth  = rotRect.Width();
    int iHeight = rotRect.Height();

    CRect destRect( 0, 0, iHeight, iWidth );

    destRect.OffsetRect( rotRect.left + iWidth  / 2 - iHeight / 2,
                         rotRect.top  + iHeight / 2 - iWidth  / 2 );
    CBitmap bmRotated;
    CDC     dcRotated;
    CDC*    pdcImg = CDC::FromHandle( m_pImg->hDC );

    if (! bmRotated.CreateCompatibleBitmap( pdcImg, iHeight, iWidth )
    ||  ! dcRotated.CreateCompatibleDC    ( pdcImg ))
        {
        if (ppalOld)
            theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

        theApp.SetGdiEmergency( TRUE );
        return;
        }

    CBitmap*  pbmOld = dcRotated.SelectObject( &bmRotated );
    CPalette* ppalRotated = SetImgPalette( &dcRotated );

    BeginWaitCursor();

    int  iRow;
    int  iCol;
    BOOL bDone = FALSE;

    // Need code here to get select RECT from the hdcSrc
    HDC     rowDC  = ::CreateCompatibleDC    ( hdcSrc );
    HDC     colDC  = ::CreateCompatibleDC    ( hdcSrc );
    HBITMAP hrowBM = ::CreateCompatibleBitmap( hdcSrc, iWidth, 1 );
    HBITMAP hcolBM = ::CreateCompatibleBitmap( hdcSrc, 1, iWidth );

    if (rowDC && colDC && hrowBM && hcolBM)
        {
        HBITMAP scolBM  = (HBITMAP)::SelectObject( colDC, hcolBM );
        HBITMAP srowBM  = (HBITMAP)::SelectObject( rowDC, hrowBM );

        ::PatBlt( rowDC, 0, 0, iWidth, 1, BLACKNESS );
        ::PatBlt( colDC, 0, 0, 1, iWidth, BLACKNESS );

        HPALETTE hpalRow = SetImgPalette( rowDC ); // save to replace later
        HPALETTE hpalCol = SetImgPalette( colDC ); // save to replace later

        ::SelectObject( colDC, scolBM );
        ::SelectObject( rowDC, srowBM );

        DWORD dwLen;

        LPSTR lpDibRow = (LPSTR) DibFromBitmap( 
            hrowBM, DIB_RGB_COLORS, 24,
            theApp.m_pPalette, NULL, dwLen,
            m_pImg->cXPelsPerMeter, m_pImg->cYPelsPerMeter);

        LPSTR lpDibCol = (LPSTR) DibFromBitmap( 
            hcolBM, DIB_RGB_COLORS, 24,
            theApp.m_pPalette, NULL, dwLen,
            m_pImg->cXPelsPerMeter, m_pImg->cYPelsPerMeter);

        if (lpDibRow && lpDibCol)
            {
            VOID* pBitsRow = FindDIBBits( lpDibRow );
            VOID* pBitsCol = FindDIBBits( lpDibCol );

            for (iRow = 0, iCol = iHeight - 1; iRow < iHeight; iRow++, iCol--)
                {
                ::SelectObject( rowDC, hrowBM );
                ::BitBlt( rowDC, 0, 0, iWidth, 1, hdcSrc, 0, iRow, SRCCOPY );
                ::SelectObject( rowDC, srowBM );

                if (! GetDIBits( hdcSrc, hrowBM, 0, 1, pBitsRow, (LPBITMAPINFO)lpDibRow, DIB_RGB_COLORS ))
                    break;

                LPBYTE  pRow =  (LPBYTE)pBitsRow;
                LPDWORD pCol = (LPDWORD)pBitsCol;

                union
                    {
                    DWORD pixel;
                    char  byte[sizeof( DWORD )];
                    } u;

                u.byte[3] = 0;

                for (register int index = iWidth - 1; index >= 0; index--)
                    {
                    u.byte[0] = *pRow++;
                    u.byte[1] = *pRow++;
                    u.byte[2] = *pRow++;

                    pCol[index] = u.pixel;
                    }

                if (! SetDIBits( hdcSrc, hcolBM, 0, iWidth, pBitsCol, (LPBITMAPINFO)lpDibCol, DIB_RGB_COLORS ))
                    break;

                ::SelectObject( colDC, hcolBM );
                ::BitBlt( dcRotated.m_hDC, iCol, 0, 1, iWidth, colDC, 0, 0, SRCCOPY );
                ::SelectObject( colDC, scolBM );
                }

            bDone = (iRow == iHeight);

            if (! bDone)
                theApp.SetGdiEmergency( TRUE );
            }
        else
            theApp.SetMemoryEmergency( TRUE );

        if (lpDibRow)
            FreeDib( lpDibRow );

        if (lpDibCol)
            FreeDib( lpDibCol );

        if (hpalRow)
            ::SelectPalette( rowDC, hpalRow, FALSE );

        if (hpalCol)
            ::SelectPalette( colDC, hpalCol, FALSE );
        }
    else
        theApp.SetGdiEmergency( TRUE );

    // clean up
    if (rowDC)
        ::DeleteDC( rowDC );

    if (colDC)
        ::DeleteDC( colDC );

    if (hrowBM)
        ::DeleteObject( hrowBM );

    if (hcolBM)
        ::DeleteObject( hcolBM );

    EndWaitCursor();

    if (! bDone) // do the brute force method
        {
        if (ppalOld)
            theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

        if (ppalRotated)
            dcRotated.SelectPalette( ppalRotated, FALSE );

        dcRotated.SelectObject( pbmOld );
        dcRotated.DeleteDC();
        bmRotated.DeleteObject();
        return;
        }

    if (ppalOld)
        theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

    if (  theImgBrush.m_pImg
    &&  ! theImgBrush.m_bFirstDrag || g_bCustomBrush)
        {
        if (ppalRotated)
            dcRotated.SelectPalette( ppalRotated, FALSE );

        dcRotated.SelectObject( pbmOld );

        CBitmap bmMask;

        if (! bmMask.CreateBitmap( iHeight, iWidth, 1, 1, NULL ))
            {
            theApp.SetMemoryEmergency( TRUE );
            return;
            }

        theImgBrush.m_dc.SelectObject( &bmRotated );
        theImgBrush.m_bitmap.DeleteObject();
        theImgBrush.m_bitmap.Attach( bmRotated.Detach() );

        theImgBrush.m_size.cx = iHeight;
        theImgBrush.m_size.cy = iWidth;

        VERIFY( theImgBrush.m_maskDC.SelectObject( &bmMask ) ==
               &theImgBrush.m_maskBitmap );

        theImgBrush.m_maskBitmap.DeleteObject();
        theImgBrush.m_maskBitmap.Attach( bmMask.Detach() );
        theImgBrush.RecalcMask( crRight );

        MoveBrush( destRect );
        }
    else
        {
        theUndo.BeginUndo( TEXT("Resize Bitmap") );

        m_pImg->m_pBitmapObj->SetSizeProp( P_Size, CSize( iHeight, iWidth ) );

        m_pImg->cxWidth  = iHeight;
        m_pImg->cyHeight = iWidth;

        SetUndo( m_pImg );

        pdcImg->BitBlt( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight, &dcRotated, 0, 0, SRCCOPY );

        dcRotated.SelectObject( pbmOld );

        if (ppalRotated)
            dcRotated.SelectPalette( ppalRotated, FALSE );

        bmRotated.DeleteObject();

        InvalImgRect ( m_pImg, &rotRect );
        CommitImgRect( m_pImg, &rotRect );

        FinishUndo   ( rotRect );

        theUndo.EndUndo();

        DirtyImg     ( m_pImg );

        InvalidateRect( NULL );
        UpdateWindow();
        }

    dcRotated.DeleteDC();
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\pictures.cpp ===
// pictures.cpp : This is the code for the picture object
//

#include "stdafx.h"
#include "resource.h"
#include "pictures.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CPic, CDC )

#include "memtrace.h"

/****************************************************************************/

CPic::CPic()
     : CDC()
{
mhBitmapOld = NULL;
mbReady     = FALSE;
/*
**  set up our DC
*/
if (! CreateCompatibleDC( NULL ))
    {
    #ifdef _DEBUG
    OutputDebugString( TEXT("GDI error or unable to get a DC!\r\n") );
    #endif
    }
}

/****************************************************************************/

CPic::~CPic()
{
if (m_hDC)
    {
    if (mhBitmapOld)
        SelectObject( CBitmap::FromHandle( mhBitmapOld ) );

    if (mBitmap.m_hObject)
        mBitmap.DeleteObject();

    if (mMask.m_hObject)
        mMask.DeleteObject();
    }
}

/****************************************************************************/

void CPic::Picture( CDC* pDC, int iX, int iY, int iPic )
{
if (! mbReady || iPic < 0 || iPic >= miCnt)
    return;

int iPicX = iPic * mSize.cx;

SelectObject( &mMask );

// select  FG color to be Black and BK color to be White
//
// The Default Mono->Color Conversion sets (Black -> FG Color, White -> BG Color)
// It uses FG/BK color from the destination (color DC).
// we want Black -> black, White -> white
// a black/white bitmap in color format.
COLORREF cRefFGColorOld = pDC->SetTextColor( RGB(0,0,0) );
COLORREF cRefBKColorOld = pDC->SetBkColor(RGB(255,255,255));

pDC->BitBlt( iX, iY, mSize.cx, mSize.cy, this, iPicX, 0, SRCAND );

pDC->SetTextColor(cRefFGColorOld);
pDC->SetBkColor(cRefBKColorOld);


SelectObject( &mBitmap );

pDC->BitBlt( iX, iY, mSize.cx, mSize.cy, this, iPicX, 0, SRCPAINT );
}

/****************************************************************************/

BOOL CPic::PictureSet( LPCTSTR lpszResourceName, int iCnt )
{
BOOL bReturn = FALSE;
/*
**  get the Pictures bitmap
*/
if (m_hDC && iCnt)
    if (mBitmap.LoadBitmap( lpszResourceName ))
        {
        miCnt = iCnt;

        bReturn = InstallPicture();
        }
    else
        {
        #ifdef _DEBUG
        OutputDebugString( TEXT("Unable to load the bitmap!\r\n") );
        #endif
        }

return bReturn;
}

/****************************************************************************/

BOOL CPic::PictureSet( UINT nIDResource, int iCnt )
{
BOOL bReturn = FALSE;
/*
**  get the Pictures bitmap
*/
if (m_hDC && iCnt)
    if (mBitmap.LoadBitmap( nIDResource ))
        {
        miCnt = iCnt;

        bReturn = InstallPicture();
        }
    else
        {
        #ifdef _DEBUG
        OutputDebugString( TEXT("Unable to load the bitmap!\r\n") );
        #endif
        }
return bReturn;
}

/****************************************************************************/

BOOL CPic::InstallPicture()
{
/*
**  get the bitmap info from the picture bitmap, saving the picture size
*/
BITMAP bmInfo;

if (mBitmap.GetObject( sizeof( BITMAP ), &bmInfo ) != sizeof( BITMAP ))
    {
    #ifdef _DEBUG
    OutputDebugString( TEXT("GDI error getting bitmap information!\r\n") );
    #endif

    return FALSE;
    }

mSize = CSize( bmInfo.bmWidth / miCnt, bmInfo.bmHeight );
/*
**  put the bitmap in the DC, saving the original.
*/
CBitmap* bitmap = SelectObject( &mBitmap );

mhBitmapOld = (HBITMAP)bitmap->m_hObject;
/*
**  create the mask bitmap, same size monochrome
*/
if (! mMask.CreateBitmap( bmInfo.bmWidth, bmInfo.bmHeight, 1, 1, NULL ))
    {
    #ifdef _DEBUG
    OutputDebugString( TEXT("GDI error creating the mask bitmap!\r\n") );
    #endif

    return FALSE;
    }
/*
**  put the mask in a temp DC so we can generate the mask bits
*/
CDC dc;

dc.CreateCompatibleDC( this );

ASSERT( dc.m_hDC );

CBitmap* ob = dc.SelectObject( &mMask );
/*
**  use the color at the upper left corner for generating the mask
*/
SetBkColor( GetPixel( 1, 1 ) );

// this ROP Code will leave bits in the destination bitmap the same color if the
// corresponding source bitmap's bit are black.
// all other bits in the destination (where source bits are not black)
// are turned to black.

#define ROP_DSna 0x00220326L
/*
**  Creates the mask from all pixels in the image of a given color.
**  Copies to the mask, then cuts the image with the mask.
*/
// create the mast, All but the background color is Black
// bkcolor is white
dc.BitBlt( 0, 0, bmInfo.bmWidth, bmInfo.bmHeight, this, 0, 0, SRCCOPY  );

// select  FG color to be Black and BK color to be White
// The Default Mono->Color Conversion sets (Black -> FG Color, White -> BG Color)
// It uses FG/BK color from the destination (color DC).
// we want Black -> black, White -> white
// a black/white bitmap in color format.
COLORREF cRefFGColorOld = dc.SetTextColor( RGB(0,0,0) );
COLORREF cRefBKColorOld = dc.SetBkColor(RGB(255,255,255));

   BitBlt( 0, 0, bmInfo.bmWidth, bmInfo.bmHeight,  &dc, 0, 0, ROP_DSna );

dc.SetTextColor(cRefFGColorOld);
dc.SetBkColor(cRefBKColorOld);

dc.SelectObject( ob );
mbReady = TRUE;
return TRUE;
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\props.h ===
// Properties

#define P_Title             100
#define P_ALIGNCAPTION      101

#define P_String            106
#define P_Preload           107
#define P_Moveable          108
#define P_Discardable       109
#define P_Pure              110

#define P_HASMINVAL         200
#define P_HASMAXVAL         201
#define P_MINVAL            202
#define P_MAXVAL            203
#define P_MULTILINE         204
#define P_INITIALVAL        205
#define P_DATATYPE          206


#define P_Autolayout        300
#define P_Wrap              301
#define P_Border            302
#define P_LeftMargin        303
#define P_TopMargin         304
#define P_RightMargin       305
#define P_BottomMargin      306
#define P_Columns           307

#define P_WindowStyle       308
#define P_Caption           312

#define P_Popup             313
#define P_Separator         314
#define P_Checked           315
#define P_Inactive          316
#define P_Break             317
#define P_Help              318
#define P_MenuBar           319
#define P_HorizontalAlignment 321
#define P_VerticalAlignment 322
#define P_AutoSizeToContent 323
#define P_ShowKeyboardShortcuts 324
#define P_Grayed        325
#define P_ShowPropertyWindow 326
#define P_ShowControlPalette 327
#define P_DetectDuplicateIDs 328
#define P_BuildOnSave   329
#define P_DefaultHelpContext 330
#define P_MinimumResourceID 331
#define P_MinimumCommandID 332
#define P_MinimumStringID 333
#define P_MinimumAcceleratorID 334
#define P_CurrentSlob   335
#define P_OwnerDraw     336
#define P_DefaultButton 337
#define P_InitiallyChecked 338
#define P_Order         339
#define P_CaptionLocation 340
#define P_Position      342
#define P_PoppingProperties 343
#define P_LogUndo       344
#define P_Image         345
#define P_Width         346
#define P_Height        347
#define P_Colors        348
#define P_Hotspot       349
#define P_Size          350
#define P_Ctrl          352
#define P_Alt           353
#define P_Shift         354
#define P_Type          355
#define P_Key           357
#define P_Visible       360
#define P_Disabled      361
#define P_Group         362
#define P_Tabstop       363
#define P_TextAlign     364
#define P_NoPrefix      365
#define P_NoWrap        366
#define P_GfxType       367
#define P_GfxColor      368
#define P_GfxIcon       369
#define P_Auto          370
#define P_LeftText      371
#define P_3State        372
#define P_Context       374
#define P_FontFace      375
#define P_FontSize      376
#define P_Menu          377
#define P_Choices       378
#define P_NewItem       379
#define P_KeyValue      380

#define P_Standard      500
#define P_Sort          502
#define P_Notify        503
#define P_Keyin         504
#define P_VScroll       505
#define P_HScroll       506
#define P_Tabstops      507
#define P_NoRedraw      508
#define P_NoIntHeight   509
#define P_MultiCol      510
#define P_HasStrings    511
#define P_Selection     512
#define P_AutoHScroll   515
#define P_AutoVScroll   516
#define P_Password      517
#define P_NoHideSel     518
#define P_OEMConvert    519
#define P_MultiLine     520
#define P_UpperCase     522
#define P_LowerCase     523
#define P_AlignText     524
#define P_Shrink        525

#define P_AddToCaption  526
#define P_AcceleratorTable 527
#define P_TitleBar      529
#define P_State         530
#define P_ClipSiblings  531
#define P_ClipChildren  532
#define P_SystemModal   533
#define P_NoIdleMsg     534
#define P_LocalEdit     535
#define P_SystemMenu    536
#define P_MinimizeBox   537
#define P_MaximizeBox   538
#define P_Style         539

#define P_ThickFrame    540
#define P_NoParentNotify 541
#define P_TopMost       542
#define P_AcceptFiles   543
#define P_Transparent   544
#define P_Class         545
#define P_LayoutBorder  546
#define P_FrameType     547
#define P_AbsAlign      548

#define P_Show          550
#define P_Message       551
#define P_MsgClass      552
#define P_Function      553

#define P_CmdMessage    561
#define P_CmdSlob       562

#define P_ShowStatusbar 563
#define P_ShowToolbar   564

#define P_PosX          565
#define P_PosY          566

#define P_FileName      567

#define P_Grid          568
#define P_GridX         569
#define P_GridY         570

#define P_DisableNoScroll   572
#define P_ScrAlign          573
#define P_WantReturn        574
#define P_ReadOnly          575

#define P_Simple            580
#define P_DlgInit           581

#ifdef DS_NONBOLD
    #define P_NonBold           591
#endif

#ifdef _DEBUG
#define P_DebugValue        700
#endif


// Actions
#define A_ImageChange       1000
#define A_PostSel           1001
#define A_PreSel            1002
#define A_HexChange         1003
#define A_DependentList     1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\saveimag.cpp ===
//
// saveimag.cpp
//
// implementation of saving a file to disk via an installed graphic filter
//
#include "stdafx.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "bmobject.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "loadimag.h"
#include "saveimag.h"
#include "bmpstrm.h"
#include "imaging.h"

#include <atlbase.h>

#ifdef _X86_
#define _USE_IFL_API
#endif

extern BOOL GetHandlerForFile(BOOL bImport,LPCSTR szFile,
                              LPSTR szHandler,
                              UINT cb);           // defined in loadimag.cpp


inline RGBTRIPLE GetPalEntry(LPVOID lpPal3, BYTE index)
{
        RGBTRIPLE rgb;

        rgb.rgbtRed   = ((RGBTRIPLE *)lpPal3 + index)->rgbtRed;
        rgb.rgbtGreen = ((RGBTRIPLE *)lpPal3 + index)->rgbtGreen;
        rgb.rgbtBlue  = ((RGBTRIPLE *)lpPal3 + index)->rgbtBlue;

        return rgb;
}

inline void ConvertPalette(int bitCount, LPBYTE lpBuf, int width)
{
        int j;

        switch (bitCount)
        {
                case 4:
                        for (j=0; j<width; j++)
                        {
                                *(lpBuf+(width-1-j)*2+1) = (*(lpBuf+width-1-j) & 0x0f);
                                *(lpBuf+(width-1-j)*2)   = (*(lpBuf+width-1-j) & 0xf0) >> 4;
                        }
                        break;

                case 1:
                        for (j=0; j<width; j++)
                        {
                                *(lpBuf+(width-1-j)*8+7) = (*(lpBuf+width-1-j) & 0x1);
                                *(lpBuf+(width-1-j)*8+6) = (*(lpBuf+width-1-j) & 0x2)  >> 1;
                                *(lpBuf+(width-1-j)*8+5) = (*(lpBuf+width-1-j) & 0x4)  >> 2;
                                *(lpBuf+(width-1-j)*8+4) = (*(lpBuf+width-1-j) & 0x8)  >> 3;
                                *(lpBuf+(width-1-j)*8+3) = (*(lpBuf+width-1-j) & 0x10) >> 4;
                                *(lpBuf+(width-1-j)*8+2) = (*(lpBuf+width-1-j) & 0x20) >> 5;
                                *(lpBuf+(width-1-j)*8+1) = (*(lpBuf+width-1-j) & 0x40) >> 6;
                                *(lpBuf+(width-1-j)*8)   = (*(lpBuf+width-1-j) & 0x80) >> 7;
                        }
                        break;

                default:
                        // impossible!!!
                        break;
        }
}

inline BYTE SearchPalette(COLORREF crColor, LPVOID lpPal3)
{
        BYTE byRed   = GetRValue( crTrans );
        BYTE byGreen = GetGValue( crTrans );
        BYTE byBlue  = GetBValue( crTrans );

        for (int i = 0; i < MAX_PALETTE_COLORS; i++)
        {
                // note that we have to switch the colors back before
                // attempting to compare them!!
                if (byRed   == ((RGBTRIPLE *)lpPal3 + i)->rgbtBlue  &&
                        byGreen == ((RGBTRIPLE *)lpPal3 + i)->rgbtGreen &&
                        byBlue  == ((RGBTRIPLE *)lpPal3 + i)->rgbtRed)
                        return (BYTE)i;
        }

        // shouldn't reach here!!
        // (the color being searched must be in the palette)
        return 0;
}

BOOL SaveDIBToFileA( LPCSTR  szFileName,
                     REFGUID guidFormatID,
                     CBitmapObj* pBitmap )
{
    IFLTYPE iflType;

    if (guidFormatID == WiaImgFmt_GIF)
    {
        iflType = IFLT_GIF;
    }
    else if (guidFormatID == WiaImgFmt_BMP)
    {
        iflType = IFLT_BMP;
    }
    else if (guidFormatID == WiaImgFmt_JPEG)
    {
        iflType = IFLT_JPEG;
    }
    else if (guidFormatID == WiaImgFmt_TIFF)
    {
        iflType = IFLT_TIFF;
    }
    else if (guidFormatID == WiaImgFmt_PNG)
    {
        iflType = IFLT_PNG;
    }
    else if (guidFormatID == WiaImgFmt_PHOTOCD)
    {
        iflType = IFLT_PCD;
    }
    else
    {
        return FALSE;
    }

   #ifdef  _USE_IFL_API
        LPBITMAPINFOHEADER lpDib = (LPBITMAPINFOHEADER) GlobalLock(pBitmap->m_hThing);

        IFLCLASS iflClass = (lpDib->biBitCount == 24) ? IFLCL_RGB : IFLCL_PALETTE;
        int iBPS = 8; // bits per sample

        if (iflType == IFLT_JPEG)
                // force it to be RGB type, otherwise the JPEG filter won't take it
                iflClass = IFLCL_RGB;

        if (iflType == IFLT_GIF && iflClass == IFLCL_RGB)
        {
                GlobalUnlock(pBitmap->m_hThing);

                // force it to be PALETTE type, otherwise the GIF filter won't take it
                iflClass = IFLCL_PALETTE;

                // Now convert the image from RGB to palette-based. Note that
                // the call to DibFromBitmap() will allocate new memory!!
                DWORD dwSize;
                lpDib = (LPBITMAPINFOHEADER) DibFromBitmap(
                        pBitmap->m_pImg->hBitmap, BI_RGB, (WORD) iBPS,
                        pBitmap->m_pImg->m_pPalette, NULL, dwSize,
                        pBitmap->m_pImg->cXPelsPerMeter, pBitmap->m_pImg->cYPelsPerMeter);

                if (lpDib == NULL)
                        return FALSE;   // memory allocation failed

                // now replace the original
                pBitmap->Free();
                pBitmap->m_hThing   = lpDib;
                pBitmap->m_lMemSize = dwSize;
                lpDib = (LPBITMAPINFOHEADER) GlobalLock(pBitmap->m_hThing);
        }


        IFLCOMPRESSION iflCompression = IFLCOMP_DEFAULT; // or IFLCOMP_NONE ???

        IFLHANDLE iflHandle = iflCreateWriteHandle(lpDib->biWidth, lpDib->biHeight,
                iflClass, iBPS, iflCompression, iflType);

        if (iflHandle == NULL)
        {
                GlobalUnlock(pBitmap->m_hThing);
                return FALSE;
        }

        IFLERROR iflErr = iflOpen(iflHandle, (LPSTR)szFileName, IFLM_WRITE);
        if (iflErr != IFLERR_NONE)
        {
                iflFreeHandle(iflHandle);
                GlobalUnlock(pBitmap->m_hThing);
                return FALSE;
        }

        LPBITMAPINFOHEADER lpHdr = lpDib;

        DWORD   dwHdrLen = lpHdr->biSize + PaletteSize((LPSTR)lpHdr);

        LPBYTE  hp = ((LPBYTE)lpDib) + dwHdrLen;

        int             iOutWidth = (lpDib->biBitCount == 24) ?
                                                 lpDib->biWidth*3 :
                                                 lpDib->biWidth*24/lpDib->biBitCount;

        LPBYTE  lpBuf = new BYTE[iOutWidth];

        int             i, j, k;
        BYTE    byTemp;
        BOOL    fFound;

        // convert from pixels to bytes after rounding it up first
        DWORD dwWidthInBytes = ((lpDib->biWidth * lpDib->biBitCount + 31) &~31) /8;
        if (iflClass == IFLCL_RGB)
        {
                // set the transparent color on demand and only if it's been set
                if (g_bUseTrans && crTrans != TRANS_COLOR_NONE) // not default
                {
                        IFLCOLOR iflTransColor;

                        iflTransColor.wRed   = GetRValue( crTrans );
                        iflTransColor.wGreen = GetGValue( crTrans );
                        iflTransColor.wBlue  = GetBValue( crTrans );

                        // ignore any error return (if a format doesn't support
                        // transparent color, so be it)
                        iflControl(iflHandle, IFLCMD_TRANS_RGB, 0, 0, &iflTransColor);
                }

                if (lpDib->biBitCount == 24)
                {
                        // we already have a RGB image, so just copy it out
                        LPBYTE  lpBMP = hp + lpDib->biSizeImage - dwWidthInBytes;

                        for (i = 0;
                                 i < abs(lpDib->biHeight);
                                 lpBMP-=dwWidthInBytes, i++)
                        {
                                memcpy(lpBuf, lpBMP, iOutWidth);

                                // need to swap RED with BLUE for export
                                for (j = 0; j < iOutWidth; j+=3)
                                {
                                        byTemp = *(lpBuf+j);
                                        *(lpBuf+j) = *(lpBuf+j+2);
                                        *(lpBuf+j+2) = byTemp;
                                }

                                // write out one line at a time
                                iflWrite(iflHandle, lpBuf, 1);
                         }
                }
                else
                {
                        // need to convert from palatte color
                        RGBTRIPLE Pal3[MAX_PALETTE_COLORS];
                        memset(Pal3, 255, MAX_PALETTE_COLORS*sizeof(RGBTRIPLE));

                        LPRGBQUAD lpPal4 = (LPRGBQUAD)((LPBYTE)lpDib + lpDib->biSize);
                        for (i = 0; i < MAX_PALETTE_COLORS; i++)
                        {
                                Pal3[i].rgbtRed   = (lpPal4+i)->rgbBlue;
                                Pal3[i].rgbtGreen = (lpPal4+i)->rgbGreen;
                                Pal3[i].rgbtBlue  = (lpPal4+i)->rgbRed;
                        }

                        LPBYTE  lpBMP = hp + lpDib->biSizeImage - dwWidthInBytes;

                        for (i = 0;
                                 i < abs(lpDib->biHeight);
                                 lpBMP-=dwWidthInBytes, i++)
                        {
                                memcpy(lpBuf, lpBMP, lpDib->biWidth);

                                if (lpDib->biBitCount != 8)
                                        ConvertPalette(lpDib->biBitCount, lpBuf, lpDib->biWidth);

                                for (j = 0; j < lpDib->biWidth; j++)
                                {
                                        ((RGBTRIPLE *)(lpBuf+(lpDib->biWidth-j-1)*3))->rgbtRed   =
                                                GetPalEntry(&Pal3, *(lpBuf+lpDib->biWidth-j-1)).rgbtRed;
                                        ((RGBTRIPLE *)(lpBuf+(lpDib->biWidth-j-1)*3))->rgbtGreen =
                                                GetPalEntry(&Pal3, *(lpBuf+lpDib->biWidth-j-1)).rgbtGreen;
                                        ((RGBTRIPLE *)(lpBuf+(lpDib->biWidth-j-1)*3))->rgbtBlue  =
                                                GetPalEntry(&Pal3, *(lpBuf+lpDib->biWidth-j-1)).rgbtBlue;
                                }

                                // write out one line at a time
                                iflWrite(iflHandle, lpBuf, 1);
                        }
                }
        }
        else if (iflClass == IFLCL_PALETTE)
        {
                // first, get the color palette straight...
                RGBTRIPLE Pal3[MAX_PALETTE_COLORS];
                memset(Pal3, 255, MAX_PALETTE_COLORS*sizeof(RGBTRIPLE));

                if (PaletteSize((LPSTR)lpDib) != 0)
                {
                        // we have one available, so just copy it out...
                        // but not before we swap the RGB values first
                        LPRGBQUAD lpPal4 = (LPRGBQUAD)((LPBYTE)lpDib + lpDib->biSize);
                        for (i = 0; i < MAX_PALETTE_COLORS; i++)
                        {
                                Pal3[i].rgbtRed   = (lpPal4+i)->rgbBlue;
                                Pal3[i].rgbtGreen = (lpPal4+i)->rgbGreen;
                                Pal3[i].rgbtBlue  = (lpPal4+i)->rgbRed;
                        }
                        iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

                        if (g_bUseTrans)
                        {
                                BYTE byTransIdx = SearchPalette(crTrans, &Pal3);
                                iflControl(iflHandle, IFLCMD_TRANS_IDX, 0, 0, &byTransIdx);
                        }

                        LPBYTE  lpBMP = hp + lpDib->biSizeImage - dwWidthInBytes;

                        for (i = 0;
                                 i < abs(lpDib->biHeight);
                                 lpBMP-=dwWidthInBytes, i++)
                        {
                                memcpy(lpBuf, lpBMP, lpDib->biWidth);

                                if (lpDib->biBitCount != 8)
                                        ConvertPalette(lpDib->biBitCount, lpBuf, lpDib->biWidth);

                                // write out one line at a time
                                iflWrite(iflHandle, lpBuf, 1);
                        }
                }
                else
                {
                        // we have to create our own palette...
                        for (i = 0, k = 0; i < (int)lpDib->biSizeImage; i+=3)
                        {
                                fFound = FALSE;
                                for (j = 0; j < MAX_PALETTE_COLORS; j++)
                                        if (Pal3[j].rgbtRed   == ((RGBTRIPLE *)(hp+i))->rgbtRed &&
                                                Pal3[j].rgbtGreen == ((RGBTRIPLE *)(hp+i))->rgbtGreen &&
                                                Pal3[j].rgbtBlue  == ((RGBTRIPLE *)(hp+i))->rgbtBlue)
                                        {
                                                fFound = TRUE;
                                                break;
                                        }

                                if (!fFound && k < MAX_PALETTE_COLORS)
                                {
                                        Pal3[k].rgbtRed         = ((RGBTRIPLE *)(hp+i))->rgbtRed;
                                        Pal3[k].rgbtGreen       = ((RGBTRIPLE *)(hp+i))->rgbtGreen;
                                        Pal3[k].rgbtBlue        = ((RGBTRIPLE *)(hp+i))->rgbtBlue;
                                        k++;
                                }

                                if (k >= MAX_PALETTE_COLORS)
                                        // we have already filled every palette entry
                                        break;
                        }
                        iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

                        LPBYTE  lpBMP = hp + lpDib->biSizeImage - dwWidthInBytes;
                        for (i = 0;
                                 i < abs(lpDib->biHeight);
                                 lpBMP-=dwWidthInBytes, i++)
                        {
                                memcpy(lpBuf, lpBMP, lpDib->biWidth);

                                for (j = 0; j < lpDib->biWidth; j+=3)
                                {
                                        fFound = FALSE;
                                        for (k = 0; k < MAX_PALETTE_COLORS; k++)
                                        {
                                                if (*(lpBuf+j)   == Pal3[k].rgbtRed &&
                                                        *(lpBuf+j+1) == Pal3[k].rgbtGreen &&
                                                        *(lpBuf+j+2) == Pal3[k].rgbtBlue)
                                                {
                                                        fFound = TRUE;
                                                        *(lpBuf+j/3) = (BYTE) k;
                                                        break;
                                                }
                                        }

//                                      if (!fFound)
//                                              *(lpBuf+j/3) = 255;
                                }

                                // write out one line at a time
                                iflWrite(iflHandle, lpBuf, 1);
                        }
                }
        }
        else
                ;       // currently not supported

        delete [] lpBuf;

        iflClose(iflHandle);
        iflFreeHandle(iflHandle);

        GlobalUnlock(pBitmap->m_hThing);

        // now update the image by loading the file just exported
        USES_CONVERSION;

        HGLOBAL hNewDib = LoadDIBFromFile(A2CT(szFileName), &theApp.m_guidFltTypeUsed);
        pBitmap->ReadResource(hNewDib);

        theApp.m_sCurFile = szFileName;
        return TRUE;
   #endif // _USE_IFL_API
      return FALSE;
}

BOOL SaveDIBGdiplus(LPCTSTR szFileName, REFGUID guidFormatID, CBitmapObj* pBitmap)
{
    // find a suitable export filter

    CLSID ClsidEncoder;

    if (GetClsidOfEncoder(guidFormatID, &ClsidEncoder))
    {
        // create a stream that emulates a bmp file

        CComPtr<CBmpStream> pStream;
        
        if (CBmpStream::Create(&pStream) == S_OK)
        {
            pStream->SetBuffer(pBitmap->m_hThing, pBitmap->m_lMemSize, pBitmap->m_dwOffBits);

            // create the GDI+ object

            Gdiplus::Bitmap image(pStream);

            if (image.GetLastStatus() == Gdiplus::Ok)
            {
                // let GDI+ export the file

                USES_CONVERSION;

                if (image.Save(T2CW(szFileName), &ClsidEncoder, 0) == Gdiplus::Ok)
                {
                    // now update the image by loading the file just exported

                    HGLOBAL hNewDib = LoadDIBFromFile(szFileName, &theApp.m_guidFltTypeUsed);

                    pBitmap->ReadResource(hNewDib);

                    theApp.m_sCurFile = szFileName;

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

BOOL SaveDIBToFile(LPCTSTR szFileName, REFGUID guidFormatID, CBitmapObj* pBitmap)
{
    // Try GDI+ filters first. If it fails to convert the image or 
    // if it's not available, try the old method

    BOOL bResult = FALSE;

    if (theApp.GdiplusInit.StartupStatus == Gdiplus::Ok)
    {
        __try
        {
            bResult = SaveDIBGdiplus(szFileName, guidFormatID, pBitmap);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    if (!bResult)
    {
        USES_CONVERSION;

        bResult = SaveDIBToFileA(T2CA(szFileName), guidFormatID, pBitmap);
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\settings.h ===
#ifndef __SETTINGS_H__
#define __SETTINGS_H__

extern void LoadRegistorSettings();
extern void SaveRegistorSettings();

#endif // __SETTINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\saveimag.h ===
//
//  SaveImage.c
//
//  routines to save and compress a graphics file using a MS Office
//  graphic export filter.
//
#include "image.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
//  SaveDIBToFile
//
//  save an image file using an installed image export filter.
//
BOOL SaveDIBToFile( LPCTSTR szFileName,
                    REFGUID guidFormatID,
                    CBitmapObj * pBitmap );

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\sources.inc ===
MAJORCOMP=shell
MINORCOMP=accesory

TARGETNAME=mspaint
TARGETPATH=obj
TARGETTYPE=PROGRAM

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h

USE_NATIVE_EH=1
USE_MFC=1
USE_STATIC_ATL=1
ATL_VER=30

# need to wait on ofn\$O\ofn.lib
SYNCHRONIZE_DRAIN = 1

C_DEFINES=-DWIN32 -D_WINDOWS -DNT -DUSE_MIRRORING

INCLUDES=..;..\res;$(INCLUDES);$(PRINTSCAN_INC_PATH)

SOURCES=            \
    ..\bar.cpp      \
    ..\bmobject.cpp \
    ..\cmpmsg.cpp   \
    ..\colorsrc.cpp \
    ..\docking.cpp  \
    ..\global.cpp   \
    ..\imageatt.cpp \
    ..\imgbrush.cpp \
    ..\imgcolor.cpp \
    ..\imgcpyps.cpp \
    ..\imgdlgs.cpp  \
    ..\imgfile.cpp  \
    ..\imgsuprt.cpp \
    ..\imgtools.cpp \
    ..\imgwell.cpp  \
    ..\imgwnd.cpp   \
    ..\ipframe.cpp  \
    ..\minifwnd.cpp \
    ..\pbrusdoc.cpp \
    ..\pbrusfrm.cpp \
    ..\pbrush.cpp   \
    ..\pbrusvw.cpp  \
    ..\pictures.cpp \
    ..\printres.cpp \
    ..\rotate.cpp   \
    ..\settings.cpp \
    ..\skew.cpp     \
    ..\sprite.cpp   \
    ..\srvritem.cpp \
    ..\tedit.cpp    \
    ..\tfont.cpp    \
    ..\thumnail.cpp \
    ..\toolbox.cpp  \
    ..\tracker.cpp  \
    ..\t_curve.cpp  \
    ..\t_fhsel.cpp  \
    ..\t_poly.cpp   \
    ..\t_text.cpp   \
    ..\undo.cpp     \
    ..\mspaint.rc   \
    ..\loadimag.cpp \
    ..\saveimag.cpp \
    ..\bmpstrm.cpp  \
    ..\imaging.cpp  \
    ..\pgsetup.cpp

# Add interlac.cpp if the PNG support is ever fixed

TARGETLIBS=                          \
        $(TARGETLIBS)                \
        $(SDK_LIB_PATH)\comdlg32.lib \
        $(SDK_LIB_PATH)\ole32.lib    \
        $(SDK_LIB_PATH)\oleaut32.lib \
        $(SDK_LIB_PATH)\winspool.lib \
        $(SDK_LIB_PATH)\uuid.lib     \
        $(SDK_LIB_PATH)\shell32.lib  \
        $(SDK_LIB_PATH)\htmlhelp.lib \
        $(SDK_LIB_PATH)\imm32.lib    \
        $(SDK_LIB_PATH)\wiaguid.lib  \
        $(SDK_LIB_PATH)\gdiplus.lib  \
        $(SDK_LIB_PATH)\uxtheme.lib


!if $(386)
TARGETLIBS=                          \
        $(TARGETLIBS)                \
        ..\image.lib                 \
        $(SDK_LIB_PATH)\oldnames.lib
!endif

DELAYLOAD=gdiplus.dll;uxtheme.dll
DLOAD_ERROR_HANDLER=none
 
# 
# Fusionized
# 
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\skew.cpp ===
/****************************************************************************
 SKEW.c

 The SKEW module handles rotating a rectangular object.

****************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgsuprt.h"
#include "bmobject.h"
#include "undo.h"
#include "props.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

static int miAngle;

/***************************************************************************/

static int CalcOffset( int iValue )
    {
    // tan[angle] is the 100000/tangent of angles 1 to 89deg.
    static int invtan[90] = {  -1, 5728996, 2863625, 1908114, 1430067,
                          1143005,  951436,  814436,  711537,  631375,
                           567128,  514455,  470463,  433148,  401078,
                           373205,  348741,  327085,  307768,  290421,
                           274748,  260509,  247509,  235585,  224604,
                           214451,  205030,  196261,  188073,  180405,
                           173205,  166428,  160034,  153987,  148256,
                           142815,  137638,  132705,  127994,  123490,
                           119175,  115037,  111061,  107237,  103553,
                           100000,   96569,   93252,   90040,   86929,
                            83910,   80978,   78129,   75355,   72654,
                            70021,   67451,   64941,   62487,   60086,
                            57735,   55431,   53171,   50953,   48773,
                            46631,   44523,   42448,   40403,   38386,
                            36397,   34433,   32492,   30573,   28675,
                            26795,   24933,   23087,   21256,   19438,
                            17633,   15838,   14054,   12279,   10510,
                             8749,    6993,    5241,    3492,    1746 };
    return (((iValue * 1000000 / invtan[miAngle]) + 5) / 10);
    }

/***************************************************************************/

void CImgWnd::CmdSkewBrush( int iAngle, BOOL bHorz )
    {
    BOOL  bFullImage = FALSE;
    CDC*  pdcImg = CDC::FromHandle( m_pImg->hDC );
    CDC*  pdcSrc = &theImgBrush.m_dc;
    CRect rectSlct( 0, 0, theImgBrush.m_size.cx, theImgBrush.m_size.cy );

    if (theImgBrush.m_pImg == NULL && ! g_bCustomBrush)
        {
        bFullImage = TRUE;
        pdcSrc     = pdcImg;
        rectSlct.SetRect( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight );
        }

    CRect rectSkew = rectSlct;

    if (!iAngle || rectSlct.IsRectEmpty() || abs(iAngle) > 89 || abs(iAngle) < 1 )
        return;

    if (! bFullImage)
        {
        PrepareForBrushChange( TRUE, TRUE );
        HideBrush();
        }
    // angle is the angle of skew 0 to 90 degrees
    // axis is the direction to skew TRUE:  horizontal
    //                                      the y axis moves by angle
    //                               FALSE: verticle
    //                                      the x axis moves by angle
    int iWidthSlct  = rectSlct.Width();
    int iHeightSlct = rectSlct.Height();

    miAngle = abs(iAngle);

    if (bHorz) // horizontal - create a new bitmap of size = x + y * tan (angle)
        rectSkew.right += CalcOffset( iHeightSlct );
    else       // verticale - create a new bitmap of size = y + x * tan (angle)
        rectSkew.bottom += CalcOffset( iWidthSlct );

    int iWidthSkew  = rectSkew.Width();
    int iHeightSkew = rectSkew.Height();

    // angle is the angle of skew 0 to 90 degrees
    // axis is the direction to skew TRUE:  horizontal
    //                                      the y axis moves by angle
    //                               FALSE: verticle
    //                                      the x axis moves by angle
    CDC     dcWork;
    CBitmap bmWork;
    CBrush  brBackground;

    if (! dcWork.CreateCompatibleDC( pdcImg )
    ||  ! bmWork.CreateCompatibleBitmap( pdcImg, iWidthSkew, iHeightSkew )
    ||  ! brBackground.CreateSolidBrush( crRight ))
        {
        theApp.SetGdiEmergency( TRUE );
        return;
        }

    CBitmap*  pbmOld = dcWork.SelectObject( &bmWork );
    CPalette* ppalOld = SetImgPalette( &dcWork, FALSE );

    dcWork.FillRect( rectSkew, &brBackground );

    CPalette* ppalOldSrc = SetImgPalette( pdcSrc, FALSE );

    // Skew the bitmap
    int mx = 1;
    int my = 1;  // local variables for the skew
    int x = rectSlct.left;
    int y = rectSlct.top;

    BeginWaitCursor();

    if (bHorz) // horizontal
        {
        if (iAngle > 0)
            {
            mx = x + CalcOffset( iHeightSlct - y );
            // Start at Bottom
            for (y = rectSlct.bottom; y >= rectSlct.top; )
                {
                dcWork.BitBlt( mx, y, iWidthSlct, 1, pdcSrc, x, y, SRCCOPY );
                mx = x + CalcOffset( iHeightSlct - y-- );
                }
            }
        else
            {
            x = rectSkew.right - iWidthSlct;
            mx = x - CalcOffset( iHeightSlct - y );
            for (y = rectSlct.bottom; y >= rectSlct.top; )
                {
                dcWork.BitBlt( mx, y, iWidthSlct, 1, pdcSrc, rectSlct.left, y, SRCCOPY );
                mx = x - CalcOffset( iHeightSlct - y-- );
                }
            }
        }
    else
        { // vertical
        if (iAngle > 0)
            {
            my = y + CalcOffset( iWidthSlct - x );
            // Start at left
            for (x = rectSlct.left - 1; x <= rectSlct.right; )
                {
                dcWork.BitBlt( x, my, 1, iHeightSlct, pdcSrc, x, y, SRCCOPY );
                my = y + CalcOffset( iWidthSlct - x++ );
                }
            }
        else
            {
            y = rectSkew.bottom - iHeightSlct;
            my = y - CalcOffset( iWidthSlct - x );
            for (x = rectSlct.left - 1; x <= rectSlct.right; )
                {
                dcWork.BitBlt( x, my, 1, iHeightSlct, pdcSrc, x, rectSlct.top, SRCCOPY );
                my = y - CalcOffset( iWidthSlct - x++ );
                }
            }
        }

    if (ppalOldSrc)
        pdcSrc->SelectPalette( ppalOldSrc, FALSE );

    if (bFullImage)
        {
        theUndo.BeginUndo( TEXT("Skew Bitmap") );

        m_pImg->m_pBitmapObj->SetSizeProp( P_Size, CSize( iWidthSkew, iHeightSkew ) );

        m_pImg->cxWidth  = iWidthSkew;
        m_pImg->cyHeight = iHeightSkew;

        SetUndo( m_pImg );

        pdcImg->BitBlt( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight, &dcWork, 0, 0, SRCCOPY );

        InvalImgRect ( m_pImg, &rectSkew );
        CommitImgRect( m_pImg, &rectSkew );

        FinishUndo( rectSkew );

        theUndo.EndUndo();

        DirtyImg( m_pImg );

        InvalidateRect( NULL );
        UpdateWindow();

        dcWork.SelectObject( pbmOld );
        bmWork.DeleteObject();
        }
    else
        {
        CBitmap bmMask;

        if (! bmMask.CreateBitmap( iWidthSkew, iHeightSkew, 1, 1, NULL ))
            {
            if (ppalOld)
                dcWork.SelectPalette( ppalOld, FALSE );

            theApp.SetMemoryEmergency( TRUE );
            return;
            }

        dcWork.SelectObject( pbmOld );

        theImgBrush.m_dc.SelectObject( &bmWork );
        theImgBrush.m_bitmap.DeleteObject();
        theImgBrush.m_bitmap.Attach( bmWork.Detach() );

        theImgBrush.m_size.cx = iWidthSkew;
        theImgBrush.m_size.cy = iHeightSkew;

        VERIFY( theImgBrush.m_maskDC.SelectObject( &bmMask ) ==
               &theImgBrush.m_maskBitmap );

        theImgBrush.m_maskBitmap.DeleteObject();
        theImgBrush.m_maskBitmap.Attach( bmMask.Detach() );
        theImgBrush.RecalcMask( crRight );

        rectSkew = theImgBrush.m_rcSelection;

        mx = 0;
        my = 0;

        if (bHorz)
            mx = CalcOffset( iHeightSlct ) / 2;
        else
            my = CalcOffset( iWidthSlct ) / 2;

        rectSkew.InflateRect( mx, my );

        MoveBrush( rectSkew );
        }

    if (ppalOld)
        dcWork.SelectPalette( ppalOld, FALSE );

    dcWork.DeleteDC();

    EndWaitCursor();
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\sprite.h ===
#ifndef __SPRITE_H__
#define __SPRITE_H__

// Draggers are graphical objects that typicaly overlay windows and
// can be shown, hidden, and moved.  A default dragger is simply a 
// dotted rectangle XOR'd over the contents of it's window.
//
// For bitmap draggers, use the CSprite class.
//
// CDragger() creates hidden draggers.
//
// ~CDragger() will hide a dragger before it is destroyed.
//
// Move() and SetSize() will make sure a dragger gets erased from 
// it's old position and if it was visible, it will be drawn in 
// it's new position.
//

class CDragger : public CObject
    {
    public:

    enum STATE 
        {
        hidden,
        shown,
        obscured
        };

             CDragger   () : m_rect(), m_pWnd() { m_state = hidden; };
             CDragger   ( CWnd* pWnd, CRect* pRect = NULL );
    virtual ~CDragger   ();

    virtual void Hide   ();
    virtual void Show   ();
    virtual void Obscure(BOOL bObscure);
    
    virtual void Draw   ();
    virtual void Erase  ();
    virtual void Move   ( const CRect& newRect, BOOL bForceShow = FALSE );
    virtual void Move   ( const CPoint& newTopLeft, BOOL bForceShow = FALSE );
            void MoveBy ( int cx, int cy, BOOL bForceShow = FALSE );
            void SetSize( const CSize& newSize, BOOL bForceShow = FALSE );

    virtual CObList* GetDraggerList() { return NULL; }
    virtual CRect    GetRect() const;
    inline  BOOL     IsShown() const { return m_state == shown; }
    
    CRect m_rect;
    STATE m_state;
    CWnd* m_pWnd;

    #ifdef _DEBUG
    DECLARE_DYNAMIC( CDragger )
    #endif
    };


class CMultiDragger : public CDragger
    {
    public:

             CMultiDragger();
             CMultiDragger(CWnd* pWnd);
    virtual ~CMultiDragger();

    virtual void Hide();
    virtual void Show();
    virtual void Draw();
    virtual void Erase();
    virtual void Move(const CPoint& newTopLeft, BOOL bForceShow = FALSE);
    
    virtual CRect GetRect() const;

    void Add   (CDragger *pDragger);
    void Remove(CDragger *pDragger);

    virtual CObList* GetDraggerList() { return &m_draggerList; }

    CObList m_draggerList;

    #ifdef _DEBUG
    DECLARE_DYNAMIC( CMultiDragger )
    #endif
    };

class CSprite : public CDragger
    {
    public:

    CSprite();
    CSprite(CWnd* pWnd, CRect* pRect = NULL);
    virtual ~CSprite();
    
    virtual void Move(const CRect&, BOOL = FALSE);
    inline  void Move(const CPoint& newTopLeft) 
                { CDragger::Move(newTopLeft); }
    virtual void Draw() = 0;
    virtual void SaveBits();
    virtual void Erase();
    
    CBitmap m_saveBits;

    #ifdef _DEBUG
    DECLARE_DYNAMIC( CSprite )
    #endif
    };

class CHighlight : public CDragger
    {
    public:

     CHighlight();
     CHighlight(CWnd *pWnd, CRect* pRect = NULL, int bdrSize = 2);
    ~CHighlight();

    int m_bdrSize;

    virtual void Draw();
    virtual void Erase();
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\settings.cpp ===
#include "stdafx.h"
#include "pbrush.h"
#include "settings.h"

#include <atlbase.h>

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

extern BOOL NEAR g_bDriverCanStretch;
extern BOOL NEAR g_bShowAllFiles;

/***************************************************************************/

static TCHAR NEAR mszView[]            = TEXT("View");
static TCHAR NEAR mszNoStretching[]    = TEXT("NoStretching");
static TCHAR NEAR mszShowAllFiles[]    = TEXT("ShowAllFiles");

static TCHAR NEAR mszShowThumbnail[]   = TEXT("ShowThumbnail");
static TCHAR NEAR mszShowText[]        = TEXT("ShowTextTool");


static TCHAR NEAR mszSnapToGrid[]      = TEXT("SnapToGrid");
static TCHAR NEAR mszGridExtent[]      = TEXT("GridExtent");
static TCHAR NEAR mszBMPWidth[]        = TEXT("BMPWidth");
static TCHAR NEAR mszBMPHeight[]       = TEXT("BMPHeight");

static TCHAR NEAR mszThumbXPos[]       = TEXT("ThumbXPos");
static TCHAR NEAR mszThumbYPos[]       = TEXT("ThumbYPos");
static TCHAR NEAR mszThumbWidth[]      = TEXT("ThumbWidth");
static TCHAR NEAR mszThumbHeight[]     = TEXT("ThumbHeight");
static TCHAR NEAR mszCurrentUnits[]    = TEXT("UnitSetting");

static TCHAR NEAR mszText[]            = TEXT("Text");
static TCHAR NEAR mszFaceName[]        = TEXT("TypeFaceName");
static TCHAR NEAR mszPointSize[]       = TEXT("PointSize");
static TCHAR NEAR mszCharSet[]         = TEXT("CharSet");
static TCHAR NEAR mszBold[]            = TEXT("Bold");
static TCHAR NEAR mszUnderline[]       = TEXT("Underline");
static TCHAR NEAR mszItalic[]          = TEXT("Italic");

static TCHAR NEAR mszVertEdit[]        = TEXT("VerticalEdit");

static TCHAR NEAR mszPositionX[]       = TEXT("PositionX");
static TCHAR NEAR mszPositionY[]       = TEXT("PositionY");
static TCHAR NEAR mszTextPen[]         = TEXT("TextPen");

static TCHAR NEAR mszColors[]          = TEXT("Colors");
static TCHAR NEAR mszNumberOfColors[]  = TEXT("NumberOfColors");

static TCHAR NEAR mszSoftware[]        = TEXT("Software");
static TCHAR NEAR mszWindowPlacement[] = TEXT("WindowPlacement");

/***************************************************************************/

void OpenAppKey(LPCTSTR pszKeyName, HKEY *phk)
{
        *phk = NULL;

        CRegKey rkSoftware;

        if (rkSoftware.Create(HKEY_CURRENT_USER, mszSoftware) != ERROR_SUCCESS)
        {
                return;
        }

        CString cszSubKey;

        if (!cszSubKey.LoadString(IDS_REGISTRY_PATH))
        {
                return;
        }

        CRegKey rkSubKey;

        if (rkSubKey.Create(rkSoftware, cszSubKey) != ERROR_SUCCESS)
        {
                return;
        }


        //
        // use the app's profile name instead of the
        // localizable app name
        //
        CRegKey rkAppKey;

        if (rkAppKey.Create(rkSubKey, theApp.m_pszProfileName) != ERROR_SUCCESS)
        {
                return;
        }

        if (RegOpenKey(rkAppKey, pszKeyName, phk) != ERROR_SUCCESS)
        {
                return;
        }
}

void CPBApp::LoadProfileSettings()
    {
    CWinApp::LoadStdProfileSettings( );

    BOOL bNoStretch = (BOOL)GetProfileInt( mszView, mszNoStretching, FALSE );

    g_bDriverCanStretch = ! bNoStretch;

    m_bShowThumbnail    = (BOOL)GetProfileInt( mszView, mszShowThumbnail  , FALSE  );

    g_bShowAllFiles     = (BOOL)GetProfileInt( mszView, mszShowAllFiles, FALSE );

    int iX = GetProfileInt( mszView, mszBMPWidth , 0 );
    int iY = GetProfileInt( mszView, mszBMPHeight, 0 );

    if (! iX || ! iY)
        {
        iX = 0;
        iY = 0;
        }
    m_sizeBitmap = CSize( iX, iY );

    HKEY hkView;

    OpenAppKey(mszView, &hkView);
    if (hkView)
    {
        DWORD dwType = REG_BINARY;
        DWORD dwSize = sizeof(m_wpPlacement);;

        if (RegQueryValueEx(hkView, mszWindowPlacement, 0, &dwType, (LPBYTE)&m_wpPlacement,
            &dwSize)!= ERROR_SUCCESS || dwType!=REG_BINARY || dwSize!=sizeof(m_wpPlacement))
        {
            memset((LPVOID)&m_wpPlacement, 0, sizeof(m_wpPlacement));
        }
        RegCloseKey(hkView);
    }

    int    iW;
    int    iH;
    CPoint ptPos;
    CSize  size;

    iX = GetProfileInt( mszView, mszThumbXPos  , 0 );
    iY = GetProfileInt( mszView, mszThumbYPos  , 0 );
    iW = GetProfileInt( mszView, mszThumbWidth , 0 );
    iH = GetProfileInt( mszView, mszThumbHeight, 0 );

    if (iX && iY && iW && iH)
        {
        size  = CSize( iW, iH );
        ptPos = CheckWindowPosition( CPoint( iX, iY ), size );
        m_rectFloatThumbnail = CRect( ptPos, size );
        }



    m_iCurrentUnits = GetProfileInt( mszView, mszCurrentUnits, 0 );

    m_bShowTextToolbar = (BOOL)GetProfileInt   ( mszText, mszShowText , TRUE );
    m_iPointSize       =       GetProfileInt   ( mszText, mszPointSize, 0 );
    m_iBoldText        =       GetProfileInt   ( mszText, mszBold     , 0 );
    m_iUnderlineText   =       GetProfileInt   ( mszText, mszUnderline, 0 );
    m_iItalicText      =       GetProfileInt   ( mszText, mszItalic   , 0 );

    m_iVertEditText    =       GetProfileInt   ( mszText, mszVertEdit, -1 );

    m_iPosTextX        =       GetProfileInt   ( mszText, mszPositionX, 0 );
    m_iPosTextY        =       GetProfileInt   ( mszText, mszPositionY, 0 );
    m_strTypeFaceName  =       GetProfileString( mszText, mszFaceName , NULL);

    m_iCharSet = GetProfileInt   ( mszText, mszCharSet  , -1 );
    if (m_iCharSet == -1)
    {
        CHARSETINFO csi;
        if (!TranslateCharsetInfo((DWORD*)UIntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE))
            csi.ciCharset=ANSI_CHARSET;
        m_iCharSet = csi.ciCharset;
    }

    m_iPenText = GetProfileInt   ( mszText, mszTextPen  , 0 );

    m_iSnapToGrid = GetProfileInt( mszView, mszSnapToGrid, 0 );
    m_iGridExtent = GetProfileInt( mszView, mszGridExtent, 1 );

    m_pColors = new COLORREF[16];

    if (m_pColors != NULL)
        {
        TCHAR szNumber[8];
        int  iColors = GetProfileInt( mszColors, mszNumberOfColors, 0 );

        for (int i = 0; i < iColors; i++)
            {
            _Itoa( i, szNumber, 10 );

            m_pColors[i] = (COLORREF)GetProfileInt( mszColors, szNumber, 0 );
            }
        m_iColors = i;
        }
    }

/***************************************************************************/

void CPBApp::SaveProfileSettings()
    {
    HKEY hkView;

    OpenAppKey(mszView, &hkView);
    if (hkView)
    {
        RegSetValueEx(hkView, mszWindowPlacement, 0, REG_BINARY, (LPBYTE)&m_wpPlacement,
            sizeof(m_wpPlacement));
        RegCloseKey(hkView);
    }

    WriteProfileInt( mszView, mszShowThumbnail  , m_bShowThumbnail );

    WriteProfileInt( mszView, mszBMPWidth       , m_sizeBitmap.cx );
    WriteProfileInt( mszView, mszBMPHeight      , m_sizeBitmap.cy );
    WriteProfileInt( mszView, mszThumbXPos      , m_rectFloatThumbnail.left );
    WriteProfileInt( mszView, mszThumbYPos      , m_rectFloatThumbnail.top );
    WriteProfileInt( mszView, mszThumbWidth     , m_rectFloatThumbnail.Width() );
    WriteProfileInt( mszView, mszThumbHeight    , m_rectFloatThumbnail.Height() );
    WriteProfileInt( mszView, mszCurrentUnits   , m_iCurrentUnits );
    WriteProfileInt( mszView, mszNoStretching   , ! g_bDriverCanStretch );

    WriteProfileInt( mszText, mszShowText   , m_bShowTextToolbar );
    WriteProfileInt( mszText, mszPointSize  , m_iPointSize );
    WriteProfileInt( mszText, mszPositionX  , m_iPosTextX );
    WriteProfileInt( mszText, mszPositionY  , m_iPosTextY );
    WriteProfileInt( mszText, mszBold       , m_iBoldText );
    WriteProfileInt( mszText, mszUnderline  , m_iUnderlineText );
    WriteProfileInt( mszText, mszItalic     , m_iItalicText );

    WriteProfileInt( mszText, mszVertEdit   , m_iVertEditText );

    WriteProfileInt( mszText, mszTextPen    , m_iPenText );
    WriteProfileString( mszText, mszFaceName, m_strTypeFaceName );
    WriteProfileInt( mszText, mszCharSet    , m_iCharSet );

    WriteProfileInt( mszView, mszSnapToGrid, m_iSnapToGrid);
    WriteProfileInt( mszView, mszGridExtent, m_iGridExtent);

    if (m_pColors != NULL)
        {
        TCHAR szNumber[8];
        int  iColor;

        WriteProfileInt( mszColors, mszNumberOfColors, m_iColors );

        for (int i = 0; i < m_iColors; i++)
            {
            iColor = (int)(m_pColors[i] & (COLORREF)0x00FFFFFF);
            _Itoa( i, szNumber, 10 );

            WriteProfileInt( mszColors, szNumber, iColor );
            }
        delete [] m_pColors;
        }
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\sprite.cpp ===
#include "stdafx.h"
#include "global.h"
#include "sprite.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG
IMPLEMENT_DYNAMIC( CDragger, CObject )
IMPLEMENT_DYNAMIC( CMultiDragger, CDragger )
IMPLEMENT_DYNAMIC(CSprite, CDragger)
#endif

#include "memtrace.h"

extern BOOL moduleInit;

  /**********************************************************************/
  /*                      CDragger Implementation                       */
  /**********************************************************************/

/*
 * OPTIMIZATION
 *
 * At the moment, draggers get a new DC whenever they need to draw or
 * erase.  We could cut that in half easily by merging the draw/erase
 * code, and achieve even better wins by allocating a single DC for a
 * multiple selection draw/erase.
 */

CDragger::CDragger( CWnd* pWnd, CRect* pRect )
    {
    ASSERT(pWnd != NULL);

    m_pWnd  = pWnd;
    m_state = hidden;

    m_rect.SetRect(0,0,0,0);

    if (pRect != NULL)
        m_rect = *pRect;
    }

CDragger::~CDragger()
    {
    if (m_pWnd->m_hWnd != NULL && m_state != hidden)
        Hide();
    }

/* CDragger::Draw
 *
 * This is a specialized Draw to draw our drag rectangles; drag
 * rectangles are the dotted rectangles which we draw when the user is
 * dragging a tracker to move or resize a control.
 */
void CDragger::Draw()
    {
    ASSERT( m_pWnd != NULL );

    CRect rect = m_rect;

    /*
     * This gets complex -- hold on to your hat.  The m_rect is
     * measured in client coordinates of the window, but since we
     * need to use GetWindowDC rather than GetDC (to avoid having
     * the m_rect clipped by the dialog's children) we must map
     * these coordinates to window coords.  We do this by mapping
     * them into screen coordinates, computing the offset from the
     * upper left corner of the dialog's WindowRect, and mapping
     * them back.  It's the most efficient way I can think to do
     * it; other suggestions are welcome.
     */
    CRect parentRect;

    m_pWnd->GetWindowRect( &parentRect );
    m_pWnd->ClientToScreen( &rect );

    rect.OffsetRect( -parentRect.left, -parentRect.top );

    // now we've got "rect" in the coordinates of the thing we
    // want to draw on.

    int dx = (rect.right - rect.left) - 1;
    int dy = (rect.bottom - rect.top) - 1;

    CDC* dc = m_pWnd->GetWindowDC();

    ASSERT( dc != NULL );

    CBrush* oldBrush = dc->SelectObject( GetHalftoneBrush() );

    dc->PatBlt( rect.left     , rect.top       , dx, 1 , PATINVERT );
    dc->PatBlt( rect.left     , rect.bottom - 1, dx, 1 , PATINVERT );
    dc->PatBlt( rect.left     , rect.top       , 1 , dy, PATINVERT );
    dc->PatBlt( rect.right - 1, rect.top       , 1 , dy, PATINVERT );

    dc->SelectObject( oldBrush );

    m_pWnd->ReleaseDC( dc );
    }

/* CDragger::Erase
 *
 * Since the default draw uses XOR, we can just Draw again to erase!
 */
void CDragger::Erase()
    {
    Draw();
    }

/* CDragger::Show, Hide
 *
 * The "drag rectangle" is the dotted rectangle which we draw when the
 * user is moving or resizing a control by dragging it with the mouse.
 * These functions erase and draw the drag rectangle, respectively.
 */
void CDragger::Hide()
    {
    if (m_state != shown)
        return;

    m_state = hidden;
    Erase();
    }

void CDragger::Show()
    {
    if (m_state != hidden)
        return;

    m_state = shown;
    Draw();
    }


void CDragger::Obscure( BOOL bObscure )
    {
    if (bObscure)
        {
        if (m_state != shown)
            return;

        Hide();
        m_state = obscured;
        }
    else
        {
        if (m_state != obscured)
            return;

        m_state = hidden;
        Show();
        }
    }

/* CDragger::Move
 *
 * Since nearly every single occurance of "CDragger->Show" occurred in
 * the context "Hide, m_rect = foo, Show", I decided to merge this
 * functionality into a single C++ function.
 */
void CDragger::Move(const CRect& newRect, BOOL bForceShow)
    {
    if ((m_rect == newRect) && !bForceShow)
        return;

    BOOL fShow = bForceShow || m_state == shown;
    Hide();
    m_rect = newRect;

    if (fShow)
        Show();
    }

void CDragger::MoveBy(int cx, int cy, BOOL bForceShow)
    {
    CSize offset (cx, cy);
    CPoint newTopLeft = m_rect.TopLeft() + offset;
    Move(newTopLeft, bForceShow);
    }

CRect CDragger::GetRect() const
    {
    return m_rect;
    }

void CDragger::Move(const CPoint& newTopLeft, BOOL bForceShow)
    {
    Move(m_rect - m_rect.TopLeft() + newTopLeft, bForceShow);
    }

void CDragger::SetSize(const CSize& newSize, BOOL bForceShow)
    {
    CRect newRect  = m_rect;
    newRect.right  = newRect.left + newSize.cx;
    newRect.bottom = newRect.top  + newSize.cy;

    Move(newRect, bForceShow);
    }

CMultiDragger::CMultiDragger() : m_draggerList()
    {
    ASSERT( m_draggerList.IsEmpty() );
    }

CMultiDragger::CMultiDragger(CWnd *pWnd) : CDragger(pWnd), m_draggerList()
    {
    ASSERT(m_draggerList.IsEmpty());
    }


CMultiDragger::~CMultiDragger()
    {
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger *pDragger = (CDragger*) m_draggerList.GetNext(pos);
        delete pDragger;
        }
    }

CRect CMultiDragger::GetRect() const
    {
    // accumulate the bounding rectangle for the group
    POSITION pos = m_draggerList.GetHeadPosition();

    CRect boundRect (32767, 32767, -32767, -32767);
    while (pos != NULL)
        {
        CDragger    *pDragger = (CDragger*) m_draggerList.GetNext(pos);
        boundRect.left  = min (boundRect.left, pDragger->m_rect.left);
        boundRect.right = max (boundRect.right, pDragger->m_rect.right);
        boundRect.top   = min (boundRect.top, pDragger->m_rect.top);
        boundRect.bottom= max (boundRect.bottom, pDragger->m_rect.bottom);
        }

    return boundRect;
    }

void CMultiDragger::Hide()
    {
    // hide each dragger on the list
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->Hide();
        }
    }

void CMultiDragger::Show()
    {
    // show each dragger on the list
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->Show();
        }
    }

void CMultiDragger::Draw()
    {
    // draw each dragger on the list
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->Draw();
        }
    }

void CMultiDragger::Erase()
    {
    // erase each dragger on the list
    POSITION pos = m_draggerList.GetHeadPosition();

    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->Erase();
        }
    }

void CMultiDragger::Move(const CPoint& newTopLeft, BOOL bForceShow)
    {
    // move each dragger to the new top left

    // first go through the list and find the current topmost leftmost
    // point

    CPoint  topLeft (32767, 32767);
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        CRect   draggerRect = pDragger->GetRect();
        if (draggerRect.left < topLeft.x)
            topLeft.x= draggerRect.left;
        if (draggerRect.top < topLeft.y)
            topLeft.y= draggerRect.top;
        }

    // now find the offset and move each dragger
    CSize   offset = newTopLeft - topLeft;
    pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->MoveBy(offset.cx, offset.cy, bForceShow);
        }
    }

void CMultiDragger::Add(CDragger *pDragger)
    {
    // add the dragger to the list
    ASSERT(pDragger != NULL);
    m_draggerList.AddTail(pDragger);
    }

void CMultiDragger::Remove(CDragger *pDragger)
    {
    // remove the dragger from the list
    ASSERT(pDragger != NULL);
    POSITION pos = m_draggerList.Find(pDragger);
    if (pos != NULL)
        m_draggerList.RemoveAt(pos);
    }


CSprite::CSprite() : m_saveBits()
    {
    m_state = hidden;
    m_pWnd = NULL;
    }


CSprite::CSprite(CWnd* pWnd, CRect* pRect)
        : CDragger(pWnd, pRect), m_saveBits()
    {
    m_state = hidden;
    m_pWnd = pWnd;
    }


CSprite::~CSprite()
    {
    if (m_pWnd->m_hWnd != NULL && m_state != hidden)
        Hide();
    }


void CSprite::Move(const CRect& newRect, BOOL bForceShow)
    {
    CRect rect = newRect;

    if ((rect == m_rect) && !bForceShow)
        return;

    STATE oldState = m_state;
    Hide();
    if (newRect.Size() != m_rect.Size())
        m_saveBits.DeleteObject();
    m_rect = rect;
    if (bForceShow || oldState == shown)
        Show();
    }

void CSprite::SaveBits()
    {
    CClientDC dcWnd(m_pWnd);
    CDC dcSave;
    CBitmap* pOldBitmap;

    dcSave.CreateCompatibleDC(&dcWnd);
    if (m_saveBits.m_hObject == NULL)
        {
        m_saveBits.CreateCompatibleBitmap(&dcWnd, m_rect.Width(),
            m_rect.Height());
        }
    pOldBitmap = dcSave.SelectObject(&m_saveBits);
    dcSave.BitBlt(0, 0, m_rect.Width(), m_rect.Height(),
        &dcWnd, m_rect.left, m_rect.top, SRCCOPY);
    dcSave.SelectObject(pOldBitmap);
    }


void CSprite::Erase()
    {
    if (m_saveBits.m_hObject == NULL)
        return;

    LONG dwStyle = ::GetWindowLong(m_pWnd->m_hWnd, GWL_STYLE);
    ::SetWindowLong(m_pWnd->m_hWnd, GWL_STYLE, dwStyle & ~WS_CLIPCHILDREN);

    CClientDC dcWnd(m_pWnd);
    CDC dcSave;
    CBitmap* pOldBitmap;

    dcSave.CreateCompatibleDC(&dcWnd);
    pOldBitmap = dcSave.SelectObject(&m_saveBits);
    dcWnd.ExcludeUpdateRgn(m_pWnd);
    dcWnd.BitBlt(m_rect.left, m_rect.top, m_rect.Width(), m_rect.Height(),
        &dcSave, 0, 0, SRCCOPY);
    dcSave.SelectObject(pOldBitmap);

    ::SetWindowLong(m_pWnd->m_hWnd, GWL_STYLE, dwStyle);
    }


CHighlight::CHighlight()
    {
    m_bdrSize = 2;
    }


CHighlight::CHighlight(CWnd *pWnd, CRect *pRect, int bdrSize)
           : CDragger(pWnd, pRect)
    {
    m_bdrSize = bdrSize;
    m_rect.InflateRect(m_bdrSize, m_bdrSize);
    }

CHighlight::~CHighlight()
    {
    if (m_pWnd->m_hWnd != NULL && m_state != hidden)
        Hide();
    }


void CHighlight::Draw()
    {
    m_pWnd->UpdateWindow();

    CClientDC   dc(m_pWnd);
    CBrush      *pOldBrush  = dc.SelectObject(GetSysBrush(COLOR_HIGHLIGHT));

    // draw the top, right, bottom and left sides
    dc.PatBlt(m_rect.left    + m_bdrSize, m_rect.top                 ,
              m_rect.Width() - m_bdrSize, m_bdrSize                  , PATCOPY);
    dc.PatBlt(m_rect.right - m_bdrSize  , m_rect.top + m_bdrSize     ,
              m_bdrSize                 , m_rect.Height() - m_bdrSize, PATCOPY);
    dc.PatBlt(m_rect.left               , m_rect.bottom - m_bdrSize  ,
              m_rect.Width() - m_bdrSize, m_bdrSize                  , PATCOPY);
    dc.PatBlt(m_rect.left               , m_rect.top                 ,
              m_bdrSize                 , m_rect.Height() - m_bdrSize, PATCOPY);

    // restore the state of the DC
    dc.SelectObject(pOldBrush);
    }

void CHighlight::Erase()
    {
    m_pWnd->InvalidateRect(&m_rect);
    m_pWnd->UpdateWindow();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\srvritem.h ===
// srvritem.h : interface of the CPBSrvrItem class
//

class CPBSrvrItem : public COleServerItem
    {
    DECLARE_DYNAMIC(CPBSrvrItem)

    // Constructors
    public:

    CPBSrvrItem(CPBDoc* pContainerDoc, CBitmapObj* pBM = NULL);

    // Attributes
    CPBDoc* GetDocument() const { return (CPBDoc*)COleServerItem::GetDocument(); }

    // Implementation
    public:

    CBitmapObj* m_pBitmapObj;

    ~CPBSrvrItem();

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    #endif

    virtual BOOL OnDraw(CDC* pDC, CSize& rSize);
    virtual BOOL OnGetExtent( DVASPECT dwDrawAspect, CSize& rSize );
    virtual BOOL OnSetExtent( DVASPECT nDrawAspect, const CSize& size );
    virtual void OnOpen( void );
    virtual void OnShow( void );
    virtual void OnHide( void );
    virtual BOOL OnRenderGlobalData( LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal );
	virtual BOOL OnRenderFileData( LPFORMATETC lpFormatEtc, CFile* pFile );
	virtual COleDataSource* OnGetClipboardData( BOOL bIncludeLink,
                                                CPoint* pptOffset, CSize *pSize );
   
    protected:

    virtual void Serialize(CArchive& ar);   // overridden for document i/o
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
#include <afxcmn.h>         // for tooltips
#include <afxwin.h>         // MFC core and standard components
#include <objbase.h>
#include <afxext.h>         // MFC extensions (including VB)
#include <afxole.h>         // MFC OLE classes
#include <afxpriv.h>

#include <sti.h>
#include <wia.h>
#include <wiadevdp.h>

#include <gdiplus/gdiplus.h>

#include <UxTheme.h>
#include <TmSchema.h>

#include "bar.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\srvritem.cpp ===
// srvritem.cpp : implementation of the CPBSrvrItem class
//

#include "stdafx.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "srvritem.h"
#include "bmobject.h"
#include "docking.h"
#include "minifwnd.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "imgcolor.h"
#include "tracker.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CPBSrvrItem, COleServerItem)

#include "memtrace.h"

/***************************************************************************/
// CPBSrvrItem implementation

CPBSrvrItem::CPBSrvrItem( CPBDoc* pContainerDoc, CBitmapObj* pBM )
                : COleServerItem( pContainerDoc, TRUE )
{
        if (pBM)
        {
                m_pBitmapObj = pBM;
        }
        else
        {
                pBM = pContainerDoc->m_pBitmapObj;

                m_pBitmapObj = NULL;
        }

        if (pBM && pBM->m_pImg)
        {
                COleDataSource* oleDataSrc = GetDataSource();

                // support CF_DIB format
                oleDataSrc->DelayRenderFileData( CF_DIB );
                oleDataSrc->DelayRenderData( CF_BITMAP );

                if (pBM->m_pImg->m_pPalette != NULL)
                {
                        oleDataSrc->DelayRenderData( CF_PALETTE );
                }
        }
}

/***************************************************************************/

CPBSrvrItem::~CPBSrvrItem()
{
        // TODO: add cleanup code here
        if (m_pBitmapObj)
        {
                delete m_pBitmapObj;
        }
}

/***************************************************************************/

void CPBSrvrItem::Serialize(CArchive& ar)
    {
    // CPBSrvrItem::Serialize will be called by the framework if
    //  the item is copied to the clipboard.  This can happen automatically
    //  through the OLE callback OnGetClipboardData.  A good default for
    //  the embedded item is simply to delegate to the document's Serialize
    //  function.  If you support links, then you will want to serialize
    //  just a portion of the document.

    // IsLinkedItem always returns TRUE even though we don't support links,
    // so I am just removing the check
    // if (! IsLinkedItem())
        {
        CPBDoc* pDoc = GetDocument();
        ASSERT_VALID(pDoc);

        CBitmapObj* pBMCur = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;
        CBitmapObj* pBMNew = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObjNew;

        pDoc->SerializeBitmap( ar, pBMCur, pBMNew, TRUE );
        }
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize)
    {
    // Most applications, like this one, only handle drawing the content
    //  aspect of the item.  If you wish to support other aspects, such
    //  as DVASPECT_THUMBNAIL (by overriding OnDrawEx), then this
    //  implementation of OnGetExtent should be modified to handle the
    //  additional aspect(s).

    if (dwDrawAspect != DVASPECT_CONTENT)
        return COleServerItem::OnGetExtent(dwDrawAspect, rSize);

    // CPBSrvrItem::OnGetExtent is called to get the extent in
    //  HIMETRIC units of the entire item.  The default implementation
    //  here simply returns a hard-coded number of units.

    CPBDoc* pDoc = GetDocument();

    ASSERT_VALID( pDoc );

    CBitmapObj* pBM = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;

    if (pBM         != NULL
    &&  pBM->m_pImg != NULL)
        {
       //
       // What was the padding for?
       //
        rSize.cx = pBM->m_pImg->cxWidth ;// + GetSystemMetrics( SM_CXBORDER ) + CTracker::HANDLE_SIZE * 2;
        rSize.cy = pBM->m_pImg->cyHeight;// + GetSystemMetrics( SM_CYBORDER ) + CTracker::HANDLE_SIZE * 2;

        CDC* pDC = CDC::FromHandle( pBM->m_pImg->hDC );

        if (pDC != NULL)
            {
            pDC->DPtoHIMETRIC( &rSize );
            }
        else /* punt */
            {
            rSize.cx = (int)(((long)rSize.cx * 10000L) / (long)theApp.ScreenDeviceInfo.ixPelsPerDM);
            rSize.cy = (int)(((long)rSize.cy * 10000L) / (long)theApp.ScreenDeviceInfo.iyPelsPerDM);
            }
        }
    else
        rSize = CSize( 3000, 3000 );

    return TRUE;
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnSetExtent( DVASPECT nDrawAspect, const CSize& size )
    {
    TRACE( TEXT("MSPaint OnSetExtent %d %d\n"), size.cx, size.cy );

    return COleServerItem::OnSetExtent( nDrawAspect, size );
    }

/***************************************************************************/

void CPBSrvrItem::OnOpen()
    {
    CPBDoc* pDoc = (CPBDoc*)GetDocument();

        if (theApp.m_bLinked)
            {
        theApp.m_bHidden = FALSE;

        if (g_pDragBrushWnd != NULL)
            HideBrush();

        g_pDragBrushWnd = NULL;
        g_pMouseImgWnd  = NULL;
        fDraggingBrush  = FALSE;

        POSITION pos = pDoc->GetFirstViewPosition();
        CPBView* pView = (CPBView*)(pDoc->GetNextView( pos ));

        if (pView != NULL)
            {
            pView->SetTools();
            }
        }
    COleServerItem::OnOpen();
    }

/***************************************************************************/

void CPBSrvrItem::OnShow()
    {
    theApp.m_bHidden = FALSE;

    COleServerItem::OnShow();
    }

/***************************************************************************/

void CPBSrvrItem::OnHide()
    {
    theApp.m_bHidden = TRUE;

    g_pMouseImgWnd = NULL;

    if (g_pDragBrushWnd != NULL)
        HideBrush();

    COleServerItem::OnHide();
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnDraw(CDC* pDC, CSize& rSize)
    {
    CPBDoc* pDoc = GetDocument();

    ASSERT_VALID(pDoc);

    CBitmapObj* pBM = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;

    if (pBM != NULL)
        {
        CDC* pDCBitmap = CDC::FromHandle( pBM->m_pImg->hDC );

        if (pDCBitmap != NULL)
            {
            CSize size( pBM->m_pImg->cxWidth,
                        pBM->m_pImg->cyHeight );

                size.cy = -size.cy;

            pDC->SetMapMode  ( MM_ANISOTROPIC );
            pDC->SetWindowExt( size );
            pDC->SetWindowOrg( 0, 0 );

            CPalette* ppalOld = NULL;

            if (pBM->m_pImg->m_pPalette != NULL)
                {
                ppalOld = pDC->SelectPalette( pBM->m_pImg->m_pPalette, FALSE ); // Background ??

                pDC->RealizePalette();
                }

            pDC->StretchBlt( 0, 0, size.cx, size.cy, pDCBitmap,
                             0, 0, pBM->m_pImg->cxWidth,
                                   pBM->m_pImg->cyHeight, SRCCOPY );

            if (pBM->m_pImg->m_pPalette != NULL)
                pDC->SelectPalette( ppalOld, FALSE ); // Background ??
            }
        }
    return TRUE;
    }

/***************************************************************************/

COleDataSource* CPBSrvrItem::OnGetClipboardData( BOOL bIncludeLink,
                                                 CPoint* pptOffset,
                                                 CSize *pSize )
    {
    ASSERT_VALID( this );

    COleDataSource* pDataSource = new COleDataSource;

    TRY
        {
        GetClipboardData( pDataSource, bIncludeLink, pptOffset, pSize );
        }
    CATCH_ALL( e )
        {
        delete pDataSource;

        THROW_LAST();
        }
    END_CATCH_ALL

    ASSERT_VALID( pDataSource );

    return pDataSource;
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnRenderGlobalData( LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal )
    {
        ASSERT( lpFormatEtc != NULL );

        BOOL bResult = FALSE;

    CPBDoc* pDoc = GetDocument();

    ASSERT_VALID( pDoc );

    CBitmapObj* pBM = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;

    if ((lpFormatEtc->cfFormat == CF_BITMAP
      || lpFormatEtc->cfFormat == CF_PALETTE)
    && pBM != NULL)
        {
        if (lpFormatEtc->cfFormat == CF_BITMAP)
            {
            }
        else // CF_PALETTE
            {
            }
        }
    else
        bResult = COleServerItem::OnRenderGlobalData( lpFormatEtc, phGlobal );

    return bResult;
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnRenderFileData( LPFORMATETC lpFormatEtc, CFile* pFile )
    {
        ASSERT( lpFormatEtc != NULL );

        BOOL bResult = FALSE;

    CPBDoc* pDoc = GetDocument();

    ASSERT_VALID( pDoc );

    CBitmapObj* pBM = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;

    if (lpFormatEtc->cfFormat == CF_DIB && pBM != NULL)
        {
        TRY
            {
            // save as dib
            pBM->SaveResource( FALSE );
            pBM->WriteResource( pFile, CBitmapObj::rtDIB );
            bResult = TRUE;
            }
        CATCH( CFileException, ex )
            {
            theApp.SetFileError( IDS_ERROR_SAVE, ex->m_cause );
            return FALSE;
            }
        END_CATCH
        }
    else
        bResult = COleServerItem::OnRenderFileData( lpFormatEtc, pFile );

        return bResult;
    }

/***************************************************************************/
// CPBSrvrItem diagnostics

#ifdef _DEBUG
void CPBSrvrItem::AssertValid() const
    {
    COleServerItem::AssertValid();
    }

/***************************************************************************/

void CPBSrvrItem::Dump(CDumpContext& dc) const
    {
    COleServerItem::Dump(dc);
    }
#endif

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\tedit.cpp ===
/******************************************************************************/
/* Tedit.CPP: IMPLEMENTATION OF THE CTedit CLASS                              */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  Edit Control Object                                                       */
/*      CAttrEdit::OnPaint                                                   */
/*      CAttrEdit::OnEraseBkgnd                                               */
/*      CAttrEdit::OnRButtonDown                                              */
/*      CAttrEdit::OnChar                                                     */
/*      CAttrEdit::OnMouseMove                                                */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  Text Edit Control Parent Window (Parent of Edit Control)                  */
/*      CTedit::CTedit                                                        */
/*      CTedit::CTedit                                                        */
/*      CTedit::~CTedit                                                       */
/*                                                                            */
/*  Miscellaneous Methods                                                     */
/*      CTedit::RefreshWindow                                                 */
/*      CTedit::SetTextColor                                                  */
/*      CTedit::SetBackColor                                                  */
/*      CTedit::SetTransparentMode                                            */
/*      CTedit::Undo                                                          */
/*      CTedit::ShowFontPalette                                               */
/*      CTedit::IsFontPaletteVisible                                          */
/*      CTedit::GetBitmap                                                     */
/*      CTedit::PostNcDestroy                                                 */
/*      CTedit::GetDefaultMinSize                                             */
/*                                                                            */
/*  Edit Control Notification and processing methods                          */
/*      CTedit::OnAttrEditEnChange                                            */
/*      CTedit::OnAttrEditFontChange                                          */
/*                                                                            */
/*  Control Notification/Window Messages                                      */
/*      CTedit::OnEraseBkgnd                                                  */
/*      CTedit::OnSize                                                        */
/*      CTedit::OnMove                                                        */
/*      CTedit::OnCtlColor                                                    */
/*      CTedit::OnNcCalcSize                                                  */
/*      CTedit::OnNcPaint                                                     */
/*      CTedit::OnNcHitTest                                                   */
/*      CTedit::OnRButtonDown                                                 */
/*                                                                            */
/*  Popup Menu Control Notification/Window Messages                           */
/*      CTedit::OnTextPlain                                                   */
/*      CTedit::OnTextBold                                                    */
/*      CTedit::OnTextItalic                                                  */
/*      CTedit::OnTextUnderline                                               */
/*      CTedit::OnTextSelectfont                                              */
/*      CTedit::OnTextSelectpointsize                                         */
/*      CTedit::OnEditCut                                                     */
/*      CTedit::OnEditCopy                                                    */
/*      CTedit::OnEditPaste                                                   */
/*      CTedit::OnTextDelete                                                  */
/*      CTedit::OnTextSelectall                                               */
/*      CTedit::OnTextPlace                                                   */
/*      CTedit::OnTextTexttool                                                */
/*                                                                            */
/*      CTedit::OnUpdateTextPlain                                             */
/*      CTedit::OnUpdateTextBold                                              */
/*      CTedit::OnUpdateTextItalic                                            */
/*      CTedit::OnUpdateTextUnderline                                         */
/*      CTedit::OnUpdateTextTexttool                                          */
/*                                                                            */
/******************************************************************************/

// TEDIT.CPP: IMPLEMENTATION OF THE CTEDIT CLASS
//
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusvw.h"
#include "pbrusfrm.h"
#include "imgwnd.h"
#include "pictures.h"
#include "minifwnd.h"
#include "tfont.h"
#include "tedit.h"
#include "tracker.h"

#include <imm.h>

#include "imgsuprt.h"

#ifndef WM_SYSTIMER
#define WM_SYSTIMER     0x118
#endif //WM_SYSTIMER


#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CAttrEdit, CEdit )
IMPLEMENT_DYNCREATE( CTedit, CWnd )

#include "memtrace.h"




/******************************************************************************/
// CAttrEdit

BEGIN_MESSAGE_MAP( CAttrEdit, CEdit )
    //{{AFX_MSG_MAP(CAttrEdit)
    ON_WM_PAINT()
    ON_WM_ERASEBKGND()
    ON_WM_RBUTTONDOWN()
    ON_WM_CHAR()

    ON_MESSAGE(WM_IME_CHAR, OnImeChar)
    ON_MESSAGE(WM_IME_COMPOSITION, OnImeComposition)
    ON_MESSAGE(WM_INPUTLANGCHANGE, OnInputLangChange)
    ON_WM_KILLFOCUS()


    ON_WM_NCHITTEST()
    ON_WM_SETFOCUS()
    ON_WM_SIZE()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_LBUTTONDOWN()
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_KEYDOWN()
    ON_MESSAGE(WM_SYSTIMER, OnSysTimer)

        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/

CAttrEdit::CAttrEdit()
    {
    m_bBackgroundTransparent = TRUE;
    m_pParentWnd             = NULL;
    m_uiLastChar[0] = 32;
    m_uiLastChar[1] = 32;

    m_rectUpdate.SetRectEmpty();


    m_strResult.Empty();
    m_bMouseDown = FALSE;
    m_hHCursor = theApp.LoadStandardCursor( IDC_IBEAM );
    m_hVCursor = theApp.LoadCursor( IDCUR_HIBEAM );
    m_hOldCursor = NULL;
    m_rectFmt.SetRectEmpty();
    m_iPrevStart = -1;
    m_bResizeOnly = FALSE;

    }

/******************************************************************************/

void CAttrEdit::OnPaint()
    {
    GetUpdateRect( &m_rectUpdate );


    if ( !m_pParentWnd->m_bVertEdit )
        {
        Default();
        return;
        }
    else
        {
        CFont*      pFont;
        CFont*      pOldFont = NULL;
        CPalette*   ppalOld = NULL;
        int         OldBkMode;
        COLORREF    OldTxtColor;
        CRect       rc = m_rectFmt;
        int         cnt = 0;
        int         i = 0, h = 0;
        int         nLen;
        CString     cStr;
        LPTSTR      lpStr;
        int         nStart, nEnd;
        CDC*        pDC = NULL;
        PAINTSTRUCT ps;

        const MSG *pCurrentMessage = GetCurrentMessage();
        //wParam is DC
        if ( pCurrentMessage->wParam )
            {
            HDC     hDC = (HDC) pCurrentMessage->wParam;
            pDC = CDC::FromHandle( hDC );
            }
        else
            pDC = BeginPaint( &ps );

        if (pDC == NULL || pDC->m_hDC == NULL)
            {
            theApp.SetGdiEmergency();
            return;
            }

        OldBkMode = pDC->GetBkMode();
        OldTxtColor = pDC->GetTextColor();
        ppalOld = PBSelectPalette(pDC, theApp.m_pPalette, FALSE);

        m_pParentWnd->SendMessage( WM_CTLCOLOREDIT, (WPARAM)pDC->m_hDC,
                                   (LPARAM) m_hWnd );

        pFont = GetFont();
        pOldFont = pDC->SelectObject( pFont );

        h = m_pParentWnd->m_iLineHeight;

        cnt = GetLineCount();

        GetSel( nStart, nEnd );
        if ( nStart == nEnd )
            {
            for ( i = 0; i < cnt; i++ )
                {
                nLen = LineLength( LineIndex( i ) );
                lpStr = cStr.GetBufferSetLength( nLen );
                GetLine( i, lpStr, nLen );
                TabTextOut( pDC, LineIndex( i ), rc.right - h * i, 0,
                            (LPTSTR)lpStr, nLen, FALSE );
                }
            }
        else
            {
            int nStartLn, nEndLn;
            int nMaxText = GetWindowTextLength();
            int nChar = 0;

            nStartLn = LineFromChar( nStart );
            nEndLn   = LineFromChar( nEnd );

            //Before Start
            for ( i = 0; i < nStartLn; i++ )
                {
                nLen = LineLength( LineIndex( i ) );
                lpStr = cStr.GetBufferSetLength( nLen );
                GetLine( i, lpStr, nLen );
                TabTextOut( pDC, LineIndex( i ), rc.right - h * i, 0,
                            (LPTSTR)lpStr, nLen, FALSE );
                nChar = LineIndex( i + 1 );
                }
            nLen = LineLength( LineIndex( i ) );
            lpStr = cStr.GetBufferSetLength( nLen );
            GetLine( i, lpStr, nLen );
            TabTextOut( pDC, LineIndex( i ), rc.right - h * i, 0,
                        (LPTSTR)lpStr, nStart - nChar, FALSE );

            //Selected Text
            COLORREF bkColor  = pDC->SetBkColor( GetSysColor(COLOR_HIGHLIGHT) );
            COLORREF txtColor = pDC->SetTextColor( GetSysColor(COLOR_HIGHLIGHTTEXT) );
            int      bkMode   = pDC->SetBkMode( OPAQUE );

            CPoint ptStart( (DWORD)SendMessage( EM_POSFROMCHAR, nStart ) );
            if ( nStartLn == nEndLn )
                {
                TabTextOut( pDC, nStart, rc.right - h * i, ptStart.x,
                            (LPTSTR)lpStr + (nStart - nChar), nEnd - nStart, TRUE );
                }
            else
                {
                TabTextOut( pDC, nStart, rc.right - h * i, ptStart.x,
                            (LPTSTR)lpStr + (nStart - nChar), nLen + nChar - nStart, TRUE );
                nChar = LineIndex( i + 1 );

                for ( i++; i < nEndLn; i++ )
                    {
                    nLen = LineLength( LineIndex( i ) );
                    lpStr = cStr.GetBufferSetLength( nLen );
                    GetLine( i, lpStr, nLen );
                    TabTextOut( pDC, nChar, rc.right - h * i, 0,
                                (LPTSTR)lpStr, nLen, TRUE );
                    nChar = LineIndex( i + 1 );
                    }

                nLen = LineLength( LineIndex( i ) );
                lpStr = cStr.GetBufferSetLength( nLen );
                GetLine( i, lpStr, nLen );
                TabTextOut( pDC, nChar, rc.right - h * i, 0,
                            (LPTSTR)lpStr, nEnd - nChar, TRUE );
                }

            pDC->SetBkColor( bkColor );
            pDC->SetTextColor( txtColor );
            pDC->SetBkMode( bkMode );

            //After End
            if ( nEnd < nMaxText )
                {
                CPoint ptEnd( (DWORD)SendMessage( EM_POSFROMCHAR, nEnd ) );
                TabTextOut( pDC, nEnd, rc.right - h * i, ptEnd.x,
                            (LPTSTR)lpStr + (nEnd - nChar), nChar + nLen - nEnd, FALSE );
                for ( i++; i < cnt; i++ )
                    {
                    nLen = LineLength( LineIndex( i ) );
                    lpStr = cStr.GetBufferSetLength( nLen );
                    GetLine( i, lpStr, nLen );
                    TabTextOut( pDC, LineIndex( i ), rc.right - h * i, 0,
                                (LPTSTR)lpStr, nLen, FALSE );
                    }
                }
            }

        cStr.Empty();

        if (pOldFont)   pDC->SelectObject( pOldFont );
        if (ppalOld)    pDC->SelectPalette( ppalOld, FALSE );
        pDC->SetBkMode( OldBkMode );
        pDC->SetTextColor( OldTxtColor );

        if ( !pCurrentMessage->wParam )
            EndPaint( &ps );
        }
    }

/******************************************************************************/

BOOL CAttrEdit::OnEraseBkgnd( CDC* pDC )
    {
    if (m_pParentWnd == NULL)
        return CEdit::OnEraseBkgnd( pDC );

    ASSERT( m_pParentWnd->m_pImgWnd->m_pImg      != NULL );
    ASSERT( m_pParentWnd->m_pImgWnd->m_pImg->hDC != NULL );

    CPalette* ppalOld = NULL;

    if (m_rectUpdate.IsRectEmpty())
        {
        if (! GetUpdateRect( &m_rectUpdate, FALSE ))
            GetClientRect( &m_rectUpdate );

        ValidateRect( &m_rectUpdate );
        }
    CRect destRect = m_rectUpdate;

    ClientToScreen( &m_rectUpdate );

    m_pParentWnd->m_pImgWnd->ScreenToClient( &m_rectUpdate );

    ppalOld = PBSelectPalette(pDC, theApp.m_pPalette, FALSE);

    if (m_bBackgroundTransparent)
        m_pParentWnd->m_pImgWnd->DrawImage( pDC, &m_rectUpdate, &destRect );
    else
        pDC->FillRect( &destRect, &m_pParentWnd->m_hbrBkColor );

    if (ppalOld)
        pDC->SelectPalette( ppalOld, FALSE );

    m_rectUpdate.SetRectEmpty();

    return TRUE;
    }

/******************************************************************************/

void CAttrEdit::OnRButtonDown(UINT nFlags, CPoint point)
    {
    const MSG *pCurrentMessage = GetCurrentMessage();

    m_pParentWnd->SendMessage( pCurrentMessage->message,
                               pCurrentMessage->wParam,
                               pCurrentMessage->lParam);
    }

/******************************************************************************/

void CAttrEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{

    m_uiLastChar[0] = m_uiLastChar[1];

#ifndef UNICODE
    //
    // For DBCS we have to peek for the trail byte if the current
    // byte is a lead byte
    //
    if (IsDBCSLeadByte((BYTE)nChar))
    {
       MSG msg;
       ZeroMemory (&msg, sizeof(msg));
       ::PeekMessage (&msg, m_hWnd, WM_CHAR, WM_CHAR, PM_NOREMOVE);
       m_uiLastChar[1] = (UINT)MAKEWORD((BYTE)msg.wParam, (BYTE)nChar);
    }
    else
#endif // UNICODE
       m_uiLastChar[1] = nChar;


    if ( m_pParentWnd->m_bVertEdit )
       {
       SetCaretPosition( TRUE, NULL, -1 );
       UpdateInput();
       HideCaret();
       }

    CEdit::OnChar( nChar, nRepCnt, nFlags );

    if ( m_pParentWnd->m_bVertEdit )
       {
       SetCaretShape();
       UpdateInput();
       ShowCaret();
       }


    BOOL bRefresh = FALSE;

    switch (nChar)
        {
        case VK_BACK:
        case VK_DELETE:
        case VK_INSERT:
            bRefresh = TRUE;

            break;
        }

    if (bRefresh)
        m_pParentWnd->RefreshWindow(); /* enhance to do only the character involved */


     //
     // The edit control may have to resize
     //
     m_bResizeOnly = TRUE;
     m_pParentWnd->OnEnMaxText ();
     m_bResizeOnly = FALSE;

}


/******************************************************************************/

LRESULT CAttrEdit::OnInputLangChange( WPARAM wParam, LPARAM lParam )
{
    LRESULT lRet = Default();

    if ( m_pParentWnd->m_bVertEdit )
    {
        SetCaretPosition( TRUE, NULL, -1 );
    }
    return lRet;
}

/******************************************************************************/

LRESULT CAttrEdit::OnImeChar( WPARAM wParam, LPARAM lParam )
    {



        if ( m_pParentWnd->m_bVertEdit )
            {
            SetCaretPosition( TRUE, NULL, -1 );
            UpdateInput();
            HideCaret();
            }


            return Default();

    }

/******************************************************************************/

LRESULT CAttrEdit::OnImeComposition( WPARAM wParam, LPARAM lParam )
    {
    // Use Faster Way undr Japanese Keyboard Layout (Japanese IME)
    // Japanese IME may generate lots of chars at one time.
    // This way is better than waiting WM_CHAR.

    DWORD dwKeyboardLayout = PRIMARYLANGID(LOWORD(GetKeyboardLayout(0)));

    if ( dwKeyboardLayout == LANG_JAPANESE)
        {
        if (lParam & GCS_RESULTSTR)
            {
            HIMC hIMC = ImmGetContext(m_hWnd);

            DWORD dwSize;
            if (hIMC &&
                (dwSize = ImmGetCompositionString(hIMC,GCS_RESULTSTR,NULL,0L)))
                {
                    // ImmGetCompositionString returns the buffer size, IN BYTES.
                    // even if Unicode version.
                    LPTSTR lp = m_strResult.GetBufferSetLength(dwSize);
                    ImmGetCompositionString(hIMC,GCS_RESULTSTR,lp,dwSize+sizeof(TCHAR));
                    *(lp + dwSize/sizeof(TCHAR)) = TEXT('\0');
                    ReplaceSel(lp);
                    m_strResult.Empty();
                }

            ImmReleaseContext(m_hWnd, hIMC);

            lParam &= ~( GCS_RESULTREADSTR | GCS_RESULTREADCLAUSE | GCS_RESULTSTR | GCS_RESULTCLAUSE);
            if (lParam)
                DefWindowProc(WM_IME_COMPOSITION,wParam,lParam);

            // We'are not sure, how IME hide its composiiton window.
            m_pParentWnd->RefreshWindow();
            return 0;
            }
        }
    else if ( dwKeyboardLayout == LANG_KOREAN)
        {
        if ( m_pParentWnd->m_bVertEdit ) {

           Default();

           SetCaretPosition( FALSE, NULL, -2);

           // We should update current composition string.
           UpdateInput();
           return 0;
        }
        else {
           // We should update current composition string.
           UpdateInput();
               return Default();
        }
    }

    return Default();
    }

/******************************************************************************/

void CAttrEdit::OnKillFocus(CWnd* pNewWnd)
    {
    HIMC hIMC = ImmGetContext(m_hWnd);
    ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0L);
    ImmReleaseContext(m_hWnd, hIMC);

    CEdit::OnKillFocus(pNewWnd);


        if ( m_pParentWnd->m_bVertEdit )
                {
                SetFmtRect();
                Repaint();
                }


    }



/******************************************************************************/

UINT CAttrEdit::OnNcHitTest( CPoint point )
    {
    const MSG *pCurrentMessage = GetCurrentMessage();
    UINT  uiHitTestCode = (UINT)DefWindowProc( pCurrentMessage->message,
                   pCurrentMessage->wParam,
                   pCurrentMessage->lParam);

        if ( (uiHitTestCode == HTCLIENT) )
                {
                if ( (m_pParentWnd->m_bVertEdit) )  SetVCursorShape();
                else                                SetHCursorShape();
                }

    return uiHitTestCode;
    }

/******************************************************************************/

void CAttrEdit::OnSetFocus( CWnd* pOldWnd )
    {
        Default();

        if ( m_pParentWnd->m_bVertEdit )
                {
                SetCaretShape();
                SetCaretPosition( FALSE, NULL, -1 );
                Repaint();
                }
    }

/******************************************************************************/

void CAttrEdit::OnSize( UINT nType, int cx, int cy )
    {
        Default();

        m_rectFmt.left = m_rectFmt.top = 0;
        m_rectFmt.right  = cx;
        m_rectFmt.bottom = cy;

        SetFmtRect();
    }


/******************************************************************************/

void CAttrEdit::OnLButtonDblClk(UINT nFlags, CPoint point)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return;
                }

        HideCaret();
        UpdateSel();
        SetStartSelect();

        int     tt = point.y;
        point.y = m_rectFmt.right - point.x;
        point.x = tt;

    const MSG *pCurrentMessage = GetCurrentMessage();
        DefWindowProc( pCurrentMessage->message,
                   pCurrentMessage->wParam,
                   MAKELPARAM( point.x, point.y ));

        SetCaretPosition( TRUE, &point, -1 );
        ShowCaret();
        UpdateSel();
        UpdateWindow();
    }

/******************************************************************************/

void CAttrEdit::OnLButtonDown(UINT nFlags, CPoint point)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return;
                }

        HideCaret();
        UpdateSel();
        SetStartSelect();

        int     iPrevEnd;
        GetSel( m_iPrevStart, iPrevEnd );

        int     tt = point.y;
        point.y = m_rectFmt.right - point.x;
        point.x = tt;

        //reset caret position to get correct caret position
        CPoint  pt( -20000, -20000 );
        SetCaretPos( pt );

    const MSG *pCurrentMessage = GetCurrentMessage();
        DefWindowProc( pCurrentMessage->message,
                   pCurrentMessage->wParam,
                   MAKELPARAM( point.x, point.y ));

        SetCaretPosition( TRUE, &point, m_iPrevStart );
        if ( GetKeyState(VK_SHIFT) >= 0 )       //not extend selection
                        GetSel( m_iPrevStart, iPrevEnd );
        ShowCaret();
        UpdateSel();
        UpdateWindow();

        m_bMouseDown = TRUE;

    }

/******************************************************************************/

void CAttrEdit::OnLButtonUp(UINT nFlags, CPoint point)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return;
                }

        m_bMouseDown = FALSE;

        HideCaret();
        UpdateSel();
        SetStartSelect();

        int     tt = point.y;
        point.y = m_rectFmt.right - point.x;
        point.x = tt;

    const MSG *pCurrentMessage = GetCurrentMessage();
        DefWindowProc( pCurrentMessage->message,
                   pCurrentMessage->wParam,
                   MAKELPARAM( point.x, point.y ));

        SetCaretPosition( TRUE, &point, m_iPrevStart );
        ShowCaret();
        UpdateSel();
        UpdateWindow();
    }


/******************************************************************************/

void CAttrEdit::OnMouseMove(UINT nFlags, CPoint point)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return;
                }

        if ( m_bMouseDown )
                {
                HideCaret();
                UpdateSel();
                SetStartSelect();

                int     tt = point.y;
                point.y = m_rectFmt.right - point.x;
                point.x = tt;

        const MSG *pCurrentMessage = GetCurrentMessage();
                DefWindowProc( pCurrentMessage->message,
                           pCurrentMessage->wParam,
                       MAKELPARAM( point.x, point.y ));

                SetCaretPosition( TRUE, &point, m_iPrevStart );
                ShowCaret();
                UpdateSel();
                UpdateWindow();
                }
        else    CEdit::OnMouseMove( nFlags, point );

    }

/******************************************************************************/

void CAttrEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
                return;
                }

        BOOL    bPrev = FALSE;

        HideCaret();

    switch (nChar)
        {
        case VK_LEFT:
                case VK_RIGHT:
                case VK_UP:
                case VK_DOWN:
                case VK_HOME:
        case VK_END:
                        {
                        UpdateSel();

                        CPoint ptCaretPos = GetCaretPos();
                        if ( ptCaretPos.y != 0 ) bPrev = TRUE;

                        int     iPrevEnd;
                        GetSel( m_iPrevStart, iPrevEnd );

                        SetStartSelect();       //for VK_RETURN

                        //reset caret position to get correct caret position
                        CPoint  pt( -20000, -20000 );
                        SetCaretPos( pt );

                        break;
                        }
        }

    switch (nChar)
        {
        case VK_LEFT:   nChar = VK_DOWN;                                        break;
                case VK_RIGHT:  nChar = VK_UP;                                          break;
                case VK_UP:             nChar = VK_LEFT;        bPrev = FALSE;  break;
                case VK_DOWN:   nChar = VK_RIGHT;       bPrev = FALSE;  break;
                case VK_HOME:                                           bPrev = FALSE;  break;
        case VK_END:                                            bPrev = TRUE;   break;
        }

    const MSG *pCurrentMessage = GetCurrentMessage();
    DefWindowProc( pCurrentMessage->message,
                   nChar,
                   pCurrentMessage->lParam);

    switch (nChar)
        {
        case VK_LEFT:
                case VK_RIGHT:
                case VK_UP:
                case VK_DOWN:
                case VK_HOME:
        case VK_END:
                        {
                        SetCaretPosition( bPrev, NULL, m_iPrevStart );
                        UpdateSel();
                        UpdateWindow();
                        break;
                        }
        case VK_HANJA:
                // For Korea hanja conversion.
                SetCaretPosition( FALSE, NULL, -2);
                break;

                }

        ShowCaret();
}

/******************************************************************************/
void            CAttrEdit::SetStartSelect( void )
        {
        int     nStart, nEnd;

        CPoint ptCaretPos = GetCaretPos();

        if ( ptCaretPos.y == 0 )
                {
                GetSel( nStart, nEnd );
                if ( nStart == nEnd )   SetSel( nStart, nEnd );
                }
        }

/******************************************************************************/
void CAttrEdit::SetCaretPosition( BOOL bPrev, CPoint* ptMouse, int iPrevStart )
        {

        HideCaret();

        // Get Caret Position
        CPoint  ptCaretPos;

        // Get End Selected Position to be Caret Position
        int     nStart, nEnd;

        GetSel( nStart, nEnd );

        if ( iPrevStart != -1 && nStart < iPrevStart )
            nEnd = nStart;
#ifdef UNICODE
        // When NT bug 116057 is fixed, remove this code


        // For composition string support
        if ( m_pParentWnd->m_bVertEdit && iPrevStart == -2)
            nEnd -= 1 * sizeof(WCHAR)/sizeof(TCHAR);
#endif //UNICODE
        CPoint ptPos( (DWORD)SendMessage( EM_POSFROMCHAR, nEnd ) );

        if ( nEnd >= GetWindowTextLength() ||
             ( ptPos.x == 0 && (bPrev) && (ptMouse == NULL ||
                                           ptMouse->y < ptPos.y ) ) )
            {
            CString cStr;
            CDC*    pDC = GetDC();
            CFont*  pFont = GetFont();
            CFont*  pOldFont;
            int     nLine = ( (ptPos.x < 0) ? GetLineCount() : LineFromChar( nEnd ) ) - 1;
            int     nChar = LineIndex( nLine );
            int     nLen = LineLength( nChar );
            LPTSTR  lpStr = cStr.GetBufferSetLength( nLen );
            TEXTMETRIC tm;

            pOldFont = pDC->SelectObject( pFont );
            GetLine( nLine, lpStr, nLen );

            pDC->GetTextMetrics( &tm );

            if ( !(tm.tmPitchAndFamily & TMPF_FIXED_PITCH) )
                m_iTabPos = tm.tmAveCharWidth;
            else
                {
                CPoint  len( pDC->GetTextExtent( TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52) );
                m_iTabPos = (len.x / 26 + 1) / 2;
                if ( m_iTabPos <= 0 )   m_iTabPos = tm.tmAveCharWidth;
                }

            m_iTabPos *= 8;
            if ( m_iTabPos <= 0 )   m_iTabPos = 1;

            CPoint  tt( 0, 0 );
            if ( nLen > 0 )
                {
                if ( *(lpStr + nLen - 1) == TEXT('\t') )
                    {
                    tt = (CPoint) (DWORD)SendMessage( EM_POSFROMCHAR, nChar + nLen - 1 );
                    tt.x = min( (tt.x / m_iTabPos + 1) * m_iTabPos, m_rectFmt.bottom - 1 );
                    }
                else
                    {
                    LPTSTR  lpChar = lpStr + nLen - 1;
                    int     nCnt;

                    for ( nCnt = 0; nCnt < nLen && *lpChar != TEXT('\t'); nCnt++, lpChar-- );
                    lpChar++;
                    tt = (CPoint) (DWORD)SendMessage( EM_POSFROMCHAR, nChar + nLen - nCnt );
                    tt.Offset( pDC->GetTextExtent( lpChar, nCnt ) );
                    }
                }
            cStr.Empty();
            ptCaretPos.x = tt.x;
            ptCaretPos.y = m_pParentWnd->m_iLineHeight * nLine;
            pDC->SelectObject( pOldFont );

            ReleaseDC( pDC );
            }
        else
            {
            ptCaretPos.x = ptPos.x;
            ptCaretPos.y = ptPos.y;
            }

        // H -> V
        CPoint  pt( m_rectFmt.right - ptCaretPos.y - m_pParentWnd->m_iLineHeight,
                    ptCaretPos.x );
        //
        // for some reason, typing spaces pushes the caret beyond the bottom of the rect.
        // Cover that case by forcing the caret to be at the bottom of the rect.
        //
        if (pt.y > m_rectFmt.bottom)
        {
           pt.y = m_rectFmt.bottom-2;
        }
        SetCaretPos( pt );

        //Set IME composition window position
        HIMC        himc;

        if (himc=ImmGetContext(m_hWnd))
            {
            COMPOSITIONFORM cf;
            RECT    rcClient;

            cf.dwStyle = CFS_RECT;
            cf.ptCurrentPos.x = m_rectFmt.right - ptCaretPos.y - 1;
            cf.ptCurrentPos.y = pt.y;
            GetClientRect( &rcClient );
            cf.rcArea = rcClient;

            ImmSetCompositionWindow(himc,&cf);
            ImmReleaseContext(m_hWnd, himc);
            }

#ifndef WINNT // don't call ImmSetCompositionWindow at this time.
        SetFmtRect();   //it should be called after set IME position
#endif

        ShowCaret();
        }

/******************************************************************************/
void            CAttrEdit::SetCaretShape( void )
        {
        HideCaret();
        ::DestroyCaret();
        ::CreateCaret( m_hWnd, NULL, m_pParentWnd->m_iLineHeight, 2 );
        ShowCaret();
        }

/******************************************************************************/
void            CAttrEdit::SetFmtRect()
        {
        RECT    rc;

        rc.left = rc.top = 0;
        if ( m_pParentWnd->m_bVertEdit )
                {
                rc.right  = m_rectFmt.bottom;
                rc.bottom = m_rectFmt.right;
                }
        else
                {
                rc.right  = m_rectFmt.right;
                rc.bottom = m_rectFmt.bottom;
                }
        
        HIMC            himc;
        COMPOSITIONFORM cf;
        BOOL            bResult = FALSE;

        if (himc=ImmGetContext(m_hWnd)) {
            bResult = ImmGetCompositionWindow(himc,&cf);
        }
        
        SetRectNP( &rc );
        
        if (himc && bResult) {
            ImmSetCompositionWindow(himc,&cf);
        }

        }

/******************************************************************************/
void CAttrEdit::Repaint(void)
    {
        InvalidateRect( NULL, TRUE );
        UpdateWindow();
        }

/******************************************************************************/
void CAttrEdit::UpdateSel(void)
    {
        int     nStart, nEnd;

        GetSel( nStart, nEnd );

        if (nStart != nEnd )
                {
                RECT    rc = m_rectFmt;

                if ( nStart > nEnd )
                        {
                        int     tt = nStart;
                        nStart = nEnd;
                        nEnd = tt;
                        }

                CPoint ptStart( (DWORD)SendMessage( EM_POSFROMCHAR, nStart ) );
                rc.right -= ptStart.y;

                if ( nEnd < GetWindowTextLength() )
                        {
                        CPoint ptEnd( (DWORD)SendMessage( EM_POSFROMCHAR, nEnd ) );
                        rc.left = m_rectFmt.right - ptEnd.y  - m_pParentWnd->m_iLineHeight;
                        }

                InvalidateRect( &rc );
                }
        }

/******************************************************************************/
void CAttrEdit::UpdateInput(void)
    {
        RECT    rc = m_rectFmt;

        CPoint pt( GetCaretPos() );
        rc.right = pt.x + m_pParentWnd->m_iLineHeight;

        InvalidateRect( &rc );
        }

/******************************************************************************/

LRESULT CAttrEdit::OnSysTimer( WPARAM wParam, LPARAM lParam )
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return 1L;
                }

    return 1L;
    }

/******************************************************************************/
void CAttrEdit::SetHCursorShape(void)
    {
        if ( GetSafeHwnd() )
                {
                ShowCursor( FALSE );
                SetClassLongPtr( m_hWnd, GCLP_HCURSOR, (LONG_PTR) m_hHCursor );
                ShowCursor( TRUE );
                }
        }

/******************************************************************************/
void CAttrEdit::SetVCursorShape(void)
    {
        if ( GetSafeHwnd() )
                {
                ShowCursor( FALSE );
                SetClassLongPtr( m_hWnd, GCLP_HCURSOR, (LONG_PTR) m_hVCursor );
                ShowCursor( TRUE );
                }
        }

/******************************************************************************/
void CAttrEdit::TabTextOut( CDC* pDC, int nCharIndex, int x, int y, LPCTSTR lpStr, int nCount, BOOL bSelect )
{
    int     i, nCnt;
    LPCTSTR lpChar = lpStr;
    CPoint  pt;
    CPoint  ptEnd;
    RECT    rc;
    BOOL    bReverse;

    CSize s1 = pDC->GetTextExtent( TEXT("a"), 1 );
    CSize s2 = pDC->GetTextExtent( TEXT("aa"), 2 );
    bReverse = (s1.cx == s2.cx);

    rc.left = x - m_pParentWnd->m_iLineHeight;
    rc.right = x;

    for ( i = 0, nCnt = 0; i < nCount; i++, nCnt++, lpStr++ )
    {
        if ( *lpStr == TEXT('\t') )
        {
            pt = (CPoint)(DWORD)SendMessage( EM_POSFROMCHAR, nCharIndex );
            if ( nCnt > 0 )
            {
                pDC->TextOut( x, pt.x, lpChar, nCnt );
            }

            nCharIndex += nCnt + 1;
            nCnt = -1;
            lpChar = lpStr + 1;
            if ( bSelect )
            {
                pt = (CPoint)(DWORD)SendMessage( EM_POSFROMCHAR, nCharIndex - 1 );
                rc.top = pt.x;

                if ( i < (nCount - 1) )
                {
                    pt = (CPoint)(DWORD)SendMessage( EM_POSFROMCHAR, nCharIndex );
                    rc.bottom = pt.x;
                }
                else
                {
                    rc.bottom = min( (pt.x / m_iTabPos + 1) * m_iTabPos,
                                     m_rectFmt.bottom - 1 );
                }

                pDC->ExtTextOut( x, rc.top, 0 /*ETO_OPAQUE*/, &rc, NULL, 0, NULL );
            }
        }
    }

    if ( nCnt > 0 )
    {
        pt = (CPoint)(DWORD)SendMessage( EM_POSFROMCHAR, nCharIndex );
        pDC->TextOut( x, pt.x, lpChar, nCnt );
    }
}


/******************************************************************************/
/******************************************************************************/
// CTedit

BEGIN_MESSAGE_MAP( CTedit, CWnd )
    //{{AFX_MSG_MAP(CTedit)
    ON_WM_SIZE()
    ON_WM_MOVE()
    ON_WM_CTLCOLOR()
    ON_WM_NCCALCSIZE()
    ON_WM_NCPAINT()
    ON_WM_NCHITTEST()
    ON_WM_RBUTTONDOWN()
    ON_COMMAND(ID_TEXT_PLAIN, OnTextPlain)
    ON_COMMAND(ID_TEXT_BOLD, OnTextBold)
    ON_COMMAND(ID_TEXT_ITALIC, OnTextItalic)
    ON_COMMAND(ID_TEXT_UNDERLINE, OnTextUnderline)
    ON_COMMAND(ID_TEXT_SELECTFONT, OnTextSelectfont)
    ON_COMMAND(ID_TEXT_SELECTPOINTSIZE, OnTextSelectpointsize)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_COMMAND(ID_EDIT_CLEAR, OnTextDelete)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnTextSelectall)
    ON_COMMAND(ID_EDIT_UNDO, OnTextUndo)
    ON_COMMAND(ID_TEXT_PLACE, OnTextPlace)
    ON_COMMAND(ID_VIEW_TEXT_TOOLBAR, OnTextTexttool)
    ON_WM_LBUTTONDOWN()
        //}}AFX_MSG_MAP
    ON_WM_GETMINMAXINFO()
    ON_MESSAGE(WM_MOVING, OnMoving)
    ON_EN_CHANGE(IDC_ATTREDIT, OnAttrEditEnChange)
    ON_EN_MAXTEXT(IDC_ATTREDIT, OnEnMaxText)
    ON_EN_UPDATE(IDC_ATTREDIT, OnEnUpdate)

    ON_WM_DESTROY()

END_MESSAGE_MAP()

/******************************************************************************/
// CTedit construction/destruction

CTedit::CTedit()
    {
    m_eLastAction     = eNO_CHANGE;
    m_bCleanupBKBrush = FALSE;
    m_bStarting       = TRUE;
    m_bPasting        = FALSE;
    m_bExpand         = FALSE;
    m_bChanged        = FALSE;
    m_uiHitArea       = HTNOWHERE;
    m_crFGColor       = ::GetSysColor( COLOR_WINDOWTEXT );
    m_crBKColor       = ::GetSysColor( COLOR_WINDOW     );

    // Need to be initialized during first GETMINMAXINFO call
    m_SizeMinimum.cx = 1;
    m_SizeMinimum.cy = 1;

    m_bBackgroundTransparent = TRUE;

    m_cRectOldPos.SetRectEmpty();
    m_cRectWindow.SetRectEmpty();


    m_bVertEdit = FALSE;
    m_bAssocIMC = FALSE;
    m_hIMCEdit = NULL;
    m_hIMCFace = NULL;
    m_hIMCSize = NULL;
    m_hWndFace = NULL;
    m_hWndSize = NULL;

    }

/******************************************************************************/

CTedit::~CTedit()
    {
    if (m_bCleanupBKBrush)
        {
        m_hbrBkColor.DeleteObject();      //Set in SetTransparentMode
        m_bCleanupBKBrush = FALSE;
        }
    }

/******************************************************************************/

BOOL CTedit::Create( CImgWnd* pParentWnd,
                     COLORREF crefForeground,
                     COLORREF crefBackground,
                     CRect&   rectPos,
                     BOOL     bBackTransparent )
    {
    if (! m_bStarting)
        return FALSE;

    // Initialize member variables
    m_pImgWnd   = pParentWnd;
    m_crBKColor = crefBackground;
    m_crFGColor = crefForeground;
    m_bBackgroundTransparent = bBackTransparent; // Do this or else

    SetTransparentMode( bBackTransparent );

    CRect rectText = rectPos;

    rectText.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );
    rectText.right  += CTracker::HANDLE_SIZE * 2;
    rectText.bottom += CTracker::HANDLE_SIZE * 2;

    if (! CWnd::Create( NULL, TEXT(""), WS_CHILD | WS_THICKFRAME, rectText, pParentWnd, IDC_ATTREDIT + 1 ))
        return FALSE;

    CRect rectEditArea;

    GetClientRect( &rectEditArea );

    m_cEdit.m_pParentWnd = this;

    if (! m_cEdit.Create( WS_CHILD | ES_LEFT | ES_MULTILINE | ES_NOHIDESEL | ES_WANTRETURN, rectEditArea, this, IDC_ATTREDIT ))
        {
        theApp.SetMemoryEmergency();

        DestroyWindow();
        return FALSE;
        }

    ClientToScreen( &rectEditArea ); // use this to let the font tool where not to cover

    m_pcTfont = new CTfont( this ); // this is the class Text Font Pallette
                                    // it is derived from cframewnd and will
    ASSERT( m_pcTfont != NULL );    // auto destruct when this window
                                    // 'CTedit' is Destroyed
    if (m_pcTfont == NULL || ! m_pcTfont->Create( rectEditArea ))
        {
        theApp.SetMemoryEmergency();

        DestroyWindow();

        m_pcTfont = NULL;
        return FALSE;
        }

    // reset the width and height to the minimum if nessesary
    CSize size = GetDefaultMinSize(); // must call after ctfont object created (it sets our font).
    m_cRectWindow = CRect( rectText.TopLeft(), size );
    SetWindowPos( &wndTop, 0, 0, size.cx, size.cy, SWP_NOACTIVATE | SWP_NOMOVE );

    ShowWindow( SW_SHOWNOACTIVATE );

    GetClientRect( &rectEditArea );

    m_cEdit.SetWindowPos( &wndTopMost, 0, 0, rectEditArea.Width(),
                                             rectEditArea.Height(), 0 );
    m_cEdit.ShowWindow( SW_SHOWNOACTIVATE );

    m_bStarting = FALSE;


        //get all control windows on ToolBar for controling IME
        CWnd* pcWndFace = m_pcTfont->GetFontFaceControl();
        if ( (pcWndFace != NULL) && (pcWndFace->GetSafeHwnd() != NULL) )
                        m_hWndFace = pcWndFace->m_hWnd; //static

        CWnd* pcWndSize = m_pcTfont->GetFontSizeControl();
        if ( (pcWndSize != NULL) && (
                  pcWndSize->GetSafeHwnd() != NULL) )
                {
                CWnd* pcWndEditSize = pcWndSize->GetWindow( GW_CHILD ); //edit
                if ( (pcWndEditSize != NULL) && (
                          pcWndEditSize->GetSafeHwnd() != NULL) )
                                m_hWndSize = pcWndEditSize->m_hWnd;     //edit
                }

        //save original Edit control
        if ( m_cEdit.GetSafeHwnd() )
                m_cEdit.m_hOldCursor = (HCURSOR) SetClassLongPtr( m_cEdit.m_hWnd, GCLP_HCURSOR, (LONG_PTR) m_cEdit.m_hHCursor );


         //only DBCS font would enable IME
        CFont* pcFont = m_cEdit.GetFont();
        LOGFONT     lf;
        pcFont->GetObject( sizeof( LOGFONT ), &lf );
        if ( !IS_DBCS_CHARSET( lf.lfCharSet ) )
                {
                m_bAssocIMC = TRUE;
                if (!IsCUAS())
                    m_hIMCEdit = DisableIme( m_cEdit.m_hWnd );
                m_hIMCFace = DisableIme( m_hWndFace );
                m_hIMCSize = DisableIme( m_hWndSize );
                }


        //initial Caret Position
        if ( m_bVertEdit )
                {
                CPoint  pt( 0, 0 );
                m_cEdit.SetCaretPos( pt );
                m_cEdit.SetCaretPosition( FALSE, NULL, -1 );
                }

    m_cEdit.SetFocus();

    return TRUE;
    }

/******************************************************************************/

BOOL CTedit::PreCreateWindow( CREATESTRUCT& cs )
    {
    cs.dwExStyle |= WS_EX_TRANSPARENT;

    return CWnd::PreCreateWindow( cs );
    }

/******************************************************************************/

void CTedit::RefreshWindow( CRect* prect, BOOL bErase )
    {
    if (! m_bStarting)
        {
        UINT flags = RDW_INVALIDATE;

        if (bErase)
            flags |= RDW_ERASE;

        if ( m_bVertEdit )
            {
            m_cEdit.SetFmtRect();
            m_cEdit.Repaint();
            }

        else
            m_cEdit.RedrawWindow( prect, NULL, flags );
        }
    }

/******************************************************************************/

void CTedit::SetTextColor( COLORREF crColor )
    {
    m_crFGColor = crColor;
    RefreshWindow( NULL, FALSE );
    }

/******************************************************************************/

void CTedit::SetBackColor( COLORREF crColor )
    {
    m_crBKColor = crColor;

    if (! m_bBackgroundTransparent)
        {
        m_bBackgroundTransparent = TRUE; // just fake it out
        SetTransparentMode( FALSE ); // to setup the background brush when in opaque mode
        }
    }

/******************************************************************************/

void CTedit::SetTransparentMode( BOOL bTransparent )
    {
    BOOL bRefresh = ((! m_bBackgroundTransparent &&   bTransparent)
                  || (  m_bBackgroundTransparent && ! bTransparent));

    m_cEdit.m_bBackgroundTransparent = bTransparent;
            m_bBackgroundTransparent = bTransparent;

    if (m_bCleanupBKBrush)
        {
        m_hbrBkColor.DeleteObject();
        m_bCleanupBKBrush = FALSE;
        }

    if (! m_bBackgroundTransparent)
        {
        m_hbrBkColor.CreateSolidBrush( m_crBKColor );
        m_bCleanupBKBrush = TRUE;
        }

    if (bRefresh)
        {
        InvalidateRect( NULL );
        UpdateWindow();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::Undo()
    {

    if ( m_bVertEdit )
        m_cEdit.HideCaret();

    switch(m_eLastAction)
        {
        case eEBOX_CHANGE:
            m_cEdit.Undo();
            break;

        case eFONT_CHANGE:
            ASSERT(m_pcTfont != NULL);

            if (m_pcTfont != NULL)
                {
                m_pcTfont->Undo();
                }
             break;

        case eSIZE_MOVE_CHANGE:
            if (! m_cRectOldPos.IsRectEmpty())
                MoveWindow( m_cRectOldPos );
             break;

        default:
             break;
        }


        if ( m_bVertEdit )
                {
                m_cEdit.SetCaretShape();
                m_cEdit.SetCaretPosition( TRUE, NULL, -1 );
                m_cEdit.ShowCaret();
                }

    }

/******************************************************************************/

void CTedit::ShowFontPalette(int nCmdShow)
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        theApp.m_bShowTextToolbar = ! theApp.m_bShowTextToolbar;

        m_pcTfont->ShowWindow(nCmdShow);
        }
    }

/******************************************************************************/

BOOL CTedit::IsFontPaletteVisible(void)
    {
    BOOL bWindowVisible = FALSE;

    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        bWindowVisible = m_pcTfont->IsWindowVisible();
        }

    return bWindowVisible;
    }

/******************************************************************************/

void CTedit::ShowFontToolbar(BOOL bActivate)
{
        // FEATURE: Remove ShowFontPalette after RTM

        if (m_pcTfont == NULL)
        {
                return;
        }

        m_pcTfont->ShowWindow(bActivate ? SW_SHOW : SW_SHOWNOACTIVATE);
}

/******************************************************************************/

void CTedit::HideFontToolbar(void)
{
        if (m_pcTfont == NULL)
        {
                return;
        }

        m_pcTfont->ShowWindow(SW_HIDE);
}

/******************************************************************************/
// Returns a Ptr to a discardable bitmap (CBitmap object) or NULL on error

void CTedit::GetBitmap( CDC* pDC, CRect* prectImg )
    {
    if (! m_bBackgroundTransparent)
        pDC->FillRect( prectImg, &m_hbrBkColor );

    m_cEdit.SetSel( -1, 0 );


    if ( m_bVertEdit )
        {
        m_cEdit.SetFmtRect();
        m_cEdit.UpdateWindow();
        }


    CPoint ptViewOrgOld = pDC->SetViewportOrg( prectImg->left, prectImg->top );

    m_cEdit.SendMessage( WM_PAINT, (WPARAM)(pDC->m_hDC) );

    pDC->SetViewportOrg( ptViewOrgOld );
    pDC->SelectClipRgn( NULL );
    }

/******************************************************************************/

void CTedit::PostNcDestroy()
    {

    // If m_pcTfont is destroyed by shutdown before CTedit,
    // m_pcTfont will be null
    if (m_pcTfont != NULL)
        {
        m_pcTfont->DestroyWindow();
        m_pcTfont = NULL;
        }

    delete this;
    }

/******************************************************************************/

CSize CTedit::GetDefaultMinSize( void )
    {
    CRect cRectClient;
    int   iWidth;
    int   iHeight;

    // edit control takes up the whole client area of the ctedit
    // object/window, so width of client of ctedit is same as widht of edit
    // control window.  Edit control window has no border.
    GetClientRect( &cRectClient );

    iWidth  = cRectClient.Width();
    iHeight = cRectClient.Height();

    CDC*   pDC    = m_cEdit.GetDC();
    CFont* pcFont = m_cEdit.GetFont();

    if (pDC    != NULL
    &&  pcFont != NULL)
        {
        TEXTMETRIC tm;
        CFont*     pcFontOld = NULL;

        pcFontOld = pDC->SelectObject( pcFont );

        pDC->GetTextMetrics( &tm );

        BOOL bUpdateSize = FALSE;

        m_SizeMinimum.cx = tm.tmAveCharWidth * MIN_CHARS_DISPLAY_SIZE + CTracker::HANDLE_SIZE * 2;
        m_SizeMinimum.cy = tm.tmHeight                                + CTracker::HANDLE_SIZE * 2;

        if (m_SizeMinimum.cx > iWidth) // must be able to at least display MIN_CHARS_DISPLAY_SIZE
            {
            iWidth      = m_SizeMinimum.cx;
            bUpdateSize = TRUE;
            }

        if (m_SizeMinimum.cy > iHeight) // must be able to at least 1 char high
            {
            iHeight     = m_SizeMinimum.cy;
            bUpdateSize = TRUE;
            }

        if (bUpdateSize)
            m_eLastAction = eNO_CHANGE; // don't want user to be able to undo this

        if (pcFontOld != NULL)
            {
            pDC->SelectObject( pcFontOld );
            }
        }
    if (pDC != NULL)
        m_cEdit.ReleaseDC( pDC );

    cRectClient.SetRect( 0, 0, iWidth - 1, iHeight - 1 );

    ClientToScreen( &cRectClient );
    m_pImgWnd->ScreenToClient( &cRectClient );

    CRect rectDrawing = m_pImgWnd->GetDrawingRect();

    if (cRectClient.right > rectDrawing.right)
        iWidth -= (cRectClient.right - rectDrawing.right) - CTracker::HANDLE_SIZE;

    if (cRectClient.bottom > rectDrawing.bottom)
        iHeight -= (cRectClient.bottom - rectDrawing.bottom) - CTracker::HANDLE_SIZE;

    m_SizeMinimum.cx = iWidth;
    m_SizeMinimum.cy = iHeight;

    return CSize( iWidth, iHeight );
    }

/******************************************************************************/

void CTedit::OnAttrEditEnChange(void)
    {
    m_eLastAction = eEBOX_CHANGE;

    if (m_bRefresh)
        m_cEdit.UpdateWindow();


        if ( m_bVertEdit )
                {
                m_cEdit.SetCaretPosition( TRUE, NULL, -1 );
                m_cEdit.UpdateWindow();
                }

    }

/******************************************************************************/

void CTedit::OnEnUpdate()
    {
    CPoint ptCaretPos = m_cEdit.GetCaretPos();
    CPoint ptLastChar( (DWORD)m_cEdit.SendMessage( EM_POSFROMCHAR,
                               (WPARAM)(m_cEdit.GetWindowTextLength() - 1) ) );
    CRect rect;
    m_cEdit.GetClientRect( &rect );
    rect.top    = ptCaretPos.y;
    rect.bottom = ptLastChar.y + m_iLineHeight;
    m_cEdit.InvalidateRect( &rect, TRUE );

    m_bChanged = TRUE;
    }

/******************************************************************************/

void CTedit::OnEnMaxText()
    {

    if (m_bPasting)
        {
        if (!m_cEdit.m_bResizeOnly)
        {
            AfxMessageBox( IDS_UNABLE_TO_PASTE, MB_OK | MB_ICONEXCLAMATION );
        }
        return;
        }

    CFont* pfntEdit = m_cEdit.GetFont();

    if (pfntEdit == NULL)
        return;

    CClientDC dc( &m_cEdit );

    CFont* pfntOld = dc.SelectObject( pfntEdit );

    TEXTMETRIC tm;

    dc.GetTextMetrics( &tm );

    CRect rectText;
    CRect rectImg;

    GetWindowRect( &rectText );

    m_pImgWnd->ScreenToClient( &rectText );

    POINT pt;
    ::GetCaretPos (&pt);
    //
    // If the next character would extend past the end of the
    // edit window, grow the window


    if (!m_bVertEdit && m_cEdit.m_bResizeOnly &&
       ((rectText.left + pt.x + 2*tm.tmMaxCharWidth < rectText.right)
       || (rectText.top + pt.y + 2*tm.tmHeight < rectText.bottom)) )
    {
       return;
    }
    else if (m_bVertEdit && m_cEdit.m_bResizeOnly &&
       ((pt.x - tm.tmMaxCharWidth > 0)
       || (rectText.top + pt.y + 2*tm.tmHeight < rectText.bottom)) )
    {
       return;
    }
    m_pImgWnd->GetClientRect ( &rectImg );


    if (m_cEdit.m_strResult.IsEmpty())
    {

                if (m_bVertEdit)
                        rectText.left -= tm.tmHeight;
                else
                rectText.bottom += tm.tmHeight;
    }
    else
    {
        CRect rectTmp = rectText;
        int nLen = m_cEdit.m_strResult.GetLength();


        if (m_bVertEdit)
           rectText.left -= dc.DrawText(m_cEdit.m_strResult.GetBuffer(nLen),
                                      nLen,&rectTmp,
                                      DT_CALCRECT | DT_LEFT | DT_WORDBREAK);
        else
           rectText.bottom += dc.DrawText(m_cEdit.m_strResult.GetBuffer(nLen),
                                      nLen,&rectTmp,
                                      DT_CALCRECT | DT_LEFT | DT_WORDBREAK);
    }

    CRect rectDrawing = m_pImgWnd->GetDrawingRect();

    if ( ((m_bVertEdit) && rectText.left>=rectDrawing.left && rectText.left >= rectImg.left) ||
         ((!m_bVertEdit) && rectText.bottom<=rectDrawing.bottom && rectText.bottom<=rectImg.bottom) )
    {
        MoveWindow( &rectText );
        m_cEdit.UpdateWindow();

        if ( m_bVertEdit )
            m_cEdit.UpdateInput();

        if (!m_cEdit.m_bResizeOnly)
        {
            if (m_cEdit.m_strResult.IsEmpty())
            {
                #ifdef UNICODE
                WCHAR ch[3];

                ch[0] = (WCHAR)m_cEdit.m_uiLastChar[0];
                ch[1] = L'\0';
                #else
                BYTE ch[3];
                //
                // Put lead and trail bytes in proper place for DBCS characters.
                //
                if (IsDBCSLeadByte (HIBYTE(LOWORD(m_cEdit.m_uiLastChar[0]))))
                {
                   ch[0] = HIBYTE(LOWORD(m_cEdit.m_uiLastChar[0]));
                   ch[1] = LOBYTE(LOWORD(m_cEdit.m_uiLastChar[0]));
                   ch[2] = '\0';
                }
                else
                {
                   ch[0] = LOBYTE(LOWORD(m_cEdit.m_uiLastChar[0]));
                   ch[1] = '\0';
                }
                #endif // UNICODE
                if (ch[0] == VK_RETURN)
                {
                    lstrcpy((LPTSTR)ch, TEXT("\r\n"));
                }

                m_cEdit.ReplaceSel((LPCTSTR) ch );
            }
             else
            {
                int nLen = m_cEdit.m_strResult.GetLength();

                m_cEdit.ReplaceSel( m_cEdit.m_strResult.GetBuffer(nLen));
            }
        }
    }

    if (pfntOld)
        dc.SelectObject( pfntOld );
    }

/******************************************************************************/

void CTedit::OnAttrEditFontChange(void)
    {
    CClientDC editDC( &m_cEdit );
    CFont* pcFont = m_cEdit.GetFont();
    if (!pcFont)
    {
        return; // this happens when you "escape" from the font
                //  selection listbox
    }
    CFont* pFontOld = editDC.SelectObject( pcFont);

    TEXTMETRIC tm;

    editDC.GetTextMetrics( &tm );

    m_iLineHeight = tm.tmHeight;


    #ifdef _DEBUG
    TRACE1( "New font line height %d.\n", m_iLineHeight );
    #endif


        //only DBCS associated font would enable IME
        if ( !m_bStarting )
                {

                LOGFONT     lf;

                pcFont->GetObject( sizeof( LOGFONT ), &lf );
                if ( IS_DBCS_CHARSET( lf.lfCharSet ) )

                        {

                        if (m_bAssocIMC)
                                {

                                m_bAssocIMC = FALSE;
                                if (!IsCUAS())
                                    {
                                    EnableIme( m_cEdit.m_hWnd, m_hIMCEdit );
                                    m_hIMCEdit = NULL;
                                    }
                                EnableIme( m_hWndFace, m_hIMCFace );
                                EnableIme( m_hWndSize, m_hIMCSize );
                                m_hIMCFace = NULL;
                                m_hIMCSize = NULL;
                                m_pcTfont->SetFocus();
                                }
                        }
                else
                        {

                        if (!m_bAssocIMC)
                                {

                                m_bAssocIMC = TRUE;
                                if (!IsCUAS())
                                    m_hIMCEdit = DisableIme( m_cEdit.m_hWnd );
                                m_hIMCFace = DisableIme( m_hWndFace );
                                m_hIMCSize = DisableIme( m_hWndSize );
                                m_pcTfont->SetFocus();
                                }
                        }
                }


    if (pFontOld != NULL)
        editDC.SelectObject( pFontOld );

    m_eLastAction = eFONT_CHANGE;
    }

/******************************************************************************/

void CTedit::OnSize( UINT nType, int cx, int cy )
    {
    if (! m_bStarting)
        ShowWindow( SW_HIDE );

    // need to do this if transparent to force see through
    m_cRectOldPos = m_cRectWindow;
    GetWindowRect( &m_cRectWindow );
    m_pImgWnd->ScreenToClient( m_cRectWindow );

    m_eLastAction = eSIZE_MOVE_CHANGE;

    // could be NULL when main window is created and child edit window
    // has not been created yet.
    if (m_cEdit.GetSafeHwnd() != NULL)
        {
        m_cEdit.MoveWindow( 0, 0, cx, cy );
        m_cEdit.SetWindowPos( &wndTopMost, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );
        }
    InvalidateRect( NULL );
    UpdateWindow();

    if (m_bBackgroundTransparent)
        {
        RefreshWindow();
        }
    if (! m_bStarting)
        ShowWindow( SW_SHOW );


        if ( m_bVertEdit )
                {
                m_cEdit.SetFmtRect();
                CPoint pt( -20000, -20000 );
                m_cEdit.SetCaretPos( pt );
                m_cEdit.SetCaretPosition( FALSE, NULL, -1 );
                m_cEdit.Repaint();
                }


    }

/******************************************************************************/

void CTedit::OnMove( int x, int y )
    {
    // need to do this if transparent to force see through
    m_cRectOldPos = m_cRectWindow;
    GetWindowRect( &m_cRectWindow );
    m_pImgWnd->ScreenToClient( m_cRectWindow );

    if (m_cRectOldPos.Width()  != m_cRectWindow.Width()
    ||  m_cRectOldPos.Height() != m_cRectWindow.Height())
        {
        //reset back to previous, since new will be updated in onsize, due to
        // size and move happening both (e.g. sizing either left or top side
        // causes an onmove then an onsize
        m_cRectWindow = m_cRectOldPos;
        }
    m_eLastAction = eSIZE_MOVE_CHANGE;

    if (m_cEdit.GetSafeHwnd() != NULL)
        {
        m_cEdit.SetWindowPos( &wndTopMost, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );
        }

    InvalidateRect( NULL );
    UpdateWindow();

    if (m_bBackgroundTransparent)
        {
        RefreshWindow();
        }
    }

/******************************************************************************/

LRESULT CTedit::OnMoving( WPARAM, LPARAM lprc )
    {
    LRESULT lResult = 0;
    CRect rectEdit  = *((LPRECT)lprc);
    CRect rectImage = m_pImgWnd->GetDrawingRect();

    m_pImgWnd->ClientToScreen( &rectImage );

    int iX = 0;
    int iY = 0;

    if (rectEdit.left < rectImage.left)
        iX = rectImage.left - rectEdit.left;
    else
        if (rectEdit.right > rectImage.right)
            iX = -(rectEdit.right - rectImage.right);

    if (rectEdit.top < rectImage.top)
        iY = rectImage.top - rectEdit.top;
    else
        if (rectEdit.bottom > rectImage.bottom)
            iY = -(rectEdit.bottom - rectImage.bottom);

    if (iX || iY)
        {
        rectEdit.OffsetRect( iX, iY );
        *((LPRECT)lprc) = rectEdit;
        lResult = 1;
        }
    return lResult;
    }

/******************************************************************************/

void CTedit::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
    {
    CRect rectImage = m_pImgWnd->GetDrawingRect();
    CSize      Size = rectImage.Size();

    lpMMI->ptMaxSize.x      = Size.cx;
    lpMMI->ptMaxSize.y      = Size.cy;
    lpMMI->ptMaxPosition    = rectImage.TopLeft();
    lpMMI->ptMinTrackSize.x = m_SizeMinimum.cx;
    lpMMI->ptMinTrackSize.y = m_SizeMinimum.cy;

    CRect rectClient;

    GetWindowRect( &rectClient );
    m_pImgWnd->ScreenToClient( &rectClient );

    switch (m_uiHitArea)
        {
        case HTTOP:
        case HTLEFT:
        case HTTOPLEFT:
            break;

        case HTRIGHT:
        case HTTOPRIGHT:
        case HTBOTTOMRIGHT:
            lpMMI->ptMaxSize.x -= (rectClient.left - rectImage.left);

            if (m_uiHitArea == HTBOTTOMRIGHT)
                ; // fall thru and do the bottom
            else
                break;

        case HTBOTTOMLEFT:
        case HTBOTTOM:
            lpMMI->ptMaxSize.y -= (rectClient.top - rectImage.top);
            break;
        }

    lpMMI->ptMaxTrackSize = lpMMI->ptMaxSize;
    }

/******************************************************************************/

HBRUSH CTedit::OnCtlColor (CDC* pDC, CWnd* pWnd, UINT nCtlColor )
    {
    HBRUSH hbrBack = NULL;

    if (pWnd == &m_cEdit)
        {
        PBSelectPalette( pDC, theApp.m_pPalette, FALSE );
        pDC->SetTextColor( m_crFGColor );

        //set the background color and transparent mode
//      if (m_bBackgroundTransparent)
//          {
            pDC->SetBkMode( TRANSPARENT );

            hbrBack = (HBRUSH)::GetStockObject( NULL_BRUSH );
//          }
//      else
//          {
//          pDC->SetBkMode( OPAQUE );
//          pDC->SetBkColor( m_crBKColor );

//          hbrBack = (HBRUSH)m_hbrBkColor.GetSafeHandle();
//          }
        }
    if (hbrBack == NULL)
        return (HBRUSH)Default();

    return hbrBack;
    }

/******************************************************************************/
//void CTedit::OnLButtonDown(UINT nFlags, CPoint point )
//  {
//  SendMessage(WM_NCLBUTTONDOWN, HTCAPTION, MAKELPARAM(point.x, point.y));
//  SetFocus();
//  CEdit::OnLButtonDown(nFlags, point);
//  }

/******************************************************************************/

void CTedit::OnNcCalcSize( BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp )
    {
    /* Increase by an extra width height of the border*/
    lpncsp->rgrc[0].left   += CTracker::HANDLE_SIZE;
    lpncsp->rgrc[0].top    += CTracker::HANDLE_SIZE;
    lpncsp->rgrc[0].right  -= CTracker::HANDLE_SIZE;
    lpncsp->rgrc[0].bottom -= CTracker::HANDLE_SIZE;
    }

/******************************************************************************/

void CTedit::OnNcPaint()
    {
    CDC *pdcWindow = GetWindowDC();

    ASSERT(pdcWindow != NULL);

    if (pdcWindow != NULL)
        {
        CRgn    rgnClipping;
        CRect   cWinRect;
        int     iWindowWidth;
        int     iWindowHeight;

        GetWindowRect( &cWinRect );

        iWindowWidth  = cWinRect.Width();
        iWindowHeight = cWinRect.Height();

        CRect cBorderRect( 0, 0, iWindowWidth, iWindowHeight );

        CTracker::DrawBorder ( pdcWindow, cBorderRect, CTracker::all );
        CTracker::DrawHandles( pdcWindow, cBorderRect, CTracker::all );

        ReleaseDC( pdcWindow );
        }
    }

/******************************************************************************/

UINT CTedit::OnNcHitTest( CPoint point )
    {
    CRect cClientRect;
    UINT  uiHitTestCode = HTCAPTION;

    ScreenToClient( &point );

    GetClientRect(&cClientRect);

    //Test to see if the pt is in THE CLIENT AREA
    if (cClientRect.PtInRect(point))
        {
        uiHitTestCode = HTCLIENT;
        }

    m_uiHitArea = HTNOWHERE;

    switch (CTracker::HitTest( cClientRect, point, CTracker::nil ))
        {
        case CTracker::resizingTop:
            m_uiHitArea = HTTOP;
            break;

        case CTracker::resizingLeft:
            m_uiHitArea = HTLEFT;
            break;

        case CTracker::resizingRight:
            m_uiHitArea = HTRIGHT;
            break;

        case CTracker::resizingBottom:
            m_uiHitArea = HTBOTTOM;
            break;

        case CTracker::resizingTopLeft:
            m_uiHitArea = HTTOPLEFT;
            break;

        case CTracker::resizingTopRight:
            m_uiHitArea = HTTOPRIGHT;
            break;

        case CTracker::resizingBottomLeft:
            m_uiHitArea = HTBOTTOMLEFT;
            break;

        case CTracker::resizingBottomRight:
            m_uiHitArea = HTBOTTOMRIGHT;
            break;
        }

    if (m_uiHitArea != HTNOWHERE)
        uiHitTestCode = m_uiHitArea;


        m_cEdit.SetHCursorShape();


    return uiHitTestCode;
    }

/******************************************************************************/

void CTedit::OnRButtonDown(UINT nFlags, CPoint point)
    {
    CMenu cMenuPopup;
    CMenu *pcContextMenu;
    CRect cRectClient;
    BOOL  bRC = cMenuPopup.LoadMenu( IDR_TEXT_POPUP );

    ASSERT( bRC );

    if (bRC)
        {
        GetClientRect( &cRectClient );

        pcContextMenu = cMenuPopup.GetSubMenu( ID_EBOX_POPUPMENU_POS );

        ASSERT( pcContextMenu != NULL );

        if (pcContextMenu != NULL)
            {
            // update the check marks
            OnUpdateTextPlain    ( pcContextMenu );
            OnUpdateTextBold     ( pcContextMenu );
            OnUpdateTextItalic   ( pcContextMenu );
            OnUpdateTextUnderline( pcContextMenu );
            OnUpdateTextTexttool ( pcContextMenu );

            ClientToScreen( &point );
            ClientToScreen( &cRectClient );

            // the frame actually has a clue about what items to enable...
            CWnd *notify = GetParentFrame();

            if( !notify )
                notify = this; // oh well...

            pcContextMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                                     point.x, point.y, notify, &cRectClient );
            }
        }
    }

/******************************************************************************/

void CTedit::OnTextPlain()
    {
    ASSERT( m_pcTfont != NULL );

    if (m_pcTfont != NULL)
        {
        if (m_pcTfont->IsBoldOn())
            {
            m_pcTfont->OnBold();
            }

        if (m_pcTfont->IsItalicOn())
            {
            m_pcTfont->OnItalic();
            }

        if (m_pcTfont->IsUnderlineOn())
            {
            m_pcTfont->OnUnderline();
            }

        if (m_pcTfont->IsShadowOn())
            {
            m_pcTfont->OnShadow();
            }

        m_pcTfont->RefreshToolBar();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::OnTextBold()
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        m_pcTfont->OnBold();
        m_pcTfont->RefreshToolBar();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::OnTextItalic()
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        m_pcTfont->OnItalic();
        m_pcTfont->RefreshToolBar();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::OnTextUnderline()
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        m_pcTfont->OnUnderline();
        m_pcTfont->RefreshToolBar();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::OnTextSelectfont()
    {
    if (m_pcTfont != NULL)
        {
        if (! IsFontPaletteVisible())
            ShowFontPalette( SW_SHOW );
        else
            m_pcTfont->SetFocus();
        }
    }

/******************************************************************************/

void CTedit::OnTextSelectpointsize()
    {
    if (m_pcTfont != NULL)
        {
        if (! IsFontPaletteVisible())
            ShowFontPalette( SW_SHOW );
        else
            m_pcTfont->SetFocus();

        CWnd* pWnd = m_pcTfont->GetFontSizeControl();

        if (pWnd != NULL)
            {
            pWnd->SetFocus();
            }
        }
    }

/******************************************************************************/

void CTedit::OnEditCut()
    {

        if ( m_bVertEdit )      HideCaret();


    m_cEdit.Cut();
    RefreshWindow();


        if ( m_bVertEdit )
                {
                m_cEdit.SetCaretShape();
                ShowCaret();
                }

    }

/******************************************************************************/

void CTedit::OnEditCopy()
    {
    m_cEdit.Copy();
    }

/******************************************************************************/

void CTedit::OnEditPaste()
    {
    m_bPasting = TRUE;

    #ifdef _DEBUG
    TRACE0( "OnEditPaste Start\n" );
    #endif

    m_cEdit.Paste();

    #ifdef _DEBUG
    TRACE0( "OnEditPaste End\n" );
    #endif

    m_bPasting = FALSE;

    RefreshWindow();
    }

/******************************************************************************/

void CTedit::OnTextDelete()
    {
    int iLength = m_cEdit.GetWindowTextLength();
    int iStart  = iLength;
    int iEnd    = iLength;


        if ( m_bVertEdit )              m_cEdit.HideCaret();


    m_cEdit.GetSel( iStart, iEnd );

    if (iStart == iEnd)
        {
        if (iLength == iStart)
            return;

        CString strText;
        m_cEdit.GetWindowText(strText);
        if (!strText.IsEmpty() && (IsDBCSLeadByte((CHAR)strText[iStart])
            || strText[iStart]==TEXT('\r')))
            iEnd += 2;
        else
            iEnd += 1;

        m_cEdit.SetSel( iStart, iEnd, TRUE );
        }
    m_cEdit.Clear();


        if ( m_bVertEdit )
                {
                m_cEdit.SetCaretShape();
                m_cEdit.SetCaretPosition( TRUE, NULL, -1 );
                m_cEdit.ShowCaret();
                m_cEdit.Repaint();
                }
        else
                {


    UpdateWindow();
    RefreshWindow();


                }


    }

/******************************************************************************/

void CTedit::OnTextSelectall()
    {
    m_cEdit.SetSel( 0, -1, TRUE );

    RefreshWindow();
    }

/******************************************************************************/

void CTedit::OnTextUndo()
    {
    Undo();

    RefreshWindow();
    }

/******************************************************************************/

void CTedit::OnTextPlace()
    {
    CWnd* cwndParent = GetParent();

    cwndParent->PostMessage( WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM( CTracker::HANDLE_SIZE + 1, CTracker::HANDLE_SIZE + 1 ) );
    cwndParent->PostMessage( WM_LBUTTONUP,   MK_LBUTTON, MAKELPARAM( CTracker::HANDLE_SIZE + 1, CTracker::HANDLE_SIZE + 1 ) );
    }

/******************************************************************************/

void CTedit::OnTextTexttool()
    {
    if (IsFontPaletteVisible())
        {
        ShowFontPalette( SW_HIDE );
        }
    else
        {
        ShowFontPalette( SW_SHOWNOACTIVATE );
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextPlain( CMenu *pcMenu )
    {
    ASSERT( m_pcTfont != NULL );

    if (m_pcTfont != NULL)
        {
        if (! m_pcTfont->IsBoldOn()
        &&  ! m_pcTfont->IsItalicOn()
        &&  ! m_pcTfont->IsUnderlineOn()
        &&  ! m_pcTfont->IsShadowOn())
           {
           pcMenu->CheckMenuItem(ID_TEXT_PLAIN, MF_BYCOMMAND | MF_CHECKED);
           }
       else
           {
           pcMenu->CheckMenuItem(ID_TEXT_PLAIN, MF_BYCOMMAND | MF_UNCHECKED);
           }
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextBold(CMenu *pcMenu)
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        if (m_pcTfont->IsBoldOn())
            {
            pcMenu->CheckMenuItem(ID_TEXT_BOLD, MF_BYCOMMAND | MF_CHECKED);
            }
        else
            {
            pcMenu->CheckMenuItem(ID_TEXT_BOLD, MF_BYCOMMAND | MF_UNCHECKED);
            }
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextItalic(CMenu *pcMenu)
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        if (m_pcTfont->IsItalicOn())
            {
            pcMenu->CheckMenuItem(ID_TEXT_ITALIC, MF_BYCOMMAND | MF_CHECKED);
            }
        else
            {
            pcMenu->CheckMenuItem(ID_TEXT_ITALIC, MF_BYCOMMAND | MF_UNCHECKED);
            }
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextUnderline(CMenu *pcMenu)
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        if (m_pcTfont->IsUnderlineOn())
            {
            pcMenu->CheckMenuItem(ID_TEXT_UNDERLINE, MF_BYCOMMAND | MF_CHECKED);
            }
        else
            {
            pcMenu->CheckMenuItem(ID_TEXT_UNDERLINE, MF_BYCOMMAND | MF_UNCHECKED);
            }
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextTexttool(CMenu *pcMenu)
    {
    if (IsFontPaletteVisible())
        {
        pcMenu->CheckMenuItem(ID_VIEW_TEXT_TOOLBAR, MF_BYCOMMAND | MF_CHECKED);
        }
    else
        {
        pcMenu->CheckMenuItem(ID_VIEW_TEXT_TOOLBAR, MF_BYCOMMAND | MF_UNCHECKED);
        }
    }

/******************************************************************************/



/******************************************************************************/

void CTedit::OnDestroy(void)
    {
        if ( m_cEdit.GetSafeHwnd() )
                {
                if ( m_cEdit.m_hOldCursor )
                        SetClassLongPtr( m_cEdit.m_hWnd, GCLP_HCURSOR, (LONG_PTR) m_cEdit.m_hOldCursor );

                //restore original edit IMC
                if (m_bAssocIMC)
                        {
                        m_bAssocIMC = FALSE;
                        EnableIme( m_cEdit.m_hWnd, m_hIMCEdit );
                        EnableIme( m_hWndFace, m_hIMCFace );
                        EnableIme( m_hWndSize, m_hIMCSize );
                        m_hIMCEdit = NULL;
                        m_hIMCFace = NULL;
                        m_hIMCSize = NULL;
                        }
                }

        Default();
        return;
        }

/******************************************************************************/

HIMC    CTedit::DisableIme( HWND hWnd )
        {
        HIMC    hIMC = NULL;

        if ( (hWnd) && (::IsWindow( hWnd )) )
                hIMC = ImmAssociateContext( hWnd, NULL );

        return  hIMC;
        }

/******************************************************************************/

void    CTedit::EnableIme( HWND hWnd, HIMC hIMC )
        {
        if ( (hWnd) && (::IsWindow( hWnd )) )
                ImmAssociateContext( hWnd, hIMC );
        }

/******************************************************************************/

//
// Tablet PC.
//
// Is CUAS (Cicero Unaware App Support) is on, we need to use hIMC even on
// Ansi Font. The string from English HW/Speech TIPs will be delivered
// through hIMC.
//
BOOL CTedit::IsCUAS()
{
    BOOL bRet = FALSE;

    typedef BOOL (*PFNCTFIMMISCICEROENABLED)(void);

    static PFNCTFIMMISCICEROENABLED pfn = NULL;

    if (!pfn)
    {
        HMODULE hMod = LoadLibrary(TEXT("imm32.dll"));
        if (hMod)
        {
            pfn = (PFNCTFIMMISCICEROENABLED)GetProcAddress(hMod,
                               "CtfImmIsCiceroEnabled");

        }
    }
    if (pfn)
        bRet = pfn();
    return bRet;
}

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\tfont.cpp ===
/******************************************************************************/
/* Tfont.CPP: IMPLEMENTATION OF THE CTfont CLASS which encapsulates the       */
/* CTfondDlg and CTfontTbar classes                                           */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  TextFont Object                                                           */
/*      CTfont::CTfont                                                        */
/*      CTfont::CTfont                                                        */
/*      CTfont::~CTfont                                                       */
/*      CTfont::EmptyMap                                                      */
/*      CTfont::FreeMemoryFromCBox                                            */
/*                                                                            */
/*  Miscellaneous Methods                                                     */
/*      CTfont::Create                                                        */
/*      CTfont::Undo                                                          */
/*      CTfont::RefreshToolBar                                                */
/*      CTfont::ResizeWindow                                                  */
/*      CTfont::DrawItem                                                      */
/*      CTfont::SetColorsInDC                                                 */
/*      CTfont::SaveToIniFile                                                 */
/*      CTfont::RestoreFontAttrsFromIniFile                                   */
/*      CTfont::ReadFromIniFile                                               */
/*                                                                            */
/*  Font/Size enumeration methods                                             */
/*      CTfont::RefreshFontList                                               */
/*      CTfont::EnumFontFace                                                  */
/*      CTfont::EnumFontFaceProc                                              */
/*      CTfont::EnumFontSizes                                                 */
/*      CTfont::EnumFontOneFaceProc                                           */
/*                                                                            */
/*  Combo Box Notification and processing methods                             */
/*      CTfont::ProcessNewTypeface                                            */
/*      CTfont::UpdateEditControlFont                                         */
/*      CTfont::OnTypeFaceComboBoxUpdate                                      */
/*      CTfont::OnPointSizeComboBoxUpdate                                     */
/*      CTfont::OnTypefaceChange                                              */
/*      CTfont::OnPointSizeChange                                             */
/*      CTfont::OnRButtonDown                                                 */
/*                                                                            */
/*                                                                            */
/*  Control Notification/Window Messages                                      */
/*      CTfont::OnMove                                                        */
/*      CTfont::OnClose                                                       */
/*      CTfont::OnSetFocus                                                    */
/*      CTfont::OnDestroy                                                     */
/*      CTfont::OnBold                                                        */
/*      CTfont::OnItalic                                                      */
/*      CTfont::OnUnderline                                                   */
/*      CTfont::OnShadow                                                      */
/*      CTfont::OnPen                                                         */
/*      CTfont::OnEditText                                                    */
/*      CTfont::OnKeyboard                                                    */
/*      CTfont::OnInsSpace                                                    */
/*      CTfont::OnBackSpace                                                   */
/*      CTfont::OnNewLine                                                     */
/*      CTfont::OnDrawItem                                                    */
/*      CTfont::OnMeasureItem                                                 */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  Tool Bar Object                                                           */
/*      CTfontTbar::CTfontTbar                                                */
/*      CTfontTbar::Create                                                    */
/*      CTfontTbar::~CTfontTbar                                               */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  Dialog Bar Object                                                         */
/*      TfontDlg::CTfontDlg(void)                                             */
/*      TfontDlg::Create(CWnd* pcParentWnd)                                   */
/*      TfontDlg::~CTfontDlg(void)                                            */
/*      TfontDlg::OnRButtonDown                                               */
/*                                                                            */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include <memory.h>
#include <tchar.h>
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "pictures.h"
#include "resource.h"
#include "minifwnd.h"
#include "Tfont.h"
#include "Tedit.h"
#ifndef NT
#include <penwin.h> // soe we can bring up the lens from the toolbar
#endif
#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CTfont, CMiniFrmWnd )
IMPLEMENT_DYNCREATE( CTfontTbar, CToolBar )
IMPLEMENT_DYNCREATE( CTfontDlg, CDialogBar )

#include "memtrace.h"

UINT    CTBitmaps[] = {FONT_TT_BMP, FONT_PRN_BMP, TT_OPENTYPE_BMP, PS_OPENTYPE_BMP, TYPE1_BMP};

/******************************************************************************/

class CCharSetDesc
{
public:
        CCharSetDesc(LPCTSTR lpszScript, BYTE nCharSet);

        CString       m_strScript;
        BYTE          m_nCharSet;
        CCharSetDesc *m_pNext;
};

CCharSetDesc::CCharSetDesc(LPCTSTR lpszScript, BYTE nCharSet)
{
        m_strScript = lpszScript;
        m_nCharSet  = nCharSet;
        m_pNext     = NULL;
}

/******************************************************************************/

class CFontDesc
{
public:
        CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet, int iFontType);
        ~CFontDesc();

        CString m_strName;
        CCharSetDesc m_CharSetDesc;
        int m_iFontType;
};

CFontDesc::CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet, int iFontType)
    : m_CharSetDesc(lpszScript, nCharSet)
{
        m_strName = lpszName;
        m_iFontType = iFontType;
}

CFontDesc::~CFontDesc()
{
    // delete the charset list entries

    CCharSetDesc *pCharSetDesc = m_CharSetDesc.m_pNext;

    while (pCharSetDesc) 
    {
        CCharSetDesc *pTemp = pCharSetDesc;
        pCharSetDesc = pCharSetDesc->m_pNext;
        delete pTemp;
    }
}

/******************************************************************************/

class CFontComboBox : public CComboBox
{
public:


        int AddFontName(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
                int iFontType);
        CFontDesc* GetFontDesc(int nIndex) {return (CFontDesc*)GetItemData(nIndex);};
        BOOL IsSameName(CFontDesc* pDesc, int index);

        // I'm not really doing the message map stuff
        void ClearList();
} ;

/******************************************************************************/

class CCharSetComboBox : public CComboBox
{
public:        
        int AddCharSet(LPCTSTR lpszScript, BYTE nCharSet);
        int SelectCharSet(int nStartAfter, BYTE nCharSet);
        int GetCurSelCharSet();
} ;

/******************************************************************************/

//
// HACKHACK: All this history stuff is to help make choosing a script for
// a font easier.  There doesn't seem to be anyway to get a "good" script
// for a given font/locale so what we do is save the last serveral scripts
// and hope that the font the user just switched to supports one of them.
//

class CHistoryList
{
public:
    CHistoryList();
    void AddHead(int nNewItem);
    int  GetAt  (unsigned int uIndex);

    enum       { m_uHistorySize = 4 };

private:
    unsigned int m_uHistoryIndex;
    int          m_HistoryList[m_uHistorySize];
};

CHistoryList::CHistoryList()
{
    m_uHistoryIndex = 0;

    for (int i = 0; i < m_uHistorySize; ++i)
    {
        m_HistoryList[i] = -1;
    }
}

void CHistoryList::AddHead(int nNewItem)
{
    m_HistoryList[(++m_uHistoryIndex) % m_uHistorySize] = nNewItem;
}

int CHistoryList::GetAt(unsigned int uIndex)
{
    ASSERT((int)uIndex >= 0 && uIndex < m_uHistorySize);

    return m_HistoryList[(m_uHistoryIndex-uIndex) % m_uHistorySize];
}

static CHistoryList g_CharSetHistoryList;

/******************************************************************************/
// CTfont

BEGIN_MESSAGE_MAP( CTfont, CMiniFrmWnd )
    //{{AFX_MSG_MAP(CTfont)
    ON_CBN_SELCHANGE(IDC_TYPEFACE, OnTypefaceChange)
    ON_CBN_SELCHANGE(IDC_POINTSIZE, OnPointSizeChange)
    ON_CBN_KILLFOCUS(IDC_POINTSIZE, OnPointSizeChange)
    ON_COMMAND(IDOK, OnPointSizeChange)
    ON_CBN_SELCHANGE(IDC_CHARSET, OnTypefaceChange)
    ON_WM_ERASEBKGND()
    ON_WM_SETFOCUS()
    ON_WM_DESTROY()
    ON_WM_MOVE()
    ON_WM_CLOSE()
    ON_WM_RBUTTONDOWN()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_COMMAND(IDC_BOLD, OnBold)
    ON_COMMAND(IDC_ITALIC, OnItalic)
    ON_COMMAND(IDC_UNDERLINE, OnUnderline)

    ON_COMMAND(IDC_VERTEDIT, OnVertEdit)
    ON_UPDATE_COMMAND_UI(IDC_VERTEDIT, OnVertEditUpdate)

    ON_COMMAND(IDC_SHADOW, OnShadow)
    ON_COMMAND(IDC_PENEXT, OnPen)
    ON_COMMAND(IDC_EDITTEXT, OnEditText)
    ON_COMMAND(IDC_KEYBOARD, OnKeyboard)
    ON_COMMAND(IDC_INS_SPACE, OnInsSpace)
    ON_COMMAND(IDC_BACKSPACE, OnBackSpace)
    ON_COMMAND(IDC_NEWLINE, OnNewLine)
        //}}AFX_MSG_MAP

    ON_MESSAGE(UM_DELAYED_TOOLBAR, OnDelayedPen)

END_MESSAGE_MAP()


/******************************************************************************/
// CTfont construction/destruction

CTfont::CTfont( CTedit *pcTedit )
    {
    ASSERT( pcTedit != NULL );

    m_pcTedit = pcTedit;

    m_cStrTypeFaceName.Empty();
    m_cStrTypeFaceNamePrev.Empty();

    m_nCharSet             = DEFAULT_CHARSET;
    m_nCharSetPrev         = DEFAULT_CHARSET;

    m_iWeight              = FW_NORMAL;
    m_bBoldOn              = FALSE;
    m_bItalicOn            = FALSE;
    m_bUnderlineOn         = FALSE;

    m_bVertEditOn          = FALSE;

    m_bShadowOn            = FALSE;
    m_bPenOn               = FALSE;
    m_bInUpdate            = FALSE;
    m_iControlIDLastChange = 0;
    m_iPointSize           = 0;
    m_iPointSizePrev       = 0;
    m_iFontType            = 0;

    m_cRectWindow.SetRectEmpty();

    m_pcTfontTbar = new CTfontTbar();
    }

/******************************************************************************/

CTfont::CTfont()
    {
    m_cStrTypeFaceName.Empty();
    m_cStrTypeFaceNamePrev.Empty();

    m_nCharSet             = DEFAULT_CHARSET;
    m_nCharSetPrev         = DEFAULT_CHARSET;

    m_iWeight              = FW_NORMAL;
    m_bBoldOn              = FALSE;
    m_bItalicOn            = FALSE;
    m_bUnderlineOn         = FALSE;

    m_bVertEditOn          = FALSE;

    m_bShadowOn            = FALSE;
    m_bPenOn               = FALSE;
    m_bInUpdate            = FALSE;
    m_iControlIDLastChange = 0;
    m_iPointSize           = 0;
    m_iPointSizePrev       = 0;
    m_iFontType            = 0;

    m_cRectWindow.SetRectEmpty();

    m_pcTfontTbar = new CTfontTbar();
    }

/******************************************************************************/
// CTfont construction/destruction

CTfont::~CTfont(void)
    {
    SaveToIniFile();

//  *DK* this deletion of the current font assumes this object, the font picker,
//  is going away at the same time the edit control is going away, since this
//  current font is selected into the edit control.

    m_cCurrentFont.DeleteObject();

    if (m_pcTedit)
    {
       m_pcTedit->m_pcTfont = NULL;
       m_pcTedit = NULL;
    }
    delete m_pcTfontTbar;
    }

/******************************************************************************/

BOOL CTfont::Create( CRect rectEditArea )
    {
    BOOL bRC = TRUE;

    CRect cRectWindow( 0, 0, 0, 0 );

    CString pWindowName;

    pWindowName.LoadString( IDS_FONT_TOOL);

    bRC = CMiniFrmWnd::Create( pWindowName, 0, cRectWindow, AfxGetMainWnd() );

    if (bRC != FALSE)
        {
        TRY
            {
            bRC = m_cTfontDlg.Create   ( this );   // can throw excpetion
            bRC = m_pcTfontTbar->Create( this );   // can throw excpetion

            ResizeWindow();
            }
        CATCH(CResourceException, e)
            {
            /*DK* ##ERROR CResourceException caught, could not create either toolbar or dialog bar object */
            }
        END_CATCH
        }
    else
        {
        /*DK* ##ERROR Could not create window for font tool box*/
        }

    ASSERT( bRC != FALSE );

    if (bRC != FALSE)
        {
        RefreshFontList();

        //Select the first item in the combobox.

        CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem( IDC_TYPEFACE );

        ASSERT( pCBox != NULL );

        if (pCBox != NULL)
            {

            // we need to default to font with correct charset or font association.
            CHARSETINFO csi;
            if (!TranslateCharsetInfo((DWORD*)UIntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE))
                csi.ciCharset=ANSI_CHARSET;

            for (int bFound = FALSE, index=0; !bFound && index < pCBox->GetCount();index++)
            {
                CFontDesc* pDesc = (CFontDesc*) pCBox->GetItemData(index);

                for (CCharSetDesc *pCharSetDesc = &pDesc->m_CharSetDesc; !bFound && pCharSetDesc != NULL; pCharSetDesc = pCharSetDesc->m_pNext) 
                {
                    if ( pCharSetDesc->m_nCharSet == csi.ciCharset)
                    {
                        bFound = TRUE;
                        pCBox->SetCurSel(index);
                        g_CharSetHistoryList.AddHead(pCharSetDesc->m_nCharSet);
                    }
                }
            }

            // simulate a selection
            OnTypefaceChange();
            }
        ReadFromIniFile();  // will show the window the same state as saved

        // make sure the font tools does not show up on top of the edit box
        CRect rectFont;
        CRect rect;

        GetWindowRect( &rectFont );

        if (rect.IntersectRect( &rectEditArea, &rectFont ))
            SetWindowPos( &wndTop, rectFont.left,
                          rectEditArea.top - (rectFont.Height() + theApp.m_cyFrame),
                          0, 0, SWP_NOSIZE );

        if (theApp.m_bShowTextToolbar)
            ShowWindow( SW_SHOWNOACTIVATE );
        }
    return bRC;
    }

/***************************************************************************/

BOOL CTfont::PreCreateWindow(CREATESTRUCT& cs)
{
        BOOL bRet = CMiniFrmWnd::PreCreateWindow(cs);

        if (bRet)
        {
                // We don't want CLIENTEDGE on this window
                cs.dwExStyle &= ~WS_EX_CLIENTEDGE;
        }

        return(bRet);
}

/******************************************************************************/

void CTfont::GetFontInfo(int iFontSelection, BYTE nCharSetSelection)
{
        CFontComboBox*    pFontCBox    = (CFontComboBox*)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);
        CCharSetComboBox* pCharSetCBox = (CCharSetComboBox*)m_cTfontDlg.GetDlgItem(IDC_CHARSET);

        CFontDesc* pDesc = pFontCBox->GetFontDesc(iFontSelection);

        m_strFontName = pDesc->m_strName;
        m_iFontType   = pDesc->m_iFontType;

        // set the charset

        m_nCharSetPrev = m_nCharSet;
        m_nCharSet     = nCharSetSelection;

        // fill in the charset combo box with the current set of charsets

        pCharSetCBox->ResetContent();

        for (CCharSetDesc *pCharSetDesc = &pDesc->m_CharSetDesc; pCharSetDesc != NULL; pCharSetDesc = pCharSetDesc->m_pNext) 
            {
            pCharSetCBox->AddCharSet(pCharSetDesc->m_strScript, pCharSetDesc->m_nCharSet);
            }

        // and select the current charset

        pCharSetCBox->SelectCharSet(-1, nCharSetSelection);
}


void CTfont::Undo(void)
    {
    switch( m_iControlIDLastChange )
        {
        case IDC_TYPEFACE:
            if (m_cStrTypeFaceName.Compare(m_cStrTypeFaceNamePrev) != 0)
                {
                TRY
                    {
                    CString cStrTemp = m_cStrTypeFaceName;

                    m_cStrTypeFaceName      = m_cStrTypeFaceNamePrev;
                    m_cStrTypeFaceNamePrev = cStrTemp;

                    CFontComboBox* pCBox = (CFontComboBox*)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);

                    int iSelection = pCBox->SelectString( -1, m_cStrTypeFaceName );

                    ASSERT( iSelection != CB_ERR );

                    if (iSelection != CB_ERR)
                        {
                           GetFontInfo(iSelection, m_nCharSetPrev);
                           ProcessNewTypeface();
                        }
                    }
                CATCH(CMemoryException,e)
                    {
                    /*DK* ##ERROR CString Thrown CMemoryException*/
                    }
                END_CATCH
                }

            // the processing of process new font may cause a re-selection in the
            // combo box (same code as user selection) changing this value.  We
            // must re-set for undo of undo.
            m_iControlIDLastChange = IDC_TYPEFACE;

            break;

        case IDC_POINTSIZE:
            if (m_iPointSize != m_iPointSizePrev)
                {
                int iPointSizeTemp = m_iPointSize;

                m_iPointSize     = m_iPointSizePrev;
                m_iPointSizePrev = iPointSizeTemp;

                m_cTfontDlg.SetDlgItemInt( IDC_POINTSIZE, m_iPointSize );

                UpdateEditControlFont();
                }
            break;

        case IDC_BOLD:
            OnBold();
            RefreshToolBar();
            break;

        case IDC_ITALIC:
            OnItalic();
            RefreshToolBar();
            break;

        case IDC_UNDERLINE:
            OnUnderline();
            RefreshToolBar();
            break;


        case IDC_VERTEDIT:
            OnVertEdit();
            RefreshToolBar();
            break;


        case IDC_SHADOW:
            OnShadow();
            RefreshToolBar();
            break;

        default:
            break;
        }
    }

/******************************************************************************/

void CTfont::RefreshToolBar(void)
    {
    // Set the bold button state
    if (m_bBoldOn)
        {
        m_pcTfontTbar->SetButtonInfo( BOLD_TBAR_POS, IDC_BOLD, TBBS_CHECKBOX | TBBS_CHECKED, BOLD_BMP_POS);
        }
    else
        {
        m_pcTfontTbar->SetButtonInfo( BOLD_TBAR_POS, IDC_BOLD, TBBS_CHECKBOX, BOLD_BMP_POS);
        }

    // Set the italic button state
    if (m_bItalicOn)
        {
        m_pcTfontTbar->SetButtonInfo( ITALIC_TBAR_POS, IDC_ITALIC, TBBS_CHECKBOX | TBBS_CHECKED, ITALIC_BMP_POS);
        }
    else
        {
        m_pcTfontTbar->SetButtonInfo( ITALIC_TBAR_POS, IDC_ITALIC, TBBS_CHECKBOX, ITALIC_BMP_POS);
        }

    // Set the underline button state
    if (m_bUnderlineOn)
        {
        m_pcTfontTbar->SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE, TBBS_CHECKBOX | TBBS_CHECKED, UNDERLINE_BMP_POS);
        }
    else
        {
        m_pcTfontTbar->SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE, TBBS_CHECKBOX, UNDERLINE_BMP_POS);
        }


    // Set the VertEdit button state
        if (m_bVertEditOn)
        {
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT, TBBS_CHECKBOX | TBBS_CHECKED, VERTEDIT_BMP_POS);
        }
    else
        {
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT, TBBS_CHECKBOX, VERTEDIT_BMP_POS);
        }


    // Set the underline button state
    if (theApp.m_bPenSystem)
        if (m_bPenOn)
            {
            m_pcTfontTbar->SetButtonInfo(PEN_TBAR_PEN_POS, IDC_PENEXT, TBBS_CHECKBOX | TBBS_CHECKED, PEN_BMP_POS);
            }
        else
            {
            m_pcTfontTbar->SetButtonInfo(PEN_TBAR_TEXT_POS, IDC_PENEXT, TBBS_CHECKBOX, PEN_BMP_POS);
            }

    // Set the shadow button state
//  currently this is not present on the toolbar.  When it is available, fix the
//  SHADOW_TBAR_POS and SHADOW_BMP_POS #define in tfont.h

//   if (m_bShadowOn)
//       {
//       m_pcTfontTbar->SetButtonInfo(SHADOW_TBAR_POS, IDC_SHADOW, TBBS_CHECKBOX | TBBS_CHECKED, SHADOW_BMP_POS);
//       }
//   else
//       {
//       m_pcTfontTbar->SetButtonInfo(SHADOW_TBAR_POS, IDC_SHADOW, TBBS_CHECKBOX, SHADOW_BMP_POS);
//       }
    }

/******************************************************************************/

void CTfont::ResizeWindow( void )
    {
    CRect cClientRect;
    CRect cRectDlgBar;
    CRect cRectTbar;

    int ixPosDlgBar   = 0;
    int iyPosDlgBar   = 0;
    int ixPosTbar     = 0;
    int iyPosTbar     = 0;
    int iWindowHeight = 0;
    int iWindowWidth  = 0;
    int iBorder       = 0;
    int ixNCBorder    = 0;
    int iyNCBorder    = 0;

    ixNCBorder += theApp.m_cxBorder * 2;
    iyNCBorder += theApp.m_cyBorder * 2;
    iyNCBorder += theApp.m_cyCaption;

    m_cTfontDlg.GetWindowRect( &cRectDlgBar );

    cRectTbar.SetRectEmpty();

    m_pcTfontTbar->GetWindowRect( &cRectTbar );

    // /4 since border is for top/bottom or left/right
    // the boder is 1/4 the height of the tool/dialog bar
    iBorder += cRectDlgBar.Height() / 4;

    // Compute the Width
    // Width is combination of both
    iWindowWidth += ixNCBorder;
    iWindowWidth += cRectDlgBar.Width();
    iWindowWidth += cRectTbar.Width();
    iWindowWidth += 3 * iBorder;  // border on left and right and between dlgbar and tbar

    // Compute the Height
    // Height is combination of both
    iWindowHeight += iyNCBorder;
    iWindowHeight += cRectDlgBar.Height();
    iWindowHeight += 2 * iBorder;  // border on top and bottom

    // position the main window
    if (GetSafeHwnd() != NULL)
        {
        // size this window to fit children
        SetWindowPos(&wndTop, 0, 0, iWindowWidth, iWindowHeight, SWP_NOMOVE);
        }

    GetClientRect(&cClientRect);

    // calculate the x positions of the 2 control bars (next to eachother)
    ixPosDlgBar   = iBorder;
    ixPosTbar     = iBorder * 2 + cRectDlgBar.Width();

    // center the 2 control bars in the vertical position
    iyPosDlgBar   = (cClientRect.Height() - cRectDlgBar.Height()) / 2;
    iyPosTbar     = (cClientRect.Height() - cRectTbar.Height()) / 2;

    // Position the Dialog Bar
    if (m_cTfontDlg.GetSafeHwnd() != NULL)
        {
        m_cTfontDlg.SetWindowPos(&wndTop, ixPosDlgBar, iyPosDlgBar, 0, 0, SWP_NOSIZE);
        m_cTfontDlg.ShowWindow(SW_SHOWNOACTIVATE);
        }

    // Position the Toolbar
    if (m_pcTfontTbar->GetSafeHwnd() != NULL)
        {
        m_pcTfontTbar->SetWindowPos(&wndTop, ixPosTbar, iyPosTbar, 0, 0, SWP_NOSIZE);
        m_pcTfontTbar->ShowWindow(SW_SHOWNOACTIVATE);
        }
    }

/******************************************************************************/


/******************************************************************************/
/*                                                                            */
/* Ini File section format  PBrush.INI in Windows Dir                         */
/* [Text]                                                                     */
/* TypeFaceName= string                                                       */
/* PointSize=  #                                                              */
/* FontPalette= x y nCmdShow  (x,y) is location screen.  nCmdShow is param to */
/* Bold= ON   F                              ShowWindow of SW_SHOW or SW_HIDE */
/* Italic= ON                                                                 */
/* Underline= ON                                                              */
/*                                                                            */
/******************************************************************************/

void CTfont::SaveToIniFile(void)
    {
    theApp.m_iPointSize      = m_iPointSize;
    theApp.m_strTypeFaceName = m_cStrTypeFaceName;
    theApp.m_iCharSet        = m_nCharSet;
    theApp.m_iPosTextX       = m_cRectWindow.left;
    theApp.m_iPosTextY       = m_cRectWindow.top;
    theApp.m_iBoldText       = m_bBoldOn;
    theApp.m_iItalicText     = m_bItalicOn;
    theApp.m_iUnderlineText  = m_bUnderlineOn;

    theApp.m_iVertEditText   = m_bVertEditOn;

    theApp.m_iPenText        = m_bPenOn;
    }

/******************************************************************************/
/* See Save to ini for format of ini file                                     */

void CTfont::ReadFromIniFile(void)
    {
    CRect rect;

    GetWindowRect( &rect );

    CSize size = rect.Size();

    CPoint ptPos = theApp.CheckWindowPosition( CPoint( theApp.m_iPosTextX,
                                                       theApp.m_iPosTextY ),
                                               size );
    if (! ptPos.x
    &&  ! ptPos.y)
        {
        AfxGetMainWnd()->GetWindowRect( &rect );

        rect.OffsetRect( 15, 15 );

        ptPos.x = rect.left;
        ptPos.y = rect.top;
        }

    if (GetSafeHwnd() != NULL)
        {
        SetWindowPos(&wndTop, ptPos.x, ptPos.y, 0, 0, SWP_NOSIZE);
        }

    if (theApp.m_strTypeFaceName.IsEmpty() == 0)
        {
        m_cStrTypeFaceName = theApp.m_strTypeFaceName;
        m_iPointSize = theApp.m_iPointSize;

//        m_iPointSize = 0; // 0 is initial value => 1st in list will be selected

        CFontComboBox* pCBox = (CFontComboBox*)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);

        int iSelection = pCBox->SelectString(-1, m_cStrTypeFaceName);

        if (iSelection != CB_ERR)
            {
            CFontDesc* pDesc = pCBox->GetFontDesc(iSelection);
            BYTE nNewCharSet = PickCharSet(&pDesc->m_CharSetDesc, theApp.m_iCharSet);

            GetFontInfo(iSelection, nNewCharSet);

            ProcessNewTypeface();  // this will also set the pointsize to what we have in our variable
            }
        }

    if (theApp.m_iBoldText)
        {
        m_bBoldOn = FALSE;
        OnBold();  // toggles from false to TRUE
        m_pcTfontTbar->SetButtonInfo(BOLD_TBAR_POS, IDC_BOLD,  TBBS_CHECKBOX | TBBS_CHECKED, BOLD_BMP_POS);
        }

    if (theApp.m_iItalicText)
        {
        m_bItalicOn = FALSE;
        OnItalic();  // toggles from false to TRUE
        m_pcTfontTbar->SetButtonInfo(ITALIC_TBAR_POS, IDC_ITALIC,  TBBS_CHECKBOX | TBBS_CHECKED, ITALIC_BMP_POS);
        }

    if (theApp.m_iUnderlineText)
        {
        m_bUnderlineOn = FALSE;
        OnUnderline();  // toggles from false to TRUE
        m_pcTfontTbar->SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE,  TBBS_CHECKBOX | TBBS_CHECKED, UNDERLINE_BMP_POS);
        }


        if (theApp.m_iVertEditText == -1)       //no setting in profile
                {
                        theApp.m_iVertEditText = (IS_DBCS_CHARSET(m_nCharSet)) ? FALSE : 2;
                }

        if (theApp.m_iVertEditText == 2)
                {
                m_bVertEditOn = 2;
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT,  TBBS_CHECKBOX | TBBS_DISABLED, VERTEDIT_BMP_POS);
                }
    else if (theApp.m_iVertEditText)
        {
        m_bVertEditOn = FALSE;
        OnVertEdit();  // toggles from false to TRUE
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT,  TBBS_CHECKBOX | TBBS_CHECKED, VERTEDIT_BMP_POS);
        }
        else
        {
        m_bVertEditOn = FALSE;
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT,  TBBS_CHECKBOX, VERTEDIT_BMP_POS);
        }


    if (theApp.m_bPenSystem)
        if (theApp.m_iPenText)
            {
            m_bPenOn = FALSE;
            OnPen();  // toggles from false to TRUE
            }
    }

/******************************************************************************/

void CTfont::RefreshFontList(void)
    {
        CFontComboBox* pBox = (CFontComboBox *)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);
        pBox->ClearList();

    CClientDC cdcWindow(this);
    HDC hDC = cdcWindow.GetSafeHdc();

    ASSERT(hDC != NULL);

    if (hDC != NULL)
        {
        FONTENUMPROC lpEnumFamCallBack;
        lpEnumFamCallBack = (FONTENUMPROC) CTfont::EnumFontFaceProc;

        LOGFONT lf;
        memset(&lf, 0, sizeof(lf));
        lf.lfCharSet = DEFAULT_CHARSET;

        ::EnumFontFamiliesEx(hDC, &lf, lpEnumFamCallBack, (LPARAM) this, NULL);
        }
    }

/******************************************************************************/

int CFontComboBox::AddFontName(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
        int iFontType)
{
        int nIndex = FindStringExact(-1, lpszName);
        if (nIndex != CB_ERR)
        {
                // add this new charset to the end of the charset list

                CFontDesc* pDesc = (CFontDesc*) GetItemData(nIndex);

                CCharSetDesc *pCharSetDesc = &pDesc->m_CharSetDesc;

                while (pCharSetDesc->m_pNext != NULL) 
                {
                    pCharSetDesc = pCharSetDesc->m_pNext;
                }

                pCharSetDesc->m_pNext = new CCharSetDesc(lpszScript, nCharSet);

                return(nIndex);
        }

        CFontDesc* pDesc = new CFontDesc(lpszName, lpszScript, nCharSet, iFontType);
        if (!pDesc)
        {
                return(-1);
        }

        nIndex = AddString(lpszName);
        ASSERT(nIndex >=0);
        if (nIndex >=0) //no error
        {
                SetItemData(nIndex, (DWORD_PTR)pDesc);
        }
        else
        {
                delete pDesc;
        }

        return nIndex;
}

void CFontComboBox::ClearList()
{
        // destroy all the CFontDesc's
        int nCount = GetCount();
        for (int i=0;i<nCount;i++)
                delete GetFontDesc(i);

        ResetContent();
}

BOOL CFontComboBox::IsSameName(CFontDesc* pDesc, int index)
{
        CFontDesc* pDescOther = GetFontDesc(index);
        if (pDescOther == (CFontDesc*)CB_ERR)
        {
                return(FALSE);
        }

        return(lstrcmp(pDesc->m_strName, pDescOther->m_strName) == 0);
}

int CCharSetComboBox::AddCharSet(LPCTSTR lpszScript, BYTE nCharSet)
{
    int nIndex = AddString(lpszScript);

    if (nIndex != CB_ERR && nIndex != CB_ERRSPACE)
    {
        SetItemData(nIndex, nCharSet);
    }

    return nIndex;
}

int CCharSetComboBox::SelectCharSet(int nStartAfter, BYTE nCharSet)
{
    for (int i = nStartAfter+1; i < GetCount(); ++i)
    {
        if ((BYTE) GetItemData(i) == nCharSet) 
        {
            return SetCurSel(i);
        }
    }

    return CB_ERR;
}

int CCharSetComboBox::GetCurSelCharSet()
{
    int iSelection = GetCurSel();

    if (iSelection != CB_ERR)
        {
        iSelection = (int) GetItemData(iSelection);
        }

    return iSelection;
}


int CTfont::EnumFontFace( ENUMLOGFONTEX*   lpEnumLogFont,
                          NEWTEXTMETRICEX* lpNewTextMetric,
                          int iFontType )
{
        // only enumerate TrueType faces
        // in DBCS builds also exclude vertical faces
        if ((lpEnumLogFont->elfLogFont.lfCharSet != OEM_CHARSET)
                && (lpEnumLogFont->elfLogFont.lfCharSet != MAC_CHARSET)

                && (lpEnumLogFont->elfLogFont.lfFaceName[0] != TEXT('@'))

                )
        {
                INT  ntmFlags = lpNewTextMetric->ntmTm.ntmFlags;
                CFontComboBox* pBox = (CFontComboBox *)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);

                if (ntmFlags & NTM_PS_OPENTYPE)
                    iFontType = PS_OPENTYPE_FONT;
                else if  (ntmFlags & NTM_TYPE1)
                    iFontType = TYPE1_FONT;
                else
                {
                    if (iFontType & TRUETYPE_FONTTYPE)
                    {
                        if (ntmFlags & NTM_TT_OPENTYPE)
                            iFontType = TT_OPENTYPE_FONT;
                        else
                            iFontType = TT_FONT;
                    }
                    else if (iFontType & DEVICE_FONTTYPE)
                        iFontType = DEVICE_FONT;
                    else if (iFontType & RASTER_FONTTYPE)
                        iFontType = RASTER_FONT;
                }

                pBox->AddFontName(lpEnumLogFont->elfLogFont.lfFaceName,
                        (LPCTSTR)lpEnumLogFont->elfScript, lpEnumLogFont->elfLogFont.lfCharSet, iFontType);
        }
        return 1;
}

/******************************************************************************/

int CALLBACK CTfont::EnumFontFaceProc( ENUMLOGFONTEX*   lpEnumLogFont,
                                       NEWTEXTMETRICEX* lpNewTextMetric,
                                       int iFontType, LPARAM lParam )
    {
    class CTfont* pCTfont;

    ASSERT(lParam != NULL);

    if (lParam != NULL)
        {
        pCTfont = (CTfont*)lParam;
        return pCTfont->EnumFontFace(lpEnumLogFont, lpNewTextMetric, iFontType);
        }

    return 0;
    }

/******************************************************************************/

int  CTfont::EnumFontSizes( LPENUMLOGFONT lpEnumLogFont,
                            LPNEWTEXTMETRIC lpNewTextMetric,
                            int iFontType )
    {
    int iPtSize;

    /* testint */

    CAttrEdit* pcEdit = m_pcTedit->GetEditWindow();

    ASSERT(pcEdit != NULL);

    if (pcEdit != NULL)
        {
        CClientDC cdcClient( pcEdit );

        // ptsize = char height * 72 / pixels  per inch
        // char height = cell height - internal leading

        iPtSize = MulDiv( lpNewTextMetric->tmHeight -
                          lpNewTextMetric->tmInternalLeading,
                      72, cdcClient.GetDeviceCaps( LOGPIXELSY ) );
        }

    TCHAR buffTmp[10];

    // Leading zero prefixed for Combobox sorting order.
    wsprintf( buffTmp, TEXT("%2d"), iPtSize );

    CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem(IDC_POINTSIZE);

    ASSERT (pCBox != NULL);

    if (pCBox != NULL)
        {
        // only add the string if it does not exist
        int iRC = pCBox->FindStringExact(-1, buffTmp);

        if (iRC == CB_ERR)
            {
            pCBox->AddString(buffTmp);
            }
        }
    return 1;
    }

/******************************************************************************/

int CALLBACK CTfont::EnumFontOneFaceProc( LPENUMLOGFONT lpEnumLogFont,
                                                  LPNEWTEXTMETRIC lpNewTextMetric,
                                                  int iFontType, LPARAM lParam )
    {
    class CTfont* pCTfont;

    ASSERT(lParam != NULL);

    if (lParam != NULL)
        {
        pCTfont = (CTfont*)lParam;
        return pCTfont->EnumFontSizes(lpEnumLogFont, lpNewTextMetric, iFontType);
        }

    return 0;
    }

/******************************************************************************/
// User selected a new typeface in the combo box
/******************************************************************************/

void CTfont::ProcessNewTypeface(void)
    {
    CString cStringText;
    CClientDC cdcDlgBox( this );
    HDC hDC = cdcDlgBox.GetSafeHdc();

    ASSERT(hDC != NULL);

    if (hDC != NULL)
        {
        FONTENUMPROC lpEnumFamCallBack;
        lpEnumFamCallBack = (FONTENUMPROC)CTfont::EnumFontOneFaceProc;

        CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem(IDC_POINTSIZE);

        ASSERT (pCBox != NULL);

        if (pCBox != NULL)
            {
            pCBox->ResetContent();

            // only do this if non-true-type font  if true type, filll in with  default sizes
            if (
                (m_iFontType & (TT_FONT | TT_OPENTYPE_FONT)) ||
                !( (m_iFontType & (TT_FONT | TT_OPENTYPE_FONT)) || (m_iFontType & RASTER_FONT) )
                ) // if truetype or vector font
                {
                // True Type and Vector Fonts are continuously scallable.
                // There are the reccomended values
                pCBox->AddString(TEXT(" 8"));
                pCBox->AddString(TEXT(" 9"));
                pCBox->AddString(TEXT("10"));
                pCBox->AddString(TEXT("11"));
                pCBox->AddString(TEXT("12"));
                pCBox->AddString(TEXT("14"));
                pCBox->AddString(TEXT("16"));
                pCBox->AddString(TEXT("18"));
                pCBox->AddString(TEXT("20"));
                pCBox->AddString(TEXT("22"));
                pCBox->AddString(TEXT("24"));
                pCBox->AddString(TEXT("26"));
                pCBox->AddString(TEXT("28"));
                pCBox->AddString(TEXT("36"));
                pCBox->AddString(TEXT("48"));
                pCBox->AddString(TEXT("72"));
                }
            else
                {
                ::EnumFontFamilies(hDC, m_strFontName, lpEnumFamCallBack, (LPARAM) this);
                }

            // 0 is uninitialized value
            if (m_iPointSize != 0)
                {
                m_cTfontDlg.SetDlgItemInt(IDC_POINTSIZE, m_iPointSize);
                }
            else
                {
                pCBox->SetCurSel(0);
                }
           // simulate a selection
           OnPointSizeComboBoxUpdate();
           }
       }
    }

/******************************************************************************/
// change the font in the edit control based on the font selection
/******************************************************************************/

void CTfont::UpdateEditControlFont(void)
    {
    LOGFONT    lf;
    CFont*     pcOldFont;
    BOOL       bRC;
    HFONT      hFont;
    int        iCellHeight = 0;

    BeginWaitCursor();


    CAttrEdit* pcEdit = m_pcTedit->GetEditWindow();

    ASSERT(pcEdit != NULL);

    if (pcEdit != NULL)
        {
        CClientDC cdcClient( pcEdit );

        //previous font's tm.tmInternalLeading could be different from current.
        iCellHeight = - MulDiv(m_iPointSize, cdcClient.GetDeviceCaps(LOGPIXELSY)
                      ,72);
        }

    lf.lfWidth          = 0;
    lf.lfHeight         = iCellHeight;

    lf.lfEscapement     = (m_bVertEditOn == TRUE) ? 2700 : 0;
    lf.lfOrientation    = (m_bVertEditOn == TRUE) ? 2700 : 0;
    lf.lfWeight         = m_iWeight;
    lf.lfItalic         = (BYTE)m_bItalicOn;
    lf.lfUnderline      = (BYTE)m_bUnderlineOn;
    lf.lfStrikeOut      = 0;
    lf.lfCharSet        = m_nCharSet;
    lf.lfOutPrecision   = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
    lf.lfQuality        = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = FF_DONTCARE | DEFAULT_PITCH;


    if ( (m_bVertEditOn == TRUE) && IS_DBCS_CHARSET( lf.lfCharSet ) )
         {
         lstrcpy(lf.lfFaceName, TEXT("@"));
         lstrcpyn(lf.lfFaceName + 1, m_strFontName, ARRAYSIZE(lf.lfFaceName) - 1);
         }
     else
         lstrcpyn(lf.lfFaceName, m_strFontName, ARRAYSIZE(lf.lfFaceName));

    hFont = (HFONT)m_cCurrentFont.Detach();
    bRC = m_cCurrentFont.CreateFontIndirect(&lf);

    ASSERT(bRC != 0);

    if (bRC != 0)
        {
        if (m_pcTedit != NULL)
            {
            CAttrEdit* pcEdit = m_pcTedit->GetEditWindow();

            ASSERT( pcEdit != NULL );

            pcOldFont = pcEdit->GetFont();
            pcEdit->SetFont( &m_cCurrentFont );
            m_pcTedit->OnAttrEditFontChange();
            m_pcTedit->RefreshWindow();
            }

        //hFont is last font allocated here
        if (hFont != NULL)
            {
            ::DeleteObject( hFont );
            }
        }
    else
        {
        /*DK* ##ERROR Could not create font indirect */
        }

    EndWaitCursor();
    }

/******************************************************************************/
/******************************************************************************/

BYTE CTfont::PickCharSet(CCharSetDesc *pCharSetDescList, int iCharSetSelection)
{
    ASSERT(pCharSetDescList);

    // place the selected charset on top of the charset history list

    if (iCharSetSelection != g_CharSetHistoryList.GetAt(0) && iCharSetSelection != -1)
    {
        g_CharSetHistoryList.AddHead(iCharSetSelection);
    }

    // try to select a charset from the history list

    for (unsigned int i = 0; i < g_CharSetHistoryList.m_uHistorySize; ++i) 
    {
        int nSearchCharSet = g_CharSetHistoryList.GetAt(i);

        if (nSearchCharSet != -1) 
        {
            for (CCharSetDesc *pCharSetDesc = pCharSetDescList; pCharSetDesc != NULL; pCharSetDesc = pCharSetDesc->m_pNext) 
            {
                if (pCharSetDesc->m_nCharSet == (BYTE) nSearchCharSet)
                {
                    return (BYTE) nSearchCharSet;
                }
            }
        }
    }

    // if we fail to find a match, select the first charset

    return pCharSetDescList->m_nCharSet;
}

/******************************************************************************/
// Combo box for type face changed, determine what processing to do
/******************************************************************************/

void CTfont::OnTypeFaceComboBoxUpdate(void)
    {
    int iSelection;
    CString cStringText;

//  LPFONTINFORMATION lpFontInformation;

    CFontComboBox*    pFontCBox    = (CFontComboBox*)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);
    CCharSetComboBox* pCharSetCBox = (CCharSetComboBox*)m_cTfontDlg.GetDlgItem(IDC_CHARSET);

    ASSERT(pFontCBox != NULL && pCharSetCBox != NULL);

    if (pFontCBox != NULL && pCharSetCBox != NULL)
        {
        TRY
            {
            iSelection = pFontCBox->GetCurSel();

            ASSERT(iSelection != CB_ERR);

            if (iSelection != CB_ERR)
                {
                pFontCBox->GetLBText(iSelection, cStringText);
                }
            }
        CATCH(CMemoryException,e)
            {
            cStringText.Empty();
            /*DK* ##ERROR CString Thrown CMemoryException*/
            }
        END_CATCH

        int iCharSetSelection = pCharSetCBox->GetCurSelCharSet();

        if (m_cStrTypeFaceName.Compare(cStringText) != 0 || (BYTE) iCharSetSelection != m_nCharSet)
            {
            CFontDesc* pDesc = pFontCBox->GetFontDesc(iSelection);

            BYTE nNewCharSet = PickCharSet(&pDesc->m_CharSetDesc, iCharSetSelection);

            if ( IS_DBCS_CHARSET( nNewCharSet ) )
                {
                if ( m_bVertEditOn == 2 )
                    {
                    m_bVertEditOn = FALSE;
                    m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT,
                                                 TBBS_CHECKBOX, VERTEDIT_BMP_POS);
                    }
                }
            else
                {
                if ( m_bVertEditOn == TRUE )
                    {
                    AfxMessageBox(IDS_ERROR_DBCSFONTONLY);
                    pFontCBox->SelectString( -1, m_cStrTypeFaceName );
                    pCharSetCBox->SelectCharSet( -1, m_nCharSet );
                    return;
                    }
                else
                    {
                    m_bVertEditOn = 2;
                    m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT, TBBS_CHECKBOX | TBBS_DISABLED, VERTEDIT_BMP_POS);
                    }
                }


            // could have been set in OnCloseUpTypeFace method, so don't do double
            // processing
            TRY
                {
                m_cStrTypeFaceNamePrev = m_cStrTypeFaceName;
                m_cStrTypeFaceName = cStringText;
                }
            CATCH(CMemoryException,e)
                {
                m_cStrTypeFaceName.Empty();
                /*DK* ##ERROR CString Thrown CMemoryException*/
                }
            END_CATCH

            GetFontInfo(iSelection, nNewCharSet);

            ProcessNewTypeface();
            m_iControlIDLastChange = IDC_TYPEFACE;
            }
        }
    }

/******************************************************************************/

void CTfont::OnPointSizeComboBoxUpdate(void)
    {
    int iSelection;
    int iHeight;
    CString cStringText;

    CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem(IDC_POINTSIZE);

    ASSERT(pCBox != NULL);

    if (pCBox != NULL)
        {
        TRY
            {
            iSelection = pCBox->GetCurSel();

            if (iSelection != CB_ERR)
                {
                pCBox->GetLBText(iSelection, cStringText);
                iHeight = Atoi(cStringText);
                }
            else
                {
                // if no selection, get displayed value in combo edit part
                iHeight = m_cTfontDlg.GetDlgItemInt(IDC_POINTSIZE);
                }
            }
        CATCH(CMemoryException,e)
            {
            cStringText.Empty();
            /*DK* ##ERROR CString Thrown CMemoryException*/
            }
        END_CATCH


        if (iHeight !=0 )
            {
            if (iHeight != m_iPointSize )
                                {
                    // could have been set in OnCloseUpTypeFace method, so don't do double
                    // processing
                    m_iPointSizePrev = m_iPointSize;
                    m_iPointSize = iHeight;
                    }
                        }
                else
                        {
                        AfxMessageBox(IDS_ERROR_FONTSIZENUMERIC);
                        m_cTfontDlg.SetDlgItemInt(IDC_POINTSIZE,m_iPointSize);
                        }

        // need to call update font  because could be same size with diff
        // typeface, and we got called indirectly by filling the combo box
        UpdateEditControlFont();
        m_iControlIDLastChange = IDC_POINTSIZE;
        }
    }

/******************************************************************************/

void CTfont::OnTypefaceChange()
    {
    if (! m_bInUpdate)
        {
        m_bInUpdate = TRUE;
        OnTypeFaceComboBoxUpdate();
        m_bInUpdate = FALSE;
        }
    }

/******************************************************************************/

void CTfont::OnPointSizeChange()
    {
    if (! m_bInUpdate)
        {
        m_bInUpdate = TRUE;
        OnPointSizeComboBoxUpdate();
        m_bInUpdate = FALSE;
        }
    }

/******************************************************************************/

void CTfont::OnRButtonDown(UINT nFlags, CPoint point)
    {
#if 0
    CMenu cMenuPopup;
    CMenu *pcContextMenu;
    BOOL  bRC;

    bRC = cMenuPopup.LoadMenu(IDR_TEXT_POPUP);

    ASSERT(bRC != 0);

    if (bRC != 0)
        {
        pcContextMenu = cMenuPopup.GetSubMenu(ID_TOOL_POPUPMENU_POS);
        ASSERT(pcContextMenu != NULL);
        if (pcContextMenu != NULL)
            {
            ClientToScreen(&point);
            pcContextMenu->TrackPopupMenu(TPM_LEFTALIGN, point.x, point.y, this, NULL);
            }
        }
    else
        {
        /*DK* ##ERROR Could not loadmenu */
        }
#endif
    }

/******************************************************************************/

void CTfont::OnMove(int x, int y)
    {
    CMiniFrmWnd::OnMove(x, y);

    // TODO: Add your message handler code here
    GetWindowRect(&m_cRectWindow);
    }

/******************************************************************************/

void CTfont::OnClose()
    {
    theApp.m_bShowTextToolbar = FALSE;

    ShowWindow( SW_HIDE );
    }

/******************************************************************************/

BOOL CTfont::OnEraseBkgnd( CDC* pDC )
    {
    CRect rect;

    GetClientRect( rect );

    pDC->FillRect( rect, GetSysBrush( COLOR_BTNFACE ) );

        return CMiniFrmWnd::OnEraseBkgnd( pDC );
    }

/******************************************************************************/

void CTfont::OnSetFocus(CWnd* pOldWnd)
    {
    CMiniFrmWnd::OnSetFocus(pOldWnd);

    CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem( IDC_TYPEFACE );

    ASSERT(pCBox != NULL);

    if (pCBox != NULL)
        {
        pCBox->SetFocus();
        }
    }

/******************************************************************************/

void CTfont::OnDestroy()
{
        CFontComboBox* pBox = (CFontComboBox *)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);
        pBox->ClearList();

        CMiniFrmWnd::OnDestroy();
}

/******************************************************************************/

void CTfont::OnBold(void)
    {
    m_iControlIDLastChange = IDC_BOLD;

    m_bBoldOn = !m_bBoldOn;

    if (m_bBoldOn)
        {
        m_iWeight = FW_BOLD;
        }
    else
        {
        m_iWeight = FW_NORMAL;
        }

    UpdateEditControlFont();
    }

/******************************************************************************/

void CTfont::OnItalic(void)
    {
    m_bItalicOn = !m_bItalicOn;

    UpdateEditControlFont();

    m_iControlIDLastChange = IDC_ITALIC;
    }

/******************************************************************************/

void CTfont::OnUnderline(void)
    {
    m_bUnderlineOn = !m_bUnderlineOn;

    UpdateEditControlFont();

    m_iControlIDLastChange = IDC_UNDERLINE;
    }


/******************************************************************************/

void CTfont::OnVertEdit(void)
    {
    if (m_bVertEditOn == 2)
        {
        return;
        }

    m_bVertEditOn = !m_bVertEditOn;
    m_pcTedit->m_bVertEdit = m_bVertEditOn;
    UpdateEditControlFont();
    m_iControlIDLastChange = IDC_VERTEDIT;
    }

/******************************************************************************/

void CTfont::OnVertEditUpdate(CCmdUI* pCmdUI)
    {
        pCmdUI->Enable( !(m_bVertEditOn == 2) );
    }


/******************************************************************************/

void CTfont::OnShadow(void)
    {
    m_bShadowOn = !m_bShadowOn;

    UpdateEditControlFont();

    m_iControlIDLastChange = IDC_SHADOW;
    }

/******************************************************************************/

void CTfont::OnPen(void)
    {
    PostMessage( UM_DELAYED_TOOLBAR );
    }

/******************************************************************************/

long CTfont::OnDelayedPen( WPARAM, LPARAM )
    {
    if (! theApp.m_bPenSystem)
        m_bPenOn = FALSE;

    m_bPenOn               = !m_bPenOn;
    m_iControlIDLastChange = IDC_PENEXT;

    delete m_pcTfontTbar;

    m_pcTfontTbar = new CTfontTbar();

    BOOL bRC = m_pcTfontTbar->Create( this, m_bPenOn );

    if (bRC)
        {
        ResizeWindow();
        RefreshToolBar();
        }
    return 0;
    }

/******************************************************************************/

void CTfont::OnEditText(void)
    {
    m_iControlIDLastChange = IDC_EDITTEXT;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        ctl->SetFocus();
        #ifndef NT
        // NT doesn't support pen computing
        ctl->SendMessage(WM_PENMISC, PMSC_EDITTEXT, 0);
        #endif
        }
    }

/******************************************************************************/

void CTfont::OnKeyboard(void)
    {
    m_iControlIDLastChange = IDC_KEYBOARD;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        }
    }

/******************************************************************************/

void CTfont::OnInsSpace(void)
    {
    m_iControlIDLastChange = IDC_INS_SPACE;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        ctl->SendMessage(WM_CHAR, (WPARAM)VK_SPACE, 0);
        ctl->SetFocus();
        }
    }

/******************************************************************************/

void CTfont::OnBackSpace(void)
    {
    m_iControlIDLastChange = IDC_BACKSPACE;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        ctl->SendMessage(WM_CHAR, (WPARAM)VK_BACK, 0);
        ctl->SetFocus();
        }
    }

/******************************************************************************/

void CTfont::OnNewLine(void)
    {
    m_iControlIDLastChange = IDC_NEWLINE;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        ctl->SendMessage(WM_CHAR, (WPARAM)VK_RETURN, 0);
        ctl->SetFocus();
        }
    }

/******************************************************************************/

void CTfontDlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
    {
    CString   cStringText;
    CComboBox cCBox;
    BOOL      bRC;

    TRY
        {
        ASSERT( lpDrawItemStruct->CtlType == ODT_COMBOBOX );
        ASSERT( lpDrawItemStruct->CtlID   == IDC_TYPEFACE );

        if (lpDrawItemStruct->CtlType != ODT_COMBOBOX
        ||  lpDrawItemStruct->CtlID   != IDC_TYPEFACE)
            {
            AfxThrowNotSupportedException();
            }

        // empty combo boxes have -1 id

        if (lpDrawItemStruct->itemID != 0xFFFFFFFF)
            {
            bRC = cCBox.Attach(lpDrawItemStruct->hwndItem);

            ASSERT(bRC != 0);

            if (bRC == 0)
                {
                AfxThrowNotSupportedException();
                }

            TRY
                {
                cCBox.GetLBText(lpDrawItemStruct->itemID, cStringText);
                cCBox.Detach();

                DrawItem(lpDrawItemStruct, &cStringText);
                }
            CATCH(CMemoryException,e)
                {
                cStringText.Empty();
                cCBox.Detach();
                /*DK* ##ERROR CString Thrown CMemoryException*/
                }
            END_CATCH
            }
        }
    CATCH(CNotSupportedException,e)
        {
        CWnd::OnDrawItem(nIDCtl, lpDrawItemStruct);
        }
    END_CATCH
    }

/******************************************************************************/


void CTfont::OnLButtonDown(UINT nFlags, CPoint point)
    {
    CMiniFrmWnd::OnLButtonDown(nFlags, point);
    }

/******************************************************************************/

void CTfont::OnLButtonUp(UINT nFlags, CPoint point)
    {
    CMiniFrmWnd::OnLButtonUp( nFlags, point );
    }

/******************************************************************************/

void CTfont::RecalcLayout(BOOL bNotify /*= TRUE*/)
    {
    if (m_pcTfontTbar && m_pcTfontTbar->m_hWnd && m_cTfontDlg.m_hWnd)
        {
        ResizeWindow();
        }
    }

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
// CTfontTbar

BEGIN_MESSAGE_MAP( CTfontTbar, CToolBar )
    //{{AFX_MSG_MAP(CTfontTbar)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //  ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/
// CTfontTbar construction/destruction

CTfontTbar::CTfontTbar(void)
    {
    }

/******************************************************************************/

BOOL CTfontTbar::Create(CWnd* pcParentWnd, BOOL bShowPen)
    {
    BOOL bRC = TRUE;
    int iNumButtons;
    int iNumSeparators;

    UINT ButtonIDS[MAX_TBAR_ITEMS];

    if (bShowPen)
        {
        ButtonIDS[0]   = IDC_BOLD;
        ButtonIDS[1]   = IDC_ITALIC;
        ButtonIDS[2]   = IDC_UNDERLINE;


        ButtonIDS[3]   = IDC_VERTEDIT;

        ButtonIDS[4]   = ID_SEPARATOR;
        ButtonIDS[5]   = IDC_INS_SPACE;
        ButtonIDS[6]   = IDC_BACKSPACE;
        ButtonIDS[7]   = IDC_NEWLINE;

        ButtonIDS[8]   = ID_SEPARATOR;
        ButtonIDS[9]   = IDC_EDITTEXT;

        ButtonIDS[10]  = ID_SEPARATOR;
        ButtonIDS[11]  = IDC_PENEXT;

        iNumButtons    = 12;
        iNumSeparators = 3;
        }
    else
        {
        ButtonIDS[0] = IDC_BOLD;
        ButtonIDS[1] = IDC_ITALIC;
        ButtonIDS[2] = IDC_UNDERLINE;

        ButtonIDS[3] = IDC_VERTEDIT;


        if (theApp.m_bPenSystem)
            {

            ButtonIDS[4] = ID_SEPARATOR;

            ButtonIDS[5] = IDC_PENEXT;
            iNumButtons    = 6;
            iNumSeparators = 1;
            }
        else
            {

            iNumButtons    = 4;
            iNumSeparators = 0;
            }
        }

    bRC = CToolBar::Create( pcParentWnd, CBRS_ALIGN_TOP );

    if (bRC == 0)
        {
        AfxThrowResourceException();
        /*DK* ##ERROR Could not create toolbar object*/
        }

    bRC = LoadBitmap(IDB_TEXT_TBAR);

    if (bRC == 0)
        {
        AfxThrowResourceException();
        /*DK* ##ERROR Could not load bitmap for toolbar*/
        }

    bRC = SetButtons(ButtonIDS, iNumButtons);

    if (bShowPen)
        {
        // Set the style to be checkbox  style.
        SetButtonInfo(BOLD_TBAR_POS,      IDC_BOLD,       TBBS_CHECKBOX, BOLD_BMP_POS);
        SetButtonInfo(ITALIC_TBAR_POS,    IDC_ITALIC,     TBBS_CHECKBOX, ITALIC_BMP_POS);
        SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE,  TBBS_CHECKBOX, UNDERLINE_BMP_POS);

        SetButtonInfo(VERTEDIT_TBAR_POS,  IDC_VERTEDIT,   TBBS_CHECKBOX, VERTEDIT_BMP_POS);



        SetButtonInfo(INS_SPACE_TBAR_POS, IDC_INS_SPACE,  TBBS_BUTTON, INS_SPACE_BMP_POS);
        SetButtonInfo(BACKSPACE_TBAR_POS, IDC_BACKSPACE,  TBBS_BUTTON, BACKSPACE_BMP_POS);
        SetButtonInfo(NEWLINE_TBAR_POS,   IDC_NEWLINE,    TBBS_BUTTON, NEWLINE_BMP_POS);

        SetButtonInfo(EDITTEXT_TBAR_POS,  IDC_EDITTEXT,   TBBS_BUTTON, EDITTEXT_BMP_POS);

        SetButtonInfo(PEN_TBAR_PEN_POS,   IDC_PENEXT,     TBBS_CHECKBOX, PEN_BMP_POS);

// presently unused
//        SetButtonInfo(KEYBOARD_TBAR_POS,  IDC_KEYBOARD,   TBBS_BUTTON, KEYBOARD_BMP_POS);
        }
    else
        {
        // Set the style to be checkbox  style.
        SetButtonInfo(BOLD_TBAR_POS,      IDC_BOLD,       TBBS_CHECKBOX, BOLD_BMP_POS);
        SetButtonInfo(ITALIC_TBAR_POS,    IDC_ITALIC,     TBBS_CHECKBOX, ITALIC_BMP_POS);
        SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE,  TBBS_CHECKBOX, UNDERLINE_BMP_POS);

        SetButtonInfo(VERTEDIT_TBAR_POS,  IDC_VERTEDIT,   TBBS_CHECKBOX, VERTEDIT_BMP_POS);


        if (theApp.m_bPenSystem)
            SetButtonInfo(PEN_TBAR_TEXT_POS, IDC_PENEXT,  TBBS_CHECKBOX, PEN_BMP_POS);
        }

    CSize size = CToolBar::CalcFixedLayout( FALSE, TRUE );

    if (GetSafeHwnd() != NULL)
        {
        SetWindowPos( &wndTop, 0, 0, size.cx, size.cy, SWP_NOMOVE );
        }

    return bRC;
    }

/******************************************************************************/

CTfontTbar::~CTfontTbar(void)
    {
    }

/******************************************************************************/
/******************************************************************************/
// CTfontDlg

BEGIN_MESSAGE_MAP(CTfontDlg, CDialogBar)
    //{{AFX_MSG_MAP(CTfontDlg)
    ON_WM_RBUTTONDOWN()
    ON_WM_MEASUREITEM()
    ON_WM_DRAWITEM()
//  ON_DM_GETDEFID()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/******************************************************************************/
// CTfontDlg construction/destruction

CTfontDlg::CTfontDlg(void)
    {
      BOOL bRC;
      CSize cSizeBmp(0, 0);
      INT   i;

      m_Max_cx_FontType_BMP = 0;

      // Set up the Size Structures for offsets in drawing the font typeface.
      for (i = 0; i < NumCPic; i++)
      {
          bRC = m_cPictures[i].PictureSet(CTBitmaps[i]);
          ASSERT( bRC != 0 );

          if (bRC)
          {
              cSizeBmp = m_cPictures[i].PictureSize();
              if (cSizeBmp.cx > m_Max_cx_FontType_BMP)
              {
                  m_Max_cx_FontType_BMP = cSizeBmp.cx;
              }
          }
          else
          {
              /*DK* ##ERROR  could not create bitmap for tt font in owner draw lbox*/
          }
      }
    }

/******************************************************************************/

BOOL CTfontDlg::Create(CWnd* pcParentWnd)
    {
    BOOL bRC = CDialogBar::Create(pcParentWnd, IDD_TEXT_FONT_DLG,
                                               CBRS_NOALIGN, NULL);
    if (bRC)
        SetWindowPos(&wndTop, 0,0, m_sizeDefault.cx, m_sizeDefault.cy, SWP_NOMOVE);

    return bRC;
    }

/******************************************************************************/

CTfontDlg::~CTfontDlg(void)
    {
    }

/******************************************************************************/

void CTfontDlg::OnRButtonDown(UINT nFlags, CPoint point)
    {
    CWnd *pcParent = GetParent();

    const MSG *pCurrentMessage = GetCurrentMessage();

    pcParent->SendMessage(pCurrentMessage->message, pCurrentMessage->wParam,
                          pCurrentMessage->lParam);
    }

/******************************************************************************/
void CTfontDlg::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
    {
    TEXTMETRIC tm;
    BOOL bRC;

    // get default to fill in measureitem struct first
    CWnd::OnMeasureItem(nIDCtl, lpMeasureItemStruct);

    TRY
        {
        ASSERT( lpMeasureItemStruct->CtlType == ODT_COMBOBOX );
        ASSERT( lpMeasureItemStruct->CtlID   == IDC_TYPEFACE );

        if (lpMeasureItemStruct->CtlType != ODT_COMBOBOX
        ||  lpMeasureItemStruct->CtlID   != IDC_TYPEFACE)
            {
            AfxThrowNotSupportedException();
            }

        CClientDC cdcClient(this);

        bRC = cdcClient.GetTextMetrics(&tm);

        ASSERT(bRC !=0);

        if (bRC != 0)
            {
            lpMeasureItemStruct->itemHeight = tm.tmAscent + 2;
            }
        }
    CATCH(CNotSupportedException,e)
        {
        }
    END_CATCH
    }

/******************************************************************************/

void CTfontDlg::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct, CString *pcStringText)
{
   CBrush* cpBrush;
   BOOL   bSelected;
   BOOL   bRC;
   CDC    cdcCombo;
   BOOL   bDrawPicture = FALSE;
   CRect  cRectText;
   int    iPictureHeight = 0;
   CSize  cSizeBmp(0,0);
   int    ix = 0;
   int    iy = 0;

   CFontDesc* pDesc = (CFontDesc*)lpDrawItemStruct->itemData;
   CFontComboBox *pwndCombo = (CFontComboBox *)CFontComboBox::FromHandle(lpDrawItemStruct->hwndItem);
   if (pwndCombo)
   {
   // Only need to check the item before and after
      if (!pwndCombo->IsSameName(pDesc, lpDrawItemStruct->itemID - 1)
       && !pwndCombo->IsSameName(pDesc, lpDrawItemStruct->itemID + 1))
      {
         pcStringText = &pDesc->m_strName;
      }
   }

   // Set the picture object up to draw a picture if one is needed (if this
   // font is a printer/true type font).
   bDrawPicture = TRUE;

   switch (pDesc->m_iFontType)
   {
      case DEVICE_FONT:
         cSizeBmp       = m_cPictures[1].PictureSize();
         break;

      case TT_FONT:
         cSizeBmp       = m_cPictures[0].PictureSize();
         break;

      case TT_OPENTYPE_FONT:
         cSizeBmp       = m_cPictures[2].PictureSize();
         break;

      case PS_OPENTYPE_FONT:
         cSizeBmp       = m_cPictures[3].PictureSize();
         break;

      case TYPE1_FONT:
         cSizeBmp       = m_cPictures[4].PictureSize();
         break;

      default:
         bDrawPicture = FALSE;
         break;
   }

   if (bDrawPicture)
   {
      iPictureHeight = cSizeBmp.cy;
   }

   TRY
   {
      if ( (lpDrawItemStruct->itemState & ODS_SELECTED) ==  ODS_SELECTED)
      {
         bSelected = TRUE;
         cpBrush = GetSysBrush( COLOR_HIGHLIGHT );
      }
      else
      {
         bSelected = FALSE;
         cpBrush = GetSysBrush( COLOR_WINDOW );
      }

      if (! cpBrush)
      {
         /*DK* ##ERROR Could not create solid brush */
         AfxThrowNotSupportedException();
      }

      bRC = cdcCombo.Attach(lpDrawItemStruct->hDC);

      ASSERT(bRC != 0);

      if (bRC == 0)
      {
          AfxThrowNotSupportedException();
      }

      SetColorsInDC(lpDrawItemStruct->hDC, bSelected);

      cdcCombo.FillRect(&(lpDrawItemStruct->rcItem), cpBrush);

      // If this is a Printer or True Type font, draw the image/picture.
      if (bDrawPicture)
      {
          ix = lpDrawItemStruct->rcItem.left + 1;  // 0 is focus rect
          //center vertically
          iy = lpDrawItemStruct->rcItem.top +
              abs(((lpDrawItemStruct->rcItem.bottom -
          lpDrawItemStruct->rcItem.top) - iPictureHeight))/2;

          switch (pDesc->m_iFontType)
          {
             case DEVICE_FONT:
                m_cPictures[1].Picture(&cdcCombo, ix, iy);
                break;

             case TT_FONT:
                m_cPictures[0].Picture(&cdcCombo, ix, iy);
                break;

             case TT_OPENTYPE_FONT:
                m_cPictures[2].Picture(&cdcCombo, ix, iy);
                break;

             case PS_OPENTYPE_FONT:
                m_cPictures[3].Picture(&cdcCombo, ix, iy);
                break;

             case TYPE1_FONT:
                m_cPictures[4].Picture(&cdcCombo, ix, iy);
                break;

             default:
                break;
          }
      }

      // set the rectangle  for the text, and draw the text
      cRectText       =  lpDrawItemStruct->rcItem;
      cRectText.left += m_Max_cx_FontType_BMP + FONT_BMP_TXT_BORDER;

      cdcCombo.DrawText(*pcStringText, -1, &(cRectText), DT_LEFT | DT_SINGLELINE | DT_VCENTER);

      if ( (lpDrawItemStruct->itemState & ODS_FOCUS) ==  ODS_FOCUS)
      {
         cdcCombo.DrawFocusRect(&(lpDrawItemStruct->rcItem));
      }

   }
   CATCH(CNotSupportedException,e)
   {
   /*DK* ##ERROR Internal Thown Unsupported Exception */
   }
   END_CATCH

   cdcCombo.Detach();
}

/******************************************************************************/
// bInverted is the same as text selected.

void CTfontDlg::SetColorsInDC(HDC hdc, BOOL bInverted)
{
    DWORD dwFGColor;
    DWORD dwBKColor;

    if (bInverted)
        {
        dwFGColor = ::GetSysColor( COLOR_HIGHLIGHTTEXT );
        dwBKColor = ::GetSysColor( COLOR_HIGHLIGHT );
        }
    else
       {
       dwFGColor = ::GetSysColor( COLOR_WINDOWTEXT );
       dwBKColor = ::GetSysColor( COLOR_WINDOW );
       }

    ::SetTextColor( hdc, dwFGColor );

    ::SetBkMode ( hdc, OPAQUE );
    ::SetBkColor( hdc, dwBKColor );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\tfont.h ===
// Tfont.h : interface of the CTfont class
//           This class takes text entry from the user.
//           It is derived from the CEdit class
/***************************************************************************/

#ifndef __Tfont_H__
#define __Tfont_H__

// TOOLBAAR CONSTANTS -- Bitmap Positions and Toolbar Positions

#define MAX_TBAR_ITEMS        12 // positions 0 through 11

#define BOLD_BMP_POS          0
#define ITALIC_BMP_POS        1
#define UNDERLINE_BMP_POS     2


#define VERTEDIT_BMP_POS      3
#define PEN_BMP_POS           4
#define EDITTEXT_BMP_POS      5
#define KEYBOARD_BMP_POS      6   // still wasting space in image
#define INS_SPACE_BMP_POS     7
#define BACKSPACE_BMP_POS     8
#define NEWLINE_BMP_POS       9

#define SHADOW_BMP_POS        -1  // don't exist currently

#define BOLD_TBAR_POS         0
#define ITALIC_TBAR_POS       1
#define UNDERLINE_TBAR_POS    2


#define VERTEDIT_TBAR_POS     3
#define SPACE_ONE             4
#define PEN_TBAR_TEXT_POS     5

#define INS_SPACE_TBAR_POS    5
#define BACKSPACE_TBAR_POS    6
#define NEWLINE_TBAR_POS      7
#define SPACE_TWO             8
#define EDITTEXT_TBAR_POS     9
#define SPACE_THREE          10
#define PEN_TBAR_PEN_POS     11

#define SHADOW_TBAR_POS       -1  // don't exist currently
#define KEYBOARD_TBAR_POS     -1  // don't exist currently

#define FONT_BMP_TXT_BORDER   2   // # pixels between font bmp (prn/tt) and text

#define UM_DELAYED_TOOLBAR   WM_USER + 900

// definde font types used by m_iFontType in CTfont class
#define TT_FONT             0x0001
#define TT_OPENTYPE_FONT    0x0002
#define PS_OPENTYPE_FONT    0x0004
#define TYPE1_FONT          0x0008
#define DEVICE_FONT         0x0010
#define RASTER_FONT         0x0020

#define NumCPic         5

class CTedit;    // forward reference for change/undo notification
//class CAttrEdit; // forward reference for setfont,...notification

/******************************************************************************/

class CTfontTbar : public CToolBar
    {
    private:

    protected: // create from serialization only

    DECLARE_DYNCREATE(CTfontTbar)

    protected:

    //{{AFX_MSG(CTfontTbar)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
        //  afx_msg void OnInsertObject();  // OLE support
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    public:

    CTfontTbar(void);

    virtual ~CTfontTbar(void);
    BOOL    Create(CWnd* pcParentWnd, BOOL bShowPen = FALSE);
    };

/******************************************************************************/

class CTfontDlg : public CDialogBar
    {
    private:
    CPic          m_cPictures[NumCPic];
    int           m_Max_cx_FontType_BMP;
    void SetColorsInDC(HDC hdc, BOOL bInverted);
    protected: // create from serialization only

    DECLARE_DYNCREATE(CTfontDlg)

    protected:

    //{{AFX_MSG(CTfontDlg)
    afx_msg void OnRButtonDown ( UINT nFlags, CPoint point );
//
// MFC 4 - had to put the WM_DRAWITEM and WM_MEASUREITEM handlers here instead
// of CTfont. This dialog is the real parent of the owner-draw combobox, don't
// know how the old version worked with these handlers in CTfont.
//
    afx_msg void OnDrawItem    (int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
    afx_msg void OnMeasureItem (int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    afx_msg DWORD OnGetDefId   ( void );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    public:

    CTfontDlg(void);
    void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct, CString *pcStringText);
    virtual ~CTfontDlg(void);
    BOOL     Create(CWnd* pcParentWnd);
    };

/******************************************************************************/

class CCharSetDesc;
class CFontDesc;

/******************************************************************************/

class CTfont : public CMiniFrmWnd
    {
    private:

    int           m_iControlIDLastChange;
    int           m_iWeight;
    CFont         m_cCurrentFont;
    CString       m_cStrTypeFaceName;
    CString       m_cStrTypeFaceNamePrev;
    int           m_iPointSize;
    int           m_iPointSizePrev;

    CString       m_strFontName;
    int           m_iFontType;
    BYTE          m_nCharSet;
    BYTE          m_nCharSetPrev;

    BOOL          m_bBoldOn;
    BOOL          m_bItalicOn;
    BOOL          m_bUnderlineOn;

    BOOL          m_bVertEditOn;

    BOOL          m_bShadowOn;
    BOOL          m_bPenOn;

    CRect         m_cRectWindow;
    BOOL          m_bDisplayCText;
    BOOL          m_bInUpdate;

    class CTedit* m_pcTedit;
    CTfontDlg     m_cTfontDlg;
    CTfontTbar    *m_pcTfontTbar; // must be dynamic for changing buttons (delete/new)

    BYTE PickCharSet(CCharSetDesc *pCharSetDescList, int iCharSetSelection);

    void ResizeWindow(void);
    void ProcessNewTypeface(void);
    void UpdateEditControlFont(void);
    void FreeMemoryFromCBox(void);
    void OnTypeFaceComboBoxUpdate(void);
    void OnPointSizeComboBoxUpdate(void);

    void SaveToIniFile(void);
    void ReadFromIniFile(void);

    // was used for spin control to save point sizes,...
    //  CMapWordToPtr PointSizeMap;
    //  void EmptyMap(void);

    void RefreshFontList(void);

    int  EnumFontFace( ENUMLOGFONTEX*   lpEnumLogFont,
                       NEWTEXTMETRICEX* lpNewTextMetric,
                       int             iFontType );

    int  EnumFontSizes( LPENUMLOGFONT   lpEnumLogFont,
                        LPNEWTEXTMETRIC lpNewTextMetric,
                        int             iFontType );

    protected: // create from serialization only

    DECLARE_DYNCREATE(CTfont)

    //{{AFX_MSG(CTfont)
    afx_msg void OnTypefaceChange();
    afx_msg void OnPointSizeChange();
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnDestroy();
    afx_msg void OnMove(int x, int y);
    afx_msg void OnClose();
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    public:

    CTfont();
    CTfont( CTedit *pcTedit );
    ~CTfont(void);

    CWnd* GetFontSizeControl() { return ((m_cTfontDlg.GetSafeHwnd() == NULL)? NULL:
                                          m_cTfontDlg.GetDlgItem( IDC_POINTSIZE ) ); }

    CWnd* GetFontFaceControl() { return ((m_cTfontDlg.GetSafeHwnd() == NULL)? NULL:
                                          m_cTfontDlg.GetDlgItem( IDC_TYPEFACE ) ); }

    //MY AFX_MSG(CTfont)
    afx_msg void OnBold      ( void );
    afx_msg void OnItalic    ( void );
    afx_msg void OnUnderline ( void );

    afx_msg void OnVertEdit  ( void );
    afx_msg void OnVertEditUpdate  ( CCmdUI* pCmdUI );

    afx_msg void OnShadow    ( void );
    afx_msg void OnPen       ( void );
    afx_msg long OnDelayedPen( WPARAM wParam, LPARAM lParam );
    afx_msg void OnEditText  ( void );
    afx_msg void OnKeyboard  ( void );
    afx_msg void OnInsSpace  ( void );
    afx_msg void OnBackSpace ( void );
    afx_msg void OnNewLine   ( void );
    //MY AFX_MSG

    BOOL IsBoldOn      ( void ) { return m_bBoldOn;      }
    BOOL IsItalicOn    ( void ) { return m_bItalicOn;    }
    BOOL IsUnderlineOn ( void ) { return m_bUnderlineOn; }

    BOOL IsVertEditOn  ( void ) { return m_bVertEditOn;  }

    BOOL IsShadowOn    ( void ) { return m_bShadowOn;    }
    BOOL Create        ( CRect rectEditArea );
    void Undo          ( void );
    void RefreshToolBar( void );
    void GetFontInfo   ( int iFontSelection, BYTE nCharSetSelection);

    static int CALLBACK EnumFontFaceProc(ENUMLOGFONTEX* lpEnumLogFont,
                                         NEWTEXTMETRICEX* lpNewTextMetric,
                                          int iFontType, LPARAM lParam);
    static int CALLBACK EnumFontOneFaceProc(LPENUMLOGFONT lpEnumLogFont,
                                            LPNEWTEXTMETRIC lpNewTextMetric,
                                            int iFontType, LPARAM lParam);

    virtual WORD GetHelpOffset() {return 0;} // for now just return 0

    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

    virtual void RecalcLayout(BOOL bNotify = TRUE);

    };

/***************************************************************************/

#endif // __Tfont_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\tedit.h ===
// tedit.h : interface of the CTedit class
//
// This class takes text entry from the user.
// It is derived from the CEdit class
//

#ifndef __TEDIT_H__
#define __TEDIT_H__

// default position for text box
#define INITX 10
#define INITY 10
#define INITCX 100
#define INITCY 50

#define MIN_CHARS_DISPLAY_SIZE 5 // minimum size is 5 chars with the default font

#define WM_MOVING       0x0216

//#define EM_POSFROMCHAR  0x00D6
//#define EM_CHARFROMPOS  0x00D7


#define IS_DBCS_CHARSET( charset )         ( (charset == GB2312_CHARSET) || \
                                             (charset == SHIFTJIS_CHARSET) || \
                                             (charset == HANGEUL_CHARSET) || \
                                             (charset == CHINESEBIG5_CHARSET) )


class CTedit;
class CTfont;

typedef enum
    {
        eEBOX_CHANGE,
        eFONT_CHANGE,
        eSIZE_MOVE_CHANGE,
    eNO_CHANGE
    } eLASTACTION;


/******************************************************************************/

class CAttrEdit : public CEdit
    {
    public:

    BOOL    m_bBackgroundTransparent;

    UINT    m_uiLastChar[2];

    CRect   m_rectUpdate;

    CTedit* m_pParentWnd;

    CString m_strResult;


    HKL     m_hKL;
    BOOL    m_bMouseDown;
    HCURSOR m_hHCursor;
    HCURSOR m_hVCursor;
    HCURSOR m_hOldCursor;
    CRect   m_rectFmt;
    int     m_iPrevStart;
    int     m_iTabPos;
    BOOL    m_bResizeOnly; // when IME composition will
                           // force a resize
   
    CAttrEdit::CAttrEdit();

    DECLARE_DYNCREATE( CAttrEdit )

    protected: // create from serialization only

    //{{AFX_MSG(CAttrEdit)
    afx_msg void OnPaint();
    afx_msg BOOL OnEraseBkgnd ( CDC* pDC );
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnChar       (UINT nChar, UINT nRepCnt, UINT nFlags);

    afx_msg LRESULT OnImeChar          ( WPARAM wParam, LPARAM lParam );
    afx_msg LRESULT OnImeComposition   ( WPARAM wParam, LPARAM lParam );
    afx_msg LRESULT OnInputLangChange  ( WPARAM wParam, LPARAM lParam );
    afx_msg void OnKillFocus           ( CWnd* pNewWnd );
    afx_msg UINT OnNcHitTest           ( CPoint point );
    afx_msg void OnSetFocus            ( CWnd* pOldWnd );
    afx_msg void OnSize                ( UINT nType, int cx, int cy );
    afx_msg void OnLButtonDblClk       ( UINT nFlags, CPoint point );
    afx_msg void OnLButtonDown         ( UINT nFlags, CPoint point );
    afx_msg void OnMouseMove           ( UINT nFlags, CPoint point );
    afx_msg void OnLButtonUp           ( UINT nFlags, CPoint point );
    afx_msg void OnKeyDown             ( UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg LRESULT OnSysTimer         ( WPARAM wParam, LPARAM lParam );

        //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetHCursorShape  ( void );
    void SetVCursorShape  ( void );
    void UpdateSel        ( void );
    void UpdateInput      ( void );
    void SetStartSelect   ( void );
    void SetCaretPosition ( BOOL bPrev, CPoint *ptMouse, int iPrevStart );
    void SetCaretShape    ( void );
    void SetFmtRect       ( void );
    void Repaint          ( void );
    void TabTextOut       ( CDC *pDC, int nCharIndex, int x, int y,
                            LPCTSTR lpStr, int nCount, BOOL bSelect );

    friend class CTedit;
    };

/******************************************************************************/

class CTedit : public CWnd
    {
       friend class CTfont;
    private:

    CAttrEdit   m_cEdit;
    CTfont*     m_pcTfont;
    eLASTACTION m_eLastAction;
    BOOL        m_bBackgroundTransparent;
    BOOL        m_bCleanupBKBrush;
    BOOL        m_bStarting;
    BOOL        m_bPasting;
    BOOL        m_bExpand;
    BOOL        m_bChanged;
    UINT        m_uiHitArea;
    COLORREF    m_crFGColor;
    COLORREF    m_crBKColor;
    CRect       m_cRectOldPos;
    CRect       m_cRectWindow;
    CSize       m_SizeMinimum;


    public:

    CImgWnd*    m_pImgWnd;
    CBrush      m_hbrBkColor;
    BOOL        m_bRefresh;


    int         m_iLineHeight;
    BOOL        m_bVertEdit;
    BOOL        m_bAssocIMC;
    HIMC        m_hIMCEdit;
    HIMC        m_hIMCFace;
    HIMC        m_hIMCSize;
    HWND        m_hWndFace;
    HWND        m_hWndSize;


    CTedit::CTedit();
   
    DECLARE_DYNCREATE( CTedit )
    afx_msg void OnEnMaxText();
    protected:

    //{{AFX_MSG(CTedit)
    afx_msg void OnAttrEditEnChange(void);
    afx_msg void OnSize( UINT nType, int cx, int cy );
    afx_msg void OnMove( int x, int y );
    afx_msg void OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI );
    afx_msg HBRUSH OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor );
    afx_msg void OnNcCalcSize( BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp );
    afx_msg void OnNcPaint();
    afx_msg UINT OnNcHitTest( CPoint point );
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);

    afx_msg void OnTextPlain();
    afx_msg void OnTextBold();
    afx_msg void OnTextItalic();
    afx_msg void OnTextUnderline();
    afx_msg void OnTextSelectfont();
    afx_msg void OnTextSelectpointsize();
    afx_msg void OnEditCut();
    afx_msg void OnEditCopy();
    afx_msg void OnEditPaste();
    afx_msg void OnTextDelete();
    afx_msg void OnTextSelectall();
    afx_msg void OnTextUndo();
    afx_msg void OnTextPlace();
    afx_msg void OnTextTexttool();
    afx_msg void OnUpdateTextPlain(CMenu *pcMenu);
    afx_msg void OnUpdateTextBold(CMenu *pcMenu);
    afx_msg void OnUpdateTextItalic(CMenu *pcMenu);
    afx_msg void OnUpdateTextUnderline(CMenu *pcMenu);
    afx_msg void OnUpdateTextTexttool(CMenu *pcMenu);

    afx_msg void OnDestroy();

        //}}AFX_MSG

    afx_msg void OnEnUpdate();

    afx_msg LRESULT OnMoving( WPARAM, LPARAM lprc );

    DECLARE_MESSAGE_MAP()

    virtual void PostNcDestroy();

    CSize GetDefaultMinSize( void );

    public:

    virtual CTedit::~CTedit();

    virtual BOOL PreCreateWindow( CREATESTRUCT& cs );

    BOOL       Create( CImgWnd* pParentWnd,
                                       COLORREF crefForeground,
                       COLORREF crefBackground,
                       CRect& rectTextPos,
                       BOOL bBackTransparent = TRUE );

    void       OnAttrEditFontChange( void );
    void       RefreshWindow       ( CRect* prect = NULL, BOOL bErase = TRUE );
    void       SetTextColor        ( COLORREF crColor );
    void       SetBackColor        ( COLORREF crColor );
    void       SetTransparentMode  ( BOOL bTransparent );
    void       Undo                ();
    void       ShowFontPalette     ( int nCmdShow );
    BOOL       IsFontPaletteVisible( void );
    void       ShowFontToolbar     ( BOOL bActivate = FALSE );
    void       HideFontToolbar     ( void );
    BOOL       IsModified          ( void ) { return m_bChanged; }
    void       GetBitmap           ( CDC* pDC, CRect* prectImg );
    CAttrEdit* GetEditWindow       ( void ) { return &m_cEdit; }

    HIMC       DisableIme( HWND hWnd );
    void       EnableIme( HWND hWnd, HIMC hIMC );
    BOOL       IsCUAS();

    };

#endif // __TEDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\thumnail.h ===
#ifndef __THUMNAIL_H__
#define __THUMNAIL_H__

/******************************************************************************/

class CThumbNailView : public CWnd
    {
    DECLARE_DYNAMIC(CThumbNailView)

    protected:

    class CImgWnd *m_pcImgWnd;

    // Generated message map functions
    //{{AFX_MSG(CThumbNailView)
    afx_msg void OnPaint();
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
        afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
        afx_msg void OnThumbnailThumbnail();
    afx_msg void OnUpdateThumbnailThumbnail(CCmdUI* pCmdUI);
    afx_msg void OnClose();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DrawTracker(CDC *pDC);

    public:

    CThumbNailView();
    CThumbNailView(CImgWnd *pcImgWnd);
    ~CThumbNailView();
    BOOL Create(DWORD dwStyle, CRect cRectWindow, CWnd *pcParentWnd);
    void DrawImage(CDC* pDC);
    void RefreshImage(void);
    CImgWnd* GetImgWnd(void);
    void UpdateThumbNailView();
    };

/******************************************************************************/

class CFloatThumbNailView : public CMiniFrmWnd
    {
    DECLARE_DYNAMIC(CFloatThumbNailView)

    protected:

    CThumbNailView *m_pcThumbNailView;

    // Generated message map functions
    //{{AFX_MSG(CFloatThumbNailView)
    afx_msg void OnClose();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
        //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    public:

    CPoint GetPosition() { return m_ptPosition; }
    CSize  GetSize()     { return m_szSize; }

    CFloatThumbNailView();
    CFloatThumbNailView(CImgWnd *pcImgWnd);
    ~CFloatThumbNailView();
    CThumbNailView* GetThumbNailView() { return m_pcThumbNailView; }

    virtual BOOL Create(CWnd* pParentWnd);
    virtual void PostNcDestroy();
    virtual WORD GetHelpOffset() { return ID_WND_GRAPHIC; }

    private:

    CPoint  m_ptPosition;
    CSize   m_szSize;
    };

/******************************************************************************/

class CFullScreenThumbNailView : public CFrameWnd
    {
    DECLARE_DYNAMIC(CFullScreenThumbNailView)

    private:
    LONG_PTR m_hOldIcon;
    protected:

    BOOL   m_bSaveShowFlag;
//  CBrush m_brBackground;

    CThumbNailView *m_pcThumbNailView;

    // Generated message map functions
    //{{AFX_MSG(CFullScreenThumbNailView)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnClose ();

        //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    public:

    CFullScreenThumbNailView();
    CFullScreenThumbNailView(CImgWnd *pcImgWnd);
    ~CFullScreenThumbNailView();
    virtual BOOL Create(LPCTSTR szCaption);
    };


#endif // __THUMNAIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\toolbox.cpp ===
/******************************************************************************/
/*                                                                            */
/* Class Implementations in this file                                         */
/*      CFloatImgToolWnd                                                      */
/*      CImgToolWnd                                                           */
/*      CToolboxWnd                                                           */
/*      CTool                                                                 */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "ipframe.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "docking.h"
#include "t_Text.h"

#define TRYANYTHING

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CToolboxWnd, CControlBar)

#include "memtrace.h"

CImgToolWnd* NEAR g_pImgToolWnd = NULL;

#define BPR(br, rop)        \
 { dc.SelectObject((br));   \
   dc.PatBlt(rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, rop); }

#define iidmMac ( sizeof (rgidm) / sizeof (rgidm[0]) )

static UINT NEAR rgidm [] =
    {
    IDMB_PICKRGNTOOL,
    IDMB_PICKTOOL,

    IDMB_ERASERTOOL,
    IDMB_FILLTOOL,

    IDMY_PICKCOLOR,
    IDMB_ZOOMTOOL,

    IDMB_PENCILTOOL,
    IDMB_CBRUSHTOOL,

    IDMB_AIRBSHTOOL,
    IDMX_TEXTTOOL,

    IDMB_LINETOOL,
    IDMB_CURVETOOL,

    IDMB_RECTTOOL,
    IDMB_POLYGONTOOL,

    IDMB_ELLIPSETOOL,
    IDMB_RNDRECTTOOL
    };

/******************************************************************************/

BEGIN_MESSAGE_MAP(CImgToolWnd, CToolboxWnd)
        ON_WM_SYSCOLORCHANGE()
    ON_WM_ERASEBKGND()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_RBUTTONDOWN()
    ON_WM_PAINT()
    ON_WM_KEYDOWN()
    ON_WM_KEYUP()
    ON_WM_CHAR()
    ON_WM_NCHITTEST()
END_MESSAGE_MAP()


/******************************************************************************/

HTHEME SafeOpenThemeData(HWND hwnd, LPCWSTR pszClassList)
    {
    __try
        {
        return OpenThemeData(hwnd, pszClassList);
        }
    __except(EXCEPTION_EXECUTE_HANDLER)
        {
        return 0;
        }
    }

/******************************************************************************/

BOOL CImgToolWnd::Create(const TCHAR* pWindowName, DWORD dwStyle,
                         const RECT& rect, const POINT& btnSize, WORD wWide,
                         CWnd* pParentWnd, BOOL bDkRegister)
    {
    if (! CToolboxWnd::Create( pWindowName, dwStyle, rect,
                               btnSize, NUM_TOOLS_WIDE, pParentWnd, IDB_IMGTOOLS ))
        {
        return FALSE;
        }

    for (int iidm = 0; iidm < iidmMac; iidm += 1)
        {
        CTool* pTool = new CTool(this, (WORD)rgidm[iidm], iidm, TS_CMD | TS_STICKY,
                rgidm[iidm] == CImgTool::GetCurrentID() ? TF_DOWN : 0);

        if (pTool == NULL)
            {
            DestroyWindow();
            return FALSE;
            }
        AddTool(pTool);

        }


    m_nOffsetX = m_btnsize.x / 5;
    m_nOffsetY = m_btnsize.y / 5;

    CSize size = GetSize();

    MoveWindow( rect.left, rect.top, size.cx, size.cy );

    return TRUE;
    }


/******************************************************************************/
//

void CImgToolWnd::OnSysColorChange()
        {
        CToolboxWnd::OnSysColorChange();
        InvalidateRect(NULL, FALSE);
        }

/******************************************************************************/

int CImgToolWnd::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
    {
    CRect rect;

    CTool* pTool = ToolFromPoint( &rect, &point );

	if (pTool != NULL)
	    {
		int nHit = pTool->m_wID;

		if (pTI != NULL)
		    {
			pTI->hwnd     = m_hWnd;
            pTI->uId      = nHit;
            pTI->rect     = rect;
			pTI->lpszText = LPSTR_TEXTCALLBACK;
		    }

		return nHit;
	    }

	return -1;  // not found
    }

/******************************************************************************/

void CImgToolWnd::OnUpdateCmdUI( CFrameWnd* pTarget, BOOL bDisableIfNoHndler )
    {
    }

/******************************************************************************/

CSize CImgToolWnd::CalcFixedLayout( BOOL bStretch, BOOL bHorz )
    {
#ifdef TRYANYTHING
        return GetSize();
#else
    CSize size = CControlBar::CalcFixedLayout( bStretch, bHorz );

    CSize sizeBar = GetSize();

    size.cx = sizeBar.cx;
    return size;
#endif
    }

/******************************************************************************/

UINT CImgToolWnd::OnNcHitTest(CPoint point)
    {
    return CToolboxWnd::OnNcHitTest(point);
    }

/******************************************************************************/

CSize CImgToolWnd::GetSize()
    {
    // Leave room in the toolbox for the brushes...
    CRect clientRect;
    CRect windowRect;
    CSize sizeDiff;

    GetWindowRect( &windowRect );
    GetClientRect( &clientRect );

    sizeDiff = windowRect.Size() - clientRect.Size();
    int nTools = GetToolCount();

    clientRect.right  = m_btnsize.x * NUM_TOOLS_WIDE + m_nOffsetX * 2;
    clientRect.bottom = (nTools / NUM_TOOLS_WIDE + (!!(nTools % NUM_TOOLS_WIDE)))
                                          * m_btnsize.y + m_nOffsetY * 2;

    m_rcTools.left   = m_nOffsetX;
    m_rcTools.top    = m_nOffsetY;
    m_rcTools.right  = clientRect.right - m_nOffsetX;
    m_rcTools.bottom = clientRect.bottom - m_nOffsetY;

    m_rcBrushes.left   = clientRect.left   + (4 + m_nOffsetX);
    m_rcBrushes.top    = clientRect.bottom;
    m_rcBrushes.right  = clientRect.right  - (4 + m_nOffsetX);
    m_rcBrushes.bottom = clientRect.bottom + 66;

    clientRect.bottom += m_rcBrushes.Height() + m_nOffsetY;

    return clientRect.Size() + sizeDiff;
    }

/******************************************************************************/

void CImgToolWnd::OnLButtonDown(UINT nFlags, CPoint pt)
    {
    BOOL bInBrushes = m_rcBrushes.PtInRect(pt);

    if (bInBrushes)
        {
        CRect optionsRect = m_rcBrushes;

        optionsRect.InflateRect(-1, -1);
        pt -= (CSize)optionsRect.TopLeft();

        CImgTool::GetCurrent()->OnClickOptions(this, optionsRect, pt);
        }
    else
        CToolboxWnd::OnLButtonDown(nFlags, pt);
    }

/******************************************************************************/

void CImgToolWnd::InvalidateOptions(BOOL bErase)
    {
    // NOTE: bErase is now ignored since we do drawing off-screen and
    // blt the whole thing...

    CRect optionsRect = m_rcBrushes;
    optionsRect.InflateRect(-1, -1);

    InvalidateRect(&optionsRect, FALSE);
    }

/******************************************************************************/

void CImgToolWnd::OnLButtonDblClk(UINT nFlags, CPoint pt)
    {
    CToolboxWnd::OnLButtonDblClk(nFlags, pt);
    }

/******************************************************************************/

void CImgToolWnd::OnRButtonDown(UINT nFlags, CPoint pt)
    {
    CToolboxWnd::OnRButtonDown(nFlags, pt);
    }

/******************************************************************************/

BOOL CImgToolWnd::OnEraseBkgnd( CDC* pDC )
    {
    CRect rect;
    GetClientRect( rect );
    pDC->FillRect( rect, GetSysBrush( COLOR_BTNFACE ) );

        return CControlBar::OnEraseBkgnd( pDC );
    }

/******************************************************************************/

void CImgToolWnd::OnPaint()
    {
    CPaintDC dc(this);

    if (dc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency();
        return;
        }

    if (CImgWnd::c_pImgWndCur == NULL)
        {
        // Chances are, we're are going to be hidden soon, so don't
        // bother painting...
        return;
        }

    DrawButtons(dc, &dc.m_ps.rcPaint);

    ASSERT(CImgWnd::c_pImgWndCur->m_pImg != NULL);

    // Brush Shapes
    if (!(m_rcBrushes & dc.m_ps.rcPaint).IsRectEmpty())
        {
        Draw3dRect(dc.m_hDC, &m_rcBrushes );
        CRect optionsRect = m_rcBrushes;
        optionsRect.InflateRect(-1, -1);

        CRect rc(0, 0, optionsRect.Width(), optionsRect.Height());
        CDC memDC;
        CBitmap memBM;

        if (!memDC.CreateCompatibleDC(&dc) ||
            !memBM.CreateCompatibleBitmap(&dc, rc.right, rc.bottom))
            {
            theApp.SetGdiEmergency();
            return;
            }
        CBitmap* pOldBitmap = memDC.SelectObject(&memBM);

        CBrush* pOldBrush = memDC.SelectObject(GetSysBrush( COLOR_BTNFACE ));

        memDC.PatBlt(0, 0, rc.right, rc.bottom, PATCOPY);

        CRect rcPaint = dc.m_ps.rcPaint;
        rcPaint.OffsetRect(-optionsRect.left, -optionsRect.top);

        CImgTool::GetCurrent()->OnPaintOptions(&memDC, rcPaint, rc);

        dc.BitBlt(optionsRect.left, optionsRect.top, optionsRect.Width(),
                  optionsRect.Height(), &memDC, 0, 0, SRCCOPY);

        memDC.SelectObject(pOldBitmap);
        memDC.SelectObject(pOldBrush);
        }
    }

/******************************************************************************/

BOOL CImgToolWnd::PreTranslateMessage(MSG* pMsg)
    {
    switch (pMsg->message)
        {
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
            if (CImgWnd::c_pImgWndCur != NULL)
                {
                pMsg->hwnd = CImgWnd::c_pImgWndCur->m_hWnd;
                return CImgWnd::c_pImgWndCur->PreTranslateMessage(pMsg);
                }
            return FALSE;
        }

        return CToolboxWnd::PreTranslateMessage(pMsg);
    }

/******************************************************************************/
// default button size

const POINT NEAR CToolboxWnd::ptDefButton = { 26, 26 };

/*DK*/
BEGIN_MESSAGE_MAP(CToolboxWnd, CControlBar)
        ON_WM_SYSCOLORCHANGE()
    ON_WM_PAINT()
    ON_WM_LBUTTONDOWN()
    ON_WM_RBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_CLOSE()
    ON_WM_DESTROY()
    ON_WM_WININICHANGE()
    ON_WM_KEYDOWN()
    ON_MESSAGE(TM_TOOLDOWN, OnToolDown)
    ON_MESSAGE(TM_TOOLUP, OnToolUp)
    ON_MESSAGE(WM_THEMECHANGED, OnThemeChanged)
    /*DK*/
//  ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)
END_MESSAGE_MAP()

/******************************************************************************/

CToolboxWnd::CToolboxWnd()
    {
    m_Tools    = new CObArray;
    m_bmStuck  = NULL;
    m_bmPushed = NULL;
    m_bmPopped = NULL;
    m_tCapture = NULL;
    m_bInside  = FALSE;
    m_nOffsetX = 0;
    m_nOffsetY = 0;
    m_pLastHot = 0;
    m_hTheme   = 0;
    }

/******************************************************************************/

CToolboxWnd::~CToolboxWnd()
    {
    if (m_bmStuck != NULL)
        delete m_bmStuck;

    if (m_bmPushed != NULL)
        delete m_bmPushed;

    if (m_bmPopped != NULL)
        delete m_bmPopped;

    if (m_Tools != NULL)
        {
        int nTools = (int)m_Tools->GetSize();

        for (int iTool = 0; iTool < nTools; iTool += 1)
            {
            CTool* pTool = (CTool*)m_Tools->GetAt(iTool);
            delete pTool;
            }

        delete m_Tools;
        }
    }

/******************************************************************************/

BOOL CToolboxWnd::Create(const TCHAR FAR* lpWindowName,
                         DWORD dwStyle, const RECT& rect,
                         const POINT& btnsize /* = ptDefButton */, WORD wWide /* = 1 */,
                         CWnd* pParentWnd /* = NULL */, int nImageWellID /* = 0 */)
    {
    // This routine is a lot more complicated than the typical Create, so
    // because (1) we aren't a built-in Windows window type, and (2) we
    // want to specify the client size with the btnsize and wWide parameters.
    // (We ignore the width, height of the rect parameter.)

    if (nImageWellID != 0 && !m_imageWell.Load(nImageWellID, CSize(16, 16)))
        return FALSE;

        // save the style
        m_dwStyle = (UINT)dwStyle | CBRS_TOOLTIPS | CBRS_FLYBY;

    DWORD dwS = (m_dwStyle & ~WS_VISIBLE);

    CRect t = rect;

    t.right  = t.left + 20;
    t.bottom = t.top  + 20;

    BOOL bRet = CControlBar::Create( NULL, lpWindowName, dwS, t, pParentWnd,
                                                         ID_VIEW_TOOL_BOX );
    if (! bRet)
        return FALSE;

    m_wWide   = wWide;
    m_btnsize = btnsize;

#ifdef TRYANYTHING
        SizeByButtons( -1, TRUE );
#else
    SizeByButtons( 0 );
#endif

    m_hTheme = SafeOpenThemeData(GetSafeHwnd(), L"toolbar");

    if (! DrawStockBitmaps())
        {
        DestroyWindow();
        return FALSE;
        }

    if (dwStyle & WS_VISIBLE)
        {
        ShowWindow(SW_SHOW);
        UpdateWindow();
        }

    return TRUE;
    }

/******************************************************************************/
// private DrawStockBitmaps:
// Draws the three states of button, given the desired button size of this
// CToolboxWnd.  These have no graphic on them; the buttons have bitmap
// glyphs to be added to these blank forms.
//
// The three states:
//   m_bmPopped  This is the normal look of a button.  Note that this is
//               also used as the basis of a grayed (disabled) button, by
//               changing how the button's glyph is drawn on it.
//   m_bmPushed  This is the button-down state for non-sticky tools (tools
//               that pop back out as soon as you let go.
//   m_bmStuck   This is the button-down state for sticky tools.  This has
//               a distinct look that is more easily visible, per UISG.
//

BOOL CToolboxWnd::DrawStockBitmaps()
    {
    CWindowDC wdc(this);
    if (wdc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency(TRUE);
        return FALSE;
        }

    CBitmap* obm;
    CBrush* obr;
    CRect rc;
    CDC dc;

    if (!dc.CreateCompatibleDC(&wdc))
        {
        theApp.SetGdiEmergency(TRUE);
        return FALSE;
        }

    obr = dc.SelectObject(GetSysBrush(COLOR_WINDOWFRAME));

    // bmPopped:
    //
    if (m_bmPopped)
        delete m_bmPopped;
    m_bmPopped = new CBitmap;
    if (!m_bmPopped->CreateCompatibleBitmap(&wdc, m_btnsize.x, m_btnsize.y))
        {
        theApp.SetMemoryEmergency(TRUE);
        return FALSE;
        }
    obm = dc.SelectObject(m_bmPopped);
    rc = CRect(0, 0, m_btnsize.x, m_btnsize.y);
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
#ifdef OLDBUTTONS
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
#endif
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNHIGHLIGHT), PATCOPY);
    rc.left++; rc.top++;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);

    // bmPushed:
    //
    if (m_bmPushed)
        delete m_bmPushed;
    m_bmPushed = new CBitmap;
    if (!m_bmPushed->CreateCompatibleBitmap(&wdc, m_btnsize.x, m_btnsize.y))
        {
        theApp.SetMemoryEmergency(TRUE);
        return FALSE;
        }
    dc.SelectObject(m_bmPushed);
    rc = CRect(0, 0, m_btnsize.x, m_btnsize.y);
#ifndef OLDBUTTONS
    BPR(GetSysBrush(COLOR_BTNHIGHLIGHT), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
    rc.left++; rc.top++;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.left++; rc.top++;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);
#else
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.left += 2; rc.top += 2;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);
#endif

    // bmStuck:
    //
    if (m_bmStuck)
        delete m_bmStuck;
    m_bmStuck = new CBitmap;
    if (!m_bmStuck->CreateCompatibleBitmap(&wdc, m_btnsize.x, m_btnsize.y))
        {
        theApp.SetMemoryEmergency(TRUE);
        return FALSE;
        }
    dc.SelectObject(m_bmStuck);
    rc = CRect(0, 0, m_btnsize.x, m_btnsize.y);
#ifndef OLDBUTTONS
    BPR(GetSysBrush(COLOR_BTNHIGHLIGHT), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
    rc.left++; rc.top++;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.left++; rc.top++;
#else
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.left += 2; rc.top += 2;
#endif

    dc.SelectObject(GetHalftoneBrush());
#ifdef OLDBUTTONS
    dc.SetTextColor(RGB(255, 255, 255));
    dc.SetBkColor(RGB(192, 192, 192));
#else
        dc.SetTextColor(GetSysColor(COLOR_BTNFACE));
        dc.SetBkColor(GetSysColor(COLOR_BTNHIGHLIGHT));
#endif
    dc.PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATCOPY);

    dc.SelectObject(obm);
    dc.SelectObject(obr);
    dc.DeleteDC();

    return TRUE;
    }

/******************************************************************************/
//

afx_msg void CToolboxWnd::OnSysColorChange()
        {
        CControlBar::OnSysColorChange();
        DrawStockBitmaps();
        InvalidateRect(NULL, FALSE);
        }

/******************************************************************************/
//
// SizeByButtons
//
// Sizes the window according to the current (or a specified) number of
// buttons.  If there are no buttons, the window makes room for one button.
// Unfilled button slots show through to the background.
//

void CToolboxWnd::SizeByButtons(int nButtons /* = -1 */,
                                BOOL bRepaint /* = FALSE */)
    {
    if (nButtons == -1)
        nButtons = (int)m_Tools->GetSize();
    if (nButtons == 0)
        nButtons = 1;

    // Can't use the hokey Windows' AdjustWindowRect() to work this out,
    // so we do it ourselves by adapting the window based on the difference
    // between GetWindowRect and ClientRect results.
    //
    CRect w, c;
    GetWindowRect(&w);
    w.right -= w.left;
    w.bottom -= w.top;
    GetClientRect(&c);

    if (bRepaint)
        Invalidate(TRUE);

    MoveWindow(w.left, w.top,
                m_btnsize.x * m_wWide + (w.right - c.right) - 1,
                m_btnsize.y * ((nButtons / m_wWide) + (!!(nButtons % m_wWide)))
                        + (w.bottom-c.bottom) - 1,
                bRepaint);
    }

/******************************************************************************/
// OnWinIniChange:
//
void CToolboxWnd::OnWinIniChange(LPCTSTR lpSection)

    {
        lpSection;
#ifdef TRYANYTHING
        CControlBar::OnWinIniChange( lpSection );
#endif
    DrawStockBitmaps();
    Invalidate(TRUE);
    }

/******************************************************************************/
//
// OnKeyDown
//
// Implements keyboard handling for the toolbox window.. this allows
// trapping of the ESC key, for moving the selected to back to the
// arrow.
//
void CToolboxWnd::OnKeyDown(UINT nKey, UINT nRepCnt, UINT nFlags)
    {
    if (nKey == VK_ESCAPE && m_tCapture)
        CancelDrag();
    else
        CControlBar::OnKeyDown(nKey, nRepCnt, nFlags);
    }

/******************************************************************************/

void CToolboxWnd::CancelDrag()
    {
#if 0
    // this is bogus as dragging is presently disabled
    if (m_tCapture != NULL)
        m_tCapture->m_wState |= TF_DRAG; // so select will cancel it
#endif

    m_bInside = FALSE;

#if 0
    // whoever tries to make drag/drop work will have to handle the fact
    // that our client does not get notified by SelectTool
    SelectTool( IDMB_ARROW );
#endif

    m_tCapture = NULL;
    ReleaseCapture();
    }

/******************************************************************************/
// AddTool:
//
void CToolboxWnd::AddTool(CTool* tool)
    {
    m_Tools->Add((CObject*)tool);

    if ((m_Tools->GetSize() + m_wWide - 1) / m_wWide > 11)  // only have 11 high if more increase the width
        m_wWide += 1;

    SizeByButtons(-1, TRUE);

    }


/******************************************************************************/
// RemoveTool:
//
void CToolboxWnd::RemoveTool(CTool* tool)
    {
    for (int nTool = GetToolCount() - 1; GetToolAt(nTool) != tool; nTool -= 1)
        ASSERT(nTool >= 0);

    m_Tools->RemoveAt(nTool);

    if ((m_Tools->GetSize() + m_wWide - 2) / (m_wWide - 1) <= 11 && m_wWide > 1)
        m_wWide -= 1;

    SizeByButtons(-1, TRUE);
    }


/******************************************************************************/
// private GetTool:
//
CTool* CToolboxWnd::GetTool(WORD wID)
    {
    int nTools = (int)m_Tools->GetSize();
    for (int i = 0; i < nTools; i++)
        {
        CTool* t = (CTool*)m_Tools->GetAt(i);
        if (t && t->m_wID == wID)
            return t;
        }

    return NULL;
    }

/******************************************************************************/
//
// SetToolState
//
// Used by the owner of a button to modify the state of the button.
// This does not notify the owner of the new state; presumably the
// owner knows what it's doing to its own buttons.  This allows the
// owner to use this API during a WM_TOOLDOWN, etc., without getting
// into a shouting match with the toolbox.
//
WORD CToolboxWnd::SetToolState(WORD wID, WORD wState)
    {
    CRect rect;
    CTool* t = GetTool(wID);
    if (t && !(t->m_wState & TF_NYI))
        {
        WORD w = t->m_wState;
        t->m_wState = wState;

        //
        // if state hasn't changed, return to avoid invalidate and
        // associated flicker.
        //

        if (w == wState)
            return w;

        //
        // Calculate the rectangle of the button whose state is changing,
        // and invalidate it.
        //
        // replaces ed's simplistic (and flickering) code:
        //
        //      Invalidate(FALSE)
        //

        for (int i = 0; (CTool*)m_Tools->GetAt(i) != t; i += 1)
            {
            ASSERT(i != m_Tools->GetSize());
            }

        rect.left   = (i % m_wWide) * m_btnsize.x + m_nOffsetX;
        rect.top    = (i / m_wWide) * m_btnsize.y + m_nOffsetY;
        rect.right  = rect.left + m_btnsize.x;
        rect.bottom = rect.top  + m_btnsize.y;

        InvalidateRect(&rect, TRUE);
        return w;
        }

    return 0;
    }

/******************************************************************************/
// SetToolStyle:
// Used by the owner of a button to modify the style of the button.
// This forces the state of the button to be enabled and released.
// This does not notify the owner of the new state; presumably the
// owner knows what it's doing to its own buttons.  This allows the
// owner to use this API during a WM_TOOLDOWN, etc., without getting
// into a shouting match with the toolbox.
//
WORD CToolboxWnd::SetToolStyle(WORD wID, WORD wStyle)
    {
    CTool* t = GetTool(wID);
    if (t)
        {
        WORD w = t->m_wStyle;
        t->m_wStyle = wStyle;
        t->m_wState = 0;
        Invalidate(FALSE);
        return w;
        }

    return 0;
    }


/******************************************************************************/
//
// SelectTool
//
// Selects a given tool and deselects all the other tools.      So, for instance,
// to select the arrow, call pToolbox->SelectTool(IDMB_ARROW);
//
void CToolboxWnd::SelectTool(WORD wID)
    {
    //
    // first clear all the tools except the one we want pressed, then
    // select the one we want.
    //
    for (int i = 0; i < m_Tools->GetSize(); i += 1)
        {
        CTool* pTool = (CTool*)m_Tools->GetAt(i);

        if (pTool->m_wID != wID)
            SetToolState(pTool->m_wID, 0);
        }

    SetToolState( wID, TF_SELECTED );
    }

/******************************************************************************/
/* CToolboxWnd::CurrentTool
 *
 * Returns the ID of the currently selected tool.
 */
WORD CToolboxWnd::CurrentToolID()
    {
    int nTools = (int)m_Tools->GetSize();
    for (int i = 0; i < nTools; i++)
        {
        CTool* t = (CTool*)m_Tools->GetAt(i);
        if (t && t->m_wState == TF_SELECTED)
            return t->m_wID;
        }
    return IDMB_ARROW;
    }

/******************************************************************************/

#define HITTYPE_SUCCESS         0               // hit an item in the control bar
#define HITTYPE_NOTHING         (-1)    // hit nothing, but hit the control bar itself
#define HITTYPE_OUTSIDE         (-2)    // hit a window outside of the control bar
#define HITTYPE_TRACKING        (-3)    // this app is has the focus (is tracking)
#define HITTYPE_INACTIVE        (-4)    // the app is not active
#define HITTYPE_DISABLED        (-5)    // the control bar is disabled
#define HITTYPE_FOCUS           (-6)    // the control bar has focus

int CToolboxWnd::HitTestToolTip( CPoint point, UINT* pHit )
    {
    if (pHit)
        *pHit = (UINT)-1;    // assume it won't hit anything

    int iReturn = HITTYPE_INACTIVE;

    // make sure this app is active
    if (theApp.m_bActiveApp)
        {
        // check for this application tracking (capture set)
        if (! m_tCapture)
            {
            // finally do the hit test on the items within the control bar
            ScreenToClient( &point );

            CRect  rect;
            CTool* pTool = ToolFromPoint( &rect, &point );

            if (pTool && rect.PtInRect( point ))
                {
                iReturn = HITTYPE_SUCCESS;

                if (pHit)
                    *pHit = pTool->m_wID;
                }
            else
                iReturn = HITTYPE_OUTSIDE;
            }
        else
            iReturn = HITTYPE_TRACKING;
                }

    #ifdef _DEBUG
    TRACE2( "HitTestToolType %d - %u\n", iReturn, pHit );
    #endif

    return iReturn;
    }

/******************************************************************************/

UINT CToolboxWnd::OnCmdHitTest( CPoint point, CPoint* pCenter )
    {
    ASSERT_VALID( this );

    // now hit test against CToolBar buttons
    CRect  rect;
    UINT   nHit  = (UINT)-1;
    CTool* pTool = ToolFromPoint( &rect, &point );

    if (pTool)
        nHit = pTool->m_wID;

    return nHit;
    }

/******************************************************************************/
// private ToolFromPoint:
// Given a CPoint in client coordinates, this function returns the tool
// associated with the button at that point, if any.  If a tool is found,
// the given CRect (if not NULL) is filled with the bounds of the tool's
// button.
//
CTool* CToolboxWnd::ToolFromPoint(CRect* rect, CPoint* pt) const
    {
    CRect  c = m_rcTools;
    CPoint p = *pt;

    if (p.x < c.left || p.x >= c.right
    ||  p.y < c.top  || p.y >= c.bottom)
        return NULL;

    int x = (p.x - m_nOffsetX) / m_btnsize.x;
    int y = (p.y - m_nOffsetY) / m_btnsize.y;
    int i = x + (y * m_wWide);

    if (i >= m_Tools->GetSize())
        return NULL;

    CTool* t = (CTool*)(m_Tools->GetAt( i ));

    if (t && rect)
        {
        rect->left   = m_btnsize.x * x + m_nOffsetX;
        rect->top    = m_btnsize.y * y + m_nOffsetY;
        rect->right  = rect->left + m_btnsize.x;
        rect->bottom = rect->top  + m_btnsize.y;
        }

    return t;
    }

/******************************************************************************/
// OnLButtonDown:

void CToolboxWnd::OnLButtonDown(UINT wFlags, CPoint point)
    {
        wFlags; // Avoid unused arg warnings
    m_tCapture = ToolFromPoint( &m_lasttool, &point );
    m_downpt   = point;

    if (m_tCapture)
        {
        CRect   rect = m_lasttool;
        CString strPrompt;

        m_bInside = FALSE;

        rect.InflateRect( -1, -1 );

        if (rect.PtInRect( point ))
            {
            if (m_tCapture->m_wID <= IDMB_USERBTN)
                GetOwner()->SendMessage( WM_SETMESSAGESTRING, (WPARAM)m_tCapture->m_wID );

            if (m_tCapture->m_wState & TF_DISABLED)
                m_tCapture = NULL;
            else
                m_bInside = TRUE;
            }
        else
            m_tCapture = NULL;
        }
    else
        {
                CControlBar::OnLButtonDown(wFlags,point);
        }

    if (m_tCapture )
        {
        SetCapture();

        if (m_tCapture)
            InvalidateRect( &m_lasttool, TRUE );
        }
    }

/******************************************************************************/

void CToolboxWnd::OnRButtonDown(UINT wFlags, CPoint point)
    {
        wFlags;
        point;
    if (GetCapture() == this)
        CancelDrag();
    }

/******************************************************************************/
/*DK*/
//  LRESULT CToolboxWnd::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
//      {
//      CPoint pt(lParam);
//      CTool* t = ToolFromPoint(&m_lasttool, &pt);
//
//      if (t == NULL)
//          return CMiniFrmWnd::OnHelpHitTest(wParam, lParam);
//      else
//          {
//          ASSERT( t->m_wID );
//          return HID_BASE_BUTTON + t->m_wID;
//          }
//      }


// OnLButtonDblClk:  FUTURE: Maybe just not use CS_DBLCLKS?
//
void CToolboxWnd::OnLButtonDblClk(UINT wFlags, CPoint point)
    {
    OnLButtonDown(wFlags, point);
    }

/******************************************************************************/

BOOL CToolboxWnd::SetStatusText(int nHit)
    {
    if (nHit == -1 && m_pLastHot != 0)
        {
        m_pLastHot->m_wState &= ~TF_HOT;
        InvalidateRect(&m_rectLastHot, TRUE);
        m_pLastHot = 0;
        }

    return CControlBar::SetStatusText(nHit);
    }

/******************************************************************************/
// OnMouseMove:
//
void CToolboxWnd::OnMouseMove(UINT wFlags, CPoint point)
    {
    CTool* t = m_tCapture;

    if (! t || (t->m_wState & TF_DISABLED))
        {
        if (m_hTheme) 
            {
            CRect rectHot;

            CTool* pHot = ToolFromPoint(&rectHot, &point);

            if (m_pLastHot != pHot)
                {
                if (m_pLastHot)
                    {
                    m_pLastHot->m_wState &= ~TF_HOT;
                    InvalidateRect(&m_rectLastHot, TRUE);
                    }

                if (pHot)
                    {
                    pHot->m_wState |= TF_HOT;
                    InvalidateRect(&rectHot, TRUE);
                    }

                m_rectLastHot = rectHot;
                m_pLastHot = pHot;
                }
            }

        CControlBar::OnMouseMove( wFlags, point );
        return;
        }

    BOOL bWasInside = m_bInside;
    CRect rect = m_lasttool;

    rect.InflateRect( -1, -1 );

    m_bInside = ((! (t->m_wState & TF_DRAG)) && rect.PtInRect( point ));

    if (bWasInside != m_bInside)
        InvalidateRect( &m_lasttool, TRUE );

    if (t && !(t->m_wState & TF_DISABLED))
        {
        // if it's a mousemove and we're draggable, then see how far it
        // is from the original mousedown -- if it's a fair distance,
        // then drag it.
        if ((t->m_wStyle & TS_DRAG) &&
                    (((point.x - m_downpt.x) > 3) ||
                     ((point.y - m_downpt.y) > 3) ||
                     ((m_downpt.x - point.x) > 3) ||
                     ((m_downpt.y - point.y) > 3)))
            {
            t->m_wState |= TF_DRAG;

            if (t->m_wStyle & TS_STICKY)
                {
                if (!(t->m_wState & TF_SELECTED))
                    {
                    t->m_wState |= TF_SELECTED;

                    if (t->m_pOwner)
                        t->m_pOwner->SendMessage(TM_TOOLDOWN, t->m_wID);
                    }

                if (m_bInside)
                    InvalidateRect(&m_lasttool, TRUE);

                m_bInside = FALSE; // looks stuck immediately!
                }
            }
        if (t->m_pOwner && (t->m_wState & TF_DRAG))
            {
            CPoint spt = point;
            ClientToScreen(&spt);

            // if the drag and drop began ok, release the captured tool
//          if (t->m_pOwner->BeginDragDrop( t, spt ))
//              m_tCapture = NULL;
            }
        }
    }


/******************************************************************************/
// OnLButtonUp:

void CToolboxWnd::OnLButtonUp(UINT wFlags, CPoint point)
    {
    if (! m_tCapture )
        {
        CControlBar::OnLButtonUp( wFlags, point );
        return;
        }

    CTool* t = m_tCapture;

    if (t && ! (t->m_wState & TF_DISABLED))
        {
        m_bInside = (point.x >= m_lasttool.left
                  && point.x <  m_lasttool.right
                  && point.y >= m_lasttool.top
                  && point.y <  m_lasttool.bottom);

        if (m_bInside)
            {
            if (t->m_wStyle & TS_STICKY)
                {
                if (! (t->m_wState & TF_DRAG))
                    {
                    t->m_wState ^= TF_SELECTED;

                    InvalidateRect(&m_lasttool, TRUE);

                    if (t->m_pOwner)
                        t->m_pOwner->SendMessage( t->m_wState & TF_SELECTED?
                                         TM_TOOLDOWN : TM_TOOLUP, t->m_wID );
                    }
                }

            if (t->m_wStyle & TS_CMD)
                {
                if (t->m_pOwner)
                    AfxGetMainWnd()->SendMessage( WM_COMMAND, t->m_wID );
                }
            }
        }
    ReleaseCapture();
    m_tCapture = NULL;
    m_bInside  = FALSE;
    }

/******************************************************************************/

BOOL CToolboxWnd::OnCommand(UINT wParam, LONG lParam)
    {
    AfxGetMainWnd()->SendMessage(WM_COMMAND, wParam, lParam);
    return TRUE;
    }

/******************************************************************************/

void CToolboxWnd::DrawButtons(CDC& dc, RECT* rcPaint)
    {
    CRect rect;
    CRect updateRect;
    int i, n;

    if (rcPaint == NULL)
        {
        GetClientRect( &updateRect );
        rcPaint = &updateRect;
        }

    CDC memdc;
    memdc.CreateCompatibleDC(&dc);

    if (m_hTheme == 0)
        {
        // Force the buttons to be rebuilt here
        DrawStockBitmaps();
        }

    CBitmap* obm = memdc.SelectObject( m_bmPopped );
    CBrush*  obr = memdc.SelectObject( GetSysBrush( COLOR_BTNTEXT ) );

    n = (int)m_Tools->GetSize();

    BOOL bUsedImageWell = FALSE;

    for (i = 0; i < n; i++)
        {
        CTool* t = (CTool*)m_Tools->GetAt(i);

        if (! t)
            continue;

        rect.left   = (i % m_wWide) * m_btnsize.x + m_nOffsetX;
        rect.top    = (i / m_wWide) * m_btnsize.y + m_nOffsetY;

        rect.right  = rect.left + m_btnsize.x;
        rect.bottom = rect.top  + m_btnsize.y;

        CRect ir;

        if (! ir.IntersectRect( rcPaint, &rect ))
            continue;

        // Select the right stock bitmap, and remember to
        // shove the graphic if it's in a pushed state.
        //
        CBitmap* bmStock = m_bmPopped;
        int xshove = 0, yshove = 0;
        int iButtonStateId = TS_NORMAL;

        if (t->m_wState & (TF_SELECTED | TF_DRAG))
            {
            bmStock = m_bmStuck;
            xshove = 1; yshove = 1;
            iButtonStateId = t->m_wState & TF_HOT ? TS_HOTCHECKED : TS_CHECKED;
            }
        else if (t->m_wState & TF_HOT)
            {
            iButtonStateId = TS_HOT;
            }

        if ((t == m_tCapture && m_bInside) && !(t->m_wState & TF_DRAG))
            {
            bmStock = m_bmPushed;
            xshove = 2; yshove = 2;
            iButtonStateId = TS_PRESSED;
            }

        // Draw a blank button first...

        if (m_hTheme)     
            { 
            DrawThemeBackground(m_hTheme, dc, TP_BUTTON, iButtonStateId, &rect, 0);
            }
            else
            {
            ::DrawBitmap(&dc, bmStock, &rect, SRCCOPY, &memdc);
            }
         
        // Now draw the glyph on top...
        rect.OffsetRect( xshove, yshove );

        if (! bUsedImageWell)
            {
            if (! m_imageWell.Open())
                goto LReturn;

            bUsedImageWell = TRUE;

            if (! m_imageWell.CalculateMask())
                goto LReturn;
            }

        CPoint pt( rect.left + (rect.Width()  - 16) / 2,
                   rect.top  + (rect.Height() - 16) / 2 );

        m_imageWell.DrawImage( &dc, pt, t->m_nImage );
        }

LReturn:
    if (bUsedImageWell)
        m_imageWell.Close();

    memdc.SelectObject(obr);
    memdc.SelectObject(obm);
    memdc.DeleteDC();
    }

/******************************************************************************/
// OnPaint:
//

void CToolboxWnd::OnPaint()
    {
    CPaintDC dc(this);
    if (dc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency();
        return;
        }
    DrawButtons(dc, &dc.m_ps.rcPaint);
    }

/******************************************************************************/
// OnClose
//
// A toolbox is usally created by the parent, and will be destroyed
// specifically by the parent upon leaving the app.  When the user closes
// the toolbox, it is simply hidden.  The parent can then reshow it without
// recreating it.
//
// This also changes the menu test to "show" rather than "hide"

void CToolboxWnd::OnClose()
    {
#ifdef TRYANYTHING
        CControlBar::OnClose();
#endif
//      ShowWindow(SW_HIDE);
    }

/******************************************************************************/
// OnDestroy
//
void CToolboxWnd::OnDestroy()
    {
    if (m_hTheme)
        {
        CloseThemeData(m_hTheme);
        m_hTheme = 0;
        }
    CControlBar::OnDestroy();
    }

/******************************************************************************/
// OnThemeChanged
//
LRESULT CToolboxWnd::OnThemeChanged(WPARAM, LPARAM)
    {
    if (m_hTheme)
        {
        CloseThemeData(m_hTheme);
        }
    m_hTheme = SafeOpenThemeData(GetSafeHwnd(), L"toolbar");
    InvalidateRect(0, TRUE);
    return TRUE;
    }

/******************************************************************************/
// OnToolDown:
//
LONG CToolboxWnd::OnToolDown(UINT wID, LONG /* lParam */)
    {
    for (int i = 0; i < m_Tools->GetSize(); i += 1)
        {
        CTool* pTool = (CTool*)m_Tools->GetAt(i);

        if (pTool->m_wID != wID)
            SetToolState(pTool->m_wID, 0);
        }

    return (LONG)TRUE;
    }

/******************************************************************************/
// OnToolUp:
//
LONG CToolboxWnd::OnToolUp(UINT /* wID */, LONG /* lParam */)
    {
    for (int i = 0; i < m_Tools->GetSize(); i += 1)
        {
        CTool* pTool = (CTool*)m_Tools->GetAt(i);
        SetToolState(pTool->m_wID, 0);
        }
    SetToolState(IDMB_ARROW, TF_SELECTED);

    return (LONG)TRUE;
    }
#ifdef XYZZYZ
/******************************************************************************/
// OnSwitch:
//
LONG CToolboxWnd::OnSwitch(UINT /* wID */, LONG /* point */)
    {
    return (LONG)TRUE;
    }

/******************************************************************************/
// OnQueryDrop:
//
BOOL CToolboxWnd::BeginDragDrop (CTool* /*pTool*/, CPoint /*pt*/)
    {
    return FALSE;
    }
#endif
/******************************************************************************/

CTool::CTool(CToolboxWnd* pOwner, WORD wID, int nImage,
        WORD wStyle /* = 0 */, WORD wState /* = 0 */)
    {
    m_pOwner = pOwner;
    m_wID    = wID;
    m_nImage = nImage;
    m_wStyle = wStyle;
    m_wState = wState;
    }

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\toolbox.h ===
// toolbox.h : Declares the class interfaces for the toolbox window class.

#ifndef __TOOLBOX_H__
#define __TOOLBOX_H__

#define TM_TOOLDOWN     (WM_USER+0x0010)
#define TM_TOOLUP       (WM_USER+0x0011)
#define TM_TOOLDBLCLK   (WM_USER+0x0012)
#define TM_QUERYDROP    (WM_USER+0x0013)
#define TM_DROP         (WM_USER+0x0014)
#define TM_ABORTDROP    (WM_USER+0x0015)

#define TF_DISABLED     0x8000
#define TF_GRAYED       TF_DISABLED
#define TF_SELECTED     0x4000
#define TF_DOWN         TF_SELECTED
#define TF_DRAG         0x2000
#define TF_HOT          0x0800
#define TF_NYI          0x9000     // this represents a NYI tool (note that
                                   // TF_NYI implies TF_DISABLED)

#define TS_DEFAULT      0xC000
#define TS_STICKY       0x4000
#define TS_DRAG         0x2000
#define TS_CMD          0x1000
#define TS_VB           0x0800
#define TS_WELL         0x0400

#define NUM_TOOLS_WIDE  2

class CToolboxWnd;

#ifdef CUSTOMFLOAT
class CImageWell;
#else //!CUSTOMFLOAT
#include "imgwell.h"
#include "imgcolor.h"
#endif

/////////////////////////////////////////////////////////////////////////////

// CTool:
// A CTool is a thin-window button which can be inserted in a CToolboxWnd.
// Note that the tool is "owned" by a separate window, which is notified
// directly when the tool is used (pushed, dragged, unpushed, etc.).  The
// CToolboxWnd sends TM_* messages to the owning window.
//
// The graphics are completely calculated from the single bitmap given to
// the tool upon creation.  The pushed, disabled and unpushed states are
// drawn from the bitmap, which should be a two-color image without any
// chiseling button effects in it.  The graphic is centered in the button.
//
// For buttons defined with the TS_DRAG style, a cursor ID may be specified
// for the can't-drop state.  If not specified, the generic slashed-O
// cursor is used.
//
/******************************************************************************/

class CTool : public CObject
    {
    public: /*****************************************************************/
    CToolboxWnd* m_pOwner;
    WORD         m_wID;
    int          m_nImage; // index into parent's image well

    WORD         m_wState;
    WORD         m_wStyle;

    CTool(CToolboxWnd* pOwner, WORD wID, int nImage,
                      WORD wStyle = 0, WORD wState = 0);
    };

/******************************************************************************/
// CToolboxWnd:
// This is a typical mini-frame window, filled with an array of special
// buttons of the CTool class (above).  Direct access to this CObArray is
// allowed with the GetTools member function.
//
// After directly manipulating the tool array (adding, removing or modifying
// tools), use the Invalidate member function to repaint the window with the
// new state.
//
/******************************************************************************/

#ifdef CUSTOMFLOAT
class CDocking;
#endif

class CToolboxWnd : public CControlBar
    {
    DECLARE_DYNAMIC(CToolboxWnd)

    private:    /**************************************************************/

    CBitmap*    m_bmStuck;
    CBitmap*    m_bmPushed;
    CBitmap*    m_bmPopped;
    CTool*      m_tCapture;
    BOOL        m_bInside;
    CRect       m_lasttool;
    HCURSOR     m_oldcursor;
    CTool*      m_pLastHot;
    CRect       m_rectLastHot;
    HTHEME      m_hTheme;

    CObArray*   m_Tools;
    CPoint      m_downpt;            // "click down point" for drag debounce -gh

#ifdef CUSTOMFLOAT
    CDocking*   m_pDocking;
#endif

    protected:  /**************************************************************/

    CTool* ToolFromPoint(CRect* rect, CPoint* pt) const;
    void   SizeByButtons(int nButtons = -1, BOOL bRepaint = FALSE);
    BOOL   DrawStockBitmaps();

    WORD        m_wWide;
    CPoint     m_btnsize;
    CImageWell m_imageWell;
    CRect      m_rcTools;
    int        m_nOffsetX;
    int        m_nOffsetY;

    public:     /**************************************************************/

    static const POINT NEAR ptDefButton;

    CToolboxWnd();
    ~CToolboxWnd();

    virtual BOOL Create(const TCHAR FAR* lpWindowName,
                        DWORD dwStyle, const RECT& rect,
                        const POINT& btnsize = ptDefButton, WORD wWide = 1,
                        CWnd* pParentWnd = NULL, int nImageWellID = 0);
    virtual BOOL OnCommand(UINT wParam, LONG lParam);
    virtual UINT OnCmdHitTest ( CPoint point, CPoint* pCenter );
    virtual BOOL SetStatusText(int nHit);

    int  HitTestToolTip( CPoint point, UINT* pHit );

    void AddTool(CTool* tool);
    void RemoveTool(CTool* tool);
    WORD SetToolState(WORD wID, WORD wState);
    WORD SetToolStyle(WORD wID, WORD wStyle);
    void SelectTool(WORD wid);
    WORD CurrentToolID();
    CTool* GetTool(WORD wID);
    void DrawButtons(CDC& dc, RECT* rcPaint);

    inline int GetToolCount() { return (int)m_Tools->GetSize(); }
    inline CTool* GetToolAt(int nTool) { return (CTool*)m_Tools->GetAt(nTool); }

    void CancelDrag();

    afx_msg void OnSysColorChange();
    afx_msg void OnPaint();
    afx_msg void OnLButtonDown(UINT wFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT wFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT wFlags, CPoint point);
    afx_msg void OnMouseMove(UINT wFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT wFlags, CPoint point);
    afx_msg void OnClose();
    afx_msg void OnDestroy();
    afx_msg void OnWinIniChange(LPCTSTR lpSection);
    afx_msg void OnKeyDown(UINT, UINT, UINT);
    afx_msg LONG OnToolDown(UINT wID, LONG lParam);
    afx_msg LONG OnToolUp(UINT wID, LONG lParam);
    afx_msg LRESULT OnThemeChanged(WPARAM, LPARAM);
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
//  afx_msg LONG OnSwitch(UINT wID, LONG point);

//  virtual BOOL BeginDragDrop( CTool* pTool, CPoint pt );

    DECLARE_MESSAGE_MAP()
    };

/******************************************************************************/

class CImgToolWnd : public CToolboxWnd
    {
    public:     /**************************************************************/

    CRect        m_rcBrushes;

    virtual BOOL Create(const TCHAR* pWindowName, DWORD dwStyle,
                        const RECT& rect, const POINT& btnSize, WORD wWide,
                        CWnd* pParentWnd, BOOL bDkRegister = TRUE);
    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

    BOOL PreTranslateMessage(MSG* pMsg);

    afx_msg void  OnSysColorChange();
    afx_msg BOOL  OnEraseBkgnd(CDC* pDC);
    afx_msg void  OnLButtonDown(UINT nFlags, CPoint pt);
    afx_msg void  OnLButtonDblClk(UINT nFlags, CPoint pt);
    afx_msg void  OnRButtonDown(UINT nFlags, CPoint pt);
    afx_msg void  OnPaint();
    afx_msg UINT  OnNcHitTest(CPoint point);

	virtual int   OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
    virtual CSize GetSize();
    virtual WORD  GetHelpOffset() { return ID_WND_GRAPHIC; }
    virtual void  OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

    void InvalidateOptions(BOOL bErase = TRUE);
    friend class CImgColorsWnd;

#ifdef _DEBUG
    virtual void AssertValid() const
    {
	    CWnd::AssertValid();
    }
#endif //_DEBUG

    DECLARE_MESSAGE_MAP();
    };


/******************************************************************************/

#ifdef CUSTOMFLOAT
class CFloatImgToolWnd : public CMiniFrmWnd
    {
    DECLARE_DYNAMIC(CFloatImgToolWnd)

    public:     /**************************************************************/

    virtual ~CFloatImgToolWnd(void);
    virtual BOOL Create(const TCHAR* pWindowName, DWORD dwStyle,
                        const RECT& rect, const POINT& btnSize, WORD wWide,
                        CWnd* pParentWnd, BOOL bDkRegister = TRUE);
    virtual WORD GetHelpOffset() { return ID_WND_GRAPHIC; }
    afx_msg void OnSysColorChange();
    afx_msg void OnClose();

    DECLARE_MESSAGE_MAP()

    };
#endif //CUSTOMFLOAT

/***************************************************************************/

extern CImgToolWnd* NEAR g_pImgToolWnd;

#endif // __TOOLBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\thumnail.cpp ===
/******************************************************************************/
/* THUMNAIL.CPP: IMPLEMENTATION OF THE CThumbNailView and CFloatThumNailView  */
/*               and CFullScreenThumbNailView Classes                         */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  CThumbNailView Class Object                                               */
/*     CThumbNailView::CThumbNailView                                         */
/*     CThumbNailView::CThumbNailView                                         */
/*     CThumbNailView::~CThumbNailView                                        */
/*     CThumbNailView::Create                                                 */
/*     CThumbNailView::OnSize                                                 */
/*     CThumbNailView::OnPaint                                                */
/*     CThumbNailView::DrawImage                                              */
/*     CThumbNailView::DrawTracker                                            */
/*     CThumbNailView::RefreshImage                                           */
/*     CThumbNailView::GetImgWnd                                              */
/*     CThumbNailView::OnKeyDown                                              */
/*     CThumbNailView::OnLButtonDown                                          */
/*     CThumbNailView::OnRButtonDown                                          */
/*     CThumbNailView::OnThumbnailThumbnail                                   */
/*     CThumbNailView::OnUpdateThumbnailThumbnail                             */
/*                                                                            */
/*  CFloatThumbNailView Class Object                                          */
/*     CFloatThumbNailView::CFloatThumbNailView                               */
/*     CFloatThumbNailView::~CFloatThumbNailView                              */
/*     CFloatThumbNailView::Create                                            */
/*     CFloatThumbNailView::OnClose                                           */
/*     CFloatThumbNailView::OnSize                                            */
/*                                                                            */
/*  CFullScreenThumbNailView Class Object                                     */
/*     CFullScreenThumbNailView::CFullScreenThumbNailView                     */
/*     CFullScreenThumbNailView::CFullScreenThumbNailView                     */
/*     CFullScreenThumbNailView::~CFullScreenThumbNailView                    */
/*     CFullScreenThumbNailView::Create                                       */
/*     CFullScreenThumbNailView::OnLButtonDown                                */
/*     CFullScreenThumbNailView::OnKeyDown                                    */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  These 3 objects provide a layer around the thumbnail view window, which   */
/*  allow it to easily be a child, floating or a full screen. The ThumbNail   */
/*  View Window is just a CWnd Window which on paints does a BitBlt from the  */
/*  CImgWnd it was passsed on construction.                                   */
/*                                                                            */
/*  The structure of the objects is as follows:                               */
/*                                                                            */
/*  CFullScreenThumbNailView is a Frame Window  (with no border and sized to  */
/*      full screen).  It destroys itself on any keystroke or button click     */
/*      while visible, it dissables the main application window.  It contains */
/*      a CThumbNailView object as a child window.                            */
/*                                                                            */
/*  CFloatThumbNailView is a MiniFrame Window                                 */
/*     CThumbNailView is a Child Window (which is sizable) A child of the     */
/*                    the CFloatThumbNailView window.  This can be created    */
/*                    independent if a floating window is not desired (i.e.   */
/*                    for the docked view). It is this window which has the   */
/*                    image drawn into it.                                    */
/*                                                                            */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "docking.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgwnd.h"
#include "thumnail.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CThumbNailView, CWnd)
IMPLEMENT_DYNAMIC(CFloatThumbNailView, CMiniFrmWnd)
IMPLEMENT_DYNAMIC(CFullScreenThumbNailView, CFrameWnd)


#include "memtrace.h"

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/

BEGIN_MESSAGE_MAP(CThumbNailView, CWnd)
    //{{AFX_MSG_MAP(CThumbNailView)
    ON_WM_PAINT()
    ON_WM_KEYDOWN()
    ON_WM_LBUTTONDOWN()
    ON_WM_RBUTTONDOWN()
    ON_COMMAND(ID_THUMBNAIL_THUMBNAIL, OnThumbnailThumbnail)
    ON_UPDATE_COMMAND_UI(ID_THUMBNAIL_THUMBNAIL, OnUpdateThumbnailThumbnail)
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/

CThumbNailView::CThumbNailView(CImgWnd *pcImgWnd)
    {
    m_pcImgWnd = pcImgWnd;
    }

/******************************************************************************/

CThumbNailView::CThumbNailView()
    {
    m_pcImgWnd = NULL;
    }

/******************************************************************************/

CThumbNailView::~CThumbNailView(void)
    {
    }

/******************************************************************************/

BOOL CThumbNailView::Create(DWORD dwStyle, CRect cRectWindow, CWnd *pcParentWnd)
    {
    return( CWnd::Create(NULL, TEXT(""), dwStyle, cRectWindow, pcParentWnd, NULL) );
    }

/***************************************************************************/

void CThumbNailView::OnClose()
    {
    ShowWindow(SW_HIDE);
    }

/******************************************************************************/

void CThumbNailView::OnPaint()
    {
    CPaintDC dc(this); // device context for painting

    // TODO: Add your message handler code here

#ifdef USE_MIRRORING
    //
    // Disable RTL mirroring on full screen window
    //
    if (PBGetLayout(dc.GetSafeHdc()) & LAYOUT_RTL)
    {
        PBSetLayout(dc.GetSafeHdc(), 0);
    }
#endif

    // Do not call CWnd::OnPaint() for painting messages
    DrawImage(&dc);
    }

/******************************************************************************/

void CThumbNailView::DrawImage(CDC* pDC)
    {
    /*
    **  when there is nothing to do, then don't do it
    */
    if (! theApp.m_bShowThumbnail || m_pcImgWnd         == NULL
                                  || m_pcImgWnd->m_pImg == NULL )
        return;

    CRect crectClient;
    int   iMinWidth;
    int   iMinHeight;
    int   iLeft;
    int   iTop;

    CSize cSizeScrollPos = m_pcImgWnd->GetScrollPos();

    cSizeScrollPos.cx = abs( cSizeScrollPos.cx ) - CTracker::HANDLE_SIZE;
    cSizeScrollPos.cy = abs( cSizeScrollPos.cy ) - CTracker::HANDLE_SIZE;

    GetClientRect(crectClient);

    // find the smaller of the two the real image or the thumbnail window.

    iMinWidth  = min( crectClient.Width() , m_pcImgWnd->m_pImg->cxWidth  );
    iMinHeight = min( crectClient.Height(), m_pcImgWnd->m_pImg->cyHeight );

    if (crectClient.Width() >= m_pcImgWnd->m_pImg->cxWidth)
        {
        iLeft = 0; // can fit the whole image width into the thumbnail
        }
    else // image width greater than thumbnail width
        {
        // does thumbnail extend past end if started at scroll pos?
        if (cSizeScrollPos.cx + crectClient.Width() > m_pcImgWnd->m_pImg->cxWidth)
            {
            iLeft = cSizeScrollPos.cx - ( (cSizeScrollPos.cx
                                          + crectClient.Width()
                                          - m_pcImgWnd->m_pImg->cxWidth));
            }
        else
            {
            iLeft = cSizeScrollPos.cx;
            }
        }

    if (crectClient.Height() >= m_pcImgWnd->m_pImg->cyHeight)
        {
        iTop = 0; // can fit the whole image height into the thumbnail
        }
    else // image height greater than thumbnail height
        {
        // does thumbnail extend past bottom if started at scroll pos?
        if (cSizeScrollPos.cy + crectClient.Height() > m_pcImgWnd->m_pImg->cyHeight)
            {
            iTop = cSizeScrollPos.cy - ( (cSizeScrollPos.cy
                                          + crectClient.Height()
                                          - m_pcImgWnd->m_pImg->cyHeight));
            }
        else
            {
            iTop = cSizeScrollPos.cy;
            }
        }

    CDC cDC;
    cDC.Attach(m_pcImgWnd->m_pImg->hDC);

    CPalette* ppalOldSrc = theImgBrush.SetBrushPalette(&cDC, FALSE);
    CPalette* ppalOldDst = theImgBrush.SetBrushPalette( pDC, FALSE);

    pDC->BitBlt(0, 0, iMinWidth, iMinHeight,
                &cDC, iLeft, iTop, SRCCOPY);

    if (ppalOldDst)
    {
        pDC->SelectPalette(ppalOldDst, FALSE);
    }
    if (ppalOldSrc)
    {
        cDC.SelectPalette(ppalOldSrc, FALSE);
    }

    cDC.Detach();

    DrawTracker(pDC);
    }

/******************************************************************************/
/* basically the same processing as the imgwnd::drawtracker method, without   */
/* the zoom */

void CThumbNailView::DrawTracker(CDC *pDC)
    {
//  BOOL bDrawTrackerRgn = FALSE;

    if (m_pcImgWnd->GetCurrent() != m_pcImgWnd
    ||  theImgBrush.m_bMoveSel
    ||  theImgBrush.m_bSmearSel
    ||  theImgBrush.m_bMakingSelection)
        {
        // This is not the active view, or the user is doing something
        // to prevent the tracker from appearing.
        return;
        }

    BOOL bReleaseDC = FALSE;
    CRect clientRect;

    if (pDC == NULL)
        {
        pDC = GetDC();

        if (pDC == NULL)
            {
            theApp.SetGdiEmergency(FALSE);
            return;
            }
        bReleaseDC = TRUE;
        }

    GetClientRect(&clientRect);

    CRect trackerRect;

    m_pcImgWnd->GetImageRect(trackerRect);

    trackerRect.InflateRect(CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE);

    CTracker::EDGES edges = (CTracker::EDGES)(CTracker::right | CTracker::bottom);

//  if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
//      {
//      bDrawTrackerRgn = TRUE;
//      }

    if (m_pcImgWnd->m_pImg == theImgBrush.m_pImg)
        {
        edges = CTracker::all;
        CSize cSzScroll = m_pcImgWnd->GetScrollPos();

        trackerRect = theImgBrush.m_rcSelection;

//      trackerRect.InflateRect( CTracker::HANDLE_SIZE,
//                               CTracker::HANDLE_SIZE);
        trackerRect.OffsetRect(  cSzScroll.cx, cSzScroll.cy);

        }

    if (m_pcImgWnd->m_pImg == theImgBrush.m_pImg)
        {
//      if (bDrawTrackerRgn)
//          {
//          CTracker::DrawBorderRgn( pDC, trackerRect, &(theImgBrush.m_cRgnPolyFreeHandSel) );
//          }
//      else
//          {
            CTracker::DrawBorder( pDC, trackerRect );
//          }
        }

    if (bReleaseDC)
        {
        ReleaseDC(pDC);
        }
    }

/******************************************************************************/
/* Basically Do a paint without an erase background to prevent blinking       */

void CThumbNailView::RefreshImage(void)
    {
    if (theApp.m_bShowThumbnail)
        {
        TRY
            {
            CClientDC dc(this);
            DrawImage(&dc);
            }
        CATCH(CResourceException,e)
            {
            }
        END_CATCH
        }
    }

/******************************************************************************/

CImgWnd* CThumbNailView::GetImgWnd(void)
    {
    return m_pcImgWnd;
    }

/******************************************************************************/

void CThumbNailView::UpdateThumbNailView()
    {
    CPBView* pcbActiveView = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();

    m_pcImgWnd = pcbActiveView->m_pImgWnd;
    }

/******************************************************************************/

void CThumbNailView::OnKeyDown(UINT /*nChar*/, UINT /*nRepCnt*/, UINT /*nFlags*/)
    {
    const MSG* pmsg = GetCurrentMessage();

    GetParent()->SendMessage( pmsg->message, pmsg->wParam, pmsg->lParam );
    }

/******************************************************************************/

void CThumbNailView::OnLButtonDown(UINT /*nFlags*/, CPoint /*point*/)
    {
    const MSG* pmsg = GetCurrentMessage();

    GetParent()->SendMessage(pmsg->message, pmsg->wParam, pmsg->lParam);
    }

/******************************************************************************/

void CThumbNailView::OnRButtonDown(UINT /*nFlags*/, CPoint point)
    {
    HWND  hwnd = GetSafeHwnd();  // must do this before calling SendMsg to parent, since it could delete us,
    const MSG* pmsg = GetCurrentMessage();

    GetParent()->SendMessage(pmsg->message, pmsg->wParam, pmsg->lParam);
    // the window is destroyed by the parent if FullScreenView

    if (::IsWindow(hwnd) != FALSE)  // window still exists => object still valid, put up pop up menu.
        {
        CMenu cMenuPopup;
        CMenu *pcContextMenu;
        BOOL  bRC;
        CRect cRectClient;

        GetClientRect(&cRectClient);

        bRC = cMenuPopup.LoadMenu( IDR_THUMBNAIL_POPUP );

        ASSERT(bRC != 0);

        if (bRC != 0)
            {
            pcContextMenu = cMenuPopup.GetSubMenu(0);

            ASSERT(pcContextMenu != NULL);

            if (pcContextMenu != NULL)
                {
                // update the check marks
                ClientToScreen(&point);
                ClientToScreen(&cRectClient);
                pcContextMenu->CheckMenuItem(ID_THUMBNAIL_THUMBNAIL, MF_BYCOMMAND | MF_CHECKED);
                pcContextMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, &cRectClient);
                }
            }
        }
    }

/******************************************************************************/

void CThumbNailView::OnThumbnailThumbnail()
    {
    CPBView* pView = (CPBView*)(((CFrameWnd*)AfxGetMainWnd())->GetActiveView());

    if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        pView->HideThumbNailView();
    }

/******************************************************************************/

void CThumbNailView::OnUpdateThumbnailThumbnail(CCmdUI* pCmdUI)
    {
    pCmdUI->SetCheck();
    }

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/

BEGIN_MESSAGE_MAP(CFloatThumbNailView, CMiniFrmWnd)
    //{{AFX_MSG_MAP(CFloatThumbNailView)
    ON_WM_CLOSE()
    ON_WM_SIZE()
        ON_WM_GETMINMAXINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/

CFloatThumbNailView::CFloatThumbNailView(CImgWnd *pcMainImgWnd)
    {
    m_pcThumbNailView = new CThumbNailView(pcMainImgWnd);

    if (m_pcThumbNailView == NULL)
        {
        theApp.SetMemoryEmergency();
        TRACE( TEXT("New Thumbnail View faild\n") );
        }
    }

/******************************************************************************/

CFloatThumbNailView::CFloatThumbNailView()
    {
    m_pcThumbNailView = NULL;
    }

/******************************************************************************/

CFloatThumbNailView::~CFloatThumbNailView(void)
    {
    }

/******************************************************************************/

BOOL CFloatThumbNailView::Create(CWnd* pParentWnd)
    {
    BOOL bRC;
    CRect cWindowRect;

    pParentWnd->GetWindowRect( &cWindowRect );

    cWindowRect.BottomRight() = cWindowRect.TopLeft();
    cWindowRect.right   += 120;
    cWindowRect.bottom  += 120;
    cWindowRect.OffsetRect( 15, 15 );

    if (! theApp.m_rectFloatThumbnail.IsRectEmpty())
        {
        cWindowRect = theApp.m_rectFloatThumbnail;
        }

    CString pWindowName;

    pWindowName.LoadString( IDS_VIEW );

    bRC = CMiniFrmWnd::Create( pWindowName, WS_THICKFRAME, cWindowRect, pParentWnd );

    if (bRC)
        {
        ASSERT( m_pcThumbNailView );

        GetClientRect( &cWindowRect );

        if (!m_pcThumbNailView->Create( WS_CHILD | WS_VISIBLE, cWindowRect, this ))
            {
            bRC = FALSE;
            theApp.SetMemoryEmergency();
            TRACE( TEXT("New Thumbnail View faild\n") );
            }
        }

    GetWindowRect( &theApp.m_rectFloatThumbnail );

    return bRC;
    }

/******************************************************************************/
// OnClose
//
// A Colorsbox is usally created by the parent, and will be destroyed
// specifically by the parent upon leaving the app.  When the user closes
// the Colorsbox, it is simply hidden.  The parent can then reshow it without
// recreating it.
//
void CFloatThumbNailView::OnClose()
    {
    theApp.m_bShowThumbnail = FALSE;

    ShowWindow(SW_HIDE);
    }

/******************************************************************************/

void CFloatThumbNailView::PostNcDestroy()
    {
    if (m_pcThumbNailView != NULL)
        {
        delete m_pcThumbNailView;
        m_pcThumbNailView = NULL;
        }

    CWnd::PostNcDestroy();
    }

/******************************************************************************/

void CFloatThumbNailView::OnSize(UINT nType, int cx, int cy)
    {
    CMiniFrmWnd::OnSize(nType, cx, cy);

    if (m_pcThumbNailView                != NULL
    &&  m_pcThumbNailView->GetSafeHwnd() != NULL)
        {
        m_pcThumbNailView->SetWindowPos( &wndTop, 0, 0, cx, cy, SWP_NOACTIVATE );
        }

    theApp.m_rectFloatThumbnail.right  = theApp.m_rectFloatThumbnail.left + cx;
    theApp.m_rectFloatThumbnail.bottom = theApp.m_rectFloatThumbnail.top  + cy;
    }

/******************************************************************************/

void CFloatThumbNailView::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
    {
    lpMMI->ptMinTrackSize.x = 2 * GetSystemMetrics( SM_CXICON );
    lpMMI->ptMinTrackSize.y = 2 * GetSystemMetrics( SM_CYICON );

    CWnd::OnGetMinMaxInfo( lpMMI );
    }

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/

BEGIN_MESSAGE_MAP(CFullScreenThumbNailView, CFrameWnd)
    //{{AFX_MSG_MAP(CFullScreenThumbNailView)
    ON_WM_LBUTTONDOWN()
    ON_WM_KEYDOWN()
    ON_WM_RBUTTONDOWN()
    ON_WM_ERASEBKGND()
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/

CFullScreenThumbNailView::CFullScreenThumbNailView(CImgWnd *pcMainImgWnd)
    {
    m_bSaveShowFlag = theApp.m_bShowThumbnail;
    theApp.m_bShowThumbnail = TRUE;


//  m_brBackground.CreateSolidBrush( ::GetSysColor( COLOR_BACKGROUND ) );

    m_pcThumbNailView = new CThumbNailView(pcMainImgWnd);

    if (m_pcThumbNailView == NULL)
        {
        theApp.SetMemoryEmergency();
        TRACE( TEXT("New Thumbnail View faild\n") );
        }
    }

/******************************************************************************/

CFullScreenThumbNailView::CFullScreenThumbNailView()
    {
    m_hOldIcon = 0;
    m_pcThumbNailView = NULL;
    }

/******************************************************************************/

CFullScreenThumbNailView::~CFullScreenThumbNailView(void)
    {
    if (m_hOldIcon)
    {
       SetClassLongPtr (((CFrameWnd*)this)->GetSafeHwnd(), GCLP_HICON, (LONG_PTR)m_hOldIcon);
    }
    if (m_pcThumbNailView != NULL)
        {
        delete m_pcThumbNailView;

        theApp.m_bShowThumbnail = m_bSaveShowFlag;
        }
//  if (m_brBackground.m_hObject != NULL)
//      m_brBackground.DeleteObject();
    }

/******************************************************************************/

BOOL CFullScreenThumbNailView::Create(LPCTSTR szCaption)
    {
    ASSERT( m_pcThumbNailView );
    TCHAR szFileName[MAX_PATH];
    HICON hIcon;

    CRect cWindowRect( 0, 0, ::GetSystemMetrics( SM_CXSCREEN ),
                             ::GetSystemMetrics( SM_CYSCREEN ) );
    //
    // Use the current file name as the caption of the window so
    // it shows up in alt-tab
    if (szCaption && *szCaption)
    {
       GetFileTitle (szCaption, szFileName, MAX_PATH);
    }
    else
    {
       LoadString (GetModuleHandle (NULL), AFX_IDS_UNTITLED, szFileName, MAX_PATH);
    }

    BOOL bRC = CFrameWnd::Create( NULL, szFileName,  WS_POPUP|WS_VISIBLE | WS_CLIPCHILDREN,
                                                                       cWindowRect );
    //
    // This window needs a Paint icon instead of a boring icon
    // So set the class's icon to the Paint icon
    // We want alt-tab to work decently
    hIcon = LoadIcon (GetModuleHandle (NULL), MAKEINTRESOURCE(ID_MAINFRAME));
    m_hOldIcon = SetClassLongPtr (((CFrameWnd*)this)->GetSafeHwnd(), GCLP_HICON, (LONG_PTR)hIcon);

    if (bRC)
        {
        ASSERT( m_pcThumbNailView );

        AfxGetMainWnd()->EnableWindow( FALSE );

        CImgWnd* pcImgWnd = m_pcThumbNailView->GetImgWnd();

        if (pcImgWnd != NULL)
            {
            // find the smaller of the two the real image or the full screen window size.
            int iMinWidth  = min( cWindowRect.Width(),  pcImgWnd->m_pImg->cxWidth  );
            int iMinHeight = min( cWindowRect.Height(), pcImgWnd->m_pImg->cyHeight );

            // center the image in the full screen window.
            cWindowRect.left   =  (cWindowRect.Width()  - iMinWidth)  / 2;
            cWindowRect.top    =  (cWindowRect.Height() - iMinHeight) / 2;
            cWindowRect.right  =   cWindowRect.left     + iMinWidth;
            cWindowRect.bottom =   cWindowRect.top      + iMinHeight;

            m_pcThumbNailView->Create( WS_CHILD | WS_VISIBLE, cWindowRect, this );
            }
        }

    return bRC;
    }

/******************************************************************************/

BOOL CFullScreenThumbNailView::OnEraseBkgnd( CDC* pDC )
    {
    CBrush* pbr = GetSysBrush( COLOR_BACKGROUND );

//  if (m_brBackground.m_hObject == NULL)
    if (! pbr)
            return CFrameWnd::OnEraseBkgnd( pDC );

    CRect cRectClient;

    GetClientRect( &cRectClient );
    pDC->FillRect( &cRectClient, pbr /* &m_brBackground */ );

    return TRUE;
    }


/******************************************************************************/
void CFullScreenThumbNailView::OnLButtonDown(UINT /*nFlags*/, CPoint /*point*/)
    {
    PostMessage (WM_CLOSE, 0, 0);
    }

/******************************************************************************/

void CFullScreenThumbNailView::OnKeyDown(UINT /*nChar*/, UINT /*nRepCnt*/, UINT /*nFlags*/)
    {
    PostMessage (WM_CLOSE, 0, 0);
    }

/******************************************************************************/


void CFullScreenThumbNailView::OnClose ()
    {
    AfxGetMainWnd()->EnableWindow( TRUE );
    ::DestroyWindow( m_hWnd );
    }
/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\tracker.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "sprite.h"
#include "tracker.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

// FUTURE: Make these static to CTracker!
CBitmap NEAR g_bmapDragHandle;  // Handle for the drag handle bitmap.
CBitmap NEAR g_bmapDragHandle2; // Handle for hollow drag handle bitmap.


// These are the bitmaps arrays used for tracker borders and the dotted
// drag rectangles.
//
static unsigned short bmapHorizBorder[] =
                                { 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0 };

static unsigned short bmapVertBorder [] =
                                { 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA };

static CBrush  NEAR brushHorizBorder;
static CBrush  NEAR brushVertBorder;
static CBitmap NEAR bitmapHorizBorder;
static CBitmap NEAR bitmapVertBorder;

static HCURSOR hcurArrow    = NULL;     // System "Select Arrow" cursor.
static HCURSOR hcurMove     = NULL;     // System "Move" cursor.
static HCURSOR hcurSizeNESW = NULL;     // System sizing "NESW" cursor.
static HCURSOR hcurSizeNS   = NULL;     // System sizing "NS" cursor.
static HCURSOR hcurSizeNWSE = NULL;     // System sizing "NWSE" cursor.
static HCURSOR hcurSizeWE   = NULL;     // System sizing "WE" cursor.
static HCURSOR hcurDragTool;


// This array of hCursors is used to map tracker states (see the definition
// of CTracker in editor.hxx) to the appropriate mouse cursor bitmaps.
//
static HCURSOR* mapTrackerStateToPHCursor[] =
    {
    &hcurArrow,                             // nil
    &hcurArrow,                             // predrag
    &hcurMove,                              // moving
    &hcurSizeNS,                            // resizingTop
    &hcurSizeWE,                            // resizingLeft
    &hcurSizeWE,                            // resizingRight
    &hcurSizeNS,                            // resizingBottom
    &hcurSizeNWSE,                          // resizingTopLeft
    &hcurSizeNESW,                          // resizingTopRight
    &hcurSizeNESW,                          // resizingBottomLeft
    &hcurSizeNWSE,                          // resizingBottomRight
    };


HCURSOR HCursorFromTrackerState( int m )
    {
    ASSERT(m >= 0 &&
        m < sizeof (mapTrackerStateToPHCursor) / sizeof (HCURSOR*));
    return (*(mapTrackerStateToPHCursor[m]));
    }


/* RVUV2
 *
 * This code needs to be called, just once, before we begin to use
 * trackers.  In lieu of a standard initialization function into which
 * I can put this code, I am using a moduleInit variable as a kludge.
 */

BOOL moduleInit = FALSE;                    /**  RVUV2 temporary!  **/

BOOL InitTrackers()
    {
    /*
     * Initialize the brushes and bitmaps needed to do repaints
     */

    if (! bitmapHorizBorder.CreateBitmap( 8, 8, 1, 1, (LPSTR)bmapHorizBorder )
    ||  ! bitmapVertBorder.CreateBitmap ( 8, 8, 1, 1, (LPSTR)bmapVertBorder  )
    ||  ! brushHorizBorder.CreatePatternBrush( &bitmapHorizBorder )
    ||  ! brushVertBorder.CreatePatternBrush ( &bitmapVertBorder  )
    ||  ! g_bmapDragHandle.LoadBitmap ( IDBM_DRAGHANDLE )
    ||  ! g_bmapDragHandle2.LoadBitmap( IDBM_DRAGHANDLE2 ))
        {
        // Future: Failure here should cause error in opening dialog resource!
        theApp.SetMemoryEmergency( FALSE );
        return FALSE;
        }

    hcurArrow    = theApp.LoadStandardCursor( IDC_ARROW );
    hcurMove     = theApp.LoadCursor( IDCUR_MOVE     );
    hcurSizeNESW = theApp.LoadCursor( IDCUR_SIZENESW );
    hcurSizeNS   = theApp.LoadCursor( IDCUR_SIZENS   );
    hcurSizeNWSE = theApp.LoadCursor( IDCUR_SIZENWSE );
    hcurSizeWE   = theApp.LoadCursor( IDCUR_SIZEWE   );

    hcurDragTool = ::LoadCursor( AfxGetInstanceHandle(),
                                 MAKEINTRESOURCE( IDC_DRAGTOOL ));

    moduleInit = TRUE;

    return TRUE;
    }

/***************************************************************************/

void CTracker::CleanUpTracker()
    {
    brushHorizBorder.DeleteObject();
    brushVertBorder.DeleteObject();

    bitmapHorizBorder.DeleteObject();
    bitmapVertBorder.DeleteObject();

    g_bmapDragHandle.DeleteObject();
    g_bmapDragHandle2.DeleteObject();
    }

/***************************************************************************/
// NOTE: The rect passed in here is the inner-most rect of the tracker!

CTracker::STATE CTracker::HitTest( const CRect& rc,
                                         CPoint pt,
                                   STATE defaultState )
    {
    /*
     * Compute position of edge (non-corner) handles
     */
    int xMid = ((rc.right + rc.left) / 2) - (HANDLE_SIZE / 2);
    int yMid = ((rc.top + rc.bottom) / 2) - (HANDLE_SIZE / 2);

    /*
     * Now we do the actual hit-testing for each resizing handle
     */
    if ((pt.x < rc.left) && (pt.x > rc.left - HANDLE_SIZE))
        {
        if ((pt.y < rc.top) && (pt.y > rc.top - HANDLE_SIZE))
            return(resizingTopLeft);
        else
            if ((pt.y >= rc.bottom) && (pt.y < rc.bottom + HANDLE_SIZE))
                return(resizingBottomLeft);
            else
                if ( (pt.y >= yMid) && (pt.y < yMid + HANDLE_SIZE) )
                    return(resizingLeft);
        }
    else
        if ((pt.x >= rc.right) && (pt.x < rc.right + HANDLE_SIZE))
            {
            if ((pt.y < rc.top) && (pt.y > rc.top - HANDLE_SIZE))
                return(resizingTopRight);
            else
                if ((pt.y >= rc.bottom) && (pt.y < rc.bottom + HANDLE_SIZE))
                    return(resizingBottomRight);
                else
                    if ((pt.y >= yMid) && (pt.y < yMid + HANDLE_SIZE))
                        return(resizingRight);
            }
        else
            if ( (pt.x >= xMid) && (pt.x < xMid + HANDLE_SIZE) )
                {
                if ((pt.y < rc.top) && (pt.y > rc.top - HANDLE_SIZE))
                    return(resizingTop);
                else
                    if ((pt.y >= rc.bottom) && (pt.y < rc.bottom + HANDLE_SIZE))
                        return(resizingBottom);
                }

    return (defaultState);
    }

/******************************************************************************/

void CTracker::DrawBorder( CDC* dc, const CRect& trackerRect, EDGES edges )
    {
    if (! moduleInit)
        InitTrackers();     // RVUV2

    // Some precalculation for drawing the fuzzy borders
    int width       = trackerRect.Width();
    int height      = trackerRect.Height();
    int borderWidth =                             HANDLE_SIZE;
    int xLength     = width                     - HANDLE_SIZE * 2;
    int xHeight     = height                    - HANDLE_SIZE * 2;
    int xRight      = trackerRect.left + width  - HANDLE_SIZE;
    int yBottom     = trackerRect.top  + height - HANDLE_SIZE;
    int iOffset     = 1;

    // Draw the fuzzy borders.  Note that we have different bitmaps for
    // the vertical and horizontal borders.
    COLORREF windowColor    = GetSysColor( COLOR_WINDOW    );
    COLORREF highlightColor = GetSysColor( COLOR_HIGHLIGHT );

    dc->SetTextColor( windowColor    ); // colors reversed to adjust for
    dc->SetBkColor  ( highlightColor ); // patblt's reversed world view.

    CBrush* oldBrush = dc->SelectObject( &brushHorizBorder );

    if (! (edges & top))
        {
        dc->SelectObject( GetSysBrush( COLOR_APPWORKSPACE ) );
        iOffset = 0;
        }

    dc->PatBlt( trackerRect.left + HANDLE_SIZE, trackerRect.top + iOffset, xLength, borderWidth - 2 * iOffset, PATCOPY );
    dc->PatBlt( trackerRect.left + HANDLE_SIZE,         yBottom + iOffset, xLength, borderWidth - 2 * iOffset, PATCOPY );

    iOffset = 1;

//  dc->SelectObject( &brushVertBorder );

    if (! (edges & left))
        {
        dc->SelectObject( GetSysBrush( COLOR_APPWORKSPACE ) );
        iOffset = 0;
        }

    dc->PatBlt(           xRight + iOffset, trackerRect.top + HANDLE_SIZE, borderWidth - 2 * iOffset, xHeight, PATCOPY );
    dc->PatBlt( trackerRect.left + iOffset, trackerRect.top + HANDLE_SIZE, borderWidth - 2 * iOffset, xHeight, PATCOPY );

    dc->SelectObject( oldBrush );         // clean up
    }

/******************************************************************************/

void CTracker::DrawHandles( CDC* dc, const CRect& rect, EDGES edges )
    {
    /*
     * Some precalculation for tracker handles.  The bitmaps are colored,
     * but the function that loads them adds the windowColor and
     * selectionColor.
     */
    int x = rect.left + rect.Width() - HANDLE_SIZE;
    int y = rect.top + rect.Height() - HANDLE_SIZE;
    int xMid = rect.left + (((rect.Width() + 1) / 2) - (HANDLE_SIZE / 2));
    int yMid = rect.top + (((rect.Height() + 1) / 2) - (HANDLE_SIZE / 2));

    BOOL bTopLeft     = (edges & top   ) && (edges & left );
    BOOL bTopRight    = (edges & top   ) && (edges & right);
    BOOL bBottomLeft  = (edges & bottom) && (edges & left );
    BOOL bBottomRight = (edges & bottom) && (edges & right);
    /*
     * Choose a solid resizing handle if this is the currently selected
     * control, otherwise choose a hollow tracker handle.
     */
    CDC tempDC;

    if (!tempDC.CreateCompatibleDC(dc))
        {
        theApp.SetGdiEmergency();
        return;
        }
    /*
     * Draw the eight resizing handles.
     */
    dc->SetTextColor( GetSysColor( COLOR_HIGHLIGHT ) );
    dc->SetBkColor  ( GetSysColor( COLOR_WINDOW    ) );

    for (int i = 0; i < 2; i += 1)
        {
        CBitmap* pOldBitmap = tempDC.SelectObject( i? &g_bmapDragHandle2
                                                    : &g_bmapDragHandle );
        if (bTopLeft)
            dc->BitBlt(rect.left, rect.top, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (edges & top)
            dc->BitBlt(xMid, rect.top, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (bTopRight)
            dc->BitBlt(x, rect.top, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (edges & right)
            dc->BitBlt(x, yMid, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (bBottomRight)
            dc->BitBlt(x, y, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (edges & bottom)
            dc->BitBlt(xMid, y, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (bBottomLeft)
            dc->BitBlt(rect.left, y, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (edges & left)
            dc->BitBlt(rect.left, yMid, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);

        edges        = (EDGES)~(int)edges;
        bTopLeft     = !bTopLeft;
        bTopRight    = !bTopRight;
        bBottomLeft  = !bBottomLeft;
        bBottomRight = !bBottomRight;

        tempDC.SelectObject(pOldBitmap);
        }
    }

/******************************************************************************/

void CTracker::DrawBorderRgn( CDC* pdc, const CRect& trackerRect, CRgn *pcRgnPoly)
    {
    int ixOffset, iyOffset;

    if (! moduleInit)
        {
        InitTrackers(); // RVUV2
        }

    COLORREF windowColor    = GetSysColor( COLOR_WINDOW );
    COLORREF highlightColor = GetSysColor( COLOR_HIGHLIGHT );

    pdc->SetTextColor( windowColor    ); // colors reversed to adjust for
    pdc->SetBkColor  ( highlightColor ); // patblt's reversed world view.

    ixOffset = trackerRect.left + CTracker::HANDLE_SIZE + 1;
    iyOffset = trackerRect.top  + CTracker::HANDLE_SIZE + 1;

    // offset bitmap in the imgwnd from selection boundary
    if (pcRgnPoly                  != NULL
    &&  pcRgnPoly->GetSafeHandle() != NULL)
        {
        pcRgnPoly->OffsetRgn( ixOffset, iyOffset );

        pdc->FrameRgn( pcRgnPoly, &brushVertBorder, 1, 1 );

        pcRgnPoly->OffsetRgn( -ixOffset, -iyOffset );
        }
    }

/******************************************************************************/

void CTracker::DrawHandlesRgn( CDC* dc, const CRect& rect, EDGES edges, CRgn *pcRgnPoly)
    {
    /*
     * Some precalculation for tracker handles.  The bitmaps are colored,
     * but the function that loads them adds the windowColor and
     * selectionColor.
     */
    }

/******************************************************************************/

CTracker::STATE CTracker::HitTestRgn( const CRect& rc, CPoint pt,
                                   STATE defaultState, CRgn *pcRgnPoly)
    {
//  if (pcRgnPoly->PtInRegion(pt) != FALSE)

    return (defaultState);
    }

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\tracker.h ===
#ifndef __TRACKER_H__
#define __TRACKER_H__

#include "sprite.h"

extern HCURSOR HCursorFromTrackerState( int m );

class CTracker : public CSprite
    {
    public:

    enum STATE
        {                               // WARNING - mapTrackerStateToPHCursor
        nil,                            //           (in tracker.cpp) is
        predrag,                        //           dependant on the
        moving,                         //           ordering of this enum!
        resizingTop,
        resizingLeft,
        resizingRight,
        resizingBottom,
        resizingTopLeft,
        resizingTopRight,
        resizingBottomLeft,
        resizingBottomRight,
        };

    enum { HANDLE_SIZE = 3 };           // size of tracker resize handles

    enum EDGES
        {
        none   = 0,
        left   = 1,
        top    = 2,
        right  = 4,
        bottom = 8,
        all    = 15
        };

    static  void    DrawBorder ( CDC* pDC, const CRect& rect, EDGES edges = all );
    static  void    DrawHandles( CDC* pDC, const CRect& rect, EDGES edges );

    static  STATE   HitTest(const CRect& rect, CPoint pt, STATE defaultState );

    static  void    DrawBorderRgn ( CDC* pdc, const CRect& trackerRect,              CRgn *pcRgnPoly );
    static  void    DrawHandlesRgn( CDC* pDC, const CRect&        rect, EDGES edges, CRgn *pcRgnPoly );

    static  STATE   HitTestRgn(const CRect& rect, CPoint pt, STATE defaultState, CRgn *pcRgnPoly );

    static  void    CleanUpTracker();
    };

#endif // __TRACKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\t_curve.h ===
#ifndef __T_CURVE_H__
#define __T_CURVE_H__

#include "imgtools.h"

#define MAX_ANCHOR_POINTS  4 // endpoints the user selects (buttondown).

class CCurveTool : public CRubberTool
    {
    DECLARE_DYNAMIC(CCurveTool)

    protected:
        POINT    m_PolyPoints[MAX_ANCHOR_POINTS];
        CRect    m_cRectBounding;
        int      m_iNumAnchorPoints;

        void AdjustBoundingRect(void);
        void AddPoint(POINT ptNewPoint);
        void SetCurrentPoint(POINT ptNewPoint);
        BOOL DrawCurve(CDC* pDC);

        virtual void AdjustPointsForConstraint(MTI *pmti);
        virtual void PreProcessPoints(MTI *pmti);

    public:

        CCurveTool();
        ~CCurveTool();

        virtual void Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown);
        virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti );
        virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti );
        virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti );
        virtual void OnCancel(CImgWnd* pImgWnd);
        virtual void EndMultiptOperation(BOOL bAbort = FALSE);
        virtual void OnActivate( BOOL bActivate );

        BOOL CanEndMultiptOperation(MTI* pmti );

    };


#endif // __T_CURVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\t_fhsel.h ===
#ifndef __T_FHSEL_H__
#define __T_FHSEL_H__

#include "imgtools.h"
#include "t_poly.h"

class CFreehandSelectTool : public CPolygonTool
    {
    DECLARE_DYNAMIC(CFreehandSelectTool)

    protected:

    CRgn *m_pcRgnPoly;
    CRgn *m_pcRgnPolyBorder;

    int  m_iNumPoints;

    void AdjustPointsForZoom( int iZoom );
    BOOL CreatePolyRegion   ( int iZoom );
    BOOL CreatePolyRegion   ( int iZoom, LPPOINT lpPoints, int iPoints );

    virtual BOOL SetupPenBrush( HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown );
    virtual void AdjustPointsForConstraint( MTI *pmti );
    virtual void PreProcessPoints( MTI *pmti );

    virtual BOOL IsToolModal(void);

    public:

    CFreehandSelectTool();
    ~CFreehandSelectTool();

    BOOL ExpandPolyRegion( int iNewSizeX, int iNewSizeY );

    virtual void OnPaintOptions ( CDC* pDC, const CRect& paintRect,
                                  const CRect& optionsRect );
    virtual void OnClickOptions ( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                     const CPoint& clickPoint );



    virtual void OnStartDrag( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnEndDrag  ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnDrag     ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnCancel   ( CImgWnd* pImgWnd );
    virtual void OnActivate ( BOOL bActivate );

    virtual BOOL CanEndMultiptOperation( MTI* pmti );

    friend class CImgWnd;
    };


#endif // __T_FHSEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\t_poly.h ===
#ifndef __T_POLY_H__
#define __T_POLY_H__

#include "imgtools.h"

class CPolygonTool : public CClosedFormTool
    {
    DECLARE_DYNAMIC( CPolygonTool )

    protected:

    CObArray m_cObArrayPoints;
    CRect    m_cRectBounding;
    CImgWnd* m_pImgWnd;
    MTI      m_MTI;

    void DeleteArrayContents ( void );
    void AdjustBoundingRect  ( void );
    BOOL CopyPointsToMemArray( CPoint **pcPoint, int *piNumElements );
    void AddPoint            ( POINT ptNewPoint );
    void SetCurrentPoint     ( POINT ptNewPoint );

    virtual void RenderInProgress         ( CDC* pDC );
    virtual void RenderFinal              ( CDC* pDC );
    virtual BOOL SetupPenBrush            ( HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown );
    virtual void AdjustPointsForConstraint( MTI *pmti );
    virtual void PreProcessPoints         ( MTI *pmti );

    public:

    CPolygonTool();
    ~CPolygonTool();

    virtual void Render        ( CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown );
    virtual void OnEnter       ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnLeave       ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnActivate    ( BOOL bActivate );
    virtual void OnStartDrag   ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnEndDrag     ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnDrag        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnCancel      ( CImgWnd* pImgWnd );
    virtual void OnUpdateColors( CImgWnd* pImgWnd );

    virtual void EndMultiptOperation   ( BOOL bAbort = FALSE );
    virtual BOOL CanEndMultiptOperation( MTI* pmti );


    friend class CImgWnd;
    };

#endif // __T_POLY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\t_curve.cpp ===
/******************************************************************************/
/* T_CURVE.CPP: IMPLEMENTATION OF THE CCurveTool CLASS                        */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  CCurve Tool Class Object                                                  */
/*     CCurveTool::CCurveTool                                                 */
/*     CCurveTool::~CCurveTool                                                */
/*     CCurveTool::AdjustBoundingRect                                         */
/*     CCurveTool::AddPoint                                                   */
/*     CCurveTool::SetCurrentPoint                                            */
/*     CCurveTool::DrawCurve                                                  */
/*     CCurveTool::AdjustPointsForConstraint                                  */
/*     CCurveTool::PreProcessPoints                                           */
/*     CCurveTool::Render                                                     */
/*     CCurveTool::OnStartDrag                                                */
/*     CCurveTool::OnEndDrag                                                  */
/*     CCurveTool::OnDrag                                                     */
/*     CCurveTool::OnCancel                                                   */
/*     CCurveTool::CanEndMultiptOperation                                     */
/*     CCurveTool::EndMultiptOperation                                        */
/******************************************************************************/
/*                                                                            */
/* Briefly, this Object draws a curve from 4 (currently) points. It generates */
/* a list of points which are placed in the array, and then calls polyline    */
/* to draw line segments to build a curve.                                    */
/*                                                                            */
/* The array is divided into 2 pieces.  The first piece is the anchor points, */
/* the 2nd piece is the array of points which will be passed to polyline.     */
/* The anchor points are placed in the array in the following order           */
/* 2,3,4,...1. See the addpoint method below for info on this order.          */
/*                                                                            */
/******************************************************************************/
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "pbrusvw.h"
#include "t_curve.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CCurveTool, CRubberTool)

#include "memtrace.h"

extern CLineTool NEAR g_lineTool;

CCurveTool       NEAR g_curveTool;


/******************************************************************************/
CCurveTool::CCurveTool()
    {
    m_nCmdID = IDMB_CURVETOOL;
    m_iNumAnchorPoints = 0;
    m_cRectBounding.SetRectEmpty();
    }

/******************************************************************************/
CCurveTool::~CCurveTool()
    {
    m_cRectBounding.SetRectEmpty();
    }

/******************************************************************************/
/* recalculate the bounding rectangle for the polyline/curve                  */
void CCurveTool::AdjustBoundingRect(void)
    {
    int iStrokeWidth = GetStrokeWidth();
    int i;

    if (m_iNumAnchorPoints >= 1)
        {
        //set the rect to equal the 1st value
        m_cRectBounding.SetRect(m_PolyPoints[0].x, m_PolyPoints[0].y,
                                m_PolyPoints[0].x, m_PolyPoints[0].y);
        }

    for (i=1; i < m_iNumAnchorPoints; i++)
        {
        m_cRectBounding.SetRect( min(m_PolyPoints[i].x, m_cRectBounding.left),
                                 min(m_PolyPoints[i].y, m_cRectBounding.top),
                                 max(m_PolyPoints[i].x, m_cRectBounding.right),
                                 max(m_PolyPoints[i].y, m_cRectBounding.bottom));
        }

        // Adjust rectangle for Windows GDI (Non-inclusive right/bottom)
        m_cRectBounding.bottom++; m_cRectBounding.right++;

    // Adjust for width of current drawing line/border
    m_cRectBounding.OffsetRect(-(iStrokeWidth/2),-(iStrokeWidth/2));
    m_cRectBounding.InflateRect(iStrokeWidth, iStrokeWidth);
    }
/******************************************************************************/
// This method adds a new point into the array and increases the number of
// anchor points currently in the array.  If there  are no points in the
// array, it adds a point to the 1st position (index 0).  If there are any
// points currently in the array, it copies the last point to the new
// location, and then adds the new point where the old last point was (1 point
// before the last point.  The 1st point added is always the last point in the
// array, and the  2nd point added is always the 1st point.
// The order of the points in the array are: 2,3,4,....,1
void CCurveTool::AddPoint(POINT ptNewPoint)
    {
    BOOL bRC = TRUE;

    if (m_iNumAnchorPoints == 0)
        {
        m_PolyPoints[m_iNumAnchorPoints] = ptNewPoint;
        m_iNumAnchorPoints++;
        }
    else
        {
        if (m_iNumAnchorPoints < MAX_ANCHOR_POINTS)
            {
            m_PolyPoints[m_iNumAnchorPoints] = m_PolyPoints[m_iNumAnchorPoints-1];
            m_PolyPoints[m_iNumAnchorPoints-1] = ptNewPoint;
            m_iNumAnchorPoints++;
            }
        }


    AdjustBoundingRect();
    }
/******************************************************************************/
// This method changes the value of the last point in the array.  If there are
// 2 points, then it modifies the 2nd point, knowing that when there are only
// 2 points, we are draing a straight line (between 2 points).  If there are
// more than 2 points, it modified the second to last point in the array,
// which is actually the last point dropped/placed.  See above for expl of
// order of points in the array.
void CCurveTool::SetCurrentPoint(POINT ptNewPoint)
    {
    if (m_iNumAnchorPoints == 2)
        {
        m_PolyPoints[m_iNumAnchorPoints-1] = ptNewPoint;
        }
    else
        {
        if (m_iNumAnchorPoints > 2)
            {
            m_PolyPoints[m_iNumAnchorPoints-2] = ptNewPoint;
            }
        }
    AdjustBoundingRect();
    }
/******************************************************************************/
BOOL CCurveTool::DrawCurve(CDC* pDC)
    {
                POINT ptCurve[MAX_ANCHOR_POINTS];
                UINT uPoints = m_iNumAnchorPoints;
                int i;

                for (i=uPoints-1; i>=0; --i)
                {
                        ptCurve[i] = m_PolyPoints[i];
                }

                // HACK: PolyBezier cannot handle 3 points, so repeat the middle point
                if (uPoints == 3)
                {
                        ptCurve[3] = ptCurve[2];
                        ptCurve[2] = ptCurve[1];
                        uPoints = 4;
                }

                PolyBezier(pDC->m_hDC, ptCurve, uPoints);

                return(TRUE);
    }
/******************************************************************************/
/* Call the line's adjustpointsforconstraint member function                  */
/* only do this if there are 2 points (i.e. drawing a straight line           */
void CCurveTool::AdjustPointsForConstraint(MTI *pmti)
    {
    if (m_iNumAnchorPoints == 2)
        {
        g_lineTool.AdjustPointsForConstraint(pmti);
        }
    }

/******************************************************************************/
// ptDown must be anchor point for our line, not where we did mouse button down
// on a subsequent point in the multipt operation
void CCurveTool::PreProcessPoints(MTI *pmti)
    {
    pmti->ptDown = m_PolyPoints[0];
    CRubberTool::PreProcessPoints(pmti);
    }

/******************************************************************************/
/* Render sets up the pen and brush, and then calls either Render             */
/* The pen and brush is set up exactly the same as the parent routine in      */
/* CRubberTool.  If there are only 2 points, do the standard line drawing     */
/* using moveto and lineto, instead of trying to create a curve between 2 pts */

void CCurveTool::Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown)
    {
    // Setup Pen/Brush
    SetupPenBrush( pDC->m_hDC, bDraw, TRUE, bCtrlDown );

    if (m_iNumAnchorPoints == 2)
        {
        pDC->MoveTo( m_PolyPoints[0].x, m_PolyPoints[0].y );
        pDC->LineTo( m_PolyPoints[1].x, m_PolyPoints[1].y );
        }
    else
        {
        if (m_iNumAnchorPoints > 2)
            {
            DrawCurve( pDC );
            }
        }
    // Cleanup Pen/Brush
    SetupPenBrush( pDC->m_hDC, bDraw,  FALSE, bCtrlDown );

    // Need to return the bounding rect
    rect = m_cRectBounding;
    }

void CCurveTool::OnActivate( BOOL bActivate )
{
        if (!bActivate && m_bMultPtOpInProgress)
        {
                CImgWnd* pImgWnd = ((CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView())->m_pImgWnd;

                // Stolen from CPBView::OnEscape
                // I don't think this can ever be NULL, but just in case
                if (pImgWnd != NULL)
                {
                        EndMultiptOperation( FALSE ); // end the multipt operation

                        Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), m_cRectBounding, TRUE, TRUE, FALSE);
                        InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);
                        CommitImgRect(pImgWnd->m_pImg, &m_cRectBounding);
                        pImgWnd->FinishUndo(m_cRectBounding);

                        ClearStatusBarSize();
                }
        }

        CRubberTool::OnActivate( bActivate );
}


/******************************************************************************/
/* On Start Drag is called on mouse button down.  We basically call on Start  */
/* Drag of the parent (default) class after adding in our point(s) into the   */
/* array of points.  If this is the first point (i.e. bMultiptOpInProgress == */
/* False, then we need 2 points in our array, and we can call the default     */
/* OnStartDrag.  If it is not the first point, then we just add the new point */
/* and call our OnDrag.  In either case, OnDrag is called which eventually    */
/* calls render to do our drawing on the mouse down                           */
/* We only call the parent OnStartDrag  the first time, because it does some  */
/* setup which we do not want done each time                                  */
void CCurveTool::OnStartDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    if (m_bMultPtOpInProgress)
        {
        AddPoint(pmti->pt);
        OnDrag(pImgWnd, pmti);
        }
    else
        {
        // must reset numAnchorPoints before calling addpoint the 1st time.
        m_iNumAnchorPoints = 0;
        AddPoint(pmti->pt);
        m_bMultPtOpInProgress = TRUE;
        // No Mult Pt In Progress => 1st Click
        //
        // add a 2nd point, last point is what we are draing to
        // 1st point is anchor.  1st time, need 2 points to draw a line
        // subsequent times, just add 1 point in array of points.
        AddPoint(pmti->pt);
        CRubberTool::OnStartDrag(pImgWnd, pmti);
        }

    }
/******************************************************************************/
/* On End Drag is sent on a mouse button up.  This basically is a clone of the*/
/* CRubberTool::OnEndDrag method, except that we use our bounding rect for all*/
/* the image invalidation, and commit, and undo function calls.               */
/* if we are in the middle of a multipoint operation, we do not want to call  */
/* all the routines to fix the drawing (e.g. invalImgRect, CommitImgRect,     */
/* FinishUndo).  We just want to save the current point, render, and return   */
void CCurveTool::OnEndDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    PreProcessPoints(pmti);
    SetCurrentPoint(pmti->pt);

    if (m_bMultPtOpInProgress)
        {
        // can't call OnDrag for this object/class, since it calls preprocesspt
        // again, and then onDrag.  If you call preproces again, you will lose
        // bounding rectange box prev, and not be able to invalidate / repaint
        // Still have to invalidate bounding rect, since if rect is larger than
        // current rect, must invalidate to paint. E.g. If let off shift, then
        // let off button, end point would be adjusted and bouning rect would
        // also be correct, but rect calculated in CRubberTool::OnDrag is
        // incorrect.
        InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);
        CRubberTool::OnDrag(pImgWnd, pmti);
        }
    else
        {
        OnDrag(pImgWnd, pmti); // one last time to refresh display in prep for final render
        Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), m_cRectBounding, pmti->fLeft, TRUE, pmti->fCtrlDown);
        InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);
        CommitImgRect(pImgWnd->m_pImg, &m_cRectBounding);
        pImgWnd->FinishUndo(m_cRectBounding);

        ClearStatusBarSize();

        CImgTool::OnEndDrag(pImgWnd, pmti);
        }
    }

/******************************************************************************/
/* On Drag is sent when the mouse is moved with the button down.  We basically*/
/* save the current point, and call the base class processing.  Since the base*/
/* class processing invalidates the rect on the screen and cleans it up so we */
/* can paint a new line, we have to adjust the previous rectangle to be the   */
/* bounding rectangle of our polyline.  If we did not do this, our previous   */
/* drawing would not get erased, and we would be drawing our new line over    */
/* part of the previous line.  The default processing finally calls Render    */
/* which since our render is virtual, will call our render method above.      */
void CCurveTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    PreProcessPoints(pmti);
    SetCurrentPoint(pmti->pt);
    CRubberTool::OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/
/* On Cancel is sent when the user aborts an operation while in progress      */
/* EndMultiptOperation with TRUE will do all our cleanup                      */
void CCurveTool::OnCancel(CImgWnd* pImgWnd)
    {
    EndMultiptOperation(TRUE);
    CImgTool::OnCancel(pImgWnd);
    }

/******************************************************************************/
/* we can only end if the number of maximum points was entered.  We must stay */
/* in capture/multiptmode until we get EXACTLY the desired number of anchor   */
/* points                                                                     */
BOOL CCurveTool::CanEndMultiptOperation(MTI* pmti )
    {

    if (m_iNumAnchorPoints == MAX_ANCHOR_POINTS)
        {
        m_bMultPtOpInProgress = FALSE;
        }
    else
        {
        m_bMultPtOpInProgress = TRUE;
        }

    return (CRubberTool::CanEndMultiptOperation(pmti));
    }

/******************************************************************************/
/* If bAbort is true, this means an error occurred, or the user cancelled the */
/* multipoint operation in the middle of it.  We just set the num of anchor   */
/* points to 0 to stop drawing and call the default endmultiptoperation       */
void CCurveTool::EndMultiptOperation(BOOL bAbort)
    {
    if (bAbort)
        {
        m_iNumAnchorPoints = 0;
        m_cRectBounding.SetRectEmpty();
        }

    CRubberTool::EndMultiptOperation();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\t_poly.cpp ===
/******************************************************************************/
/* T_POLY.CPP: IMPLEMENTATION OF THE CPolygonTool CLASS                       */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  Polygon Tool Class Object                                                 */
/*     CPolygonTool::CPolygonTool                                             */
/*     CPolygonTool::~CPolygonTool                                            */
/*     CPolygonTool::DeleteArrayContents                                      */
/*     CPolygonTool::AdjustBoundingRect                                       */
/*     CPolygonTool::CopyPointsToMemArray                                     */
/*     CPolygonTool::AddPoint                                                 */
/*     CPolygonTool::SetCurrentPoint                                          */
/*     CPolygonTool::RenderInProgress                                         */
/*     CPolygonTool::RenderFinal                                              */
/*     CPolygonTool::SetupPenBrush                                            */
/*     CPolygonTool::AdjustPointsForConstraint                                */
/*     CPolygonTool::PreProcessPoints                                         */
/*     CPolygonTool::Render                                                   */
/*     CPolygonTool::OnStartDrag                                              */
/*     CPolygonTool::OnEndDrag                                                */
/*     CPolygonTool::OnDrag                                                   */
/*     CPolygonTool::OnCancel                                                 */
/*     CPolygonTool::CanEndMultiptOperation                                   */
/*     CPolygonTool::EndMultiptOperation                                      */
/******************************************************************************/
/*                                                                            */
/* Briefly, This object stores the points of the polygon in a CObArray of     */
/* CPoint Objects.  For the in progress drawing, it calls PolyLine.  When the */
/* polygon is closed or completed (by the user doubleclicking => asking us to */
/* close it), Polygon is called on the same points.                           */
/*                                                                            */
/* The last point in the array of points is always the point the current line */
/* is being drawn to.  The first time 2 points are added (the Anchor/first    */
/* point, and the point the line is being drawn to) It does happen that this  */
/* first time, they are the same point.  It is necessary that the first time  */
/* 2 points are added, since subsequent times, new points are not added, but  */
/* the last point is reset.                                                   */
/*                                                                            */
/******************************************************************************/
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "t_poly.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CPolygonTool, CClosedFormTool)

#include "memtrace.h"

extern CLineTool NEAR g_lineTool;

CPolygonTool     NEAR g_polygonTool;

extern MTI NEAR mti;

/******************************************************************************/

CPolygonTool::CPolygonTool()
    {
    m_nCmdID              = IDMB_POLYGONTOOL;
    m_cRectBounding.SetRectEmpty();
    m_bMultPtOpInProgress = FALSE;
    m_nStrokeWidth        = 1;
    }

/******************************************************************************/

CPolygonTool::~CPolygonTool()
    {
    m_cRectBounding.SetRectEmpty();
    DeleteArrayContents();
    }

/******************************************************************************/
/* delete all cpoint objects allocated and stored in the array                */
/* also free any memory associated with the array                             */

void CPolygonTool::DeleteArrayContents(void)
    {
    int iSize = (int)m_cObArrayPoints.GetSize();

    CPoint *pcPoint;

    for (int i = 0; i < iSize; i++)
        {
        pcPoint= (CPoint *)m_cObArrayPoints.GetAt( i );
        delete pcPoint;
        }
    m_cObArrayPoints.RemoveAll();
    }

/******************************************************************************/
/* recalculate the bounding rectangle for the polyline/polygon                */

void CPolygonTool::AdjustBoundingRect(void)
    {
    int iSize = (int)m_cObArrayPoints.GetSize();
    CPoint *pcPoint;
    int iStrokeWidth = GetStrokeWidth();
    int i;

    if (iSize >= 1)
        {
        pcPoint= (CPoint*)m_cObArrayPoints.GetAt( 0 );
        //set the rect to equal the 1st value
        m_cRectBounding.SetRect(pcPoint->x, pcPoint->y, pcPoint->x, pcPoint->y);
        }

    for (i = 1; i < iSize; i++)
        {
        pcPoint = (CPoint *)m_cObArrayPoints.GetAt( i );

        m_cRectBounding.SetRect( min( pcPoint->x, m_cRectBounding.left   ),
                                 min( pcPoint->y, m_cRectBounding.top    ),
                                 max( pcPoint->x, m_cRectBounding.right  ),
                                 max( pcPoint->y, m_cRectBounding.bottom ) );
        }
    // Adjust for width of current drawing line/border
    m_cRectBounding.OffsetRect ( -(iStrokeWidth / 2), -(iStrokeWidth / 2) );
    m_cRectBounding.InflateRect(   iStrokeWidth     ,   iStrokeWidth);
    }

/******************************************************************************/
/* This method will copy the CObArray structure of CPoints to a contiguous    */
/* memory block of CPoint Structures                                          */

BOOL CPolygonTool::CopyPointsToMemArray(CPoint **pcPoint, int *piNumElements)
    {
    BOOL bRC = TRUE;
    int i;
    int iSize = (int)m_cObArrayPoints.GetSize();

    if (! iSize)
        {
        *piNumElements = 0;
        *pcPoint = NULL;
        return TRUE;
        }
    TRY
        {
        *pcPoint = new CPoint[iSize];

        if (*pcPoint == NULL)
            {
            AfxThrowMemoryException();
            }

        for (i=0; i < iSize; i++)
            {
            (*pcPoint)[i] = *((CPoint*) (m_cObArrayPoints[i]));
            }

        *piNumElements = iSize;
        }

    CATCH(CMemoryException,e)
        {
        *piNumElements = 0;
        bRC = FALSE;
        }

    END_CATCH

    return bRC;
    }

/******************************************************************************/
/* This routine can Throw a CMemoryException!!                                */
/* It adds a new point to the end of the array, possibly increasing the size  */

void CPolygonTool::AddPoint(POINT ptNewPoint)
    {

    CPoint *pcPoint;

    pcPoint = new CPoint(ptNewPoint);
    if (pcPoint == NULL)
        {
        AfxThrowMemoryException();
        }

    m_cObArrayPoints.Add((CObject *)pcPoint);
    AdjustBoundingRect();
    }

/******************************************************************************/
/* This method changes the value of the last point in the array.  It does not */
/* remove the point and add a new one.  It just modifies it in place          */

void CPolygonTool::SetCurrentPoint(POINT ptNewPoint)
    {
    int iLast = (int)m_cObArrayPoints.GetUpperBound();

    if (iLast >= 0)
        {
        CPoint *pcPoint = (CPoint *) m_cObArrayPoints[iLast];

        pcPoint->x = ptNewPoint.x;
        pcPoint->y = ptNewPoint.y;

        AdjustBoundingRect();
        }
    }

/******************************************************************************/
/* Render In Progress is called for all drawing during the multi-pt operation */
/* The only difference between this method and RenderFinal is that it calls   */
/* polyline and RenderFinal calls polygon.                                    */

void CPolygonTool::RenderInProgress(CDC* pDC)
    {

    CPoint *pcPointArray = 0;
    int     iNumElements;



    if (CopyPointsToMemArray( &pcPointArray, &iNumElements ) && pcPointArray != NULL)
        {
        pDC->Polyline(pcPointArray, iNumElements);

        delete [] pcPointArray;
        }
    }

/******************************************************************************/
/* Render Final is called at the end of the multi-pt drawing mode.  The only  */
/* difference between this method and RenderInProgress is that it calls       */
/* polygon and RenderInProgress calls polyline.                               */

void CPolygonTool::RenderFinal(CDC* pDC)
    {

    CPoint *pcPointArray = 0;
    int     iNumElements;


    if (CopyPointsToMemArray(&pcPointArray, &iNumElements) && pcPointArray != NULL)
        {
        // Remove RIP with only 2 points
        if (iNumElements > 2)
            pDC->Polygon(pcPointArray, iNumElements);
        delete [] pcPointArray;
        }

    }

/******************************************************************************/
/* This routine is called before rendering onto the DC.  It basically, calls  */
/* the default setup to setup the pen and brush, and then overrides the Pen if*/
/* drawing in progress and drawing without any border.  This case is necessary*/
/* since if you do not have a border, you need to see something during the in */
/* progress drawing mode.  It uses the inverse (not) of the screen color as   */
/* the border in this mode.                                                   */

BOOL CPolygonTool::SetupPenBrush(HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown)
    {
    static int  iOldROP2Code;
    static BOOL bCurrentlySetup = FALSE;

    BOOL bRC = CClosedFormTool::SetupPenBrush(hDC, bLeftButton, bSetup, bCtrlDown);

    // for multipt operations in progress (e.g. drawing outline, not fill yet
    // if there is no border, use the not of the screen color for the border.
    // When bMultiptopinprogress == FALSE, final drawing, we will use a null
    // pen and thus have no border.
    if (m_bMultPtOpInProgress)
        {
        if (bSetup)
            {
            if (! bCurrentlySetup)
               {
               bCurrentlySetup = TRUE;

               // if no border, draw inprogress border as inverse of screen color
               if (! m_bBorder)
                   iOldROP2Code = SetROP2(hDC, R2_NOT);
               }
            else
                // Error: Will lose allocated Brush/Pen
                bRC = FALSE;
            }
        else
            {
            if (bCurrentlySetup)
                {
                bCurrentlySetup = FALSE;

                // if no border, restore drawing mode
                if (! m_bBorder)
                    SetROP2(hDC, iOldROP2Code);
                }
            else
                // Error: Cannot Free/cleanup Brush/Pen -- Never allocated.
                bRC = FALSE;
            }
        }

    return bRC;
    }

/******************************************************************************/
/* Call the line's adjustpointsforconstraint member function                  */
void CPolygonTool::AdjustPointsForConstraint(MTI *pmti)
    {
    g_lineTool.AdjustPointsForConstraint(pmti);
    }

/******************************************************************************/
// ptDown must be anchor point for our line, not where we did mouse button down

void CPolygonTool::PreProcessPoints(MTI *pmti)
    {
    int iLast = (int)m_cObArrayPoints.GetUpperBound();

    if (iLast > 0)
        iLast--;

    CPoint* pcPoint;

    if (iLast >= 0)
        {
        pcPoint = (CPoint *)m_cObArrayPoints[iLast];
        pmti->ptDown = *pcPoint;
        }
    CClosedFormTool::PreProcessPoints(pmti);
    }

/******************************************************************************/
/* Render sets up the pen and brush, and then calls either RenderInProgress   */
/* or RenderFinal.  RenderInProgress is called if in the middle of a multipt  */
/* operation, and RenderFinal is called when a multipt operation is complete  */
/* The pen and brush is set up exactly the same as the parent routine in      */
/* CRubberTool */

void CPolygonTool::Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown)
    {
    // Setup Pen/Brush
    SetupPenBrush(pDC->m_hDC, bDraw, TRUE, bCtrlDown);

    if (m_bMultPtOpInProgress)
        {
        RenderInProgress(pDC);
        }
    else
        {
        RenderFinal(pDC);
        }
    // Cleanup Pen/Brush
    SetupPenBrush(pDC->m_hDC, bDraw,  FALSE, bCtrlDown);

    // Need to return the bounding rect
    rect = m_cRectBounding;
    }

/******************************************************************************/

void CPolygonTool::OnActivate( BOOL bActivate )
    {
    if (! bActivate && m_bMultPtOpInProgress)
        {
        if (m_pImgWnd != NULL)
            if (m_cObArrayPoints.GetSize() > 1)
                {
                OnStartDrag( m_pImgWnd, &m_MTI );
                OnEndDrag  ( m_pImgWnd, &m_MTI );

                m_MTI.ptPrev = m_MTI.pt;

                EndMultiptOperation(); // end the multipt operation

                OnEndDrag( m_pImgWnd, &m_MTI );

                mti.fLeft  = FALSE;
                mti.fRight = FALSE;
                }
            else
                OnCancel( m_pImgWnd );
        else
            EndMultiptOperation( TRUE );
        }
    m_pImgWnd = NULL;

        if (bActivate)
        {
                m_nStrokeWidth = g_nStrokeWidth;
        }
        else
        {
                g_nStrokeWidth = m_nStrokeWidth;
        }

    CImgTool::OnActivate( bActivate );
    }

/******************************************************************************/

void CPolygonTool::OnEnter( CImgWnd* pImgWnd, MTI* pmti )
    {
    m_pImgWnd = NULL;
    }

/******************************************************************************/

void CPolygonTool::OnLeave( CImgWnd* pImgWnd, MTI* pmti )
    {
    m_pImgWnd = pImgWnd;
    }

/******************************************************************************/
/* On Start Drag is called on mouse button down.  We basically call on Start  */
/* Drag of the parent (default) class after adding in our point(s) into the   */
/* array of points.  If this is the first point (i.e. bMultiptOpInProgress == */
/* False, then we need 2 points in our array, and we can call the default     */
/* OnStartDrag.  If it is not the first point, then we just add the new point */
/* and call our OnDrag.  In either case, OnDrag is called which eventually    */
/* calls render to do our drawing on the mouse down                           */

void CPolygonTool::OnStartDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    TRY {
        if (m_bMultPtOpInProgress)
            {
            CRect rect;

            CPoint pt = pmti->pt;

            pImgWnd->ImageToClient( pt );
            pImgWnd->GetClientRect( &rect );

            if (rect.PtInRect( pt ))
                {
                AddPoint( pmti->pt );
                OnDrag( pImgWnd, pmti );
                }
            }
        else
            {
            DeleteArrayContents();
            m_cRectBounding.SetRectEmpty();

            AddPoint( pmti->pt );
            // must set m_bmultptopinprogress prior to calling onstartdrag
            // since that calls render,and render will call renderinprogress
            // or renderfinal depending on the sate of this variable.
            m_bMultPtOpInProgress = TRUE;
            // No Mult Pt In Progress => 1st Click
            //
            // add a 2nd point, last point is what we are draing to
            // 1st point is anchor.  1st time, need 2 points to draw a line
            // subsequent times, just re-use last point as anchor and only one
            // more point is added (above outside test for m_bmultptopinprogress)
            AddPoint( pmti->pt );
            CClosedFormTool::OnStartDrag( pImgWnd, pmti );
            }
        }

    CATCH(CMemoryException,e)
        {
        }

    END_CATCH
    }

/******************************************************************************/
/* On End Drag is sent on a mouse button up.  This basically is a clone of the*/
/* CRubberTool::OnEndDrag method, except that we use our bounding rect for all*/
/* the image invalidation, and commit, and undo function calls.               */
/* if we are in the middle of a multipoint operation, we do not want to call  */
/* all the routines to fix the drawing (e.g. invalImgRect, CommitImgRect,     */
/* FinishUndo).  We just want to save the current point, render, and return   */

void CPolygonTool::OnEndDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    PreProcessPoints(pmti);
    SetCurrentPoint(pmti->pt);

    if (m_bMultPtOpInProgress)
        {
        m_MTI = *pmti;
        // can't call OnDrag for this object/class, since it calls preprocesspt
        // again, and then onDrag.  If you call preproces again, you will lose
        // bounding rectange box prev, and not be able to invalidate / repaint
        // Still have to invalidate bounding rect, since if rect is larger than
        // current rect, must invalidate to paint. E.g. If let off shift, then
        // let off button, end point would be adjusted and bouning rect would
        // also be correct, but rect calculated in CClosedFormTool::OnDrag is
        // incorrect.
        InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);

        CClosedFormTool::OnDrag(pImgWnd, pmti);
        return;
        }


    if (! m_cObArrayPoints.GetSize())
        return;

    OnDrag(pImgWnd, pmti); // one last time to refresh display in prep for final render
    Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), m_cRectBounding, pmti->fLeft, TRUE, pmti->fCtrlDown);
    InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);
    CommitImgRect(pImgWnd->m_pImg, &m_cRectBounding);
    pImgWnd->FinishUndo(m_cRectBounding);

    ClearStatusBarSize();

    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/******************************************************************************/
/* On Drag is sent when the mouse is moved with the button down.  We basically*/
/* save the current point, and call the base class processing.  Since the base*/
/* class processing invalidates the rect on the screen and cleans it up so we */
/* can paint a new line, we have to adjust the previous rectangle to be the   */
/* bounding rectangle of our polyline.  If we did not do this, our previous   */
/* drawing would not get erased, and we would be drawing our new line over    */
/* part of the previous line.  The default processing finally calls Render    */
/* which since our render is virtual, will call our render method above.      */

void CPolygonTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    PreProcessPoints    ( pmti     );
    SetCurrentPoint     ( pmti->pt );
    SetStatusBarPosition( pmti->pt );
    SetStatusBarSize    ( m_cRectBounding.Size() );

    CClosedFormTool::OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/
/* On Cancel is sent when the user aborts an operation while in progress      */
/* EndMultiptOperation with TRUE will do all our cleanup                      */

void CPolygonTool::OnCancel(CImgWnd* pImgWnd)
    {
    InvalImgRect( pImgWnd->m_pImg, &m_cRectBounding );
    EndMultiptOperation(TRUE);
    CClosedFormTool::OnCancel(pImgWnd);
    }

/******************************************************************************/
/* If point is on 1st point (i.e. closes the polygon) then can end is true    */
// Use the stroke width to determine the width of the line and whether the    */
/* end point touches the beginning point because of the line thickness        */

BOOL CPolygonTool::CanEndMultiptOperation(MTI* pmti )
    {
    CPoint *pcPoint = (CPoint *) m_cObArrayPoints[0];

    CSize cSizeDiff = (*pcPoint) - pmti->pt;

    int iStrokeWidth = GetStrokeWidth() * 2;

    m_bMultPtOpInProgress = ! ((abs( cSizeDiff.cx ) <= iStrokeWidth)
                            && (abs( cSizeDiff.cy ) <= iStrokeWidth));
    return ( TRUE );
    }

/******************************************************************************/
/* If bAbort is true, this means an error occurred, or the user cancelled the */
/* multipoint operation in the middle of it.  We need to clean up the         */
/* allocated memory in our array of points.                                   */

void CPolygonTool::EndMultiptOperation( BOOL bAbort )
    {
    if (bAbort)
        {
        DeleteArrayContents();
        }

    CClosedFormTool::EndMultiptOperation();
    }

/******************************************************************************/

void CPolygonTool::OnUpdateColors( CImgWnd* pImgWnd )
    {
    if (m_cObArrayPoints.GetSize() && m_bMultPtOpInProgress)
        {
        OnStartDrag( pImgWnd, &m_MTI );
        OnEndDrag  ( pImgWnd, &m_MTI );
        }
    }

/******************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\t_fhsel.cpp ===
/******************************************************************************/
/* T_FHSEL.CPP: IMPLEMENTATION OF THE CFreehandSelectTool CLASS               */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/******************************************************************************/
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgbrush.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "t_fhsel.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CFreehandSelectTool, CPolygonTool )

#include "memtrace.h"

extern CSelectTool  NEAR g_selectTool;
CFreehandSelectTool NEAR g_freehandselectTool;

/******************************************************************************/

CFreehandSelectTool::CFreehandSelectTool()
    {
    m_bIsUndoable     = FALSE;
    m_nCmdID          = IDMB_PICKRGNTOOL;
    m_bCanBePrevTool  = FALSE;
    m_bFilled         = FALSE;
    m_bBorder         = FALSE;
    m_nStrokeWidth    = 1;
    m_pcRgnPoly       = &(theImgBrush.m_cRgnPolyFreeHandSel);
    m_pcRgnPolyBorder = &(theImgBrush.m_cRgnPolyFreeHandSelBorder);
    }

/******************************************************************************/

CFreehandSelectTool::~CFreehandSelectTool()
    {
    }

/******************************************************************************/

void CFreehandSelectTool::AdjustPointsForZoom(int iZoom)
    {
    int iSize = (int)m_cObArrayPoints.GetSize();
    CPoint *pcPoint;

    for (int i = 0; i < iSize; i++)
        {
        pcPoint= (CPoint *)m_cObArrayPoints.GetAt(i);
        pcPoint->x *= iZoom;
        pcPoint->y *= iZoom;
        }
    }

/******************************************************************************/

BOOL CFreehandSelectTool::CreatePolyRegion( int iZoom )
    {
    BOOL bRC = TRUE;
    CPoint *pcPointArray;

    // cleanup old region if exists
    if (m_pcRgnPoly->GetSafeHandle())
        m_pcRgnPoly->DeleteObject();

    // cleanup old region if exists
    if (m_pcRgnPolyBorder->GetSafeHandle())
        m_pcRgnPolyBorder->DeleteObject();

    bRC = CopyPointsToMemArray( &pcPointArray, &m_iNumPoints );

    if (! bRC)
        {
        theApp.SetMemoryEmergency();
        return FALSE;
        }

    bRC = m_pcRgnPoly->CreatePolygonRgn( pcPointArray, m_iNumPoints, ALTERNATE );

    delete [] pcPointArray;

    if (! bRC)  // offset for selection boundary
        {
        theApp.SetGdiEmergency();
        return FALSE;
        }

    m_pcRgnPoly->OffsetRgn( -m_cRectBounding.left,
                            -m_cRectBounding.top );
    //
// This adjustment appears to be unnecessary. removed it 5/1/1997
//    AdjustPointsForZoom( iZoom );

    bRC = CopyPointsToMemArray( &pcPointArray, &m_iNumPoints );

    if (bRC)
        {
        bRC = m_pcRgnPolyBorder->CreatePolygonRgn( pcPointArray, m_iNumPoints, ALTERNATE );

        delete [] pcPointArray;

        if (bRC) // offset for selection boundary
            m_pcRgnPolyBorder->OffsetRgn( -(m_cRectBounding.left * iZoom),
                                          -(m_cRectBounding.top  * iZoom) );
        }
    if (! bRC)
        m_pcRgnPoly->DeleteObject();

    return bRC;
    }

/******************************************************************************/

BOOL CFreehandSelectTool::CreatePolyRegion( int iZoom, LPPOINT lpPoints, int iPoints )
    {
    if (! lpPoints || iPoints < 3)
        return FALSE;

    DeleteArrayContents();

    TRY {
        CPoint* pPt;

        for (int i = 0; i < iPoints; i++)
            {
            pPt = new CPoint( lpPoints[i] );

            m_cObArrayPoints.Add( (CObject *)pPt );
            }
        }
    CATCH( CMemoryException, e )
        {
        DeleteArrayContents();

        theApp.SetMemoryEmergency();

        return FALSE;
        }
    END_CATCH

    m_iNumPoints = iPoints;

    AdjustBoundingRect();

    rcPrev = m_cRectBounding;
    m_bMultPtOpInProgress = FALSE;

    theImgBrush.m_bMakingSelection = FALSE;
    theImgBrush.m_bMoveSel         = FALSE;
    theImgBrush.m_bSmearSel        = FALSE;

    if (! CreatePolyRegion( iZoom ))
        return FALSE;

    return TRUE;
    }

/******************************************************************************/

BOOL CFreehandSelectTool::ExpandPolyRegion( int iNewSizeX, int iNewSizeY )
    {
    CPoint* pcPointArray;
    int    iNumPts;

    if (! CopyPointsToMemArray( &pcPointArray, &iNumPts ))
        return FALSE;

    int iWidth  = m_cRectBounding.Width()  + 1;
    int iHeight = m_cRectBounding.Height() + 1;
    int iDeltaX = ((iNewSizeX - iWidth ) * 10) / iWidth;
    int iDeltaY = ((iNewSizeY - iHeight) * 10) / iHeight;

    CPoint* pPtArray = pcPointArray;
    int     iPts     = iNumPts;

    while (iPts--)
        {
        pPtArray->x = (((pPtArray->x * 10) + (pPtArray->x * iDeltaX)) + 5) / 10;
        pPtArray->y = (((pPtArray->y * 10) + (pPtArray->y * iDeltaY)) + 5) / 10;

        pPtArray++;
        }

    BOOL bReturn = CreatePolyRegion( CImgWnd::GetCurrent()->GetZoom(),
                                     pcPointArray, iNumPts );
    delete [] pcPointArray;

    return bReturn;
    }

/******************************************************************************/
/* This routine is called before rendering onto the DC.  It basically, calls  */
/* the default setup to setup the pen and brush, and then overrides the Pen if*/
/* drawing in progress and drawing without any border.  This case is necessary*/
/* since if you do not have a border, you need to see something during the in */
/* progress drawing mode.  It uses the inverse (not) of the screen color as   */
/* the border in this mode.                                                   */

BOOL CFreehandSelectTool::SetupPenBrush(HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown)
    {
    static int iOldROP2Code;
    static BOOL bCurrentlySetup = FALSE;

    m_nStrokeWidth = 1;  // override any changes

    BOOL bRC = CClosedFormTool::SetupPenBrush(hDC, bLeftButton, bSetup, bCtrlDown);

    // for multipt operations in progress (e.g. drawing outline, not fill yet
    // if there is no border, use the not of the screen color for the border.
    // When bMultiptopinprogress == FALSE, final drawing, we will use a null
    // pen and thus have no border.
    if (bSetup)
        {
        if (bCurrentlySetup)
            bRC = FALSE;
        else
            {
            bCurrentlySetup = TRUE;
            iOldROP2Code = SetROP2(hDC, R2_NOT);
            }
        }
    else
        {
        if (bCurrentlySetup)
            {
            bCurrentlySetup = FALSE;

            // if no border, restore drawing mode
            SetROP2(hDC, iOldROP2Code);
            }
        else
            // Error: Cannot Free/cleanup Brush/Pen -- Never allocated.
            bRC = FALSE;
        }

    return bRC;
    }

/******************************************************************************/
/* Call the line's adjustpointsforconstraint member function                  */

void CFreehandSelectTool::AdjustPointsForConstraint(MTI *pmti)
    {
    CClosedFormTool::AdjustPointsForConstraint(pmti);
    }

/******************************************************************************/
// ptDown must be anchor point for our line, not where we did mouse button down

void CFreehandSelectTool::PreProcessPoints(MTI *pmti)
    {
    CClosedFormTool::PreProcessPoints(pmti);
    }

/***************************************************************************/

void CFreehandSelectTool::OnPaintOptions ( CDC* pDC,
                                           const CRect& paintRect,
                                           const CRect& optionsRect )
    {
    g_selectTool.OnPaintOptions( pDC, paintRect, optionsRect );
    }

/******************************************************************************/

void CFreehandSelectTool::OnClickOptions ( CImgToolWnd* pWnd,
                                           const CRect& optionsRect,
                                           const CPoint& clickPoint )
    {
    g_selectTool.OnClickOptions(pWnd, optionsRect, clickPoint);
    }

/******************************************************************************/

void CFreehandSelectTool::OnStartDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    HideBrush();
    OnActivate( FALSE );
//  CommitSelection( TRUE );

    pImgWnd->EraseTracker();
    theImgBrush.m_bMakingSelection = TRUE;

    // simulate multipt op in progress, until button up or asked.  This will
    // allow us to draw differently for duration and end.
    m_bMultPtOpInProgress = TRUE;

    DeleteArrayContents();

    CClosedFormTool::OnStartDrag( pImgWnd, pmti );
    }

/******************************************************************************/

void CFreehandSelectTool::OnEndDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    int iZoom = pImgWnd->GetZoom();

    theImgBrush.m_bMakingSelection = FALSE;
    theImgBrush.m_bMoveSel         = theImgBrush.m_bSmearSel = FALSE;

    OnDrag(pImgWnd, pmti); // one last time to refresh display in prep for final render

    Render( CDC::FromHandle(pImgWnd->m_pImg->hDC), m_cRectBounding, pmti->fLeft, TRUE, pmti->fCtrlDown );

    m_iNumPoints = (int)m_cObArrayPoints.GetSize();

    if (m_iNumPoints > 2)
        if (! CreatePolyRegion( iZoom ))
            return;

    if (pmti->ptDown.x == pmti->pt.x
    &&  pmti->ptDown.y == pmti->pt.y)
        {
        if (m_iNumPoints > 3) // 3 is min points.  If click down/up get 2
            {
            // must fool selectTool.OnEndDrag to think width of selection is
            // greater than 0.  If 0, thinks selection is done/place it (i.e.
            // just clicked down/up.  We only do this if the end point is the
            // same as the beginning point.  This case will have width=height=0,
            // but number of points > 2
            pmti->pt.x++;
            pmti->pt.y++;
            }
        }

    pmti->ptDown = m_cRectBounding.TopLeft();
    pmti->pt     = m_cRectBounding.BottomRight();

    g_selectTool.OnEndDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CFreehandSelectTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    // Must set rcPrev to m_cRectBoundingRect prior to calling SetCurrentPoint
    // Since SetCurrentPoint will adjust m_cRectBounding, and we want the
    // previous bounding rect.
    rcPrev = m_cRectBounding;

    if (pmti->pt.x > pImgWnd->m_pImg->cxWidth)
        pmti->pt.x = pImgWnd->m_pImg->cxWidth;

    if (pmti->pt.y > pImgWnd->m_pImg->cyHeight)
        pmti->pt.y = pImgWnd->m_pImg->cyHeight;

    if (pmti->pt.x < 0)
        pmti->pt.x = 0;

    if (pmti->pt.y < 0)
        pmti->pt.y = 0;

    TRY {
        AddPoint(pmti->pt);
        }

    CATCH(CMemoryException,e)
        {
        theApp.SetMemoryEmergency();
        return;
        }
    END_CATCH

    CClosedFormTool::OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CFreehandSelectTool::OnCancel(CImgWnd* pImgWnd)
    {
    // We were not selecting or dragging, just cancel the select tool...
    CommitSelection( TRUE );

    //render one last time to turn off/invert the line if any drawn
        if (theImgBrush.m_bMakingSelection)
        {
                Render( CDC::FromHandle( pImgWnd->m_pImg->hDC ), m_cRectBounding,
                        TRUE, TRUE, FALSE );
        }
    theImgBrush.TopLeftHandle();

    g_bCustomBrush = FALSE;
    theImgBrush.m_pImg             = NULL;
    theImgBrush.m_bMoveSel         = FALSE;
    theImgBrush.m_bSmearSel        = FALSE;
    theImgBrush.m_bMakingSelection = FALSE;

    InvalImgRect( pImgWnd->m_pImg, NULL );

    DeleteArrayContents();

    CPolygonTool::OnCancel(pImgWnd);
    }

/***************************************************************************/

BOOL CFreehandSelectTool::IsToolModal(void)
{
        if (theImgBrush.m_pImg)
        {
                return(TRUE);
        }

        return(CPolygonTool::IsToolModal());
}

/******************************************************************************/

void CFreehandSelectTool::OnActivate(BOOL bActivate)
    {
    g_selectTool.OnActivate(bActivate);
    }

/******************************************************************************/
/* this class really isn't a multipt operation, but is derived from one thus  */
/* we can always end the multipt operation if anyone asks                     */

BOOL CFreehandSelectTool::CanEndMultiptOperation(MTI* pmti )
    {
    m_bMultPtOpInProgress = FALSE;
    return (CClosedFormTool::CanEndMultiptOperation(pmti));
    }

/******************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\t_text.cpp ===
/******************************************************************************/
/* T_TEXT.CPP: IMPLEMENTATION OF THE CTextTool CLASS                        */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  CText Tool Class Object                                                   */
/*     CTextTool::CTextTool                                                   */
/*     CTextTool::~CTextTool                                                  */
/*     CTextTool::CreateTextEditObject                                        */
/*     CTextTool::PlaceTextOnBitmap                                           */
/*     CTextTool::OnUpdateColors                                              */
/*     CTextTool::OnCancel                                                    */
/*     CTextTool::OnStartDrag                                                 */
/*     CTextTool::OnEndDrag                                                   */
/*     CTextTool::OnDrag                                                      */
/*     CTextTool::OnClickOptions                                              */
/******************************************************************************/
/*                                                                            */
/* This is the Text edit tool.  It creates a tedit class object when the user */
/* is done dragging the selection for the size desired.                       */
/*                                                                            */
/* The Once a text object window exist, it is either cancelled or placed      */
/* according to the following rules.                                          */
/*                                                                            */
/* Cancel Rules                                                               */
/* - During a Drag, if the user drags more than MAX_MOVE_DIST_FOR_PLACE       */
/* - At the End of a Drag, if the user lets up the mouse more than            */
/*      MAX_MOVE_DIST_FOR_PLACE pixels from where they did the mosue down     */
/* - If the user selects anohter tool (in imgtools, select processing, see    */
/*      CImgTool::Select()).                                                  */
/*                                                                            */
/* Place Rules                                                                */
/* - At the End of a Drag, if the user lets up the mouse less than or equal   */
/*      to MAX_MOVE_DIST_FOR_PLACE pixels from where they did the mosue down  */
/*                                                                            */
/* Also, during the time the edit control object is visible/exists, the scroll*/
/* bars are disabled.                                                         */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "docking.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "pictures.h"
#include "tfont.h"
#include "tedit.h"
#include "t_Text.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CTextTool, CSelectTool )

#include "memtrace.h"

CTextTool NEAR g_TextTool;

/******************************************************************************/

CTextTool::CTextTool()
    {
    m_nCmdID         = IDMX_TEXTTOOL;
    m_pCTedit        = NULL;
    m_bIsUndoable    = TRUE;
    m_bCanBePrevTool = FALSE;
    }

/******************************************************************************/

CTextTool::~CTextTool()
    {
    }

/******************************************************************************/
/* Creates the CTedit class object with the appropriate attributes and        */
/* dissables the scroll bars on the bitmap window                             */

void CTextTool::CreateTextEditObject( CImgWnd* pImgWnd, MTI* pmti )
    {
    c_selectRect.SetRect( 0, 0, 0, 0 );

    if (pImgWnd         == NULL
    ||  pImgWnd->m_pImg == NULL)
        return;

    BOOL  bBackTransparent;
    CRect cRectTextBox;

    if (pmti->ptDown.x > pmti->pt.x)
        {
        cRectTextBox.left  = pmti->pt.x;
        cRectTextBox.right = pmti->ptDown.x;
        }
    else
        {
        cRectTextBox.left  = pmti->ptDown.x;
        cRectTextBox.right = pmti->pt.x;
        }

    if (pmti->ptDown.y > pmti->pt.y)
        {
        cRectTextBox.top    = pmti->pt.y;
        cRectTextBox.bottom = pmti->ptDown.y;
        }
    else
        {
        cRectTextBox.top    = pmti->ptDown.y;
        cRectTextBox.bottom = pmti->pt.y;
        }

    if (cRectTextBox.left   < 0)
        cRectTextBox.left   = 0;
    if (cRectTextBox.top    < 0)
        cRectTextBox.top    = 0;
    if (cRectTextBox.right  > pImgWnd->m_pImg->cxWidth  - 1)
        cRectTextBox.right  = pImgWnd->m_pImg->cxWidth  - 1;
    if (cRectTextBox.bottom > pImgWnd->m_pImg->cyHeight - 1)
        cRectTextBox.bottom = pImgWnd->m_pImg->cyHeight - 1;

    CRect rectImg;

    pImgWnd->GetClientRect( &rectImg );
    pImgWnd->ClientToImage(  rectImg );

    if (cRectTextBox.left   < rectImg.left)
        cRectTextBox.left   = rectImg.left;
    if (cRectTextBox.top    < rectImg.top )
        cRectTextBox.top    = rectImg.top;
    if (cRectTextBox.right  > rectImg.right)
        cRectTextBox.right  = rectImg.right - 1;
    if (cRectTextBox.bottom > rectImg.bottom)
        cRectTextBox.bottom = rectImg.bottom -1;

    bBackTransparent = ! theImgBrush.m_bOpaque;

    pImgWnd->ImageToClient( cRectTextBox );

    m_pCTedit = new CTedit;

    if (m_pCTedit != NULL
    &&  m_pCTedit->Create( pImgWnd, crLeft, crRight, cRectTextBox, bBackTransparent ))
        {
        SetupRubber( pImgWnd->m_pImg );

        pImgWnd->EnableScrollBar( SB_BOTH, ESB_DISABLE_BOTH );
        }
    else
        {
        TRACE( TEXT("Create Edit Window Failed!\n") );

        theApp.SetMemoryEmergency();
        }
    }

/******************************************************************************/
/* Places the image of the text edit control on the bitmap                    */
/* Then it deletes the text edit control, and re-enables the scroll bars      */

void CTextTool::PlaceTextOnBitmap( CImgWnd* pImgWnd )
    {
    if (m_pCTedit->IsModified())
        {
        CRect cRectClient;
        CDC*  pDC = CDC::FromHandle(pImgWnd->m_pImg->hDC);

        m_pCTedit->GetClientRect ( &cRectClient );
        m_pCTedit->ClientToScreen( &cRectClient );
        pImgWnd->ScreenToClient  ( &cRectClient );
        pImgWnd->ClientToImage   (  cRectClient );
        m_pCTedit->GetBitmap( pDC, &cRectClient );

        InvalImgRect ( pImgWnd->m_pImg, &cRectClient );
        CommitImgRect( pImgWnd->m_pImg, &cRectClient );

        pImgWnd->FinishUndo( cRectClient );

        DirtyImg( pImgWnd->m_pImg );
        }
    m_pCTedit->DestroyWindow();
    m_pCTedit = NULL;

    pImgWnd->EnableScrollBar( SB_BOTH, ESB_ENABLE_BOTH );
    }

/******************************************************************************/
/* updates the foreground and background colors                               */

void CTextTool::OnUpdateColors( CImgWnd* pImgWnd )
    {
    if (m_pCTedit != NULL)
        {
        m_pCTedit->SetTextColor( crLeft  );
        m_pCTedit->SetBackColor( crRight );
        }
    }

/******************************************************************************/

void CTextTool::OnActivate( BOOL bActivate )
    {
    if (bActivate)
        {
                // Disallow activation if Zoomed.
        if (CImgWnd::GetCurrent()->GetZoom() > 1 )
            {
            ::MessageBeep( MB_ICONASTERISK );

                        SelectPrevious();
            }
        }
    else
        {
        if (CWnd::GetCapture() != CImgWnd::c_pImgWndCur && m_pCTedit != NULL &&
                IsWindow(m_pCTedit->m_hWnd) )
            {
            CAttrEdit* pEdit = m_pCTedit->GetEditWindow();

            if (pEdit != NULL && IsWindow(pEdit->m_hWnd) && pEdit->GetWindowTextLength() > 0)
                PlaceTextOnBitmap( CImgWnd::c_pImgWndCur );
            else
                {
                m_pCTedit->DestroyWindow();
                m_pCTedit = NULL;
                InvalImgRect( CImgWnd::c_pImgWndCur->m_pImg, NULL ); // redraw selection

                CImgWnd::c_pImgWndCur->EnableScrollBar( SB_BOTH, ESB_ENABLE_BOTH );
                }
            }
        }
    CImgTool::OnActivate( bActivate );
    }

/******************************************************************************/
/* Deletes the text edit control, and refreshes the bitmap display, while     */
/* also re-enabling the scroll bars                                           */

void CTextTool::OnCancel(CImgWnd* pImgWnd)
    {
    if (m_pCTedit != NULL)
        {
        m_pCTedit->DestroyWindow();
        m_pCTedit = NULL;
        }

    InvalImgRect( pImgWnd->m_pImg, NULL );  // redraw selection

    pImgWnd->EnableScrollBar( SB_BOTH, ESB_ENABLE_BOTH );

    CImgTool::OnCancel( pImgWnd );
    }

/******************************************************************************/

void CTextTool::OnStartDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    CImgTool::OnStartDrag( pImgWnd, pmti );
    OnDrag( pImgWnd, pmti );
    }

/******************************************************************************/
/* if a text edit object does not exist, it creates one here.  If one does    */
/* exist, it checks the distance between the point down and point up.  If     */
/* less than or equal to MAX_MOVE_DIST_FOR_PLACE it places the bitmap, else   */
/* it assumes the user wants to abort the prior text editing session, and     */
/* destroys the prior text edit control and creates a new one with the newly  */
/* created dragged coordinate box (ptdown and ptup).                          */

void CTextTool::OnEndDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    CSize cPtDownUpDistance = pmti->ptDown - pmti->pt;

    // if the text box exists on a button up, was the button up close enough
    // to the button down to decide to place instead of throw away and
    // create a new text edit box.
    if (m_pCTedit != NULL)
        {
        PlaceTextOnBitmap( pImgWnd );

        int iDist = max( (abs( cPtDownUpDistance.cx )),
                         (abs( cPtDownUpDistance.cy )) );

        if (iDist <= MAX_MOVE_DIST_FOR_PLACE)
            {
            ClearStatusBarSize();
            CImgTool::OnEndDrag( pImgWnd, pmti );
            }
        else
            CreateTextEditObject( pImgWnd, pmti );
        }
    else // m_pCTedit == NULL either 1st time or destroyed, since on drag moved more than MAX_MOVE_DIS_FOR_PLACE
        {
        CreateTextEditObject( pImgWnd, pmti );
        }
    }

/******************************************************************************/

void CTextTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    CPoint ptNew( pmti->pt.x, pmti->pt.y );
    CRect rectImg;

    pImgWnd->GetClientRect( &rectImg );
    pImgWnd->ClientToImage(  rectImg );

    if (! rectImg.PtInRect( ptNew ))
        {
        if (ptNew.x < rectImg.left)
            ptNew.x = rectImg.left;
        if (ptNew.x > rectImg.right)
            ptNew.x = rectImg.right;
        if (ptNew.y < rectImg.top)
            ptNew.y = rectImg.top;
        if (ptNew.y > rectImg.bottom)
            ptNew.y = rectImg.bottom;

        pmti->pt = ptNew;
        }
    CSelectTool::OnDrag( pImgWnd, pmti );
    }

/******************************************************************************/
/* Set the text edit tool  window's options for transparent or opaque         */

void CTextTool::OnClickOptions( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint )
    {
    CSelectTool::OnClickOptions( pWnd, optionsRect, clickPoint );

    if (m_pCTedit != NULL)
        m_pCTedit->SetTransparentMode( ! theImgBrush.m_bOpaque );
    }

/******************************************************************************/
/* report to the rest of the program if the font palette is showin            */

BOOL CTextTool::FontPaletteVisible()
    {
    return (m_pCTedit? m_pCTedit->IsFontPaletteVisible(): FALSE);
    }

/******************************************************************************/
/* toggle the visable state of the Font Palette                               */

void CTextTool::ToggleFontPalette()
    {
    if (m_pCTedit)
        m_pCTedit->ShowFontPalette( m_pCTedit->IsFontPaletteVisible()? SW_HIDE: SW_SHOW );
    }

/******************************************************************************/

void CTextTool::OnShowControlBars(BOOL bShow)
{
        if (m_pCTedit == NULL)
        {
                return;
        }

        if (bShow)
        {
                if (!theApp.m_bShowTextToolbar)
                {
                        return;
                }

                m_pCTedit->ShowFontToolbar();
        }
        else
        {
                m_pCTedit->HideFontToolbar();
        }
}

/******************************************************************************/

void CTextTool::CloseTextTool( CImgWnd* pImgWnd )
    {
    if (! m_pCTedit)
        return;

        if ( IsWindow(pImgWnd->m_hWnd) )
                {
            if (! m_pCTedit->IsModified())
                {
                OnCancel( pImgWnd );
                return;
                }

            if (pRubberImg != pImgWnd->m_pImg)
                SetupRubber( pImgWnd->m_pImg );

                //  SetUndo( pImgWnd->m_pImg );

            PlaceTextOnBitmap( pImgWnd );

            pImgWnd->UpdateWindow();
                }
    }

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\t_text.h ===
#ifndef __T_TEXT_H__
#define __T_TEXT_H__

#include "imgtools.h"

#define MAX_MOVE_DIST_FOR_PLACE 10 // min pixels to move before not considered a place operation

class CTextTool : public CSelectTool
    {
    DECLARE_DYNAMIC( CTextTool )

    protected:

    class CTedit* m_pCTedit;

    void CreateTextEditObject( CImgWnd* pImgWnd, MTI* pmti );
    void PlaceTextOnBitmap   ( CImgWnd* pImgWnd );

    public:

    CTextTool();
    ~CTextTool();

    virtual void OnUpdateColors( CImgWnd* pImgWnd );
    virtual void OnActivate    ( BOOL bActivate );
    virtual void OnCancel      ( CImgWnd* pImgWnd );
    virtual void OnStartDrag   ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnEndDrag     ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnDrag        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnClickOptions( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                    const CPoint& clickPoint );
    virtual void OnShowControlBars(BOOL bShow);

    BOOL    IsSlectionVisible () { return ( m_pCTedit != NULL ); }
    CTedit* GetTextEditField  () { return m_pCTedit; }
    BOOL    FontPaletteVisible();
    void    ToggleFontPalette ();
    void    CloseTextTool     ( CImgWnd* pImgWnd );
    };

#endif // __T_TEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\undo.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "bmobject.h"
#include "undo.h"
#include "props.h"
#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CUndoBmObj, CBitmapObj)

#include "memtrace.h"

CUndoBmObj NEAR theUndo;

static BOOL m_bFlushAtEnd;

/////////////////////////////////////////////////////////////////////////////
//
// A CBmObjSequence is a packed array of slob property changes or custom
// actions.  Each record contains a property or action id, a pointer to
// a slob, a property type, and a value (depending on the type).
//
// These sequences are used to store undo/redo information in theUndo.
// Each undo/redo-able thing is contained in one CBmObjSequence.
//


CBmObjSequence::CBmObjSequence() : CByteArray(), m_strDescription()
    {
    SetSize(0, 100); // increase growth rate
    m_nCursor = 0;
    }

CBmObjSequence::~CBmObjSequence()
    {
    Cleanup();
    }

// Pull an array of bytes out of the sequence.
//
void CBmObjSequence::Retrieve( BYTE* rgb, int cb )
    {
    for (int ib = 0; ib < cb; ib += 1)
        *rgb++ = GetAt(m_nCursor++);
    }

// Pull a string out the sequence.

void CBmObjSequence::RetrieveStr( CString& str )
    {
    int nStrLen;
    RetrieveInt(nStrLen);
    if (nStrLen == 0)
        {
        str.Empty();
        }
    else
        {
        BYTE* pb = (BYTE*)str.GetBufferSetLength(nStrLen);
        for (int nByte = 0; nByte < nStrLen; nByte += 1)
            *pb++ = GetAt(m_nCursor++);
        str.ReleaseBuffer(nStrLen);
        }
    }

// Traverse the sequence and remove any slobs that are contained within.
//
void CBmObjSequence::Cleanup()
    {
    m_nCursor = 0;

    while (m_nCursor < GetSize())
        {
        BYTE op;
        CBitmapObj* pSlob;
        int nPropID;

        RetrieveByte(op);

        RetrievePtr(pSlob);
        RetrieveInt(nPropID);

        switch (op)
            {
            default:
                TRACE1("Illegal undo opcode (%d)\n", op);
                ASSERT(FALSE);

            case CUndoBmObj::opAction:
                {
                int cbUndoRecord;
                RetrieveInt(cbUndoRecord);
                int ib = m_nCursor;
                pSlob->DeleteUndoAction(this, nPropID);
                m_nCursor = ib + cbUndoRecord;
                }
                break;

            case CUndoBmObj::opIntProp:
            case CUndoBmObj::opBoolProp:
                {
                int val;
                RetrieveInt(val);
                }
                break;

            case CUndoBmObj::opLongProp:
                {
                long val;
                RetrieveLong(val);
                }
                break;

            case CUndoBmObj::opDoubleProp:
                {
                double num;
                RetrieveNum(num);
                }
                break;

            case CUndoBmObj::opStrProp:
                {
                CString str;
                RetrieveStr(str);
                }
                break;

            case CUndoBmObj::opSlobProp:
                {
                CBitmapObj* pSlobVal;
                RetrievePtr(pSlobVal);
                }
                break;

            case CUndoBmObj::opRectProp:
                {
                CRect rcVal;
                RetrieveRect(rcVal);
                }
                break;

            case CUndoBmObj::opPointProp:
                {
                CPoint ptVal;
                RetrievePoint(ptVal);
                }
                break;
            }
        }
    }


// Start looking right after the begin op for ops we really need to keep.
// If none are found, the entire record is discarded below.  (For now, we
// only throw away records that are empty or consist only of selection
// change ops.)
//
BOOL CBmObjSequence::IsUseful(CBitmapObj*& pLastSlob, int& nLastPropID)
    {
    m_nCursor = 0;
    while (m_nCursor < GetSize() && GetAt(m_nCursor) == CUndoBmObj::opAction)
        {
        BYTE op;
        int nAction, cbActionRecord;
        CBitmapObj* pSlob;

        RetrieveByte(op);
        ASSERT(op == CUndoBmObj::opAction);
        RetrievePtr(pSlob);
        RetrieveInt(nAction);
        RetrieveInt(cbActionRecord);

        if (nAction != A_PreSel && nAction != A_PostSel)
            {
            // Back cursor up to the opcode...
            m_nCursor -= sizeof (int) * 2 + sizeof (CBitmapObj*) + 1;
            break;
            }

        m_nCursor += cbActionRecord;
        }

    if (m_nCursor == GetSize())
        return FALSE; // sequnce consists only of selection changes


    // Now check if we should throw this away because it's just
    // modifying the same string or rectangle property as the last
    // undoable operation...  This is an incredible hack to implement
    // a "poor man's" Multiple-Consecutive-Changes-to-a-Property-as-
    // One-Operation feature.

    BYTE op;
    RetrieveByte(op);

    if (op == CUndoBmObj::opStrProp || op == CUndoBmObj::opRectProp)
        {
        CBitmapObj* pSlob;
        int nPropID;

        RetrievePtr(pSlob);
        RetrieveInt(nPropID);

        nLastPropID = nPropID;
        pLastSlob = pSlob;
        }

    m_nCursor = 0;
    return TRUE;
    }


// Perform the property changes and actions listed in the sequence.
//
void CBmObjSequence::Apply()
    {
    m_nCursor = 0;
    while (m_nCursor < GetSize())
        {
        BYTE op;
        CBitmapObj* pSlob;
        int nPropID;

        RetrieveByte(op);
        RetrievePtr(pSlob);
        RetrieveInt(nPropID);

        switch (op)
            {
            default:
                TRACE1("Illegal undo opcode (%d)\n", op);
                ASSERT(FALSE);

            case CUndoBmObj::opAction:
                pSlob->UndoAction(this, nPropID);
                break;

            case CUndoBmObj::opIntProp:
            case CUndoBmObj::opBoolProp:
                {
                int val;
                RetrieveInt(val);
                pSlob->SetIntProp(nPropID, val);
                }
                break;
            }
        }
    }

/////////////////////////////////////////////////////////////////////////////



CUndoBmObj::CUndoBmObj() : m_seqs()
    {
    ASSERT(this == &theUndo); // only one of these is allowed!

    m_nRecording = 0;
    m_cbUndo = 0;
    m_nMaxLevels = 2;
    m_pLastSlob = NULL;
    m_nLastPropID = 0;
    m_nPauseLevel = 0;
    m_nRedoSeqs = 0;
    }


CUndoBmObj::~CUndoBmObj()
    {
    Flush();
    }


// Set the maximum number of sequences that can be held at once.
//
void CUndoBmObj::SetMaxLevels(int nLevels)
    {
    if (nLevels < 1)
        return;

    m_nMaxLevels = nLevels;
    Truncate();
    }


// Returns the maximum number of sequences that can be held at once.
//
int CUndoBmObj::GetMaxLevels() const
    {
    return m_nMaxLevels;
    }


// Call this to after a sequence is recorded to prevent the next
// sequence from being coalesced with it.
//
void CUndoBmObj::FlushLast()
    {
    m_pLastSlob = NULL;
    m_nLastPropID = 0;
    }


// Call this at the start of an undoable user action.  Calls may be nested
// as long as each call to BeginUndo is balanced with a call to EndUndo.
// Only the "outermost" calls actually have any affect on the undo buffer.
//
// The szCmd parameter should contain the text that you want to appear
// after "Undo" in the Edit menu.
//
// The bResetCursor parameter is only used internally to modify behaviour
// when recording redo sequences and you should NOT pass anything for this
// parameter.
//
void CUndoBmObj::BeginUndo(const TCHAR* szCmd, BOOL bResetCursor)
    {
#ifdef _DEBUG
    if (theApp.m_bLogUndo)
        TRACE2("BeginUndo: %s (%d)\n", szCmd, m_nRecording);
#endif

    // Handle nesting
    m_nRecording += 1;
    if (m_nRecording != 1)
        return;

    if (bResetCursor) // this is the default case
        {
        // Disable Redo for non-Undo/Redo commands...
        while (m_nRedoSeqs > 0)
            {
            delete m_seqs.GetHead();
            m_seqs.RemoveHead();
            m_nRedoSeqs -= 1;
            }
        }

    m_pCurSeq = new CBmObjSequence;
    m_pCurSeq->m_strDescription = szCmd;

    m_bFlushAtEnd = FALSE;
    }

// In most cases, this overloaded function will be called.  It takes a
// resource ID instead of a char*, allowing easier internationalization
//
void CUndoBmObj::BeginUndo(const UINT idCmd, BOOL bResetCursor)
    {
    CString strCmd;
    VERIFY(strCmd.LoadString(idCmd));

    BeginUndo(strCmd, bResetCursor);
    }


// Call this at the end of an undoable user action to cause the sequence
// since the BeginUndo to be stored in the undo buffer.
//
void CUndoBmObj::EndUndo()
    {
#ifdef _DEBUG
    if (theApp.m_bLogUndo)
        TRACE1("EndUndo: %d\n", m_nRecording - 1);
#endif

    ASSERT(m_nRecording > 0);

    // Handle nesting
    m_nRecording -= 1;
    if (m_nRecording != 0)
        return;

    if (!m_pCurSeq->IsUseful(m_pLastSlob, m_nLastPropID))
        {
        // Remove empty or otherwise useless undo records!
        delete m_pCurSeq;
        m_pCurSeq = NULL;
        return;
        }

    // We'll keep it, add it to the list...
    if (m_nRedoSeqs > 0)
        {
        // Add AFTER any redo sequences we have but before any undo's
        POSITION pos = m_seqs.FindIndex(m_nRedoSeqs - 1);
        ASSERT(pos != NULL);
        m_seqs.InsertAfter(pos, m_pCurSeq);
        }
    else
        {
        // Just add before any other undo sequences
        m_seqs.AddHead(m_pCurSeq);
        }
    m_pCurSeq = NULL;

    Truncate(); // Make sure the undo buffer doesn't get too big!

    if (m_bFlushAtEnd)
        Flush();
    }


// This functions ensures there aren't too many levels in the buffer.
//
void CUndoBmObj::Truncate()
    {
    POSITION pos = m_seqs.FindIndex(m_nRedoSeqs + m_nMaxLevels);
    while (pos != NULL)
        {
#ifdef _DEBUG
    if (theApp.m_bLogUndo)
        TRACE(TEXT("Undo record fell off the edge...\n"));
#endif
        POSITION posRemove = pos;
        delete m_seqs.GetNext(pos);
        m_seqs.RemoveAt(posRemove);
        }
    }


// Call this to perform an undo command.
//
void CUndoBmObj::DoUndo()
    {
    CWaitCursor waitCursor;

    if (m_nRedoSeqs == m_seqs.GetCount())
        return; // nothing to undo!

    m_bPerformingUndoRedo = TRUE;

    POSITION pos = m_seqs.FindIndex(m_nRedoSeqs);
    ASSERT(pos != NULL);
    CBmObjSequence* pSeq = (CBmObjSequence*)m_seqs.GetAt(pos);

    BeginUndo(pSeq->m_strDescription, FALSE); // Setup Redo

    // Remove this sequence after BeginUndo so the one inserted
    // there goes to the right place...
    m_seqs.RemoveAt(pos);

    pSeq->Apply();

    FlushLast();
    EndUndo();
    FlushLast();

    m_bPerformingUndoRedo = FALSE;

    delete pSeq;

    // Do not bump the redo count if the undo flushed the buffer!  (This
    // happens when a resource is pasted/dropped, then opened, then a
    // property in it changes, and the user undoes back to before the
    // paste.)
    if (m_seqs.GetCount() != 0)
        m_nRedoSeqs += 1;


    }


// Call this to perform a redo command.
//
void CUndoBmObj::DoRedo()
    {
    if (m_nRedoSeqs == 0)
        return; // nothing in redo buffer

    m_nRedoSeqs -= 1;
    DoUndo();

    // Do not drop the redo count if the undo flushed the buffer!  (This
    // happens when a resource is pasted/dropped, then opened, then a
    // property in it changes, and the user undoes back to before the
    // paste.)
    if (m_seqs.GetCount() != 0)
        m_nRedoSeqs -= 1;
    }


// Generate a string appropriate for the undo menu command.
//
void CUndoBmObj::GetUndoString(CString& strUndo)
    {
    static CString NEAR strUndoTemplate;

    if (strUndoTemplate.IsEmpty())
        VERIFY(strUndoTemplate.LoadString(IDS_UNDO));

    CString strUndoCmd;

    if (CanUndo())
        {
        POSITION pos = m_seqs.FindIndex(m_nRedoSeqs);
        strUndoCmd = ((CBmObjSequence*)m_seqs.GetAt(pos))->m_strDescription;
        }

    int cchUndo = strUndoTemplate.GetLength() - 2; // less 2 for "%s"
    wsprintf(strUndo.GetBufferSetLength(cchUndo + strUndoCmd.GetLength()),
             strUndoTemplate, (const TCHAR*)strUndoCmd);
    }


// Generate a string appropriate for the redo menu command.
//
void CUndoBmObj::GetRedoString(CString& strRedo)
    {
    static CString NEAR strRedoTemplate;

    if (strRedoTemplate.IsEmpty())
        VERIFY(strRedoTemplate.LoadString(IDS_REDO));

    CString strRedoCmd;

    if (CanRedo())
        {
        POSITION pos = m_seqs.FindIndex(m_nRedoSeqs - 1);
        strRedoCmd = ((CBmObjSequence*)m_seqs.GetAt(pos))->m_strDescription;
        }

    int cchRedo = strRedoTemplate.GetLength() - 2; // less 2 for "%s"
    wsprintf(strRedo.GetBufferSetLength(cchRedo + strRedoCmd.GetLength()),
        strRedoTemplate, (const TCHAR*)strRedoCmd);
    }


// Call this to completely empty the undo buffer.
//
void CUndoBmObj::Flush()
    {
    PreTerminateList(&m_seqs);

    m_cbUndo = 0;
    m_nRedoSeqs = 0;

    m_bFlushAtEnd = TRUE;
    }


void CUndoBmObj::OnInform(CBitmapObj* pChangedSlob, UINT idChange)
    {
    if (idChange == SN_DESTROY)
        {
        // When a slob we have a reference to is deleted (for real), we
        // have no choice but to flush the whole buffer...  This normally
        // only happens when a resource editor window is closed...  (If
        // the slob's container is the undo buffer, then we are already
        // in the process of flushing, so don't recurse!)

        Flush();
        }

    CBitmapObj::OnInform(pChangedSlob, idChange);
    }


//
// The following functions are used by the CBitmapObj code to insert commands
// into the undo/redo sequence currently being recorded.  All of the On...
// functions are used to record changes to the various types of properties
// and are called by the CBitmapObj::Set...Prop functions exclusively.
//


// Insert an array of bytes.
//
UINT CUndoBmObj::Insert(const void* pv, int cb)
    {
    ASSERT(m_pCurSeq != NULL);

    BYTE* rgb = (BYTE*)pv;

    m_pCurSeq->InsertAt(0, 0, cb);

    for (int ib = 0; ib < cb; ib += 1)
        m_pCurSeq->SetAt(ib, *rgb++);

    return cb;
    }


// Insert a string.
//
UINT CUndoBmObj::InsertStr(const TCHAR* sz)
    {
    ASSERT(m_pCurSeq != NULL);

    BYTE* pb = (BYTE*)sz;
    int nStrLen = lstrlen(sz);

    InsertInt(nStrLen);
    if (nStrLen > 0)
        {
        m_pCurSeq->InsertAt(sizeof (int), 0, nStrLen);
        for (int nByte = 0; nByte < nStrLen; nByte += 1)
            m_pCurSeq->SetAt(sizeof (int) + nByte, *pb++);
        }
    return nStrLen + sizeof (int);
    }


void CUndoBmObj::OnSetIntProp(CBitmapObj* pChangedSlob, UINT nPropID, UINT nOldVal)
        {
    ASSERT(m_nRecording != 0);

    CIntUndoRecord undoRecord;
    undoRecord.m_op = opIntProp;
    undoRecord.m_pBitmapObj = pChangedSlob;
    undoRecord.m_nPropID = nPropID;
    undoRecord.m_nOldVal = nOldVal;
    Insert(&undoRecord, sizeof (undoRecord));
    pChangedSlob->AddDependant(this);
    }

#ifdef _DEBUG

/////////////////////////////////////////////////////////////////////////////
//
// Undo related debugging aids
//

void CBmObjSequence::Dump()
    {
    m_nCursor = 0;
    while (m_nCursor < GetSize())
        {
        BYTE op;
        CBitmapObj* pSlob;
        int nPropID;

        RetrieveByte(op);
        RetrievePtr(pSlob);
        RetrieveInt(nPropID);

        switch (op)
            {
        default:
            TRACE1("Illegal undo opcode (%d)\n", op);
            ASSERT(FALSE);

        case CUndoBmObj::opAction:
                {
                int cbUndoRecord;
                RetrieveInt(cbUndoRecord);
                m_nCursor += cbUndoRecord;

                TRACE3("opAction: pSlob = 0x%08lx, nActionID = %d, "
                    TEXT("nBytes = %d\n"), pSlob, nPropID, cbUndoRecord);
                }
            break;

        case CUndoBmObj::opIntProp:
        case CUndoBmObj::opBoolProp:
                {
                int val;
                RetrieveInt(val);
                TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, val = %d\n",
                    pSlob, nPropID, val);
                }
            break;

        case CUndoBmObj::opLongProp:
                {
                long val;
                RetrieveLong(val);
                TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, val = %ld\n",
                    pSlob, nPropID, val);
                }
            break;

        case CUndoBmObj::opDoubleProp:
                {
                double num;
                RetrieveNum(num);
                TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, val = %f\n",
                    pSlob, nPropID, num);
                }
            break;

        case CUndoBmObj::opStrProp:
                {
                CString str;
                RetrieveStr(str);
                if (str.GetLength() > 80)
                    {
                    str = str.Left(80);
                    str += TEXT("...");
                    }
                TRACE3("opStr: pSlob = 0x%08lx, nPropID = %d, val = %s\n",
                    pSlob, nPropID, (const TCHAR*)str);
                }
            break;

        case CUndoBmObj::opSlobProp:
                {
                CBitmapObj* pSlobVal;
                RetrievePtr(pSlobVal);
                TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, "
                    TEXT("val = 0x%08lx\n"), pSlob, nPropID, pSlobVal);
                }
            break;

        case CUndoBmObj::opRectProp:
                {
                CRect rcVal;
                RetrieveRect(rcVal);
                TRACE3("opRect: pSlob = 0x%08lx, nPropID = %d, "
                    TEXT("val = %d,%d,%d,%d\n"), pSlob, nPropID, rcVal);
                }
            break;

        case CUndoBmObj::opPointProp:
                {
                CPoint ptVal;
                RetrievePoint(ptVal);
                TRACE3("opPoint: pSlob = 0x%08lx, nPropID = %d, "
                    TEXT("val = %d,%d,%d,%d\n"), pSlob, nPropID, ptVal);
                }
            break;
            }
        }
    }


void CUndoBmObj::Dump()
    {
    int nRecord = 0;
    POSITION pos = m_seqs.GetHeadPosition();
    while (pos != NULL)
        {
        CBmObjSequence* pSeq = (CBmObjSequence*)m_seqs.GetNext(pos);
        TRACE2("Record (%d) %s:\n", nRecord,
            nRecord < m_nRedoSeqs ? TEXT("redo") : TEXT("undo"));
        pSeq->Dump();
        nRecord += 1;
        }
    }


extern "C" void DumpUndo()
    {
    theUndo.Dump();
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\cntritem.cpp ===
// cntritem.cpp : implementation of the CNetClipCntrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//
// FEATURE: This class is probably not needed.  Just use
// CRichEditCntrItem direclty instead.

#include "stdafx.h"
#include "netclipapp.h"

#include "doc.h"
#include "View.h"
#include "cntritem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetClipCntrItem implementation

IMPLEMENT_SERIAL(CNetClipCntrItem, CRichEditCntrItem, 0)

CNetClipCntrItem::CNetClipCntrItem(REOBJECT *preo, CNetClipDoc* pContainer)
	: CRichEditCntrItem(preo, pContainer)
{
}

/////////////////////////////////////////////////////////////////////////////
// CNetClipCntrItem diagnostics

#ifdef _DEBUG
void CNetClipCntrItem::AssertValid() const
{
	CRichEditCntrItem::AssertValid();
}

void CNetClipCntrItem::Dump(CDumpContext& dc) const
{
	CRichEditCntrItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\dataobj.h ===
// GenericDataObject.h : header file
//

// Note: the following interface is not an actual OLE interface, but is useful
//  for describing an abstract (not typesafe) enumerator.

// Stolen from MFC 4.0 (OLEIMPL2.H)
#undef  INTERFACE
#define INTERFACE   IEnumVOID

DECLARE_INTERFACE_(IEnumVOID, IUnknown)
{
	STDMETHOD(QueryInterface)(REFIID, LPVOID*) PURE;
	STDMETHOD_(ULONG,AddRef)()  PURE;
	STDMETHOD_(ULONG,Release)() PURE;
	STDMETHOD(Next)(ULONG, void*, ULONG*) PURE;
	STDMETHOD(Skip)(ULONG) PURE;
	STDMETHOD(Reset)() PURE;
	STDMETHOD(Clone)(IEnumVOID**) PURE;
};

// Stolen from MFC 4.0 (OLEIMPL2.H)
class CEnumArray : public CCmdTarget
{
// Constructors
public:
	CEnumArray(size_t nSize,
		const void* pvEnum, UINT nCount, BOOL bNeedFree = FALSE);

// Implementation
public:
	virtual ~CEnumArray();

protected:
	size_t m_nSizeElem;     // size of each item in the array
	CCmdTarget* m_pClonedFrom;  // used to keep original alive for clones

	BYTE* m_pvEnum;     // pointer data to enumerate
	UINT m_nCurPos;     // current position in m_pvEnum
	UINT m_nSize;       // total number of items in m_pvEnum
	BOOL m_bNeedFree;   // free on release?

	virtual BOOL OnNext(void* pv);
	virtual BOOL OnSkip();
	virtual void OnReset();
	virtual CEnumArray* OnClone();

// Interface Maps
public:
	BEGIN_INTERFACE_PART(EnumVOID, IEnumVOID)
		INIT_INTERFACE_PART(CEnumArray, EnumVOID)
		STDMETHOD(Next)(ULONG, void*, ULONG*);
		STDMETHOD(Skip)(ULONG);
		STDMETHOD(Reset)();
		STDMETHOD(Clone)(IEnumVOID**);
	END_INTERFACE_PART(EnumVOID)
};


/////////////////////////////////////////////////////////////////////////////
// CGenericDataObject command target

struct _DATACACHE_ENTRY;
class CGenericDataObject : public CCmdTarget
{
public:
    CGenericDataObject(IDataObject* pdo=NULL);

    // Operations
	void Empty();   // empty cache (similar to ::EmptyClipboard)

// Overidables
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);

// Implementation
public:
	virtual ~CGenericDataObject();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	_DATACACHE_ENTRY* m_pDataCache;  // data cache itself
	UINT m_nMaxSize;    // current allocated size
	UINT m_nSize;       // current size of the cache
	UINT m_nGrowBy;     // number of cache elements to grow by for new allocs
    BOOL m_bModified;   // Data was modified since IPersistStorage::Load, Save, or InitNew
    BOOL m_bInitialized;  // IPersistStorage::InitNew was called

	_DATACACHE_ENTRY* Lookup(
		LPFORMATETC lpFormatEtc) const;
	_DATACACHE_ENTRY* GetCacheEntry(
		LPFORMATETC lpFormatEtc);

        // Interface Maps
public:
	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		INIT_INTERFACE_PART(CGenericDataObject, DataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);
	END_INTERFACE_PART(DataObject)

  	BEGIN_INTERFACE_PART(PersistStorage, IPersistStorage)
		INIT_INTERFACE_PART(CGenericDataObject, PersistStorage)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(InitNew)(LPSTORAGE);
		STDMETHOD(Load)(LPSTORAGE);
		STDMETHOD(Save)(LPSTORAGE, BOOL);
		STDMETHOD(SaveCompleted)(LPSTORAGE);
		STDMETHOD(HandsOffStorage)();
	END_INTERFACE_PART(PersistStorage)

	DECLARE_INTERFACE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\mspaint\undo.h ===
#ifndef __UNDO_H__
#define __UNDO_H__


// A CBmObjSequence holds the codes for one undo or redo operation.
class CBmObjSequence : public CByteArray
    {
    public:

     CBmObjSequence();
    ~CBmObjSequence();

    void Retrieve(BYTE* rgb, int cb);
    void RetrieveStr(CString& str);

    inline void RetrieveByte(BYTE& b)     { Retrieve(&b, 1); }
    inline void RetrieveInt(int& n)       { Retrieve((BYTE*)&n  , sizeof (int)); }
    inline void RetrieveLong(long& n)     { Retrieve((BYTE*)&n  , sizeof (long)); }
    inline void RetrieveNum(double& num)  { Retrieve((BYTE*)&num, sizeof (double)); }
    inline void RetrievePtr(CBitmapObj*& ptr)  { Retrieve((BYTE*)&ptr, sizeof (CBitmapObj*)); }
    inline void RetrieveRect(CRect& rc)   { Retrieve((BYTE*)&rc , sizeof (rc)); }
    inline void RetrievePoint(CPoint& pt) { Retrieve((BYTE*)&pt , sizeof (pt)); }

    void Cleanup();
    BOOL IsUseful(CBitmapObj*&, int&);
    void Apply();

    #ifdef _DEBUG
    void Dump();
    #endif

    int m_nCursor;
    CString m_strDescription;
    };


class CUndoBmObj : public CBitmapObj
    {
    DECLARE_DYNAMIC(CUndoBmObj)

    public:
     CUndoBmObj();
    ~CUndoBmObj();

    void BeginUndo(const TCHAR* szCmd, BOOL bResetCursor = TRUE);
    void BeginUndo(const UINT idCmd, BOOL bResetCursor = TRUE);
    void EndUndo();

    inline BOOL CanUndo() const
            { return m_nRedoSeqs < m_seqs.GetCount(); }

    inline BOOL CanRedo() const
            { return m_nRedoSeqs > 0; }

    inline BOOL InUndoRedo() const
            { return m_bPerformingUndoRedo; }

    void GetUndoString(CString& strUndo);
    void GetRedoString(CString& strRedo);

    void DoUndo();
    void DoRedo();

    void SetMaxLevels(int nLevels);
    int  GetMaxLevels() const;

    void OnSetIntProp( CBitmapObj* pChangedSlob, UINT nPropID, UINT nOldVal );

    #ifdef _DEBUG
    void Dump();
    #endif

    inline BOOL IsRecording() { return m_nRecording != 0 && m_nPauseLevel == 0; }

    inline void Pause() { m_nPauseLevel += 1; }

    inline void Resume() { ASSERT(m_nPauseLevel > 0); m_nPauseLevel -= 1; }

    enum
        {
        // Note correspondence with PRD
        opStart,
        opEnd,
        opAction,
        opIntProp,
        opLongProp,
        opBoolProp,
        opDoubleProp,
        opStrProp,
        opSlobProp,
        opRectProp,
        opPointProp
        };

    UINT Insert(const void* rgb, int cb);
    UINT InsertStr(const TCHAR* sz);

    inline UINT InsertByte(BYTE b) { return Insert(&b, 1); }
    inline UINT InsertInt(int n) { return Insert((BYTE*)&n, sizeof (int)); }
    inline UINT InsertLong(long n) { return Insert((BYTE*)&n, sizeof (long)); }
    inline UINT InsertNum(double num) { return Insert((BYTE*)&num, sizeof (double)); }
    inline UINT InsertPtr(const void* ptr)
                {
                if (ptr != NULL)
                    {
                    ASSERT(((CObject*)ptr)->IsKindOf(RUNTIME_CLASS(CBitmapObj)));
                    ((CBitmapObj*)ptr)->AddDependant(this);
                    }
                return Insert((BYTE*)&ptr, sizeof (CBitmapObj*));
                }
    inline UINT InsertRect(const CRect& rc) { return Insert((BYTE*)&rc, sizeof (CRect)); }
    inline UINT InsertPoint(const CPoint& pt) { return Insert((BYTE*)&pt, sizeof (CPoint)); }

    void Flush();

    void OnInform(CBitmapObj* pChangedSlob, UINT idChange);

    void FlushLast();

    private:

    void Truncate();

    int m_nRecording; // BeginUndo() nesting count
    int m_nPauseLevel; // Pause() nesting count

    int m_cbUndo;

    // These ?Last* variables are used to coalesce consecutive changes
    // to the same property...
    CBitmapObj* m_pLastSlob;
    int m_nLastPropID;

    // Properties...
    int m_nMaxLevels;

    CObList m_seqs; // pointers to CBmObjSequences
    int m_nRedoSeqs;
    CBmObjSequence* m_pCurSeq;

    BOOL m_bPerformingUndoRedo;

    friend class CBmObjSequence;
    };


#pragma pack(1)

class CUndoRecord
    {
    public:

    BYTE m_op;
    CBitmapObj* m_pBitmapObj;
    UINT m_nPropID;
    };


class CIntUndoRecord : public CUndoRecord
    {
    public:

    int m_nOldVal;
    };


class CLongUndoRecord : public CUndoRecord
    {
    public:

    long m_nOldVal;
    };


class CDoubleUndoRecord : public CUndoRecord
    {
    public:

    double m_numOldVal;
    };


class CRectUndoRecord : public CUndoRecord
    {
    public:

    CRect m_rectOldVal;
    };


class CPointUndoRecord : public CUndoRecord
    {
    public:

    CPoint m_ptOldVal;
    };


class CBitmapObjUndoRecord : public CUndoRecord
    {
    public:

    const CBitmapObj* m_pOldVal;
    };

#pragma pack()

extern CUndoBmObj NEAR theUndo;

#endif // __UNDO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\cntritem.h ===
// cntritem.h : interface of the CNetClipCntrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CNetClipDoc;
class CPictView;

class CNetClipCntrItem : public CRichEditCntrItem
{
	DECLARE_SERIAL(CNetClipCntrItem)

// Constructors
public:
	CNetClipCntrItem(REOBJECT* preo = NULL, CNetClipDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CNetClipDoc* GetDocument()
		{ return (CNetClipDoc*)COleClientItem::GetDocument(); }
	CPictView* GetActiveView()
		{ return (CPictView*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetClipCntrItem)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\dataobj.cpp ===
// GenericDataObject.cpp : implementation file
//
// This class provides a very generic implementation of IDataObject.
// Call SetData with any FORMATETC and STGMEDIUM and it will cache
// a *copy* and make it available to GetData.
//
// IStream and IStorage based STGMEDIUM's are *copied*. If IStream,
// an IStream on HGLOBAL is created and the source is copied into it.
// if an IStorage, a temp DocFile is created, and the source
// copied into it.
//
// This class is a radical derivation of COleDataSource.
//
#include "stdafx.h"
#include "netclipapp.h"
#include "DataObj.h"
#include "guids.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// CLSID_GenericDataObject = {92436B40-6327-11cf-B63C-0080C792B782}

/////////////////////////////////////////////////////////////////////////////
// CGenericDataObject

// Each time SetData is called for a new format, a new _DATACACHE_ENTRY
// is allocated to the array
struct _DATACACHE_ENTRY
{
	FORMATETC m_formatEtc;
	STGMEDIUM m_stgMedium;
};

DVTARGETDEVICE* CopyTargetDevice(DVTARGETDEVICE* ptdSrc)
{
	if (ptdSrc == NULL)
		return NULL;

	DVTARGETDEVICE* ptdDest =
		(DVTARGETDEVICE*)CoTaskMemAlloc(ptdSrc->tdSize);
	if (ptdDest == NULL)
		return NULL;

	memcpy(ptdDest, ptdSrc, (size_t)ptdSrc->tdSize);
	return ptdDest;
}

void CopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc)
{
	ASSERT(petcDest != NULL);
	ASSERT(petcSrc != NULL);

	petcDest->cfFormat = petcSrc->cfFormat;
	petcDest->ptd = CopyTargetDevice(petcSrc->ptd);
	petcDest->dwAspect = petcSrc->dwAspect;
	petcDest->lindex = petcSrc->lindex;
	petcDest->tymed = petcSrc->tymed;
}

static HGLOBAL CopyGlobalMemory(HGLOBAL hDest, HGLOBAL hSource)
{
	ASSERT(hSource != NULL);

	// make sure we have suitable hDest
	DWORD nSize = (DWORD)::GlobalSize(hSource);
	if (hDest == NULL)
	{
		hDest = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, nSize);
		if (hDest == NULL)
			return NULL;
	}
	else if (nSize > ::GlobalSize(hDest))
	{
		// hDest is not large enough
		return NULL;
	}

	// copy the bits
	LPVOID lpSource = ::GlobalLock(hSource);
	LPVOID lpDest = ::GlobalLock(hDest);
	ASSERT(lpDest != NULL);
	ASSERT(lpSource != NULL);
	memcpy(lpDest, lpSource, nSize);
	::GlobalUnlock(hDest);
	::GlobalUnlock(hSource);

	// success -- return hDest
	return hDest;
}

BOOL CopyStgMedium(
	CLIPFORMAT cfFormat, LPSTGMEDIUM lpDest, LPSTGMEDIUM lpSource)
{
	if (lpDest->tymed == TYMED_NULL)
	{
		ASSERT(lpSource->tymed != TYMED_NULL);
		switch (lpSource->tymed)
		{
		case TYMED_ENHMF:
		case TYMED_HGLOBAL:
			ASSERT(sizeof(HGLOBAL) == sizeof(HENHMETAFILE));
			lpDest->tymed = lpSource->tymed;
			lpDest->hGlobal = NULL;
			break;  // fall through to CopyGlobalMemory case

		case TYMED_ISTREAM:
    		lpDest->tymed = TYMED_ISTREAM;
            lpDest->pstm = NULL;
            CreateStreamOnHGlobal(0, TRUE, &lpDest->pstm);
            ASSERT(lpDest->pstm);
			break ;  // fall through to CopyTo case

		case TYMED_ISTORAGE:
            {
			    lpDest->tymed = TYMED_ISTORAGE;
                lpDest->pstg = NULL;
                HRESULT hr = StgCreateDocfile(NULL,
                        STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_DELETEONRELEASE|STGM_CREATE,
                        0, &lpDest->pstg);
                ASSERT(lpDest->pstg);
                if (FAILED(hr))
                    return FALSE;
            }
            break;// fall through to CopyTo case

		case TYMED_MFPICT:
			{
				// copy LPMETAFILEPICT struct + embedded HMETAFILE
				HGLOBAL hDest = ::CopyGlobalMemory(NULL, lpSource->hGlobal);
				if (hDest == NULL)
					return FALSE;
				LPMETAFILEPICT lpPict = (LPMETAFILEPICT)::GlobalLock(hDest);
				ASSERT(lpPict != NULL);
				lpPict->hMF = ::CopyMetaFile(lpPict->hMF, NULL);
				if (lpPict->hMF == NULL)
				{
					::GlobalUnlock(hDest);
					::GlobalFree(hDest);
					return FALSE;
				}
				::GlobalUnlock(hDest);

				// fill STGMEDIUM struct
				lpDest->hGlobal = hDest;
				lpDest->tymed = TYMED_MFPICT;
			}
			return TRUE;

		case TYMED_GDI:
			lpDest->tymed = TYMED_GDI;
			lpDest->hGlobal = NULL;
			break;

		// unable to create + copy other TYMEDs
		default:
			return FALSE;
		}
	}
	ASSERT(lpDest->tymed == lpSource->tymed);

	switch (lpSource->tymed)
	{
	case TYMED_HGLOBAL:
		{
			HGLOBAL hDest = ::CopyGlobalMemory(lpDest->hGlobal,
				lpSource->hGlobal);
			if (hDest == NULL)
				return FALSE;

			lpDest->hGlobal = hDest;
		}
		return TRUE;

	case TYMED_ISTREAM:
		{
			ASSERT(lpDest->pstm != NULL);
			ASSERT(lpSource->pstm != NULL);

			// get the size of the source stream
			STATSTG stat;
			if (lpSource->pstm->Stat(&stat, STATFLAG_NONAME) != S_OK)
			{
				// unable to get size of source stream
				return FALSE;
			}
			ASSERT(stat.pwcsName == NULL);

			// always seek to zero before copy
			LARGE_INTEGER zero = { 0, 0 };
			lpDest->pstm->Seek(zero, STREAM_SEEK_SET, NULL);
			lpSource->pstm->Seek(zero, STREAM_SEEK_SET, NULL);

			// copy source to destination
			if (lpSource->pstm->CopyTo(lpDest->pstm, stat.cbSize,
				NULL, NULL) != NULL)
			{
				// copy from source to dest failed
				return FALSE;
			}

			// always seek to zero after copy
			lpDest->pstm->Seek(zero, STREAM_SEEK_SET, NULL);
			lpSource->pstm->Seek(zero, STREAM_SEEK_SET, NULL);
		}
		return TRUE;

	case TYMED_ISTORAGE:
		{
			ASSERT(lpDest->pstg != NULL);
			ASSERT(lpSource->pstg != NULL);

			// just copy source to destination
			if (lpSource->pstg->CopyTo(0, NULL, NULL, lpDest->pstg) != S_OK)
				return FALSE;
		}
		return TRUE;

	case TYMED_ENHMF:
	case TYMED_GDI:
		{
			ASSERT(sizeof(HGLOBAL) == sizeof(HENHMETAFILE));

			// with TYMED_GDI cannot copy into existing HANDLE
			if (lpDest->hGlobal != NULL)
				return FALSE;

			// otherwise, use OleDuplicateData for the copy
			lpDest->hGlobal = OleDuplicateData(lpSource->hGlobal, cfFormat, 0);
			if (lpDest->hGlobal == NULL)
				return FALSE;
		}
		return TRUE;

	// other TYMEDs cannot be copied
	default:
		return FALSE;
	}
}


CGenericDataObject::CGenericDataObject(IDataObject* pdoSource)
{
	m_pDataCache = NULL;
	m_nMaxSize = 0;
	m_nSize = 0;
	m_nGrowBy = 10;
    m_bModified = FALSE;
    m_bInitialized = FALSE;

    if (pdoSource == NULL)
        return;

    IDataObject* pdoDest = (IDataObject*)GetInterface(&IID_IDataObject);
    ASSERT(pdoDest);
    ASSERT(pdoSource);

    // For each format copy.
    FORMATETC fetc;
    STGMEDIUM stgm;
    IEnumFORMATETC* penum=NULL;
    HRESULT hr;
    if (SUCCEEDED(hr = pdoSource->EnumFormatEtc(DATADIR_GET, &penum)))
    {
        ULONG ulFetched;
        while (S_OK == penum->Next(1, &fetc, &ulFetched))
        {
            stgm.tymed = fetc.tymed ;
            stgm.hGlobal = NULL;
            stgm.pUnkForRelease = NULL;
            if (SUCCEEDED(hr = pdoSource->GetData(&fetc, &stgm)))
            {
                // Call IDataObject::SetData of our generic dataobject,
                // which will copy the data.  We pass FALSE for fRelease so
                // that the generic dataobject will not try to take
                // ownership, but will copy.
                //
                // We do not test for failure because we don't care. If
                // the copy failed, then there's nothing we can do anyway.
                //
                // fetc.tymed may specify multiple tymeds.  GetData will
                // pick one and return it to us (in stgm).  SetData requires fetc.tymed
                // and stgm.tymed to be equal, so we simply fix up fetc.
                fetc.tymed = stgm.tymed;
                hr = pdoDest->SetData(&fetc, &stgm, FALSE);
#ifdef _DEBUG
                if (FAILED(hr))
                    TRACE(_T("SetData failed. %s"), HRtoString(hr));
#endif
                ReleaseStgMedium(&stgm);
            }
#ifdef _DEBUG
            else
                TRACE(_T("GetData failed. %s"), HRtoString(hr));
#endif

        }
        penum->Release();
    }

    /*
    IInterfaceViewer* piv= NULL;
    hr = CoCreateInstance(CLSID_IDataObjectViewer, NULL, CLSCTX_SERVER, IID_IInterfaceViewer, (void**)&piv);
    if (SUCCEEDED(hr))
    {
        piv->View(AfxGetMainWnd()->GetSafeHwnd(), IID_IDataObject, pdoDest);
        piv->Release();
    }
    else
        ErrorMessage("Could not load viewer.", hr);
    */
}

CGenericDataObject::~CGenericDataObject()
{
    // Go through our internal list releasing everything
	Empty();
}

void CGenericDataObject::Empty()
{
	if (m_pDataCache != NULL)
	{
		ASSERT(m_nMaxSize != 0);
		ASSERT(m_nSize != 0);

		// release all of the STGMEDIUMs and FORMATETCs
		for (UINT nIndex = 0; nIndex < m_nSize; nIndex++)
		{
            if (m_pDataCache[nIndex].m_formatEtc.ptd)
			    CoTaskMemFree(m_pDataCache[nIndex].m_formatEtc.ptd);
			::ReleaseStgMedium(&m_pDataCache[nIndex].m_stgMedium);
		}

		// delete the cache
		delete m_pDataCache;
		m_pDataCache = NULL;
		m_nMaxSize = 0;
		m_nSize = 0;
        m_bModified=TRUE;
	}
	ASSERT(m_pDataCache == NULL);
	ASSERT(m_nMaxSize == 0);
	ASSERT(m_nSize == 0);
}

/////////////////////////////////////////////////////////////////////////////
// CGenericDataObject cache allocation

_DATACACHE_ENTRY* CGenericDataObject::GetCacheEntry(
	LPFORMATETC lpFormatEtc)
{
	_DATACACHE_ENTRY* pEntry = Lookup(lpFormatEtc);
	if (pEntry != NULL)
	{
		// cleanup current entry and return it
        if (pEntry->m_formatEtc.ptd)
		    CoTaskMemFree(pEntry->m_formatEtc.ptd);
		::ReleaseStgMedium(&pEntry->m_stgMedium);
	}
	else
	{
		// allocate space for item at m_nSize (at least room for 1 item)
		if (m_pDataCache == NULL || m_nSize == m_nMaxSize)
		{
			ASSERT(m_nGrowBy != 0);
			_DATACACHE_ENTRY* pCache = new _DATACACHE_ENTRY[m_nMaxSize+m_nGrowBy];
			m_nMaxSize += m_nGrowBy;
			if (m_pDataCache != NULL)
			{
				memcpy(pCache, m_pDataCache, m_nSize * sizeof(_DATACACHE_ENTRY));
				delete[] m_pDataCache;
			}
			m_pDataCache = pCache;
		}
		ASSERT(m_pDataCache != NULL);
		ASSERT(m_nMaxSize != 0);

		pEntry = &m_pDataCache[m_nSize++];
	}

	// fill the cache entry with the format and return it
	pEntry->m_formatEtc = *lpFormatEtc;
    memset(&pEntry->m_stgMedium, 0, sizeof(STGMEDIUM));
	return pEntry;
}

/////////////////////////////////////////////////////////////////////////////
// CGenericDataObject operations

/////////////////////////////////////////////////////////////////////////////
// CGenericDataObject cache implementation

_DATACACHE_ENTRY* CGenericDataObject::Lookup(
	LPFORMATETC lpFormatEtc) const
{
	// look for suitable match to lpFormatEtc in cache
	for (UINT nIndex = 0; nIndex < m_nSize; nIndex++)
	{
		// get entry from cache at nIndex
		_DATACACHE_ENTRY* pCache = &m_pDataCache[nIndex];
		FORMATETC *pCacheFormat = &pCache->m_formatEtc;

		// check for match
		if (pCacheFormat->cfFormat == lpFormatEtc->cfFormat &&
			(pCacheFormat->tymed & lpFormatEtc->tymed) != 0 &&
			pCacheFormat->lindex == lpFormatEtc->lindex &&
			pCacheFormat->dwAspect == lpFormatEtc->dwAspect)
		{
			// return that cache entry
			return pCache;
		}
	}

	return NULL;    // not found
}

// TODO: Determine whether it makes sense to implement this
// function. It's possible that we can provide more formats
// than are specfied by SetData's (e.g. additional stgmediums per format).
BOOL CGenericDataObject::OnRenderData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
    /*
	// attempt TYMED_HGLOBAL as prefered format
	if (lpFormatEtc->tymed & TYMED_HGLOBAL)
	{
		// attempt HGLOBAL delay render hook
		HGLOBAL hGlobal = lpStgMedium->hGlobal;
		if (OnRenderGlobalData(lpFormatEtc, &hGlobal))
		{
			ASSERT(lpStgMedium->tymed != TYMED_HGLOBAL ||
				(lpStgMedium->hGlobal == hGlobal));
			ASSERT(hGlobal != NULL);
			lpStgMedium->tymed = TYMED_HGLOBAL;
			lpStgMedium->hGlobal = hGlobal;
			return TRUE;
		}

		// attempt CFile* based delay render hook
		CSharedFile file;
		if (lpStgMedium->tymed == TYMED_HGLOBAL)
		{
			ASSERT(lpStgMedium->hGlobal != NULL);
			file.SetHandle(lpStgMedium->hGlobal, FALSE);
		}
		if (OnRenderFileData(lpFormatEtc, &file))
		{
			lpStgMedium->tymed = TYMED_HGLOBAL;
			lpStgMedium->hGlobal = file.Detach();
			ASSERT(lpStgMedium->hGlobal != NULL);
			return TRUE;
		}
		if (lpStgMedium->tymed == TYMED_HGLOBAL)
			file.Detach();
	}

	// attempt TYMED_ISTREAM format
	if (lpFormatEtc->tymed & TYMED_ISTREAM)
	{
		COleStreamFile file;
		if (lpStgMedium->tymed == TYMED_ISTREAM)
		{
			ASSERT(lpStgMedium->pstm != NULL);
			file.Attach(lpStgMedium->pstm);
		}
		else
		{
			if (!file.CreateMemoryStream())
				AfxThrowMemoryException();
		}
		// get data into the stream
		if (OnRenderFileData(lpFormatEtc, &file))
		{
			lpStgMedium->tymed = TYMED_ISTREAM;
			lpStgMedium->pstm = file.Detach();
			return TRUE;
		}
		if (lpStgMedium->tymed == TYMED_ISTREAM)
			file.Detach();
	}
*/
	return FALSE;   // default does nothing
}


/////////////////////////////////////////////////////////////////////////////
// CGenericDataObject message handlers


/////////////////////////////////////////////////////////////////////////////
// CEnumFormatEtc - enumerator for array for FORMATETC structures
// Stolen from MFC (OLEPRIV)
class CEnumFormatEtc : public CEnumArray
{
// Constructors
public:
	CEnumFormatEtc();

// Operations
	void AddFormat(const FORMATETC* lpFormatEtc);

// Implementation
public:
	virtual ~CEnumFormatEtc();

protected:
	virtual BOOL OnNext(void* pv);

	UINT m_nMaxSize;    // number of items allocated (>= m_nSize)
	DECLARE_INTERFACE_MAP()
};

BEGIN_INTERFACE_MAP(CEnumFormatEtc, CEnumArray)
	INTERFACE_PART(CEnumFormatEtc, IID_IEnumFORMATETC, EnumVOID)
END_INTERFACE_MAP()

CEnumFormatEtc::CEnumFormatEtc()
	: CEnumArray(sizeof(FORMATETC), NULL, 0, TRUE)
{
	m_nMaxSize = 0;
}

CEnumFormatEtc::~CEnumFormatEtc()
{
	if (m_pClonedFrom == NULL)
	{
		// release all of the pointers to DVTARGETDEVICE
		LPFORMATETC lpFormatEtc = (LPFORMATETC)m_pvEnum;
		for (UINT nIndex = 0; nIndex < m_nSize; nIndex++)
			CoTaskMemFree(lpFormatEtc[nIndex].ptd);
	}
	// destructor will free the actual array (if it was not a clone)
}

BOOL CEnumFormatEtc::OnNext(void* pv)
{
	if (!CEnumArray::OnNext(pv))
		return FALSE;

	// any outgoing formatEtc may require the DVTARGETDEVICE to
	//  be copied (the caller has responsibility to free it)
	LPFORMATETC lpFormatEtc = (LPFORMATETC)pv;
	if (lpFormatEtc->ptd != NULL)
	{
		lpFormatEtc->ptd = CopyTargetDevice(lpFormatEtc->ptd);
		if (lpFormatEtc->ptd == NULL)
			AfxThrowMemoryException();
	}
	// otherwise, copying worked...
	return TRUE;
}

void CEnumFormatEtc::AddFormat(const FORMATETC* lpFormatEtc)
{
	ASSERT(m_nSize <= m_nMaxSize);

	if (m_nSize == m_nMaxSize)
	{
		// not enough space for new item -- allocate more
		FORMATETC* pListNew = new FORMATETC[m_nSize+10];
		m_nMaxSize += 10;
		memcpy(pListNew, m_pvEnum, m_nSize*sizeof(FORMATETC));
		delete m_pvEnum;
		m_pvEnum = (BYTE*)pListNew;
	}

	// add this item to the list
	ASSERT(m_nSize < m_nMaxSize);
	FORMATETC* pFormat = &((FORMATETC*)m_pvEnum)[m_nSize];
	pFormat->cfFormat = lpFormatEtc->cfFormat;
	pFormat->ptd = lpFormatEtc->ptd;
		// Note: ownership of lpFormatEtc->ptd is transfered with this call.
	pFormat->dwAspect = lpFormatEtc->dwAspect;
	pFormat->lindex = lpFormatEtc->lindex;
	pFormat->tymed = lpFormatEtc->tymed;
	++m_nSize;
}

/////////////////////////////////////////////////////////////////////////////
// CGenericDataObject::XDataObject

BEGIN_INTERFACE_MAP(CGenericDataObject, CCmdTarget)
	INTERFACE_PART(CGenericDataObject, IID_IDataObject, DataObject)
	INTERFACE_PART(CGenericDataObject, IID_IPersistStorage, PersistStorage)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) CGenericDataObject::XDataObject::AddRef()
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, DataObject)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CGenericDataObject::XDataObject::Release()
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, DataObject)
	return pThis->ExternalRelease();
}

STDMETHODIMP CGenericDataObject::XDataObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, DataObject)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CGenericDataObject::XDataObject::GetData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	METHOD_PROLOGUE_EX(CGenericDataObject, DataObject)
	ASSERT_VALID(pThis);

	// attempt to find match in the cache
	_DATACACHE_ENTRY* pCache = pThis->Lookup(lpFormatEtc);
	if (pCache == NULL)
		return DATA_E_FORMATETC;

	// use cache if entry is not delay render
	memset(lpStgMedium, 0, sizeof(STGMEDIUM));
	if (pCache->m_stgMedium.tymed != TYMED_NULL)
	{
		// Copy the cached medium into the lpStgMedium provided by caller.
		if (!CopyStgMedium(lpFormatEtc->cfFormat, lpStgMedium,
		  &pCache->m_stgMedium))
			return DATA_E_FORMATETC;

		// format was supported for copying
		return S_OK;
	}

	SCODE sc = DATA_E_FORMATETC;
	try
	{
		// attempt LPSTGMEDIUM based delay render
		if (pThis->OnRenderData(lpFormatEtc, lpStgMedium))
			sc = S_OK;
	}
	catch(CException*e)
	{
		sc = COleException::Process(e);
		e->Delete();
	}

	return sc;
}

STDMETHODIMP CGenericDataObject::XDataObject::GetDataHere(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	METHOD_PROLOGUE_EX(CGenericDataObject, DataObject)
	ASSERT_VALID(pThis);

	// these two must be the same
	ASSERT(lpFormatEtc->tymed == lpStgMedium->tymed);
	lpFormatEtc->tymed = lpStgMedium->tymed;    // but just in case...

	// attempt to find match in the cache
	_DATACACHE_ENTRY* pCache = pThis->Lookup(lpFormatEtc);
	if (pCache == NULL)
		return DATA_E_FORMATETC;

	// handle cached medium and copy
	if (pCache->m_stgMedium.tymed != TYMED_NULL)
	{
		// found a cached format -- copy it to dest medium
		ASSERT(pCache->m_stgMedium.tymed == lpStgMedium->tymed);
		if (!CopyStgMedium(lpFormatEtc->cfFormat, lpStgMedium,
		  &pCache->m_stgMedium))
			return DATA_E_FORMATETC;

		// format was supported for copying
		return S_OK;
	}

	SCODE sc = DATA_E_FORMATETC;
	try
	{
		// attempt LPSTGMEDIUM based delay render
		if (pThis->OnRenderData(lpFormatEtc, lpStgMedium))
			sc = S_OK;
	}
	catch(CException*e)
	{
		sc = COleException::Process(e);
		e->Delete();
	}

	return sc;
}

STDMETHODIMP CGenericDataObject::XDataObject::QueryGetData(LPFORMATETC lpFormatEtc)
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, DataObject)

	// attempt to find match in the cache
	_DATACACHE_ENTRY* pCache = pThis->Lookup(lpFormatEtc);
	if (pCache == NULL)
		return DATA_E_FORMATETC;

	// it was found in the cache or can be rendered -- success
	return S_OK;
}

STDMETHODIMP CGenericDataObject::XDataObject::GetCanonicalFormatEtc(
	LPFORMATETC /*lpFormatEtcIn*/, LPFORMATETC /*lpFormatEtcOut*/)
{
	// because we support the target-device (ptd) for server metafile format,
	//  all members of the FORMATETC are significant.

	return DATA_S_SAMEFORMATETC;
}

STDMETHODIMP CGenericDataObject::XDataObject::SetData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium, BOOL bRelease)
{
	METHOD_PROLOGUE_EX(CGenericDataObject, DataObject)
	ASSERT_VALID(pThis);

	ASSERT(lpFormatEtc->tymed == lpStgMedium->tymed);

    // FEATURE: We don't know how to deal with this yet..
    if (bRelease == TRUE)
        return E_INVALIDARG;

	// attempt to find match in the cache
	_DATACACHE_ENTRY* pCache = pThis->Lookup(lpFormatEtc);
	if (pCache == NULL)
    {
        // Not found, so create one
        //
        pCache = pThis->GetCacheEntry(lpFormatEtc);
        pCache->m_stgMedium.tymed = NULL;
        pCache->m_stgMedium.hGlobal = NULL;
        ASSERT(pCache);
        if (pCache ==NULL)
    		return DV_E_FORMATETC;
    }

//	ASSERT(pCache->m_stgMedium.tymed == TYMED_NULL);

	SCODE sc = E_UNEXPECTED;
	try
	{
	    if (CopyStgMedium(lpFormatEtc->cfFormat, &pCache->m_stgMedium, lpStgMedium))
    	    sc = S_OK;
	}
	catch(CException*e)
	{
		sc = COleException::Process(e);
		e->Delete();
	}

    if (sc == S_OK)
        pThis->m_bModified = TRUE;
	return sc;
}

STDMETHODIMP CGenericDataObject::XDataObject::EnumFormatEtc(
	DWORD dwDirection, LPENUMFORMATETC* ppenumFormatEtc)
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, DataObject)

	*ppenumFormatEtc = NULL;

	CEnumFormatEtc* pFormatList = NULL;
	SCODE sc = E_OUTOFMEMORY;
	try
	{
		// generate a format list from the cache
		pFormatList = new CEnumFormatEtc;
		for (UINT nIndex = 0; nIndex < pThis->m_nSize; nIndex++)
		{
			_DATACACHE_ENTRY* pCache = &pThis->m_pDataCache[nIndex];
			{
				// entry should be enumerated -- add it to the list
				FORMATETC formatEtc;
				CopyFormatEtc(&formatEtc, &pCache->m_formatEtc);
				pFormatList->AddFormat(&formatEtc);
			}
		}
		// give it away to OLE (ref count is already 1)
		*ppenumFormatEtc = (LPENUMFORMATETC)&pFormatList->m_xEnumVOID;
		sc = S_OK;
	}
    catch(...)
    {
    }

	return sc;
}

STDMETHODIMP CGenericDataObject::XDataObject::DAdvise(
	FORMATETC* /*pFormatetc*/, DWORD /*advf*/,
	LPADVISESINK /*pAdvSink*/, DWORD* pdwConnection)
{
	*pdwConnection = 0;
	return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CGenericDataObject::XDataObject::DUnadvise(DWORD /*dwConnection*/)
{
	return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CGenericDataObject::XDataObject::EnumDAdvise(
	LPENUMSTATDATA* ppenumAdvise)
{
	*ppenumAdvise = NULL;
	return OLE_E_ADVISENOTSUPPORTED;
}

/////////////////////////////////////////////////////////////////////////////
// CGenericDataObject::XPersistStorage

STDMETHODIMP_(ULONG) CGenericDataObject::XPersistStorage::AddRef()
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, PersistStorage)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CGenericDataObject::XPersistStorage::Release()
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, PersistStorage)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CGenericDataObject::XPersistStorage::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, PersistStorage)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CGenericDataObject::XPersistStorage::GetClassID(LPCLSID lpClassID)
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, PersistStorage)
    // Can I do this?
	return E_NOTIMPL;
}

STDMETHODIMP CGenericDataObject::XPersistStorage::IsDirty()
{
	// Return S_OK if modified, and S_FALSE otherwise.
	METHOD_PROLOGUE_EX_(CGenericDataObject, PersistStorage)

	return (pThis->m_bModified) ? S_OK : S_FALSE;
}

STDMETHODIMP CGenericDataObject::XPersistStorage::InitNew(LPSTORAGE pStg)
{
	METHOD_PROLOGUE_EX(CGenericDataObject, PersistStorage)

	pThis->Empty();
	pThis->m_bInitialized = TRUE;
	pThis->m_bModified = FALSE;
    WriteClassStg(pStg, CLSID_GenericDataObject);

	return S_OK;
}

STDMETHODIMP CGenericDataObject::XPersistStorage::Load(LPSTORAGE pStg)
{
	ASSERT(pStg != NULL);
	METHOD_PROLOGUE_EX(CGenericDataObject, PersistStorage)
	HRESULT hr;
    USES_CONVERSION;

    pThis->Empty();

    CLSID clsid;
    // Verify it's our storage
    ReadClassStg(pStg, &clsid);
    if (clsid != CLSID_GenericDataObject)
        return E_FAIL;

	// Open the "Contents" stream of the supplied storage object
	LPSTREAM pStm = NULL;
	hr = pStg->OpenStream(L"CONTENTS", NULL,
		STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStm);

	ASSERT(FAILED(hr) || pStm != NULL);

	if (pStm == NULL)
        return hr;

    // The CONTENTs stream is formated thus:
    //   dwFormatCount
    // followed by dwFormatCount instances of:
    //   FORMATETC
    //   DWORD cb + string (if fetc.cfFormat non-native)
    //   DVTARGETDEVICE (if fetc.ptd != NULL)
    // From this information, the location of the
    // actual data is gleaned. Sub Stream & Storages are
    // named numerically by their dwFormatCount index.
    try
    {
        HRESULT hr;
        DWORD dwFormatCount ;
        hr = pStm->Read(&dwFormatCount, sizeof(DWORD), NULL);
        if (hr != S_OK)
            AfxThrowOleException(hr);

        FORMATETC fetc;
        _DATACACHE_ENTRY* pEntry ;
        // Open sub stream or storage and read
	    IStream* pstmData = NULL;
        IStorage* pstgData = NULL;
        TCHAR szName[32];
	    LARGE_INTEGER zero = { 0, 0 };
        try
        {

    		for (UINT nIndex = 0; nIndex < dwFormatCount; nIndex++)
            {
                fetc.ptd = NULL;
                pEntry = NULL;
	            pstmData = NULL;
                pstgData = NULL;

                hr = pStm->Read(&fetc, sizeof(FORMATETC), NULL);
                if (hr != S_OK)
                    AfxThrowOleException(hr);

                if (fetc.cfFormat >= 0xC000)
                {
                    // non-native
                    DWORD cb;
                    hr = pStm->Read(&cb, sizeof(DWORD), NULL);
                    if (hr != S_OK)
                        AfxThrowOleException(hr);
                    WCHAR* pwsz = new WCHAR[cb];
                    hr = pStm->Read(pwsz, cb, NULL);
                    if (hr == S_OK)
                        fetc.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(OLE2T(pwsz));
                    delete []pwsz;
                    if (hr != S_OK || fetc.cfFormat == 0)
                        AfxThrowOleException(E_FAIL);

                }

                // If .ptd is non-NULL then we need to read the
                // DVTARGETDEVICE info and setup .ptd correctly
                if (fetc.ptd != NULL)
                {
                    DWORD dwSize;
                    hr = pStm->Read(&dwSize, sizeof(DWORD), NULL);
                    if (hr != S_OK)
                        AfxThrowOleException(hr);
                    ASSERT(dwSize >= sizeof(DVTARGETDEVICE));

                    fetc.ptd = (DVTARGETDEVICE*)CoTaskMemAlloc(dwSize);
                    ASSERT(fetc.ptd);
                    fetc.ptd->tdSize = dwSize;

                    hr = pStm->Read(((BYTE*)fetc.ptd)+sizeof(DWORD), dwSize-sizeof(DWORD), NULL);
                    if (hr != S_OK)
                        AfxThrowOleException(hr);
                }

                wsprintf(szName, _T("%d"), nIndex);
                switch(fetc.tymed)
                {
		        case TYMED_ENHMF:   // stm contains enhmetafile
		        case TYMED_HGLOBAL: // stm contains data
		        case TYMED_ISTREAM: // stm
                case TYMED_GDI:     // stm contains DIB
                case TYMED_MFPICT:  // stm contains metafile
                case TYMED_FILE:    // stm contains filename
	                hr = pStg->OpenStream(T2OLE(szName), NULL,
		                STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pstmData);
	                ASSERT(FAILED(hr) || pstmData != NULL);
                    if (FAILED(hr))
                        AfxThrowOleException(hr);
                    break;

                case TYMED_ISTORAGE:
	                hr = pStg->OpenStorage(T2OLE(szName), NULL,
		                STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, 0, &pstgData);
	                ASSERT(FAILED(hr) || pstgData != NULL);
                    if (FAILED(hr))
                        AfxThrowOleException(hr);
                    break;

                default:
                    AfxThrowOleException(E_FAIL);
                }

                pEntry = pThis->GetCacheEntry(&fetc);
                if (pEntry==NULL)
                    AfxThrowOleException(E_OUTOFMEMORY);

                pEntry->m_stgMedium.tymed = fetc.tymed;
                // Now read from the stream or storage
                switch(fetc.tymed)
                {
		        case TYMED_ENHMF:   // stm contains enhmetafile
                case TYMED_GDI:     // stm contains DIB
                case TYMED_MFPICT:  // stm contains metafile
                case TYMED_FILE:    // stm contains filename
		        case TYMED_HGLOBAL: // stm contains data
		        case TYMED_ISTREAM: // stm
                    {
			            // get the size of the source stream
			            STATSTG stat;
			            if (pstmData->Stat(&stat, STATFLAG_NONAME) != S_OK)
				            // unable to get size of source stream
                            AfxThrowOleException(hr);
			            ASSERT(stat.pwcsName == NULL);

			            // always seek to zero before copy
			            pstmData->Seek(zero, STREAM_SEEK_SET, NULL);

                        if (fetc.tymed == TYMED_ISTREAM)
                        {
                            hr = CreateStreamOnHGlobal(NULL, TRUE, &pEntry->m_stgMedium.pstm);
                            if (FAILED(hr))
                                AfxThrowOleException(hr);

                            hr = pstmData->CopyTo(pEntry->m_stgMedium.pstm, stat.cbSize, NULL, NULL);
                            if (FAILED(hr))
                            {
                                pEntry->m_stgMedium.pstm->Release();
                                AfxThrowOleException(hr);
                            }

			                // always seek to zero after copy
			                pEntry->m_stgMedium.pstm->Seek(zero, STREAM_SEEK_SET, NULL);
                        }
                        else
                        {
                            pEntry->m_stgMedium.hGlobal = GlobalAlloc(GHND, stat.cbSize.LowPart);
                            ASSERT(pEntry->m_stgMedium.hGlobal );

                            BYTE* pb = (BYTE*)GlobalLock(pEntry->m_stgMedium.hGlobal);
                            hr = pstmData->Read(pb, stat.cbSize.LowPart, NULL);

                            GlobalUnlock(pEntry->m_stgMedium.hGlobal);
                            if (hr != S_OK)
                            {
                                GlobalFree(pEntry->m_stgMedium.hGlobal);
                                AfxThrowOleException(hr);
                            }

                            if (fetc.tymed == TYMED_FILE)
                            {
                                HGLOBAL h = pEntry->m_stgMedium.hGlobal;
                                pb = (BYTE*)GlobalLock(h);
                                pEntry->m_stgMedium.lpszFileName = (LPWSTR)CoTaskMemAlloc(stat.cbSize.LowPart);
                                ASSERT(pEntry->m_stgMedium.lpszFileName);
                                memcpy(pEntry->m_stgMedium.lpszFileName, pb, stat.cbSize.LowPart);
                                GlobalUnlock(h);
                                GlobalFree(h);
                            }
                        }

			            // always seek to zero after copy
			            pstmData->Seek(zero, STREAM_SEEK_SET, NULL);
                    }
                    break;


                case TYMED_ISTORAGE:
                    hr = StgCreateDocfile(NULL,
                        STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_DELETEONRELEASE|STGM_CREATE,
                        0, &pEntry->m_stgMedium.pstg);
                    if (FAILED(hr))
                        AfxThrowOleException(hr);

                    hr = pstgData->CopyTo(0, NULL, NULL, pEntry->m_stgMedium.pstg);
                    if (FAILED(hr))
                    {
                        pEntry->m_stgMedium.pstg->Release();
                        AfxThrowOleException(hr);
                    }
                    break;

                default:
                    AfxThrowOleException(E_FAIL);
                }
                if (pstmData)
                {
                    pstmData->Release();
                    pstmData = NULL;
                }
                if (pstgData)
                {
                    pstgData->Release();
                    pstgData = NULL;
                }
            } // for(nIndex...)
        }
        catch(...)
        {
            if (fetc.ptd != NULL)
                CoTaskMemFree(fetc.ptd);
            if (pstmData)
                pstmData->Release();
            if (pstgData)
                pstgData->Release();
            throw;
        }

        pThis->m_bModified = FALSE;
    }
    catch(COleException* e)
    {
        if (e->m_sc == S_FALSE)
            hr = E_FAIL;
        else
            hr = e->m_sc;
        e->Delete();
    }
    pStm->Release();
	return hr;
}

STDMETHODIMP CGenericDataObject::XPersistStorage::Save(LPSTORAGE pStg,
	BOOL fSameAsLoad)
{
	METHOD_PROLOGUE_EX(CGenericDataObject, PersistStorage)
	ASSERT(pStg != NULL);
    USES_CONVERSION;

	// Create a "Contents" stream on the supplied storage object

	// Don't bother saving if destination is up-to-date.
	if (fSameAsLoad && (IsDirty() != S_OK))
		return S_OK;

    WriteClassStg(pStg, CLSID_GenericDataObject);

	LPSTREAM pStm = NULL;
	HRESULT hr = pStg->CreateStream(L"CONTENTS",
		STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &pStm);

	ASSERT(FAILED(hr) || pStm != NULL);

	if (pStm == NULL)
        return hr;

	IStream* pstmData = NULL;
    IStorage* pstgData = NULL;
    TCHAR szName[32];
	LARGE_INTEGER zero = { 0, 0 };
    try
	{
		// Save
        UINT nName = 0;
        // Write out the first DWORD as zero.  After we're done, we seek back
        // and write the actual amount.
        pStm->Write(&nName, sizeof(nName), NULL);
		for (UINT nIndex = 0; nIndex < pThis->m_nSize; nIndex++)
		{
            // skip things we don't know how to persist reliably
            if (pThis->m_pDataCache[nIndex].m_formatEtc.tymed == TYMED_GDI)
                continue;

            // write out formatetc
            pStm->Write(&pThis->m_pDataCache[nIndex].m_formatEtc, sizeof(FORMATETC), NULL);
            if (pThis->m_pDataCache[nIndex].m_formatEtc.cfFormat >= 0xC000)
            {
                TCHAR sz[256];
                if (!GetClipboardFormatName(pThis->m_pDataCache[nIndex].m_formatEtc.cfFormat, sz, 256))
                    AfxThrowOleException(E_FAIL);

                OLECHAR* osz = T2OLE(sz);
                DWORD cb = (wcslen(osz)+1) * sizeof(OLECHAR) ;
                pStm->Write(&cb, sizeof(DWORD), NULL);
                pStm->Write(osz, cb, NULL);
            }

            if (pThis->m_pDataCache[nIndex].m_formatEtc.ptd != NULL)
            {
                pStm->Write(pThis->m_pDataCache[nIndex].m_formatEtc.ptd,
                            pThis->m_pDataCache[nIndex].m_formatEtc.ptd->tdSize, NULL);
            }

            // write out m_pDataCache[nIndex].m_stgMedium
            wsprintf(szName, _T("%d"), nName++);
            switch(pThis->m_pDataCache[nIndex].m_stgMedium.tymed)
            {
            case TYMED_GDI:     // stm contains DIB
		    case TYMED_ENHMF:   // stm contains enhmetafile
		    case TYMED_HGLOBAL: // stm contains data
		    case TYMED_ISTREAM: // stm
            case TYMED_MFPICT:  // stm contains metafile
            case TYMED_FILE:    // stm contains filename
	            hr = pStg->CreateStream(T2OLE(szName),
		            STGM_CREATE|STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0,0, &pstmData);
	            ASSERT(FAILED(hr) || pstmData != NULL);
                if (FAILED(hr))
                    AfxThrowOleException(hr);

                if (pThis->m_pDataCache[nIndex].m_stgMedium.tymed == TYMED_ISTREAM)
                {
			        // get the size of the source stream
			        STATSTG stat;
			        if (pThis->m_pDataCache[nIndex].m_stgMedium.pstm->Stat(&stat, STATFLAG_NONAME) != S_OK)
			        {
				        // unable to get size of source stream
				        return FALSE;
			        }
			        ASSERT(stat.pwcsName == NULL);

			        // always seek to zero before copy
			        LARGE_INTEGER zero = { 0, 0 };
			        pThis->m_pDataCache[nIndex].m_stgMedium.pstm->Seek(zero, STREAM_SEEK_SET, NULL);
                    pThis->m_pDataCache[nIndex].m_stgMedium.pstm->CopyTo(pstmData, stat.cbSize, NULL, NULL);

                    pThis->m_pDataCache[nIndex].m_stgMedium.pstm->Seek(zero, STREAM_SEEK_SET, NULL);
                }
                else if (pThis->m_pDataCache[nIndex].m_stgMedium.tymed == TYMED_FILE)
                {
                    pstmData->Write(pThis->m_pDataCache[nIndex].m_stgMedium.lpszFileName,
                                     (wcslen(pThis->m_pDataCache[nIndex].m_stgMedium.lpszFileName)+1)*2, NULL);
                }
                else
                {
                    BYTE* pb = (BYTE*)GlobalLock(pThis->m_pDataCache[nIndex].m_stgMedium.hGlobal);
                    ASSERT(pb);
                    pstmData->Write(pb, (DWORD)GlobalSize(pThis->m_pDataCache[nIndex].m_stgMedium.hGlobal), NULL);
                    GlobalUnlock(pThis->m_pDataCache[nIndex].m_stgMedium.hGlobal);
                }
			    pstmData->Seek(zero, STREAM_SEEK_SET, NULL);
                pstmData->Release();
                break;

            case TYMED_ISTORAGE:
	            hr = pStg->CreateStorage(T2OLE(szName),
		            STGM_CREATE|STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, NULL, &pstgData);
	            ASSERT(FAILED(hr) || pstgData != NULL);
                if (FAILED(hr))
                    AfxThrowOleException(hr);
                pThis->m_pDataCache[nIndex].m_stgMedium.pstg->CopyTo(NULL, NULL, NULL, pstgData);
                pstgData->Release();
                break;

            default:
                AfxThrowOleException(E_FAIL);
            }
		}

        // Write out the actual # of entries written
        //
        pStm->Seek(zero, STREAM_SEEK_SET, NULL);
        pStm->Write(&nName, sizeof(nName), NULL);

		// Bookkeeping:  Clear the dirty flag, if storage is same.
		if (fSameAsLoad)
			pThis->m_bModified = FALSE;
	}
    catch(COleException* e)
    {
        if (e->m_sc == S_FALSE)
            hr = E_FAIL;
        else
            hr = e->m_sc;

        e->Delete();
    }
    pStm->Release();

	return hr;
}

STDMETHODIMP CGenericDataObject::XPersistStorage::SaveCompleted(LPSTORAGE pStgSaved)
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, PersistStorage)

	//if (pStgSaved != NULL)
	//	pThis->m_bModified = FALSE;

	return E_NOTIMPL;
}

STDMETHODIMP CGenericDataObject::XPersistStorage::HandsOffStorage()
{
	METHOD_PROLOGUE_EX_(CGenericDataObject, PersistStorage)
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CGenericDataObject diagnostics

#ifdef _DEBUG
void CGenericDataObject::AssertValid() const
{
	CCmdTarget::AssertValid();
	ASSERT(m_nSize <= m_nMaxSize);
	ASSERT(m_nMaxSize != 0 || m_pDataCache == NULL);
}

void CGenericDataObject::Dump(CDumpContext& dc) const
{
	CCmdTarget::Dump(dc);

	dc << "m_nMaxSize = " << m_nMaxSize;
	dc << "\nm_nSize = " << m_nSize;
	dc << "\nm_pDataCache = " << m_pDataCache;

	for (UINT n = 0; n < m_nSize; n++)
	{
		dc << "\n\tentry [" << n << "] = {";
		_DATACACHE_ENTRY& rEntry = m_pDataCache[n];
		dc << "\n\t m_formatEtc.cfFormat = " << rEntry.m_formatEtc.cfFormat;
		dc << "\n\t m_formatEtc.pdt = " << rEntry.m_formatEtc.ptd;
		dc << "\n\t m_formatEtc.dwAspect = " << rEntry.m_formatEtc.dwAspect;
		dc << "\n\t m_formatEtc.lindex = " << rEntry.m_formatEtc.lindex;
		dc << "\n\t m_formatEtc.tymed = " << rEntry.m_formatEtc.tymed;
		dc << "\n\t m_stgMedium.tymed = " << rEntry.m_stgMedium.tymed;
		dc << "\n\t}";
	}

	dc << "\n";
}
#endif //_DEBUG




/////////////////////////////////////////////////////////////////////////////
// CEnumArray (provides OLE enumerator for arbitrary items in an array)
//
// Stolen from MFC (OLEIMPL2.H)
//
CEnumArray::CEnumArray(size_t nSizeElem, const void* pvEnum, UINT nSize,
	BOOL bNeedFree)
{
	m_nSizeElem = nSizeElem;
	m_pClonedFrom = NULL;

	m_nCurPos = 0;
	m_nSize = nSize;
	m_pvEnum = (BYTE*)pvEnum;
	m_bNeedFree = bNeedFree;

	ASSERT_VALID(this);
}

CEnumArray::~CEnumArray()
{
	ASSERT_VALID(this);

	// release the clone pointer (only for clones)
	if (m_pClonedFrom != NULL)
	{
		m_pClonedFrom->InternalRelease();
		ASSERT(!m_bNeedFree);
	}

	// release the pointer (should only happen on non-clones)
	if (m_bNeedFree)
	{
		ASSERT(m_pClonedFrom == NULL);
		delete m_pvEnum;
	}
}

BOOL CEnumArray::OnNext(void* pv)
{
	ASSERT_VALID(this);

	if (m_nCurPos >= m_nSize)
		return FALSE;

	memcpy(pv, &m_pvEnum[m_nCurPos*m_nSizeElem], m_nSizeElem);
	++m_nCurPos;
	return TRUE;
}

BOOL CEnumArray::OnSkip()
{
	ASSERT_VALID(this);

	if (m_nCurPos >= m_nSize)
		return FALSE;

	return ++m_nCurPos < m_nSize;
}

void CEnumArray::OnReset()
{
	ASSERT_VALID(this);

	m_nCurPos = 0;
}

CEnumArray* CEnumArray::OnClone()
{
	ASSERT_VALID(this);

	// set up an exact copy of this object
	//  (derivatives may have to replace this code)
	CEnumArray* pClone;
	pClone = new CEnumArray(m_nSizeElem, m_pvEnum, m_nSize);
	ASSERT(pClone != NULL);
	ASSERT(!pClone->m_bNeedFree);   // clones should never free themselves
	pClone->m_nCurPos = m_nCurPos;

	// finally, return the clone to OLE
	ASSERT_VALID(pClone);
	return pClone;
}

/////////////////////////////////////////////////////////////////////////////
// CEnumArray::XEnumVOID implementation

STDMETHODIMP_(ULONG) CEnumArray::XEnumVOID::AddRef()
{
	METHOD_PROLOGUE_EX_(CEnumArray, EnumVOID)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CEnumArray::XEnumVOID::Release()
{
	METHOD_PROLOGUE_EX_(CEnumArray, EnumVOID)
	return pThis->ExternalRelease();
}

STDMETHODIMP CEnumArray::XEnumVOID::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(CEnumArray, EnumVOID)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CEnumArray::XEnumVOID::Next(
	ULONG celt, void* reelt, ULONG* pceltFetched)
{
	METHOD_PROLOGUE_EX(CEnumArray, EnumVOID);
	ASSERT_VALID(pThis);

	if (pceltFetched != NULL)
		*pceltFetched = 0;

	ASSERT(celt > 0);
	ASSERT(celt == 1 || pceltFetched != NULL);

	BYTE* pchCur = (BYTE*)reelt;
	ULONG nFetched = 0;

	ULONG celtT = celt;
	SCODE sc = E_UNEXPECTED;
	try
	{
		while (celtT != 0 && pThis->OnNext((void*)pchCur))
		{
			pchCur += pThis->m_nSizeElem;
			--celtT;
		}
		if (pceltFetched != NULL)
			*pceltFetched = celt - celtT;
		sc = celtT == 0 ? S_OK : S_FALSE;
	}
    catch(...)
    {
    }
	
	return sc;
}

STDMETHODIMP CEnumArray::XEnumVOID::Skip(ULONG celt)
{
	METHOD_PROLOGUE_EX(CEnumArray, EnumVOID);
	ASSERT_VALID(pThis);

	ULONG celtT = celt;
	SCODE sc = E_UNEXPECTED;
	try
	{
		while (celtT != 0 && pThis->OnSkip())
			--celtT;
		sc = celtT == 0 ? S_OK : S_FALSE;
	}
    catch(...)
    {
    }

	return celtT != 0 ? S_FALSE : S_OK;
}

STDMETHODIMP CEnumArray::XEnumVOID::Reset()
{
	METHOD_PROLOGUE_EX(CEnumArray, EnumVOID);
	ASSERT_VALID(pThis);

	pThis->OnReset();
	return S_OK;
}

STDMETHODIMP CEnumArray::XEnumVOID::Clone(IEnumVOID** ppenm)
{
	METHOD_PROLOGUE_EX(CEnumArray, EnumVOID);
	ASSERT_VALID(pThis);

	*ppenm = NULL;

	SCODE sc = E_UNEXPECTED;
	try
	{
		CEnumArray* pEnumHelper = pThis->OnClone();
		ASSERT_VALID(pEnumHelper);

		// we use an extra reference to keep the original object alive
		//  (the extra reference is removed in the clone's destructor)
		if (pThis->m_pClonedFrom != NULL)
			pEnumHelper->m_pClonedFrom = pThis->m_pClonedFrom;
		else
			pEnumHelper->m_pClonedFrom = pThis;
		pEnumHelper->m_pClonedFrom->InternalAddRef();
		*ppenm = &pEnumHelper->m_xEnumVOID;

		sc = S_OK;
	}
    catch(...)
    {
    }

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\guids.h ===
#ifndef __GUIDS_H__
#define __GUIDS_H__
DEFINE_GUID(CLSID_IDataObjectViewer, 0x28d8aba0, 0x4b78, 0x11ce, 0xb2, 0x7d, 0x0,  0xaa, 0x0,  0x1f, 0x73, 0xc1);
DEFINE_GUID(IID_IInterfaceViewer,0xfc37e5ba,0x4a8e,0x11ce, 0x87,0x0b,0x08,0x00,0x36,0x8d,0x23,0x02);
#ifndef _NTBUILD
DEFINE_GUID(IID_IClipboard,0x7502CA01,0x4ACA,0x11cf,0xB6,0x3C,0x00,0x80,0xC7,0x92,0xB7,0x82);
DEFINE_GUID(IID_IClipboardNotify, 0x7502CA02,0x4ACA,0x11cf,0xB6,0x3C,0x00,0x80,0xC7,0x92,0xB7,0x82);
#endif
DEFINE_GUID(CLSID_GenericDataObject, 0x92436b40, 0x6327, 0x11cf, 0xb6, 0x3c, 0x0, 0x80, 0xc7, 0x92, 0xb7, 0x82);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//
// CMainFrame implements most menu handling code, is registered in
// the clipboard viewer chain, provides OLE D&D support.
//

#include "stdafx.h"
#include "Server.h"
#include "netclipapp.h"
#include "Doc.h"
#include "View.h"

#include "MainFrm.h"
#include "SvrDlg.h"
#ifdef _USE_OLEVIEWER
//#include "..\\ole2view\\iviewers\\iview.h"
#endif
#include "guids.h"
#include "DataObj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

// Because WM_DRAWCLIPBOARD is an Input Async message we cannot
// make calls on out-of-proc OLE interfaces during processing. To
// work around this we post a message to ourselves and do the
// appropriate processing on it. With the help of a semaphore
// (m_fRefreshPosted) this has the added benefit of eliminating
// multiple re-paints and clipboard accesses during D&D operations.
//
#define WM_REFRESH (WM_USER+1)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_COMMAND(ID_DISPLAY_AUTO, OnDisplayAuto)
	ON_UPDATE_COMMAND_UI(ID_DISPLAY_AUTO, OnUpdateDisplayAuto)
	ON_WM_INITMENUPOPUP()
	ON_WM_DRAWCLIPBOARD()
	ON_WM_CHANGECBCHAIN()
	ON_COMMAND(ID_EDIT_DELETE, OnEditClear)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditClear)
	ON_COMMAND(ID_CONNECT_CONNECT, OnConnectConnect)
	ON_UPDATE_COMMAND_UI(ID_CONNECT_CONNECT, OnUpdateConnectConnect)
	ON_COMMAND(ID_CONNECT_DISCONNECT, OnConnectDisconnect)
	ON_UPDATE_COMMAND_UI(ID_CONNECT_DISCONNECT, OnUpdateConnectDisconnect)
	ON_WM_INITMENU()
	ON_COMMAND(ID_EDIT_PASTELOCAL, OnEditPaste)
	ON_MESSAGE(WM_SETMESSAGESTRING, OnSetMessageString)
	//}}AFX_MSG_MAP
#ifdef _USE_OLEVIEWER
#ifdef _DEBUG
	ON_COMMAND(ID_VIEWDATAOBJECT, OnViewDataObject)
	ON_UPDATE_COMMAND_UI(ID_VIEWDATAOBJECT, OnUpdateViewDataObject)
#endif
#endif
    ON_COMMAND_RANGE(ID_DISPLAY_FIRST, ID_DISPLAY_LAST, OnOtherFormat)
	ON_UPDATE_COMMAND_UI_RANGE(ID_DISPLAY_FIRST, ID_DISPLAY_LAST, OnUpdateOtherFormat)
    ON_MESSAGE(WM_REFRESH, OnRefresh)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
//	ID_INDICATOR_CAPS,
//	ID_INDICATOR_NUM,
//	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    m_pNetClipView = NULL;
    m_fDisplayAsIcon = FALSE;	
    m_cfDisplay = 0;
    m_hwndNextCB = NULL;
    m_pClipboard = NULL;
    m_dwConnectionCookie = NULL;
    m_pConnectionPt = NULL;

    m_fRefreshPosted = FALSE;// prevent multiple refreshes.
}

CMainFrame::~CMainFrame()
{
    // Make sure we've released
    ASSERT(m_pConnectionPt == NULL);
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return 0;

    // Register our d&d handler
    m_dropTarget.Register( this ) ;

    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
    UINT    nResources = IDR_MAINFRAME;
    if (g_fDCOM == FALSE)
        nResources = IDR_NONETOLE;

	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(nResources))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY );

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	//m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	//EnableDocking(CBRS_ALIGN_ANY);
	//DockControlBar(&m_wndToolBar);

#ifdef _DEBUG
    // For debug we add a top leve menu item "View[Debug]..." that
    // pops up the Ole2View 2.0 UDT interface viewer.
    CMenu* pMenu = GetMenu();
    ASSERT(pMenu);
    pMenu->AppendMenu(MF_STRING , ID_VIEWDATAOBJECT, _T("[De&bugView...]"));
#endif

    //TRACE("m_hWnd=%08X\n", m_hWnd);

    m_hwndNextCB = SetClipboardViewer();

	return 0;
}

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/, CCreateContext* pContext)
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return TRUE;

    // default create client will create a view if asked for it
	if (pContext != NULL && pContext->m_pNewViewClass != NULL)
	{
        pContext->m_pNewViewClass = RUNTIME_CLASS(CNetClipView) ;
		m_pNetClipView = (CNetClipView*)CreateView(pContext, AFX_IDW_PANE_FIRST);
        if (m_pNetClipView == NULL)
			return FALSE;
        ASSERT(m_pNetClipView->IsKindOf(RUNTIME_CLASS(CNetClipView)));
    }
    return TRUE;
}

LRESULT CMainFrame::OnSetMessageString(WPARAM wParam, LPARAM lParam)
{
    LRESULT lr = CFrameWnd::OnSetMessageString(wParam, lParam);
	CWnd* pMessageBar = GetMessageBar();
    pMessageBar->InvalidateRect(NULL, TRUE);
    pMessageBar->UpdateWindow();
    return lr ;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

BOOL CMainFrame::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle, CWnd* pParentWnd, CCreateContext* pContext)
{
    // Turn off auto update of title bar
    dwDefaultStyle &= ~((DWORD)FWS_ADDTOTITLE) ;
    BOOL f = CFrameWnd::LoadFrame(nIDResource, dwDefaultStyle,
                pParentWnd, pContext);

    return f ;
}

void CMainFrame::OnDestroy()
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (!theApp.m_fServing)
    {
        m_dropTarget.Revoke( ) ;
        SavePosition(m_strMachine) ;
    }
    Disconnect();

    //if (m_hwndNextCB)
    {
        ASSERT(m_hwndNextCB!= m_hWnd);
        TRACE(_T("ChangeClipboardChain(m_hwndNextCB = %08X)..."), m_hwndNextCB);
        ChangeClipboardChain(m_hwndNextCB);
        TRACE(_T("ChangeClipboardChain\n"));
        m_hwndNextCB = NULL;
    }
    CFrameWnd::OnDestroy();
}

// Saves the window settings. Settings are saved per
// machinename, allowing the user to have separate windows in
// saved positions for each machine they are viewing.
//
// TODO: Save m_strMachineName.
//
BOOL CMainFrame::SavePosition(LPCTSTR szName)
{
    CString szSection("Default") ;
    CString szKey("WndPos") ;

    if (szName && *szName)
    {
        if (*szName == '\\') szName++;
        if (*szName == '\\') szName++;
        szSection = szName;
    }

    WINDOWPLACEMENT wp;
    CString szValue ;

    wp.length = sizeof( WINDOWPLACEMENT );
    GetWindowPlacement( &wp );

    LPTSTR p = szValue.GetBuffer( 255 ) ;
    wsprintf( p, _T("%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d"),
        wp.showCmd, wp.ptMinPosition.x, wp.ptMinPosition.y,
        wp.ptMaxPosition.x, wp.ptMaxPosition.y,
        wp.rcNormalPosition.left, wp.rcNormalPosition.top,
        wp.rcNormalPosition.right, wp.rcNormalPosition.bottom,
        (m_wndToolBar.GetSafeHwnd() && (m_wndToolBar.GetStyle() & WS_VISIBLE)) ? TRUE : FALSE,
        (m_wndStatusBar.GetSafeHwnd() && (m_wndStatusBar.GetStyle() & WS_VISIBLE)) ? TRUE : FALSE);

    szValue.ReleaseBuffer() ;
    theApp.WriteProfileString( szSection, szKey, szValue );
    return TRUE ;
}

// Restores window settings
// TODO: Save m_strMachineName.
BOOL CMainFrame::RestorePosition(LPCTSTR szName, int nCmdShow)
{
    CString sz ;
    CString szSection("Default") ;
    CString szKey("WndPos") ;
    BOOL fToolBar = TRUE ;
    BOOL fStatusBar = TRUE ;

    if (szName && *szName)
    {
        if (*szName == '\\') szName++;
        if (*szName == '\\') szName++;
        szSection = szName ;
    }

    WINDOWPLACEMENT wp;
    int     nConv;

    wp.length = sizeof( WINDOWPLACEMENT );
    wp.flags = 0 ;

    try
    {
        sz = theApp.GetProfileString(szSection, szKey, _T("") ) ;
        if (sz.IsEmpty())
            AfxThrowMemoryException();

        LPTSTR   lp = (LPTSTR)sz.GetBuffer( 255 );

        wp.showCmd = (WORD)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        wp.ptMinPosition.x = (int)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        wp.ptMinPosition.y = (int)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        wp.ptMaxPosition.x = (int)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        wp.ptMaxPosition.y = (int)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        wp.rcNormalPosition.left = (int)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        wp.rcNormalPosition.top = (int)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        wp.rcNormalPosition.right = (int)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        wp.rcNormalPosition.bottom = (int)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        fToolBar = (BOOL)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        fStatusBar = (BOOL)ParseOffNumber( (LPTSTR FAR *)&lp, &nConv );
        if (!nConv)
            AfxThrowMemoryException();

        // Always strip off minimize.
        //
        if (wp.showCmd == SW_SHOWMINIMIZED)
            wp.showCmd = SW_SHOWNORMAL ;

        if (nCmdShow != SW_SHOWNORMAL || nCmdShow != SW_NORMAL)
            wp.showCmd = nCmdShow ;
    }
    catch(CException* e)
    {
        fToolBar = TRUE ;
        fStatusBar = TRUE ;
        ShowControlBar( &m_wndToolBar, fToolBar, TRUE ) ;
        ShowControlBar( &m_wndStatusBar, fStatusBar, TRUE ) ;
        ShowWindow( SW_SHOWNORMAL );
        e->Delete();
        return FALSE ;
    };

    ShowControlBar( &m_wndToolBar, fToolBar, TRUE ) ;
    ShowControlBar( &m_wndStatusBar, fStatusBar, TRUE ) ;
    return (BOOL)SetWindowPlacement( &wp ) ;
}

// Automatic selection of clipboard format. Selection is dependent
// on the Rich Edit control.
//
void CMainFrame::OnDisplayAuto()
{
    if (m_cfDisplay != 0)
        m_cfDisplay = 0;  // auto
    else
    {
        // menu item 2 is &Display
        CMenu* pMenu = GetMenu()->GetSubMenu(2);
        ASSERT(pMenu);
        if (pMenu)
        {
            m_cfDisplay = m_rgFormats[0];
            if (!m_pNetClipView->CanDisplay(m_cfDisplay))
                m_cfDisplay = 0;
        }
    }
    m_pNetClipView->OnUpdate(NULL, 0, NULL);
}

void CMainFrame::OnUpdateDisplayAuto(CCmdUI* pCmdUI)
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
    {
        pCmdUI->Enable(FALSE);
        return;
    }

    pCmdUI->SetCheck(m_cfDisplay == 0 ? 1 : 0);
}

// The Windows API GetClipboardFormatName() only returns strings
// for formats registered through RegisterClipboardFormat(), not
// the predefined set.  This little function handles the predefined
// format names.
//
LPTSTR CMainFrame::GetNameOfClipboardFormat(CLIPFORMAT cf)
{
    static TCHAR sz[256] ;
    switch( cf )
    {
        case CF_UNICODETEXT: lstrcpy( sz, _T( "Unicode Text" ) ) ; break ;
        case CF_ENHMETAFILE: lstrcpy( sz, _T( "Enhanced Metafile" ) ) ; break ;
        case CF_TEXT: lstrcpy( sz, _T( "Text" ) ) ; break ;
        case CF_BITMAP: lstrcpy( sz, _T( "Bitmap" ) ) ; break ;
        case CF_METAFILEPICT: lstrcpy( sz, _T( "Metafile" ) ) ; break ;
        case CF_SYLK: lstrcpy( sz, _T( "SLYK" ) ) ; break ;
        case CF_DIF: lstrcpy( sz, _T( "DIF" ) ) ; break ;
        case CF_TIFF: lstrcpy( sz, _T( "TIFF" ) ) ; break ;
        case CF_OEMTEXT: lstrcpy( sz, _T( "OEM Text" ) ) ; break ;
        case CF_DIB: lstrcpy( sz, _T( "Device Independent Bitmap" ) ) ; break ;
        case CF_PALETTE: lstrcpy( sz, _T( "Palette" ) ) ; break ;
        case CF_PENDATA: lstrcpy( sz, _T( "Pen Data" ) ) ; break ;
        case CF_RIFF: lstrcpy( sz, _T( "RIFF" ) ) ; break ;
        case CF_WAVE: lstrcpy( sz, _T( "Wave Data" ) ) ; break ;
        default:
            {
#if 0
                if (m_pClipboard)
                {
                    WCHAR* pwsz = NULL;
                    HRESULT hr = m_pClipboard->GetClipboardFormatName(cf, &pwsz) ;
                    if (SUCCEEDED(hr))
                    {
                        if (hr == S_OK)
                        {
                            ASSERT(pwsz);
#ifdef _UNICODE
                            wcscpy(sz, pwsz);
#else
                            WideCharToMultiByte(CP_ACP, 0, pwsz, -1, sz, 256, NULL, NULL);
#endif
                            CoTaskMemFree(pwsz);
                        }
                        else
                        {
                            if (!GetClipboardFormatName( (UINT)cf, sz, 254 ))
                                *sz = '\0';
                        }
                    }
                    else
                        *sz = '\0';
                }
                else
#endif
                    if (!GetClipboardFormatName( (UINT)cf, sz, 254 ))
                        *sz = '\0';
            }
        break ;
    }

    return sz ;
}

void CMainFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return;

    if (bSysMenu)
		return;     // don't support system menu

	AfxLockTempMaps();  // prevent temp CMenu from being deleted too early

    // 2 is the index of the Display menu
    if (nIndex != 2)
    {
    	CFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
        AfxUnlockTempMaps();
        return;
    }

    // Starting at item 2 (0 == &Auto, 1 == separator)
    // delete all items
    while (pPopupMenu->DeleteMenu(2, MF_BYPOSITION))
        ;

    IDataObject* pdo = NULL;
    HRESULT hr;

    BeginWaitCursor();
    if (m_pClipboard)
        hr = m_pClipboard->GetClipboard(&pdo);
    else
        hr = OleGetClipboard(&pdo);

    if (SUCCEEDED(hr))
    {
        // Fill menu with all formats, enabling only those which
        // we know we can view (graying out the others).
        //
        FORMATETC       fetc;
        IEnumFORMATETC* penum=NULL;
        if (SUCCEEDED(hr = pdo->EnumFormatEtc(DATADIR_GET, &penum)))
        {
            ULONG   ulFetched;
            TCHAR   sz[256];
            UINT    uiFormat = ID_DISPLAY_FIRST;
            while (S_OK == penum->Next(1, &fetc, &ulFetched))
            {
                lstrcpy(sz, GetNameOfClipboardFormat(fetc.cfFormat));
                if (*sz)
                {
                    m_rgFormats[uiFormat-ID_DISPLAY_FIRST] = fetc.cfFormat;
                    pPopupMenu->AppendMenu(MF_STRING, uiFormat, sz);
                    uiFormat++;
                    ASSERT(uiFormat<ID_DISPLAY_LAST);
                }
            }
            penum->Release();
        }
        pdo->Release();

        // Must let default do it's thing
	    CFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
    }
    EndWaitCursor();
    AfxUnlockTempMaps();
}

// OnOtherFormat is the handler for all items on the display
// menu below the 2nd one ("&Auto" and the separator).
//
// m_rgFormats is populated with the clipboard formats
// returned through IDataObject::EnumFormatEtc, in the
// order returned.
//
void CMainFrame::OnOtherFormat( UINT nID )
{
    if (nID >= ID_DISPLAY_FIRST && nID < ID_DISPLAY_LAST)
    {
        m_cfDisplay = m_rgFormats[nID-ID_DISPLAY_FIRST];
        m_pNetClipView->OnUpdate(NULL, 0, NULL);
    }
}

void CMainFrame::OnUpdateOtherFormat(CCmdUI* pCmdUI)
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
    {
        pCmdUI->Enable(FALSE);
        return;
    }
	
    UINT nID = pCmdUI->m_nID;

    if (nID >= ID_DISPLAY_FIRST && nID < ID_DISPLAY_LAST)
    {
        // Do we know how to display this format?
        if (m_pNetClipView->CanDisplay(m_rgFormats[nID-ID_DISPLAY_FIRST]))
            pCmdUI->Enable(TRUE);
        else
        {
            pCmdUI->Enable(FALSE);
            if (m_cfDisplay == m_rgFormats[nID-ID_DISPLAY_FIRST])
                m_cfDisplay = 0;
        }

        // Check the active one.
        if (m_cfDisplay == m_rgFormats[nID-ID_DISPLAY_FIRST])
            pCmdUI->SetCheck(1);
        else
            pCmdUI->SetCheck(0);
    }
}

void CMainFrame::OnDrawClipboard()
{
    // If we're registered in the clipboard format viewer chain
    // then we must call the next viewer. m_hwndNextCB will
    // only be non-NULL if we're viewing the local clipboard
    //TRACE("In OnDrawClipboard (m_hwndNextCB = %08X)...", m_hwndNextCB);
    //ASSERT(m_hwndNextCB!= m_hWnd);
    if (m_hwndNextCB)
    {
        ::SendMessage(m_hwndNextCB, WM_DRAWCLIPBOARD, 0, 0);
        //TRACE("Sent WM_DRAWCLIPBOARD.\n");
    }
    else
    {
        //TRACE("Did not send WM_DRAWCLIPBOARD.\n");
    }

    // FEATURE: The check for m_Serving is not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (!theApp.m_fServing && m_pClipboard == NULL && m_fRefreshPosted == FALSE && theApp.m_fNoUpdate==FALSE)
    {
        // WM_DRAWCLIPBOARD is an INPUTASYNC call.  OnUpdate may
        // try to call into an in-place active item, so we post ourselves
        // a message (WM_USER+1 == OnRefresh()).
        // m_pNetClipView->OnUpdate(NULL, 0, NULL);
        m_fRefreshPosted = TRUE;
        PostMessage(WM_REFRESH);
    }
}

// Because WM_DRAWCLIPBOARD is an Input Async message we cannot
// make calls on out-of-proc OLE interfaces during processing. To
// work around this we post a message to ourselves and do the
// appropriate processing on it. With the help of a semaphore
// (m_fRefreshPosted) this has the added benefit of eliminating
// multiple re-paints and clipboard accesses during D&D operations.
//
LRESULT CMainFrame::OnRefresh(WPARAM, LPARAM)
{
    BeginWaitCursor();
    m_fRefreshPosted=FALSE;
    m_pNetClipView->OnUpdate(NULL, 0, NULL);
    EndWaitCursor();
    return 0;
}

void CMainFrame::OnChangeCbChain(HWND hWndRemove, HWND hWndAfter)
{
    // Pass on to next in chain.
    //ASSERT(!(hWndRemove == m_hWnd && hWndAfter == m_hWnd));
    //ASSERT(m_hwndNextCB!= m_hWnd);
    //TRACE("In OnChangeCbChain(%08X, %08X) (m_hwndNextCB = %08X)", hWndRemove, hWndAfter, m_hwndNextCB);
    if (m_hwndNextCB)
    {
        ::SendMessage(m_hwndNextCB, WM_CHANGECBCHAIN, (WPARAM)hWndRemove, (LPARAM)hWndAfter);
        //TRACE("Sent WM_CHANGERCBCHAIN.\n");
    }
    else
    {
        //TRACE("Did not send WM_CHANGERCBCHAIN.\n");
    }
}


void CMainFrame::OnEditClear()
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return;

    BeginWaitCursor();
    if (m_pClipboard)
        m_pClipboard->SetClipboard(NULL);
    else
        OleSetClipboard(NULL);

    m_pNetClipView->OnUpdate(NULL, 0, NULL);
    EndWaitCursor();
}

void CMainFrame::OnUpdateEditClear(CCmdUI* pCmdUI)
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return;

    pCmdUI->Enable(1);	
}

void CMainFrame::OnEditPaste() 
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return;
    BeginWaitCursor();
    if (m_pClipboard)
    {
        IDataObject* pdo;
        SetMessageText(IDS_STATUS_GETLOCAL);
        HRESULT hr=OleGetClipboard(&pdo);
        if (SUCCEEDED(hr))
        {
            SetMessageText(IDS_STATUS_SETREMOTE);
            m_pClipboard->SetClipboard(pdo);
            pdo->Release();
        }
        SetMessageText(AFX_IDS_IDLEMESSAGE);
    }
    EndWaitCursor();
}

void CMainFrame::OnConnectConnect() 
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return;

    CServerInfoDlg dlg(this);
    dlg.m_strMachine = m_strMachine;
    if (IDOK==dlg.DoModal())
    {
        m_strMachine = dlg.m_strMachine;
        if (SUCCEEDED(Connect(dlg.m_strMachine)))
        {
            SetWindowText(m_strMachine + _T(" - NetClip"));
            // Force an update of the display.
            m_pNetClipView->OnUpdate(NULL, 0, NULL);
        }
    }
}

void CMainFrame::OnUpdateConnectConnect(CCmdUI* pCmdUI)
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return;
    pCmdUI->Enable(m_pClipboard==NULL);
}

void CMainFrame::OnConnectDisconnect()
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return;

    Disconnect();	
    SetWindowText(_T("Local Clipboard"));
    /*
    TRACE("SetClipBoardViewer...");
    m_hwndNextCB = SetClipboardViewer();
    TRACE("SetClipboardViewer returned m_hwndNextCB = %08X\n", m_hwndNextCB);
    //ASSERT(m_hwndNextCB!= m_hWnd);
    */
    m_pNetClipView->OnUpdate(NULL, 0, NULL);
}

void CMainFrame::OnUpdateConnectDisconnect(CCmdUI* pCmdUI)
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return;
    pCmdUI->Enable(m_pClipboard!=NULL);
}

HRESULT CMainFrame::Connect(CString &strMachine)
{
    // FEATURE: These checks are not really necessary because CMainFrame
    // is never created when we are run as a server (or service)
    //
    if (theApp.m_fServing)
        return E_FAIL;

    BeginWaitCursor();
    // If we're already connected for some reason just make
    // sure we disconnect first.
    //
    Disconnect();

    CString strMsg;
    strMsg.FormatMessage(IDS_STATUS_CONNECTING, strMachine);
    SetMessageText(strMsg);

    HRESULT hr = S_OK;
    MULTI_QI rgMQI[] = 
    { 
        //{*pIID, *pItf, hr}
        {&IID_IClipboard, NULL, E_FAIL}, 
        {&IID_IConnectionPointContainer, NULL, E_FAIL}
    };

    USES_CONVERSION;

    if (strMachine.CompareNoCase(_T("%inproc%")) != 0)
    {
        COSERVERINFO info;
	    memset(&info, 0, sizeof(info)); // MH 8/8/96: fix for NT 4.0 final
        info.pwszName = T2OLE(strMachine.GetBuffer(_MAX_PATH));
        info.pAuthInfo = NULL;
        hr = CoCreateInstanceEx(CNetClipServer::guid, NULL, CLSCTX_SERVER | CLSCTX_REMOTE_SERVER, &info, 
                                (sizeof(rgMQI)/sizeof(rgMQI[0])), rgMQI);
        strMachine.ReleaseBuffer();
    }
    else
    {
        CNetClipServer* p = new CNetClipServer;
        p->CreateEx(0, AfxRegisterWndClass(0), _T("Serving Clipboard"), WS_OVERLAPPEDWINDOW, 0,0,0,0, NULL, 0);
        rgMQI[0].pItf = (IClipboard*)p->GetInterface(&IID_IClipboard);
        rgMQI[0].hr = S_OK;

        ASSERT(rgMQI[0].pItf);
        if (rgMQI[0].pItf == NULL)
        {
            EndWaitCursor();
            ErrorMessage("Could not create instance of inproc server.", hr);
            SetMessageText(AFX_IDS_IDLEMESSAGE);
            return E_FAIL;
        }
        rgMQI[1].hr = rgMQI[0].pItf->QueryInterface(IID_IConnectionPointContainer, (void**)&rgMQI[1].pItf);
        hr = rgMQI[1].hr;
    }

    strMsg += _T(".");
    SetMessageText(strMsg);

    if (FAILED(hr))
    {
        EndWaitCursor();
        // Pop up error message
        CString str = _T("CoCreateInstanceEx failed.");
        switch (hr)
        {
            case REGDB_E_CLASSNOTREG:
            case CO_E_CREATEPROCESS_FAILURE:
            case CO_E_SERVER_EXEC_FAILURE:
                str = _T("The Remote Clipboard Viewer is not be installed correctly on the remote computer.");
            break;

            case CO_E_CANT_REMOTE:
                str = _T("Possible reason: Distributed COM is disabled.");
            break;

            case CO_E_BAD_SERVER_NAME:
                str = _T("The machine name is invalid.");
            break;

            case CO_E_WRONG_SERVER_IDENTITY:
            case CO_E_RUNAS_CREATEPROCESS_FAILURE:
            case CO_E_RUNAS_LOGON_FAILURE:
            case CO_E_LAUNCH_PERMSSION_DENIED:
            case E_ACCESSDENIED:
                str = _T("Permission denied. Make sure the same user is logged on to both computers.");
            break;

            case CO_E_REMOTE_COMMUNICATION_FAILURE:
                str = _T("This computer was unable to communicate with the remote computer.");
            break;

        }
        CString strError = _T("Could not connect to ") + strMachine + _T(". ") + str;
        ErrorMessage(strError,hr);
        SetMessageText(AFX_IDS_IDLEMESSAGE);
        return hr;
    }

    if (SUCCEEDED(rgMQI[0].hr) && rgMQI[0].pItf != NULL)
        m_pClipboard = (IClipboard*)rgMQI[0].pItf;
    else
    {
        // Pop up error message
        if (rgMQI[1].hr && rgMQI[1].pItf != NULL)
            rgMQI[1].pItf->Release();
        EndWaitCursor();
        ErrorMessage("Could not connect to remote server. QueryInterface for IClipboard failed.",hr);
        SetMessageText(AFX_IDS_IDLEMESSAGE);
        return rgMQI[0].hr ;
    }
    
    IConnectionPointContainer* pcpc=NULL;
    if (SUCCEEDED(rgMQI[1].hr) && rgMQI[1].pItf != NULL)
        pcpc = (IConnectionPointContainer*)rgMQI[1].pItf;
    else
    {
        // Pop up error message
        EndWaitCursor();
        if (rgMQI[0].hr && rgMQI[0].pItf != NULL)
            rgMQI[0].pItf->Release();
        ErrorMessage("Could not connect to remote server. QueryInterface for IConnectionPointContainer failed.",hr);
        SetMessageText(AFX_IDS_IDLEMESSAGE);
        return rgMQI[1].hr ;
    }

    ASSERT(m_pClipboard);
    ASSERT(pcpc);
    ASSERT(m_pConnectionPt == NULL);

    strMsg += _T(".");
    SetMessageText(strMsg);

    hr = pcpc->FindConnectionPoint(IID_IClipboardNotify, &m_pConnectionPt);
    if (FAILED(hr))
    {
        // Pop up error message
        EndWaitCursor();
        ErrorMessage("Find Connection Point failed.",hr);

        // Release and get out
        pcpc->Release();
        m_pClipboard->Release();
        m_pClipboard = NULL;
        SetMessageText(AFX_IDS_IDLEMESSAGE);
        return hr;
    }
    pcpc->Release();

    strMsg += _T(".");
    SetMessageText(strMsg);

    // Get our IUnknown
    //
    IUnknown* pClipboardNotify = (IUnknown*)GetInterface(&IID_IUnknown);
    ASSERT(pClipboardNotify);

#ifdef _TEST
    // Test to make sure we can actually get the clipboard
    IDataObject* pdo=NULL;
    hr = m_pClipboard->GetClipboard(&pdo);
    if (FAILED(hr))
    {
        EndWaitCursor();
        // Pop up error message
        CString str = _T("Could not get the remote clipboard.");
        switch (hr)
        {
            case E_ACCESSDENIED:
                str = _T("Access to remote clipboard denied. Make sure the same user is logged on to both computers.");
            break;
        }
        CString strError = _T("Could not connect to ") + strMachine + _T(". ") + str;
        ErrorMessage(strError,hr);

        // Release and get out
        m_pConnectionPt->Release();
        m_pConnectionPt = NULL;
        m_dwConnectionCookie = 0;
        m_pClipboard->Release();
        m_pClipboard = NULL;
        return hr;
    }
    else
        pdo->Release();
#endif

    strMsg += _T(".");
    SetMessageText(strMsg);

    // Call IConnectionPoint::Advise to setup the callbacks
    //
    hr = m_pConnectionPt->Advise(pClipboardNotify, &m_dwConnectionCookie);
    if (FAILED(hr))
    {
        EndWaitCursor();
        // Pop up error message
        CString str = _T("Connection point advise failed.");
        switch (hr)
        {
            case E_ACCESSDENIED:
                str = _T("Access to remote clipboard denied. Make sure the same user is logged on to both computers.");
            break;
        }
        CString strError = _T("Could not connect to ") + strMachine + _T(". ") + str;
        ErrorMessage(strError,hr);

        // Release and get out
        if (m_dwConnectionCookie != NULL)
            m_pConnectionPt->Unadvise(m_dwConnectionCookie);
        m_pConnectionPt->Release();
        m_pConnectionPt = NULL;
        m_dwConnectionCookie = 0;
        m_pClipboard->Release();
        m_pClipboard = NULL;
        SetMessageText(AFX_IDS_IDLEMESSAGE);
        return hr;
    }
    SetMessageText(AFX_IDS_IDLEMESSAGE);
    EndWaitCursor();
    return S_OK;
}

HRESULT CMainFrame::Disconnect()
{
    HRESULT hr = S_OK;
    BeginWaitCursor();
    if (m_pClipboard)
    {
        // We need to tell the remote guy to flush the clipboard.
        // Otherwise he'll still have a pointer to an object
        // we might have passed him.
        // TODO: We can be smarter about this and detect if
        // we've passed out any references to objects?  Set a
        // flag whereever we do m_pClipboard->SetClipboard()?
        //
        // if (m_fSetRemoteClipboard)
            m_pClipboard->FlushClipboard();

        if (m_dwConnectionCookie && m_pConnectionPt)
        {
            m_pConnectionPt->Unadvise(m_dwConnectionCookie);
            m_pConnectionPt->Release();
            m_pConnectionPt = NULL;
            m_dwConnectionCookie=0;
        }
        m_pClipboard->Release();
        m_pClipboard=NULL;
    }
    EndWaitCursor();
    return hr;
}

// We implement the notification interface on the main window
// for convenience.
//
BEGIN_INTERFACE_MAP(CMainFrame, CFrameWnd)
	INTERFACE_PART(CMainFrame, IID_IClipboardNotify, ClipboardNotify)
END_INTERFACE_MAP()

ULONG CMainFrame::XClipboardNotify::AddRef()
{
    METHOD_PROLOGUE(CMainFrame, ClipboardNotify)
    return pThis->ExternalAddRef();
}

ULONG CMainFrame::XClipboardNotify::Release()
{
    METHOD_PROLOGUE(CMainFrame, ClipboardNotify)
    return pThis->ExternalRelease();
}

HRESULT CMainFrame::XClipboardNotify::QueryInterface(
    REFIID iid, void** ppvObj)
{
    METHOD_PROLOGUE(CMainFrame, ClipboardNotify)
    return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT CMainFrame::XClipboardNotify::OnClipboardChanged()
{
    METHOD_PROLOGUE(CMainFrame, ClipboardNotify)
    pThis->OnRefresh(0,0);
    return S_OK;
}

#ifdef _USE_OLEVIEWER
#ifdef _DEBUG
// Pops up the Ole2View 2.0 Uniform Data Transfer viewer on
// the current clipboard.
//
void CMainFrame::OnViewDataObject()
{
    IInterfaceViewer* piv= NULL;
    HRESULT hr = CoCreateInstance(CLSID_IDataObjectViewer, NULL, CLSCTX_SERVER, IID_IInterfaceViewer, (void**)&piv);
    if (SUCCEEDED(hr))
    {
        IDataObject* pdo;
        if (m_pClipboard)
            hr= m_pClipboard->GetClipboard(&pdo);
        else
            hr=OleGetClipboard(&pdo);
        piv->View(AfxGetMainWnd()->GetSafeHwnd(), IID_IDataObject, pdo);
        pdo->Release();
        piv->Release();
    }
    else
        ErrorMessage("Could not load viewer. You must have Ole2View 2.0 installed.", hr);
}

void CMainFrame::OnUpdateViewDataObject(CCmdUI* pCmdUI)
{
}
#endif
#endif

//////////////////////////////////////////////////////////////////
// The main frame supports OLE D&D to/from the clipboard; CDropTarget
// implements our support.
//
CDropTarget::CDropTarget ()
{
}

CDropTarget::~CDropTarget()
{
}

DROPEFFECT CDropTarget::OnDragEnter(CWnd* , COleDataObject* , DWORD , CPoint )
{
    DROPEFFECT de = DROPEFFECT_COPY ;
    return de ;
}

DROPEFFECT CDropTarget::OnDragOver(CWnd*, COleDataObject* , DWORD dwKeyState, CPoint )
{
    DROPEFFECT de ;

    // Prevent d&d'ing on self
    CMainFrame*   pfrm = (CMainFrame*)CWnd::FromHandle(m_hWnd) ;
    CNetClipView* pview = (CNetClipView*)pfrm->GetActiveView();

    // TODO: We should check to make sure the dataobject passed in
    // has a format we can support.
    //

    // check for force link
    if ((dwKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
        de = DROPEFFECT_LINK;
    // check for force copy
    else if ((dwKeyState & MK_CONTROL) == MK_CONTROL)
        de = DROPEFFECT_COPY;
    // check for force move
    else if ((dwKeyState & MK_ALT) == MK_ALT)
        de = DROPEFFECT_MOVE;
    // default -- recommended action is move
    else
        de = DROPEFFECT_MOVE;
    return de;
}

BOOL CDropTarget::OnDrop(CWnd* , COleDataObject* pDataObject, DROPEFFECT , CPoint )
{
    CMainFrame*  pfrm = (CMainFrame*)CWnd::FromHandle(m_hWnd) ;
    CNetClipDoc* pdoc = (CNetClipDoc*)pfrm->GetActiveView()->GetDocument();

    HRESULT hr ;

    // We must make a copy of the data object.  We do this because
    // the provider will have no way of notifying us when he shuts down
    // and we won't know to call OleFlushClipboard.  By making a copy
    // of the data object, *we* get to call OleFushClipboard when *we*
    // shutdown.
    //
    // CGenericDataObject is a simple IDataObject implementation that
    // will accept any data format for ::SetData, copying the
    // data and making it available via ::GetData. It's very similar
    // to COleDataSource, except that it works with ANY formatetc
    // and stgmedium.
    //
    // This means that there is a difference between doing
    // a Edit.Copy in an application and draging onto the viewer. Edit.Copy
    // means delayed rendering, D&D means cached rendering. The only way
    // for this to be fixed is for OLE to provide a mechanism (unlikely).
    //
    CGenericDataObject* pGeneric = new CGenericDataObject(pDataObject->m_lpDataObject);
    ASSERT(pGeneric);
    if (pGeneric==NULL)
        return FALSE;

    IDataObject* pdo = (IDataObject*)pGeneric->GetInterface(&IID_IDataObject);
    ASSERT(pdo);

    if (pfrm->m_pClipboard)
        hr = pfrm->m_pClipboard->SetClipboard(pdo);
    else
        hr = OleSetClipboard(pdo);

    // If OleSetClipboard succeeded, it AddRef'd pdo.  If it failed, it didn't.
    // In either case, we release
    //
    pdo->Release();

    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\doc.h ===
// NetClipDoc.h : interface of the CNetClipDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CNetClipDoc : public CRichEditDoc
{
protected: // create from serialization only
	CNetClipDoc();
	DECLARE_DYNCREATE(CNetClipDoc)

// Attributes
public:

// Operations
public:

// Overrides
	virtual CRichEditCntrItem* CreateClientItem(REOBJECT* preo) const;
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetClipDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void DeleteContents();
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNetClipDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CNetClipDoc)
	afx_msg void OnFileSaveAs();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

friend class CNetClipApp;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////
class CNetClipView;

// The main frame supports OLE D&D to/from the clipboard; CDropTarget
// implements our support.
//
class CDropTarget : public COleDropTarget
{
public:
	CDropTarget();
	virtual ~CDropTarget();

    virtual DROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual BOOL OnDrop(CWnd* pWnd, COleDataObject* pDataObject,
		DROPEFFECT dropEffect, CPoint point);
};

class CMainFrame : public CFrameWnd
{
public:
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)
    BOOL SavePosition(LPCTSTR szName) ;
    BOOL RestorePosition(LPCTSTR szName, int nCmdShow) ;
    LPTSTR GetNameOfClipboardFormat(CLIPFORMAT cf);

// Attributes
protected:
public:
                        // name of machine we're connected to
	CString             m_strMachine;
                        // remote clipboard
	IClipboard*         m_pClipboard;
                        // OLE D&D support
    CDropTarget         m_dropTarget;
                        // Helper pointer to our view class
    CNetClipView*       m_pNetClipView;
                        // Display embeddings as icon
    BOOL                m_fDisplayAsIcon;

                        // Currently selected clipformat or 0 for auto
    UINT                m_cfDisplay;
                        // Array of formats currently on clipboard
    UINT                m_rgFormats[ID_DISPLAY_LAST-ID_DISPLAY_FIRST];
                        // For clipboard chaining
    HWND                m_hwndNextCB;

                        // Connection point connection cookie
    DWORD               m_dwConnectionCookie;
                        // Connection point for IClipboardNotify
    IConnectionPoint*   m_pConnectionPt;

                        // prevent multiple refreshes.
	BOOL                m_fRefreshPosted;

    // Operations
public:
	HRESULT Connect(CString &strMachine);
	HRESULT Disconnect();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnDisplayAuto();
	afx_msg void OnUpdateDisplayAuto(CCmdUI* pCmdUI);
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
	afx_msg void OnDrawClipboard();
	afx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);
	afx_msg void OnEditClear();
	afx_msg void OnUpdateEditClear(CCmdUI* pCmdUI);
	afx_msg void OnConnectConnect();
	afx_msg void OnUpdateConnectConnect(CCmdUI* pCmdUI);
	afx_msg void OnConnectDisconnect();
	afx_msg void OnUpdateConnectDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
    afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
#ifndef _NTBUILD
#ifdef _DEBUG
	afx_msg void OnViewDataObject();
	afx_msg void OnUpdateViewDataObject(CCmdUI* pCmdUI);
#endif
#endif
    afx_msg void OnOtherFormat( UINT nID );
	afx_msg void OnUpdateOtherFormat(CCmdUI* pCmdUI);
    afx_msg LRESULT OnRefresh(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

	DECLARE_INTERFACE_MAP()

    BEGIN_INTERFACE_PART(ClipboardNotify, IClipboardNotify)
        virtual HRESULT __stdcall OnClipboardChanged(void);
    END_INTERFACE_PART(ClipboardNotify)

friend class CNetClipApp;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\guids.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	NetClip.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"


#include <initguid.h>
#include "guids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\doc.cpp ===
// NetClipDoc.cpp : implementation of the CNetClipDoc class
//

#include "stdafx.h"
#include "netclipapp.h"
#include "Doc.h"
#include "View.h"

#include "MainFrm.h"

#include "guids.h"

#include "cntritem.h"
#include "DataObj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetClipDoc

IMPLEMENT_DYNCREATE(CNetClipDoc, CRichEditDoc)

BEGIN_MESSAGE_MAP(CNetClipDoc, CRichEditDoc)
	//{{AFX_MSG_MAP(CNetClipDoc)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNetClipDoc construction/destruction

CNetClipDoc::CNetClipDoc()
{
    EnableCompoundFile();
}

CNetClipDoc::~CNetClipDoc()
{
}

// We never prompt if the user closes/opens etc..
//
BOOL CNetClipDoc::SaveModified()
{
    return 1;
}

void CNetClipDoc::DeleteContents()
{
	CRichEditDoc::DeleteContents();
}

BOOL CNetClipDoc::OnNewDocument()
{
    SetModifiedFlag(TRUE);
    // Default implementation calls DeleteContents
	if (!CRichEditDoc::OnNewDocument())
		return FALSE;

    return TRUE;
}

// OnOpenDocument attempts to open the specified docfile and
// uses the IPersistStorage::Load method of the generic data object
// to read the data.
//
// We do not keep the file open.
//
BOOL CNetClipDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
	USES_CONVERSION;

	ASSERT(lpszPathName);

	// abort changes to current docfile
	DeleteContents();
    if(m_lpRootStg)
    {
    	m_lpRootStg->Release();
        m_lpRootStg = NULL;
    }

	BOOL bResult = FALSE;
	try
	{
		LPCOLESTR lpsz = T2COLE(lpszPathName);

		// use STGM_CONVERT if necessary
		SCODE sc;
		LPSTORAGE lpStorage = NULL;
		// open new storage file
		sc = StgOpenStorage(lpsz, NULL,
			STGM_READWRITE|STGM_TRANSACTED|STGM_SHARE_EXCLUSIVE,
			0, 0, &lpStorage);
		if (FAILED(sc) || lpStorage == NULL)
			sc = StgOpenStorage(lpsz, NULL,
				STGM_READ|STGM_TRANSACTED|STGM_SHARE_EXCLUSIVE,
				0, 0, &lpStorage);
		if (FAILED(sc))
			AfxThrowOleException(sc);

		ASSERT(lpStorage != NULL);
		m_lpRootStg = lpStorage;

		// Create a generic IDataObject, and initialize it
        // with the storage.  Then set the clipboard.
        //
        HRESULT hr;
        CGenericDataObject* pGeneric = new CGenericDataObject();
        IPersistStorage* pPersist = (IPersistStorage*)pGeneric->GetInterface(&IID_IPersistStorage);
        ASSERT(pPersist);

        hr = pPersist->Load(m_lpRootStg);
        if (FAILED(hr))
        {
            pPersist->Release();
            AfxThrowOleException(hr);
        }

        CMainFrame* pfrm = (CMainFrame*)AfxGetMainWnd();
        ASSERT(pfrm);
        IDataObject* pdo = (IDataObject*)pGeneric->GetInterface(&IID_IDataObject);
        ASSERT(pdo);
        if (pfrm->m_pClipboard == NULL)
            hr = OleSetClipboard(pdo);
        else
            hr = pfrm->m_pClipboard->SetClipboard(pdo);

        // We could use either pdo or pPersist here because
        // GetInterface does not AddRef
        pdo->Release();

        if (FAILED(hr))
            AfxThrowOleException(hr);

        if (m_lpRootStg)
        {
    		m_lpRootStg->Release();
            m_lpRootStg = NULL;
        }
		SetModifiedFlag(TRUE);
		bResult = TRUE;
	}
	catch(CException* e)
	{
		DeleteContents();   // removed failed contents
        if (m_lpRootStg)
        {
    		m_lpRootStg->Release();
            m_lpRootStg = NULL;
        }

		// if not file-based load, return exceptions to the caller
		if (lpszPathName == NULL)
		{
			throw;
			ASSERT(FALSE);  // not reached
		}

		try
		{
			ReportSaveLoadException(lpszPathName, e,
				FALSE, AFX_IDP_FAILED_TO_OPEN_DOC);
		}
		catch(...)
        {}

		e->Delete();
	}
	
	return bResult;
}

void CNetClipDoc::OnFileSaveAs()
{
	if (!DoSave(NULL, FALSE)) { // bReplace == FALSE means don't change m_strPathName
		TRACE0("Warning: File save-as failed.\n");
    }
}

// OnSaveDocument creates the specified docfile and uses
// the IPeristStorage::Save method of the generic data object
// to save the clipboard.
//
BOOL CNetClipDoc::OnSaveDocument(LPCTSTR lpszPathName)
	// lpszPathName must be fully qualified
{
    USES_CONVERSION;
	ASSERT(lpszPathName);

	BOOL bResult = FALSE;

    if (m_lpRootStg)
    {
    	m_lpRootStg->Release();
        m_lpRootStg = NULL;
    }

	try
	{
		LPSTORAGE lpStorage;
		SCODE sc = ::StgCreateDocfile(T2COLE(lpszPathName),
			STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
			0, &lpStorage);
		if (sc != S_OK)
			AfxThrowOleException(sc);

		ASSERT(lpStorage != NULL);
		m_lpRootStg = lpStorage;

        // Copy clipboard dataobject.  CGenericDataObject implements
        // IPersistStorage, we just pass him our IStorage and he does
        // all the work.
        CMainFrame* pfrm = (CMainFrame*)AfxGetMainWnd();
        ASSERT(pfrm);
        IDataObject* pdo ;
        HRESULT hr;
        if (pfrm->m_pClipboard == NULL)
            hr = OleGetClipboard(&pdo);
        else
            hr = pfrm->m_pClipboard->GetClipboard(&pdo);
        if (FAILED(hr))
            AfxThrowOleException(hr);

        CGenericDataObject* pGeneric = new CGenericDataObject(pdo);
        pdo->Release();

        COleMessageFilter* pFilter = AfxOleGetMessageFilter();
	    ASSERT(pFilter != NULL);
	    pFilter->EnableBusyDialog(FALSE);

        IPersistStorage* pPersist = (IPersistStorage*)pGeneric->GetInterface(&IID_IPersistStorage);
        ASSERT(pPersist);
        hr = pPersist->Save(m_lpRootStg, FALSE);
        pPersist->Release();
	    pFilter->EnableBusyDialog(TRUE);

        if (FAILED(hr))
            AfxThrowOleException(hr);

		m_lpRootStg->Release();
		m_lpRootStg = NULL;

		SetModifiedFlag(TRUE);
		bResult = TRUE;
	}
	catch(CException* e)
	{

        if (m_lpRootStg)
        {
    		m_lpRootStg->Release();
	    	m_lpRootStg = NULL;
        }

		try
		{
			ReportSaveLoadException(lpszPathName, e,
				TRUE, AFX_IDP_FAILED_TO_SAVE_DOC);
		}
		catch(...)
        {
        }
		e->Delete();
	}
	
	// cleanup
	m_bSameAsLoad = FALSE;
	//m_bRemember = TRUE;

	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CNetClipDoc diagnostics

#ifdef _DEBUG
void CNetClipDoc::AssertValid() const
{
	CRichEditDoc::AssertValid();
}

void CNetClipDoc::Dump(CDumpContext& dc) const
{
	CRichEditDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CNetClipDoc commands

CRichEditCntrItem* CNetClipDoc::CreateClientItem(REOBJECT* preo) const
{
	// cast away constness of this
	return new CNetClipCntrItem(preo, (CNetClipDoc*)this);
}

#if 0
void CWordPadDoc::OnFileSendMail()
{
	if (m_strTitle.Find('.') == -1)
	{
		// add the extension because the default extension will be wrong
		CString strOldTitle = m_strTitle;
		m_strTitle += GetExtFromType(m_nDocType);
		CRichEditDoc::OnFileSendMail();
		m_strTitle = strOldTitle;
	}
	else
		CRichEditDoc::OnFileSendMail();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\netclip.cpp ===
// NetClip.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "netclipapp.h"
#include "Server.h"

#include "MainFrm.h"
#include "Doc.h"
#include "View.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetClipApp

BEGIN_MESSAGE_MAP(CNetClipApp, CWinApp)
	//{{AFX_MSG_MAP(CNetClipApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

OSVERSIONINFO  g_osvi ;
BOOL g_fDCOM = FALSE;

BOOL RegisterSupportDLLs(CWnd* pParent,BOOL fForce /*=FALSE*/);
/////////////////////////////////////////////////////////////////////////////
// CNetClipApp construction

CNetClipApp::CNetClipApp()
{
    m_fNoUpdate = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CNetClipApp object

CNetClipApp theApp;


#include <winreg.h>
#define ERROR_BADKEY_WIN16 2 // needed when running on Win32s

LONG RecursiveRegDeleteKey(HKEY hParentKey, LPCTSTR szKeyName)
{
	DWORD   dwIndex = 0L;
	TCHAR   szSubKeyName[256];
	HKEY    hCurrentKey = NULL;
	DWORD   dwResult;

	if (((dwResult = RegOpenKey(hParentKey, szKeyName, &hCurrentKey)) ==
		ERROR_SUCCESS) && hCurrentKey)
	{
		// Remove all subkeys of the key to delete
		while ((dwResult = RegEnumKey(hCurrentKey, 0, szSubKeyName, 255)) ==
			ERROR_SUCCESS)
		{
			if ((dwResult = RecursiveRegDeleteKey(hCurrentKey,
				szSubKeyName)) != ERROR_SUCCESS)
				break;
		}

		// If all went well, we should now be able to delete the requested key
		if ((dwResult == ERROR_NO_MORE_ITEMS) || (dwResult == ERROR_BADKEY) ||
			(dwResult == ERROR_BADKEY_WIN16))
		{
			dwResult = RegDeleteKey(hParentKey, szKeyName);
		}
		RegCloseKey(hCurrentKey);
	}

	return dwResult;
}

#ifdef _FEATURE_SERVICE
// When we're started with the /service command line switch
// we run as a service (we assume we've been started via Network OLE's
// LocalService32 mechanism).
//
VOID WINAPI NetClipServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
{
    // This is called on a new thread so we have to call
    // OleInitialize
    //
    HRESULT hr ;
    if (FAILED(hr = AfxOleInit())) //OleInitialize(NULL)))
    {
        ErrorMessage( _T("Could not initialize OLE; NetClip cannot run."), hr ) ;
        return ;
    }

	// Application was run with /Embedding or /Automation.  Don't show the
	//  main window in this case.
	theApp.m_fServing = TRUE;

	// Register all OLE server (factories) as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleObjectFactory::RegisterAll();

}
#endif

class CMyCommandLineInfo : public CCommandLineInfo
{
public:
#ifdef _FEATURE_SERVICE
    BOOL m_bRunAsService;
#endif
    BOOL m_bSelfReg;
    BOOL m_bSelfUnReg;
    BOOL m_bServer;
    CMyCommandLineInfo()
        {
#ifdef _FEATURE_SERVICE
          m_bRunAsService = FALSE;
#endif
          m_bSelfReg = FALSE;
          m_bSelfUnReg = FALSE;
          m_bServer = FALSE;
        };
    virtual ~CMyCommandLineInfo() {};
    virtual void ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast );
};

void CMyCommandLineInfo::ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast)
{
    CString strParam(pszParam);
#ifdef _FEATURE_SERVICE
    if (strParam.CompareNoCase(_T("service")) == 0)
        m_bRunAsService = TRUE;
    else
#endif
        if (strParam.CompareNoCase(_T("regserver")) == 0)
        m_bSelfReg = TRUE;
    else if (strParam.CompareNoCase(_T("unregserver")) == 0)
        m_bSelfUnReg = TRUE;
    else if (strParam.CompareNoCase(_T("server")) == 0)
        m_bServer = TRUE;
    else
        CCommandLineInfo::ParseParam(pszParam, bFlag, bLast);
}

/////////////////////////////////////////////////////////////////////////////
// CNetClipApp initialization

BOOL CNetClipApp::InitInstance()
{
	USES_CONVERSION;

    HRESULT hr;
    g_osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;
    GetVersionEx(&g_osvi);

    HINSTANCE hinst ;
	hinst = LoadLibrary( _T("OLE32.DLL") ) ;
    if (hinst > (HINSTANCE)HINSTANCE_ERROR)
    {
        // See if we're DCOM enabled
        HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
        (FARPROC&)lpDllEntryPoint = GetProcAddress(hinst, "CoCreateInstanceEx");
        if (lpDllEntryPoint)
        {
            HKEY hkey=NULL;
            RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Ole"), &hkey);
            if (hkey!=NULL)
            {
                TCHAR sz[16];
                DWORD cb = sizeof(sz)/sizeof(sz[0]);
                *sz = '\0';
                RegQueryValueEx(hkey, _T("EnableDCOM"), NULL, NULL, (BYTE*)sz, &cb);
                if (*sz == _T('Y') || *sz == _T('y'))
                    g_fDCOM = TRUE;
            }
        }
        FreeLibrary(hinst);
    }

    // Parse command line for standard shell commands, DDE, file open
	CMyCommandLineInfo cmdInfo;
#ifdef _NTBUILD
    // For some reason the implementation of ParseCommandLine in NT 4.0's MFC
    // does not pick up __argc.  Hence this hack.
    //
	for (int i = 1; i < __argc; i++)
	{
#ifdef _UNICODE
		LPCTSTR pszParam = __wargv[i];
#else
		LPCTSTR pszParam = __argv[i];
#endif
		BOOL bFlag = FALSE;
		BOOL bLast = ((i + 1) == __argc);
		if (pszParam[0] == _T('-') || pszParam[0] == _T('/'))
		{
			// remove flag specifier
			bFlag = TRUE;
			++pszParam;
		}
#if _MFC_VER >= 0x0420
		cmdInfo.ParseParam(T2CA(pszParam), bFlag, bLast);
#else
		cmdInfo.ParseParam(T2A(pszParam), bFlag, bLast);
#endif
	}
#else
	ParseCommandLine(cmdInfo);
#endif

    if (cmdInfo.m_bSelfUnReg == TRUE)
    {
        // Un-register nclipps.dll
	    HINSTANCE hinst = LoadLibrary(_T("NCLIPPS.DLL")) ;
        if (hinst > (HINSTANCE)HINSTANCE_ERROR)
        {
            // Get DllUnRegisterServer function
            HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
            (FARPROC&)lpDllEntryPoint = GetProcAddress(hinst, "DllUnregisterServer");
            if (lpDllEntryPoint)
                (*lpDllEntryPoint)() ;
            FreeLibrary(hinst);
        }

        // Un-register ourselves
        OLECHAR szCLSID[40];
        StringFromGUID2(CNetClipServer::guid, szCLSID, 40);
        CString strReg;
    #ifdef _UNICODE
        strReg.Format(_T("AppID\\%s"), szCLSID);
    #else
        strReg.Format(_T("AppID\\%S"), szCLSID);
    #endif
        RecursiveRegDeleteKey(HKEY_CLASSES_ROOT, strReg);

    #ifdef _UNICODE
        strReg.Format(_T("CLSID\\%s"), szCLSID);
    #else
        strReg.Format(_T("CLSID\\%S"), szCLSID);
    #endif
        RecursiveRegDeleteKey(HKEY_CLASSES_ROOT, strReg);

        strReg = _T("Remote Clipboard");
        RecursiveRegDeleteKey(HKEY_CLASSES_ROOT, strReg);

        return TRUE;
    }

    if (!(cmdInfo.m_bServer || cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated))
    {
        // Run client
        HKEY hkey;
        OLECHAR szCLSID[40];
        StringFromGUID2(CNetClipServer::guid, szCLSID, 40);
        CString strReg;
        TCHAR sz[] = _T("Remote Clipboard");

    #ifdef _UNICODE
        strReg.Format(_T("AppID\\%s"), szCLSID);
    #else
        strReg.Format(_T("AppID\\%S"), szCLSID);
    #endif
        hr = RegCreateKey(HKEY_CLASSES_ROOT, strReg, &hkey);
        if (hr == ERROR_SUCCESS)
        {
            hr = RegSetValueEx(hkey, _T(""), 0, REG_SZ, (BYTE*)sz, lstrlen(sz));
            lstrcpy(sz, _T("Interactive User"));
            hr = RegSetValueEx(hkey, _T("RunAs"), 0, REG_SZ, (BYTE*)sz, lstrlen(sz));
            RegCloseKey(hkey);

            COleObjectFactory::UpdateRegistryAll();

    #ifdef _UNICODE
            strReg.Format(_T("CLSID\\%s"), szCLSID);
    #else
            strReg.Format(_T("CLSID\\%S"), szCLSID);
    #endif
            hr = RegCreateKey(HKEY_CLASSES_ROOT, strReg, &hkey);
            if (hr == ERROR_SUCCESS)
            {
                lstrcpy(sz, _T("Remote Clipboard"));
                TCHAR* p = W2T(szCLSID);
                hr = RegSetValueEx(hkey, _T(""), 0, REG_SZ, (BYTE*)sz, lstrlen(sz));
                if (hr == ERROR_SUCCESS)
                    hr = RegSetValueEx(hkey, _T("AppID"), 0, REG_SZ, (BYTE*)p, lstrlen(p));
                RegCloseKey(hkey);
            }
        }

        if (hr != ERROR_SUCCESS)
        {
            AfxMessageBox(IDS_SELFREFFAILED);
            return FALSE;
        }

        if (!RegisterSupportDLLs(AfxGetMainWnd(), FALSE))
        {
            //AfxMessageBox(IDS_SELFREFFAILED);
            //return FALSE;
        }

        if (cmdInfo.m_bSelfReg)
            return TRUE;
    }

#ifdef _FEATURE_SERVICE
    // Check to see if launched as an NT service
	if (cmdInfo.m_bRunAsService)
	{
        // We must run as a service
        //
        SERVICE_TABLE_ENTRY ste;
        ste.lpServiceName = _T("Remote OLE Clipboard Server");
        ste.lpServiceProc = NetClipServiceMain;

        if (!StartServiceCtrlDispatcher(&ste))
        {
            // Error!
            TRACE(_T("StartServiceCtrlDispatcher failed!"));
            return FALSE;
        }
	}
    else
#endif

    {
        // Standard initialization
        if (FAILED(hr = AfxOleInit())) //OleInitialize(NULL)))
        {
            ErrorMessage( _T("Could not initialize OLE; NetClip cannot run."), hr ) ;
            return FALSE;
        }

        if (cmdInfo.m_bServer || cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
        {
	        // Application was run with /Embedding or /Automation.  Don't show the
	        //  main window in this case.
	        theApp.m_fServing = TRUE;

            // MFC is hard coded internally to set user control to true if
            // "Embedding" or "Automation" are not found on the cmd line. 
            // We like "server" better (more intuitive) so we force user control
            // to be false here if "server" is detected.
            //
            AfxOleSetUserCtrl(FALSE);

	        // Register all OLE server (factories) as running.  This enables the
	        //  OLE libraries to create objects from other applications.
	        COleObjectFactory::RegisterAll();
            return TRUE;
        }

        SetRegistryKey( IDS_REGISTRYKEY );

    #ifdef _AFXDLL
	    Enable3dControls();			// Call this when using MFC in a shared DLL
    #else
	    Enable3dControlsStatic();	// Call this when linking to MFC statically
    #endif
	    // Register the application's document templates.  Document templates
	    //  serve as the connection between documents, frame windows and views.
        //
        // Assume that we're running on a non-DCOM system. Check for CoCreateInstanceEx
        // to see if DCOM is around.

	    CSingleDocTemplate* pDocTemplate;
        UINT    nResources = IDR_NONETOLE;
        if (g_fDCOM)
            nResources = IDR_MAINFRAME;

	    pDocTemplate = new CSingleDocTemplate(
		    nResources,
		    RUNTIME_CLASS(CNetClipDoc),
		    RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		    RUNTIME_CLASS(CNetClipView));
	    AddDocTemplate(pDocTemplate);

        HRESULT hr = S_OK;
		m_fServing = FALSE;
        int nCmdShow = m_nCmdShow ;
        m_nCmdShow = SW_HIDE ;
        OnFileNew() ;
        CMainFrame* pfrm = (CMainFrame*)GetMainWnd();
        pfrm->RestorePosition(m_lpCmdLine, nCmdShow);
        if (m_lpCmdLine && *m_lpCmdLine)
        {
            if (SUCCEEDED(pfrm->Connect(CString(m_lpCmdLine))))
            {
                pfrm->m_strMachine = m_lpCmdLine;
                pfrm->SetWindowText(pfrm->m_strMachine + _T(" - NetClip"));
            }
            else
            {
                CString str;
                str.Format(_T("Could not connect to the remote clipboard object on %s."), m_lpCmdLine);
                ErrorMessage(str, hr);
            }
        }
        else
        {
            ((CMainFrame*)GetMainWnd())->OnConnectDisconnect();
        }
    }

    return TRUE;
}

CDocument* CNetClipApp::OpenDocumentFile(LPCTSTR lpszFileName)
{
    CNetClipDoc* pdoc;
    if (pdoc = (CNetClipDoc*)CWinApp::OpenDocumentFile(lpszFileName))
    {
	    pdoc->m_strPathName.Empty();      // no path name yet
    }
    return pdoc;
}

// App command to run the dialog
void CNetClipApp::OnAppAbout()
{
    TCHAR szVersion[64] ;
    BYTE* pdata=NULL;
	TCHAR szFileName[_MAX_PATH] ;
	::GetModuleFileName(NULL, szFileName, _MAX_PATH) ;

    wsprintf( szVersion, _T("NetClip build 1.00 - %s"),(LPTSTR)__DATE__  );
#ifndef _MAC
    DWORD dwDummy ;
    DWORD dw = ::GetFileVersionInfoSize(szFileName, &dwDummy) ;
    if (dw)
    {
        pdata = new BYTE[dw] ;
        if (pdata && ::GetFileVersionInfo(szFileName, NULL, dw, pdata))
        {
			DWORD* pdwBuffer ;
			// Get the translation information.
			BOOL bResult = ::VerQueryValue( pdata,
							  _T("\\VarFileInfo\\Translation"),
							  (void**)&pdwBuffer,
							  (UINT*)&dw);
		    if (!bResult || !dw) goto NastyGoto ;

			// Build the path to the OLESelfRegister key
			// using the translation information.
			TCHAR szName[64] ;
			wsprintf( szName,
					 _T("\\StringFileInfo\\%04hX%04hX\\FileVersion"),
					 LOWORD(*pdwBuffer),
					 HIWORD(*pdwBuffer)) ;

		    // Search for the key.
		    bResult = ::VerQueryValue( pdata,
									   szName,
									   (void**)&pdwBuffer,
									   (UINT*)&dw);
		    if (!bResult || !dw) goto NastyGoto ;

#ifdef _UNICODE
            wsprintf( szVersion, _T("NetClip build %s - %S"),  (LPCTSTR)pdwBuffer, (LPSTR)__DATE__ ) ;
#else
            wsprintf( szVersion, _T("NetClip build - %s"),  (LPCTSTR)pdwBuffer, (LPSTR)__DATE__ ) ;
#endif
        }
NastyGoto:
        if (pdata)
            delete []pdata ;
    }
#endif // !_MAC

#ifdef _DEBUG
	lstrcat(szVersion, _T(" Debug Build") ) ;
#endif
    lstrcat(szVersion, _T("\nWritten by Charlie Kindel"));
    ShellAbout(AfxGetMainWnd()->GetSafeHwnd(),AfxGetAppName( ), szVersion, LoadIcon(IDR_MAINFRAME));
}

/////////////////////////////////////////////////////////////////////////////
// CNetClipApp commands

int CNetClipApp::ExitInstance()
{
    OleFlushClipboard();

	return CWinApp::ExitInstance();
}


// This function attempts to register the any supporting DLLs
// such as NetClipPS.DLL
//
BOOL RegisterSupportDLLs(CWnd* pParent,BOOL fForce /*=FALSE*/)
{
//	CFileDialog

    CString str ;
    CString str2 ;
	CString strSupportDLL = _T("NCLIPPS.DLL") ;
    HINSTANCE hinst ;
	BOOL	fRet = FALSE ;

TryToLoad:	
	hinst = LoadLibrary( strSupportDLL ) ;
    if (hinst > (HINSTANCE)HINSTANCE_ERROR)
    {
        // Get DllRegisterServer function
        HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
        (FARPROC&)lpDllEntryPoint = GetProcAddress(hinst, "DllRegisterServer");
        if (lpDllEntryPoint)
        {
            HRESULT hr ;
            if (FAILED(hr = (*lpDllEntryPoint)()))
            {
                str.LoadString( IDS_AUTOREGFAILED ) ;
                str2.LoadString( IDS_AUTOREGFAILED2 ) ;
                str += str2 ;
                AfxMessageBox( str ) ;
            }
			else
				fRet = TRUE ;
        }
        else
        {
            str.LoadString( IDS_AUTOREGFAILED3 ) ;
            str2.LoadString( IDS_AUTOREGFAILED2 ) ;
            str += str2 ;
            AfxMessageBox( str ) ;
        }

        FreeLibrary( hinst ) ;
    }
    else
    {
        str.LoadString( IDS_AUTOREGFAILED1 ) ;
        str2.LoadString( IDS_AUTOREGFAILED2 ) ;
        str += str2 ;
        str2.LoadString( IDS_AUTOREGFAILED4 ) ;
        str += str2 ;
        if (AfxMessageBox( str, MB_YESNO ) == IDYES)
		{
			static TCHAR szFilter[] = _T("DLL Files (*.dll)|*.dll|AllFiles(*.*)|*.*|") ;

			CFileDialog dlg(TRUE, _T("NCLIPPS.DLL"), NULL,
							OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
							szFilter, pParent);
			if (IDOK == dlg.DoModal())
			{
				strSupportDLL = dlg.GetPathName() ;
				goto TryToLoad;
			}
		}
    }

	return fRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	NetClip.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"


#include <initguid.h>
#include "guids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\svrdlg.cpp ===
// ServerInfoDlg.cpp : implementation file
//

#include "stdafx.h"
#include "netclipapp.h"
#include "SvrDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServerInfoDlg dialog


CServerInfoDlg::CServerInfoDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CServerInfoDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServerInfoDlg)
	m_strMachine = _T("");
	//}}AFX_DATA_INIT
}


void CServerInfoDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerInfoDlg)
	DDX_Text(pDX, IDC_MACHINE, m_strMachine);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerInfoDlg, CDialog)
	//{{AFX_MSG_MAP(CServerInfoDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerInfoDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\netclipapp.h ===
// NetClipApp.h : main header file for the NETCLIP application
//
#ifndef _NETCLIPAPP_H_
#define _NETCLIPAPP_H_

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CNetClipApp:
// See NetClip.cpp for the implementation of this class
//
class CNetClipServer;

class CNetClipApp : public CWinApp
{
public:
	CNetClipApp();

    BOOL m_fServing ;
    BOOL m_fNoUpdate;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetClipApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName);
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CNetClipApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

extern CNetClipApp      theApp ;
extern OSVERSIONINFO    g_osvi ;
extern BOOL             g_fDCOM ;

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NetClip.rc
//
#define IDS_REGISTRYKEY                 17
#define IDS_AUTOREGFAILED1              18
#define IDS_AUTOREGFAILED2              19
#define IDS_AUTOREGFAILED3              20
#define IDS_AUTOREGFAILED4              21
#define IDS_AUTOREGFAILED               22
#define IDS_SELFREFFAILED               23
#define IDS_STATUS_UPDATE               24
#define IDS_STATUS_GETTING_CLIPDATA     25
#define IDS_STATUS_GETLOCAL             26
#define IDS_STATUS_SETLOCAL             27
#define IDS_STATUS_GETREMOTE            28
#define IDS_STATUS_SETREMOTE            29
#define IDS_STATUS_CONNECTING           30
#define IDD_ABOUTBOX                    100
#define IDC_VERSION                     101
#define IDC_APPNAME                     104
#define IDC_COPYRIGHT                   105
#define IDC_ALLRIGHTSRESERVED           106
#define IDC_WRITTENBY                   107
#define IDC_GROUP                       108
#define IDC_MACHINE                     127
#define IDR_MAINFRAME                   128
#define IDR_NONETOLE                    129
#define IDB_BITMAP1                     130
#define IDD_SERVERINFO                  131
#define IDR_NETCLITYPE                  131
#define ID_CONNECT_CONNECT              32771
#define ID_CONNECT_DISCONNECT           32773
#define ID_DISPLAY_AUTO                 32774
#define ID_DISPLAY_VIEWDATAOBJECT       32775
#define ID_DISPLAY_TEXT                 32776
#define ID_DISPLAY_OEMTEXT              32777
#define ID_DISPLAY_FIRST                32778
#define ID_DISPLAY_LAST                 32878
#define ID_EDIT_DELETE                  32880
#define ID_VIEWDATAOBJECT               32881
#define ID_CONNECTION_PERMISSIONS       32881
#define ID_EDIT_COPYTOLOCALCLIPBOARD    32882
#define ID_EDIT_CUTLOCAL                32883
#define ID_EDIT_COPYLOCAL               32885
#define ID_EDIT_PASTELOCAL              32886

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        143
#define _APS_NEXT_COMMAND_VALUE         32887
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\server.cpp ===
// NetClipServer.cpp : CNetClipServer implementation file
//
// Implements the remote clipboard object (IClipboard)
//
#include "stdafx.h"
#include "NetClipApp.h"
#include "Server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CNetClipObjectFactory::CNetClipObjectFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass, BOOL bMultiInstance, LPCTSTR lpszProgID) :
        COleObjectFactory(clsid, pRuntimeClass, bMultiInstance, lpszProgID)
{
}

// We override OnCreateObject so we can create a window that we register
// in the clipboard viewer chain
CCmdTarget* CNetClipObjectFactory::OnCreateObject()
{
    CNetClipServer* p =(CNetClipServer*)COleObjectFactory::OnCreateObject();

	// make sure it is a CNetClipServer
	ASSERT_KINDOF(CNetClipServer, p);
	ASSERT_VALID(p);

    // Create our window
    //
    if (0 == p->CreateEx(0, AfxRegisterWndClass(0), _T("Serving Clipboard"), WS_OVERLAPPEDWINDOW, 0,0,0,0, NULL, 0))
    	AfxThrowMemoryException();

	// return the new CCmdTarget object
	return p;
}

BOOL CNetClipObjectFactory::Register()
{
	ASSERT_VALID(this);
	ASSERT(!m_bRegistered);  // registering server/factory twice?
	ASSERT(m_clsid != CLSID_NULL);

	SCODE sc = ::CoRegisterClassObject(m_clsid, &m_xClassFactory,
		CLSCTX_LOCAL_SERVER,
		m_bMultiInstance ? REGCLS_SINGLEUSE : REGCLS_MULTIPLEUSE,
		&m_dwRegister);
	if (sc != S_OK)
	{
#ifdef _DEBUG
		TRACE1("Warning: CoRegisterClassObject failed scode = %s.\n",
			::AfxGetFullScodeString(sc));
#endif
		// registration failed.
		return FALSE;
	}
	ASSERT(m_dwRegister != 0);

	++m_bRegistered;

    // On Win95 we act as a daemon...that is, once started via "netclip /server"
    // we never shut down until killed.
    //
    // On NT only "netclip /Embedding" will cause us to stay around, and we'll
    // exit as soon as the last client releases us.
    //
    // We accomplish this by forcing an additional "App lock". MFC will not
    // revoke the class factory unless the app lock goes to zero...
    //
    if (g_osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        AfxOleLockApp();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CNetClipServer

IMPLEMENT_DYNCREATE(CNetClipServer, CWnd)

CNetClipServer::CNetClipServer()
{
    // We need to enable MFC IConnectionPointContainer support
    EnableConnections();

	// To keep the application running as long as an OLE
	//	object is active, the constructor calls AfxOleLockApp	
	AfxOleLockApp();

    m_hwndNextCB = NULL;
}

CNetClipServer::~CNetClipServer()
{
	// To terminate the application when all objects created with
	// 	with OLE, the destructor calls AfxOleUnlockApp.
	AfxOleUnlockApp();
}

void CNetClipServer::OnFinalRelease()
{
	// When the last reference for an object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

    // OnFinalRelease will destroy our window for us.
	CWnd::OnFinalRelease();

    // CWnd does not automatically delete the object so we have
    // to do it ourselves.
    delete this;
}

#define WM_SENDONCLPBOARDCHANGED (WM_USER+1)
BEGIN_MESSAGE_MAP(CNetClipServer, CWnd)
	//{{AFX_MSG_MAP(CNetClipServer)
	ON_WM_DRAWCLIPBOARD()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_CHANGECBCHAIN()
	//}}AFX_MSG_MAP
    ON_MESSAGE( WM_SENDONCLPBOARDCHANGED, OnSendOnClipboardChanged)
END_MESSAGE_MAP()

int CNetClipServer::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
    // Register as a clipboard viewer
    m_hwndNextCB = SetClipboardViewer();
	return 0;
}

void CNetClipServer::OnDestroy()
{
    //if (m_hwndNextCB)
        ChangeClipboardChain(m_hwndNextCB);
    m_hwndNextCB = NULL;
    CWnd::OnDestroy();
}

void CNetClipServer::OnChangeCbChain(HWND hWndRemove, HWND hWndAfter)
{
    if (m_hwndNextCB)
        ::SendMessage(m_hwndNextCB, WM_CHANGECBCHAIN, (WPARAM)hWndRemove, (LPARAM)hWndAfter);
}

void CNetClipServer::OnDrawClipboard()
{
    if (m_hwndNextCB)
        ::SendMessage(m_hwndNextCB, WM_DRAWCLIPBOARD, 0, 0);

    // Attempting to call out while handling a WM_DRAWCLIPBOARD causes
    // RPC_E_CANTCALLOUT_ININPUTSYNCCALL.  We work around this
    // by posting a WM_USER message to ourselves and calling
    // SendOnClipboardChanged from there
    //
    PostMessage(WM_SENDONCLPBOARDCHANGED);
}

LRESULT CNetClipServer::OnSendOnClipboardChanged(WPARAM, LPARAM)
{
    SendOnClipboardChanged();
    return 0;
}

BEGIN_INTERFACE_MAP(CNetClipServer, CWnd)
	INTERFACE_PART(CNetClipServer, IID_IClipboard, Clipboard)
	INTERFACE_PART(CNetClipServer, IID_IConnectionPointContainer, ConnPtContainer)
END_INTERFACE_MAP()

// {F7565504-4B54-11CF-B63C-0080C792B782}
IMPLEMENT_NETCLIPCREATE(CNetClipServer, "Remote Clipboard", 0xf7565504, 0x4b54, 0x11cf, 0xb6, 0x3c, 0x0, 0x80, 0xc7, 0x92, 0xb7, 0x82)

/////////////////////////////////////////////////////////////////////////////
// CNetClipServer message handlers

ULONG CNetClipServer::XClipboard::AddRef()
{
    METHOD_PROLOGUE(CNetClipServer, Clipboard)
    return pThis->ExternalAddRef();
}

ULONG CNetClipServer::XClipboard::Release()
{
    METHOD_PROLOGUE(CNetClipServer, Clipboard)
    return pThis->ExternalRelease();
}

HRESULT CNetClipServer::XClipboard::QueryInterface(
    REFIID iid, void** ppvObj)
{
    METHOD_PROLOGUE(CNetClipServer, Clipboard)
    return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}


HRESULT CNetClipServer::XClipboard::GetClipboardFormatName(
            /* [in] */ CLIPFORMAT cf,
            /* [out] */ LPOLESTR __RPC_FAR *ppsz)
{
    METHOD_PROLOGUE(CNetClipServer, Clipboard)

    *ppsz=NULL;
    TCHAR sz[256];
    int n = ::GetClipboardFormatName(cf, sz, 255);
    if (n == 0)
        return S_FALSE;

    *ppsz = (OLECHAR*)CoTaskMemAlloc((n+1)*sizeof(OLECHAR));
    if (*ppsz==NULL)
        return E_OUTOFMEMORY;

#ifdef _UNICODE
    wcscpy(*ppsz, sz);
#else
    MultiByteToWideChar(CP_ACP, 0, sz, -1, *ppsz, n+1);
#endif

    return S_OK;
}

HRESULT CNetClipServer::XClipboard::GetClipboard(
    /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDataObject)
{
    METHOD_PROLOGUE(CNetClipServer, Clipboard)

    /*
    if (caller does not have write access)
    {
        IDataObject* pdo = NULL;
        HRESULT hr;
        if (SUCCEEDED(hr = OleGetClipboard(&pdo)))
        {
            CGenericDataObject* pgen = new CGenericDataObject(pdo);
            *ppDataObject = (IDataObject*)pgen->GetInterface(IID_IDataObject);
            pdo->Release();
        }
        return hr;
    }
    */

    return OleGetClipboard(ppDataObject);
}

HRESULT CNetClipServer::XClipboard::SetClipboard(
    /* [in] */ IDataObject __RPC_FAR *pDataObject)
{
    METHOD_PROLOGUE(CNetClipServer, Clipboard)

    /*
    if (caller does not have write access)
        return E_ACCESSDENIED;
    */

    return OleSetClipboard(pDataObject);
}

HRESULT CNetClipServer::XClipboard::IsCurrentClipboard(
    /* [in] */ IDataObject __RPC_FAR *pDataObject)
{
    METHOD_PROLOGUE(CNetClipServer, Clipboard)

    return OleIsCurrentClipboard(pDataObject);
}

HRESULT CNetClipServer::XClipboard::FlushClipboard()
{
    METHOD_PROLOGUE(CNetClipServer, Clipboard)

    return OleFlushClipboard();
}

BEGIN_CONNECTION_MAP(CNetClipServer, CWnd)
    CONNECTION_PART(CNetClipServer, IID_IClipboardNotify, ClipboardNotifyCP)
END_CONNECTION_MAP()

HRESULT CNetClipServer::SendOnClipboardChanged()
{
    const CPtrArray* pConnections = m_xClipboardNotifyCP.GetConnections();
    ASSERT(pConnections != NULL);

    int cConnections = (int)pConnections->GetSize();
    IClipboardNotify* pSink;
    for (int i = 0; i < cConnections; i++)
    {
        pSink = (IClipboardNotify*)(pConnections->GetAt(i));
        ASSERT(pSink != NULL);
        pSink->OnClipboardChanged();
    }
    return S_OK;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxole.h>      
#include <afxcmn.h>
#include <afxcview.h>
#include <afxpriv.h>

#include <afxrich.h>
#include <winnls.h>
#include <winsvc.h>
#include <winreg.h>
#include <winver.h>

#include "NetClip.h"

#pragma warning( disable: 4706 4100 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\util.cpp ===
// util.cpp
#include "stdafx.h"
#include "util.h"

#define new DEBUG_NEW


// Stolen from OLEMISC.CPP in the MFC 3.0 source.  Function names
// changed from Afx* to _*.
//
#define _countof(array)	(sizeof(array)/sizeof(array[0]))
LPCTSTR AFXAPI _GetScodeString(SCODE sc)
{
	struct SCODE_ENTRY
	{
		SCODE sc;
		LPCTSTR lpszName;
	};
	#define MAKE_SCODE_ENTRY(sc)    { sc, _T(#sc) }
	static const SCODE_ENTRY scNameTable[] =
	{
		MAKE_SCODE_ENTRY(S_OK),
		MAKE_SCODE_ENTRY(S_FALSE),

		MAKE_SCODE_ENTRY(CACHE_S_FORMATETC_NOTSUPPORTED),
		MAKE_SCODE_ENTRY(CACHE_S_SAMECACHE),
		MAKE_SCODE_ENTRY(CACHE_S_SOMECACHES_NOTUPDATED),
		MAKE_SCODE_ENTRY(CONVERT10_S_NO_PRESENTATION),
		MAKE_SCODE_ENTRY(DATA_S_SAMEFORMATETC),
		MAKE_SCODE_ENTRY(DRAGDROP_S_CANCEL),
		MAKE_SCODE_ENTRY(DRAGDROP_S_DROP),
		MAKE_SCODE_ENTRY(DRAGDROP_S_USEDEFAULTCURSORS),
		MAKE_SCODE_ENTRY(INPLACE_S_TRUNCATED),
		MAKE_SCODE_ENTRY(MK_S_HIM),
		MAKE_SCODE_ENTRY(MK_S_ME),
		MAKE_SCODE_ENTRY(MK_S_MONIKERALREADYREGISTERED),
		MAKE_SCODE_ENTRY(MK_S_REDUCED_TO_SELF),
		MAKE_SCODE_ENTRY(MK_S_US),
		MAKE_SCODE_ENTRY(OLE_S_MAC_CLIPFORMAT),
		MAKE_SCODE_ENTRY(OLE_S_STATIC),
		MAKE_SCODE_ENTRY(OLE_S_USEREG),
		MAKE_SCODE_ENTRY(OLEOBJ_S_CANNOT_DOVERB_NOW),
		MAKE_SCODE_ENTRY(OLEOBJ_S_INVALIDHWND),
		MAKE_SCODE_ENTRY(OLEOBJ_S_INVALIDVERB),
		MAKE_SCODE_ENTRY(OLEOBJ_S_LAST),
		MAKE_SCODE_ENTRY(STG_S_CONVERTED),
		MAKE_SCODE_ENTRY(VIEW_S_ALREADY_FROZEN),

		MAKE_SCODE_ENTRY(E_UNEXPECTED),
		MAKE_SCODE_ENTRY(E_NOTIMPL),
		MAKE_SCODE_ENTRY(E_OUTOFMEMORY),
		MAKE_SCODE_ENTRY(E_INVALIDARG),
		MAKE_SCODE_ENTRY(E_NOINTERFACE),
		MAKE_SCODE_ENTRY(E_POINTER),
		MAKE_SCODE_ENTRY(E_HANDLE),
		MAKE_SCODE_ENTRY(E_ABORT),
		MAKE_SCODE_ENTRY(E_FAIL),
		MAKE_SCODE_ENTRY(E_ACCESSDENIED),

		MAKE_SCODE_ENTRY(CACHE_E_NOCACHE_UPDATED),
		MAKE_SCODE_ENTRY(CLASS_E_CLASSNOTAVAILABLE),
		MAKE_SCODE_ENTRY(CLASS_E_NOAGGREGATION),
		MAKE_SCODE_ENTRY(CLIPBRD_E_BAD_DATA),
		MAKE_SCODE_ENTRY(CLIPBRD_E_CANT_CLOSE),
		MAKE_SCODE_ENTRY(CLIPBRD_E_CANT_EMPTY),
		MAKE_SCODE_ENTRY(CLIPBRD_E_CANT_OPEN),
		MAKE_SCODE_ENTRY(CLIPBRD_E_CANT_SET),
		MAKE_SCODE_ENTRY(CO_E_ALREADYINITIALIZED),
		MAKE_SCODE_ENTRY(CO_E_APPDIDNTREG),
		MAKE_SCODE_ENTRY(CO_E_APPNOTFOUND),
		MAKE_SCODE_ENTRY(CO_E_APPSINGLEUSE),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(CO_E_BAD_PATH),
		#endif
		MAKE_SCODE_ENTRY(CO_E_CANTDETERMINECLASS),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(CO_E_CLASS_CREATE_FAILED),
		#endif
		MAKE_SCODE_ENTRY(CO_E_CLASSSTRING),
		MAKE_SCODE_ENTRY(CO_E_DLLNOTFOUND),
		MAKE_SCODE_ENTRY(CO_E_ERRORINAPP),
		MAKE_SCODE_ENTRY(CO_E_ERRORINDLL),
		MAKE_SCODE_ENTRY(CO_E_IIDSTRING),
		MAKE_SCODE_ENTRY(CO_E_NOTINITIALIZED),
		MAKE_SCODE_ENTRY(CO_E_OBJISREG),
		MAKE_SCODE_ENTRY(CO_E_OBJNOTCONNECTED),
		MAKE_SCODE_ENTRY(CO_E_OBJNOTREG),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(CO_E_OBJSRV_RPC_FAILURE),
		MAKE_SCODE_ENTRY(CO_E_SCM_ERROR),
		MAKE_SCODE_ENTRY(CO_E_SCM_RPC_FAILURE),
		MAKE_SCODE_ENTRY(CO_E_SERVER_EXEC_FAILURE),
		MAKE_SCODE_ENTRY(CO_E_SERVER_STOPPING),
		#endif
		MAKE_SCODE_ENTRY(CO_E_WRONGOSFORAPP),
		MAKE_SCODE_ENTRY(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB),
		MAKE_SCODE_ENTRY(CONVERT10_E_OLESTREAM_FMT),
		MAKE_SCODE_ENTRY(CONVERT10_E_OLESTREAM_GET),
		MAKE_SCODE_ENTRY(CONVERT10_E_OLESTREAM_PUT),
		MAKE_SCODE_ENTRY(CONVERT10_E_STG_DIB_TO_BITMAP),
		MAKE_SCODE_ENTRY(CONVERT10_E_STG_FMT),
		MAKE_SCODE_ENTRY(CONVERT10_E_STG_NO_STD_STREAM),
		MAKE_SCODE_ENTRY(DISP_E_ARRAYISLOCKED),
		MAKE_SCODE_ENTRY(DISP_E_BADCALLEE),
		MAKE_SCODE_ENTRY(DISP_E_BADINDEX),
		MAKE_SCODE_ENTRY(DISP_E_BADPARAMCOUNT),
		MAKE_SCODE_ENTRY(DISP_E_BADVARTYPE),
		MAKE_SCODE_ENTRY(DISP_E_EXCEPTION),
		MAKE_SCODE_ENTRY(DISP_E_MEMBERNOTFOUND),
		MAKE_SCODE_ENTRY(DISP_E_NONAMEDARGS),
		MAKE_SCODE_ENTRY(DISP_E_NOTACOLLECTION),
		MAKE_SCODE_ENTRY(DISP_E_OVERFLOW),
		MAKE_SCODE_ENTRY(DISP_E_PARAMNOTFOUND),
		MAKE_SCODE_ENTRY(DISP_E_PARAMNOTOPTIONAL),
		MAKE_SCODE_ENTRY(DISP_E_TYPEMISMATCH),
		MAKE_SCODE_ENTRY(DISP_E_UNKNOWNINTERFACE),
		MAKE_SCODE_ENTRY(DISP_E_UNKNOWNLCID),
		MAKE_SCODE_ENTRY(DISP_E_UNKNOWNNAME),
		MAKE_SCODE_ENTRY(DRAGDROP_E_ALREADYREGISTERED),
		MAKE_SCODE_ENTRY(DRAGDROP_E_INVALIDHWND),
		MAKE_SCODE_ENTRY(DRAGDROP_E_NOTREGISTERED),
		MAKE_SCODE_ENTRY(DV_E_CLIPFORMAT),
		MAKE_SCODE_ENTRY(DV_E_DVASPECT),
		MAKE_SCODE_ENTRY(DV_E_DVTARGETDEVICE),
		MAKE_SCODE_ENTRY(DV_E_DVTARGETDEVICE_SIZE),
		MAKE_SCODE_ENTRY(DV_E_FORMATETC),
		MAKE_SCODE_ENTRY(DV_E_LINDEX),
		MAKE_SCODE_ENTRY(DV_E_NOIVIEWOBJECT),
		MAKE_SCODE_ENTRY(DV_E_STATDATA),
		MAKE_SCODE_ENTRY(DV_E_STGMEDIUM),
		MAKE_SCODE_ENTRY(DV_E_TYMED),
		MAKE_SCODE_ENTRY(INPLACE_E_NOTOOLSPACE),
		MAKE_SCODE_ENTRY(INPLACE_E_NOTUNDOABLE),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(MEM_E_INVALID_LINK),
		MAKE_SCODE_ENTRY(MEM_E_INVALID_ROOT),
		MAKE_SCODE_ENTRY(MEM_E_INVALID_SIZE),
		#endif		
		MAKE_SCODE_ENTRY(MK_E_CANTOPENFILE),
		MAKE_SCODE_ENTRY(MK_E_CONNECTMANUALLY),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(MK_E_ENUMERATION_FAILED),
		#endif
		MAKE_SCODE_ENTRY(MK_E_EXCEEDEDDEADLINE),
		MAKE_SCODE_ENTRY(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED),
		MAKE_SCODE_ENTRY(MK_E_INVALIDEXTENSION),
		MAKE_SCODE_ENTRY(MK_E_MUSTBOTHERUSER),
		MAKE_SCODE_ENTRY(MK_E_NEEDGENERIC),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(MK_E_NO_NORMALIZED),
		#endif
		MAKE_SCODE_ENTRY(MK_E_NOINVERSE),
		MAKE_SCODE_ENTRY(MK_E_NOOBJECT),
		MAKE_SCODE_ENTRY(MK_E_NOPREFIX),
		MAKE_SCODE_ENTRY(MK_E_NOSTORAGE),
		MAKE_SCODE_ENTRY(MK_E_NOTBINDABLE),
		MAKE_SCODE_ENTRY(MK_E_NOTBOUND),
		MAKE_SCODE_ENTRY(MK_E_SYNTAX),
		MAKE_SCODE_ENTRY(MK_E_UNAVAILABLE),
		MAKE_SCODE_ENTRY(OLE_E_ADVF),
		MAKE_SCODE_ENTRY(OLE_E_ADVISENOTSUPPORTED),
		MAKE_SCODE_ENTRY(OLE_E_BLANK),
		MAKE_SCODE_ENTRY(OLE_E_CANT_BINDTOSOURCE),
		MAKE_SCODE_ENTRY(OLE_E_CANT_GETMONIKER),
		MAKE_SCODE_ENTRY(OLE_E_CANTCONVERT),
		MAKE_SCODE_ENTRY(OLE_E_CLASSDIFF),
		MAKE_SCODE_ENTRY(OLE_E_ENUM_NOMORE),
		MAKE_SCODE_ENTRY(OLE_E_INVALIDHWND),
		MAKE_SCODE_ENTRY(OLE_E_INVALIDRECT),
		MAKE_SCODE_ENTRY(OLE_E_NOCACHE),
		MAKE_SCODE_ENTRY(OLE_E_NOCONNECTION),
		MAKE_SCODE_ENTRY(OLE_E_NOSTORAGE),
		MAKE_SCODE_ENTRY(OLE_E_NOT_INPLACEACTIVE),
		MAKE_SCODE_ENTRY(OLE_E_NOTRUNNING),
		MAKE_SCODE_ENTRY(OLE_E_OLEVERB),
		MAKE_SCODE_ENTRY(OLE_E_PROMPTSAVECANCELLED),
		MAKE_SCODE_ENTRY(OLE_E_STATIC),
		MAKE_SCODE_ENTRY(OLE_E_WRONGCOMPOBJ),
		MAKE_SCODE_ENTRY(OLEOBJ_E_INVALIDVERB),
		MAKE_SCODE_ENTRY(OLEOBJ_E_NOVERBS),
		MAKE_SCODE_ENTRY(REGDB_E_CLASSNOTREG),
		MAKE_SCODE_ENTRY(REGDB_E_IIDNOTREG),
		MAKE_SCODE_ENTRY(REGDB_E_INVALIDVALUE),
		MAKE_SCODE_ENTRY(REGDB_E_KEYMISSING),
		MAKE_SCODE_ENTRY(REGDB_E_READREGDB),
		MAKE_SCODE_ENTRY(REGDB_E_WRITEREGDB),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(RPC_E_ATTEMPTED_MULTITHREAD),
		#endif
		MAKE_SCODE_ENTRY(RPC_E_CALL_CANCELED),
		MAKE_SCODE_ENTRY(RPC_E_CALL_REJECTED),
		MAKE_SCODE_ENTRY(RPC_E_CANTCALLOUT_AGAIN),
		MAKE_SCODE_ENTRY(RPC_E_CANTCALLOUT_INASYNCCALL),
		MAKE_SCODE_ENTRY(RPC_E_CANTCALLOUT_INEXTERNALCALL),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(RPC_E_CANTCALLOUT_ININPUTSYNCCALL),
		#endif
		MAKE_SCODE_ENTRY(RPC_E_CANTPOST_INSENDCALL),
		MAKE_SCODE_ENTRY(RPC_E_CANTTRANSMIT_CALL),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(RPC_E_CHANGED_MODE),
		#endif
		MAKE_SCODE_ENTRY(RPC_E_CLIENT_CANTMARSHAL_DATA),
		MAKE_SCODE_ENTRY(RPC_E_CLIENT_CANTUNMARSHAL_DATA),
		MAKE_SCODE_ENTRY(RPC_E_CLIENT_DIED),
		MAKE_SCODE_ENTRY(RPC_E_CONNECTION_TERMINATED),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(RPC_E_DISCONNECTED),
		MAKE_SCODE_ENTRY(RPC_E_FAULT),
		MAKE_SCODE_ENTRY(RPC_E_INVALID_CALLDATA),
		#endif
		MAKE_SCODE_ENTRY(RPC_E_INVALID_DATA),
		MAKE_SCODE_ENTRY(RPC_E_INVALID_DATAPACKET),
		MAKE_SCODE_ENTRY(RPC_E_INVALID_PARAMETER),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(RPC_E_INVALIDMETHOD),
		MAKE_SCODE_ENTRY(RPC_E_NOT_REGISTERED),
		MAKE_SCODE_ENTRY(RPC_E_OUT_OF_RESOURCES),
		MAKE_SCODE_ENTRY(RPC_E_RETRY),
		#endif		
		MAKE_SCODE_ENTRY(RPC_E_SERVER_CANTMARSHAL_DATA),
		MAKE_SCODE_ENTRY(RPC_E_SERVER_CANTUNMARSHAL_DATA),
		MAKE_SCODE_ENTRY(RPC_E_SERVER_DIED),
		#ifdef _WIN32
		MAKE_SCODE_ENTRY(RPC_E_SERVER_DIED_DNE),
		MAKE_SCODE_ENTRY(RPC_E_SERVERCALL_REJECTED),
		MAKE_SCODE_ENTRY(RPC_E_SERVERCALL_RETRYLATER),
		MAKE_SCODE_ENTRY(RPC_E_SERVERFAULT),
		MAKE_SCODE_ENTRY(RPC_E_SYS_CALL_FAILED),
		MAKE_SCODE_ENTRY(RPC_E_THREAD_NOT_INIT),
		MAKE_SCODE_ENTRY(RPC_E_WRONG_THREAD),
		#endif
		MAKE_SCODE_ENTRY(RPC_E_UNEXPECTED),
		MAKE_SCODE_ENTRY(STG_E_ABNORMALAPIEXIT),
		MAKE_SCODE_ENTRY(STG_E_ACCESSDENIED),
		MAKE_SCODE_ENTRY(STG_E_CANTSAVE),
		MAKE_SCODE_ENTRY(STG_E_DISKISWRITEPROTECTED),
		MAKE_SCODE_ENTRY(STG_E_EXTANTMARSHALLINGS),
		MAKE_SCODE_ENTRY(STG_E_FILEALREADYEXISTS),
		MAKE_SCODE_ENTRY(STG_E_FILENOTFOUND),
		MAKE_SCODE_ENTRY(STG_E_INSUFFICIENTMEMORY),
		MAKE_SCODE_ENTRY(STG_E_INUSE),
		MAKE_SCODE_ENTRY(STG_E_INVALIDFLAG),
		MAKE_SCODE_ENTRY(STG_E_INVALIDFUNCTION),
		MAKE_SCODE_ENTRY(STG_E_INVALIDHANDLE),
		MAKE_SCODE_ENTRY(STG_E_INVALIDHEADER),
		MAKE_SCODE_ENTRY(STG_E_INVALIDNAME),
		MAKE_SCODE_ENTRY(STG_E_INVALIDPARAMETER),
		MAKE_SCODE_ENTRY(STG_E_INVALIDPOINTER),
		MAKE_SCODE_ENTRY(STG_E_LOCKVIOLATION),
		MAKE_SCODE_ENTRY(STG_E_MEDIUMFULL),
		MAKE_SCODE_ENTRY(STG_E_NOMOREFILES),
		MAKE_SCODE_ENTRY(STG_E_NOTCURRENT),
		MAKE_SCODE_ENTRY(STG_E_NOTFILEBASEDSTORAGE),
		MAKE_SCODE_ENTRY(STG_E_OLDDLL),
		MAKE_SCODE_ENTRY(STG_E_OLDFORMAT),
		MAKE_SCODE_ENTRY(STG_E_PATHNOTFOUND),
		MAKE_SCODE_ENTRY(STG_E_READFAULT),
		MAKE_SCODE_ENTRY(STG_E_REVERTED),
		MAKE_SCODE_ENTRY(STG_E_SEEKERROR),
		MAKE_SCODE_ENTRY(STG_E_SHAREREQUIRED),
		MAKE_SCODE_ENTRY(STG_E_SHAREVIOLATION),
		MAKE_SCODE_ENTRY(STG_E_TOOMANYOPENFILES),
		MAKE_SCODE_ENTRY(STG_E_UNIMPLEMENTEDFUNCTION),
		MAKE_SCODE_ENTRY(STG_E_UNKNOWN),
		MAKE_SCODE_ENTRY(STG_E_WRITEFAULT),
		MAKE_SCODE_ENTRY(TYPE_E_AMBIGUOUSNAME),
		MAKE_SCODE_ENTRY(TYPE_E_BADMODULEKIND),
		MAKE_SCODE_ENTRY(TYPE_E_BUFFERTOOSMALL),
		MAKE_SCODE_ENTRY(TYPE_E_CANTCREATETMPFILE),
		MAKE_SCODE_ENTRY(TYPE_E_CANTLOADLIBRARY),
		MAKE_SCODE_ENTRY(TYPE_E_CIRCULARTYPE),
		MAKE_SCODE_ENTRY(TYPE_E_DLLFUNCTIONNOTFOUND),
		MAKE_SCODE_ENTRY(TYPE_E_DUPLICATEID),
		MAKE_SCODE_ENTRY(TYPE_E_ELEMENTNOTFOUND),
		MAKE_SCODE_ENTRY(TYPE_E_INCONSISTENTPROPFUNCS),
		MAKE_SCODE_ENTRY(TYPE_E_INVALIDSTATE),
		MAKE_SCODE_ENTRY(TYPE_E_INVDATAREAD),
		MAKE_SCODE_ENTRY(TYPE_E_IOERROR),
		MAKE_SCODE_ENTRY(TYPE_E_LIBNOTREGISTERED),
		MAKE_SCODE_ENTRY(TYPE_E_NAMECONFLICT),
		MAKE_SCODE_ENTRY(TYPE_E_OUTOFBOUNDS),
		MAKE_SCODE_ENTRY(TYPE_E_QUALIFIEDNAMEDISALLOWED),
		MAKE_SCODE_ENTRY(TYPE_E_REGISTRYACCESS),
		MAKE_SCODE_ENTRY(TYPE_E_SIZETOOBIG),
		MAKE_SCODE_ENTRY(TYPE_E_TYPEMISMATCH),
		MAKE_SCODE_ENTRY(TYPE_E_UNDEFINEDTYPE),
		MAKE_SCODE_ENTRY(TYPE_E_UNKNOWNLCID),
		MAKE_SCODE_ENTRY(TYPE_E_UNSUPFORMAT),
		MAKE_SCODE_ENTRY(TYPE_E_WRONGTYPEKIND),
		MAKE_SCODE_ENTRY(VIEW_E_DRAW),
	};
	#undef MAKE_SCODE_ENTRY

	// look for it in the table
	for (int i = 0; i < _countof(scNameTable); i++)
	{
		if (sc == scNameTable[i].sc)
			return scNameTable[i].lpszName;
	}
	return NULL;    // not found
}

LPCTSTR AFXAPI _GetScodeRangeString(SCODE sc)
{
	struct RANGE_ENTRY
	{
		SCODE scFirst;
		SCODE scLast;
		LPCTSTR lpszName;
	};
	#define MAKE_RANGE_ENTRY(scRange) \
		{ scRange##_FIRST, scRange##_LAST, \
			_T(#scRange) _T("_FIRST...") _T(#scRange) _T("_LAST") }

	static const RANGE_ENTRY scRangeTable[] =
	{
		MAKE_RANGE_ENTRY(CACHE_E),
		MAKE_RANGE_ENTRY(CACHE_S),
		MAKE_RANGE_ENTRY(CLASSFACTORY_E),
		MAKE_RANGE_ENTRY(CLASSFACTORY_S),
		MAKE_RANGE_ENTRY(CLIENTSITE_E),
		MAKE_RANGE_ENTRY(CLIENTSITE_S),
		MAKE_RANGE_ENTRY(CLIPBRD_E),
		MAKE_RANGE_ENTRY(CLIPBRD_S),
		MAKE_RANGE_ENTRY(CONVERT10_E),
		MAKE_RANGE_ENTRY(CONVERT10_S),
		MAKE_RANGE_ENTRY(CO_E),
		MAKE_RANGE_ENTRY(CO_S),
		MAKE_RANGE_ENTRY(DATA_E),
		MAKE_RANGE_ENTRY(DATA_S),
		MAKE_RANGE_ENTRY(DRAGDROP_E),
		MAKE_RANGE_ENTRY(DRAGDROP_S),
		MAKE_RANGE_ENTRY(ENUM_E),
		MAKE_RANGE_ENTRY(ENUM_S),
		MAKE_RANGE_ENTRY(INPLACE_E),
		MAKE_RANGE_ENTRY(INPLACE_S),
		MAKE_RANGE_ENTRY(MARSHAL_E),
		MAKE_RANGE_ENTRY(MARSHAL_S),
		MAKE_RANGE_ENTRY(MK_E),
		MAKE_RANGE_ENTRY(MK_S),
		MAKE_RANGE_ENTRY(OLEOBJ_E),
		MAKE_RANGE_ENTRY(OLEOBJ_S),
		MAKE_RANGE_ENTRY(OLE_E),
		MAKE_RANGE_ENTRY(OLE_S),
		MAKE_RANGE_ENTRY(REGDB_E),
		MAKE_RANGE_ENTRY(REGDB_S),
		MAKE_RANGE_ENTRY(VIEW_E),
		MAKE_RANGE_ENTRY(VIEW_S),
	};
	#undef MAKE_RANGE_ENTRY

	// look for it in the table
	for (int i = 0; i < _countof(scRangeTable); i++)
	{
		if (sc >= scRangeTable[i].scFirst && sc <= scRangeTable[i].scLast)
			return scRangeTable[i].lpszName;
	}
	return NULL;    // not found
}

LPCTSTR AFXAPI _GetSeverityString(SCODE sc)
{
	static const TCHAR* rgszSEVERITY[] =
	{
		_T("SEVERITY_SUCCESS"),
		_T("SEVERITY_ERROR"),
	};
	return rgszSEVERITY[SCODE_SEVERITY(sc)];
}

LPCTSTR AFXAPI _GetFacilityString(SCODE sc)
{
	static const TCHAR* rgszFACILITY[] =
	{
		_T("FACILITY_NULL"),
		_T("FACILITY_RPC"),
		_T("FACILITY_DISPATCH"),
		_T("FACILITY_STORAGE"),
		_T("FACILITY_ITF"),
		_T("FACILITY_0x05"),
		_T("FACILITY_0x06"),
		_T("FACILITY_WIN32"),
		_T("FACILITY_WINDOWS"),
	};
	if (SCODE_FACILITY(sc) >= _countof(rgszFACILITY))
		return _T("<Unknown Facility>");

	return rgszFACILITY[SCODE_FACILITY(sc)];
}

LPCTSTR AFXAPI _GetFullScodeString(SCODE sc)
{
	static TCHAR szBuf[128];
	LPCTSTR lpsz;
	if ((lpsz = _GetScodeString(sc)) != NULL)
	{
		// found exact match
		wsprintf(szBuf, _T("%s ($%08lX)"), lpsz, sc);
	}
	else if ((lpsz = _GetScodeRangeString(sc)) != NULL)
	{
		// found suitable range
		wsprintf(szBuf, _T("range: %s ($%08lX)"), lpsz, sc);
	}
	else
	{
		// not found at all -- split it up into its parts
		wsprintf(szBuf, _T("severity: %s, facility: %s ($%08lX)"),
			_GetSeverityString(sc), _GetFacilityString(sc), sc);
	}
	return szBuf;
}

void ErrorMessageID( const UINT id, HRESULT hr)
{
    CString str;
    str.LoadString(id);
    ErrorMessage(str, hr);
}

void ErrorMessage( const CString& str, HRESULT hr )
{
//#ifdef _DEBUG
    LPVOID lpMessageBuffer = NULL ;
#ifndef _MAC
    if (FormatMessage(
          FORMAT_MESSAGE_ALLOCATE_BUFFER |
          FORMAT_MESSAGE_FROM_SYSTEM,
          NULL,
          hr,
          MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
          (LPTSTR) &lpMessageBuffer,
          0,
          NULL ))
    {
        CString str2 ;
        str2.Format( _T("\n%s %s"), (LPCTSTR)lpMessageBuffer, (LPCTSTR)_GetFullScodeString(hr) ) ;
        str2 = str + str2 ;
        LocalFree(lpMessageBuffer) ;
        AfxMessageBox( str2 ) ;
    }
    else
#endif // !_MAC
    {
        CString str2 ;
        str2.Format( _T("\n<No system message defined> %s"), (LPCTSTR)_GetFullScodeString(hr) ) ;
        str2 = str + str2 ;
        AfxMessageBox( str2 ) ;
    }
//#else // _DEBUG
//    AfxMessageBox(str) ;
//#endif
}

LPTSTR HRtoString( HRESULT hr )
{   
    SCODE   sc ;
    sc = GetScode( hr ) ;

#ifndef _MAC
#ifdef FORMATMSG
    LPVOID lpMessageBuffer ;
    if (FormatMessage(
          FORMAT_MESSAGE_ALLOCATE_BUFFER |
          FORMAT_MESSAGE_FROM_SYSTEM,
          NULL,
          sc,
          MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
          (LPTSTR) &lpMessageBuffer,
          0,
          NULL ))
    {
        wsprintf( sz, _T( "%s (0x%lx)" ), (LPTSTR)lpMessageBuffer, sc);
        LocalFree(lpMessageBuffer) ;
    }
    else
    {
        wsprintf( sz, _T( "Unknown Scode (0x%lx)" ), sc);
    }
    

#endif // !FORMATMSG
#endif // !_MAC

    return (LPTSTR)_GetFullScodeString(sc) ;
}   

static TCHAR * g_rgszVT[] =
{
    _T( "Void" ),             //VT_EMPTY           = 0,   /* [V]   [P]  nothing                     */
    _T( "Null" ),             //VT_NULL            = 1,   /* [V]        SQL style Null              */
    _T( "Integer" ),          //VT_I2              = 2,   /* [V][T][P]  2 byte signed int           */
    _T( "Long" ),             //VT_I4              = 3,   /* [V][T][P]  4 byte signed int           */
    _T( "Single" ),           //VT_R4              = 4,   /* [V][T][P]  4 byte real                 */
    _T( "Double" ),           //VT_R8              = 5,   /* [V][T][P]  8 byte real                 */
    _T( "Currency" ),         //VT_CY              = 6,   /* [V][T][P]  currency                    */
    _T( "Date" ),             //VT_DATE            = 7,   /* [V][T][P]  date                        */
    _T( "String" ),           //VT_BSTR            = 8,   /* [V][T][P]  binary string               */
    _T( "Object" ),           //VT_DISPATCH        = 9,   /* [V][T]     IDispatch FAR*              */
    _T( "SCODE" ),            //VT_ERROR           = 10,  /* [V][T]     SCODE                       */
    _T( "Boolean" ),          //VT_BOOL            = 11,  /* [V][T][P]  True=-1, False=0            */
    _T( "Variant" ),          //VT_VARIANT         = 12,  /* [V][T][P]  VARIANT FAR*                */
    _T( "pIUnknown" ),        //VT_UNKNOWN         = 13,  /* [V][T]     IUnknown FAR*               */
    _T( "Unicode" ),          //VT_WBSTR           = 14,  /* [V][T]     wide binary string          */
    _T( "" ),                 //                   = 15,
    _T( "BYTE" ),             //VT_I1              = 16,  /*    [T]     signed char                 */
    _T( "char" ),             //VT_UI1             = 17,  /*    [T]     unsigned char               */
    _T( "USHORT" ),           //VT_UI2             = 18,  /*    [T]     unsigned short              */
    _T( "ULONG" ),            //VT_UI4             = 19,  /*    [T]     unsigned short              */
    _T( "int64" ),            //VT_I8              = 20,  /*    [T][P]  signed 64-bit int           */
    _T( "uint64" ),           //VT_UI8             = 21,  /*    [T]     unsigned 64-bit int         */
    _T( "int" ),              //VT_INT             = 22,  /*    [T]     signed machine int          */
    _T( "UINT" ),             //VT_UINT            = 23,  /*    [T]     unsigned machine int        */
    _T( "VOID" ),             //VT_VOID            = 24,  /*    [T]     C style void                */
    _T( "HRESULT" ),          //VT_HRESULT         = 25,  /*    [T]                                 */
    _T( "PTR" ),              //VT_PTR             = 26,  /*    [T]     pointer type                */
    _T( "SAFEARRAY" ),        //VT_SAFEARRAY       = 27,  /*    [T]     (use VT_ARRAY in VARIANT)   */
    _T( "CARRAY" ),           //VT_CARRAY          = 28,  /*    [T]     C style array               */
    _T( "USERDEFINED" ),      //VT_USERDEFINED     = 29,  /*    [T]     user defined type         */
    _T( "LPTSTR" ),            //VT_LPTSTR           = 30,  /*    [T][P]  null terminated string      */
    _T( "LPWSTR" ),           //VT_LPWSTR          = 31,  /*    [T][P]  wide null terminated string */
    _T( "" ),                 //                   = 32,
    _T( "" ),                 //                   = 33,
    _T( "" ),                 //                   = 34,
    _T( "" ),                 //                   = 35,
    _T( "" ),                 //                   = 36,
    _T( "" ),                 //                   = 37,
    _T( "" ),                 //                   = 38,
    _T( "" ),                 //                   = 39,
    _T( "" ),                 //                   = 40,
    _T( "" ),                 //                   = 41,
    _T( "" ),                 //                   = 42,
    _T( "" ),                 //                   = 43,
    _T( "" ),                 //                   = 44,
    _T( "" ),                 //                   = 45,
    _T( "" ),                 //                   = 46,
    _T( "" ),                 //                   = 47,
    _T( "" ),                 //                   = 48,
    _T( "" ),                 //                   = 49,
    _T( "" ),                 //                   = 50,
    _T( "" ),                 //                   = 51,
    _T( "" ),                 //                   = 52,
    _T( "" ),                 //                   = 53,
    _T( "" ),                 //                   = 54,
    _T( "" ),                 //                   = 55,
    _T( "" ),                 //                   = 56,
    _T( "" ),                 //                   = 57,
    _T( "" ),                 //                   = 58,
    _T( "" ),                 //                   = 59,
    _T( "" ),                 //                   = 60,
    _T( "" ),                 //                   = 61,
    _T( "" ),                 //                   = 62,
    _T( "" ),                 //                   = 63,
    _T( "FILETIME" ),         //VT_FILETIME        = 64,  /*       [P]  FILETIME                    */
    _T( "BLOB" ),             //VT_BLOB            = 65,  /*       [P]  Length prefixed bytes       */
    _T( "STREAM" ),           //VT_STREAM          = 66,  /*       [P]  Name of the stream follows  */
    _T( "STORAGE" ),          //VT_STORAGE         = 67,  /*       [P]  Name of the storage follows */
    _T( "STREAMED_OBJECT" ),  //VT_STREAMED_OBJECT = 68,  /*       [P]  Stream contains an object   */
    _T( "STORED_OBJECT" ),    //VT_STORED_OBJECT   = 69,  /*       [P]  Storage contains an object  */
    _T( "BLOB_OBJECT" ),      //VT_BLOB_OBJECT     = 70,  /*       [P]  Blob contains an object     */
    _T( "CF" ),               //VT_CF              = 71,  /*       [P]  Clipboard format            */
    _T( "CLSID" ),            //VT_CLSID           = 72   /*       [P]  A Class ID                  */
};

LPTSTR VTtoString( VARTYPE vt )
{
    static TCHAR szBuf[64];

    if (vt <= VT_CLSID)
        return (LPTSTR)g_rgszVT[vt] ;

    if (vt & VT_VECTOR)
    {
        vt &= ~VT_VECTOR ;
        if (vt <= VT_CLSID)
            wsprintf( szBuf, _T("VECTOR of %s"), (LPTSTR)g_rgszVT[vt] ) ;
        else
            wsprintf( szBuf, _T("<Unknown %08lX>"), vt & VT_VECTOR ) ;
        return (LPTSTR)szBuf ;
    }

    if (vt & VT_ARRAY)
    {
        vt &= ~VT_ARRAY ;
        if (vt <= VT_CLSID)
            wsprintf( szBuf, _T("Array of %s"), (LPTSTR)g_rgszVT[vt] ) ;
        else
            wsprintf( szBuf, _T("<Unknown %08lX>"), vt & VT_ARRAY ) ;
        return (LPTSTR)szBuf ;
    }

    if (vt & VT_BYREF)
    {
        vt &= ~VT_BYREF ;
        if (vt <= VT_CLSID)
            wsprintf( szBuf, _T("%s BYREF "), (LPTSTR)g_rgszVT[vt] ) ;
        else
            wsprintf( szBuf, _T("<Unknown %08lX>"), vt & VT_BYREF ) ;
        return (LPTSTR)szBuf ;
    }

    if (vt & VT_RESERVED)
    {
        vt &= ~VT_RESERVED ;
        if (vt <= VT_CLSID)
            wsprintf( szBuf, _T("RESERVED (%s)"), (LPTSTR)g_rgszVT[vt] ) ;
        else
            wsprintf( szBuf, _T("<Unknown %08lX>"), vt & VT_RESERVED ) ;
        return (LPTSTR)szBuf ;
    }

    wsprintf( szBuf, _T("<Unknown %08lX>"), vt ) ;
            
    return (LPTSTR)szBuf ;
}

/* Remove the filespec portion from a path (including the backslash).
 */
VOID WINAPI StripFilespec( LPTSTR lpszPath )
{
    LPTSTR     p;

    p = lpszPath + lstrlen( lpszPath ) ;
    while ((*p != '\\') && (*p != ':') && (p != lpszPath))
        p-- ;

    if (*p == ':')
        p++ ;

    /* Don't strip backslash from root directory entry. */
    if (p != lpszPath)
    {
        if ((*p == '\\') && (*(p-1) == ':'))
            p++ ;
    }

    *p = NULL ;
}

/* Ensures that a path ends with a backslash.
 */
VOID WINAPI AddBackslash( LPTSTR lpszPath )
{
    if (lpszPath[lstrlen( lpszPath ) - 1] == '\\')
        return ;
    lstrcat( lpszPath, _T("\\") ) ;
}

 #include <ctype.h>
// Very useful API that parses a LONG out of a string, updating
// the string pointer before it returns.
// 
LONG WINAPI ParseOffNumber( LPTSTR FAR *lplp, LPINT lpConv )
{
    LPTSTR lp = *lplp;
    LONG  lValue=0;
    int   sign=1;

    while( isspace(*lp) )
        lp++;
    if( *lp=='-' )
    {               
        sign = -1;
        lp++;
    }
    if (*lp=='\0')
    {
        *lpConv = FALSE;
        return 0L;
    }

    // Is it a decimal number
    if (!(*lp == '0' && (*(lp+1) == 'x' || *(lp+1) == 'X')))
    {
        
        while( isdigit(*lp) )
        {
            lValue *= 10;
            lValue += (*lp - (TCHAR)'0');
            lp++;
        }
    }    
    else
    {
        lp+=2;

        while( isxdigit(*lp) )
        {
            lValue *= 16;
            if( isdigit(*lp) )
                lValue += (*lp - (TCHAR)'0');
            else
                lValue += (toupper(*lp) - (TCHAR)'A' + 10);
            lp++;
        }
    }
    while( isspace(*lp) )
        lp++;

    lValue *= (long)sign;

    if (*lp==(TCHAR)',')
    {
        lp++;
        while( isspace(*lp) )
            lp++;
        *lplp = lp;
        if (lpConv)
            *lpConv = (int)TRUE;
    }
    else
    {
        *lplp = lp;
        if (lpConv)
            *lpConv = (int)(*lp=='\0');
    }
    return lValue;

} //*** ParseOffNumber
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\svrdlg.h ===
// ServerInfoDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServerInfoDlg dialog

class CServerInfoDlg : public CDialog
{
// Construction
public:
	CServerInfoDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServerInfoDlg)
	enum { IDD = IDD_SERVERINFO };
	CString	m_strMachine;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerInfoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CServerInfoDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\server.h ===
// NetClipServer.h : header file
//

#define DECLARE_NETCLIPCREATE(class_name) \
public: \
	static AFX_DATA CNetClipObjectFactory factory; \
	static AFX_DATA const GUID guid; \

// Specify that we're multi-instance
//
#define IMPLEMENT_NETCLIPCREATE(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	AFX_DATADEF CNetClipObjectFactory class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), FALSE, _T(external_name)); \
	const AFX_DATADEF GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \

class CNetClipObjectFactory : public COleObjectFactory
{
public:
    CNetClipObjectFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass, BOOL bMultiInstance, LPCTSTR lpszProgID);
    virtual ~CNetClipObjectFactory() {};
    virtual CCmdTarget* OnCreateObject();
    virtual BOOL Register();
};

/////////////////////////////////////////////////////////////////////////////
// CNetClipServer command target

class CNetClipServer : public CWnd
{
	DECLARE_DYNCREATE(CNetClipServer)

	CNetClipServer();           // protected constructor used by dynamic creation

// Attributes
public:
    HWND m_hwndNextCB ;

// Operations
public:
    HRESULT SendOnClipboardChanged();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetClipServer)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CNetClipServer();

	// Generated message map functions
	//{{AFX_MSG(CNetClipServer)
	afx_msg void OnDrawClipboard();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);
	//}}AFX_MSG
    afx_msg LRESULT OnSendOnClipboardChanged(WPARAM, LPARAM);

	DECLARE_MESSAGE_MAP()
	DECLARE_NETCLIPCREATE(CNetClipServer)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CNetClipServer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
//  DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

    BEGIN_INTERFACE_PART(Clipboard, IClipboard)
        virtual HRESULT __stdcall GetClipboardFormatName( 
            /* [in] */ CLIPFORMAT cf,
            /* [out] */ LPOLESTR __RPC_FAR *ppsz);
        
        virtual HRESULT __stdcall GetClipboard( 
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDataObject);
        
        virtual HRESULT __stdcall SetClipboard( 
            /* [in] */ IDataObject __RPC_FAR *pDataObject);
        
        virtual HRESULT __stdcall IsCurrentClipboard( 
            /* [in] */ IDataObject __RPC_FAR *pDataObject);
        
        virtual HRESULT __stdcall FlushClipboard( void);
    END_INTERFACE_PART(Clipboard)

    DECLARE_CONNECTION_MAP()

    // Connection point for ISample interface
    BEGIN_CONNECTION_PART(CNetClipServer, ClipboardNotifyCP)
        CONNECTION_IID(IID_IClipboardNotify)
    END_CONNECTION_PART(ClipboardNotifyCP)
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\proxy\classfac.h ===
#ifndef _SHELLEXFACTORY_INCLUDE
#define _SHELLEXFACTORY_INCLUDE

class CShellExFactory : public IClassFactory {
public:
	HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	ULONG	_stdcall AddRef();
	ULONG	_stdcall Release();
	HRESULT _stdcall CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppObject);
	HRESULT	_stdcall LockServer(BOOL fLock);

	CShellExFactory::CShellExFactory();
private:
	ULONG m_dwRefCount;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\util.h ===
// util.h

#ifndef _UTIL_H_
#define _UTIL_H_

/// Utilities   

void ErrorMessageID( const UINT id, HRESULT hr);
void ErrorMessage( const CString& str, HRESULT hr ) ;

LPTSTR HRtoString( HRESULT hr ) ;
LPTSTR VTtoString( VARTYPE vt ) ;
   
LONG WINAPI ParseOffNumber( LPTSTR FAR *lplp, LPINT lpConv );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\proxy\dlldatax.c ===
// ===========================================================================
// File: D L L D A T A X . C
// 
// Copyright 1995 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential.
// ===========================================================================

#define DllGetClassObject   PSDllGetClassObject
#define DllCanUnloadNow     PSDllCanUnloadNow
#define DllRegisterServer   PSDllRegisterServer
#define DllUnregisterServer PSDllUnregisterServer

#include "dlldata.c"

// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\view.h ===
// NetClipView.h : interface of the CNetClipView class
//
/////////////////////////////////////////////////////////////////////////////

class CNetClipView : public CRichEditView
{
friend class CMainFrame;
protected: // create from serialization only
	CNetClipView();
	DECLARE_DYNCREATE(CNetClipView)

// Attributes
public:

// Operations
public:
    BOOL CanDisplay(UINT cf);

// Overrides
    virtual HRESULT QueryAcceptData(LPDATAOBJECT lpdataobj,
	CLIPFORMAT* lpcfFormat, DWORD /*dwReco*/, BOOL bReally, HGLOBAL hMetaPict);
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetClipView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void OnInitialUpdate();
	protected:
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNetClipView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CNetClipView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnEditCopy();
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/*
#ifndef _DEBUG  // debug version in NetClipView.cpp
inline CNetClipDoc* CNetClipView::GetDocument()
   { return (CNetClipDoc*)m_pDocument; }
#endif
*/
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\netclip\view.cpp ===
// NetClipView.cpp : implementation of the CNetClipView class
//
// CNetClipView is derived from CRichEditView found in MFC 4.0.
// Normally this would give us a RichEdit control that the user
// could type into, but we set it to read only.
//
// We use the ImportDataObject method of the rich edit control
// to show the clipboard contents. Simple but effective.
//

#include "stdafx.h"
#include "NetClipApp.h"

#include "Doc.h"
#include "MainFrm.h"
#include "View.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetClipView

IMPLEMENT_DYNCREATE(CNetClipView, CRichEditView)

BEGIN_MESSAGE_MAP(CNetClipView, CRichEditView)
	//{{AFX_MSG_MAP(CNetClipView)
	ON_WM_CREATE()
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUTLOCAL, OnUpdateNeedSel)
    ON_COMMAND(ID_EDIT_CUTLOCAL, OnEditCut)
	ON_COMMAND(ID_EDIT_COPYLOCAL, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTELOCAL, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPYLOCAL, OnUpdateNeedSel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNetClipView construction/destruction

// Well known clipboard formats that are not pre-defined
// by Windows.
UINT cf_ObjectDiscriptor;
UINT cf_EmbedSource;
UINT cf_LinkSource;
UINT cf_RichTextFormat;
UINT cf_RichTextFormatWithoutObjects;
UINT cf_RichTextAndObjects;

CNetClipView::CNetClipView()
{
    cf_ObjectDiscriptor = RegisterClipboardFormat(_T("Object Descriptor"));
    cf_EmbedSource = RegisterClipboardFormat(_T("Embed Source"));
    cf_LinkSource = RegisterClipboardFormat(_T("Link Source"));
    cf_RichTextFormat = RegisterClipboardFormat(_T("Rich Text Format"));
    cf_RichTextFormatWithoutObjects = RegisterClipboardFormat(_T("Rich Text Format Without Objects"));
    cf_RichTextAndObjects = RegisterClipboardFormat(_T("Rich Text And Objects"));
}

CNetClipView::~CNetClipView()
{
}

// FEATURE: Remove this since we don't do anything
BOOL CNetClipView::PreCreateWindow(CREATESTRUCT& cs)
{
	return CRichEditView::PreCreateWindow(cs);
}

int CNetClipView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CRichEditView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	GetRichEditCtrl().SetEventMask(ENM_KEYEVENTS|ENM_MOUSEEVENTS|GetRichEditCtrl().GetEventMask());
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CNetClipView drawing

void CNetClipView::OnDraw(CDC* pDC)
{
    // OnDraw is pure-virtual in the base so we have to 
    // provide at least an empty impl.
}

/////////////////////////////////////////////////////////////////////////////
// CNetClipView diagnostics

#ifdef _DEBUG
void CNetClipView::AssertValid() const
{
	CRichEditView::AssertValid();
}

void CNetClipView::Dump(CDumpContext& dc) const
{
	CRichEditView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CNetClipView message handlers

// FEATURE: Remove this since we don't do anything
void CNetClipView::OnInitialUpdate() 
{
	CRichEditView::OnInitialUpdate();
}

void CNetClipView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
    if (theApp.m_fNoUpdate == TRUE)
    {
        // Don't update
        return;
    }

    BeginWaitCursor();

    CMainFrame* pfrm = (CMainFrame*)AfxGetMainWnd();
    pfrm->SetMessageText(IDS_STATUS_UPDATE);

    // If we have an in-place active item then deactivate and
    // close it. 
    CRichEditCntrItem* pItem = GetInPlaceActiveItem();
    if (pItem)
    {
        TRACE(_T("Deactivating in-place active item\n."));
		pItem->Deactivate();
		pItem->Close(OLECLOSE_NOSAVE);
    }

    GetRichEditCtrl().SetRedraw(FALSE);
    GetRichEditCtrl( ).SetReadOnly(FALSE);
    GetRichEditCtrl( ).SetSel(0, -1);
    GetRichEditCtrl( ).Clear();
    if (pfrm->m_cfDisplay == 0 ||
        pfrm->m_cfDisplay == CF_TEXT || 
        pfrm->m_cfDisplay == CF_OEMTEXT ||
        pfrm->m_cfDisplay == CF_UNICODETEXT)
    {
        /*
        HFONT hfont;
        // Set the font to the default font
        if (pfrm->m_cfDisplay == CF_OEMTEXT)
            hfont = (HFONT)GetStockObject(OEM_FIXED_FONT);
        else
            hfont = (HFONT)GetStockObject(ANSI_VAR_FONT);

        LOGFONT lf;
        //hdc = ::GetDC(GetSafeHwnd());
        GetObject(hfont, sizeof(LOGFONT), &lf);
        */

        CHARFORMAT cfmt;
        memset(&cfmt, '\0', sizeof(CHARFORMAT));
        cfmt.cbSize=sizeof(CHARFORMAT);
        cfmt.dwEffects = CFE_AUTOCOLOR;
        if (pfrm->m_cfDisplay == CF_OEMTEXT)
        {
            cfmt.yHeight = 10;
            cfmt.dwMask = CFM_SIZE | CFM_FACE | CFM_COLOR | CFM_BOLD;
            cfmt.bCharSet = ANSI_CHARSET;
            cfmt.bPitchAndFamily = FF_DONTCARE | FIXED_PITCH;
#if defined(_UNICODE) && !defined(_NTBUILD)
            WideCharToMultiByte(CP_ACP, 0, L"Courier", -1, cfmt.szFaceName, sizeof(cfmt.szFaceName)/sizeof(cfmt.szFaceName[0]), NULL, NULL);
#else
            lstrcpy(cfmt.szFaceName, _T("Courier"));
#endif
        }
        else
        {
            cfmt.yHeight = 10;
            cfmt.dwMask = CFM_SIZE | CFM_FACE | CFM_COLOR | CFM_BOLD;
            cfmt.bCharSet = ANSI_CHARSET;
            cfmt.bPitchAndFamily = VARIABLE_PITCH | FF_SWISS ;
#if defined(_UNICODE) && !defined(_NTBUILD)
            WideCharToMultiByte(CP_ACP, 0, L"MS Sans Serif", -1, cfmt.szFaceName, sizeof(cfmt.szFaceName)/sizeof(cfmt.szFaceName[0]), NULL, NULL);
#else
            lstrcpy(cfmt.szFaceName, _T("MS Sans Serif"));
#endif
        }
        GetRichEditCtrl().SetDefaultCharFormat(cfmt);
    }


    if (pfrm->m_fDisplayAsIcon)
    {
        // TODO: Implement
    }
    else
    {
        IRichEditOle* prich = GetRichEditCtrl().GetIRichEditOle();
        if (prich)
        {
            IDataObject* pdo = NULL;
            if (pfrm->m_pClipboard)
                pfrm->m_pClipboard->GetClipboard(&pdo);
            else
                OleGetClipboard(&pdo);

            pfrm->SetMessageText(IDS_STATUS_GETTING_CLIPDATA);
            if (pdo)
            {
                if (pfrm->m_cfDisplay == CF_OEMTEXT)
                    prich->ImportDataObject(pdo, CF_TEXT, NULL);
                else
                    prich->ImportDataObject(pdo, (CLIPFORMAT)pfrm->m_cfDisplay, NULL);
	            pdo->Release();
            }
            prich->Release();
        }
    }

    GetRichEditCtrl().SetSel(0, 0);
    GetRichEditCtrl().LineScroll(0,0);
    GetRichEditCtrl().SetReadOnly(TRUE);
    GetRichEditCtrl().SetRedraw(TRUE);
    GetRichEditCtrl().InvalidateRect(NULL);
    GetRichEditCtrl().UpdateWindow();

    EndWaitCursor();
    pfrm->SetMessageText(AFX_IDS_IDLEMESSAGE);
}

BOOL CNetClipView::CanDisplay(UINT cf)
{
    switch(cf)
    {
    case CF_TEXT:
    case CF_OEMTEXT:
    case CF_BITMAP:
    case CF_METAFILEPICT:
    case CF_DIB:
    case CF_UNICODETEXT:
    case CF_ENHMETAFILE:
        return TRUE;
    }

    if (
        cf == cf_EmbedSource ||
        cf == cf_LinkSource ||
        cf == cf_RichTextFormat ||
        cf == cf_RichTextFormatWithoutObjects ||
        cf == cf_RichTextAndObjects
        )
        return TRUE;

    return FALSE;
}

HRESULT CNetClipView::QueryAcceptData(LPDATAOBJECT lpdataobj,
	CLIPFORMAT* lpcfFormat, DWORD dwReco, BOOL bReally, HGLOBAL hMetaPict)
{
	ASSERT(lpcfFormat != NULL);
	// if direct pasting a particular native format allow it
	if (!bReally) // not actually pasting
    {
	    if (IsRichEditFormat(*lpcfFormat))
		    return S_OK;
        else
            return S_FALSE;
    }

    return CRichEditView::QueryAcceptData(lpdataobj,lpcfFormat, dwReco, bReally, hMetaPict);
}

void CNetClipView::OnUpdateNeedSel(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
    CMainFrame* pfrm = (CMainFrame*)AfxGetMainWnd();
	long nStartChar, nEndChar;
	GetRichEditCtrl().GetSel(nStartChar, nEndChar);
	pCmdUI->Enable(pfrm->m_pClipboard!=NULL && (nStartChar != nEndChar));
	ASSERT_VALID(this);
}

void CNetClipView::OnEditCut() 
{
    CRichEditView::OnEditCut();
}

void CNetClipView::OnEditCopy() 
{
    CRichEditView::OnEditCopy();
}


void CNetClipView::OnUpdateEditPaste(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
    CMainFrame* pfrm = (CMainFrame*)AfxGetMainWnd();
	pCmdUI->Enable(pfrm->m_pClipboard!=NULL);
	ASSERT_VALID(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\proxy\shellex.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <ole2.h>
#include <tchar.h>

#ifdef _FEATURE_SHELLEX

#include <shlobj.h>

#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#pragma data_seg()

#include "shellex.h"

CShellEx::CShellEx()
{
#ifdef _DEBUG
    OutputDebugString(_T("CShellEx::CShellEx\r\n"));
#endif

    m_dwRefCount=0;
	m_punkInner=NULL;
	m_punkOuter=NULL;
}

HRESULT CShellEx::Initialize(IUnknown* punkOuter) {
	try
	{
		m_punkInner=new CInnerUnk(this);
	}
	catch(...)
	{
		m_punkInner=NULL;
		return E_OUTOFMEMORY;
	}

	if (punkOuter) 
	{
		m_punkOuter=punkOuter;
	}
	else
	{
		m_punkOuter=(IUnknown*) m_punkInner;
	}

	return S_OK;
}

CShellEx::~CShellEx() 
{
#ifdef _DEBUG
    OutputDebugString(_T("CShellEx::~CShellEx\r\n"));
#endif

	if (m_punkInner)
	{
		delete m_punkInner;
	}
}

HRESULT CShellEx::QueryInterface(REFIID riid, void** ppObject) {
	if (IsBadWritePtr(this, sizeof(*this))) 
	{
		return E_POINTER;
	}
	return m_punkOuter->QueryInterface(riid, ppObject);
}

ULONG CShellEx::AddRef() 
{
	if (IsBadWritePtr(this, sizeof(*this))) 
	{
		return 0;
	}
	return m_punkOuter->AddRef();
}

ULONG CShellEx::Release()
{
	if (IsBadWritePtr(this, sizeof(*this))) 
	{
		return 0;
	}
	return m_punkOuter->Release();
}

CShellEx::CInnerUnk::CInnerUnk(CShellEx* pObj)
{
	m_pObj=pObj;
}

HRESULT CShellEx::CInnerUnk::QueryInterface(REFIID riid, void** ppObject) 
{
#ifdef _DEBUG
    OutputDebugString(_T("CShellEx::CInnerUnk::QueryInterface\r\n"));
#endif
	if (IsBadWritePtr(this, sizeof(*this))) 
	{
#ifdef _DEBUG
        OutputDebugString(_T("CShellEx::CInnerUnk::QueryInterface failed E_POINTER\r\n"));
#endif
		return E_POINTER;
	}
    else if (riid==IID_IUnknown || riid== IID_IShellExtInit) 
    {
		*ppObject=(IShellExtInit*) m_pObj;
    }
    else if (riid==IID_IDropTarget)
	{
		*ppObject=(IDropTarget*) m_pObj;
	}
    else if (riid==IID_IExtractIcon)
	{
		*ppObject=(IExtractIcon*) m_pObj;
	}
    else if (riid==IID_IContextMenu)
	{
		*ppObject=(IContextMenu*) m_pObj;
	}
	else 
	{
#ifdef _DEBUG
        WCHAR sz[256];
        StringFromGUID2(riid, sz, 256);
        OutputDebugString(_T("CShellEx::CInnerUnk::QueryInterface failed E_NOINTERFACE: "));
        OutputDebugStringW(sz);
        OutputDebugString(_T("\r\n"));
#endif
		return E_NOINTERFACE;
	}
	m_pObj->AddRef();
	return S_OK;
}

ULONG CShellEx::CInnerUnk::AddRef() 
{
	if (IsBadWritePtr(this, sizeof(*this))) 
	{
		return 0;
	}
	InterlockedIncrement((long*) &g_dwRefCount);
	InterlockedIncrement((long*) &m_pObj->m_dwRefCount);
	return m_pObj->m_dwRefCount;
}

ULONG CShellEx::CInnerUnk::Release()
{
	if (IsBadWritePtr(this, sizeof(*this))) 
	{
		return 0;
	}
	ULONG dwRefCount=(m_pObj->m_dwRefCount)-1;
	InterlockedDecrement((long*) &g_dwRefCount);
	if (InterlockedDecrement((long*) &m_pObj->m_dwRefCount)==0) 
	{
		delete m_pObj;
		return 0;
	}
	return dwRefCount;
}

// IShellExtInit::Initialize
HRESULT CShellEx::Initialize(LPCITEMIDLIST pidlFolder,LPDATAOBJECT lpdobj, HKEY hkeyProgID)
{
#ifdef _DEBUG
    OutputDebugString(_T("CShellEx::Initialize\r\n"));
#endif
    return S_OK;
}

// IDropTarget::DragEnter
HRESULT CShellEx::DragEnter( 
    /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD __RPC_FAR *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY ;
    return S_OK;
}

// IDropTarget::DragOver
HRESULT CShellEx::DragOver( 
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD __RPC_FAR *pdwEffect)
{
    // Prevent d&d'ing on self

    // TODO: We should check to make sure the dataobject passed in
    // has a format we can support.
    //

    // check for force link
    if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
        *pdwEffect= DROPEFFECT_LINK;
    // check for force copy
    else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
        *pdwEffect= DROPEFFECT_COPY;
    // check for force move
    else if ((grfKeyState & MK_ALT) == MK_ALT)
        *pdwEffect= DROPEFFECT_MOVE;
    // default -- recommended action is move
    else
        *pdwEffect= DROPEFFECT_MOVE;
    return S_OK;
}

// IDropTarget::DragLeave
HRESULT CShellEx::DragLeave( void)
{
    return S_OK;
}

// IDropTarget::Drop
HRESULT CShellEx::Drop( 
    /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD __RPC_FAR *pdwEffect)
{
    return S_OK;
}

// IExtractIcon::GetIconLocation
HRESULT CShellEx::GetIconLocation(UINT uFlags,LPSTR  szIconFile,UINT   cchMax,int   * piIndex,UINT  * pwFlags)
{
#ifdef _DEBUG
    OutputDebugString(_T("CShellEx::GetIconLocation\n\r"));
#endif
	HMODULE hModule;
	hModule=GetModuleHandle(_T("nclipps.DLL"));
	if (!hModule) 
	{
#ifdef _DEBUG
        OutputDebugString(_T("GetModuleHandle failed in CShellEx::GetIconLocation\n\r"));
#endif
        return E_UNEXPECTED;
    }

	if (GetModuleFileName(hModule, szIconFile, cchMax)==0) 
	{
#ifdef _DEBUG
        OutputDebugString(_T("GetModuleFileName failed in CShellEx::GetIconLocation\n\r"));
#endif
        return E_UNEXPECTED;
    }

    *piIndex = 0;
    *pwFlags = GIL_PERINSTANCE;
    
    return S_OK;
}

// IContextMenu::GetCommandString
HRESULT CShellEx::GetCommandString(UINT idCmd, UINT uFlags, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

// IContextMenu::InvokeCommand
HRESULT CShellEx::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    return E_NOTIMPL;
}

// IContextMenu::QueryContextMenu
HRESULT CShellEx::QueryContextMenu(HMENU hMenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags) 
{ 
    return E_NOTIMPL;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\proxy\shellex.h ===
#ifndef __ncshellex_h__
#define __ncshellex_h__

class CShellExFactory;

class CShellEx : public IShellExtInit, IDropTarget, IContextMenu
{
public:
	// IUnknown methods
	HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	ULONG	_stdcall AddRef();
	ULONG	_stdcall Release();

    // IShellExtInit methods 
    HRESULT _stdcall Initialize(LPCITEMIDLIST pidlFolder,LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    HRESULT __stdcall DragEnter( 
        /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
        /* [in] */ DWORD grfKeyState,
        /* [in] */ POINTL pt,
        /* [out][in] */ DWORD __RPC_FAR *pdwEffect);
    
    HRESULT __stdcall DragOver( 
        /* [in] */ DWORD grfKeyState,
        /* [in] */ POINTL pt,
        /* [out][in] */ DWORD __RPC_FAR *pdwEffect);
    
    HRESULT __stdcall DragLeave( void);
    
    HRESULT __stdcall Drop( 
        /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
        /* [in] */ DWORD grfKeyState,
        /* [in] */ POINTL pt,
        /* [out][in] */ DWORD __RPC_FAR *pdwEffect);

    // *** IExtractIcon methods ***
    HRESULT __stdcall GetIconLocation(
                         UINT   uFlags,
                         LPSTR  szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags);

	// IContextMenu methods
    HRESULT _stdcall QueryContextMenu(HMENU hMenu,UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    HRESULT _stdcall InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    HRESULT _stdcall GetCommandString(UINT idCmd, UINT uFlags,UINT *pwReserved, LPSTR pszName, UINT cchMax);
    
    friend CShellExFactory;

private:

	CShellEx();
	HRESULT Initialize(IUnknown* punkOuter);
	~CShellEx();

	class CInnerUnk : public IUnknown 
	{
	public:
		// IUnknown methods
		HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
		ULONG	_stdcall AddRef();
		ULONG	_stdcall Release();

		CInnerUnk(CShellEx* pObj);

		CShellEx* m_pObj;
	} *m_punkInner;
	friend CInnerUnk;

	IUnknown* m_punkOuter;
	ULONG m_dwRefCount;
};

extern ULONG g_dwRefCount;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\netclip\proxy\classfac.cpp ===
#include "windows.h"
#include "ole2.h"
#include "tchar.h"

#ifdef _FEATURE_SHELLEX
#include <shlobj.h>
#include <shlguid.h>
#endif

#include "classfac.h"

#ifdef _FEATURE_SHELLEX
#include "shellex.h"
// {B222AAAA-8813-11cf-A54D-080036F12502}
static const CLSID CLSID_NetClipShellEx = 
{ 0xb222aaaa, 0x8813, 0x11cf, { 0xa5, 0x4d, 0x8, 0x0, 0x36, 0xf1, 0x25, 0x2 } };

ULONG g_dwRefCount=0;

// Create a new database object and return a pointer to it
HRESULT CShellExFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppObject) 
{
	if (pUnkOuter && riid!=IID_IUnknown)
	{
		*ppObject=NULL;
		return E_INVALIDARG;
	}
	CShellEx* pObj=new CShellEx();
	HRESULT hRes=pObj->Initialize(pUnkOuter);
	if (FAILED(hRes)) 
	{
		delete pObj;
		return hRes;
	}
	
	if (pUnkOuter)
	{
		*ppObject=(IUnknown*) (pObj->m_punkInner);
		pObj->m_punkInner->AddRef();
	}
	else if (FAILED(pObj->QueryInterface(riid, ppObject))) 
	{
		delete pObj;
		*ppObject=NULL;
		return E_NOINTERFACE;
	}
	return S_OK;
}

HRESULT	CShellExFactory::LockServer(BOOL fLock) 
{
	if (fLock) 
	{
		InterlockedIncrement((long*) &g_dwRefCount);
	}
	else 
	{
		InterlockedDecrement((long*) &g_dwRefCount);
	}
	return S_OK;
}

CShellExFactory::CShellExFactory() 
{
	m_dwRefCount=0;
}

HRESULT CShellExFactory::QueryInterface(REFIID riid, void** ppObject) 
{
	if (riid==IID_IUnknown || riid==IID_IClassFactory) 
	{
		*ppObject=(IClassFactory*) this;
	}
	else 
	{
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

ULONG CShellExFactory::AddRef() 
{
	InterlockedIncrement((long*) &g_dwRefCount);
	InterlockedIncrement((long*) &m_dwRefCount);
	return m_dwRefCount;
}

ULONG CShellExFactory::Release() 
{
    ULONG dwRefCount=m_dwRefCount-1;
	InterlockedDecrement((long*) &g_dwRefCount);
	if (InterlockedDecrement((long*) &m_dwRefCount)==0) 
	{
		delete this;
		return 0;
	}
	return dwRefCount;
}
#endif

// Declarations for PS functions
STDAPI PSDllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject);
STDAPI PSDllCanUnloadNow();
STDAPI PSDllRegisterServer(void);
STDAPI PSDllUnregisterServer(void);

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject) 
{
#ifdef _FEATURE_SHELLEX
	if (rclsid==CLSID_NetClipShellEx) 
	{
		CShellExFactory *pFactory= new CShellExFactory;
		if (FAILED(pFactory->QueryInterface(riid, ppObject))) 
		{
			delete pFactory;
			*ppObject=NULL;
			return E_INVALIDARG;
		}
	}
	else 
#endif
	{ 
		return PSDllGetClassObject(rclsid, riid, ppObject);
	}
#ifdef _FEATURE_SHELLEX
	return NO_ERROR;
#endif
}

STDAPI DllCanUnloadNow() 
{
	if (g_dwRefCount) 
	{
		return S_FALSE;
	}
	else 
	{
		return PSDllCanUnloadNow();
	}
}

STDAPI DllRegisterServer(void) 
{
	PSDllRegisterServer(); // Register ProxyStubs

#ifdef _FEATURE_SHELLEX
    HKEY hKeyCLSID, hKeyInproc32;
    HKEY hKey;
    TCHAR szValue[256];
	DWORD dwDisposition;

	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{B222AAAA-8813-11cf-A54D-080036F12502}"), 
			NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

	if (RegSetValueEx(hKeyCLSID, _T(""), NULL, REG_SZ, (BYTE*) _T("Remote Clipboard Shell Extension"), sizeof("Remote Clipboard Shell Extension")*sizeof(TCHAR))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}

	if (RegCreateKeyEx(hKeyCLSID, 
			_T("InprocServer32"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}

	HMODULE hModule;
	hModule=GetModuleHandle(_T("nclipps.DLL"));
	if (!hModule) 
	{
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}
	TCHAR szName[MAX_PATH+64];
	if (GetModuleFileName(hModule, szName, sizeof(szName))==0) 
	{
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}
	if (RegSetValueEx(hKeyInproc32, _T(""), NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}

    lstrcat(szValue, _T("Apartment"));
	if (RegSetValueEx(hKeyInproc32, _T("ThreadingModel"), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKeyInproc32);

	if (RegCreateKeyEx(hKeyCLSID, 
			_T("DefaultIcon"), 
			NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}
    lstrcat(szName, _T(",0"));
	if (RegSetValueEx(hKeyInproc32, _T(""), NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}

    RegCloseKey(hKeyInproc32);
	RegCloseKey(hKeyCLSID);

    // [HKEY_CLASSES_ROOT\.{B222AAAA-8813-11cf-A54D-080036F12502}]
    //    @="NetClipFile"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T(".{B222AAAA-8813-11cf-A54D-080036F12502}"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("NetClipFile"));
	if (RegSetValueEx(hKey, _T(""), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);

    // [HKEY_CLASSES_ROOT\.{B222AAAA-8813-11cf-A54D-080036F12502}\ShellNew]
    //    @="NetClipFile"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T(".{B222AAAA-8813-11cf-A54D-080036F12502}\\ShellNew"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T(""));
	if (RegSetValueEx(hKey, _T("NullFile"), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);

    // [HKEY_CLASSES_ROOT\NetClipFile]
    //    @="Remote Clipboard"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("NetClipFile"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("Remote Clipboard"));
	if (RegSetValueEx(hKey, _T(""), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);


    // [HKEY_CLASSES_ROOT\NetClipFile\CLSID]
    //    @="{B222AAAA-8813-11cf-A54D-080036F12502}"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\CLSID"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("{B222AAAA-8813-11cf-A54D-080036F12502}"));
	if (RegSetValueEx(hKey, _T(""), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);

#ifdef FEATURE_MENUHANDLER
    // [HKEY_CLASSES_ROOT\NetClipFile\shellex\ContextMenuHandlers]
    //    @="NetClipMenu"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex\\ContextMenuHandlers"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("NetClipMenu"));
	if (RegSetValueEx(hKey, _T(""), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);

    // [HKEY_CLASSES_ROOT\NetClipFile\shellex\ContextMenuHandlers\NetClipMenu]
    //    @="{B222AAAA-8813-11cf-A54D-080036F12502}"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex\\ContextMenuHandlers\\NetClipMenu"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("{B222AAAA-8813-11cf-A54D-080036F12502}"));
	if (RegSetValueEx(hKey, _T(""), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);
    
#endif

    // [HKEY_CLASSES_ROOT\NetClipFile\DefaultIcon]
    //    @="%1"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\DefaultIcon"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("%1"));
	if (RegSetValueEx(hKey, _T(""), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);

    // [HKEY_CLASSES_ROOT\NetClipFile\shellex\DropHandler]
    //    @="{B222AAAA-8813-11cf-A54D-080036F12502}"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex\\DropHandler"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("{B222AAAA-8813-11cf-A54D-080036F12502}"));
	if (RegSetValueEx(hKey, _T(""), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);

    // [HKEY_CLASSES_ROOT\NetClipFile\shellex\IconHandler]
    //    @="%1"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex\\IconHandler"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("{B222AAAA-8813-11cf-A54D-080036F12502}"));
	if (RegSetValueEx(hKey, _T(""), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);


    // [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved]
    //    "{B222AAAA-8813-11cf-A54D-080036F12502}"="Remote Clipboard"
	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
			_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("Remote Clipboard"));
	if (RegSetValueEx(hKey, _T("{B222AAAA-8813-11cf-A54D-080036F12502}"), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);


    // [HKEY_CLASSES_ROOT\NetClipFile\shell\open\command]
    //    @="netclip.exe"
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shell\\open\\command"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
			&hKey, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    lstrcpy(szValue, _T("netclip.exe"));
	if (RegSetValueEx(hKey, _T(""), NULL, REG_SZ, (BYTE*) szValue, sizeof(TCHAR)*(lstrlen(szValue)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKey);
		return E_UNEXPECTED;
	}
    RegCloseKey(hKey);
#endif

	return NOERROR;
}

STDAPI DllUnregisterServer(void) 
{
	PSDllUnregisterServer();
#ifdef _FEATURE_SHELLEX
    if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{B222AAAA-8813-11cf-A54D-080036F12502}\\InprocServer32"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{B222AAAA-8813-11cf-A54D-080036F12502}\\DefaultIcon"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}


    if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{B222AAAA-8813-11cf-A54D-080036F12502}"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\.{B222AAAA-8813-11cf-A54D-080036F12502}\ShellNew]
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T(".{B222AAAA-8813-11cf-A54D-080036F12502}\\ShellNew"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\.{B222AAAA-8813-11cf-A54D-080036F12502}]
    //    @="NetClipFile"
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T(".{B222AAAA-8813-11cf-A54D-080036F12502}"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

#ifdef FEATURE_MENUHANDLER
    // [HKEY_CLASSES_ROOT\NetClipFile\shellex\ContextMenuHandlers\NetClipMenu]
    //    @="{B222AAAA-8813-11cf-A54D-080036F12502}"
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex\\ContextMenuHandlers\\NetClipMenu"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\NetClipFile\shellex\ContextMenuHandlers]
    //    @="NetClipMenu"
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex\\ContextMenuHandlers"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
    // [HKEY_CLASSES_ROOT\NetClipFile\shellex]
    //    @="NetClipMenu"
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
#endif

    // [HKEY_CLASSES_ROOT\NetClipFile\CLSID]
    //    @="{B222AAAA-8813-11cf-A54D-080036F12502}"
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\CLSID"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\NetClipFile\shellex\DropHandler]
    //    @="{B222AAAA-8813-11cf-A54D-080036F12502}"
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex\\DropHandler"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\NetClipFile\shellex\IconHandler]
    //    @="{B222AAAA-8813-11cf-A54D-080036F12502}"
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex\\IconHandler"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\NetClipFile\shellex]
    //    @="{B222AAAA-8813-11cf-A54D-080036F12502}"
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shellex"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\NetClipFile\DefaultIcon]
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\DefaultIcon"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\NetClipFile\shell\open\command]
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shell\\open\\command"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\NetClipFile\shell\open
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shell\\open"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\NetClipFile\shell]
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile\\shell"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_CLASSES_ROOT\NetClipFile]
    //    @="Remote Clipboard Shell Extension file"
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("NetClipFile"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    // [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved]
    //    "{B222AAAA-8813-11cf-A54D-080036F12502}"="Remote Clipboard Shell Extension"
    HKEY hKey;
	if (RegOpenKey(HKEY_LOCAL_MACHINE, 
			_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"), 
			&hKey)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    if (RegDeleteValue(hKey, _T("{B222AAAA-8813-11cf-A54D-080036F12502}")) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return E_UNEXPECTED;
    }
    RegCloseKey(hKey);
#endif

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\npdate.c ===
/* npdate - Code for getting and inserting current date and time.
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#include "precomp.h"

/* ** Replace current selection with date/time string.
 *    if fCrlf is true, date/time string should begin
 *    and end with crlf
*/
VOID InsertDateTime (BOOL fCrlf)
{
   SYSTEMTIME time ;
   TCHAR szDate[80] ;
   TCHAR szTime[80] ;
   TCHAR szDateTime[sizeof(szDate) + sizeof(szTime) + 10] = TEXT("");
   DWORD locale;
   BOOL bMELocale;
   DWORD dwFlags = DATE_SHORTDATE;

   //  See if the user locale id is Arabic or Hebrew.
   locale    = GetUserDefaultLCID();
   bMELocale = ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
                (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW));

   locale = MAKELCID( MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT) ;

   // Get the time
   GetLocalTime( &time ) ;

   if (bMELocale)
   {
       //Get the date format that matches the edit control reading direction.
       if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING) {
           dwFlags |= DATE_RTLREADING;
           lstrcat(szDateTime, TEXT("\x200F")); // RLM
       } else {
           dwFlags |= DATE_LTRREADING;
           lstrcat(szDateTime, TEXT("\x200E")); // LRM
       }
   }

   // Format date and time
   GetDateFormat(locale,dwFlags, &time,NULL,szDate,CharSizeOf(szDate));
   GetTimeFormat(locale,TIME_NOSECONDS,&time,NULL,szTime,CharSizeOf(szTime));

   if( fCrlf )
       lstrcat(szDateTime, TEXT("\r\n"));


   lstrcat(szDateTime, szTime);
   lstrcat(szDateTime, TEXT(" "));
   lstrcat(szDateTime, szDate);

   if( fCrlf )
        lstrcat(szDateTime, TEXT("\r\n"));

   // send it in one shot; this is also useful for undo command
   // so that user can undo the date-time.
   SendMessage(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szDateTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\npcss.c ===
/*
 * CSS support functions
 *  Copyright (C) 2000 Microsoft Corporation
 */

#include "precomp.h"


BOOL FIsCssWhitespaceW(WCHAR wch)
{
    return((wch == L' ') || (wch == L'\x9') || (wch == L'\xA') || (wch == L'\xC') || (wch == L'\xD'));
}


BOOL FIsCssWhitespaceA(char ch)
{
    return(FIsCssWhitespaceW((WCHAR) (BYTE) ch));
}


BOOL FIsCssA(LPCSTR rgch, UINT cch)
{
    if (memcmp(rgch, "@charset", 8) != 0)
    {
        // Not XML

        return(FALSE);
    }

    return(TRUE);

    UNREFERENCED_PARAMETER( cch );
}


BOOL FIsCssW(LPCWSTR rgwch, UINT cch)
{
    if (memcmp(rgwch, L"@charset", 8 * sizeof(WCHAR)) != 0)
    {
        // Not XML

        return(FALSE);
    }

    return(TRUE);

    UNREFERENCED_PARAMETER( cch );
}


BOOL FDetectCssEncodingA(LPCSTR rgch, UINT cch, UINT *pcp)
{
    const char *pchMax;
    const char *pch;
    char chQuote;
    const char *pchCharset;

    // Check for file begining with @charset

    if (cch < 13)
    {
        // File is too small

        return(FALSE);
    }

    if (!FIsCssA(rgch, cch))
    {
        // Not XML

        return(FALSE);
    }

    // Don't scan more than 4K looking for encoding even if it is valid XML

    cch = __min(cch, 4096);

    pchMax = rgch + cch;
    pch = rgch + 8;

    while ((pch < pchMax) && FIsCssWhitespaceA(*pch))
    {
        pch++;
    }

    if ((pch == pchMax) || ((*pch != '\'') && (*pch != '"')))
    {
        // No @charset specification

        return(FALSE);
    }

    chQuote = *pch++;

    pchCharset = pch;

    while ((pch < pchMax) && (*pch != chQuote))
    {
        pch++;
    }

    if (pch == pchMax)
    {
        // No @charset specification

        return(FALSE);
    }

    // We have an CSS encoding declaration from pchCharset to (pch - 1)

    if (pch == pchCharset)
    {
        // No @charset specification

        return(FALSE);
    }

    // To be strict a CSS charset declaration should have optional whitespace then a semicolon here

    if (!FLookupCodepageNameA((LPCSTR) pchCharset, (UINT) (pch - pchCharset), pcp))
    {
        // Encoding is not recognized

        return(FALSE);
    }

    if ((*pcp == CP_UTF16) || (*pcp == CP_UTF16BE))
    {
        // These are bogus since we know the file is MBCS

        return(FALSE);
    }

    return(FValidateCodepage(hwndNP, *pcp));
}


BOOL FDetectCssEncodingW(LPCWSTR rgch, UINT cch, UINT *pcp)
{
    const WCHAR *pchMax;
    const WCHAR *pch;
    WCHAR chQuote;
    const WCHAR *pchCharset;

    // Check for file begining with @charset

    if (cch < 13)
    {
        // File is too small

        return(FALSE);
    }

    if (!FIsCssW(rgch, cch))
    {
        // No @charset specification

        return(FALSE);
    }

    // Don't scan more than 4K looking for encoding even if it is valid XML

    cch = __min(cch, 4096);

    pchMax = rgch + cch;
    pch = rgch + 8;

    while ((pch < pchMax) && FIsCssWhitespaceW(*pch))
    {
        pch++;
    }

    if ((pch == pchMax) || ((*pch != L'\'') && (*pch != L'"')))
    {
        // No @charset specification

        return(FALSE);
    }

    chQuote = *pch++;

    pchCharset = pch;

    while ((pch < pchMax) && (*pch != chQuote))
    {
        pch++;
    }

    if (pch == pchMax)
    {
        // No @charset specification

        return(FALSE);
    }

    // We have an CSS encoding declaration from pchCharset to (pch - 1)

    if (pch == pchCharset)
    {
        // No @charset specification

        return(FALSE);
    }

    // To be strict a CSS charset declaration should have optional whitespace then a semicolon here

    if (!FLookupCodepageNameW(pchCharset, (UINT) (pch - pchCharset), pcp))
    {
        // Encoding is not recognized

        return(FALSE);
    }

#if 0
    if ((*pcp == CP_UTF16) || (*pcp == CP_UTF16BE))
    {
        // These are bogus since we know the file is MBCS

        return(FALSE);
    }
#endif

    return(FValidateCodepage(hwndNP, *pcp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\notepad.h ===
/* Notepad.h */

#pragma warning(disable: 4201) // nonstd extension: nameless struct/union
#pragma warning(disable:4127) // conditional expression is constant
#define NOCOMM
#define NOSOUND
#define STRICT
#include <windows.h>
#include <ole2.h>
#include <commdlg.h>
#include <commctrl.h>

// we need this for CharSizeOf(), ByteCountOf(),
#include "uniconv.h"

/* handy debug macro */
#define ODS OutputDebugString

#define CP_UTF16     1200
#define CP_UTF16BE   1201
#define CP_AUTO      65536             // Internal to notepad

#define BOM_UTF8_HALF        0xBBEF
#define BOM_UTF8_2HALF       0xBF


/* openfile filter for all text files */
#define FILE_TEXT         1
#define FILE_ENCODED      4


typedef enum WB
{
   wbDefault,                          // New file or loaded from encoding without BOM
   wbNo,                               // BOM was not present
   wbYes,                              // BOM was not present
} WB;


/* ID for the status window */
#define ID_STATUS_WINDOW     WM_USER+1



#define PT_LEN               40    /* max length of page setup strings */
#define CCHFILTERMAX         256   /* max. length of filter name buffers */

// Menu IDs 
#define ID_APPICON           1 /* must be one for explorer to find this */
#define ID_ICON              2
#define ID_MENUBAR           1

// Dialog IDs

#define IDD_ABORTPRINT           11
#define IDD_PAGESETUP            12
#define IDD_SAVEDIALOG           13    // template for save dialog
#define IDD_GOTODIALOG           14    // goto line number dialog
#define IDD_SELECT_ENCODING      15    // Select Encoding dialog
#define IDD_SAVE_UNICODE_DIALOG  16    //

// Control IDs 

#define IDC_CODEPAGE         257   // listbox in save dialog
#define IDC_GOTO             258   // line number to goto
#define IDC_ENCODING         259   // static text in save dialog
#define IDC_SAVE_AS_UNICODE  260

//  Menu IDs 

// File
#define M_NEW                1
#define M_OPEN               2
#define M_SAVE               3
#define M_SAVEAS             4
#define M_PAGESETUP          5
#define M_PRINT              6
#define M_EXIT               7

// Edit
#define M_UNDO               16
#define M_CUT                WM_CUT       /* These just get passed down to the edit control */
#define M_COPY               WM_COPY
#define M_PASTE              WM_PASTE
#define M_CLEAR              WM_CLEAR
#define M_FIND               21
#define M_FINDNEXT           22
#define M_REPLACE            23
#define M_GOTO               24
#define M_SELECTALL          25
#define M_DATETIME           26
#define M_STATUSBAR          27

// Format
#define M_WW                 32
#define M_SETFONT            33

// Help
#define M_HELP               64
#define M_ABOUT              65

// Control IDs

#define ID_EDIT              15
#define ID_FILENAME          20
#define ID_PAGENUMBER        21


#define ID_HEADER            30
#define ID_FOOTER            31
#define ID_HEADER_LABEL      32
#define ID_FOOTER_LABEL      33

#define ID_ASCII             50
#define ID_UNICODE           51


// IDs used to load RC strings

#define IDS_DISKERROR         1
#define IDS_FNF               2
#define IDS_SCBC              3
#define IDS_UNTITLED          4
#define IDS_NOTEPAD           5
#define IDS_CFS               6
#define IDS_ERRSPACE          7
#define IDS_FTL               8
#define IDS_NN                9
#define IDS_COMMDLGINIT      10
#define IDS_PRINTDLGINIT     11
#define IDS_CANTPRINT        12
#define IDS_NVF              13
#define IDS_CREATEERR        14
#define IDS_NOWW             15
#define IDS_MERGE1           16
#define IDS_HELPFILE         17
#define IDS_HEADER           18
#define IDS_FOOTER           19

#define IDS_TEXTFILES        20
#define IDS_HTMLFILES        21
#define IDS_XMLFILES         22
#define IDS_ENCODEDTEXT      23
#define IDS_ALLFILES         24

#define IDS_MOREENCODING     25

#define IDS_CANNOTQUIT       28
#define IDS_LOADDRVFAIL      29
#define IDS_ACCESSDENY       30

#define IDS_FONTTOOBIG       31
#define IDS_COMMDLGERR       32

#define IDS_LINEERROR        33  /* line number error     */
#define IDS_LINETOOLARGE     34  /* line number too large */
#define IDS_INVALIDCP        35  /* invalid codepage */
#define IDS_INVALIDIANA      36  /* invalid encoding */
#define IDS_ENCODINGMISMATCH 37

#define IDS_CURRENT_PAGE     38  /* currently printing page on abort dlg */

// constants for the status bar
#define IDS_LINECOL          39
#define IDS_COMPRESSED_FILE  40
#define IDS_ENCRYPTED_FILE   41
#define IDS_HIDDEN_FILE      42
#define IDS_OFFLINE_FILE     43
#define IDS_READONLY_FILE    44
#define IDS_SYSTEM_FILE      45
#define IDS_FILE             46

#define IDS_NOSTATUSAVAIL    47  

#define CCHKEYMAX           128  /* max characters in search string */

#define CCHNPMAX              0  /* no limit on file size */

#define SETHANDLEINPROGRESS   0x0001 /* EM_SETHANDLE has been sent */
#define SETHANDLEFAILED       0x0002 /* EM_SETHANDLE caused EN_ERRSPACE */

/* Standard edit control style:
 * ES_NOHIDESEL set so that find/replace dialog doesn't undo selection
 * of text while it has the focus away from the edit control.  Makes finding
 * your text easier.
 */
#define ES_STD (WS_CHILD|WS_VSCROLL|WS_VISIBLE|ES_MULTILINE|ES_NOHIDESEL)

/* EXTERN decls for data */

extern BOOL fCase;                /* Flag specifying case sensitive search */
extern BOOL fReverse;             /* Flag for direction of search */
extern TCHAR szSearch[];
extern HWND hDlgFind;             /* handle to modeless FindText window */

extern HANDLE hEdit;
extern HANDLE hFont;
extern HANDLE hAccel;
extern HANDLE hInstanceNP;
extern HANDLE hStdCursor, hWaitCursor;
extern HWND   hwndNP, hwndEdit, hwndStatus;

extern LOGFONT  FontStruct;
extern INT      iPointSize;

extern BOOL     fRunBySetup;

extern DWORD    dwEmSetHandle;

extern TCHAR    chMerge;

extern BOOL     fWrap;
extern TCHAR    szFileOpened[];
extern HANDLE   fp;

//
// Holds header and footer strings to be used in printing.
// use HEADER and FOOTER to index.
//
extern TCHAR    chPageText[2][PT_LEN]; // header and footer strings
#define HEADER 0
#define FOOTER 1
//
// Holds header and footer from pagesetupdlg during destroy.
// if the user hit ok, then keep.  Otherwise ignore.
//
extern TCHAR    chPageTextTemp[2][PT_LEN];

extern TCHAR    szNotepad[];
extern TCHAR   *szMerge;
extern TCHAR   *szUntitled, *szNpTitle, *szNN, *szErrSpace;
extern TCHAR  **const rgsz[];     /* More strings. */
extern TCHAR   *szNVF;
extern TCHAR   *szPDIE;
extern TCHAR   *szDiskError;
extern TCHAR   *szCREATEERR;
extern TCHAR   *szWE;
extern TCHAR   *szFTL;
extern TCHAR   *szINF;
extern TCHAR   *szFNF;
extern TCHAR   *szNEDSTP;
extern TCHAR   *szNEMTP;
extern TCHAR   *szCFS;
extern TCHAR   *szPE;
extern TCHAR   *szCP;
extern TCHAR   *szACCESSDENY;
extern TCHAR   *szFontTooBig;
extern TCHAR   *szLoadDrvFail;
extern TCHAR   *szCommDlgErr;
extern TCHAR   *szCommDlgInitErr;
extern TCHAR   *szInvalidCP;
extern TCHAR   *szInvalidIANA;
extern TCHAR   *szEncodingMismatch;
extern TCHAR   *szHelpFile;

extern TCHAR   *szCurrentPage;
extern TCHAR   *szHeader;
extern TCHAR   *szFooter;

/* variables for the new File/Open and File/Saveas dialogs */
extern OPENFILENAME OFN;        /* passed to the File Open/save APIs */
extern TCHAR  szOpenFilterSpec[]; /* default open filter spec          */
extern TCHAR  szSaveFilterSpec[]; /* default save filter spec          */

extern TCHAR *szTextFiles;      /* File/Open TXT filter spec. string */
extern TCHAR *szHtmlFiles;      /* File/Open HTML filter spec. string */
extern TCHAR *szXmlFiles;       /* File/Open XML filter spec. string */
extern TCHAR *szEncodedText;    /* File/Open TXT Filter spec. string */
extern TCHAR *szAllFiles;       /* File/Open Filter spec. string */
extern TCHAR *szMoreEncoding;

extern FINDREPLACE FR;          /* Passed to FindText()        */
extern PAGESETUPDLG g_PageSetupDlg;
extern TCHAR szPrinterName[];   /* name of the printer passed to PrintTo */

extern UINT g_cpANSI;           /* system ANSI codepage (GetACP())   */
extern UINT g_cpOEM;            /* system OEM codepage (GetOEMCP())  */
extern UINT g_cpUserLangANSI;   /* user UI language ANSI codepage    */
extern UINT g_cpUserLangOEM;    /* user UI language OEM codepage     */
extern UINT g_cpUserLocaleANSI; /* user default LCID ANSI codepage   */
extern UINT g_cpUserLocaleOEM;  /* user default LCID OEM codepage    */
extern UINT g_cpKeyboardANSI;   /* keyboard ANSI codepage            */
extern UINT g_cpKeyboardOEM;    /* keyboard OEM codepage             */

extern BOOL g_fSelectEncoding;  /* Prompt for encoding by default    */
extern UINT g_cpDefault;        /* codepage default                  */
extern UINT g_cpOpened;         /* codepage of open file             */
extern UINT g_cpSave;           /* codepage in which to save         */
extern WB   g_wbOpened;         /* BOM was present when opened       */
extern WB   g_wbSave;           /* BOM should be saved               */
extern BOOL g_fSaveEntity;      /* Entities should be saved          */

extern UINT   wFRMsg;           /* message used in communicating     */
                                /*   with Find/Replace dialog        */
extern UINT   wHlpMsg;          /* message used in invoking help     */

extern HMENU hSysMenuSetup;     /* Save Away for disabled Minimize   */
extern BOOL  fStatus;
extern INT   dyStatus;


/* Macro for setting status bar - x is the text to set and n is the part number
   in the statusbar */
#define SetStatusBarText(x, n) if(hwndStatus)SendMessage(hwndStatus, SB_SETTEXT, n, (LPARAM)(LPTSTR)(x));



/* EXTERN procs */
/* procs in notepad.c */
VOID
PASCAL
SetPageSetupDefaults(
    VOID
    );

BOOL far PASCAL SaveAsDlgHookProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

LPCTSTR PFileInPath(LPCTSTR szFile);

BOOL CheckSave(BOOL fSysModal);
LRESULT NPWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FUntitled(void);
const TCHAR *SzTitle(void);
void SetFileName(LPCTSTR szFile);
INT AlertBox(HWND hwndParent, LPCTSTR szCaption, LPCTSTR szText1,
                   LPCTSTR szText2, UINT style);
void NpWinIniChange(VOID);
void FreeGlobalPD(void);
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SaveUnicodeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SelectEncodingDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
VOID CALLBACK WinEventFunc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject,
                      LONG idChild, DWORD dwEventThread, DWORD dwmsEventTime);
VOID GotoAndScrollInView( INT OneBasedLineNumber );
void NPSize (int cxNew, int cyNew);


/* procs in npcss.c */
BOOL FDetectCssEncodingA(LPCSTR rgch, UINT cch, UINT *pcp);
BOOL FDetectCssEncodingW(LPCWSTR rgch, UINT cch, UINT *pcp);

/* procs in npdate.c */
VOID InsertDateTime (BOOL fCrlf);

/* procs in npfile.c */
BOOL SaveFile(HWND hwndParent, LPCTSTR szFile, BOOL fSaveAs);
BOOL LoadFile(LPCTSTR szFile, BOOL fSelectEncoding);
VOID New(BOOL fCheck);
void AddExt(TCHAR *sz);
void AlertUser_FileFail(LPCTSTR szFile);
BOOL FDetectEncodingW(LPCTSTR szFile, LPCWSTR rgch, UINT cch, UINT *pcp);

/* procs in nphtml.c */
BOOL FDetectHtmlEncodingA(LPCSTR rgch, UINT cch, UINT* pcp);
BOOL FDetectHtmlEncodingW(LPCWSTR rgch, UINT cch, UINT* pcp);

/* procs in npinit.c */
INT NPInit(HANDLE hInstance, HANDLE hPrevInstance, LPTSTR lpCmdLine, INT cmdShow);
void GetKeyboardCodepages(LANGID);
void GetUserLocaleCodepages(void);
void InitLocale(VOID);
void SaveGlobals(VOID);

/* procs in npmisc.c */
INT FindDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL Search(TCHAR *szSearch);
INT AboutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL NpReCreate(LONG style);
LPTSTR ForwardScan(LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive);

/* procs in npmlang.c */
UINT ConvertFromUnicode(UINT cp, BOOL fNoBestFit, BOOL fWriteEntities, LPCWSTR rgchUtf16, UINT cchUtf16, LPSTR rgchMbcs, UINT cchMbcs, BOOL *pfDefCharUsed);
UINT ConvertToUnicode(UINT cp, LPCSTR rgchMbcs, UINT cchMbcs, LPWSTR rgchUtf16, UINT cchUtf16);
BOOL FDetectEncodingA(LPCSTR rgch, UINT cch, UINT* pcp);
BOOL FLookupCodepageNameA(LPCSTR rgchEncoding, UINT cch, UINT* pcp);
BOOL FLookupCodepageNameW(LPCWSTR rgchEncoding, UINT cch, UINT* pcp);
BOOL FSupportWriteEntities(UINT cp);
BOOL FValidateCodepage(HWND hwnd, UINT cp);
void PopulateCodePages(HWND hWnd, BOOL fSelectEncoding, UINT cpSelect, UINT cpExtra);
void UnloadMlang();

/* procs in npprint.c */
typedef enum _PRINT_DIALOG_TYPE {
   UseDialog,
   DoNotUseDialog,
   NoDialogNonDefault
} PRINT_DIALOG_TYPE;

INT    AbortProc( HDC hPrintDC, INT reserved );
INT_PTR AbortDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
INT    NpPrint( PRINT_DIALOG_TYPE type );
INT    NpPrintGivenDC( HDC hPrintDC );

UINT_PTR
CALLBACK
PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

HANDLE GetPrinterDC (VOID);
HANDLE GetNonDefPrinterDC (VOID);
VOID   PrintIt(PRINT_DIALOG_TYPE type);


/* procs in nputf.c */

INT    IsTextUTF8   (LPSTR lpstrInputStream, INT iLen);
INT    IsInputTextUnicode(LPSTR lpstrInputStream, INT iLen);


/* procs in nxpml.c */
BOOL FDetectXmlEncodingA(LPCSTR rgch, UINT cch, UINT *pcp);
BOOL FDetectXmlEncodingW(LPCWSTR rgch, UINT cch, UINT *pcp);
BOOL FIsXmlW(LPCWSTR rgwch, UINT cch);


// Help IDs for Notepad

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_PAGE_FOOTER                 1000
#define IDH_PAGE_HEADER                 1001
#define IDH_FILETYPE                    1002
#define IDH_GOTO                        1003
#define IDH_CODEPAGE                    1004

// Private message to track the HKL switch

#define PWM_CHECK_HKL                   (WM_APP + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\npfile.c ===
/*
 * npfile.c  - Routines for file i/o for notepad
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#include "precomp.h"


HANDLE  hFirstMem;
const CHAR BOM_UTF8[3] = {(BYTE) 0xEF, (BYTE) 0xBB, (BYTE)0xBF};



//****************************************************************
//
//   ReverseEndian
//
//   Purpose: copies unicode character from one endian source
//            to another.
//
//            may work on lpDst == lpSrc
//

VOID ReverseEndian( PTCHAR lpDst, PTCHAR lpSrc, DWORD nChars )
{
    DWORD  cnt;

    for( cnt=0; cnt < nChars; cnt++,lpDst++,lpSrc++ )
    {
        *lpDst= (TCHAR) (((*lpSrc<<8) & 0xFF00) + ((*lpSrc>>8)&0xFF));
    }
}

//*****************************************************************
//
//   AnsiWriteFile()
//
//   Purpose     : To simulate the effects of _lwrite() in a Unicode
//                 environment by converting to ANSI buffer and
//                 writing out the ANSI text.
//   Returns     : TRUE is successful, FALSE if not
//                 GetLastError() will have the error code.
//
//*****************************************************************

BOOL AnsiWriteFile(HANDLE  hFile,    // file to write to
                   UINT uCodePage,   // code page to convert unicode to
                   LPVOID lpBuffer,  // unicode buffer
                   DWORD nChars,     // number of unicode chars
                   DWORD nBytes )    // number of ascii chars to produce
{
    LPSTR   lpAnsi;              // pointer to allocate buffer
    BOOL    Done;                // status from write (returned)
    DWORD   nBytesWritten;       // number of bytes written

    lpAnsi= (LPSTR) LocalAlloc( LPTR, nBytes + 1 );
    if( !lpAnsi )
    {
       SetLastError( ERROR_NOT_ENOUGH_MEMORY );
       return (FALSE);
    }

    ConvertFromUnicode(uCodePage,         // code page
                       g_fSaveEntity,     // fNoBestFit
                       g_fSaveEntity,     // fWriteEntities
                       (LPWSTR) lpBuffer, // wide char buffer
                       nChars,            // chars in wide char buffer
                       lpAnsi,            // resultant ascii string
                       nBytes,            // size of ascii string buffer
                       NULL);             // flag to set if default char used
                                          
    Done = WriteFile(hFile, lpAnsi, nBytes, &nBytesWritten, NULL);

    LocalFree(lpAnsi);

    return(Done);

} // end of AnsiWriteFile()



// Routines to deal with the soft EOL formatting.
//
// MLE Actually inserts characters into the text being under edit, so they
// have to be removed before saving the file.
//
// It turns out that MLE will get confused if the current line is bigger than
// the current file, so we will reset the cursor to 0,0 to keep it from looking stupid.
// Should be fixed in MLE, but...
//

VOID ClearFmt(VOID) 
{
    if( fWrap )
    {
        GotoAndScrollInView( 1 );

        SendMessage( hwndEdit, EM_FMTLINES, (WPARAM)FALSE, 0 );// remove soft EOLs

    }
}

VOID RestoreFmt(VOID)
{
    if( fWrap )
    {
        NpReCreate( ES_STD );   // slow but it works
    }
}


BOOL FDetectEncodingW(LPCTSTR szFile, LPCWSTR rgch, UINT cch, UINT *pcp)
{
    TCHAR szExt[_MAX_EXT];

    if (FDetectXmlEncodingW(rgch, cch, pcp))
    {
        // We recognized this as an XML file with a valid encoding

        return TRUE;
    }

    if (FDetectHtmlEncodingW(rgch, cch, pcp))
    {
        // We recognized this as an HTML file with a valid encoding

        return TRUE;
    }

    _wsplitpath(szFile, NULL, NULL, NULL, szExt);

    if (lstrcmpi(szExt, TEXT(".css")) == 0)
    {
        if (FDetectCssEncodingW(rgch, cch, pcp))
        {
            // We recognized this as CSS file with a valid encoding

            return TRUE;
        }
    }

    return FALSE;
}


/* Save notepad file to disk.  szFileSave points to filename.  fSaveAs
   is TRUE iff we are being called from SaveAsDlgProc.  This implies we must
   open file on current directory, whether or not it already exists there
   or somewhere else in our search path.
   Assumes that text exists within hwndEdit.    30 July 1991  Clark Cyr
 */

BOOL SaveFile(HWND hwndParent, LPCTSTR szFile, BOOL fSaveAs)
{
  LPTSTR    lpch;
  UINT      nChars;
  BOOL      flag;
  BOOL      fNew = FALSE;
  BOOL      fSaveEntity;
  BOOL      fDefCharUsed = FALSE;
  BOOL*     pfDefCharUsed;
  static const WCHAR wchBOM = BYTE_ORDER_MARK;
  static const WCHAR wchRBOM = REVERSE_BYTE_ORDER_MARK;
  HLOCAL    hEText;                // handle to MLE text
  UINT cpDetected;
  DWORD     nBytesWritten;         // number of bytes written
  UINT      cchMbcs;               // length of equivalent MBCS file


    if (g_cpSave == CP_AUTO)
    {
        UINT cch;
        HANDLE hText;
        int id;

        g_cpSave = g_cpOpened;

        // Check for an HTML or XML file with a declared encoding
        // If one is found, suggest the declared encoding

        cch = (UINT) SendMessage(hwndEdit, WM_GETTEXTLENGTH, 0, 0);
        hText = (HANDLE) SendMessage(hwndEdit, EM_GETHANDLE, 0, 0);

        if (hText != NULL)
        {
            LPCTSTR rgwch = (LPTSTR) LocalLock(hText);

            if (rgwch != NULL)
            {
                if (FDetectEncodingW(szFile, rgwch, cch, &cpDetected))
                {
                    // We detected an expected encoding for this file

                    g_cpSave = cpDetected;
                }

                LocalUnlock(hText);
            }
        }

        id = (int) DialogBoxParam(hInstanceNP,
                                  MAKEINTRESOURCE(IDD_SELECT_ENCODING),
                                  hwndNP,
                                  SelectEncodingDlgProc,
                                  (LPARAM) &g_cpSave);

        if (id == IDCANCEL)
        {
            return(FALSE);
        }
    }


    /* If saving to an existing file, make sure correct disk is in drive */
    if (!fSaveAs)
    {
       fp = CreateFile(szFile,                     // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ,            // share mode
                       NULL,                       // security descriptor
                       OPEN_EXISTING,              // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs
    }
    else
    {

       // Carefully open the file.  Do not truncate it if it exists.
       // set the fNew flag if it had to be created.
       // We do all this in case of failures later in the process.

       fp = CreateFile(szFile,                     // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                       NULL,                       // security descriptor
                       OPEN_ALWAYS,                // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs

       if( fp != INVALID_HANDLE_VALUE )
       {
          fNew= (GetLastError() != ERROR_ALREADY_EXISTS );
       }
    }

    if( fp == INVALID_HANDLE_VALUE )
    {
        if (fSaveAs)
          AlertBox( hwndParent, szNN, szCREATEERR, szFile,
                    MB_APPLMODAL | MB_OK | MB_ICONWARNING);
        return FALSE;
    }


    // if wordwrap, remove soft carriage returns 
    // Also move the cursor to a safe place to get around MLE bugs
    
    ClearFmt();

    /* Must get text length after formatting */

    nChars = (UINT) SendMessage(hwndEdit, WM_GETTEXTLENGTH, 0, 0);
    hEText = (HANDLE) SendMessage(hwndEdit, EM_GETHANDLE, 0, 0);

    if ((hEText == NULL) || ((lpch = (LPTSTR) LocalLock(hEText)) == NULL))
    {
       goto FailFile;
    }
       
Retry:
    // Determine the SaveAs file type, and write the appropriate BOM.
    // If the filetype is UTF-8 or Ansi, do the conversion.

    if (FDetectEncodingW(szFile, lpch, nChars, &cpDetected))
    {
        // We detected an expected encoding for this file

        if (g_cpSave != cpDetected)
        {
            int id;

            // Display a warning that encodings do not match

            id = MessageBox(hwndNP,
                            szEncodingMismatch,
                            szNN,
                            MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONWARNING);

            if (id == IDCANCEL)
            {
                goto CleanUp;
            }

            if (id == IDYES)
            {
                g_cpSave = cpDetected;
            }
        }
    }

    switch (g_cpSave)
    {
        case CP_UTF16 :
            if (g_wbSave != wbNo)
            {
                WriteFile(fp, &wchBOM, ByteCountOf(1), &nBytesWritten, NULL);
            }

            flag = WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
            break;

        case CP_UTF16BE :
            if (g_wbSave != wbNo)
            {
                WriteFile(fp, &wchRBOM, ByteCountOf(1), &nBytesWritten, NULL);
            }

            ReverseEndian(lpch, lpch, nChars);
            flag = WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
            ReverseEndian(lpch, lpch, nChars);
            break;

        case CP_UTF8 :
            // For UTF-8, write the BOM and continue to the default case.
            // For XML, do NOT write a BOM for wbDefault

            if ((g_wbSave == wbYes) || ((g_wbSave == wbDefault) && !FIsXmlW(lpch, nChars)))
            {
                WriteFile(fp, &BOM_UTF8, 3, &nBytesWritten, NULL);
            }

            // Fall through to convert and write the file

        default:
            fSaveEntity = g_fSaveEntity && FSupportWriteEntities(g_cpSave);

            pfDefCharUsed = NULL;

            if (!fSaveEntity && (g_cpSave != CP_UTF8))
            {
                pfDefCharUsed = &fDefCharUsed;
            }

            cchMbcs = ConvertFromUnicode(g_cpSave,
                                         TRUE,
                                         fSaveEntity,
                                         (LPWSTR) lpch,
                                         nChars,
                                         NULL,
                                         0,
                                         pfDefCharUsed);

            if (fDefCharUsed)
            {
                int id = (int) DialogBox(hInstanceNP,
                                         MAKEINTRESOURCE(IDD_SAVE_UNICODE_DIALOG),
                                         hwndNP,
                                         SaveUnicodeDlgProc);

                switch (id)
                {
                    case IDC_SAVE_AS_UNICODE :
                        g_cpSave = CP_UTF16;
                        goto Retry;

                    case IDOK :
                        // Continue.

                        break;

                    case IDCANCEL :
                        goto CleanUp;
                }
            }

            if (pfDefCharUsed != NULL)
            {
                // We need to convert again because WideCharToMultiByte
                // sometimes fails with pfDefUsedChar != NULL.

                cchMbcs = ConvertFromUnicode(g_cpSave,
                                             fSaveEntity,
                                             fSaveEntity,
                                             (LPWSTR) lpch,
                                             nChars,
                                             NULL,
                                             0,
                                             NULL);

            }

            flag = AnsiWriteFile(fp, g_cpSave, lpch, nChars, cchMbcs);
            break;
    }

    if (!flag)
    {
       SetCursor(hStdCursor);     /* display normal cursor */

FailFile:
       AlertUser_FileFail(szFile);
CleanUp:
       SetCursor(hStdCursor);

       CloseHandle(fp); fp=INVALID_HANDLE_VALUE;

       if( hEText )
           LocalUnlock( hEText );

       if (fNew)
          DeleteFile(szFile);

       //
       // if wordwrap, insert soft carriage returns 
       //

       RestoreFmt();

       return FALSE;
    }

    SetEndOfFile(fp);

    g_cpOpened = g_cpSave;
    g_wbOpened = g_wbSave;

    SendMessage(hwndEdit, EM_SETMODIFY, FALSE, 0L);

    SetFileName(szFile);

    CloseHandle(fp); fp=INVALID_HANDLE_VALUE;

    if( hEText )
        LocalUnlock( hEText );

    //
    // if wordwrap, insert soft carriage returns 
    //

    RestoreFmt();

    // Display the normal cursor
    SetCursor(hStdCursor);

    return TRUE;
} // end of SaveFile()


/* Read contents of file from disk.
 * Do any conversions required.
 * File is already open, referenced by handle fp
 * Close the file when done.
 * If cpOpen != CP_AUTO, then use it as codepage, otherwise do automagic guessing.
 */

BOOL LoadFile(LPCTSTR szFile, BOOL fSelectEncoding)
{
    UINT      len, i, nChars;
    LPTSTR    lpch=NULL;
    LPTSTR    lpBuf;
    LPSTR     lpBufAfterBOM;
    UINT      cpOpen;
    BOOL      fLog=FALSE;
    TCHAR*    p;
    BY_HANDLE_FILE_INFORMATION fiFileInfo;
    BOOL      bStatus;          // boolean status
    HLOCAL    hNewEdit=NULL;    // new handle for edit buffer
    HANDLE    hMap;             // file mapping handle
    TCHAR     szNullFile[2];    // fake null mapped file

    if( fp == INVALID_HANDLE_VALUE )
    {
       AlertUser_FileFail( szFile );
       return (FALSE);
    }

    //
    // Get size of file
    // We use this heavy duty GetFileInformationByHandle API
    // because it finds bugs.  It takes longer, but it only is
    // called at user interaction time.
    //

    bStatus= GetFileInformationByHandle( fp, &fiFileInfo );
    len= (UINT) fiFileInfo.nFileSizeLow;

    // NT may delay giving this status until the file is accessed.
    // i.e. the open succeeds, but operations may fail on damaged files.

    if( !bStatus )
    {
        AlertUser_FileFail( szFile );
        CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;
        return( FALSE );
    }

    // If the file is too big, fail now.
    // -1 not valid because we need a zero on the end.
    //
    // bug# 168148: silently fails to open 2.4 gig text file on win64
    // Caused by trying to convert ascii file to unicode which overflowed
    // the dword length handled by multibytetowidechar conversion.
    // Since no one will be happy with the performance of the MLE with
    // a file this big, we will just refuse to open it now.
    //
    // For example, on a Pentium 173 MHz with 192 Megs o'RAM (Tecra 8000) 
    // I got these results:
    //
    // size   CPU-time
    //    0    .12
    //    1    .46
    //    2    .77
    //    3   1.041
    //    4   1.662
    //    5   2.092
    //    6   2.543
    //    7   3.023
    //    8   3.534
    //    9   4.084
    //   10   4.576
    //   16   8.371
    //   32  23.142
    //   64  74.426
    //
    //  Curve fitting these numbers to cpu-time=a+b*size+c*size*size
    //     we get a really good fit with cpu= .24+.28*size+.013*size*size
    //
    // For 1 gig, this works out to be 3.68 hours.  2 gigs=14.6 hours
    //
    // And the user isn't going to be happy with adding or deleting characters
    // with the MLE control.  It wants to keep the memory stuctures uptodate
    // at all times.
    //
    // Going to richedit isn't a near term solution either:
    //
    // size    CPU-time
    // 2       3.8
    // 4       9.0
    // 6      21.9
    // 8      30.4
    // 10     65.3
    // 16   1721 or >3.5 hours (it was still running when I killed it)
    //
    //
    // feature: should we only bail if not unicode?
    //

    if( len >=0x4000000 || fiFileInfo.nFileSizeHigh != 0 )
    {
       AlertBox( hwndNP, szNN, szErrSpace, szFile,
                 MB_APPLMODAL | MB_OK | MB_ICONWARNING );
       CloseHandle (fp); fp=INVALID_HANDLE_VALUE;
       return (FALSE);
    }

    SetCursor(hWaitCursor);                // physical I/O takes time

    //
    // Create a file mapping so we don't page the file to
    // the pagefile.  This is a big win on small ram machines.
    //

    if( len != 0 )
    {
        lpBuf= NULL;

        hMap= CreateFileMapping( fp, NULL, PAGE_READONLY, 0, len, NULL );

        if( hMap )
        {
            lpBuf= MapViewOfFile( hMap, FILE_MAP_READ, 0,0,len);
            CloseHandle( hMap );
        }
    }
    else  // file mapping doesn't work on zero length files
    {
        lpBuf= (LPTSTR) &szNullFile;
        *lpBuf= 0;  // null terminate
    }

    CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;

    if( lpBuf == NULL )
    {
        SetCursor( hStdCursor );
        //
        // bug# 192007: Opening migrated files with bad RSS gives bad error msg
        //
        // We used to just say 'out of memory', but that was wrong.
        // We will now give the standard OS error message.
        // If the user doesn't understand that, then FormatMessage s/b be fixed.
        //
        AlertUser_FileFail( szFile );
        return( FALSE );
    }


    //
    // protect access to the mapped file with a try/except so we
    // can detect I/O errors.
    //

    //
    // WARNING: be very very careful.  This code is pretty fragile.
    // Files across the network, or RSM files (tape) may throw excepts
    // at random points in this code.  Anywhere the code touches the
    // memory mapped file can cause an AV.  Make sure variables are
    // in consistent state if an exception is thrown.  Be very careful
    // with globals.

    __try
    {
    /* Determine the file type and number of characters
     * If the user overrides, use what is specified.
     * Otherwise, we depend on 'IsTextUnicode' getting it right.
     * If it doesn't, bug IsTextUnicode.
     */

    cpOpen = g_cpDefault;

    if (fSelectEncoding || (cpOpen == CP_AUTO))
    {
        switch (*lpBuf)
        {
            TCHAR szExt[_MAX_EXT];

            case BYTE_ORDER_MARK:
                cpOpen = CP_UTF16;
                break;

            case REVERSE_BYTE_ORDER_MARK:
                cpOpen = CP_UTF16BE;
                break;

            case BOM_UTF8_HALF:
                // UTF-8 BOM has 3 bytes; if it doesn't have UTF-8 BOM just fall through ..

                if ((len > 2) && (((BYTE *) lpBuf)[2] == BOM_UTF8_2HALF))
                {
                    cpOpen = CP_UTF8;
                    break;
                }

                // Fall through

            default:
                // Is the file Unicode without BOM ?

                if (IsInputTextUnicode((LPSTR) lpBuf, len))
                {
                    cpOpen = CP_UTF16;
                    break;
                }

                if (FDetectXmlEncodingA((LPSTR) lpBuf, len, &cpOpen))
                {
                    // We recognized this as an XML file with a valid encoding

                    break;
                }

                if (FDetectHtmlEncodingA((LPSTR) lpBuf, len, &cpOpen))
                {
                    // We recognized this as an HTML file with a valid encoding

                    break;
                }

                _wsplitpath(szFile, NULL, NULL, NULL, szExt);

                if (lstrcmpi(szExt, TEXT(".css")) == 0)
                {
                    if (FDetectCssEncodingA((LPSTR) lpBuf, len, &cpOpen))
                    {
                        // We recognized this as an HTML file with a valid encoding

                        break;
                    }
                }

                // Is the file UTF-8 even though it doesn't have UTF-8 BOM.

                if (IsTextUTF8((LPSTR) lpBuf, len))
                {
                    cpOpen = CP_UTF8;
                    break;
                }

                // Well, assume default or ANSI if no default

                if (fSelectEncoding)
                {
                    // Use MLANG to detect the encoding as default in Select Encoding dialog

                    if (FDetectEncodingA((LPSTR) lpBuf, len, &cpOpen))
                    {
                        // We recognized this as an XML file with a valid encoding

                        break;
                    }
                }

                // Use default

                cpOpen = g_cpDefault;

                if (cpOpen == CP_AUTO)
                {
                    cpOpen = g_cpANSI;
                }
                break;
        }             
    }

    if (fSelectEncoding)
    {
        int id;

        id = (int) DialogBoxParam(hInstanceNP,
                                  MAKEINTRESOURCE(IDD_SELECT_ENCODING),
                                  hwndNP,
                                  SelectEncodingDlgProc,
                                  (LPARAM) &cpOpen);

        if (id == IDCANCEL)
        {
            if (lpBuf != (LPTSTR) &szNullFile)
            {
                UnmapViewOfFile(lpBuf);
            }

            return(FALSE);
        }
    }

    lpBufAfterBOM = (LPSTR) lpBuf;

    if (cpOpen == CP_UTF16)
    {
        if ((len >= sizeof(WCHAR)) && ((*(WCHAR *) lpBuf) == BYTE_ORDER_MARK))
        {
            // Skip the BOM

            lpBufAfterBOM = (LPSTR) lpBuf + sizeof(WCHAR);
            len -= sizeof(WCHAR);
        }
    }

    else if (cpOpen == CP_UTF16BE)
    {
        if ((len >= sizeof(WCHAR)) && ((*(WCHAR *) lpBuf) == REVERSE_BYTE_ORDER_MARK))
        {
            // Skip the BOM

            lpBufAfterBOM = (LPSTR) lpBuf + sizeof(WCHAR);
            len -= sizeof(WCHAR);
        }
    }

    else if (cpOpen == CP_UTF8)
    {
        if ((len >= 3) && ((*(WCHAR *) lpBuf) == BOM_UTF8_HALF) && (((BYTE *) lpBuf)[2] == BOM_UTF8_2HALF))
        {
            // Skip the BOM

            lpBufAfterBOM = (LPSTR) lpBuf + 3;
            len -= 3;
        }
    }

    // Find out no. of chars present in the string.

    if ((cpOpen == CP_UTF16) || (cpOpen == CP_UTF16BE))
    {
        nChars = len / sizeof(WCHAR);
    }

    else
    {
        nChars = ConvertToUnicode(cpOpen, (LPSTR) lpBufAfterBOM, len, NULL, 0);
    }

    //
    // Don't display text until all done.
    //

    SendMessage(hwndEdit, WM_SETREDRAW, FALSE, 0);

    // Reset selection to 0

    SendMessage(hwndEdit, EM_SETSEL, 0, 0L);
    SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

    // resize the edit buffer
    // if we can't resize the memory, inform the user

    hNewEdit= LocalReAlloc(hEdit, ByteCountOf(nChars + 1), LMEM_MOVEABLE);

    if( !hNewEdit )
    {
       TCHAR szFileT[MAX_PATH]; /* Private copy of current filename */

      /* Bug 7441: New() modifies szFileOpened to which szFile may point.
       *           Save a copy of the filename to pass to AlertBox.
       *  17 November 1991    Clark R. Cyr
       */
       lstrcpy(szFileT, szFile);
       New(FALSE);

       /* Display the hour glass cursor */
       SetCursor(hStdCursor);

       AlertBox( hwndNP, szNN, szFTL, szFileT,
                 MB_APPLMODAL | MB_OK | MB_ICONWARNING);
       if( lpBuf != (LPTSTR) &szNullFile )
       {
           UnmapViewOfFile( lpBuf );
       }

       // let user see old text

       SendMessage(hwndEdit, WM_SETREDRAW, FALSE, 0);
       return FALSE;
    }

    /* Transfer file from temporary buffer to the edit buffer */
    lpch= (LPTSTR) LocalLock(hNewEdit);

    if (cpOpen == CP_UTF16)
    {
        CopyMemory(lpch, lpBufAfterBOM, ByteCountOf(nChars));
    }

    else if (cpOpen == CP_UTF16BE)
    {
        ReverseEndian(lpch, (LPTSTR) lpBufAfterBOM, nChars);
    }

    else
    {      
        ConvertToUnicode(cpOpen, (LPSTR) lpBufAfterBOM, len, lpch, nChars);
    }

    // Got everything; update global safe now

    g_cpOpened = cpOpen;

    if ((cpOpen != CP_UTF16) && (cpOpen != CP_UTF16BE) && (cpOpen != CP_UTF8))
    {
        g_wbOpened = wbDefault;
    }

    else if (lpBufAfterBOM != (LPSTR) lpBuf)
    {
        g_wbOpened = wbYes;
    }

    else
    {
        g_wbOpened = wbNo;
    }

    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AlertBox( hwndNP, szNN, szDiskError, szFile,
            MB_APPLMODAL | MB_OK | MB_ICONWARNING );
        nChars= 0;   // don't deal with it.
    }

    /* Free file mapping */
    if( lpBuf != (LPTSTR) &szNullFile )
    {
        UnmapViewOfFile( lpBuf );
    }

    if( lpch ) 
    {

       // Fix any NUL character that came in from the file to be spaces.

       for (i = 0, p = lpch; i < nChars; i++, p++)
       {
          if( *p == (TCHAR) 0 )
             *p= TEXT(' ');
       }
      
       // null terminate it.  Safe even if nChars==0 because it is 1 TCHAR bigger

       *(lpch+nChars)= (TCHAR) 0;      /* zero terminate the thing */
   
       // Set 'fLog' if first characters in file are ".LOG"
   
       fLog= *lpch++ == TEXT('.') && *lpch++ == TEXT('L') &&
             *lpch++ == TEXT('O') && *lpch == TEXT('G');
    }
   
    if( hNewEdit )
    {
       LocalUnlock( hNewEdit );

       // now it is safe to set the global edit handle

       hEdit= hNewEdit;
    }

    SetFileName(szFile);

  /* Pass handle to edit control.  This is more efficient than WM_SETTEXT
   * which would require twice the buffer space.
   */

  /* Bug 7443: If EM_SETHANDLE doesn't have enough memory to complete things,
   * it will send the EN_ERRSPACE message.  If this happens, don't put up the
   * out of memory notification, put up the file to large message instead.
   *  17 November 1991     Clark R. Cyr
   */
    dwEmSetHandle = SETHANDLEINPROGRESS;
    SendMessage(hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, 0);
    if (dwEmSetHandle == SETHANDLEFAILED)
    {
       SetCursor(hStdCursor);

       dwEmSetHandle = 0;
       AlertBox(hwndNP, szNN, szFTL, szFile, MB_APPLMODAL|MB_OK|MB_ICONWARNING);
       New(FALSE);
       SendMessage (hwndEdit, WM_SETREDRAW, TRUE, 0);
       return(FALSE);
    }
    dwEmSetHandle = 0;

    PostMessage (hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L);

    /* If file starts with ".LOG" go to end and stamp date time */
    if (fLog)
    {
       SendMessage( hwndEdit, EM_SETSEL, (WPARAM)nChars, (LPARAM)nChars);
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);
       InsertDateTime(TRUE);
    }

    /* Move vertical thumb to correct position */
    SetScrollPos(hwndNP,
                 SB_VERT,
                 (int) SendMessage (hwndEdit, WM_VSCROLL, EM_GETTHUMB, 0),
                 TRUE);

    /* Now display text */
    SendMessage(hwndEdit, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(hwndEdit, NULL, TRUE);
    UpdateWindow(hwndEdit);

    SetCursor(hStdCursor);

    return( TRUE );
}

/* New Command - reset everything
 */

void New(BOOL fCheck)
{
    HANDLE hTemp;
    TCHAR* pSz;

    if (!fCheck || CheckSave (FALSE))
    {
        SendMessage(hwndEdit, WM_SETTEXT, 0, (LPARAM) TEXT(""));

        SetFileName(NULL);

        SendMessage(hwndEdit, EM_SETSEL, 0, 0);
        SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

        // resize of 1 NULL character i.e. zero length

        hTemp= LocalReAlloc( hEdit, sizeof(TCHAR), LMEM_MOVEABLE );
        if( hTemp )
        {
           hEdit= hTemp;
        }

        // null terminate the buffer.  LocalReAlloc won't do it
        // because in all cases it is not growing which is the
        // only time it would zero out anything.

        pSz= LocalLock( hEdit );
        *pSz= TEXT('\0');
        LocalUnlock( hEdit );

        SendMessage (hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, 0L);
        szSearch[0] = (TCHAR) 0;

        // Set encoding of new document

        g_cpOpened = g_cpDefault;

        if (g_cpOpened == CP_AUTO)
        {
            g_cpOpened = g_cpANSI;
        }

        g_wbOpened = wbDefault;
    }

} // end of New()

/* If sz does not have extension, append ".txt"
 * This function is useful for getting to undecorated filenames
 * that setup apps use.  DO NOT CHANGE the extension.  Too many setup
 * apps depend on this functionality.
 */

void AddExt( TCHAR* sz )
{
    TCHAR*   pch1;
    int      ch;
    DWORD    dwSize;

    dwSize= lstrlen(sz);

    pch1= sz + dwSize;   // point to end

    ch= *pch1;
    while( ch != TEXT('.') && ch != TEXT('\\') && ch != TEXT(':') && pch1 > sz)
    {
        //
        // backup one character.  Do NOT use CharPrev because
        // it sometimes doesn't actually backup.  Some Thai
        // tone marks fit this category but there seems to be others.
        // This is safe since it will stop at the beginning of the
        // string or on delimiters listed above.  bug# 139374 2/13/98
        //
        // pch1= (TCHAR*)CharPrev (sz, pch1);
        pch1--;  // back up
        ch= *pch1;
    }

    if( *pch1 != TEXT('.') )
    {
       if( dwSize + sizeof(".txt") <= MAX_PATH ) {  // avoid buffer overruns
           lstrcat( sz, TEXT(".txt") );
       }
    }

}


/* AlertUser_FileFail(LPTSTR szFile)
 *
 * szFile is the name of file that was attempted to open.
 * Some sort of failure on file open.  Alert the user
 * with some monologue box.  At least give him decent
 * error messages.
 */

VOID AlertUser_FileFail(LPCTSTR szFile)
{
    TCHAR msg[256];     // buffer to format message into
    DWORD dwStatus;     // status from FormatMessage
    UINT  style= MB_APPLMODAL | MB_OK | MB_ICONWARNING;

    // Check GetLastError to see why we failed
    dwStatus=
    FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   GetLastError(),
                   GetUserDefaultLangID(),
                   msg,  // where message will end up
                   CharSizeOf(msg), NULL );
    if( dwStatus )
    {
        MessageBox(hwndNP, msg, szNN, style);
    }
    else
    {
        AlertBox(hwndNP, szNN, szDiskError, szFile, style);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\nphtml.c ===
/*
 * HTML support functions
 *  Copyright (C) 2000 Microsoft Corporation
 */

#include "precomp.h"


BOOL FDetectHtmlEncodingA(LPCSTR rgch, UINT cch, UINT* pcp)
{
    return(FALSE);
    UNREFERENCED_PARAMETER( rgch );
    UNREFERENCED_PARAMETER( cch );
    UNREFERENCED_PARAMETER( pcp );
}


BOOL FDetectHtmlEncodingW(LPCWSTR rgch, UINT cch, UINT* pcp)
{
    return(FALSE);
    UNREFERENCED_PARAMETER( rgch );
    UNREFERENCED_PARAMETER( cch );
    UNREFERENCED_PARAMETER( pcp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\npinit.c ===
/*
 *   Notepad application
 *
 *      Copyright (C) 1984-2000 Microsoft Corporation
 *
 *      NPInit - One time init for notepad.
 */

#include "precomp.h"


TCHAR chPageText[2][PT_LEN];    /* Strings to hold PageSetup items.        */
TCHAR chPageTextTemp[2][PT_LEN];
TCHAR szPrinterName[256];       /* String to hold printername for PrintTo verb */

static UINT cpDefault;
static INT fSaveWindowPositions=0;    /* true if we are to save window position  */

static INT g_WPtop,g_WPleft,g_WPDX,g_WPDY;   /* initial window positions          */

/* routines to handle saving and restoring information in the registry.
 *
 * SaveGlobals - saves interesting globals to the registry
 *
 * GetGlobals  - gets interesting globals from the registry
 *
 * Interesting Globals:
 *
 * FontStruct information include calculated pointsize
 * Codepage
 *
 * If we want to save PageSetup info, save the margins in some
 * units (cm for example) and convert on input and output.
 */

/* name of section to save into -- never internationalize */
#define OURKEYNAME TEXT("Software\\Microsoft\\Notepad")

// RegWriteInt - write an integer to the registry

VOID RegWriteInt( HKEY hKey, PTCHAR pszKey, INT iValue )
{
    RegSetValueEx( hKey, pszKey, 0, REG_DWORD, (BYTE*)&iValue, sizeof(INT) );
}

// RegWriteString - write a string to the registry

VOID RegWriteString( HKEY hKey, PTCHAR pszKey, PTCHAR pszValue )
{
    INT len;     // length of string with null in bytes

    len= (lstrlen( pszValue )+1) * sizeof(TCHAR);
    RegSetValueEx( hKey, pszKey, 0, REG_SZ, (BYTE*)pszValue, len );
}

// RegGetInt - Get integer from registry

DWORD RegGetInt( HKEY hKey, PTCHAR pszKey, DWORD dwDefault )
{
    DWORD dwResult= !ERROR_SUCCESS;
    LONG  lStatus= ERROR_SUCCESS;
    DWORD dwSize= sizeof(DWORD);
    DWORD dwType= 0;

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) &dwResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_DWORD )
    {
        dwResult= dwDefault;
    }
    return( dwResult );
}

// RegGetString - get string from registry

VOID RegGetString( HKEY hKey, PTCHAR pszKey, PTCHAR pszDefault, PTCHAR pszResult, INT iCharLen )
{
    LONG  lStatus= !ERROR_SUCCESS;
    DWORD dwSize;      // size of buffer
    DWORD dwType= REG_NONE;

    dwSize= iCharLen * sizeof(TCHAR);

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) pszResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_SZ )
    {
        CopyMemory( pszResult, pszDefault, iCharLen*sizeof(TCHAR) );
    }
}


// lfHeight is calculated using PointSize
// lfWidth set by font mapper


VOID SaveGlobals(VOID)
{
    HKEY hKey;    // key to our registry root
    LONG lStatus; // status from RegCreateKey
    WINDOWPLACEMENT wp;

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        return;   // just return quietly
    }

    RegWriteInt( hKey, TEXT("lfEscapement"),     FontStruct.lfEscapement);
    RegWriteInt( hKey, TEXT("lfOrientation"),    FontStruct.lfOrientation);
    RegWriteInt( hKey, TEXT("lfWeight"),         FontStruct.lfWeight);
    RegWriteInt( hKey, TEXT("lfItalic"),         FontStruct.lfItalic);
    RegWriteInt( hKey, TEXT("lfUnderline"),      FontStruct.lfUnderline);
    RegWriteInt( hKey, TEXT("lfStrikeOut"),      FontStruct.lfStrikeOut);
    RegWriteInt( hKey, TEXT("lfCharSet"),        FontStruct.lfCharSet);
    RegWriteInt( hKey, TEXT("lfOutPrecision"),   FontStruct.lfOutPrecision);
    RegWriteInt( hKey, TEXT("lfClipPrecision"),  FontStruct.lfClipPrecision);
    RegWriteInt( hKey, TEXT("lfQuality"),        FontStruct.lfQuality);
    RegWriteInt( hKey, TEXT("lfPitchAndFamily"), FontStruct.lfPitchAndFamily);
    RegWriteInt( hKey, TEXT("iPointSize"),       iPointSize);
    RegWriteInt( hKey, TEXT("fWrap"),            fWrap);
    RegWriteInt( hKey, TEXT("StatusBar"),        fStatus);
    RegWriteInt( hKey, TEXT("fSaveWindowPositions"),fSaveWindowPositions );

    RegWriteString( hKey, TEXT("lfFaceName"), FontStruct.lfFaceName);

    RegWriteString( hKey, TEXT("szHeader"),  chPageText[HEADER] );
    RegWriteString( hKey, TEXT("szTrailer"), chPageText[FOOTER] );
    RegWriteInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
    RegWriteInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
    RegWriteInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
    RegWriteInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );

    wp.length= sizeof(wp);

    if( GetWindowPlacement( hwndNP, &wp ) )
    {
        RegWriteInt( hKey, TEXT("iWindowPosX"), wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosY"), wp.rcNormalPosition.top);
        RegWriteInt( hKey, TEXT("iWindowPosDX"), wp.rcNormalPosition.right - wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosDY"), wp.rcNormalPosition.bottom - wp.rcNormalPosition.top);
    }

    RegCloseKey( hKey );
}


// GetGlobals
//
// Pick up font information etc that may be saved in the registry.
//
// We are called pretty early in setup and don't have things like hwndNP valid yet.
//

VOID GetGlobals( VOID )
{
    LOGFONT lfDef;          // default logical font
    HFONT   hFixedFont;     // standard font to use
    LONG    lStatus;        // status from RegCreateKey
    HKEY    hKey;           // key into registry

    //
    // quickly get a reasonable set of default parameters
    // for the default font if we need it.
    //
    
    hFixedFont= GetStockObject( SYSTEM_FIXED_FONT );

    if ( hFixedFont )
    {
        GetObject( hFixedFont, sizeof(LOGFONT), &lfDef );
    }
    else
    {
        ZeroMemory( &lfDef, sizeof(lfDef) );
    }

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        hKey= NULL;   // later calls to RegGet... will return defaults
    }
    FontStruct.lfWidth= 0;



    FontStruct.lfEscapement=     (LONG)RegGetInt( hKey, TEXT("lfEscapement"),     lfDef.lfEscapement);
    FontStruct.lfOrientation=    (LONG)RegGetInt( hKey, TEXT("lfOrientation"),    lfDef.lfOrientation);
    FontStruct.lfWeight=         (LONG)RegGetInt( hKey, TEXT("lfWeight"),         lfDef.lfWeight);
    FontStruct.lfItalic=         (BYTE)RegGetInt( hKey, TEXT("lfItalic"),         lfDef.lfItalic);
    FontStruct.lfUnderline=      (BYTE)RegGetInt( hKey, TEXT("lfUnderline"),      lfDef.lfUnderline);
    FontStruct.lfStrikeOut=      (BYTE)RegGetInt( hKey, TEXT("lfStrikeOut"),      lfDef.lfStrikeOut);

    //
    // We have to preserve lfCharSet because some fonts (symbol, marlett) don't handle 
    // 0 (ANSI_CHARSET) or 1 (DEFAULT_CHARSET), and the font mapper will map to a 
    // different facename.  Later we will see if the CreateFont has the same FaceName
    // and get a more appropriate lfCharSet if need be.
    //

    FontStruct.lfCharSet=        (BYTE)RegGetInt( hKey, TEXT("lfCharSet"),        lfDef.lfCharSet);
    
    FontStruct.lfOutPrecision=   (BYTE)RegGetInt( hKey, TEXT("lfOutPrecision"),   lfDef.lfOutPrecision);
    FontStruct.lfClipPrecision=  (BYTE)RegGetInt( hKey, TEXT("lfClipPrecision"),  lfDef.lfClipPrecision);
    FontStruct.lfQuality=        (BYTE)RegGetInt( hKey, TEXT("lfQuality"),        lfDef.lfQuality);
    FontStruct.lfPitchAndFamily= (BYTE)RegGetInt( hKey, TEXT("lfPitchAndFamily"), lfDef.lfPitchAndFamily);

    //
    // If there is no FaceName in the registry, use the default "Lucida Console"
    // This will show off most of the glyphs except in the FE locales.
    // For FE, we can't font link fonts with the glyphs because they would have to have
    // the exact width as lucida console, or the console/csrss will AV (July 9, 1999)
    //

    RegGetString( hKey, TEXT("lfFaceName"), TEXT("Lucida Console"), FontStruct.lfFaceName, LF_FACESIZE);

    iPointSize= RegGetInt( hKey, TEXT("iPointSize"), 100);
    fWrap=      RegGetInt( hKey, TEXT("fWrap"),      0);
    fStatus=    RegGetInt( hKey, TEXT("StatusBar"),  0);
    fSaveWindowPositions= RegGetInt( hKey, TEXT("fSaveWindowPositions"), 0 );

    // if page settings not in registry, we will use defaults

    RegGetString( hKey, TEXT("szHeader"),  chPageText[HEADER], chPageText[HEADER], PT_LEN );
    RegGetString( hKey, TEXT("szTrailer"), chPageText[FOOTER], chPageText[FOOTER], PT_LEN );

    g_PageSetupDlg.rtMargin.top=    (LONG)RegGetInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
    g_PageSetupDlg.rtMargin.bottom= (LONG)RegGetInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
    g_PageSetupDlg.rtMargin.left=   (LONG)RegGetInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
    g_PageSetupDlg.rtMargin.right=  (LONG)RegGetInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );

    // if window positions in registry use them, otherwise us defaults

    g_WPtop=  (INT) RegGetInt( hKey, TEXT("iWindowPosY"),  (DWORD) CW_USEDEFAULT );
    g_WPleft= (INT) RegGetInt( hKey, TEXT("iWindowPosX"),  (DWORD) CW_USEDEFAULT );
    g_WPDX=   (INT) RegGetInt( hKey, TEXT("iWindowPosDX"), (DWORD) CW_USEDEFAULT );
    g_WPDY=   (INT) RegGetInt( hKey, TEXT("iWindowPosDY"), (DWORD) CW_USEDEFAULT );
    
    if( hKey )
    {
        RegCloseKey( hKey );
    }

}


void GetLocaleCodepages(LCID lcid, UINT* pcpANSI, UINT* pcpOEM)
{
    // FEATURE: don't check returns?  Not likely; fix later
    GetLocaleInfoW(lcid,
                   LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                   (LPTSTR) pcpANSI,
                   sizeof(*pcpANSI));

    GetLocaleInfoW(lcid,
                   LOCALE_IDEFAULTCODEPAGE | LOCALE_RETURN_NUMBER,
                   (LPTSTR) pcpOEM,
                   sizeof(*pcpOEM));

    // LOCALE_IDEFAULTMACCODEPAGE ?
    // LOCALE_IDEFAULTEBCDICCODEPAGE ?
}


void GetKeyboardCodepages(LANGID langid)
{
    GetLocaleCodepages(langid, &g_cpKeyboardANSI, &g_cpKeyboardOEM);
}


void GetSystemCodepages(void)
{
    g_cpANSI = GetACP();
    g_cpOEM = GetOEMCP();
}


void GetUserLocaleCodepages(void)
{
    GetLocaleCodepages(GetUserDefaultUILanguage(), &g_cpUserLocaleANSI, &g_cpUserLocaleOEM);

    GetLocaleCodepages(GetUserDefaultLCID(), &g_cpUserLocaleANSI, &g_cpUserLocaleOEM);
}


/*
 * lstrncmpi( str1, str2, len )
 * compares two strings, str1 and str2, up
 * to length 'len' ignoring case.  If they
 * are equal, we will return 0.  Otherwise not 0.
 */

static
INT lstrncmpi( PTCHAR sz1, PTCHAR sz2 )
{
    TCHAR ch1, ch2;
    while( *sz1 )
    {
        ch1= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz1++ );
        ch2= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz2++ );
        if( ch1 != ch2 )
            return 1;
    }
    return 0;                // they are equal
}

static int NPRegister (HANDLE hInstance);

/* GetFileName
 *
 * Parse off filename from command line and put
 * into lpFileName
 */

LPTSTR GetFileName( LPTSTR lpFileName, LPTSTR lpCmdLine )
{
   LPTSTR lpTemp = lpFileName;
   HANDLE hFindFile;
   WIN32_FIND_DATA info;

   /*
   ** Allow for filenames surrounded by double and single quotes
   ** like in longfilenames.
   */
   if( *lpCmdLine == TEXT('\"') || *lpCmdLine == TEXT('\'') )
   {
      TCHAR chMatch = *lpCmdLine;
      DWORD dwSize=0;

      // Copy over filename
      while( *(++lpCmdLine) && (*lpCmdLine != chMatch) && (dwSize<MAX_PATH) )
      {
         *lpTemp++ = *lpCmdLine;
         dwSize++;
      }

      // NULL terminate the filename (no embedded quotes allowed in filenames)
      *lpTemp = TEXT('\0');
   }
   else
   {
      lstrcpyn(lpFileName, lpCmdLine,MAX_PATH);
   }

   /*
   ** Check to see if the unaltered filename exists.  If it does then don't
   ** append a default extension.
   */
   hFindFile= FindFirstFile( lpFileName, &info );

   if( hFindFile != INVALID_HANDLE_VALUE )
   {
      FindClose( hFindFile );
   }
   else
   {
      /*
      ** Add default extension and try again
      */
      AddExt( lpFileName );

      hFindFile= FindFirstFile( lpFileName, &info );

      if( hFindFile != INVALID_HANDLE_VALUE )
      {
         FindClose( hFindFile );
      }
   }

   // return the pointer to the end of the filename.
   return lpCmdLine;
}

/* SizeStrings - Get the total size of the resource strings   */
/* returns size in 'chars' or zero if failure                 */
/* we do this in case the international people really change  */
/* the size of resources.                                     */

/* Read all the strings into a buffer to size them.  Since we  */
/* don't know the maximum size of string resource, we may have */
/* to change the size of the read buffer.  This is done with   */
/* a simple doubling algorithm.                                */

INT SizeStrings(HANDLE hInstance)
{
    INT    iElementSize=350;  // current max size of string
    INT    total;             // total size of resources
    PTCHAR Buf;               // buffer to try putting resources into
    INT    ids;               // identifier number for resource
    INT    len;               // length of one resource

    while( TRUE )             // keep looping til all strings can be read
    {
        Buf= LocalAlloc( LPTR, ByteCountOf(iElementSize) );
        if( !Buf )
        {
            return 0;    // failure
        }
        for( ids=0, total=0; rgsz[ids] != NULL; ids++ )
        {
            len= LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), Buf, iElementSize );

            if( len >= iElementSize-1 )
            {
                #if DBG
                    ODS(TEXT("notepad: resource string too long!\n"));
                #endif
                break;
            }
            total += len+1;  // account for null terminator
        }
        LocalFree( Buf );

        if( rgsz[ids] == NULL ) break;

        iElementSize= iElementSize*2;
    }
    return( total );
}


/* InitStrings - Get all text strings from resource file */
BOOL InitStrings (HANDLE hInstance)
{
    TCHAR*   pch;
    INT      cchRemaining;
    INT      ids, cch;

    // allocate memory and lock it down forever.  we have pointers into it.
    // the localrealloc() function will not work well for freeing
    // unused memory because it may (and did) move memory.

    cchRemaining= SizeStrings( hInstance );
    if( !cchRemaining )
        return( FALSE );       // fail because we are out of memory

    pch= LocalAlloc( LPTR, ByteCountOf(cchRemaining) );
    if( !pch )
        return( FALSE );

    cchRemaining= (INT)LocalSize( pch ) / sizeof(TCHAR);
    if( cchRemaining == 0 )    // can't alloc memory - failure
        return( FALSE );

    for( ids = 0; rgsz[ids] != NULL; ids++ )
    {
       cch= 1 + LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), pch, cchRemaining );
       *rgsz[ids]= pch;
       pch += cch;

       if( cch > cchRemaining )   // should never happen
       {
           MessageBox( NULL, TEXT("Out of RC string space!!"),
                      TEXT("DEV Error!"), MB_OK);
           return( FALSE );
       }

       cchRemaining -= cch;
    }

    /* Get header and footer strings */

    lstrcpyn( chPageText[HEADER], szHeader, PT_LEN ); 
    lstrcpyn( chPageText[FOOTER], szFooter, PT_LEN ); 

    chMerge= *szMerge;
    return (TRUE);
}

/*
 * SkipBlanks( pszText )
 * skips blanks or tabs to either next character or EOL
 * returns pointer to same.
 */
PTCHAR SkipBlanks( PTCHAR pszText )
{
    while( *pszText == TEXT(' ') || *pszText == TEXT('\t') )
        pszText++;

    return pszText;
}


// if /.SETUP option exists in the command line process it.
BOOL ProcessSetupOption (LPTSTR lpszCmdLine)
{
    INT iSta= 0;
    /* Search for /.SETUP in the command line */
    if( !lstrncmpi( TEXT("/.SETUP"), lpszCmdLine ) )
    {
        fRunBySetup = TRUE;
        /* Save system menu handle for INITMENUPOPUP message */
        hSysMenuSetup =GetSystemMenu(hwndNP, FALSE);
        /* Allow exit on ^C, ^D and ^Z                      */
        /* Note that LoadAccelerators must be called before */
        /* TranslateAccelerator is called, true here        */
        hAccel = LoadAccelerators(hInstanceNP, TEXT("SlipUpAcc"));
        lpszCmdLine += 7;
    }
    else
        return FALSE;

    /* Don't offer a minimize button */
    SetWindowLong( hwndNP, GWL_STYLE,
                   WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                   WS_THICKFRAME |                  WS_MAXIMIZEBOX |
                   WS_VSCROLL    | WS_HSCROLL);

    /* skip blanks again to get to filename */
    lpszCmdLine= SkipBlanks( lpszCmdLine );

    if (*lpszCmdLine)
    {
        TCHAR szFile[MAX_PATH];

        /* Get the filename. */
        GetFileName(szFile, lpszCmdLine);

        fp= CreateFile( szFile,                 // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE, // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  //file attributes
                        NULL);                  // hnd of file attrs

        if( fp == INVALID_HANDLE_VALUE )
        {
           DWORD dwErr;

           // Check GetLastError to see why we failed
           dwErr = GetLastError ();
           switch (dwErr)
           {
              case ERROR_ACCESS_DENIED:
                 iSta= AlertBox( hwndNP, szNN, szACCESSDENY, szFile,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONWARNING);
                 break;

              case ERROR_FILE_NOT_FOUND:
                 iSta= AlertBox(hwndNP, szNN, szFNF, szFile,
                      MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONWARNING);
                 if( iSta == IDYES )
                 {
                    fp= CreateFile( szFile,                // filename
                                    GENERIC_READ|GENERIC_WRITE,  // access
                                    FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                    NULL,                  // security descrp
                                    OPEN_ALWAYS,           // how to create
                                    FILE_ATTRIBUTE_NORMAL, // file attributes
                                    NULL);                 // hnd of file attrs
                 }
                 break;

              case ERROR_INVALID_NAME:
                 iSta= AlertBox( hwndNP, szNN, szNVF, szFile,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONWARNING);
                 break;

              default:
                 iSta= AlertBox(hwndNP, szNN, szDiskError, szFile,
                          MB_APPLMODAL | MB_OKCANCEL | MB_ICONWARNING);
                 break;
           }
        }

        if (fp == INVALID_HANDLE_VALUE)
           return (FALSE);

        LoadFile(szFile, FALSE);          // load setup file
    }

    if( iSta == IDCANCEL )
       return( IDCANCEL );
    else
       return( IDYES );
}

/*
 * ProcessShellOptions(lpszCmdLine)
 *
 * If the command line has any options specified by the shell
 * process them.
 * Currently /P <filename> - prints the given file
 *           /PT "filename" "printer name" "Driver dll" "port"
 */
BOOL ProcessShellOptions (LPTSTR lpszCmdLine, int cmdShow)
{
    BOOL   bDefPrinter = TRUE;
    LPTSTR lpszAfterFileName;
    INT    i = 0;
    TCHAR szFile[MAX_PATH];

    // Is it PrintTo ?
    if( lstrncmpi( TEXT("/PT"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+3 );
        bDefPrinter = FALSE;
    }
    // Or is it Print ?
    else if ( lstrncmpi( TEXT("/P"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+2 );
    }
    else
        return FALSE;

    if (!*lpszCmdLine)
       return FALSE;

/* Added as per Bug #10923 declaring that the window should show up
 * and then the printing should begin.   29 July 1991  Clark Cyr
 */
    ShowWindow(hwndNP, cmdShow);

    /* Get the filename; have the pointer to the end of the filename */
    lpszAfterFileName = GetFileName(szFile, lpszCmdLine) + 1;

    if (!bDefPrinter)
    {
        /* extract the printer name from the command line. */
        if (!*lpszAfterFileName)
            return FALSE;

        lpszAfterFileName = SkipBlanks( lpszAfterFileName );

        /* (since we are passing multiple arguments here, the filename, */
        /* the printername have to be in quotes. */
        if( *lpszAfterFileName != TEXT('\"') )
            return FALSE;

        // Copy over printername
        while( *(++lpszAfterFileName) && *lpszAfterFileName != TEXT('\"') )
        {
            szPrinterName[i++] = *lpszAfterFileName;
        }

        // NULL terminate the printername (no embedded quotes allowed in printernames)
        szPrinterName[i] = TEXT('\0');
    }


    fp= CreateFile( szFile,                 // filename
                    GENERIC_READ,           // access mode
                    FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                    NULL,                   // security descriptor
                    OPEN_EXISTING,          // how to create
                    FILE_ATTRIBUTE_NORMAL,  // file attributes
                    NULL);                  // hnd of file attrs to copy

    if( fp == INVALID_HANDLE_VALUE )
    {
       TCHAR* pszMsg;

       // select reasonable error message based on GetLastError

       switch( GetLastError() )
       {
          case ERROR_ACCESS_DENIED:
          case ERROR_NETWORK_ACCESS_DENIED:
              pszMsg= szACCESSDENY;
              break;

          case ERROR_FILE_NOT_FOUND:
              pszMsg= szFNF;
              break;

          case ERROR_INVALID_NAME:
              pszMsg= szNVF;
              break;

          default:
              pszMsg= szDiskError;
              break;
       }

       AlertBox(hwndNP, szNN, pszMsg, szFile,
                 MB_APPLMODAL | MB_OK | MB_ICONWARNING);
       return (TRUE);
    }

    // Load the file into the edit control

    LoadFile(szFile, g_fSelectEncoding);    // get print file

    // Print the file

    if (bDefPrinter)
    {
        PrintIt( DoNotUseDialog );
    }
    else
    {
        PrintIt( NoDialogNonDefault );
    }

    return (TRUE);
}

/* CreateFilter
 *
 * Creates filters for GetOpenFileName.
 *
 */

VOID CreateFilter(BOOL fOpen, PTCHAR szFilterSpec)
{
    PTCHAR pszFilterSpec;

    /* construct default filter string in the required format for
     * the new FileOpen and FileSaveAs dialogs
     * if you add to this, make sure CCHFILTERMAX is large enough.
     */

    pszFilterSpec = szFilterSpec;

    // .txt first for compatibility
    lstrcpy(pszFilterSpec, szTextFiles);
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.txt"));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, szHtmlFiles);
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.htm;*.html"));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, szXmlFiles);
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.xml"));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    if (fOpen)
    {
        lstrcpy(pszFilterSpec, szEncodedText);
        pszFilterSpec += lstrlen(pszFilterSpec) + 1;

        lstrcpy(pszFilterSpec, TEXT("*.txt"));
        pszFilterSpec += lstrlen(pszFilterSpec) + 1;
    }

    // and last, all files
    lstrcpy(pszFilterSpec, szAllFiles);
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.*"));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    *pszFilterSpec = TEXT('\0');

}

// EnumProc
//
// Callback function for EnumFonts
//
// Purpose: sets lfCharSet in passed logfont to a valid lfCharSet
//          and terminates enumeration.
//

int CALLBACK EnumProc( 
    LOGFONT*     pLf,
    TEXTMETRIC*  pTm,
    DWORD        dwType,
    LPARAM       lpData )
{

    ((LOGFONT*) lpData)-> lfCharSet= pLf->lfCharSet;

    return( 0 );  // stop enumeration

    UNREFERENCED_PARAMETER( pTm );
    UNREFERENCED_PARAMETER( dwType );
}


/* One time initialization */
INT NPInit (HANDLE hInstance, HANDLE hPrevInstance,
            LPTSTR lpCmdLine, INT cmdShow)
{
    HDC    hDisplayDC;     /* screen DC                */
    RECT   rcT1;           /* for sizing edit window   */
    RECT   rcStatus;       /* rect for the status window */
    INT    iSta;
    WINDOWPLACEMENT wp;    /* structure to place window at the correct position */
    INT    iParts[2];
    LANGID langid;

    /* determine the message number to be used for communication with
     * Find dialog
     */
    wFRMsg= RegisterWindowMessage( (LPTSTR)FINDMSGSTRING );
    if( !wFRMsg )
    {
         return FALSE;
    }

    wHlpMsg=  RegisterWindowMessage( (LPTSTR)HELPMSGSTRING );
    if( !wHlpMsg )
    {
         return FALSE;
    }

    /* open a global DC to the display */

    hDisplayDC= GetDC(NULL);
    if( !hDisplayDC )
        return FALSE;

    /* Go load strings */
    if (!InitStrings (hInstance))
        return FALSE;

    InitLocale();     // localize strings etc.

    /* Load the arrow and hourglass cursors. */
    hStdCursor= LoadCursor( NULL,
           (LPTSTR) (INT_PTR) (GetSystemMetrics(SM_PENWINDOWS) ? IDC_ARROW : IDC_IBEAM ));
    hWaitCursor= LoadCursor( NULL, IDC_WAIT );

    /* Load accelerators. */
    hAccel= LoadAccelerators(hInstance, TEXT("MainAcc"));
    if( !hWaitCursor || !hAccel )
        return FALSE;

    if( !hPrevInstance )
    {
       if( !NPRegister( hInstance ) )
          return (FALSE);
    }

    hInstanceNP= hInstance;

    /* init. fields of PRINTDLG struct.. */
    /* Inserted here since command line print statements are valid. */
    g_PageSetupDlg.lStructSize   = sizeof(PAGESETUPDLG);
    g_PageSetupDlg.hDevMode      = NULL;
    g_PageSetupDlg.hDevNames     = NULL;
    g_PageSetupDlg.hInstance     = hInstance;
    SetPageSetupDefaults();

    //
    // Pick up information saved in registry
    //

    GetGlobals();

    // Determine the codepages associated with the user's various system settings

    GetSystemCodepages();

    hwndNP= CreateWindow(  szNotepad, 
                           TEXT(""),
                           WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                           WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | 0,
                           g_WPleft,     // x
                           g_WPtop,      // y
                           g_WPDX,       // width
                           g_WPDY,       // height
                           (HWND)NULL,   // parent or owner
                           (HMENU)NULL,  // menu or child window
                           hInstance,    // application instance
                           NULL);        // window creation data

    g_PageSetupDlg.hwndOwner     = hwndNP;

    if( !hwndNP )
        return FALSE;
   
    // On multimon machines, the previous position stored of notepad may
    // not be in the display area. call SetWindowPlacement to fix this.

    // If the information specified in WINDOWPLACEMENT would result in a window 
    // that is completely off the screen, the system will automatically adjust 
    // the coordinates so that the window is visible, taking into account 
    // changes in screen resolution and multiple monitor configuration. 

    // g_WPDX and g_WPDY are CW_USEDEFAULT when notepad is started for the
    // first time on the user machine.
    if (g_WPDX != CW_USEDEFAULT && g_WPDY != CW_USEDEFAULT)
    {
        memset(&wp, 0, sizeof(wp));
        wp.length = sizeof(wp);        
        wp.rcNormalPosition.left = g_WPleft;
        wp.rcNormalPosition.right = g_WPleft + g_WPDX;
        wp.rcNormalPosition.top = g_WPtop;
        wp.rcNormalPosition.bottom = g_WPtop + g_WPDY;

        // don't check the return value; if this call fails for any reason,
        // just go on with the position of the notepad in the above CreateWindow() call.
        SetWindowPlacement(hwndNP, &wp);
    }

    /* File Drag Drop support added 03/26/91 - prototype only. w-dougw   */
    /* All processing of drag/drop files is done the under WM_DROPFILES  */
    /* message.                                                          */
    DragAcceptFiles( hwndNP,TRUE ); /* Process dragged and dropped files. */

    GetClientRect( hwndNP, (LPRECT) &rcT1 );

    hwndEdit= CreateWindowEx(
                     WS_EX_CLIENTEDGE,
                     TEXT("Edit"), 
                     TEXT(""),
                     (fWrap) ? ES_STD : (ES_STD | WS_HSCROLL),
                     0, 0, rcT1.right, rcT1.bottom - 100,
                     hwndNP, 
                     (HMENU)ID_EDIT, 
                     hInstance, 
                     (LPVOID)NULL );
    if( !hwndEdit )
    {
        return FALSE;
    }


    // create a status window.
    hwndStatus= CreateStatusWindow( (fStatus?WS_VISIBLE:0)|WS_BORDER|WS_CHILD|WS_CLIPSIBLINGS, 
                                     TEXT(""), 
                                     hwndNP, 
                                     ID_STATUS_WINDOW);
    if ( !hwndStatus )
        return FALSE;

    GetClientRect( hwndStatus, (LPRECT) &rcStatus );

    // determine height of statusbar window and save...
    dyStatus = rcStatus.bottom - rcStatus.top;

    iParts[0] = 3 * (rcStatus.right-rcStatus.left)/4;
    iParts[1] = -1;

    // Divide the status window into two parts
    SendMessage(hwndStatus, SB_SETPARTS, (WPARAM) sizeof(iParts)/sizeof(INT), (LPARAM) &iParts); 
 

    // handle word wrap now if set in registry

    SendMessage( hwndEdit, EM_FMTLINES, fWrap, 0L );  // tell MLE

    FontStruct.lfHeight= -MulDiv(iPointSize,
                                 GetDeviceCaps(hDisplayDC,LOGPIXELSY),
                                 720);
    hFont= CreateFontIndirect( &FontStruct );

    //
    // Make sure the font mapper gives us the same face name.
    //
    // If the locale changes, a font that use to work just fine gets mapped to
    // a different facename because of support for the charset does not exist
    // in the new locale.
    //
    // In this case, we will find one lfCharSet that does exist for this FaceName
    // and use that for the CreateFontIndirect.
    //

    {
        HFONT hPrev;
        TCHAR szTextFace[LF_FACESIZE];

        // Get the facename that was really used.

        hPrev= SelectObject( hDisplayDC, hFont );
        GetTextFace( hDisplayDC, sizeof(szTextFace)/sizeof(TCHAR), (LPTSTR) &szTextFace );
        SelectObject( hDisplayDC, hPrev );

        // if not the same, get a lfCharSet that does exist in this font

        if( lstrcmpi( szTextFace, FontStruct.lfFaceName ) != 0 )
        {
            EnumFonts( hDisplayDC, FontStruct.lfFaceName, (FONTENUMPROC) EnumProc, (LPARAM) &FontStruct );
            DeleteObject( hFont );   

            hFont= CreateFontIndirect( &FontStruct );
        }
    }

    SendMessage (hwndEdit, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(FALSE, 0));
    ReleaseDC( NULL, hDisplayDC );

    /* we will not verify that a unicode font is available until
    ** we actually need it.  Perhaps we'll get lucky, and only deal
    ** with ascii files.
    */

    szSearch[0] = (TCHAR) 0;
    /*
     * Win32s does not allow local memory handles to be passed to Win3.1.
     * So, hEdit is used for transferring text to and from the edit control.
     * Before reading text into it, it must be reallocated to a proper size.
     */
    hEdit = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, ByteCountOf(1));

    /* limit text for safety's sake. */
    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L );

    /* Get visible window on desktop; helps taskman  find it */

    SetFileName(NULL);
    ShowWindow(hwndNP, cmdShow);
    SetCursor(hStdCursor);

    /* Scan for initial /A or /W to override automatic file typing for
     * 'notepad /p file' or 'notepad file'
     */
    lpCmdLine= SkipBlanks( lpCmdLine );

    g_cpDefault = CP_AUTO;

    if (!lstrncmpi(TEXT("/A"), lpCmdLine))
    {
        g_cpDefault = g_cpANSI;

        lpCmdLine = SkipBlanks(lpCmdLine+2);
    }

    //
    // user provided codepage 
    // In standard C format (1234 (decimal), x123 (hex), 010 (octal)
    // if 0, then use ANSI codepage
    // if 1, then use OEM codepage

    else if (!lstrncmpi(TEXT("/CP:"), lpCmdLine))
    {
        BOOL fValid;

        // scan off the code page.  Base==0 means the syntax determines the base
        // "10" == 10,  "x10" == 16, "010" == 8
        g_cpDefault = wcstoul(lpCmdLine+4, &lpCmdLine, 0);

        if ((*lpCmdLine != TEXT('\0')) && (*lpCmdLine != TEXT(' ')) && (*lpCmdLine != TEXT('\t')))
        {
            fValid = FALSE;
        }

        else
        {
            if (g_cpDefault == CP_ACP)
            {
                g_cpDefault = GetACP();
            }

            else if (g_cpDefault == CP_OEMCP)
            {
                g_cpDefault = GetOEMCP();
            }

            fValid = FValidateCodepage(hwndNP, g_cpDefault);
        }

        if (!fValid)
        {
            AlertBox(hwndNP, szNN, szInvalidCP, NULL, MB_APPLMODAL | MB_OK | MB_ICONERROR);

            return FALSE;
        }

        lpCmdLine = SkipBlanks(lpCmdLine);
    }

    else if (!lstrncmpi(TEXT("/E:"), lpCmdLine))
    {
        const TCHAR *rgchEncoding = lpCmdLine = lpCmdLine+3;

        while ((*lpCmdLine != TEXT('\0')) && (*lpCmdLine != TEXT(' ')) && (*lpCmdLine != TEXT('\t')))
        {
            lpCmdLine++;
        }

        if (!FLookupCodepageNameW(rgchEncoding, (UINT) (lpCmdLine - rgchEncoding), &g_cpDefault))
        {
            AlertBox(hwndNP, szNN, szInvalidIANA, NULL, MB_APPLMODAL | MB_OK | MB_ICONERROR);

            return FALSE;
        }

        if (!FValidateCodepage(hwndNP, g_cpDefault))
        {
            AlertBox(hwndNP, szNN, szInvalidCP, NULL, MB_APPLMODAL | MB_OK | MB_ICONERROR);

            return FALSE;
        }

        lpCmdLine = SkipBlanks(lpCmdLine);
    }

    else if (!lstrncmpi(TEXT("/W"), lpCmdLine))
    {
        g_cpDefault = CP_UTF16;

        lpCmdLine = SkipBlanks(lpCmdLine+2);
    }

    if (!lstrncmpi(TEXT("/SELECTENCODING"), lpCmdLine))
    {
        g_fSelectEncoding = TRUE;

        lpCmdLine = SkipBlanks(lpCmdLine+15);
    }

    // Set encoding of new document or if LoadFile fails

    g_cpOpened = g_cpDefault;

    if (g_cpOpened == CP_AUTO)
    {
        g_cpOpened = g_cpANSI;
    }

    g_wbOpened = wbDefault;

    /* check for /.SETUP option first.
       if /.SETUP absent, check for SHELL options /P
       Whenever a SHELL option is processed, post a WM_CLOSE msg.
       */
    iSta= ProcessSetupOption( lpCmdLine );
    if( iSta )
    {
        if( iSta == IDCANCEL )
        {
            return( FALSE );
        }
    }
    else if( ProcessShellOptions( lpCmdLine, cmdShow ) )
    {
        PostMessage( hwndNP, WM_CLOSE, 0, 0L );
        return TRUE;
    }
    else if( *lpCmdLine )
    {
        TCHAR szFile[MAX_PATH];

        /* Get the filename. */
        GetFileName(szFile, lpCmdLine);

        fp = CreateFile(szFile,                 // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);                  // hnd of file attrs to copy

        if( fp == INVALID_HANDLE_VALUE )
        {
           // If the file can't be opened, maybe the user wants a new
           // one created.

           if( GetLastError() == ERROR_FILE_NOT_FOUND )
           {
              INT AlertStatus;

              AlertStatus= AlertBox( hwndNP, szNN, szFNF, szFile,
                     MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONWARNING);
              if( AlertStatus == IDCANCEL )
              {
                  return( FALSE );
              }

              if( AlertStatus == IDYES )
              {
                 fp = CreateFile(szFile,                // filename
                                 GENERIC_READ|GENERIC_WRITE,  // access
                                 FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                 NULL,                  // security descrp
                                 OPEN_ALWAYS,           // how to create
                                 FILE_ATTRIBUTE_NORMAL, // file attributes
                                 NULL);                 // hnd of file attrs
              }

           }
           else
           {
               AlertUser_FileFail(szFile);
           }
        }

        if (fp != INVALID_HANDLE_VALUE)
        {
           LoadFile(szFile, g_fSelectEncoding);   // get file specified on command line
        }
    }

    CreateFilter(TRUE, szOpenFilterSpec);
    CreateFilter(FALSE, szSaveFilterSpec);

    /* init. some fields of the OPENFILENAME struct used by fileopen and
     * filesaveas, but NEVER changed.
     */
    memset( &OFN, 0, sizeof(OFN) );
    OFN.lStructSize       = sizeof(OPENFILENAME);
    OFN.hwndOwner         = hwndNP;
    OFN.nMaxFile          = MAX_PATH;
    OFN.hInstance         = hInstance;

    /* init.fields of the FINDREPLACE struct used by FindText() */
    memset( &FR, 0, sizeof(FR) );
    FR.lStructSize        = sizeof(FINDREPLACE);       /* Don't hard code it */
    FR.hwndOwner          = hwndNP;


    /* Force a scroll to current selection (which could be at eof if
       we loaded a log file.) */
    {
       DWORD  dwStart, dwEnd;

       SendMessage( hwndEdit, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd );
       SendMessage( hwndEdit, EM_SETSEL, dwStart, dwEnd );
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
    }

    langid = LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0));

    GetKeyboardCodepages(langid);

    if (PRIMARYLANGID(langid) == LANG_JAPANESE) {
        /*
         * If current HKL is Japanese, handle the result string at once.
         */
        SendMessage(hwndEdit, EM_SETIMESTATUS,
                                EMSIS_COMPOSITIONSTRING, EIMES_GETCOMPSTRATONCE);
    }

    return TRUE;
}

/* ** Notepad class registration proc */
BOOL NPRegister (HANDLE hInstance)
{
    WNDCLASSEX   NPClass;
    PWNDCLASSEX  pNPClass = &NPClass;

/* Bug 12191: If Pen Windows is running, make the background cursor an
 * arrow instead of the edit control ibeam.  This way the user will know
 * where they can use the pen for writing vs. what will be considered a
 * mouse action.   18 October 1991       Clark Cyr
 */
    pNPClass->cbSize        = sizeof(NPClass);
    pNPClass->hCursor       = LoadCursor(NULL, GetSystemMetrics(SM_PENWINDOWS)
                                               ? IDC_ARROW : IDC_IBEAM);
    pNPClass->hIcon         = LoadIcon(hInstance,
                                      (LPTSTR) MAKEINTRESOURCE(ID_ICON));

    pNPClass->hIconSm       = LoadImage(hInstance,
                                        MAKEINTRESOURCE(ID_ICON),
                                        IMAGE_ICON, 16, 16,
                                        LR_DEFAULTCOLOR);
    pNPClass->lpszMenuName  = (LPTSTR) MAKEINTRESOURCE(ID_MENUBAR);
    pNPClass->hInstance     = hInstance;
    pNPClass->lpszClassName = szNotepad;
    pNPClass->lpfnWndProc   = NPWndProc;
    pNPClass->hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    pNPClass->style         = 0; // was CS_BYTEALIGNCLIENT (obsolete)
    pNPClass->cbClsExtra    = 0;
    pNPClass->cbWndExtra    = 0;

    if (!RegisterClassEx((LPWNDCLASSEX)pNPClass))
        return (FALSE);

    return (TRUE);
}


/* Get Locale info from the Registry, and initialize global vars  */

void InitLocale(void)
{
    GetUserLocaleCodepages();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\notepad.c ===
/*
 *   Notepad application
 *   Copyright (C) 1984-2000 Microsoft Corporation
 */


#include "precomp.h"
#include <htmlhelp.h>

#define DeepTrouble() MessageBox(hwndNP, szErrSpace, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONSTOP);

UINT     lGotoLine;                  /* line number to goto to */

TCHAR    chMerge;
HWND     hwndNP = 0;                 /* handle to notepad parent window   */
HWND     hwndStatus = 0;             /* handle to notepad status window   */
HWND     hwndEdit = 0;               /* handle to main text control item  */
HANDLE   hEdit;                      /* Handle to storage for edit item   */
HWND     hDlgFind = NULL;            /* handle to modeless FindText window */
HANDLE   hStdCursor;                 /* handle to arrow or beam cursor    */
HANDLE   hWaitCursor;                /* handle to hour glass cursor       */
HANDLE   hInstanceNP;                /* Module instance handle            */
HANDLE   hFont;                      /* handle to Unicode font            */
LOGFONT  FontStruct;                 /* font dialog structure             */
INT      iPointSize=120;             /* current point size unit=1/10 pts  */
TCHAR    szFileOpened[MAX_PATH+1];     /* Current notepad filename          */
TCHAR    szSearch[CCHKEYMAX];        /* Search string                     */
TCHAR    szReplace[CCHKEYMAX];       /* replace string                    */

BOOL     fStatus = FALSE;            /* status bar shown?                 */
INT      dyStatus;                   /* height of status bar              */


HMENU    hSysMenuSetup;              /* Save Away for disabled Minimize   */

DWORD    dwEmSetHandle = 0;          /* Is EM_SETHANDLE in process?       */
HANDLE   hAccel;                     /* Handle to accelerator table       */
BOOL     fRunBySetup = FALSE;        /* Did SlipUp WinExec us??           */
BOOL     fWrap = 0;                  /* Flag for word wrap                */
TCHAR    szNotepad[] = TEXT("Notepad");/* Name of notepad window class    */

BOOL fInSaveAsDlg = FALSE;

/* variables for the new File/Open, File/Saveas,Find Text and Print dialogs */
OPENFILENAME OFN;                     /* passed to the File Open/save APIs */
TCHAR szOpenFilterSpec[CCHFILTERMAX]; /* default open filter spec          */
TCHAR szSaveFilterSpec[CCHFILTERMAX]; /* default save filter spec          */

UINT g_cpANSI;                        /* system ANSI codepage (GetACP())   */
UINT g_cpOEM;                         /* system OEM codepage (GetOEMCP())  */
UINT g_cpUserLangANSI;                /* user UI language ANSI codepage    */
UINT g_cpUserLangOEM;                 /* user UI language OEM codepage     */
UINT g_cpUserLocaleANSI;              /* user default LCID ANSI codepage   */
UINT g_cpUserLocaleOEM;               /* user default LCID OEM codepage    */
UINT g_cpKeyboardANSI;                /* keyboard ANSI codepage            */
UINT g_cpKeyboardOEM;                 /* keyboard OEM codepage             */

BOOL g_fSelectEncoding;               /* Prompt for encoding by default    */
UINT g_cpDefault;                     /* codepage default                  */
UINT g_cpOpened;                      /* codepage of open file             */
UINT g_cpSave;                        /* codepage in which to save         */
WB   g_wbOpened;                      /* BOM was present when opened       */
WB   g_wbSave;                        /* BOM should be saved               */
BOOL g_fSaveEntity;                   /* Entities should be saved          */

FINDREPLACE FR;                       /* Passed to FindText()              */
PAGESETUPDLG g_PageSetupDlg;
UINT wFRMsg;                          /* message used in communicating     */
                                      /* with Find/Replace dialog          */

DWORD dwCurrentSelectionStart = 0L;   /* WM_ACTIVATEAPP selection pos      */
DWORD dwCurrentSelectionEnd   = 0L;   /* WM_ACTIVATEAPP selection pos      */
UINT wHlpMsg;                         /* message used in invoking help     */

/* Strings loaded from resource file passed to LoadString at initialization time */
/* To add resource string:
 * 1) create IDS_ macro definition in notepad.h
 * 2) create string in resource file
 * 3) create 'TCHAR*' variable directly below and in notepad.h file
 * 4) add &variable to rgsz
 *
 */
TCHAR *szDiskError =(TCHAR *)IDS_DISKERROR;  /* Can't open File, check disk  */
TCHAR *szFNF       =(TCHAR *)IDS_FNF;        /* File not found               */
TCHAR *szSCBC      =(TCHAR *)IDS_SCBC;       /* Save changes before closing? */
TCHAR *szUntitled  =(TCHAR *)IDS_UNTITLED;   /* Untitled                     */
TCHAR *szNpTitle   =(TCHAR *)IDS_NOTEPAD;    /* Notepad -                    */
TCHAR *szCFS       =(TCHAR *)IDS_CFS;        /* Can't find string            */
TCHAR *szErrSpace  =(TCHAR *)IDS_ERRSPACE;   /* Memory space exhausted       */
TCHAR *szFTL       =(TCHAR *)IDS_FTL;        /* File too large for notepad   */
TCHAR *szNN        =(TCHAR *)IDS_NN;         /* Notepad name                 */

TCHAR *szCommDlgInitErr = (TCHAR*)IDS_COMMDLGINIT; /* common dialog error %x */
TCHAR *szPDIE      =(TCHAR*) IDS_PRINTDLGINIT; /* Print dialog init error    */
TCHAR *szCP        =(TCHAR*) IDS_CANTPRINT;  /* Can't print                  */
TCHAR *szNVF       =(TCHAR*) IDS_NVF;        /* Not a valid filename.        */
TCHAR *szCREATEERR =(TCHAR*) IDS_CREATEERR;  /* cannot create file           */
TCHAR *szNoWW      =(TCHAR*) IDS_NOWW;       /* Too much text to word wrap   */
TCHAR *szMerge     =(TCHAR*) IDS_MERGE1;     /* search string for merge      */
TCHAR *szHelpFile  =(TCHAR*) IDS_HELPFILE;   /* Name of helpfile.            */
TCHAR *szHeader    =(TCHAR*) IDS_HEADER;
TCHAR *szFooter    =(TCHAR*) IDS_FOOTER;

TCHAR *szTextFiles          = (TCHAR*) IDS_TEXTFILES;    /* File/Open TXT filter spec. string */
TCHAR *szHtmlFiles          = (TCHAR*) IDS_HTMLFILES;    /* File/Open HTML filter spec. string */
TCHAR *szXmlFiles           = (TCHAR*) IDS_XMLFILES;     /* File/Open XML filter spec. string */
TCHAR *szEncodedText        = (TCHAR*) IDS_ENCODEDTEXT;  /* File/Open TXT Filter spec. string */
TCHAR *szAllFiles           = (TCHAR*) IDS_ALLFILES;     /* File/Open Filter spec. string */

TCHAR *szMoreEncoding       = (TCHAR*) IDS_MOREENCODING;

#if 0
TCHAR *szOpenCaption        = (TCHAR*) IDS_OPENCAPTION;  /* caption for File/Open dlg */
TCHAR *szSaveCaption        = (TCHAR*) IDS_SAVECAPTION;  /* caption for File/Save dlg */
#endif
TCHAR *szCannotQuit         = (TCHAR*) IDS_CANNOTQUIT;   /* cannot quit during a WM_QUERYENDSESSION */
TCHAR *szLoadDrvFail        = (TCHAR*) IDS_LOADDRVFAIL;  /* LOADDRVFAIL from PrintDlg */
TCHAR *szACCESSDENY         = (TCHAR*) IDS_ACCESSDENY;   /* Access denied on Open */
TCHAR *szFontTooBig         = (TCHAR*) IDS_FONTTOOBIG;   /* font too big or page too small */

TCHAR *szCommDlgErr         = (TCHAR*) IDS_COMMDLGERR;   /* common dialog error %x */
TCHAR *szLineError          = (TCHAR*) IDS_LINEERROR;    /* line number error        */
TCHAR *szLineTooLarge       = (TCHAR*) IDS_LINETOOLARGE; /* line number out of range */
TCHAR *szInvalidCP          = (TCHAR*) IDS_INVALIDCP;    /* invalid codepage */
TCHAR *szInvalidIANA        = (TCHAR*) IDS_INVALIDIANA;  /* invalid encoding */
TCHAR *szEncodingMismatch   = (TCHAR*) IDS_ENCODINGMISMATCH;
TCHAR *szCurrentPage        = (TCHAR*) IDS_CURRENT_PAGE;

// strings for the status bar
TCHAR *szLineCol        = (TCHAR*) IDS_LINECOL;
TCHAR *szCompressedFile = (TCHAR*) IDS_COMPRESSED_FILE;  
TCHAR *szEncryptedFile  = (TCHAR*) IDS_ENCRYPTED_FILE;   
TCHAR *szHiddenFile     = (TCHAR*) IDS_HIDDEN_FILE;      
TCHAR *szOfflineFile    = (TCHAR*) IDS_OFFLINE_FILE;     
TCHAR *szReadOnlyFile   = (TCHAR*) IDS_READONLY_FILE;    
TCHAR *szSystemFile     = (TCHAR*) IDS_SYSTEM_FILE;      
TCHAR *szFile           = (TCHAR*) IDS_FILE;             
TCHAR *szNoStatusAvail  = (TCHAR*) IDS_NOSTATUSAVAIL;


// Resource strings
// This table *must* be null terminated
//
// At startup, these pointers point to pointes which have the IDS_ number in them.
// npinit.c will LoadString on these resource IDs and replace the IDs with pointers.

TCHAR ** const rgsz[] = {
        &szDiskError,
        &szFNF,
        &szSCBC,
        &szUntitled,
        &szErrSpace,
        &szCFS,
        &szNpTitle,
        &szFTL,
        &szNN,
        &szCommDlgInitErr,
        &szPDIE,
        &szCP,
        &szNVF,
        &szCREATEERR,
        &szNoWW,
        &szMerge,
        &szHelpFile,
        &szTextFiles,
        &szHtmlFiles,
        &szXmlFiles,
        &szEncodedText,
        &szAllFiles,
        &szMoreEncoding,
        &szCannotQuit,
        &szLoadDrvFail,
        &szACCESSDENY,
        &szCommDlgErr,
        &szFontTooBig,
        &szLineError,
        &szLineTooLarge,
        &szInvalidCP,
        &szInvalidIANA,
        &szEncodingMismatch,
        &szCurrentPage,
        &szHeader,
        &szFooter,
        &szLineCol,
        &szCompressedFile,
        &szEncryptedFile,
        &szHiddenFile,
        &szOfflineFile,
        &szReadOnlyFile,
        &szSystemFile,
        &szFile,
        &szNoStatusAvail,
        NULL                      // end of table marker
};


HANDLE   fp;          /* file pointer */


#if 0
VOID DisplayFont( LOGFONT* pf )
{
    TCHAR dbuf[100];

    ODS(TEXT("-----------------------\n"));
    wsprintf(dbuf,TEXT("lfHeight          %d\n"),pf->lfHeight); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWidth           %d\n"),pf->lfWidth ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfEscapement      %d\n"),pf->lfEscapement); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOrientation     %d\n"),pf->lfOrientation); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWeight          %d\n"),pf->lfWeight); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfItalic          %d\n"),pf->lfItalic); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfUnderLine       %d\n"),pf->lfUnderline); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfStrikeOut       %d\n"),pf->lfStrikeOut); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfCharSet         %d\n"),pf->lfCharSet); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOutPrecision    %d\n"),pf->lfOutPrecision); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfClipPrecision   %d\n"),pf->lfClipPrecision); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfQuality         %d\n"),pf->lfQuality); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfPitchAndFamily  %d\n"),pf->lfPitchAndFamily); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfFaceName        %s\n"),pf->lfFaceName); ODS(dbuf);

}
#endif

static TCHAR  szPath[MAX_PATH];

void FileDragOpen(void);
VOID NpResetMenu(HWND hWnd);
BOOL SignalCommDlgError(VOID);
VOID ReplaceSel( BOOL bView );

/* FreeGlobal, frees  all global memory allocated. */

void NEAR PASCAL FreeGlobal()
{
    if(g_PageSetupDlg.hDevMode)
    {
        GlobalFree(g_PageSetupDlg.hDevMode);
    }

    if(g_PageSetupDlg.hDevNames)
    {
        GlobalFree(g_PageSetupDlg.hDevNames);
    }

    g_PageSetupDlg.hDevMode=  NULL; // make sure they are zero for PrintDlg
    g_PageSetupDlg.hDevNames= NULL;
}

VOID PASCAL SetPageSetupDefaults( VOID )
{
    TCHAR szIMeasure[ 2 ];

    g_PageSetupDlg.lpfnPageSetupHook= PageSetupHookProc;
    g_PageSetupDlg.lpPageSetupTemplateName= MAKEINTRESOURCE(IDD_PAGESETUP);

    GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szIMeasure, 2 );

    g_PageSetupDlg.Flags= PSD_MARGINS  |
            PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGESETUPTEMPLATE;

    if (szIMeasure[ 0 ] == TEXT( '1' ))
    {
        //  English measure (in thousandths of inches).
        g_PageSetupDlg.Flags |= PSD_INTHOUSANDTHSOFINCHES;
        g_PageSetupDlg.rtMargin.top    = 1000;
        g_PageSetupDlg.rtMargin.bottom = 1000;
        g_PageSetupDlg.rtMargin.left   = 750;
        g_PageSetupDlg.rtMargin.right  = 750;
    }
    else
    {
        //  Metric measure (in hundreths of millimeters).
        g_PageSetupDlg.Flags |= PSD_INHUNDREDTHSOFMILLIMETERS;
        g_PageSetupDlg.rtMargin.top    = 2500;
        g_PageSetupDlg.rtMargin.bottom = 2500;
        g_PageSetupDlg.rtMargin.left   = 2000;
        g_PageSetupDlg.rtMargin.right  = 2000;
    }

}

/* Standard window size proc */
void NPSize (int cxNew, int cyNew)
{

    /* Invalidate the edit control window so that it is redrawn with the new
     * margins. Needed when comming up from iconic and when doing word wrap so
     * the new margins are accounted for.
     */

    InvalidateRect(hwndEdit, (LPRECT)NULL, TRUE);

    // the height of the edit window depends on whether the status bar is
    // displayed.
    MoveWindow (hwndEdit, 0, 0, cxNew, cyNew - (fStatus?dyStatus:0), TRUE);

}


// SelectEncodingDlgProc
//
// Handle the Goto Dialog window processing
//
// Returns:
//
// 1 if successfull
// 0 if not (cancelled)
//
// Modifies global lGotoLine
//

INT_PTR CALLBACK SelectEncodingDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UINT *pcp;

#define PCPPROP ((LPCTSTR) 0xA000L)

    switch (message)
    {
        case WM_INITDIALOG:
            pcp = (UINT *) lParam;

            SetProp(hDlg, PCPPROP, (HANDLE) pcp);

            PopulateCodePages(hDlg, TRUE, *pcp, *pcp);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                LRESULT lr;

                case IDC_CODEPAGE:
                    if (HIWORD(wParam) != LBN_DBLCLK)
                    {
                        break;
                    }

                    // Fall through

                case IDOK:
                    pcp = (UINT *) GetProp(hDlg, PCPPROP);

                    if (pcp != NULL)
                    {
                        lr = SendDlgItemMessage(hDlg, IDC_CODEPAGE, LB_GETCURSEL, 0, 0);

                        if (lr >= 0)
                        {
                            *pcp = (UINT) SendDlgItemMessage(hDlg, IDC_CODEPAGE, LB_GETITEMDATA, (WPARAM) lr, 0);
                        }
                    }

                    RemoveProp(hDlg, PCPPROP);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL :
                    RemoveProp(hDlg, PCPPROP);
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
            break;
    }

    return FALSE;
}


// NpSaveDialogHookProc
//
// Common dialog hook procedure for handling
// the file type while saving.
//

const DWORD s_SaveAsHelpIDs[]=
    {
        IDC_CODEPAGE, IDH_FILETYPE,
        IDC_ENCODING, IDH_FILETYPE,
        0, 0
    };

UINT_PTR APIENTRY NpSaveDialogHookProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT cch;
    HANDLE hText;
    INT id;

    switch( msg )
    {
        LRESULT lr;

        case WM_INITDIALOG:
            g_cpSave = g_cpOpened;
            g_wbSave = g_wbOpened;

            // Check for an HTML or XML file with a declared encoding
            // If one is found, suggest the declared encoding

            cch = (UINT) SendMessage(hwndEdit, WM_GETTEXTLENGTH, 0, 0);
            hText = (HANDLE) SendMessage(hwndEdit, EM_GETHANDLE, 0, 0);

            if (hText != NULL)
            {
                LPCTSTR rgwch = (LPTSTR) LocalLock(hText);

                if (rgwch != NULL)
                {
                    UINT cpDetected;

                    if (FDetectEncodingW(szFileOpened, rgwch, cch, &cpDetected))
                    {
                        // We detected an expected encoding for this file

                        g_cpSave = cpDetected;
                    }

                    LocalUnlock(hText);
                }
            }

            PopulateCodePages(hDlg, FALSE, g_cpSave, g_cpOpened);

            // Clear CBS_SORT flag to keep More... entry at end of list

            lr = SendDlgItemMessage(hDlg, IDC_CODEPAGE, CB_INSERTSTRING, (WPARAM) -1, (LPARAM) szMoreEncoding);

            if (lr >= 0)
            {
                SendDlgItemMessage(hDlg, IDC_CODEPAGE, CB_SETITEMDATA, (WPARAM) lr, CP_AUTO);
            }
            break;

        case WM_COMMAND:
            lr = SendDlgItemMessage(hDlg, IDC_CODEPAGE, CB_GETCURSEL, 0, 0);

            if (lr >= 0)
            {
                g_cpSave = (UINT) SendDlgItemMessage(hDlg, IDC_CODEPAGE, CB_GETITEMDATA, (WPARAM) lr, 0);
            }
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)->hItemHandle);

            if ( id != IDC_CODEPAGE && id != IDC_ENCODING)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle,
                      szHelpFile,
                      HELP_WM_HELP,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hDlg == (HWND) wParam )
            {
                POINT pt;

                GetCursorPos(&pt);
                ScreenToClient(hDlg, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hDlg, pt);
            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if ( id != IDC_CODEPAGE && id != IDC_ENCODING)
                break;

            WinHelp( (HWND)   wParam,
                              szHelpFile,
                              HELP_CONTEXTMENU,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;
    }

    return(FALSE);
}

// GotoAndScrollInView
//
// Put the cursor at the begining of a line, and scroll the
// editbox so the user can see it.
//
// If there is a failure, it just leaves the cursor where it is.
//

VOID GotoAndScrollInView( INT OneBasedLineNumber )
{
    UINT CharIndex;
    CharIndex= (UINT) SendMessage( hwndEdit,
                                   EM_LINEINDEX,
                                   OneBasedLineNumber-1,
                                   0 );
    if( CharIndex != (UINT) -1 )
    {
        SendMessage( hwndEdit, EM_SETSEL, CharIndex, CharIndex);
        SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
    }

}

/* ** Notepad command proc - called whenever notepad gets WM_COMMAND
      message.  wParam passed as cmd */
INT NPCommand(
    HWND     hwnd,
    WPARAM   wParam,
    LPARAM   lParam )
{
    HWND     hwndFocus;
    LONG     lSel;
    TCHAR    szNewName[MAX_PATH] = TEXT("");      /* New file name */
    LONG     style;
    DWORD    rc;
    RECT     rcClient;

    UNREFERENCED_PARAMETER( lParam );

    switch (LOWORD(wParam))
    {
        case M_EXIT:
            PostMessage(hwnd, WM_CLOSE, 0, 0L);
            break;

        case M_NEW:
            New(TRUE);
            break;

        case M_OPEN:
            if (CheckSave(FALSE))
            {
                szNewName[0] = TEXT('\0');      /* set default selection */

                /* set up the variable fields of the OPENFILENAME struct.
                 * (the constant fields have been set in NPInit()
                 */
                OFN.lpstrFile      = szNewName;
#if 0
                OFN.lpstrTitle     = szOpenCaption;
#endif

                /* Added OFN_FILEMUSTEXIST to eliminate problems in LoadFile.
                 * 12 February 1991    clarkc
                 */

                OFN.Flags          = OFN_HIDEREADONLY     | OFN_FILEMUSTEXIST |
                                     OFN_EXPLORER;

                OFN.lpTemplateName = NULL;
                OFN.lpfnHook       = NULL;
                OFN.lpstrFilter    = szOpenFilterSpec;
                OFN.lpstrDefExt    = TEXT("txt");
                OFN.nFilterIndex   = FILE_TEXT;

                if (GetOpenFileName(&OFN))
                {
                   HANDLE oldfp= fp;

                   fp= CreateFile( szNewName,            // filename
                                   GENERIC_READ,         // access mode
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,                 // security descriptor
                                   OPEN_EXISTING,        // how to create
                                   FILE_ATTRIBUTE_NORMAL,// file attributes
                                   NULL);                // hnd to file attrs

                   /* Try to load the file and reset fp if failed */

                   if (!LoadFile(szNewName, OFN.nFilterIndex == FILE_ENCODED))
                   {
                      fp= oldfp;
                   }
                }
                else
                {
                    SignalCommDlgError();
                }
            }
            break;

        case M_SAVE:
            /* set up the variable fields of the OPENFILENAME struct.
             * (the constant fields have been sel in NPInit()
             */
            g_cpSave = g_cpOpened;
            g_wbSave = g_wbOpened;

            if (!FUntitled() && SaveFile(hwndNP, szFileOpened, FALSE))
            {
                break;
            }

            /* fall through */

        case M_SAVEAS:
            lstrcpy(szNewName, szFileOpened);     // Set default selection

            OFN.lpstrFile      = szNewName;
#if 0
            OFN.lpstrTitle     = szSaveCaption;
#endif

            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */

            OFN.Flags          = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                                 OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                                 OFN_EXPLORER         | OFN_ENABLESIZING    |
                                 OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName = TEXT("NpSaveDialog");
            OFN.lpfnHook       = NpSaveDialogHookProc;
            OFN.lpstrFilter    = szSaveFilterSpec;
            OFN.lpstrDefExt    = TEXT("txt");
            OFN.nFilterIndex   = FILE_TEXT;

            //
            // Do common dialog to save file
            //

            fInSaveAsDlg = TRUE;
            if (GetSaveFileName(&OFN))
            {
                SaveFile(hwnd, szNewName, TRUE);
            }

            else
            {
                SignalCommDlgError();
            }

            fInSaveAsDlg = FALSE;
            break;

        case M_SELECTALL:
            {
                HMENU    hMenu;

                hMenu = GetMenu(hwndNP);
                lSel = (LONG) SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, 0L);
                SendMessage (hwndEdit, EM_SETSEL, 0, lSel );
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
                EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_GRAYED);
                break;
            }

        case M_REPLACE:
            if( hDlgFind )
            {
               SetFocus( hDlgFind );
            }
            else
            {
               FR.Flags= FR_HIDEWHOLEWORD | FR_REPLACE;
               FR.lpstrReplaceWith= szReplace;
               FR.wReplaceWithLen= CCHKEYMAX;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = ReplaceText( &FR );
            }
            break;

        case M_FINDNEXT:
            if (szSearch[0])
            {
               Search(szSearch);
               break;
            }
            /* else fall thro' a,d bring up "find" dialog */

        case M_FIND:
            if (hDlgFind)
            {
               SetFocus(hDlgFind);
            }
            else
            {
               FR.Flags= FR_DOWN | FR_HIDEWHOLEWORD;
               FR.lpstrReplaceWith= NULL;
               FR.wReplaceWithLen= 0;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = FindText((LPFINDREPLACE)&FR);
            }
            break;

        case M_GOTO:
            {
                INT  Result;

                Result= (INT)DialogBox( hInstanceNP,
                                        MAKEINTRESOURCE(IDD_GOTODIALOG),
                                        hwndNP,
                                        GotoDlgProc );

                //
                // move cursor only if ok pressed and line number ok
                //

                if( Result == 0 )
                {
                    GotoAndScrollInView( lGotoLine );
                }
            }
            break;

        case M_ABOUT:
            ShellAbout(hwndNP,
                       szNN,
                       TEXT(""),
                       LoadIcon(hInstanceNP,
                                (LPTSTR)MAKEINTRESOURCE(ID_ICON)));

            break;

        case M_HELP:
            HtmlHelpA(GetDesktopWindow(), "notepad.chm", HH_DISPLAY_TOPIC, 0L);
            break;

        case M_CUT:
        case M_COPY:
        case M_CLEAR:
            lSel = (LONG)SendMessage (hwndEdit, EM_GETSEL, 0, 0L);
            if (LOWORD(lSel) == HIWORD(lSel))
               break;

        case M_PASTE:
            /* If notepad parent or edit window has the focus,
               pass command to edit window.
               make sure line resulting from paste will not be too long. */
            hwndFocus = GetFocus();
            if (hwndFocus == hwndEdit || hwndFocus == hwndNP)
            {
                PostMessage(hwndEdit, LOWORD(wParam), 0, 0);
            }
            break;

        case M_DATETIME:
            InsertDateTime(FALSE);
            break;

        case M_UNDO:
            SendMessage (hwndEdit, EM_UNDO, 0, 0L);
            break;

        case M_WW:
            style= (!fWrap) ? ES_STD : (ES_STD | WS_HSCROLL);
            if( NpReCreate( style ) )
            {
                fWrap= !fWrap;
            }
            else
            {
                MessageBox(hwndNP, szNoWW, szNN,
                           MB_APPLMODAL | MB_OK | MB_ICONWARNING);
            }

            // redraw the status bar
            if( fStatus )
            {
                GetClientRect(hwndNP, &rcClient);
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
                ShowWindow( hwndStatus, SW_SHOW );
            }

            break;

        case M_STATUSBAR:

            // hide/show the statusbar and also redraw the edit window accordingly.
            GetClientRect(hwndNP, &rcClient);

            if ( fStatus )
            {
                fStatus = FALSE;
                ShowWindow ( hwndStatus, SW_HIDE );
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
            }
            else
            {
                fStatus = TRUE;
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);

                ShowWindow( hwndStatus, SW_SHOW );
            }
            break;

        case ID_EDIT:
            break;

        case M_PRINT:
            PrintIt( UseDialog );
            break;

        case M_PAGESETUP:
            TryPrintDlgAgain:
            
            if( PageSetupDlg(&g_PageSetupDlg) )
            {
                //  We know it's okay to copy these strings over...
                lstrcpy(chPageText[HEADER], chPageTextTemp[HEADER]);
                lstrcpy(chPageText[FOOTER], chPageTextTemp[FOOTER]);
            }
            else
            {
                rc= CommDlgExtendedError();

                if( rc == PDERR_PRINTERNOTFOUND ||
                    rc == PDERR_DNDMMISMATCH    ||
                    rc == PDERR_DEFAULTDIFFERENT )
                  {
                      FreeGlobal();
                      g_PageSetupDlg.hDevMode= g_PageSetupDlg.hDevNames= 0;
                      goto TryPrintDlgAgain;
                  }

                // Check for Dialog Failure

                SignalCommDlgError( );

            }
            break;

        case M_SETFONT:
        {
            CHOOSEFONT  cf;
            HFONT       hFontNew;
            HDC         hDisplayDC;     // display DC

            hDisplayDC= GetDC(NULL);    // try to get display DC
            if( !hDisplayDC )
                break;

            /* calls the font chooser (in commdlg)
             * We set lfHeight; choosefont returns ipointsize
             */
            cf.lStructSize = sizeof(CHOOSEFONT);
            cf.hwndOwner = hwnd;
            cf.lpLogFont = &FontStruct;         // filled in by init
            FontStruct.lfHeight= -MulDiv(iPointSize,GetDeviceCaps(hDisplayDC,LOGPIXELSY),720);
            cf.Flags = CF_INITTOLOGFONTSTRUCT |
                       CF_SCREENFONTS         | 
                       CF_NOSCRIPTSEL         |
                       CF_NOVERTFONTS         |
                       0;
            cf.rgbColors = 0;                   // only if cf_effects
            cf.lCustData = 0;                   // for hook function
            cf.lpfnHook = (LPCFHOOKPROC) NULL;
            cf.lpTemplateName = (LPTSTR) NULL;
            cf.hInstance = NULL;
            cf.lpszStyle = NULL;                // iff cf_usestyle
            cf.nFontType = SCREEN_FONTTYPE;
            cf.nSizeMin  = 0;  // iff cf_limitsize
            cf.nSizeMax  = 0;  // iff cf_limitsize
            ReleaseDC( NULL, hDisplayDC );

            if( ChooseFont(&cf) )
            {
                SetCursor( hWaitCursor );        // may take some time
                
                hFontNew= CreateFontIndirect(&FontStruct);
                if( hFontNew )
                {
                   DeleteObject( hFont );
                   hFont= hFontNew;
                   SendMessage( hwndEdit, WM_SETFONT,
                               (WPARAM)hFont, MAKELPARAM(TRUE, 0));
                   iPointSize= cf.iPointSize;  // remember for printer
                }
                SetCursor( hStdCursor );
            }
            break;
        }

        default:
            return FALSE;
    }
    return TRUE;
}


// for some reason, this procedure tries to maintain
// a valid 'fp' even though I believe it does not need
// to be.
void FileDragOpen(void)
{
    HANDLE oldfp;

    oldfp= fp;       // remember in case of error

    if( CheckSave(FALSE) )
    {

         fp= CreateFile( szPath,               // filename
                         GENERIC_READ,         // access mode
                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                         NULL,                 // security descriptor
                         OPEN_EXISTING,        // how to create
                         FILE_ATTRIBUTE_NORMAL,// file attributes
                         NULL);                // hnd to file attrs

       if( fp == INVALID_HANDLE_VALUE )
       {
          AlertUser_FileFail( szPath );

          // Restore fp to original file.
          fp= oldfp;
       }
       /* Try to load the file and reset fp if failed */
       else if (!LoadFile(szPath, g_fSelectEncoding))
       {
           fp= oldfp;
       }
    }
}


/* Proccess file drop/drag options. */
void doDrop (WPARAM wParam, HWND hwnd)
{
   /* If user dragged/dropped a file regardless of keys pressed
    * at the time, open the first selected file from file manager. */

    if (DragQueryFile ((HANDLE)wParam, 0xFFFFFFFF, NULL, 0)) /* # of files dropped */
    {
       DragQueryFile ((HANDLE)wParam, 0, szPath, CharSizeOf(szPath));
       SetActiveWindow (hwnd);
       FileDragOpen();
    }
    DragFinish ((HANDLE)wParam);  /* Delete structure alocated for WM_DROPFILES*/
}

/* ** if notepad is dirty, check to see if user wants to save contents */
BOOL CheckSave(BOOL fSysModal)
{
    INT    mdResult;
    TCHAR  szNewName[MAX_PATH];      /* New file name */

/* If it's untitled and there's no text, don't worry about it */
    if (FUntitled() && !SendMessage(hwndEdit, WM_GETTEXTLENGTH, 0, 0))
        return(TRUE);

    if (!SendMessage(hwndEdit, EM_GETMODIFY, 0, 0))
        return(TRUE);

    mdResult = AlertBox(hwndNP, szNN, szSCBC, SzTitle(),
                        (WORD)((fSysModal ? MB_SYSTEMMODAL :
                                            MB_APPLMODAL)| MB_YESNOCANCEL| MB_ICONWARNING));

    if (mdResult == IDYES)
    {
        if (FUntitled())
        {
SaveFilePrompt:
            lstrcpy(szNewName, szFileOpened);     // Set default selection

            OFN.lpstrFile      = szNewName;
#if 0
            OFN.lpstrTitle     = szSaveCaption;
#endif

            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */

            OFN.Flags          = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                                 OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                                 OFN_EXPLORER         | OFN_ENABLESIZING    |
                                 OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName = TEXT("NpSaveDialog");
            OFN.lpfnHook       = NpSaveDialogHookProc;
            OFN.lpstrFilter    = szSaveFilterSpec;
            OFN.lpstrDefExt    = TEXT("txt");
            OFN.nFilterIndex   = FILE_TEXT;

            //
            // Set dialog checkmark by current file type
            //

            fInSaveAsDlg = TRUE;
            if (GetSaveFileName(&OFN))
            {
                if (!SaveFile(hwndNP, szNewName, TRUE))
                {
                    // Fixing close without saving file when disk-full

                    goto SaveFilePrompt;
                }
            }
            else
            {
                mdResult= IDCANCEL;       /* Don't exit Program */
                if( CommDlgExtendedError() )/* Dialog box failed, Lo-mem*/
                    DeepTrouble();
            }

            fInSaveAsDlg = FALSE;
        }
        else
        {
            // Initialize the save type.

            g_cpSave = g_cpOpened;
            g_wbSave = g_wbOpened;

            if (SaveFile(hwndNP, szFileOpened, FALSE))
            {
                return(TRUE);
            }

            goto SaveFilePrompt;
        }
    }

    return (mdResult != IDCANCEL);
}


/* Notepad window class procedure */
LRESULT FAR NPWndProc(
        HWND       hwnd,
        UINT       message,
        WPARAM     wParam,
        LPARAM     lParam)
{
    LPFINDREPLACE lpfr;
    DWORD dwFlags;
    INT iParts[2];


    switch (message)
    {
/* If we're being run by Setup and it's the system menu, be certain that
 * the minimize menu item is disabled.  Note that hSysMenuSetup is only
 * initialized if Notepad is being run by Setup.  Don't use it outside
 * the fRunBySetup conditional!    28 June 1991    Clark Cyr
 */
        case WM_INITMENUPOPUP:
            if (fRunBySetup && HIWORD(lParam))
               EnableMenuItem(hSysMenuSetup,SC_MINIMIZE,MF_GRAYED|MF_DISABLED);
            break;

        case WM_SYSCOMMAND:
            if (fRunBySetup)
            {
                /* If we have been spawned by SlipUp we need to make sure the
                 * user doesn't minimize us or alt tab/esc away.
                 */
                if (wParam == SC_MINIMIZE ||
                    wParam == SC_NEXTWINDOW ||
                    wParam == SC_PREVWINDOW)
                    break;
            }
            DefWindowProc(hwnd, message, wParam, lParam);
            break;

        case WM_SETFOCUS:
            if (!IsIconic(hwndNP))
            {
               SetFocus(hwndEdit);
            }
            break;

        case WM_KILLFOCUS:
            SendMessage (hwndEdit, message, wParam, lParam);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_CLOSE:

            // Save any globals in the registry if need be

            SaveGlobals();

            if (CheckSave(FALSE))
            {
                /* Exit help */
                if(!WinHelp(hwndNP, (LPTSTR)szHelpFile, HELP_QUIT, 0))
                    DeepTrouble();

                DestroyWindow(hwndStatus);
                DestroyWindow(hwndNP);
                DeleteObject(hFont);
            }

            break;

        case WM_QUERYENDSESSION:
            if (fInSaveAsDlg)
            {
                MessageBeep (0);
                MessageBeep (0);
                MessageBox (hwndNP, szCannotQuit, szNN, MB_OK|MB_SYSTEMMODAL);
                return FALSE;
            }
            else
                return (CheckSave(TRUE));
            break;


        case WM_ACTIVATEAPP:
            if (wParam)
            {
            /* This causes the caret position to be at the end of the selection
             * but there's no way to ask where it was or set it if known.  This
             * will cause a caret change when the selection is made from bottom
             * to top.
             */
                if( dwCurrentSelectionStart != 0 || dwCurrentSelectionEnd != 0 )
                {
                   SendMessage( hwndEdit, EM_SETSEL,
                                dwCurrentSelectionStart,
                                dwCurrentSelectionEnd );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
                }
            }
            else
            {
                SendMessage( hwndEdit, EM_GETSEL,
                            (WPARAM) &dwCurrentSelectionStart,
                            (LPARAM) &dwCurrentSelectionEnd);
                if (dwCurrentSelectionStart == dwCurrentSelectionEnd)
                {
                    dwCurrentSelectionStart = 0L;
                    dwCurrentSelectionEnd = 0L;
                }
                else
                {
                   SendMessage (hwndEdit, EM_SETSEL, dwCurrentSelectionStart,
                                dwCurrentSelectionEnd);
                   SendMessage (hwndEdit, EM_SCROLLCARET, 0, 0);
                }
            }
            break;

        case WM_ACTIVATE:
            if ((LOWORD(wParam) == WA_ACTIVE       ||
                 LOWORD(wParam) == WA_CLICKACTIVE) &&
                !IsIconic(hwndNP)
               )
               {
                   // active doesn't always mean foreground (ntbug# 53048)
                   if( GetForegroundWindow() == hwndNP )
                   {
                       SetFocus(GetForegroundWindow());
                   }
               }
            break;

        case WM_SIZE:
            switch (wParam)
            {
                case SIZENORMAL:
                case SIZEFULLSCREEN:

                    // resize the status window.
                    SendMessage (hwndStatus, WM_SIZE, 0, 0L);
                    iParts[0] = 3 * (MAKEPOINTS(lParam).x)/4;
                    iParts[1] = -1;

                    // Divide the status window into two parts
                    SendMessage(hwndStatus, SB_SETPARTS, (WPARAM) sizeof(iParts)/sizeof(INT), (LPARAM) &iParts); 

                    NPSize(MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y);
                    break;

                case SIZEICONIC:
                    return (DefWindowProc(hwnd, message, wParam, lParam));
                    break;
                }
            break;

        case WM_INITMENU:
            NpResetMenu( hwnd );
            break;

        //
        // Some keyboards come with a "Search" button which the shell team
        // wanted us to handle.  See ntbug# 380067
        //

        case WM_APPCOMMAND:

            if( ( GET_APPCOMMAND_LPARAM(lParam) == APPCOMMAND_BROWSER_SEARCH ) ) 
            {
                NPCommand(hwnd, M_FIND, 0);
                break;
            }
            // otherwise fall through
 
        case WM_COMMAND:

            if ((HWND)(lParam) == hwndEdit &&
                (HIWORD(wParam) == EN_ERRSPACE ||
                 HIWORD(wParam) == EN_MAXTEXT))
            {
                if (dwEmSetHandle == SETHANDLEINPROGRESS)
                    dwEmSetHandle = SETHANDLEFAILED;
                else
                    DeepTrouble();
                return 0L;
            }

            if (!NPCommand(hwnd, wParam, lParam))
               return (DefWindowProc(hwnd, message, wParam, lParam));
            break;


        case WM_WININICHANGE:
            // Ignore for now.
            // If you put this back in, be sure it handles both
            // the metric change and the decimal change.
            NpWinIniChange();
            break;

        case WM_DROPFILES: /*case added 03/26/91 for file drag/drop support*/
            doDrop (wParam,hwnd);
            break;

        case PWM_CHECK_HKL: /* private message: corresponding to HKL change message */
            {
                LANGID langid = LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0));

                GetKeyboardCodepages(langid);

                if (PRIMARYLANGID(langid) == LANG_JAPANESE) {
                    LPARAM imeStatus = 0;
                    /*
                     * If new current HKL is Japanese, handle the result string at once.
                     */
                    imeStatus = EIMES_GETCOMPSTRATONCE;
                    SendMessage(hwndEdit, EM_SETIMESTATUS, EMSIS_COMPOSITIONSTRING, imeStatus);
                }
            }
            break;

        default:
            /* this can be a message from the modeless Find Text window */
            if (message == wFRMsg)
            {
                BOOL bStatus;    // true if found text

                lpfr = (LPFINDREPLACE)lParam;
                dwFlags = lpfr->Flags;

                fReverse = (dwFlags & FR_DOWN      ? FALSE : TRUE);
                fCase    = (dwFlags & FR_MATCHCASE ? TRUE  : FALSE);

                if( dwFlags & FR_FINDNEXT )
                {
                    SetCursor( hWaitCursor );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACE )
                {
                    //
                    // Replace current selection if it matches
                    // then highlight the next occurence of the string.
                    //

                    SetCursor( hWaitCursor );
                    ReplaceSel( TRUE );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACEALL )
                {
                   //
                   // The replace dialog doesn't allow reverse searches
                   // but just it cases it changes, for it to false.
                   //
                   if( fReverse )
                   {
                       fReverse= FALSE;
                   }

                   //
                   // Replace all occurances of text in the file
                   // starting from the top.  Reset the selection
                   // to the top of the file.
                   //
                   SetCursor( hWaitCursor );
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   do
                   {
                      ReplaceSel( FALSE );
                      bStatus= Search( szSearch );
                   }
                   while( bStatus );
                   SetCursor( hStdCursor );
                   //
                   // back to the top of the file.
                   //
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);

                }
                else if (dwFlags & FR_DIALOGTERM)
                    hDlgFind = NULL;   /* invalidate modeless window handle */
                break;
            }
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return (0L);
}

LPTSTR SkipProgramName (LPTSTR lpCmdLine)
{
    LPTSTR  p = lpCmdLine;
    BOOL    bInQuotes = FALSE;

    //
    // Skip executable name
    //
    for (p; *p; p = CharNext(p))
    {
       if ((*p == TEXT(' ') || *p == TEXT('\t')) && !bInQuotes)
          break;

       if (*p == TEXT('\"'))
          bInQuotes = !bInQuotes;
    }

    while (*p == TEXT(' ') || *p == TEXT('\t'))
       p++;

    return (p);
}

/* ** Main loop */

INT WINAPI WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR lpAnsiCmdLine,
   INT cmdShow)
{
    MSG msg;
    LPTSTR lpCmdLine = GetCommandLine ();
    HWINEVENTHOOK hEventHook = NULL;

#ifdef PENWINDOWS

    VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL) = NULL;
/* PenWindow registration must be before creating an edit class window.
 * Moved here, along with goto statement below for appropriate cleanup.
 *                 10 July 1991    ClarkC
 */
    lpfnRegisterPenApp= GetProcAddress( (HINSTANCE)(INT_PTR)(GetSystemMetrics(SM_PENWINDOWS)), 
                                        "RegisterPenApp");
    if( lpfnRegisterPenApp ) {
        (*lpfnRegisterPenApp)(1, TRUE);
    }
#endif

    if (!NPInit(hInstance, hPrevInstance, SkipProgramName(lpCmdLine), cmdShow))
    {
        msg.wParam = FALSE;
        goto UnloadMlang;
    }

    // set an event hook to get the cursor position! this event hook is used to update
    // the line & column position of the caret shown in the statusbar.
    hEventHook = SetWinEventHook(EVENT_OBJECT_LOCATIONCHANGE, EVENT_OBJECT_LOCATIONCHANGE, NULL, WinEventFunc, 
                                (DWORD) GetCurrentProcessId(), 0, WINEVENT_OUTOFCONTEXT);
 
    while (GetMessage((LPMSG)&msg, (HWND)NULL, 0, 0))
    {
        //
        // To handle IME status when active KL is changed.
        //
        if (msg.message == WM_INPUTLANGCHANGEREQUEST) {
            //
            // WM_INPUTLANGCHANGE will be *sent* to WndProc,
            // so there's no chance to catch WM_INPUTLANGCHANGE from the frame window.
            // Instead, we post the private message to check the active HKL later.
            //
            PostMessage(hwndNP, PWM_CHECK_HKL, 0, 0);
        }

        if (!hDlgFind || !IsDialogMessage(hDlgFind, &msg))
        {
            if (TranslateAccelerator(hwndNP, hAccel, (LPMSG)&msg) == 0)
            {
               TranslateMessage ((LPMSG)&msg);
               DispatchMessage ((LPMSG)&msg);
            }
        }
    }

    /* Clean up any global allocations */

    FreeGlobal();

    LocalFree(hEdit);

    if (hEventHook)
        UnhookWinEvent(hEventHook);

UnloadMlang:
    UnloadMlang();

#ifdef PENWINDOWS
    if (lpfnRegisterPenApp)
        (*lpfnRegisterPenApp)(1, FALSE);
#endif PENWINDOWS

    return (int)(msg.wParam);

    UNREFERENCED_PARAMETER( lpAnsiCmdLine );
}


/* This function is called whenever the location of the caret changes
in the edit window. The function updates the statusbar with the current
line number, column of the caret */

VOID CALLBACK WinEventFunc(
    HWINEVENTHOOK hWinEventHook, 
    DWORD event, 
    HWND hwnd, 
    LONG idObject,
    LONG idChild, 
    DWORD dwEventThread, 
    DWORD dwmsEventTime)
{
    DWORD SelStart, SelEnd;
    UINT  iLine, iCol;
    TCHAR szStatusText[128];

    // get the current caret position.
    SendMessage(hwndEdit,EM_GETSEL,(WPARAM) &SelStart,(WPARAM)&SelEnd);

    // the line numbers are 1 based instead 0 based. hence add 1.
    iLine = (UINT)SendMessage( hwndEdit, EM_LINEFROMCHAR, SelStart, 0 ) + 1;
    iCol = SelStart - (UINT)SendMessage( hwndEdit, EM_LINEINDEX, iLine-1, 0 ) + 1;

    // prepare and display the statusbar.
    // make sure you don't overflow the buffer boundary.
    _sntprintf(szStatusText, sizeof(szStatusText)/sizeof(TCHAR) -1, szLineCol, iLine, iCol);

    // display status unless wordwrap is on
    // Users get confused by MLE's idea of a line numbers.  Bug# 194034 (9/29/2000)

    if( !fWrap )
    {
        SetStatusBarText( szStatusText, 1 );
    }
    else
    {
        SetStatusBarText( szNoStatusAvail, 1 );
    }

    UNREFERENCED_PARAMETER( hWinEventHook );
    UNREFERENCED_PARAMETER( event );
    UNREFERENCED_PARAMETER( hwnd );
    UNREFERENCED_PARAMETER( idObject );
    UNREFERENCED_PARAMETER( idChild );
    UNREFERENCED_PARAMETER( dwEventThread );
    UNREFERENCED_PARAMETER( dwmsEventTime );
};


BOOL FUntitled(void)
{
   return(szFileOpened[0] == TEXT('\0'));
}


const TCHAR *SzTitle(void)
{
   return(FUntitled() ? szUntitled : szFileOpened);
}


void SetFileName(LPCTSTR szFile)
{
    TCHAR szWindowText[MAX_PATH+50];
    TCHAR szStatusText[128] = TEXT("");

    // if "untitled" then don't do all this work...

    if (szFile == NULL)
    {
        szFileOpened[0] = TEXT('\0');

        lstrcpy(szWindowText, szUntitled);
    }

    else
    {
        DWORD dwAttributes;

        if (szFile != szFileOpened)
        {
            TCHAR szFileT[MAX_PATH];
            BOOL fPeriod;
            LPTSTR pch;

            if (GetFullPathName(szFile, MAX_PATH, szFileT, NULL) == 0)
            {
                // We can't get the full path for some reason.
                // Use what was passed in.

                lstrcpyn(szFileT, szFile, MAX_PATH);
            }

            // Get real(file system) name for the file.

            if (GetLongPathName(szFileT, szFileOpened, MAX_PATH) == 0)
            {
                lstrcpy(szFileOpened, szFile);
            }

            // If the filename has no extension, append a trailing period
            // This keeps the COMDLG32 code from appending a default extension.

            fPeriod = FALSE;

            for (pch = szFileOpened; *pch != TEXT('\0'); pch++)
            {
                if (*pch == TEXT('.'))
                {
                    fPeriod = TRUE;
                }

                else if (*pch == TEXT('\\'))
                {
                    fPeriod = FALSE;
                }
            }

            if (!fPeriod && (pch < (szFileOpened + MAX_PATH - 1)))
            {
               *pch++ = TEXT('.');
               *pch = TEXT('\0');
            }
        }

        GetFileTitle(szFileOpened, szWindowText, MAX_PATH);

        // get the attributes for file. these will be shown
        // in the status bar.
        dwAttributes = GetFileAttributes(szFileOpened);

        // prepare the status bar text and show
        // if the file has any special properties (such as hidden, readonly etc.)

        if (dwAttributes & FILE_ATTRIBUTE_COMPRESSED)
            if ((lstrlen(szStatusText) + lstrlen(szCompressedFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)
                lstrcpy(szStatusText, szCompressedFile);

        if (dwAttributes & FILE_ATTRIBUTE_ENCRYPTED)   
            if ((lstrlen(szStatusText) + lstrlen(szEncryptedFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szEncryptedFile);

        if (dwAttributes & FILE_ATTRIBUTE_HIDDEN)
            if ((lstrlen(szStatusText) + lstrlen(szHiddenFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szHiddenFile);

        if (dwAttributes & FILE_ATTRIBUTE_OFFLINE)
            if ((lstrlen(szStatusText) + lstrlen(szOfflineFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szOfflineFile);

        if (dwAttributes & FILE_ATTRIBUTE_READONLY)
            if ((lstrlen(szStatusText) + lstrlen(szReadOnlyFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szReadOnlyFile);

        if (dwAttributes & FILE_ATTRIBUTE_SYSTEM)
            if ((lstrlen(szStatusText) + lstrlen(szSystemFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szSystemFile);

        // if the status did get updated by file properties
        if (*szStatusText != TEXT('\0'))
        {
            // get rid of the last comma
            szStatusText[lstrlen(szStatusText)-1] = TEXT(' ');

            if ((lstrlen(szStatusText) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)           
                lstrcat(szStatusText, szFile);
        }
    }

    // set the status bar. the Line and Col count is 1 initially for
    // the newly opened file as the caret position is at the first character.
    SetStatusBarText(szStatusText, 0);
    _sntprintf(szStatusText, sizeof(szStatusText)/sizeof(TCHAR) -1, szLineCol, 1, 1);

    if( !fWrap )
    {
        SetStatusBarText( szStatusText, 1 );
    }
    else
    {
        SetStatusBarText( szNoStatusAvail, 1 );
    }

    lstrcat(szWindowText, szNpTitle);
    SetWindowText(hwndNP, szWindowText);

}

/* ** Given filename which may or maynot include path, return pointer to
      filename (not including path part.) */
LPCTSTR PFileInPath(LPCTSTR szFile)
{
    LPCTSTR pch = szFile;
    LPCTSTR psz;

    /* Strip path/drive specification from name if there is one */
    /* Ripped out AnsiPrev calls.     21 March 1991  clarkc     */
    for (psz = szFile; *psz; psz = CharNext(psz))
      {
        if ((*psz == TEXT(':')) || (*psz == TEXT('\\')))
            pch = psz;
      }

    if (pch != szFile)  /* If found slash or colon, return the next character */
        pch++;          /* increment OK, pch not pointing to DB character     */

    return(pch);
}

/* ** Enable or disable menu items according to selection state
      This routine is called when user tries to pull down a menu. */

VOID NpResetMenu( HWND hwnd )
{
    LONG    lsel;
    INT     mfcc;   /* menuflag for cut, copy */
    BOOL    fCanUndo;
    HANDLE  hMenu;
    BOOL    fPaste= FALSE;
    UINT    uSelState;

    hMenu = GetMenu(hwndNP);

    // cut, copy and delete only get enabled if there is text selected.

    lsel = (LONG)SendMessage(hwndEdit, EM_GETSEL, 0, 0L);
    mfcc = LOWORD(lsel) == HIWORD(lsel) ? MF_GRAYED : MF_ENABLED;
    EnableMenuItem(GetSubMenu(hMenu, 1), M_CUT, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_COPY, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_CLEAR, mfcc);

    // check if the selectall is gray (that means the user has already
    // done select-all) and it the user has deselected - if so, time
    // to re-enable selectall menu.

    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if ((uSelState == MF_GRAYED) && (mfcc == MF_GRAYED))
    {
        EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
    }

    // paste is enabled if there is text in the clipboard

    if( OpenClipboard(hwnd) )
    {
        fPaste= IsClipboardFormatAvailable(CF_TEXT);
        CloseClipboard();
    }
    EnableMenuItem(GetSubMenu(hMenu, 1), M_PASTE, fPaste ? MF_ENABLED : MF_GRAYED);

    // enable Undo only if editcontrol says we can do it.

    fCanUndo = (BOOL) SendMessage(hwndEdit, EM_CANUNDO, 0, 0L);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_UNDO, fCanUndo ? MF_ENABLED : MF_GRAYED);

    // check the status bar

    CheckMenuItem(GetSubMenu(hMenu, 2), M_STATUSBAR, fStatus ? MF_CHECKED: MF_UNCHECKED );

    // check the word wrap item correctly

    CheckMenuItem(GetSubMenu(hMenu, 3), M_WW, fWrap ? MF_CHECKED : MF_UNCHECKED);


    //
    // Disable 'goto' if word wrap; there is no obvious relationship
    // between the MLE line number and what the user sees.
    // fixes windows bug# 206587 (10/18/2000)
    //
    EnableMenuItem( GetSubMenu(GetMenu(hwndNP),1), 
                    M_GOTO, 
                    fWrap ? MF_GRAYED : MF_ENABLED );

}


void NpWinIniChange(VOID)
{
   InitLocale();
}

/* ** Scan sz1 for merge spec.    If found, insert string sz2 at that point.
      Then append rest of sz1 NOTE! Merge spec guaranteed to be two chars.
      returns TRUE if it does a merge, false otherwise. */
BOOL MergeStrings(
    LPCTSTR szSrc,
    LPCTSTR szMerge,
    LPTSTR szDst)
{
    LPCTSTR pchSrc;
    LPTSTR  pchDst;

    pchSrc = szSrc;
    pchDst = szDst;

    /* Find merge spec if there is one. */
    while( *pchSrc != chMerge)
    {
        *pchDst++ = *pchSrc;

        /* If we reach end of string before merge spec, just return. */
        if( !*pchSrc++ )
        {
            return FALSE;
        }

    }

    /* If merge spec found, insert sz2 there. (check for null merge string */
    if (szMerge)
    {
        while (*szMerge)
            *pchDst++ = *szMerge++;
    }

    /* Jump over merge spec */
    pchSrc++,pchSrc++;

    /* Now append rest of Src String */
    while( *pchSrc );
    {
        *pchDst++ = *pchSrc++;
    }
    return TRUE;

}

/* ** Post a message box */
INT AlertBox(
    HWND    hwndParent,
    LPCTSTR szCaption,
    LPCTSTR szText1,
    LPCTSTR szText2,
    UINT     style)
{
    INT iResult;                      // result of function
    INT iAllocSize;                   // size needed for message
    LPTSTR pszMessage;                // combined message

    // Allocate a message buffer assuming there will be a merge.
    // If we cannot do the allocation, tell the user something
    // related to the original problem. (not the allocation failure)
    // Then pray that MessageBox can get enough memory to actually work.

    iAllocSize= (lstrlen(szText1) + (szText2 ? lstrlen(szText2) : 0) + 1 ) * sizeof(TCHAR);

    pszMessage= (TCHAR*) LocalAlloc( LPTR, iAllocSize );

    if( pszMessage )
    {
        MergeStrings( szText1, szText2, pszMessage );
        iResult= MessageBox( hwndParent, pszMessage, szCaption, style );
        LocalFree( (HLOCAL) pszMessage );
    }
    else
    {
        iResult= MessageBox( hwndParent, szText1, szCaption, style );
    }

    return( iResult );
}

// SignalCommDlgError
//
// If a common dialog error occurred, put up reasonable message box.
//
// returns: TRUE if error occurred, FALSE if no error.
//

typedef struct tagMAPERROR
{
    DWORD   rc;            // return code from CommDlgExtendedError()
    PTCHAR* ppszMsg;       // text of message pointer
} MAPERROR;

// errors not in this list get generic "common dialog error %x" message.
static TCHAR* szNull= TEXT("");

MAPERROR maperror[]=
{
    CDERR_DIALOGFAILURE,  &szErrSpace,
    CDERR_INITIALIZATION, &szCommDlgInitErr,
    CDERR_MEMLOCKFAILURE, &szPDIE,
    CDERR_LOADSTRFAILURE, &szErrSpace,
    CDERR_FINDRESFAILURE, &szErrSpace,
    PDERR_LOADDRVFAILURE, &szLoadDrvFail,
    PDERR_GETDEVMODEFAIL, &szErrSpace,
    PDERR_NODEFAULTPRN,   &szNull,          // don't report; common dialog does already
};

BOOL SignalCommDlgError(VOID)
{
    DWORD rc;               // return code
    TCHAR* pszMsg;          // message
    INT    i;
    TCHAR  szBuf[200];      // just for common dialog failure

    rc= CommDlgExtendedError();

    // no failure - just return

    if( rc == 0 )
    {
        return FALSE;
    }

    // some sort of error - pick up message

    pszMsg= NULL;
    for( i=0; i< sizeof(maperror)/sizeof(maperror[0]); i++ )
    {
        if( rc == maperror[i].rc )
        {
            pszMsg= *maperror[i].ppszMsg;
        }
    }

    // if no known mapping - tell user the actual return code
    // this may be a bit confusing, but rare hopefully.

    if( !pszMsg )
    {
        _sntprintf(szBuf, sizeof(szBuf)/sizeof(TCHAR) -1, szCommDlgErr, rc);
        pszMsg= szBuf;
    }

    // popup if there is any message to give user

    if( *pszMsg )
    {
        MessageBox(hwndNP, pszMsg, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONSTOP);
    }

    return TRUE;

}

// ReplaceSel
//
// Replace the current selection with string from FR struct
// if the current selection matches our search string.
//
// MLE will show selection if bView is true.
//


VOID ReplaceSel( BOOL bView )
{
    DWORD StartSel;    // start of selected text
    DWORD EndSel;      // end of selected text

    HANDLE hEText;
    TCHAR* pStart;
    DWORD  ReplaceWithLength;  // length of replacement string
    DWORD  FindWhatLength;

    ReplaceWithLength= lstrlen(FR.lpstrReplaceWith);
    FindWhatLength= lstrlen(FR.lpstrFindWhat);

    SendMessage( hwndEdit, EM_GETSEL, (WPARAM) &StartSel, (LPARAM) &EndSel );
    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return;
    }

    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return;
    }

    if(  (EndSel-StartSel) == FindWhatLength )
    {
       if( (fCase &&
            !_tcsncmp(  FR.lpstrFindWhat, pStart+StartSel, FindWhatLength) ) ||
           (!fCase &&
           ( 2 == CompareString(LOCALE_USER_DEFAULT,
                  NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                  FR.lpstrFindWhat, FindWhatLength,
                  pStart+StartSel,  FindWhatLength ) ) ) )
        {
            SendMessage( hwndEdit, EM_REPLACESEL,
                         TRUE, (LPARAM) FR.lpstrReplaceWith);
            SendMessage( hwndEdit, EM_SETSEL,
                         StartSel, StartSel+ReplaceWithLength );

            if( bView )
            {
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
            }
        }
    }

    LocalUnlock( hEText );
}

// GotoDlgProc
//
// Handle the Goto Dialog window processing
//
// Returns:
//
// 1 if successfull
// 0 if not (cancelled)
//
// Modifies global lGotoLine
//

const DWORD s_GotoHelpIDs[] = {
    IDC_GOTO, IDH_GOTO,
    0, 0
};

#define GOTOBUFSIZE 100
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    TCHAR szBuf[GOTOBUFSIZE];
    UINT LineNum;
    DWORD SelStart, SelEnd;

    switch (message)
    {
        //
        // initialize input field to size of file
        //
        case WM_INITDIALOG:
            SendMessage(hwndEdit,EM_GETSEL,(WPARAM) &SelStart,(WPARAM)&SelEnd);

            // the line numbers are 1 based instead 0 based. hence add 1.
            LineNum= (UINT)SendMessage( hwndEdit, EM_LINEFROMCHAR, SelStart, 0 ) + 1;
            wsprintf(szBuf, TEXT("%d"), LineNum);
            SetDlgItemText( hDlg, IDC_GOTO, szBuf );
            SetFocus( hDlg );
            return TRUE;
            break;

        // context sensitive help.
        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;

        case WM_COMMAND:

            switch (LOWORD(wParam))
            {
                UINT CharIndex;

                case IDC_GOTO:
                    return TRUE;
                    break;

                case IDOK:
                    GetDlgItemText( hDlg, IDC_GOTO, szBuf, GOTOBUFSIZE );

                    // convert all unicode numbers to range L'0' to L'9'

                    FoldString( MAP_FOLDDIGITS, szBuf, -1, szBuf, GOTOBUFSIZE);
                    lGotoLine= _ttol( szBuf );

                    //
                    // see if valid line number
                    //

                    CharIndex= (UINT)SendMessage( hwndEdit,
                                            EM_LINEINDEX,
                                            lGotoLine-1,
                                            0);
                    if( lGotoLine > 0 && CharIndex != -1 )
                    {
                        EndDialog(hDlg, 0);  // successfull
                        return TRUE;
                    }

                    //
                    // Invalid line number
                    // warning user and set to reasonable value
                    //

                    MessageBox( hDlg, szLineTooLarge, szLineError, MB_OK );

                    LineNum= (UINT)SendMessage( hwndEdit, EM_GETLINECOUNT, 0, 0 );
                    wsprintf(szBuf, TEXT("%d"), LineNum);
                    SetDlgItemText( hDlg, IDC_GOTO, szBuf );
                    SetFocus( hDlg );
                    break;

                case IDCANCEL :
                    EndDialog(hDlg, 1 );   // cancelled
                    return TRUE;
                    break;

                default:

                    break;

            } // switch (wParam)
            break;
    } // switch (message)

    return FALSE;     // Didn't process a message
}


INT_PTR CALLBACK SaveUnicodeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        int id;

        case WM_COMMAND :
            id = LOWORD(wParam);

            switch (id)
            {
                case IDC_SAVE_AS_UNICODE :
                case IDOK :
                case IDCANCEL :
                    EndDialog(hDlg, (int) LOWORD(wParam));
                    return TRUE;
            }
        break;
    }

    return FALSE;

    UNREFERENCED_PARAMETER( lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\npmlang.c ===
/*
 * MLANG wrapper functions
 *  Copyright (C) 2000 Microsoft Corporation
 */

#include "precomp.h"

#include "mlang.h"
#include "oleauto.h"


#define CP_USERDEF         50000
#define CP_ISCII_MIN       57002
#define CP_ISCII_MAC       57011

#define IsISCII(cp)  (((cp) >= CP_ISCII_MIN) && ((cp) <= CP_ISCII_MAC))


BOOL fInitializedCom;
IMultiLanguage3 *pml3;


BOOL FLoadMlang()
{
    HRESULT hr;

    if (!fInitializedCom)
    {
        hr = CoInitialize(NULL);

        if (FAILED(hr))
        {
            return(FALSE);
        }

        fInitializedCom = TRUE;
    }

    if (pml3 == NULL)
    {
        hr = CoCreateInstance(&CLSID_CMultiLanguage,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              &IID_IMultiLanguage3,
                              (void **) &pml3);

        if (FAILED(hr))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL FValidWin32CodePage(UINT cp)
{
    switch (cp)
    {
    case 50220 :
    case 50221 :
    case 50222 :
    case 50225 :
    case 50227 :
    // case 50229 :
    case 52936 :
        // We don't use WCToMB or MBToWC for these because there are
        // bugs in C_IS2022.DLL and MLANG has built support.

        return(FALSE);
    }

    return(IsValidCodePage(cp));
}


ConvertFromUnicodeMlang(UINT cp, BOOL fNoBestFit, BOOL fWriteEntities, LPCWSTR rgchUtf16, UINT cchUtf16, LPSTR rgchMbcs, UINT cchMbcs, BOOL* pfDefCharUsed)
{
    DWORD dwMode;
    UINT cchSrc;
    UINT cchDst;
    DWORD dwFlags;
    HRESULT hr;

    if (!FLoadMlang())
    {
        return(0);
    }

    dwMode = 0;
    cchSrc = cchUtf16;
    cchDst = cchMbcs;
    dwFlags = fWriteEntities ? MLCONVCHARF_NCR_ENTITIZE : MLCONVCHARF_USEDEFCHAR;

    if (fNoBestFit)
    {
        dwFlags |= MLCONVCHARF_NOBESTFITCHARS;
    }

    hr = pml3->lpVtbl->ConvertStringFromUnicodeEx(pml3,
                                                  &dwMode,
                                                  cp,
                                                  (WCHAR *) rgchUtf16,
                                                  &cchSrc,
                                                  rgchMbcs,
                                                  &cchDst,
                                                  dwFlags,
                                                  NULL);

    if (FAILED(hr))
    {
        return(0);
    }

    if (pfDefCharUsed != NULL)
    {
        *pfDefCharUsed = (hr == S_FALSE);
    }

    return(cchDst);
}


UINT ConvertFromUnicode(UINT cp, BOOL fNoBestFit, BOOL fWriteEntities, LPCWSTR rgchUtf16, UINT cchUtf16, LPSTR rgchMbcs, UINT cchMbcs, BOOL* pfDefCharUsed)
{
    UINT cch;

    if (cchUtf16 == 0)
    {
        return(0);
    }

    if (!fWriteEntities && FValidWin32CodePage(cp))
    {
        cch = WideCharToMultiByte(cp,
                                  fNoBestFit ? WC_NO_BEST_FIT_CHARS : 0,
                                  rgchUtf16,
                                  cchUtf16,
                                  rgchMbcs,
                                  cchMbcs,
                                  NULL,
                                  pfDefCharUsed);

        if (cch != 0)
        {
            return(cch);
        }

        // We retry with MLANG even when WCToMB supports the code page
        // because there are code pages when WCToMB may not support all
        // the features of the API.  I know this is the case for WCToMB
        // and the ISCII encodings.  We try again just for robustness.
    }

    cch = ConvertFromUnicodeMlang(cp, fNoBestFit, fWriteEntities, rgchUtf16, cchUtf16, rgchMbcs, cchMbcs, pfDefCharUsed);

#if DBG
    if (cch == 0)
    {
        DebugBreak();
    }
#endif

    return(cch);
}


UINT ConvertToUnicodeMlang(UINT cp, LPCSTR rgchMbcs, UINT cchMbcs, LPWSTR rgchUtf16, UINT cchUtf16)
{
    DWORD dwMode;
    UINT cchSrc;
    UINT cchDst;
    HRESULT hr;

    if (!FLoadMlang())
    {
        return(0);
    }

    dwMode = 0;
    cchSrc = cchMbcs;
    cchDst = cchUtf16;

    hr = pml3->lpVtbl->ConvertStringToUnicode(pml3,
                                              &dwMode,
                                              cp,
                                              (CHAR *) rgchMbcs,
                                              &cchSrc,
                                              rgchUtf16,
                                              &cchDst);

    if (FAILED(hr))
    {
        return(0);
    }

    return(cchDst);
}


UINT ConvertToUnicode(UINT cp, LPCSTR rgchMbcs, UINT cchMbcs, LPWSTR rgchUtf16, UINT cchUtf16)
{
    UINT cch;

    if (cchMbcs == 0)
    {
        return(0);
    }

    if (FValidWin32CodePage(cp))
    {
        cch = MultiByteToWideChar(cp, 0, rgchMbcs, cchMbcs, rgchUtf16, cchUtf16);

        if (cch != 0)
        {
            return(cch);
        }

        // We retry with MLANG even when MBToWC supports the code page
        // because there are code pages when MBToWC may not support all
        // the features of the API.  I know this is the case for WCToMB
        // and the ISCII encodings.  We try again just for robustness.
    }

    cch = ConvertToUnicodeMlang(cp, rgchMbcs, cchMbcs, rgchUtf16, cchUtf16);

#if DBG
    if (cch == 0)
    {
        DebugBreak();
    }
#endif

    return(cch);
}


BOOL FDetectEncodingA(LPCSTR rgch, UINT cch, UINT* pcp)
{
    INT cb;
    DetectEncodingInfo dei;
    INT cdei;
    HRESULT hr;

    if (!FLoadMlang())
    {
        return(0);
    }

    cb = (INT) cch;
    cdei = 1;

    hr = pml3->lpVtbl->DetectInputCodepage(pml3,
                                           0,
                                           0,
                                           (LPSTR) rgch,
                                           &cb,
                                           &dei,
                                           &cdei);

    if (hr != S_OK)
    {
        return(FALSE);
    }

    if (cdei == 0)
    {
        return(FALSE);
    }

    *pcp = dei.nCodePage;

    return(TRUE);
}


BOOL FLookupCodepageNameW(LPCWSTR rgchEncoding, UINT cch, UINT* pcp)
{
    BSTR bstrEncoding;
    MIMECSETINFO mci;
    HRESULT hr;

    if (cch == 0)
    {
        return(FALSE);
    }

    if (rgchEncoding[0] == L'_')
    {
        // Don't allow internal MLANG encodings

        return(FALSE);
    }

    if (!FLoadMlang())
    {
        return(FALSE);
    }

    bstrEncoding = SysAllocStringLen(rgchEncoding, cch);

    if (bstrEncoding == NULL)
    {
        return(FALSE);
    }

    hr = pml3->lpVtbl->GetCharsetInfo(pml3, bstrEncoding, &mci);

    SysFreeString(bstrEncoding);

    *pcp = mci.uiInternetEncoding;

    if (SUCCEEDED(hr))
    {
        return(TRUE);
    }

    return(FALSE);
}


BOOL FLookupCodepageNameA(LPCSTR rgchEncoding, UINT cch, UINT* pcp)
{
    WCHAR rgwchEncoding[MAX_MIMECSET_NAME];
    UINT ich;

    if (cch > MAX_MIMECSET_NAME)
    {
        return(FALSE);
    }

    for (ich = 0; ich < cch; ich++)
    {
        // Assume input is ASCII or Latin-1 and zero extend each character

        rgwchEncoding[ich] = (WCHAR) (BYTE) rgchEncoding[ich];
    }

    return(FLookupCodepageNameW(rgwchEncoding, cch, pcp));
}


BOOL FSupportWriteEntities(UINT cp)
{
    if (IsISCII(cp))
    {
        return(FALSE);
    }

    return(TRUE);
}


BOOL FValidateCodepage(HWND hwnd, UINT cp)
{
    HRESULT hr;

    if (IsValidCodePage(cp))
    {
        return(TRUE);
    }

    if ((cp == CP_USERDEF) || (cp == CP_AUTO) || (cp == CP_MACCP) || (cp == CP_THREAD_ACP))
    {
        return(FALSE);
    }

    if (!FLoadMlang())
    {
        return(FALSE);
    }

    hr = pml3->lpVtbl->ValidateCodePage(pml3, cp, hwnd);

    if (SUCCEEDED(hr) && (hr != S_FALSE))
    {
        return(TRUE);
    }

    return(FALSE);
}


void PopulateCodePages(HWND hWnd, BOOL fSelectEncoding, UINT cpSelect, UINT cpExtra)
{
    IEnumCodePage *pecp;
    UINT msg_ADDSTRING;
    UINT msg_SETITEMDATA;
    UINT msg_GETCOUNT;
    UINT msg_GETITEMDATA;
    UINT msg_SETCURSEL;
    HRESULT hr;
    LRESULT lr;

    if (!FLoadMlang())
    {
        return;
    }

    hr = pml3->lpVtbl->EnumCodePages(pml3,
                                     MIMECONTF_VALID_NLS | MIMECONTF_EXPORT,
                                     GetUserDefaultUILanguage(),
                                     &pecp);

    if (FAILED(hr))
    {
        return;
    }

    msg_ADDSTRING   = fSelectEncoding ? LB_ADDSTRING   : CB_ADDSTRING;
    msg_SETITEMDATA = fSelectEncoding ? LB_SETITEMDATA : CB_SETITEMDATA;
    msg_GETCOUNT    = fSelectEncoding ? LB_GETCOUNT    : CB_GETCOUNT;
    msg_GETITEMDATA = fSelectEncoding ? LB_GETITEMDATA : CB_GETITEMDATA;
    msg_SETCURSEL   = fSelectEncoding ? LB_SETCURSEL   : CB_SETCURSEL;

    for (;;)
    {
        MIMECPINFO mci;
        ULONG c;

        hr = pecp->lpVtbl->Next(pecp, 1, &mci, &c);

        if (FAILED(hr))
        {
            break;
        }

        if (c == 0)
        {
            break;
        }

        if (mci.uiCodePage == CP_USERDEF)
        {
            // Ignore "User Defined"

            continue;
        }

        if (!fSelectEncoding)
        {
            if (mci.uiCodePage == cpSelect)
            {
            }

            else if (mci.uiCodePage == cpExtra)
            {
            }

            else if (mci.uiCodePage == CP_UTF16)
            {
            }

            else if (mci.uiCodePage == 1252)
            {
            }

            else if (mci.uiCodePage == CP_UTF8)
            {
            }

            else if (mci.uiCodePage == g_cpDefault)
            {
            }

            else if (mci.uiCodePage == g_cpANSI)
            {
               // Don't filter ANSI codepage used by system
            }

            else if (mci.uiCodePage == g_cpOEM)
            {
               // Don't filter OEM codepage used by system
            }

            else if (mci.uiCodePage == g_cpUserLangANSI)
            {
               // Don't filter ANSI codepage associated with user's default UI language
            }

            else if (mci.uiCodePage == g_cpUserLangOEM)
            {
               // Don't filter OEM codepage associated with user's default UI language
            }

            else if (mci.uiCodePage == g_cpUserLocaleANSI)
            {
               // Don't filter ANSI codepage associated with user's default locale
            }

            else if (mci.uiCodePage == g_cpUserLocaleOEM)
            {
               // Don't filter OEM codepage associated with user's default locale
            }

            else if (mci.uiCodePage == g_cpKeyboardANSI)
            {
               // Don't filter ANSI codepage associated with the current active keyboard
            }

            else if (mci.uiCodePage == g_cpKeyboardOEM)
            {
               // Don't filter OEM codepage associated with the current active keyboard
            }

            else
            {
                continue;
            }
        }

        lr = SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_ADDSTRING, 0, (LPARAM) mci.wszDescription);

        if (lr < 0)
        {
            break;
        }

        SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_SETITEMDATA, (WPARAM) lr, (LPARAM) mci.uiCodePage);
    }

    pecp->lpVtbl->Release(pecp);

    lr = SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_GETCOUNT, 0, 0);

    while (--lr >= 0)
    {
        UINT cp = (UINT) SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_GETITEMDATA, (WPARAM) lr, 0);

        if (cp == cpSelect)
        {
            SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_SETCURSEL, (WPARAM) lr, 0);
            break;
        }
    }
}


void UnloadMlang()
{
    if (pml3 != NULL)
    {
        pml3->lpVtbl->Release(pml3);

        pml3 = NULL;
    }

    if (fInitializedCom)
    {
        CoUninitialize();

        fInitializedCom = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\npprint.c ===
/*
 * npprint.c -- Code for printing from notepad.
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#define NOMINMAX
#include "precomp.h"

//#define DBGPRINT

/* indices into chBuff */
#define LEFT   0
#define CENTER 1
#define RIGHT  2

INT     tabSize;                    /* Size of a tab for print device in device units*/
HWND    hAbortDlgWnd;
INT     fAbort;                     /* true if abort in progress      */
INT     yPrintChar;                 /* height of a character          */


RECT rtMargin;

/* left,center and right string for header or trailer */
#define MAXTITLE MAX_PATH
TCHAR chBuff[RIGHT+1][MAXTITLE];

/* date and time stuff for headers */
#define MAXDATE MAX_PATH
#define MAXTIME MAX_PATH
TCHAR szFormattedDate[MAXDATE]=TEXT("Y");   // formatted date (may be internationalized)
TCHAR szFormattedTime[MAXTIME]=TEXT("Y");   // formatted time (may be internaltionalized)
SYSTEMTIME PrintTime;                       // time we started printing


INT xPrintRes;          // printer resolution in x direction
INT yPrintRes;          // printer resolution in y direction
INT yPixInch;           // pixels/inch
INT xPhysRes;           // physical resolution x of paper
INT yPhysRes;           // physical resolution y of paper

INT xPhysOff;           // physical offset x
INT yPhysOff;           // physical offset y

INT dyTop;              // width of top border (pixels)
INT dyBottom;           // width of bottom border
INT dxLeft;             // width of left border
INT dxRight;            // width of right border

INT iPageNum;           // global page number currently being printed

/* define a type for NUM and the base */
typedef long NUM;
#define BASE 100L

/* converting in/out of fixed point */
#define  NumToShort(x,s)   (LOWORD(((x) + (s)) / BASE))
#define  NumRemToShort(x)  (LOWORD((x) % BASE))

/* rounding options for NumToShort */
#define  NUMFLOOR      0
#define  NUMROUND      (BASE/2)
#define  NUMCEILING    (BASE-1)

#define  ROUND(x)  NumToShort(x,NUMROUND)
#define  FLOOR(x)  NumToShort(x,NUMFLOOR)

/* Unit conversion */
#define  InchesToCM(x)  (((x) * 254L + 50) / 100)
#define  CMToInches(x)  (((x) * 100L + 127) / 254)

void     DestroyAbortWnd(void) ;
VOID     TranslateString(TCHAR *);

BOOL CALLBACK AbortProc(HDC hPrintDC, INT reserved)
{
    MSG msg;

    while( !fAbort && PeekMessage((LPMSG)&msg, NULL, 0, 0, TRUE) )
    {
       if( !hAbortDlgWnd || !IsDialogMessage( hAbortDlgWnd, (LPMSG)&msg ) )
       {
          TranslateMessage( (LPMSG)&msg );
          DispatchMessage( (LPMSG)&msg );
       }
    }
    return( !fAbort );

    UNREFERENCED_PARAMETER(hPrintDC);
    UNREFERENCED_PARAMETER(reserved);
}


INT_PTR CALLBACK AbortDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    static HMENU hSysMenu;

    switch( msg )
    {
       case WM_COMMAND:
          fAbort= TRUE;
          DestroyAbortWnd();
          return( TRUE );

       case WM_INITDIALOG:
          hSysMenu= GetSystemMenu( hwnd, FALSE );
          SetDlgItemText( hwnd, ID_FILENAME,
             FUntitled() ? szUntitled : PFileInPath(szFileOpened) );
          SetFocus( hwnd );
          return( TRUE );

       case WM_INITMENU:
          EnableMenuItem( hSysMenu, (WORD)SC_CLOSE, (DWORD)MF_GRAYED );
          return( TRUE );
    }
    return( FALSE );

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
}


/*
 * print out the translated header/footer string in proper position.
 * uses globals xPrintWidth, ...
 *
 * returns 1 if line was printed, otherwise 0.
 */

INT PrintHeaderFooter (HDC hDC, INT nHF)
{
    SIZE    Size;    // to compute the width of each string
    INT     yPos;    // y position to print
    INT     xPos;    // x position to print

    if( *chPageText[nHF] == 0 )   // see if anything to do
        return 0;                // we didn't print

    TranslateString( chPageText[nHF] );

    // figure out the y position we are printing

    if( nHF == HEADER )
        yPos= dyTop;
    else
        yPos= yPrintRes - dyBottom - yPrintChar;

    // print out the various strings
    // N.B. could overprint which seems ok for now

    if( *chBuff[LEFT] )     // left string
    {
        TextOut( hDC, dxLeft, yPos, chBuff[LEFT], lstrlen(chBuff[LEFT]) );
    }

    if( *chBuff[CENTER] )   // center string
    {
        GetTextExtentPoint32( hDC, chBuff[CENTER], lstrlen(chBuff[CENTER]), &Size );
        xPos= (xPrintRes-dxRight+dxLeft)/2 - Size.cx/2;
        TextOut( hDC, xPos, yPos, chBuff[CENTER], lstrlen(chBuff[CENTER]) );
    }

    if( *chBuff[RIGHT] )    // right string
    {
        GetTextExtentPoint32( hDC, chBuff[RIGHT], lstrlen(chBuff[RIGHT]), &Size );
        xPos= xPrintRes - dxRight - Size.cx;
        TextOut( hDC, xPos, yPos, chBuff[RIGHT], lstrlen(chBuff[RIGHT]) );
    }
    return 1;              // we did print something
}
/*
 * GetResolutions
 *
 * Gets printer resolutions.
 * sets globals: xPrintRes, yPrintRes, yPixInch
 *
 */

VOID GetResolutions(HDC hPrintDC)
{
    xPrintRes = GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes = GetDeviceCaps( hPrintDC, VERTRES );
    yPixInch  = GetDeviceCaps( hPrintDC, LOGPIXELSY );

    xPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALWIDTH );
    yPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALHEIGHT );

    xPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETX );
    yPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETY );
}

/* GetMoreText
 *
 * Gets the next line of text from the MLE, returning a pointer
 * to the beginning and just past the end.
 *
 * linenum    - index into MLE                                   (IN)
 * pStartText - start of MLE                                     (IN)
 * ppsStr     - pointer to where to put pointer to start of text (OUT)
 * ppEOL      - pointer to where to put pointer to just past EOL (OUT)
 *
 */

VOID GetMoreText( INT linenum, PTCHAR pStartText, PTCHAR* ppsStr, PTCHAR* ppEOL )
{
    INT Offset;        // offset in 'chars' into edit buffer
    INT nChars;        // number of chars in line

    Offset= (INT)SendMessage( hwndEdit, EM_LINEINDEX, linenum, 0 );

    nChars= (INT)SendMessage( hwndEdit, EM_LINELENGTH, Offset, 0 );

    *ppsStr= pStartText + Offset;

    *ppEOL= (pStartText+Offset) + nChars;
}

#ifdef DBGPRINT
TCHAR dbuf[100];
VOID ShowMargins( HDC hPrintDC )
{
    INT xPrintRes, yPrintRes;
    RECT rct;
    HBRUSH hBrush;

    xPrintRes= GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes= GetDeviceCaps( hPrintDC, VERTRES );
    hBrush= GetStockObject( BLACK_BRUSH );

    if ( hBrush )
    {
        SetRect( &rct, 0,0,xPrintRes-1, yPrintRes-1 );
        FrameRect( hPrintDC, &rct, hBrush );
        SetRect( &rct, dxLeft, dyTop, xPrintRes-dxRight, yPrintRes-dyBottom );
        FrameRect( hPrintDC, &rct, hBrush );
    }
}

VOID PrintLogFont( LOGFONT lf )
{
    wsprintf(dbuf,TEXT("lfHeight          %d\n"), lf.lfHeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWidth           %d\n"), lf.lfWidth         ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfEscapement      %d\n"), lf. lfEscapement   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOrientation     %d\n"), lf.lfOrientation   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWeight          %d\n"), lf.lfWeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfItalic          %d\n"), lf.lfItalic        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfUnderline       %d\n"), lf.lfUnderline     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfStrikeOut       %d\n"), lf.lfStrikeOut     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfCharSet         %d\n"), lf.lfCharSet       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOutPrecision    %d\n"), lf.lfOutPrecision  ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfClipPrecison    %d\n"), lf.lfClipPrecision ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfQuality         %d\n"), lf.lfQuality       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfPitchAndFamily  %d\n"), lf.lfPitchAndFamily); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfFaceName        %s\n"), lf.lfFaceName      ); ODS(dbuf);
}
#endif

// GetPrinterDCviaDialog
//
// Use the common dialog PrintDlgEx() function to get a printer DC to print to.
//
// Returns: valid HDC or INVALID_HANDLE_VALUE if error.
//

HDC GetPrinterDCviaDialog( VOID )
{
    PRINTDLGEX pdTemp;
    HDC hDC;
    HRESULT hRes;

    //
    // Get the page setup information
    //

    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
    }

    //
    // Initialize the dialog structure
    //

    ZeroMemory( &pdTemp, sizeof(pdTemp) );

    pdTemp.lStructSize= sizeof(pdTemp);

    pdTemp.hwndOwner= hwndNP;
    pdTemp.nStartPage= START_PAGE_GENERAL;
    pdTemp.Flags= PD_NOPAGENUMS  | PD_RETURNDC | PD_NOCURRENTPAGE |
                  PD_NOSELECTION | 0;

    // if use set printer in PageSetup, use it here too.

    if( g_PageSetupDlg.hDevMode )
    {
        pdTemp.hDevMode= g_PageSetupDlg.hDevMode;
    }

    if( g_PageSetupDlg.hDevNames )
    {
        pdTemp.hDevNames= g_PageSetupDlg.hDevNames;
    }


    //
    // let user select printer
    //

    hRes= PrintDlgEx( &pdTemp );

    //
    // get DC if valid return
    //

    hDC= INVALID_HANDLE_VALUE;

    if( hRes == S_OK )
    {
        if( (pdTemp.dwResultAction == PD_RESULT_PRINT) || (pdTemp.dwResultAction == PD_RESULT_APPLY) )
        {
            if( pdTemp.dwResultAction == PD_RESULT_PRINT )
            {
                hDC= pdTemp.hDC;
            }
            
            //
            // Get the page setup information for the printer selected in case it was
            // the first printer added by the user through notepad.
            //
            if( !g_PageSetupDlg.hDevMode ) 
            {
                g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
                PageSetupDlg(&g_PageSetupDlg);
                g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
            }

            // change devmode if user pressed print or apply
            g_PageSetupDlg.hDevMode= pdTemp.hDevMode;
            g_PageSetupDlg.hDevNames= pdTemp.hDevNames;
        }       
    }

    // FEATURE: free hDevNames

    return( hDC );
}

INT NpPrint( PRINT_DIALOG_TYPE type)
{
    HDC hPrintDC;

    SetCursor( hWaitCursor );

    switch( type )
    {
        case UseDialog:
            hPrintDC= GetPrinterDCviaDialog();
            break;
        case NoDialogNonDefault:
            hPrintDC= GetNonDefPrinterDC();
            break;
        case DoNotUseDialog:
        default:
            hPrintDC= GetPrinterDC();
            break;
    }

    if( hPrintDC == INVALID_HANDLE_VALUE )
    {
        SetCursor( hStdCursor );
        return( 0 );   // message already given
    }

    return( NpPrintGivenDC( hPrintDC ) );

}

INT NpPrintGivenDC( HDC hPrintDC )
{
    HANDLE     hText= NULL;          // handle to MLE text
    HFONT      hPrintFont= NULL;     // font to print with
    HANDLE     hPrevFont= NULL;      // previous font in hPrintDC

    BOOL       fPageStarted= FALSE;  // true if StartPage called for this page
    BOOL       fDocStarted=  FALSE;  // true if StartDoc called
    PTCHAR     pStartText= NULL;     // start of edit text (locked hText)
    TEXTMETRIC Metrics;
    TCHAR      msgbuf[MAX_PATH];     // Document name for tracking print job
    INT        nLinesPerPage;        // not inc. header and footer
    // iErr will contain the first error discovered ie it is sticky
    // This will be the value returned by this function.
    // It does not need to translate SP_* errors except for SP_ERROR which should be
    // GetLastError() right after it is first detected.
    INT        iErr=0;               // error return
    DOCINFO    DocInfo;
    LOGFONT    lfPrintFont;          // local version of FontStruct
    LCID       lcid;                 // locale id

    fAbort = FALSE;
    hAbortDlgWnd= NULL;

    SetCursor( hWaitCursor );

    GetResolutions( hPrintDC );

    // Get the time and date for use in the header or trailer.
    // We use the GetDateFormat and GetTimeFormat to get the
    // internationalized versions.

    GetLocalTime( &PrintTime );       // use local, not gmt

    lcid= GetUserDefaultLCID();

    GetDateFormat( lcid, DATE_LONGDATE, &PrintTime, NULL, szFormattedDate, MAXDATE );

    GetTimeFormat( lcid, 0,             &PrintTime, NULL, szFormattedTime, MAXTIME );


   /*
    * This part is to select the current font to the printer device.
    * We have to change the height because FontStruct was created
    * assuming the display.  Using the remembered pointsize, calculate
    * the new height.
    */

    lfPrintFont= FontStruct;                          // make local copy
    lfPrintFont.lfHeight= -(iPointSize*yPixInch)/(72*10);
    lfPrintFont.lfWidth= 0;

    //
    // convert margins to pixels
    // ptPaperSize is the physical paper size, not the printable area.
    // do the mapping in physical units
    //

    SetMapMode( hPrintDC, MM_ANISOTROPIC );

    SetViewportExtEx( hPrintDC,
                      xPhysRes,
                      yPhysRes,
                      NULL );

    SetWindowExtEx( hPrintDC,
                    g_PageSetupDlg.ptPaperSize.x,
                    g_PageSetupDlg.ptPaperSize.y,
                    NULL );

    rtMargin = g_PageSetupDlg.rtMargin;

    LPtoDP( hPrintDC, (LPPOINT) &rtMargin, 2 );

    SetMapMode( hPrintDC,MM_TEXT );    // restore to mm_text mode

    hPrintFont= CreateFontIndirect(&lfPrintFont);

    if( !hPrintFont )
    {
        goto ErrorExit;
    }

    hPrevFont= SelectObject( hPrintDC, hPrintFont );
    if( !hPrevFont )
    {
        goto ErrorExit;
    }

    SetBkMode( hPrintDC, TRANSPARENT );
    if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
    {
        goto ErrorExit;
    }

    // The font may not a scalable (say on a bubblejet printer)
    // In this case, just pick some font
    // For example, FixedSys 9 pt would be non-scalable

    if( !(Metrics.tmPitchAndFamily & (TMPF_VECTOR | TMPF_TRUETYPE )) )
    {
        // remove just created font

        hPrintFont= SelectObject( hPrintDC, hPrevFont );  // get old font
        DeleteObject( hPrintFont );

        memset( lfPrintFont.lfFaceName, 0, LF_FACESIZE*sizeof(TCHAR) );

        hPrintFont= CreateFontIndirect( &lfPrintFont );
        if( !hPrintFont )
        {
            goto ErrorExit;
        }

        hPrevFont= SelectObject( hPrintDC, hPrintFont );
        if( !hPrevFont )
        {
            goto ErrorExit;
        }

        if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
        {
            goto ErrorExit;
        }
    }
    yPrintChar= Metrics.tmHeight+Metrics.tmExternalLeading;  /* the height */

    tabSize = Metrics.tmAveCharWidth * 8; /* 8 ave char width pixels for tabs */

    // compute margins in pixels

    dxLeft=   max(rtMargin.left - xPhysOff,0);
    dxRight=  max(rtMargin.right  - (xPhysRes - xPrintRes - xPhysOff), 0 );
    dyTop=    max(rtMargin.top  - yPhysOff,0);
    dyBottom= max(rtMargin.bottom - (yPhysRes - yPrintRes - yPhysOff), 0 );

#ifdef DBGPRINT
    {
        TCHAR dbuf[100];
        RECT rt= g_PageSetupDlg.rtMargin;
        POINT pt;

        wsprintf(dbuf,TEXT("Print pOffx %d  pOffy %d\n"),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETX),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETY));
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALWIDTH: %d\n"), xPhysRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("HORZRES: %d\n"),xPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALOFFSETX: %d\n"),xPhysOff);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("LOGPIXELSX: %d\n"),
                 GetDeviceCaps(hPrintDC,LOGPIXELSX));
        ODS(dbuf);

        GetViewportOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Viewport org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        GetWindowOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Window org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PrintRes x: %d  y: %d\n"),xPrintRes, yPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PaperSize  x: %d  y: %d\n"),
                 g_PageSetupDlg.ptPaperSize.x,
                 g_PageSetupDlg.ptPaperSize.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("unit margins:  l: %d  r: %d  t: %d  b: %d\n"),
                 rt.left, rt.right, rt.top, rt.bottom);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("pixel margins: l: %d  r: %d  t: %d  b: %d\n"),
                 rtMargin.left, rtMargin.right, rtMargin.top, rtMargin.bottom);
        ODS(dbuf);

        wsprintf(dbuf,TEXT("dxLeft %d  dxRight %d\n"),dxLeft,dxRight);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("dyTop %d  dyBot %d\n"),dyTop,dyBottom);
        ODS(dbuf);
    }
#endif


    /* Number of lines on a page with margins  */
    /* two lines are used by header and footer */
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrintChar);

    if( *chPageText[HEADER] )
        nLinesPerPage--;
    if( *chPageText[FOOTER] )
        nLinesPerPage--;


    /*
    ** There was a bug in NT once where a printer driver would
    ** return a font that was larger than the page size which
    ** would then cause Notepad to constantly print blank pages
    ** To keep from doing this we check to see if we can fit ANYTHING
    ** on a page, if not then there is a problem so quit.  MarkRi 8/92
    */
    if( nLinesPerPage <= 0 )
    {
FontTooBig:
        MessageBox( hwndNP, szFontTooBig, szNN, MB_APPLMODAL | MB_OK | MB_ICONWARNING );

        SetLastError(0);          // no error

ErrorExit:
        iErr= GetLastError();     // remember the first error

ExitWithThisError:                // preserve iErr (return SP_* errors)

        if( hPrevFont )
        {
            SelectObject( hPrintDC, hPrevFont );
            DeleteObject( hPrintFont );
        }

        if( pStartText )          // were able to lock hText
            LocalUnlock( hText );

        if( fPageStarted )
        {
            if( EndPage( hPrintDC ) <= 0 )
            {
                // if iErr not already set then set it to the new error code.
                if( iErr == 0 )
                {
                    iErr= GetLastError();
                }
       
            }
        }    

        if( fDocStarted )
        {
            if( fAbort ) {
               AbortDoc( hPrintDC );
            }
            else {
               if( EndDoc( hPrintDC ) <= 0 )
               {
                   // if iErr not already set then set it to the new error code.
                   if (iErr == 0)
                   {
                       iErr= GetLastError();
                   }
               }
            }
        }    

        DeleteDC( hPrintDC );

        DestroyAbortWnd();

        SetCursor( hStdCursor );

        if (!fAbort)
        {
            return( iErr );
        }
        else
        {
            return( SP_USERABORT );
        }
    }



    if( (iErr= SetAbortProc (hPrintDC, AbortProc)) < 0 )
    {
        goto ExitWithThisError;
    }

    // get printer to MLE text
    hText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hText )
    {
        goto ErrorExit;
    }
    pStartText= LocalLock( hText );
    if( !pStartText )
    {
        goto ErrorExit;
    }

    GetWindowText( hwndNP, msgbuf, CharSizeOf(msgbuf) );

    EnableWindow( hwndNP, FALSE );    // Disable window to prevent reentrancy

    hAbortDlgWnd= CreateDialog(         hInstanceNP,
                              (LPTSTR)  MAKEINTRESOURCE(IDD_ABORTPRINT),
                                        hwndNP,
                                        AbortDlgProc);

    if( !hAbortDlgWnd )
    {
        goto ErrorExit;
    }

    DocInfo.cbSize= sizeof(DOCINFO);
    DocInfo.lpszDocName= msgbuf;
    DocInfo.lpszOutput= NULL;
    DocInfo.lpszDatatype= NULL; // Type of data used to record print job
    DocInfo.fwType= 0; // not DI_APPBANDING

    SetLastError(0);      // clear error so it reflects errors in the future

    if( StartDoc( hPrintDC, &DocInfo ) <= 0 )
    {
        iErr = GetLastError();
        goto ExitWithThisError;
    }
    fDocStarted= TRUE;


    // Basicly, this is just a loop surrounding the DrawTextEx API.
    // We have to calculate the printable area which will not include
    // the header and footer area.
    {
    INT iTextLeft;        // amount of text left to print
    INT iSta;              // status
    UINT dwDTFormat;       // drawtext flags
    DRAWTEXTPARAMS dtParm; // drawtext control
    RECT rect;             // rectangle to draw in
    UINT dwDTRigh = 0;     // drawtext flags (RTL)

    iPageNum= 1;
    fPageStarted= FALSE;

    // calculate the size of the printable area for the text
    // not including the header and footer

    ZeroMemory( &rect, sizeof(rect) );

    rect.left= dxLeft; rect.right= xPrintRes-dxRight;
    rect.top=  dyTop;  rect.bottom= yPrintRes-dyBottom;

    if( *chPageText[HEADER] != 0 )
    {
        rect.top += yPrintChar;
    }

    if( *chPageText[FOOTER] != 0 )
    {
        rect.bottom -= yPrintChar;
    }

    iTextLeft= lstrlen(pStartText);

    //Get the edit control direction.
    if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING)
        dwDTRigh = DT_RIGHT | DT_RTLREADING;


    while(  !fAbort && (iTextLeft>0) )
    {
        #define MAXSTATUS 100
        TCHAR szPagePrinting[MAXSTATUS+1];

        // update abort dialog box to inform user where we are in the printing
        _sntprintf( szPagePrinting, MAXSTATUS, szCurrentPage, iPageNum ); 
        SetDlgItemText( hAbortDlgWnd, ID_PAGENUMBER, szPagePrinting );

        PrintHeaderFooter( hPrintDC, HEADER );

        ZeroMemory( &dtParm, sizeof(dtParm) );

        dtParm.cbSize= sizeof(dtParm);
        dtParm.iTabLength= tabSize;

        dwDTFormat= DT_EDITCONTROL | DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX |
                    DT_WORDBREAK | dwDTRigh | 0;

        if( StartPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();            
            goto ExitWithThisError;
        }
        fPageStarted= TRUE;

        #ifdef DBGPRINT
        ShowMargins(hPrintDC);
        #endif

        /* Ignore errors in printing.  EndPage or StartPage will find them */
        iSta= DrawTextEx( hPrintDC,
                          pStartText,
                          iTextLeft,
                          &rect,
                          dwDTFormat,
                          &dtParm);

        PrintHeaderFooter( hPrintDC, FOOTER );

        if( EndPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();            
            goto ExitWithThisError;
        }
        fPageStarted= FALSE;

        iPageNum++;

        // if we can't print a single character (too big perhaps)
        // just bail now.
        if( dtParm.uiLengthDrawn == 0 )
        {
            goto FontTooBig;
        }

        pStartText += dtParm.uiLengthDrawn;
        iTextLeft  -= dtParm.uiLengthDrawn;

    }


    }

    iErr=0;        // no errors
    goto ExitWithThisError;

}


VOID DestroyAbortWnd (void)
{
    EnableWindow(hwndNP, TRUE);
    DestroyWindow(hAbortDlgWnd);
    hAbortDlgWnd = NULL;
}



const DWORD s_PageSetupHelpIDs[] = {
    ID_HEADER_LABEL,       IDH_PAGE_HEADER,
    ID_HEADER,             IDH_PAGE_HEADER,
    ID_FOOTER_LABEL,       IDH_PAGE_FOOTER,
    ID_FOOTER,             IDH_PAGE_FOOTER,
    0, 0
};

/*******************************************************************************
*
*  PageSetupHookProc
*
*  DESCRIPTION:
*     Callback procedure for the PageSetup common dialog box.
*
*  PARAMETERS:
*     hWnd, handle of PageSetup window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

UINT_PTR CALLBACK PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    INT   id;    /* ID of dialog edit controls */
    POINT pt;

    switch (Message)
    {

        case WM_INITDIALOG:
            for (id = ID_HEADER; id <= ID_FOOTER; id++)
            {
                SendDlgItemMessage(hWnd, id, EM_LIMITTEXT, PT_LEN-1, 0L);
                SetDlgItemText(hWnd, id, chPageText[id - ID_HEADER]);
            }

            SendDlgItemMessage(hWnd, ID_HEADER, EM_SETSEL, 0,
                               MAKELONG(0, PT_LEN-1));
            return TRUE;

        case WM_DESTROY:
            //  We don't know if the user hit OK or Cancel, so we don't
            //  want to replace our real copies until we know!  We _should_ get
            //  a notification from the common dialog code!
            for( id = ID_HEADER; id <= ID_FOOTER; id++ )
            {
                GetDlgItemText(hWnd, id, chPageTextTemp[id - ID_HEADER],PT_LEN);
            }
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {

                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);

            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

    }

    return FALSE;

}

/***************************************************************************
 * VOID TranslateString(TCHAR *src)
 *
 * purpose:
 *    translate a header/footer strings
 *
 * supports the following:
 *
 *    &&    insert a & char
 *    &f    current file name or (untitled)
 *    &d    date in Day Month Year
 *    &t    time
 *    &p    page number
 *    &p+num  set first page number to num
 *
 * Alignment:
 *    &l, &c, &r for left, center, right
 *
 * params:
 *    IN/OUT  src     this is the string to translate
 *
 *
 * used by:
 *    Header Footer stuff
 *
 * uses:
 *    lots of c lib stuff
 *
 ***************************************************************************/


VOID TranslateString (TCHAR * src)
{
    // File, Page, Time, Date, Center, Right, Left
    // these *never* change so don't put into resources for localizers
    TCHAR        letters[15]=TEXT("fFpPtTdDcCrRlL");
    TCHAR        buf[MAX_PATH];
    INT          page;
    INT          nAlign=CENTER;    // current string to add chars to
    INT          nIndex[RIGHT+1];  // current lengths of (left,center,right)
    struct tm   *newtime;
    time_t       long_time;
    INT          iLen;             // length of strings

    nIndex[LEFT]   = 0;
    nIndex[CENTER] = 0;
    nIndex[RIGHT]  = 0;

    /* Get the time we need in case we use &t. */
    time (&long_time);
    newtime = localtime (&long_time);


    while (*src)   /* look at all of source */
    {
        while (*src && *src != TEXT('&'))
        {
            chBuff[nAlign][nIndex[nAlign]] = *src++;
            nIndex[nAlign] += 1;
        }

        if (*src == TEXT('&'))   /* is it the escape char? */
        {
            src++;

            if (*src == letters[0] || *src == letters[1])
            {                      /* &f file name (no path) */
                if (!FUntitled())
                {
                    GetFileTitle(szFileOpened, buf, CharSizeOf(buf));
                }
                else
                {
                    lstrcpy(buf, szUntitled);
                }

                /* Copy to the currently aligned string. */
                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );

                    /* Update insertion position. */
                    nIndex[nAlign] += lstrlen (buf);
                }

            }
            else if (*src == letters[2] || *src == letters[3])  /* &P or &P+num page */
            {
                src++;
                page = 0;
                if (*src == TEXT('+'))       /* &p+num case */
                {
                    src++;
                    while (_istdigit(*src))
                    {
                        /* Convert to int on-the-fly*/
                        page = (10*page) + (*src) - TEXT('0');
                        src++;
                    }
                }

                wsprintf( buf, TEXT("%d"), iPageNum+page );  // convert to chars

                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );
                    nIndex[nAlign] += lstrlen (buf);
                }
                src--;
            }
            else if (*src == letters[4] || *src == letters[5])   /* &t time */
            {
                iLen= lstrlen( szFormattedTime );

                /* extract time */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedTime, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == letters[6] || *src == letters[7])   /* &d date */
            {
                iLen= lstrlen( szFormattedDate );

                /* extract day month day */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedDate, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == TEXT('&'))       /* quote a single & */
            {
                if( nIndex[nAlign] + 1 < MAXTITLE )
                {
                    chBuff[nAlign][nIndex[nAlign]] = TEXT('&');
                    nIndex[nAlign] += 1;
                }
            }
            /* Set the alignment for whichever has last occured. */
            else if (*src == letters[8] || *src == letters[9])   /* &c center */
                nAlign=CENTER;
            else if (*src == letters[10] || *src == letters[11]) /* &r right */
                nAlign=RIGHT;
            else if (*src == letters[12] || *src == letters[13]) /* &d date */
                nAlign=LEFT;

            src++;
        }
     }
     /* Make sure all strings are null-terminated. */
     for (nAlign= LEFT; nAlign <= RIGHT ; nAlign++)
        chBuff[nAlign][nIndex[nAlign]] = (TCHAR) 0;

}

/* GetPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */

HANDLE GetPrinterDC (VOID)
{
    LPDEVMODE lpDevMode;
    LPDEVNAMES lpDevNames;
    HDC hDC;


    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;
    }

    if( !g_PageSetupDlg.hDevNames )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONWARNING);
        return INVALID_HANDLE_VALUE;
    }

    lpDevNames= (LPDEVNAMES) GlobalLock (g_PageSetupDlg.hDevNames);


    lpDevMode= NULL;

    if( g_PageSetupDlg.hDevMode )
       lpDevMode= (LPDEVMODE) GlobalLock( g_PageSetupDlg.hDevMode );

    /*  For pre 3.0 Drivers,hDevMode will be null  from Commdlg so lpDevMode
     *  will be NULL after GlobalLock()
     */

    /* The lpszOutput name is null so CreateDC will use the current setting
     * from PrintMan.
     */

    hDC= CreateDC (((LPTSTR)lpDevNames)+lpDevNames->wDriverOffset,
                      ((LPTSTR)lpDevNames)+lpDevNames->wDeviceOffset,
                      NULL,
                      lpDevMode);

    GlobalUnlock( g_PageSetupDlg.hDevNames );

    if( g_PageSetupDlg.hDevMode )
        GlobalUnlock( g_PageSetupDlg.hDevMode );


    if( hDC == NULL )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONWARNING);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* GetNonDefPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */
/*                        using the name of the Printer server */

HANDLE GetNonDefPrinterDC (VOID)
{
    HDC     hDC;
    HANDLE  hPrinter;
    DWORD   dwBuf;
    DRIVER_INFO_1  *di1;



    // open the printer and retrieve the driver name.
    if (!OpenPrinter(szPrinterName, &hPrinter, NULL))
    {
        return INVALID_HANDLE_VALUE;
    }

    // get the buffer size.
    GetPrinterDriver(hPrinter, NULL, 1, NULL, 0, &dwBuf);
    di1 = (DRIVER_INFO_1  *) LocalAlloc(LPTR, dwBuf);
    if (!di1)
    {
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    if (!GetPrinterDriver(hPrinter, NULL, 1, (LPBYTE) di1, dwBuf, &dwBuf))
    {
        LocalFree(di1);
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    // Initialize the PageSetup dlg to default values.
    // using default printer's value for another printer !!
    g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
    PageSetupDlg(&g_PageSetupDlg);
    g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;

    // create printer dc with default initialization.
    hDC= CreateDC (di1->pName, szPrinterName, NULL, NULL);

    // cleanup.
    LocalFree(di1);
    ClosePrinter(hPrinter);

    if( hDC == NULL )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONWARNING);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* PrintIt() - print the file, giving popup if some error */

void PrintIt(PRINT_DIALOG_TYPE type)
{
    INT iError;
    TCHAR* szMsg= NULL;
    TCHAR  msg[400];       // message info on error

    /* print the file */

    iError= NpPrint( type );

    if(( iError != 0) &&
       ( iError != SP_APPABORT )     &&
       ( iError != SP_USERABORT ) )
    {
        // translate any known spooler errors
        if( iError == SP_OUTOFDISK   ) iError= ERROR_DISK_FULL;
        if( iError == SP_OUTOFMEMORY ) iError= ERROR_OUTOFMEMORY;
        if( iError == SP_ERROR       ) iError= GetLastError();
        /* SP_NOTREPORTED not handled.  Does it happen? */


        //
        // iError may be 0 because the user aborted the printing.
        // Just ignore.
        //

        if( iError == 0 ) return;

        // Get system to give reasonable error message
        // These will also be internationalized.

        if(!FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           iError,
                           GetUserDefaultLangID(),
                           msg,  // where message will end up
                           CharSizeOf(msg), NULL ) )
        {
            szMsg= szCP;   // couldn't get system to say; give generic msg
        }
        else
        {
            szMsg= msg;
        }

        AlertBox( hwndNP, szNN, szMsg, SzTitle(),
                  MB_APPLMODAL | MB_OK | MB_ICONWARNING);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\npmisc.c ===
/*
 * misc notepad functions
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#include "precomp.h"

BOOL fCase = FALSE;         // Flag specifying case sensitive search 
BOOL fReverse = FALSE;      // Flag for direction of search 

extern HWND hDlgFind;       // handle to modeless FindText window 

LPTSTR ReverseScan(
    LPTSTR lpSource,
    LPTSTR lpLast,
    LPTSTR lpSearch,
    BOOL fCaseSensitive )
{
   TCHAR cLastCharU;
   TCHAR cLastCharL;
   INT   iLen;

   cLastCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cLastCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   iLen = lstrlen(lpSearch);

   if (!lpLast)
      lpLast = lpSource + lstrlen(lpSource);

   do
   {
      if (lpLast == lpSource)
         return NULL;

      --lpLast;

      if (fCaseSensitive)
      {
         if (*lpLast != *lpSearch)
            continue;
      }
      else
      {
           if( !( *lpLast == cLastCharU || *lpLast == cLastCharL ) )
            continue;
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpLast, lpSearch, iLen))
            break;
      }
      else
      {
         //
         // compare whole string using locale specific comparison.
         // do not use C runtime version since it may be wrong.
         //

         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpLast,   iLen,
                    lpSearch, iLen) )
            break;
      }
   } while (TRUE);

   return lpLast;
}

LPTSTR ForwardScan(LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive )
{
   TCHAR cFirstCharU;
   TCHAR cFirstCharL;
   int iLen = lstrlen(lpSearch);

   cFirstCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cFirstCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   while (*lpSource)
   {
      if (fCaseSensitive)
      {
         if (*lpSource != *lpSearch)
         {
            lpSource++;
            continue;
         }
      }
      else
      {
         if( !( *lpSource == cFirstCharU || *lpSource == cFirstCharL ) )
         {
            lpSource++;
            continue;
         }
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpSource, lpSearch, iLen))
            break;
      }
      else
      {
         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpSource, iLen,
                    lpSearch, iLen) )
            break;
      }

      lpSource++;
   }

   return *lpSource ? lpSource : NULL;
}


// search forward or backward in the edit control text for the given pattern
// It is the responsibility of the caller to set the cursor

BOOL Search (TCHAR * szKey)
{
    BOOL      bStatus= FALSE;
    TCHAR   * pStart, *pMatch;
    DWORD     StartIndex, LineNum, EndIndex;
    DWORD     SelStart, SelEnd, i;
    HANDLE    hEText;           // handle to edit text
    UINT      uSelState;
    HMENU     hMenu;
    BOOL      bSelectAll = FALSE;


    if (!*szKey)
        return( bStatus );

    SendMessage(hwndEdit, EM_GETSEL, (WPARAM)&SelStart, (LPARAM)&SelEnd);


    // when we finish the search, we highlight the text found, and continue 
    // the search after the end of the highlighted position (in forward 
    // case) or from the begining of the highlighted position in the reverse
    // direction (in reverse case). this would break if the user has 
    // selected all text. this hack would take care of it. (this is consistent
    // with VC editors' search too.

    hMenu = GetMenu(hwndNP);
    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if (uSelState == MF_GRAYED)
    {
        bSelectAll = TRUE;
        SelStart = SelEnd =0;
    }


    //
    // get pointer to edit control text to search
    //

    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return( bStatus );
    }
    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return( bStatus );
    }

    if (fReverse)
    {
        // Get current line number 
        LineNum= (DWORD)SendMessage(hwndEdit, EM_LINEFROMCHAR, SelStart, 0);
        // Get index to start of the line
        StartIndex= (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, LineNum, 0);
        // Set upper limit for search text
        EndIndex= SelStart;
        pMatch= NULL;

        // Search line by line, from LineNum to 0
        i = LineNum;
        while (TRUE)
        {
            pMatch= ReverseScan(pStart+StartIndex,pStart+EndIndex,szKey,fCase);
            if (pMatch)
               break;
            // current StartIndex is the upper limit for the next search 
            EndIndex= StartIndex;

            if (i)
            {
                // Get start of the next line
                i-- ;
                StartIndex = (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, i, 0);
            }
            else
               break ;
        }
    }
    else
    {
            pMatch= ForwardScan(pStart+SelEnd, szKey, fCase);
    }

    LocalUnlock(hEText);

    if (pMatch == NULL)
    {
        //
        // alert user on not finding any text unless it is replace all
        //
        if( !(FR.Flags & FR_REPLACEALL) )
        {
            HANDLE hPrevCursor= SetCursor( hStdCursor );
            AlertBox( hDlgFind ? hDlgFind : hwndNP,
                      szNN,
                      szCFS,
                      szSearch,
                      MB_APPLMODAL | MB_OK | MB_ICONINFORMATION);
            SetCursor( hPrevCursor );
        }
    }
    else
    {
        SelStart = (DWORD)(pMatch - pStart);
        SendMessage( hwndEdit, EM_SETSEL, SelStart, SelStart+lstrlen(szKey));

        // since we are selecting the found text, enable SelectAll again.
        if (bSelectAll)
        {
            EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
        }

        //
        // show the selected text unless it is replace all
        //

        if( !(FR.Flags & FR_REPLACEALL) )
        {
            SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
        }
        bStatus= TRUE;   // found
    }

    return( bStatus );
}

// Recreate notepad edit window, get text from old window and put in new window. 
// Called when user changes style from wrap on/off 
//
// Called with the style of the new window
//

BOOL NpReCreate( long style )
{
    RECT    rcT1;
    HWND    hwndT1;
    HANDLE  hT1;
    int     cchTextNew;
    TCHAR*  pchText;
    BOOL    fWrapIsOn = ((style & WS_HSCROLL) != 0);
    HCURSOR hPrevCursor;
    BOOL    bModified;     // modify flag from old edit buffer

    // if wordwrap, remove soft carriage returns 

    hPrevCursor= SetCursor( hWaitCursor );     // this may take some time...
    if( fWrapIsOn ) 
    {
        GotoAndScrollInView(1);  // get around MLE bug

        SendMessage(hwndEdit, EM_FMTLINES, FALSE, 0L);
    }

    bModified= (SendMessage( hwndEdit, EM_GETMODIFY, 0,0 ) != 0);

    cchTextNew= (int)SendMessage( hwndEdit, WM_GETTEXTLENGTH, 0, 0L );
    hT1= LocalAlloc( LMEM_MOVEABLE, ByteCountOf(cchTextNew + 1) );
    if( !hT1 )
    {
        // failed, restore wordwrap; insert soft carriage returns
        if( fWrapIsOn )
        {
            SendMessage(hwndEdit, EM_FMTLINES, TRUE, 0L);
        }
        SetCursor( hPrevCursor );
        return FALSE;
    }

    GetClientRect( hwndNP, (LPRECT)&rcT1 );

    //
    // save the current edit control text.
    //

    pchText= LocalLock (hT1);
    SendMessage( hwndEdit, WM_GETTEXT, cchTextNew+1, (LPARAM)pchText );
    hwndT1= CreateWindowEx( WS_EX_CLIENTEDGE,
        TEXT("Edit"),
        TEXT(""), // pchText
        style,
        0,
        0,
        rcT1.right,
        rcT1.bottom,
        hwndNP,
        (HMENU)ID_EDIT,
        hInstanceNP, NULL );
    if( !hwndT1 )
    {
        SetCursor( hPrevCursor );
        if( fWrapIsOn )      // restore wordwrap
        {
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        }
        LocalUnlock(hT1);
        LocalFree(hT1);
        return FALSE;
    }

    //
    // The user can "add" styles to the edit window after it is
    // created (like WS_EX_RTLREADING) when language packs are installed.
    // Preserve these styles when changing the word wrap.
    //

    SetWindowLong( hwndT1 ,
                   GWL_EXSTYLE ,
                   GetWindowLong( hwndEdit , GWL_EXSTYLE )|WS_EX_CLIENTEDGE ) ;

    // Set font before set text to save time calculating
    SendMessage( hwndT1, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0) );

    if (!SendMessage (hwndT1, WM_SETTEXT, 0, (LPARAM) pchText))
    {
        SetCursor( hPrevCursor );
        if( fWrapIsOn )   // restore wordwrap
        {
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        }
        DestroyWindow( hwndT1 );
        LocalUnlock( hT1 );
        LocalFree( hT1 );
        return FALSE;
    }
    LocalUnlock(hT1);


    DestroyWindow( hwndEdit );     // out with the old
    hwndEdit = hwndT1;             // in with the new

    // free the earlier allocated memory in hEdit

    if (hEdit)
        LocalFree(hEdit);

    hEdit = hT1;

    // limit text for safety's sake.

    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L );

    ShowWindow(hwndNP, SW_SHOW);
    SendMessage( hwndEdit, EM_SETMODIFY, bModified, 0L );
    SetFocus(hwndEdit);

    SetCursor( hPrevCursor );   // restore cursor

    // redraw the status bar

    if( fStatus )
    {
        RECT rcClient;
        GetClientRect(hwndNP, &rcClient);
        NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
        ShowWindow( hwndStatus, SW_SHOW );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\precomp.h ===
#define WIN31
#include "notepad.h"
#include <shellapi.h>
#include <cderr.h>
#include <winnlsp.h>   // for NORM_STOP_ON_NULL

#include <string.h>

//
// We need to define BYTE_ORDER_MARK, and figure
// out how to get the system to tell us a font is a 
// unicode font, and then we can eliminate uconvert.h
//
#include "uconvert.h"
#include "uniconv.h"
#include <stdio.h>

#include <stdlib.h>

#include <ctype.h>
#include <time.h>
#include <winspool.h>
#include "dlgs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\nputf.c ===
/*
 * nputf.c  - Routines for utf text processing for notepad
 *
 * Copyright (C) 1998-2000 Microsoft Corporation
 */

#include "precomp.h"


/* IsTextUTF8
 *
 * UTF-8 is the encoding of Unicode based on Internet Society RFC2279
 * ( See http://www.cis.ohio-state.edu/htbin/rfc/rfc2279.html )
 *
 * Basicly:
 * 0000 0000-0000 007F - 0xxxxxxx  (ascii converts to 1 octet!)
 * 0000 0080-0000 07FF - 110xxxxx 10xxxxxx    ( 2 octet format)
 * 0000 0800-0000 FFFF - 1110xxxx 10xxxxxx 10xxxxxx (3 octet format)
 * (this keeps going for 32 bit unicode) 
 * 
 *
 * Return value:  TRUE, if the text is in UTF-8 format.
 *                FALSE, if the text is not in UTF-8 format.
 *                We will also return FALSE is it is only 7-bit ascii, so the right code page
 *                will be used.
 *
 *                Actually for 7 bit ascii, it doesn't matter which code page we use, but
 *                notepad will remember that it is utf-8 and "save" or "save as" will store
 *                the file with a UTF-8 BOM.  Not cool.
 */


INT IsTextUTF8( LPSTR lpstrInputStream, INT iLen )
{
    INT   i;
    DWORD cOctets;  // octets to go in this UTF-8 encoded character
    UCHAR chr;
    BOOL  bAllAscii= TRUE;

    cOctets= 0;
    for( i=0; i < iLen; i++ ) {
        chr= *(lpstrInputStream+i);

        if( (chr&0x80) != 0 ) bAllAscii= FALSE;

        if( cOctets == 0 )  {
            //
            // 7 bit ascii after 7 bit ascii is just fine.  Handle start of encoding case.
            //
            if( chr >= 0x80 ) {  
               //
               // count of the leading 1 bits is the number of characters encoded
               //
               do {
                  chr <<= 1;
                  cOctets++;
               }
               while( (chr&0x80) != 0 );

               cOctets--;                        // count includes this character
               if( cOctets == 0 ) return FALSE;  // must start with 11xxxxxx
            }
        }
        else {
            // non-leading bytes must start as 10xxxxxx
            if( (chr&0xC0) != 0x80 ) {
                return FALSE;
            }
            cOctets--;                           // processed another octet in encoding
        }
    }

    //
    // End of text.  Check for consistency.
    //

    if( cOctets > 0 ) {   // anything left over at the end is an error
        return FALSE;
    }

    if( bAllAscii ) {     // Not utf-8 if all ascii.  Forces caller to use code pages for conversion
        return FALSE;
    }

    return TRUE;
}


/* IsInputTextUnicode
 * Verify if the input stream is in Unicode format.
 *
 * Return value:  TRUE, if the text is in Unicode format.
 *
 * 29 June 1998          
 */


INT IsInputTextUnicode  (LPSTR lpstrInputStream, INT iLen)
{
    INT  iResult= ~0; // turn on IS_TEXT_UNICODE_DBCS_LEADBYTE
    BOOL bUnicode;

    // We would like to check the possibility
    // of IS_TEXT_UNICODE_DBCS_LEADBYTE.
    //

    bUnicode= IsTextUnicode( lpstrInputStream, iLen, &iResult);

    if (bUnicode                                         &&
       ((iResult & IS_TEXT_UNICODE_STATISTICS)    != 0 ) &&
       ((iResult & (~IS_TEXT_UNICODE_STATISTICS)) == 0 )    )
    {
        CPINFO cpiInfo;
        CHAR* pch= (CHAR*)lpstrInputStream;
        INT  cb;

        //
        // If the result depends only upon statistics, check
        // to see if there is a possibility of DBCS.
        // Only do this check if the ansi code page is DBCS
        //

        GetCPInfo( CP_ACP, &cpiInfo);

        if( cpiInfo.MaxCharSize > 1 )
        {
            for( cb=0; cb<iLen; cb++ )
            {
                if( IsDBCSLeadByte(*pch++) )
                {
                    return FALSE;
                }
            }
        }
     }

     return bUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\newpad\npxml.c ===
/*
 * XML support functions
 *  Copyright (C) 2000 Microsoft Corporation
 */

#include "precomp.h"


BOOL FIsXmlWhitespaceW(WCHAR wch)
{
    return((wch == L' ') || (wch == L'\x9') || (wch == L'\xA') || (wch == L'\xD'));
}


BOOL FIsXmlWhitespaceA(char ch)
{
    return(FIsXmlWhitespaceW((WCHAR) (BYTE) ch));
}


BOOL FIsXmlA(LPCSTR rgch, UINT cch)
{
    if (memcmp(rgch, "<?xml", 5) != 0)
    {
        // Not XML

        return(FALSE);
    }

    return(TRUE);

    UNREFERENCED_PARAMETER( cch );
}


BOOL FIsXmlW(LPCWSTR rgwch, UINT cch)
{
    if (memcmp(rgwch, L"<?xml", 5 * sizeof(WCHAR)) != 0)
    {
        // Not XML

        return(FALSE);
    }

    return(TRUE);

    UNREFERENCED_PARAMETER( cch );
}


BOOL FDetectXmlEncodingA(LPCSTR rgch, UINT cch, UINT *pcp)
{
    LPCSTR pchMax;
    LPCSTR pch;
    char chQuote;

    // XML files encoded in UTF-16 are required to have a BOM which if present
    // would already have been detected.  This means that if this file is XML
    // it either is encoded in UCS-4 or UTF-32 which isn't supported or an MBCS
    // encoding of some form.  We check for ASCII compatible encodings only
    // which includes everything we probably care about but excludes EBCDIC.

    // Check for file begining with <?xml ... encoding='...' ... ?>

    if (cch < 20)
    {
        // File is too small

        return(FALSE);
    }

    if (!FIsXmlA(rgch, cch))
    {
        // Not XML

        return(FALSE);
    }

    // Don't scan more than 4K looking for encoding even if it is valid XML

    cch = __min(cch, 4096);

    pchMax = rgch + cch;
    pch = rgch + 5;

    if (!FIsXmlWhitespaceA(*pch))
    {
        // Not XML

        return(FALSE);
    }

    pch++;

    chQuote = '\0';

    for (;;)
    {
        LPCSTR pchToken;

        if (pch == pchMax)
        {
            // Not XML

            break;
        }

        if (FIsXmlWhitespaceA(*pch))
        {
            pch++;
            continue;
        }

        if (*pch == '=')
        {
            pch++;
            continue;
        }

        if ((*pch == '\'') || (*pch == '"'))
        {
            if (*pch == chQuote)
            {
                chQuote = '\0';
            }

            else
            {
                chQuote = *pch;
            }

            pch++;
            continue;
        }

        if (chQuote != '\0')
        {
            // We are within a quoted string.  Skip everything until closing quote.

            pch++;
            continue;
        }

        if ((pch + 2) > pchMax)
        {
            // Not XML

            break;
        }

        if ((pch[0] == '?') && (pch[1] == '>'))
        {
            // This looks like XML.  At this point if we don't find an encoding
            // specification we could assume UTF-8.  We don't because there are
            // malformed XML documents and assuming UTF-8 might affect Notepad
            // compatibility.  This may be fine but we put it off for now.

            // *pcp = CP_UTF8;
            // return(TRUE);

            break;
        }

        pchToken = pch;

        while ((pch < pchMax) && (*pch != '=') && (*pch != '?') && !FIsXmlWhitespaceA(*pch))
        {
            pch++;
        }

        if (pch != (pchToken + 8))
        {
             continue;
        }

        if (memcmp(pchToken, "encoding", 8) != 0)
        {
             continue;
        }

        while ((pch < pchMax) && FIsXmlWhitespaceA(*pch))
        {
            pch++;
        }

        if ((pch == pchMax) || (*pch++ != '='))
        {
            // Not XML

            break;
        }

        while ((pch < pchMax) && FIsXmlWhitespaceA(*pch))
        {
            pch++;
        }

        if ((pch == pchMax) || ((*pch != '\'') && (*pch != '"')))
        {
            // Not XML

            break;
        }

        chQuote = *pch++;

        pchToken = pch;

        while ((pch < pchMax) && (*pch != chQuote))
        {
            pch++;
        }

        if (pch == pchMax)
        {
            // Not XML

            break;
        }

        // We have an XML encoding declaration from pchToken to (pch - 1)

        if (pch == pchToken)
        {
            // Not XML

            break;
        }

        if (!FLookupCodepageNameA((LPCSTR) pchToken, (UINT) (pch - pchToken), pcp))
        {
            // Encoding is not recognized

            break;
        }

        if ((*pcp == CP_UTF16) || (*pcp == CP_UTF16BE))
        {
            // These are bogus since we know the file is MBCS

            break;
        }

        return(FValidateCodepage(hwndNP, *pcp));
    }

    return(FALSE);
}


BOOL FDetectXmlEncodingW(LPCWSTR rgch, UINT cch, UINT *pcp)
{
    const WCHAR *pchMax;
    const WCHAR *pch;
    WCHAR chQuote;

    // XML files encoded in UTF-16 are required to have a BOM which if present
    // would already have been detected.  This means that if this file is XML
    // it either is encoded in UCS-4 or UTF-32 which isn't supported or an MBCS
    // encoding of some form.  We check for ASCII compatible encodings only
    // which includes everything we probably care about but excludes EBCDIC.

    // Check for file begining with <?xml ... encoding='...' ... ?>

    if (cch < 20)
    {
        // File is too small

        return(FALSE);
    }

    if (!FIsXmlW(rgch, cch))
    {
        // Not XML

        return(FALSE);
    }

    // Don't scan more than 4K looking for encoding even if it is valid XML

    cch = __min(cch, 4096);

    pchMax = rgch + cch;
    pch = rgch + 5;

    if (!FIsXmlWhitespaceW(*pch))
    {
        // Not XML

        return(FALSE);
    }

    pch++;

    chQuote = L'\0';

    for (;;)
    {
        const WCHAR *pchToken;

        if (pch == pchMax)
        {
            // Not XML

            break;
        }

        if (FIsXmlWhitespaceW(*pch))
        {
            pch++;
            continue;
        }

        if (*pch == L'=')
        {
            pch++;
            continue;
        }

        if ((*pch == L'\'') || (*pch == L'"'))
        {
            if (*pch == chQuote)
            {
                chQuote = L'\0';
            }

            else
            {
                chQuote = *pch;
            }

            pch++;
            continue;
        }

        if (chQuote != L'\0')
        {
            // We are within a quoted string.  Skip everything until closing quote.

            pch++;
            continue;
        }

        if ((pch + 2) > pchMax)
        {
            // Not XML

            break;
        }

        if ((pch[0] == L'?') && (pch[1] == L'>'))
        {
            // This looks like XML.  At this point if we don't find an encoding
            // specification we could assume UTF-8.  We don't because there are
            // malformed XML documents and assuming UTF-8 might affect Notepad
            // compatibility.  This may be fine but we put it off for now.

            // *pcp = CP_UTF8;
            // return(TRUE);

            break;
        }

        pchToken = pch;

        while ((pch < pchMax) && (*pch != L'=') && (*pch != L'?') && !FIsXmlWhitespaceW(*pch))
        {
            pch++;
        }

        if (pch != (pchToken + 8))
        {
             continue;
        }

        if (memcmp(pchToken, L"encoding", 8) != 0)
        {
             continue;
        }

        while ((pch < pchMax) && FIsXmlWhitespaceW(*pch))
        {
            pch++;
        }

        if ((pch == pchMax) || (*pch++ != L'='))
        {
            // Not XML

            break;
        }

        while ((pch < pchMax) && FIsXmlWhitespaceW(*pch))
        {
            pch++;
        }

        if ((pch == pchMax) || ((*pch != L'\'') && (*pch != L'"')))
        {
            // Not XML

            break;
        }

        chQuote = *pch++;

        pchToken = pch;

        while ((pch < pchMax) && (*pch != chQuote))
        {
            pch++;
        }

        if (pch == pchMax)
        {
            // Not XML

            break;
        }

        // We have an XML encoding declaration from pchToken to (pch - 1)

        if (pch == pchToken)
        {
            // Not XML

            break;
        }

        if (!FLookupCodepageNameW(pchToken, (UINT) (pch - pchToken), pcp))
        {
            // Encoding is not recognized

            break;
        }

#if 0
        if ((*pcp == CP_UTF16) || (*pcp == CP_UTF16BE))
        {
            // These are bogus since we know the file is MBCS

            break;
        }
#endif

        return(FValidateCodepage(hwndNP, *pcp));
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\npdate.c ===
/* npdate - Code for getting and inserting current date and time.
 *   Copyright (C) 1984-1995 Microsoft Inc.
 */

#include "precomp.h"

/* ** Replace current selection with date/time string.
 *    if fCrlf is true, date/time string should begin
 *    and end with crlf
*/
VOID FAR InsertDateTime (BOOL fCrlf)
{
   SYSTEMTIME time ;
   TCHAR szDate[80] ;
   TCHAR szTime[80] ;
   TCHAR szDateTime[sizeof(szDate) + sizeof(szTime) + 10] = TEXT("");
   DWORD locale;
   BOOL bMELocale;
   DWORD dwFlags = DATE_SHORTDATE;

   //  See if the user locale id is Arabic or Hebrew.
   locale    = GetUserDefaultLCID();
   bMELocale = ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
                (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW));

   locale = MAKELCID( MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT) ;

   // Get the time
   GetLocalTime( &time ) ;

   if (bMELocale)
   {
       //Get the date format that matches the edit control reading direction.
       if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING) {
           dwFlags |= DATE_RTLREADING;
           lstrcat(szDateTime, TEXT("\x200F")); // RLM
       } else {
           dwFlags |= DATE_LTRREADING;
           lstrcat(szDateTime, TEXT("\x200E")); // LRM
       }
   }

   // Format date and time
   GetDateFormat(locale,dwFlags, &time,NULL,szDate,CharSizeOf(szDate));
   GetTimeFormat(locale,TIME_NOSECONDS,&time,NULL,szTime,CharSizeOf(szTime));

   if( fCrlf )
       lstrcat(szDateTime, TEXT("\r\n"));


   lstrcat(szDateTime, szTime);
   lstrcat(szDateTime, TEXT(" "));
   lstrcat(szDateTime, szDate);

   if( fCrlf )
        lstrcat(szDateTime, TEXT("\r\n"));

   // send it in one shot; this is also useful for undo command
   // so that user can undo the date-time.
   SendMessage(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szDateTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\notepad.h ===
/* Notepad.h */

#define NOCOMM
#define NOSOUND
#include <windows.h>
#include <ole2.h>
#include <commdlg.h>
#include <commctrl.h>
// we need this for CharSizeOf(), ByteCountOf(),
#include "uniconv.h"

/* handy debug macro */
#define ODS OutputDebugString

typedef enum _NP_FILETYPE {
   FT_UNKNOWN=-1,
   FT_ANSI=0,
   FT_UNICODE=1,
   FT_UNICODEBE=2,
   FT_UTF8=3,
} NP_FILETYPE;


#define BOM_UTF8_HALF        0xBBEF
#define BOM_UTF8_2HALF       0xBF


/* openfile filter for all text files */
#define FILE_TEXT         1


/* ID for the status window */
#define ID_STATUS_WINDOW     WM_USER+1


#define PT_LEN               40    /* max length of page setup strings */
#define CCHFILTERMAX         80    /* max. length of filter name buffers */

// Menu IDs 
#define ID_APPICON           1 /* must be one for explorer to find this */
#define ID_ICON              2
#define ID_MENUBAR           1

// Dialog IDs

#define IDD_ABORTPRINT       11
#define IDD_PAGESETUP        12
#define IDD_SAVEDIALOG       13    // template for save dialog
#define IDD_GOTODIALOG       14    // goto line number dialog

// Control IDs 

#define IDC_FILETYPE         257   // listbox in save dialog
#define IDC_GOTO             258   // line number to goto
#define IDC_ENCODING         259   // static text in save dialog

//  Menu IDs 

// File
#define M_NEW                1
#define M_OPEN               2
#define M_SAVE               3
#define M_SAVEAS             4
#define M_PAGESETUP          5
#define M_PRINT              6
#define M_EXIT               7

// Edit
#define M_UNDO               16
#define M_CUT                WM_CUT       /* These just get passed down to the edit control */
#define M_COPY               WM_COPY
#define M_PASTE              WM_PASTE
#define M_CLEAR              WM_CLEAR
#define M_FIND               21
#define M_FINDNEXT           22
#define M_REPLACE            23
#define M_GOTO               24
#define M_SELECTALL          25
#define M_DATETIME           26
#define M_STATUSBAR          27

// Format
#define M_WW                 32
#define M_SETFONT            33

// Help
#define M_HELP               64
#define M_ABOUT              65

// Control IDs

#define ID_EDIT              15
#define ID_FILENAME          20
#define ID_PAGENUMBER        21


#define ID_HEADER            30
#define ID_FOOTER            31
#define ID_HEADER_LABEL      32
#define ID_FOOTER_LABEL      33

#define ID_ASCII             50
#define ID_UNICODE           51


// IDs used to load RC strings
//
// Note: The international team doesn't like wholesale changes
// to these IDs.  Apparently, if the ID changes they have to
// translate the string again.  It's best to just add new IDs 
// to the end.

#define IDS_DISKERROR         1
#define IDS_FNF               2
#define IDS_SCBC              3
#define IDS_UNTITLED          4
#define IDS_NOTEPAD           5
#define IDS_CFS               6
#define IDS_ERRSPACE          7
#define IDS_FTL               8
#define IDS_NN                9
#define IDS_COMMDLGINIT      10
#define IDS_PRINTDLGINIT     11
#define IDS_CANTPRINT        12
#define IDS_NVF              13
#define IDS_CREATEERR        14
#define IDS_NOWW             15
#define IDS_MERGE1           16
#define IDS_HELPFILE         17
#define IDS_HEADER           18
#define IDS_FOOTER           19

#define IDS_ANSITEXT         20
#define IDS_ALLFILES         21
#define IDS_OPENCAPTION      22
#define IDS_SAVECAPTION      23
#define IDS_CANNOTQUIT       24
#define IDS_LOADDRVFAIL      25
#define IDS_ACCESSDENY       26
#define IDS_ERRUNICODE       27


#define IDS_FONTTOOBIG       28
#define IDS_COMMDLGERR       29


#define IDS_LINEERROR        30  /* line number error     */
#define IDS_LINETOOLARGE     31  /* line number too large */

#define IDS_FT_ANSI          32  /* ascii              */
#define IDS_FT_UNICODE       33  /* unicode            */
#define IDS_FT_UNICODEBE     34  /* unicode big endian */
#define IDS_FT_UTF8          35  /* UTF-8 format       */

#define IDS_CURRENT_PAGE     36  /* currently printing page on abort dlg */

// constants for the status bar
#define IDS_LINECOL          37
#define IDS_COMPRESSED_FILE  38
#define IDS_ENCRYPTED_FILE   39
#define IDS_HIDDEN_FILE      40
#define IDS_OFFLINE_FILE     41
#define IDS_READONLY_FILE    42
#define IDS_SYSTEM_FILE      43
#define IDS_FILE             44


#define IDS_LETTERS          45    /* formatting letters used in page setup */

#define CSTRINGS             45    /* cnt of stringtable strings from .rc file */

// This string is used by MUI for the "FriendlyTypeName".
// See reference to it in hivecls.inx
// We don't load it so the number is out of sequence with those we do load.

#define IDS_TEXT_FRIENDLY_NAME      469

#define CCHKEYMAX           128  /* max characters in search string */

#define BUFFER_TEST_SIZE    1024 /* number of characters to read from a file to determine the file encoding */

#define CCHNPMAX              0  /* no limit on file size */

#define SETHANDLEINPROGRESS   0x0001 /* EM_SETHANDLE has been sent */
#define SETHANDLEFAILED       0x0002 /* EM_SETHANDLE caused EN_ERRSPACE */

/* Standard edit control style:
 * ES_NOHIDESEL set so that find/replace dialog doesn't undo selection
 * of text while it has the focus away from the edit control.  Makes finding
 * your text easier.
 */
#define ES_STD (WS_CHILD|WS_VSCROLL|WS_VISIBLE|ES_MULTILINE|ES_NOHIDESEL)

/* EXTERN decls for data */
extern NP_FILETYPE fFileType;     /* Flag indicating the type of text file */

extern BOOL fCase;                /* Flag specifying case sensitive search */
extern BOOL fReverse;             /* Flag for direction of search */
extern TCHAR szSearch[];
extern HWND hDlgFind;             /* handle to modeless FindText window */

extern HANDLE hEdit;
extern HANDLE hFont;
extern HANDLE hAccel;
extern HANDLE hInstanceNP;
extern HANDLE hStdCursor, hWaitCursor;
extern HWND   hwndNP, hwndEdit, hwndStatus;

extern LOGFONT  FontStruct;
extern INT      iPointSize;

extern BOOL     fRunBySetup;

extern DWORD    dwEmSetHandle;

extern TCHAR    chMerge;

extern BOOL     fUntitled;
extern BOOL     fWrap;
extern TCHAR    szFileName[];
extern HANDLE   fp;

extern BOOL     fMLE_is_broken;

//
// Holds header and footer strings to be used in printing.
// use HEADER and FOOTER to index.
//
extern TCHAR    chPageText[2][PT_LEN]; // header and footer strings
#define HEADER 0
#define FOOTER 1
//
// Holds header and footer from pagesetupdlg during destroy.
// if the user hit ok, then keep.  Otherwise ignore.
//
extern TCHAR    chPageTextTemp[2][PT_LEN];

extern TCHAR    szNotepad[];
extern TCHAR   *szMerge;
extern TCHAR   *szUntitled, *szNpTitle, *szNN, *szErrSpace;
extern TCHAR   *szErrUnicode;
extern TCHAR  **rgsz[];          /* More strings. */
extern TCHAR   *szNVF;
extern TCHAR   *szPDIE;
extern TCHAR   *szDiskError;
extern TCHAR   *szCREATEERR;
extern TCHAR   *szWE;
extern TCHAR   *szFTL;
extern TCHAR   *szINF;
extern TCHAR   *szFNF;
extern TCHAR   *szNEDSTP;
extern TCHAR   *szNEMTP;
extern TCHAR   *szCFS;
extern TCHAR   *szPE;
extern TCHAR   *szCP;
extern TCHAR   *szACCESSDENY;
extern TCHAR   *szFontTooBig;
extern TCHAR   *szLoadDrvFail;
extern TCHAR   *szCommDlgErr;
extern TCHAR   *szCommDlgInitErr;
extern TCHAR   *szHelpFile;

extern TCHAR   *szFtAnsi;
extern TCHAR   *szFtUnicode;
extern TCHAR   *szFtUnicodeBe;
extern TCHAR   *szFtUtf8;
extern TCHAR   *szCurrentPage;
extern TCHAR   *szHeader;
extern TCHAR   *szFooter;
extern TCHAR   *szLetters;

/* variables for the new File/Open and File/Saveas dialogs */
extern OPENFILENAME OFN;        /* passed to the File Open/save APIs */
extern TCHAR  szOpenFilterSpec[]; /* default open filter spec          */
extern TCHAR  szSaveFilterSpec[]; /* default save filter spec          */
extern TCHAR *szAnsiText;       /* part of the text for the above    */
extern TCHAR *szAllFiles;       /* part of the text for the above    */
extern FINDREPLACE FR;          /* Passed to FindText()        */
extern PAGESETUPDLG g_PageSetupDlg;
extern TCHAR  szPrinterName []; /* name of the printer passed to PrintTo */

extern NP_FILETYPE    g_ftOpenedAs;     /* file was opened           */
extern NP_FILETYPE    g_ftSaveAs;       /* file was saved as type    */

extern UINT   wFRMsg;           /* message used in communicating    */
                                /*   with Find/Replace dialog       */
extern UINT   wHlpMsg;          /* message used in invoking help    */

extern HMENU hSysMenuSetup;     /* Save Away for disabled Minimize   */
extern BOOL  fStatus;
extern INT   dyStatus;


/* Macro for setting status bar - x is the text to set and n is the part number
   in the statusbar */
#define SetStatusBarText(x, n) if(hwndStatus)SendMessage(hwndStatus, SB_SETTEXT, n, (LPARAM)(LPTSTR)(x));
VOID UpdateStatusBar( BOOL fForceUpdate );



/* EXTERN procs */
/* procs in notepad.c */
VOID
PASCAL
SetPageSetupDefaults(
    VOID
    );

BOOL far PASCAL SaveAsDlgHookProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

LPTSTR PASCAL far PFileInPath (LPTSTR sz);

BOOL FAR CheckSave (BOOL fSysModal);
LRESULT FAR NPWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void FAR SetTitle (TCHAR *sz);
INT FAR  AlertBox (HWND hwndParent, TCHAR *szCaption, TCHAR *szText1,
                   TCHAR *szText2, UINT style);
void FAR NpWinIniChange (VOID);
void FAR FreeGlobalPD (void);
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
VOID CALLBACK WinEventFunc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject,
                      LONG idChild, DWORD dwEventThread, DWORD dwmsEventTime);


NP_FILETYPE fDetermineFileType(LPBYTE lpFileContents, UINT iSize);
VOID GotoAndScrollInView( INT OneBasedLineNumber );
void NPSize (int cxNew, int cyNew);


/* procs in npdate.c */
VOID FAR InsertDateTime (BOOL fCrlf);

/* procs in npfile.c */
BOOL FAR  SaveFile (HWND hwndParent, TCHAR *szFileSave, BOOL fSaveAs);
BOOL FAR  LoadFile (TCHAR *sz, INT type );
VOID FAR  New (BOOL  fCheck);
void FAR  AddExt (TCHAR *sz);
INT FAR   Remove (LPTSTR szFileName);
VOID FAR  AlertUser_FileFail( LPTSTR szFileName );

/* procs in npinit.c */
INT FAR  NPInit (HANDLE hInstance, HANDLE hPrevInstance,
                 LPTSTR lpCmdLine, INT cmdShow);
void FAR InitLocale (VOID);
void SaveGlobals( VOID );

/* procs in npmisc.c */
INT FAR  FindDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL     Search (TCHAR *szSearch);
INT FAR  AboutDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL FAR NpReCreate (LONG style);
LPTSTR   ForwardScan (LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive);


/* procs in npprint.c */
typedef enum _PRINT_DIALOG_TYPE {
   UseDialog,
   DoNotUseDialog,
   NoDialogNonDefault
} PRINT_DIALOG_TYPE;

INT    AbortProc( HDC hPrintDC, INT reserved );
INT_PTR AbortDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
INT    NpPrint( PRINT_DIALOG_TYPE type );
INT    NpPrintGivenDC( HDC hPrintDC );

UINT_PTR
CALLBACK
PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

HANDLE GetPrinterDC (VOID);
HANDLE GetNonDefPrinterDC (VOID);
VOID   PrintIt(PRINT_DIALOG_TYPE type);


/* procs in nputf.c */

INT    IsTextUTF8   (LPSTR lpstrInputStream, INT iLen);
INT    IsInputTextUnicode(LPSTR lpstrInputStream, INT iLen);



// Help IDs for Notepad

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_PAGE_FOOTER                 1000
#define IDH_PAGE_HEADER                 1001
#define IDH_FILETYPE                    1002
#define IDH_GOTO                        1003

// Private message to track the HKL switch

#define PWM_CHECK_HKL                   (WM_APP + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\npfile.c ===
/*
 * npfile.c  - Routines for file i/o for notepad
 *   Copyright (C) 1984-2001 Microsoft Inc.
 */

#include "precomp.h"


HANDLE  hFirstMem;
CHAR    BOM_UTF8[3]= {(BYTE) 0xEF, (BYTE) 0xBB, (BYTE)0xBF};



//****************************************************************
//
//   ReverseEndian
//
//   Purpose: copies unicode character from one endian source
//            to another.
//
//            may work on lpDst == lpSrc
//

VOID ReverseEndian( PTCHAR lpDst, PTCHAR lpSrc, DWORD nChars )
{
    DWORD  cnt;

    for( cnt=0; cnt < nChars; cnt++,lpDst++,lpSrc++ )
    {
        *lpDst= (TCHAR) (((*lpSrc<<8) & 0xFF00) + ((*lpSrc>>8)&0xFF));
    }
}

//*****************************************************************
//
//   AnsiWriteFile()
//
//   Purpose     : To simulate the effects of _lwrite() in a Unicode
//                 environment by converting to ANSI buffer and
//                 writing out the ANSI text.
//   Returns     : TRUE is successful, FALSE if not
//                 GetLastError() will have the error code.
//
//*****************************************************************

BOOL AnsiWriteFile(HANDLE  hFile,    // file to write to
                   UINT uCodePage,   // code page to convert unicode to
                   DWORD  dwFlags,   // flags for WideCharToMultiByte conversion
                   LPVOID lpBuffer,  // unicode buffer
                   DWORD nChars)     // number of unicode chars
{
    LPSTR   lpAnsi;              // pointer to allocate buffer
    BOOL    fDefCharUsed;        // flag that conversion wasn't perfect
    BOOL*   pfDefCharUsed;       // pointer to flag
    DWORD   nBytesWritten;       // number of bytes written
    BOOL    bStatus;             // status from conversion and writefile
    DWORD   nBytes;              // number of ascii character to produce
    
    //
    // WideCharToMultiByte fails to convert zero characters.
    // If we get a request to write 0 chars, just return.  We are done.
    // 

    if( nChars == 0 )
    {
       return( TRUE );
    }

    pfDefCharUsed= NULL;
    if( uCodePage != CP_UTF8 )
    {
        pfDefCharUsed= &fDefCharUsed;
    }

    // 
    // Calculate number of bytes to write
    // The caller calculated the number of bytes to write
    // but it might be wrong because the user approved data loss.
    // Do the calculation here (again) in case the dwFlags are different.
    // FEATURE: We could optimize this in the case where the dwFlags did not
    // change.  
    //

    nBytes= 
    WideCharToMultiByte( uCodePage,             // code page
                         dwFlags,               // performance and mapping flags
                        (LPWSTR) lpBuffer,      // wide char buffer
                         nChars,                // chars in wide char buffer
                         NULL,                  // output buffer
                         0,                     // size of output buffer
                         NULL,                  // char to sub. for unmapped chars (use default)
                         pfDefCharUsed);        // flag to set if default char used

    if( nBytes == 0 )
    {
        return( FALSE );
    }

    //
    // Allocate buffer to convert to
    //

    lpAnsi= (LPSTR) LocalAlloc( LPTR, nBytes + 1 );

    if( !lpAnsi )
    {
       SetLastError( ERROR_NOT_ENOUGH_MEMORY );
       return (FALSE);
    }

    bStatus= 
    WideCharToMultiByte( uCodePage,             // code page
                         dwFlags,               // performance and mapping flags
                        (LPWSTR) lpBuffer,      // wide char buffer
                         nChars,                // chars in wide char buffer
                         lpAnsi,                // resultant ascii string
                         nBytes,                // size of ascii string buffer
                         NULL,                  // char to sub. for unmapped chars (use default)
                         pfDefCharUsed);        // flag to set if default char used

    if( bStatus ) 
    {
        bStatus= WriteFile( hFile, lpAnsi, nBytes, &nBytesWritten, NULL );
    }

    LocalFree( lpAnsi );

    return( bStatus );

} // end of AnsiWriteFile()


// Routines to deal with the soft EOL formatting.
//
// MLE Actually inserts characters into the text being under edit, so they
// have to be removed before saving the file.
//
// It turns out that MLE will get confused if the current line is bigger than
// the current file, so we will reset the cursor to 0,0 to keep it from looking stupid.
// Should be fixed in MLE, but...
//


static DWORD dwStartSel;    // saved start of selection
static DWORD dwEndSel;      // saved end of selection

VOID ClearFmt(VOID) 
{

    if( fWrap )
    {
        if( fMLE_is_broken ) 
        {
            GotoAndScrollInView( 1 );
        }
        else 
        {
           SendMessage( hwndEdit, EM_GETSEL, (WPARAM) &dwStartSel, (LPARAM) &dwEndSel );
           SendMessage( hwndEdit, EM_SETSEL, (WPARAM) 0, (LPARAM) 0 ); 
        }

        SendMessage( hwndEdit, EM_FMTLINES, (WPARAM)FALSE, 0 );   // remove soft EOLs
    }

}

VOID RestoreFmt(VOID)
{
    UINT CharIndex;

    if( fWrap )
    {
        if( fMLE_is_broken ) 
        {
            NpReCreate( ES_STD );     // slow but it works
        }
        else
        {
            SendMessage( hwndEdit, EM_FMTLINES, (WPARAM)TRUE, 0 );   // add soft EOLs
            SendMessage( hwndEdit, EM_SETSEL, (WPARAM) dwStartSel, (LPARAM) dwEndSel);
        }
    }


}

/* Save notepad file to disk.  szFileSave points to filename.  fSaveAs
   is TRUE iff we are being called from SaveAsDlgProc.  This implies we must
   open file on current directory, whether or not it already exists there
   or somewhere else in our search path.
   Assumes that text exists within hwndEdit.    30 July 1991  Clark Cyr
 */

BOOL FAR SaveFile (HWND hwndParent, TCHAR *szFileSave, BOOL fSaveAs )
{
    LPTSTR    lpch;
    UINT      nChars;
    BOOL      flag;
    BOOL      fNew = FALSE;
    BOOL      fDefCharUsed = FALSE;
    BOOL*     pfDefCharUsed;
    static    WCHAR wchBOM = BYTE_ORDER_MARK;
    static    WCHAR wchRBOM= REVERSE_BYTE_ORDER_MARK;
    HLOCAL    hEText;                // handle to MLE text
    DWORD     nBytesWritten;         // number of bytes written
    DWORD     nAsciiLength;          // length of equivalent ascii file
    UINT      cpTemp= CP_ACP;        // code page to convert to
    DWORD     dwFlags;               // flags for WideCharToMultiByte


    /* If saving to an existing file, make sure correct disk is in drive */
    if (!fSaveAs)
    {
       fp= CreateFile( szFileSave,                 // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ,            // share mode
                       NULL,                       // security descriptor
                       OPEN_EXISTING,              // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs
    }
    else
    {

       // Carefully open the file.  Do not truncate it if it exists.
       // set the fNew flag if it had to be created.
       // We do all this in case of failures later in the process.

       fp= CreateFile( szFileSave,                 // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                       NULL,                       // security descriptor
                       OPEN_ALWAYS,                // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs

       if( fp != INVALID_HANDLE_VALUE )
       {
          fNew= (GetLastError() != ERROR_ALREADY_EXISTS );
       }
    }

    if( fp == INVALID_HANDLE_VALUE )
    {            
        AlertBox( hwndParent, szNN, szCREATEERR, szFileSave,
                        MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return FALSE;       
    }


    // if wordwrap, remove soft carriage returns 
    // Also move the cursor to a safe place to get around MLE bugs
    
    if( fWrap ) 
    {
       ClearFmt();
    }

    /* Must get text length after formatting */
    nChars = (UINT)SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, (LPARAM)0);

    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0,0 );
    if(  !hEText || !(lpch= (LPTSTR) LocalLock(hEText) ))
    {
       AlertUser_FileFail( szFileSave );
       goto CleanUp;
    }



       
    // Determine the SaveAs file type, and write the appropriate BOM.
    // If the filetype is UTF-8 or Ansi, do the conversion.
    switch(g_ftSaveAs)
    {
    case FT_UNICODE:
        WriteFile( fp, &wchBOM, ByteCountOf(1), &nBytesWritten, NULL );
        flag= WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
        break;

    case FT_UNICODEBE:
        WriteFile( fp, &wchRBOM, ByteCountOf(1), &nBytesWritten, NULL );
        ReverseEndian( lpch, lpch,nChars );
        flag= WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
        ReverseEndian( lpch, lpch, nChars );
        break;

    // If it UTF-8, write the BOM (3 bytes), set the code page and fall 
    // through to the default case.
    case FT_UTF8:
        WriteFile( fp, &BOM_UTF8, 3, &nBytesWritten, NULL );        
        // fall through to convert and write the file

    default:

        if (g_ftSaveAs != FT_UTF8)
        {
            //
            // Always use the current locale code page to do the translation
            // If the user changes locales, they will need to know what locale
            // this version of the file was saved with.  Since we don't save that
            // information, the user may be in trouble.  Unicode would save his bacon.
            //

            cpTemp= GetACP();

            pfDefCharUsed= &fDefCharUsed;
            dwFlags= WC_NO_BEST_FIT_CHARS;
        }
        else 
        {
            cpTemp= CP_UTF8;
            pfDefCharUsed= NULL;    // these must be NULL and 0 for this code page
            dwFlags= 0;
        }
        

        nAsciiLength= WideCharToMultiByte( cpTemp,
                                           dwFlags,
                                           (LPWSTR)lpch,
                                           nChars,
                                           NULL,
                                           0,
                                           NULL,          // if no conversion, use default char
                                           pfDefCharUsed);

        // If we can't round-trip the character, warn the user.
        // If we don't use WC_NO_BEST_FIT_CHARS, WCTMB() will convert some characters
        // without setting the fDefCharUsed (for example alt-233)
        // This fixes ntbug9:367586

        if( fDefCharUsed || (nChars && (nAsciiLength==0) ) )
        {
            if ( AlertBox( hwndParent, szNN, szErrUnicode, szFileSave, 
                  MB_APPLMODAL|MB_OKCANCEL|MB_ICONEXCLAMATION) == IDCANCEL)
               goto CleanUp;          
           
            // User has approved loss of data, so try conversion with flags
            // that allow loss.   ntbug9: 435042

            dwFlags= 0;
        }
        flag= AnsiWriteFile( fp, cpTemp, dwFlags, lpch, nChars );
        break;
    }


    if (!flag)
    {
       SetCursor(hStdCursor);     /* display normal cursor */

       AlertUser_FileFail( szFileSave );
CleanUp:
       SetCursor( hStdCursor );
       CloseHandle (fp); fp=INVALID_HANDLE_VALUE;
       if( hEText )
           LocalUnlock( hEText );
       if (fNew)
          DeleteFile (szFileSave);
       /* if wordwrap, insert soft carriage returns */
       if (fWrap) 
       {
           RestoreFmt();
       }
       return FALSE;
    }
    else
    {
       SetEndOfFile (fp);
       g_ftOpenedAs = g_ftSaveAs;
       SendMessage (hwndEdit, EM_SETMODIFY, FALSE, 0L);
       SetTitle (szFileSave);
       fUntitled = FALSE;
    }

    CloseHandle (fp); fp=INVALID_HANDLE_VALUE;

    if( hEText )
        LocalUnlock( hEText );

    /* if wordwrap, insert soft carriage returns */
    if (fWrap)
    {
       RestoreFmt();
    }

    /* Display the hour glass cursor */
    SetCursor(hStdCursor);

    return TRUE;

} // end of SaveFile()

/* Read contents of file from disk.
 * Do any conversions required.
 * File is already open, referenced by handle fp
 * Close the file when done.
 * If typeFlag>=0, then use it as filetype, otherwise do automagic guessing.
 */

BOOL FAR LoadFile (TCHAR * sz, INT typeFlag )
{
    UINT      len, i, nChars;
    LPTSTR    lpch=NULL;
    LPTSTR    lpBuf;
    LPSTR     lpBufAfterBOM;
    BOOL      fLog=FALSE;
    TCHAR*    p;
    TCHAR     szSave[MAX_PATH]; /* Private copy of current filename */
    BOOL      bUnicode=FALSE;   /* true if file detected as unicode */
    BOOL      bUTF8=FALSE;      /* true if file detected as UTF-8 */
    DWORD     nBytesRead;       // number of bytes read
    BY_HANDLE_FILE_INFORMATION fiFileInfo;
    BOOL      bStatus;          // boolean status
    HLOCAL    hNewEdit=NULL;    // new handle for edit buffer
    HANDLE    hMap;             // file mapping handle
    TCHAR     szNullFile[2];    // fake null mapped file
    INT       cpTemp = CP_ACP;
    NP_FILETYPE ftOpenedAs=FT_UNKNOWN;


    if( fp == INVALID_HANDLE_VALUE )
    {
       AlertUser_FileFail( sz );
       return (FALSE);
    }

    //
    // Get size of file
    // We use this heavy duty GetFileInformationByHandle API
    // because it finds bugs.  It takes longer, but it only is
    // called at user interaction time.
    //

    bStatus= GetFileInformationByHandle( fp, &fiFileInfo );
    len= (UINT) fiFileInfo.nFileSizeLow;

    // NT may delay giving this status until the file is accessed.
    // i.e. the open succeeds, but operations may fail on damaged files.

    if( !bStatus )
    {
        AlertUser_FileFail( sz );
        CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;
        return( FALSE );
    }

    // If the file is too big, fail now.
    // -1 not valid because we need a zero on the end.


    // If the file is too big, fail now.
    // -1 not valid because we need a zero on the end.
    //
    // bug# 168148: silently fails to open 2.4 gig text file on win64
    // Caused by trying to convert ascii file to unicode which overflowed
    // the dword length handled by multibytetowidechar conversion.
    // Since no one will be happy with the performance of the MLE with
    // a file this big, we will just refuse to open it now.
    //
    // For example, on a Pentium 173 MHz with 192 Megs o'RAM (Tecra 8000) 
    // I got these results:
    //
    // size   CPU-time
    //    0    .12
    //    1    .46
    //    2    .77
    //    3   1.041
    //    4   1.662
    //    5   2.092
    //    6   2.543
    //    7   3.023
    //    8   3.534
    //    9   4.084
    //   10   4.576
    //   16   8.371
    //   32  23.142
    //   64  74.426
    //
    //  Curve fitting these numbers to cpu-time=a+b*size+c*size*size
    //     we get a really good fit with cpu= .24+.28*size+.013*size*size
    //
    // For 1 gig, this works out to be 3.68 hours.  2 gigs=14.6 hours
    //
    // And the user isn't going to be happy with adding or deleting characters
    // with the MLE control.  It wants to keep the memory stuctures uptodate
    // at all times.
    //
    // Going to richedit isn't a near term solution either:
    //
    // size    CPU-time
    // 2       3.8
    // 4       9.0
    // 6      21.9
    // 8      30.4
    // 10     65.3
    // 16   1721 or >3.5 hours (it was still running when I killed it)
    //
    //
    // feature: should we only bail if not unicode?
    //

    if( len >=0x40000000 || fiFileInfo.nFileSizeHigh != 0 )
    {
       AlertBox( hwndNP, szNN, szFTL, sz,
                 MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
       CloseHandle (fp); fp=INVALID_HANDLE_VALUE;
       return (FALSE);
    }

    SetCursor(hWaitCursor);                // physical I/O takes time

    //
    // Create a file mapping so we don't page the file to
    // the pagefile.  This is a big win on small ram machines.
    //

    if( len != 0 )
    {
        lpBuf= NULL;

        hMap= CreateFileMapping( fp, NULL, PAGE_READONLY, 0, len, NULL );

        if( hMap )
        {
            lpBuf= MapViewOfFile( hMap, FILE_MAP_READ, 0,0,len);
            CloseHandle( hMap );
        }
    }
    else  // file mapping doesn't work on zero length files
    {
        lpBuf= (LPTSTR) &szNullFile;
        *lpBuf= 0;  // null terminate
    }

    CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;

    if( lpBuf == NULL )
    {
        SetCursor( hStdCursor );
        AlertUser_FileFail( sz );
        return( FALSE );
    }


    //
    // protect access to the mapped file with a try/except so we
    // can detect I/O errors.
    //

    //
    // WARNING: be very very careful.  This code is pretty fragile.
    // Files across the network, or RSM files (tape) may throw excepts
    // at random points in this code.  Anywhere the code touches the
    // memory mapped file can cause an AV.  Make sure variables are
    // in consistent state if an exception is thrown.  Be very careful
    // with globals.

    __try
    {
    /* Determine the file type and number of characters
     * If the user overrides, use what is specified.
     * Otherwise, we depend on 'IsTextUnicode' getting it right.
     * If it doesn't, bug IsTextUnicode.
     */

    lpBufAfterBOM= (LPSTR) lpBuf;
    if( typeFlag == FT_UNKNOWN )
    {
        switch(*lpBuf)
        {
        case BYTE_ORDER_MARK:
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODE;

            // don't count the BOM.
            nChars= len / sizeof(TCHAR) -1;
            break;

        case REVERSE_BYTE_ORDER_MARK:
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODEBE;

            // don't count the BOM.
            nChars= len / sizeof(TCHAR) -1;
            break;

        // UTF bom has 3 bytes; if it doesn't have UTF BOM just fall through ..
        case BOM_UTF8_HALF:            
            if (len > 2 && ((BYTE) *(((LPSTR)lpBuf)+2) == BOM_UTF8_2HALF) )
            {
                bUTF8= TRUE;
                cpTemp= CP_UTF8;
                ftOpenedAs= FT_UTF8;
                // Ignore the first three bytes.
                lpBufAfterBOM= (LPSTR)lpBuf + 3;
                len -= 3;
                break;
            }

        default:

            // Is the file unicode without BOM ?
            if ((bUnicode= IsInputTextUnicode((LPSTR) lpBuf, len)))
            {
                ftOpenedAs= FT_UNICODE;
                nChars= len / sizeof(TCHAR);
            }      
            else
            {
                // Is the file UTF-8 even though it doesn't have UTF-8 BOM.
                if ((bUTF8= IsTextUTF8((LPSTR) lpBuf, len)))
                {
                    ftOpenedAs= FT_UTF8;
                    cpTemp= CP_UTF8;
                }
                // well, not it must be an ansi file!
                else
                {
                    ftOpenedAs= FT_ANSI;
                    cpTemp= CP_ACP;
                }
            }
            break;
        }             
    }
    else
    {
        switch(typeFlag)
        {
        case FT_UNICODE:
                        
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODE;

            nChars= len / sizeof(TCHAR);

            // don't count the BOM.
            if (*lpBuf == BYTE_ORDER_MARK)
                nChars--;
            break;

        case FT_UNICODEBE:
                        
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODE;

            nChars= len / sizeof(TCHAR);

            // don't count the BOM.
            if (*lpBuf == REVERSE_BYTE_ORDER_MARK)
                nChars--;
            break;


        case FT_UTF8:
            
            bUTF8= TRUE;
            cpTemp= CP_UTF8;
            ftOpenedAs= FT_UTF8;
                      
            if (len > 2 && ((*lpBuf == BOM_UTF8_HALF) && ((BYTE) *(((LPSTR)lpBuf)+2) == BOM_UTF8_2HALF)) )
            {                
                // Ignore the first three bytes.
                lpBufAfterBOM= (LPSTR)lpBuf + 3;
                len -= 3;
                break;
            }
            break;


        case FT_ANSI:
        default:

            ftOpenedAs= FT_ANSI;
            cpTemp= CP_ACP;
        break;
        }
    }


    // find out no. of chars present in the string.
    if (!bUnicode)
    {
        nChars = MultiByteToWideChar (cpTemp,
                                      0,
                                      (LPSTR)lpBufAfterBOM,
                                      len,
                                      NULL,
                                      0);
    }

    //
    // Don't display text until all done.
    //

    SendMessage (hwndEdit, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);

    // Reset selection to 0

    SendMessage(hwndEdit, EM_SETSEL, 0, 0L);
    SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

    // resize the edit buffer
    // if we can't resize the memory, inform the user

    if (!(hNewEdit= LocalReAlloc(hEdit,ByteCountOf(nChars + 1),LMEM_MOVEABLE)))
    {
      /* Bug 7441: New() causes szFileName to be set to "Untitled".  Save a
       *           copy of the filename to pass to AlertBox.
       *  17 November 1991    Clark R. Cyr
       */
       lstrcpy(szSave, sz);
       New(FALSE);

       /* Display the hour glass cursor */
       SetCursor(hStdCursor);

       AlertBox( hwndNP, szNN, szFTL, szSave,
                 MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
       if( lpBuf != (LPTSTR) &szNullFile )
       {
           UnmapViewOfFile( lpBuf );
       }

       // let user see old text

       SendMessage (hwndEdit, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);
       return FALSE;
    }

    /* Transfer file from temporary buffer to the edit buffer */
    lpch= (LPTSTR) LocalLock(hNewEdit);

    if( bUnicode )
    {
       /* skip the Byte Order Mark */
       if (*lpBuf == BYTE_ORDER_MARK)
       {
          CopyMemory (lpch, lpBuf + 1, ByteCountOf(nChars));
       }
       else if( *lpBuf == REVERSE_BYTE_ORDER_MARK )
       {
          ReverseEndian( lpch, lpBuf+1, nChars );          
       }
       else
       {
          CopyMemory (lpch, lpBuf, ByteCountOf(nChars));
       }
    }
    else
    {      
       nChars = MultiByteToWideChar (cpTemp,
                                     0,
                                     (LPSTR)lpBufAfterBOM,
                                     len,
                                     (LPWSTR)lpch,
                                     nChars);
       
    }

    g_ftOpenedAs= ftOpenedAs;   // got everything; update global safe now

    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AlertBox( hwndNP, szNN, szDiskError, sz,
            MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION );
        nChars= 0;   // don't deal with it.
    }

    /* Free file mapping */
    if( lpBuf != (LPTSTR) &szNullFile )
    {
        UnmapViewOfFile( lpBuf );
    }


    if( lpch ) 
    {

       // Fix any NUL character that came in from the file to be spaces.

       for (i = 0, p = lpch; i < nChars; i++, p++)
       {
          if( *p == (TCHAR) 0 )
             *p= TEXT(' ');
       }
      
       // null terminate it.  Safe even if nChars==0 because it is 1 TCHAR bigger

       *(lpch+nChars)= (TCHAR) 0;      /* zero terminate the thing */
   
       // Set 'fLog' if first characters in file are ".LOG"
   
       fLog= *lpch++ == TEXT('.') && *lpch++ == TEXT('L') &&
             *lpch++ == TEXT('O') && *lpch == TEXT('G');
    }
   
    if( hNewEdit )
    {
       LocalUnlock( hNewEdit );

       // now it is safe to set the global edit handle

       hEdit= hNewEdit;
    }

    lstrcpy( szFileName, sz );
    SetTitle( sz );
    fUntitled= FALSE;

  /* Pass handle to edit control.  This is more efficient than WM_SETTEXT
   * which would require twice the buffer space.
   */

  /* Bug 7443: If EM_SETHANDLE doesn't have enough memory to complete things,
   * it will send the EN_ERRSPACE message.  If this happens, don't put up the
   * out of memory notification, put up the file to large message instead.
   *  17 November 1991     Clark R. Cyr
   */
    dwEmSetHandle = SETHANDLEINPROGRESS;
    SendMessage (hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, (LPARAM)0);
    if (dwEmSetHandle == SETHANDLEFAILED)
    {
       SetCursor(hStdCursor);

       dwEmSetHandle = 0;
       AlertBox( hwndNP, szNN, szFTL, sz,MB_APPLMODAL|MB_OK|MB_ICONEXCLAMATION);
       New (FALSE);
       SendMessage (hwndEdit, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0);
       return (FALSE);
    }
    dwEmSetHandle = 0;

    PostMessage (hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L);

    /* If file starts with ".LOG" go to end and stamp date time */
    if (fLog)
    {
       SendMessage( hwndEdit, EM_SETSEL, (WPARAM)nChars, (LPARAM)nChars);
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);
       InsertDateTime(TRUE);
    }

    /* Move vertical thumb to correct position */
    SetScrollPos (hwndNP,
                  SB_VERT,
                  (int) SendMessage (hwndEdit, WM_VSCROLL, EM_GETTHUMB, 0L),
                  TRUE);

    /* Now display text */
    SendMessage( hwndEdit, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0 );
    InvalidateRect( hwndEdit, (LPRECT)NULL, TRUE );
    UpdateWindow( hwndEdit );

    SetCursor(hStdCursor);

    return( TRUE );

} // end of LoadFile()

/* New Command - reset everything
 */

void FAR New (BOOL  fCheck)
{
    HANDLE hTemp;
    TCHAR* pSz;

    if (!fCheck || CheckSave (FALSE))
    {
       SendMessage( hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT("") );
       fUntitled= TRUE;
       lstrcpy( szFileName, szUntitled );
       SetTitle(szFileName );
       SendMessage( hwndEdit, EM_SETSEL, 0, 0L );
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );

       // resize of 1 NULL character i.e. zero length

       hTemp= LocalReAlloc( hEdit, sizeof(TCHAR), LMEM_MOVEABLE );
       if( hTemp )
       {
          hEdit= hTemp;
       }

       // null terminate the buffer.  LocalReAlloc won't do it
       // because in all cases it is not growing which is the
       // only time it would zero out anything.

       pSz= LocalLock( hEdit );
       *pSz= TEXT('\0');
       LocalUnlock( hEdit );

       SendMessage (hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, 0L);
       szSearch[0] = (TCHAR) 0;
    }

} // end of New()

/* If sz does not have extension, append ".txt"
 * This function is useful for getting to undecorated filenames
 * that setup apps use.  DO NOT CHANGE the extension.  Too many setup
 * apps depend on this functionality.
 */

void FAR AddExt( TCHAR* sz )
{
    TCHAR*   pch1;
    int      ch;
    DWORD    dwSize;

    dwSize= lstrlen(sz);

    pch1= sz + dwSize;   // point to end

    ch= *pch1;
    while( ch != TEXT('.') && ch != TEXT('\\') && ch != TEXT(':') && pch1 > sz)
    {
        //
        // backup one character.  Do NOT use CharPrev because
        // it sometimes doesn't actually backup.  Some Thai
        // tone marks fit this category but there seems to be others.
        // This is safe since it will stop at the beginning of the
        // string or on delimiters listed above.  bug# 139374 2/13/98
        //
        // pch1= (TCHAR*)CharPrev (sz, pch1);
        pch1--;  // back up
        ch= *pch1;
    }

    if( *pch1 != TEXT('.') )
    {
       if( dwSize + sizeof(".txt") <= MAX_PATH ) {  // avoid buffer overruns
           lstrcat( sz, TEXT(".txt") );
       }
    }

}


/* AlertUser_FileFail( LPTSTR szFileName )
 *
 * szFileName is the name of file that was attempted to open.
 * Some sort of failure on file open.  Alert the user
 * with some monologue box.  At least give him decent
 * error messages.
 */

VOID FAR AlertUser_FileFail( LPTSTR szFileName )
{
    TCHAR msg[256];     // buffer to format message into
    DWORD dwStatus;     // status from FormatMessage
    UINT  style= MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION;

    // Check GetLastError to see why we failed
    dwStatus=
    FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   GetLastError(),
                   GetUserDefaultLangID(),
                   msg,  // where message will end up
                   CharSizeOf(msg), NULL );
    if( dwStatus )
    {
          MessageBox( hwndNP, msg, szNN, style );
    }
    else
    {
        AlertBox( hwndNP, szNN, szDiskError, szFileName, style );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\notepad.c ===
/*
 *   Notepad application
 *   Copyright (C) 1984-2001 Microsoft Inc.
 */


#include "precomp.h"
#include <htmlhelp.h>

#define DeepTrouble() MessageBox(hwndNP, szErrSpace, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND);

UINT     lGotoLine;                  /* line number to goto to */

TCHAR    chMerge;
HWND     hwndNP = 0;                 /* handle to notepad parent window   */
HWND     hwndStatus = 0;             /* handle to notepad status window   */
HWND     hwndEdit = 0;               /* handle to main text control item  */
HANDLE   hEdit;                      /* Handle to storage for edit item   */
HWND     hDlgFind = NULL;            /* handle to modeless FindText window */
HANDLE   hStdCursor;                 /* handle to arrow or beam cursor    */
HANDLE   hWaitCursor;                /* handle to hour glass cursor       */
HANDLE   hInstanceNP;                /* Module instance handle            */
HANDLE   hFont;                      /* handle to Unicode font            */
LOGFONT  FontStruct;                 /* font dialog structure             */
INT      iPointSize=120;             /* current point size unit=1/10 pts  */
TCHAR    szFileName[MAX_PATH+1];     /* Current notepad filename          */
TCHAR    szSearch[CCHKEYMAX];        /* Search string                     */
TCHAR    szReplace[CCHKEYMAX];       /* replace string                    */

BOOL     fUntitled = TRUE;           /* TRUE iff notepad has no title                  */
BOOL     fStatus = FALSE;            /* status bar shown?                              */
BOOL     fLastStatus = FALSE;        /* status bar status when wordwrap was turned off */
INT      dyStatus;                   /* height of status bar                           */


HMENU    hSysMenuSetup;              /* Save Away for disabled Minimize   */

DWORD    dwEmSetHandle = 0;          /* Is EM_SETHANDLE in process?       */
HANDLE   hAccel;                     /* Handle to accelerator table       */
BOOL     fRunBySetup = FALSE;        /* Did SlipUp WinExec us??           */
BOOL     fWrap = 0;                  /* Flag for word wrap                */
TCHAR    szNotepad[] = TEXT("Notepad");/* Name of notepad window class    */

BOOL     fInSaveAsDlg = FALSE;

// Edit control used to AV is EM_FMTLINES was turned off when cursor was near the end
// To get around this, notepad moved to cursor to 0,0 when it turned off wordwrap.
// Users were not happy, so we will put up with possible AVs.  Note: as of June 27, 2001
// we could not repro the AV behavior, so perhaps it is not there anymore.

BOOL     fMLE_is_broken= FALSE;     

/* variables for the new File/Open, File/Saveas,Find Text and Print dialogs */
OPENFILENAME OFN;                     /* passed to the File Open/save APIs */
TCHAR szOpenFilterSpec[CCHFILTERMAX]; /* default open filter spec          */
TCHAR szSaveFilterSpec[CCHFILTERMAX]; /* default save filter spec          */
NP_FILETYPE g_ftOpenedAs=FT_UNKNOWN;  /* current file was opened           */
NP_FILETYPE g_ftSaveAs;               /* current file was opened           */

FINDREPLACE FR;                       /* Passed to FindText()              */
PAGESETUPDLG g_PageSetupDlg;
UINT wFRMsg;                          /* message used in communicating     */
                                      /* with Find/Replace dialog          */

DWORD dwCurrentSelectionStart = 0L;   /* WM_ACTIVATEAPP selection pos      */
DWORD dwCurrentSelectionEnd   = 0L;   /* WM_ACTIVATEAPP selection pos      */
UINT wHlpMsg;                         /* message used in invoking help     */

/* Strings loaded from resource file passed to LoadString at initialization time */
/* To add resource string:
 * 1) create IDS_ macro definition in notepad.h
 * 2) create string in resource file
 * 3) create 'TCHAR*' variable directly below and in notepad.h file
 * 4) add &variable to rgsz
 * 5) increment CSTRINGS
 */
TCHAR *szDiskError =(TCHAR *)IDS_DISKERROR;  /* Can't open File, check disk  */
TCHAR *szFNF       =(TCHAR *)IDS_FNF;        /* File not found               */
TCHAR *szSCBC      =(TCHAR *)IDS_SCBC;       /* Save changes before closing? */
TCHAR *szUntitled  =(TCHAR *)IDS_UNTITLED;   /* Untitled                     */
TCHAR *szNpTitle   =(TCHAR *)IDS_NOTEPAD;    /* Notepad -                    */
TCHAR *szCFS       =(TCHAR *)IDS_CFS;        /* Can't find string            */
TCHAR *szErrSpace  =(TCHAR *)IDS_ERRSPACE;   /* Memory space exhausted       */
TCHAR *szFTL       =(TCHAR *)IDS_FTL;        /* File too large for notepad   */
TCHAR *szNN        =(TCHAR *)IDS_NN;         /* Notepad name                 */

TCHAR *szCommDlgInitErr = (TCHAR*)IDS_COMMDLGINIT; /* common dialog error %x */
TCHAR *szPDIE      =(TCHAR*) IDS_PRINTDLGINIT; /* Print dialog init error    */
TCHAR *szCP        =(TCHAR*) IDS_CANTPRINT;  /* Can't print                  */
TCHAR *szNVF       =(TCHAR*) IDS_NVF;        /* Not a valid filename.        */
TCHAR *szCREATEERR =(TCHAR*) IDS_CREATEERR;  /* cannot create file           */
TCHAR *szNoWW      =(TCHAR*) IDS_NOWW;       /* Too much text to word wrap   */
TCHAR *szMerge     =(TCHAR*) IDS_MERGE1;     /* search string for merge      */
TCHAR *szHelpFile  =(TCHAR*) IDS_HELPFILE;   /* Name of helpfile.            */
TCHAR *szHeader    =(TCHAR*) IDS_HEADER;
TCHAR *szFooter    =(TCHAR*) IDS_FOOTER;
TCHAR *szLetters   =(TCHAR*) IDS_LETTERS;    /* formatting letters in pagesetup */

TCHAR *szAnsiText    = (TCHAR*)IDS_ANSITEXT; /* File/Open ANSI filter spec. string */
TCHAR *szAllFiles    = (TCHAR*)IDS_ALLFILES;   /* File/Open Filter spec. string */
TCHAR *szOpenCaption = (TCHAR*)IDS_OPENCAPTION; /* caption for File/Open dlg */
TCHAR *szSaveCaption = (TCHAR*)IDS_SAVECAPTION; /* caption for File/Save dlg */
TCHAR *szCannotQuit  = (TCHAR*)IDS_CANNOTQUIT;  /* cannot quit during a WM_QUERYENDSESSION */
TCHAR *szLoadDrvFail = (TCHAR*)IDS_LOADDRVFAIL;  /* LOADDRVFAIL from PrintDlg */
TCHAR *szACCESSDENY  = (TCHAR*)IDS_ACCESSDENY; /* Access denied on Open */
TCHAR *szErrUnicode  = (TCHAR*)IDS_ERRUNICODE;  /* Unicode character existence error */
TCHAR *szFontTooBig  = (TCHAR*)IDS_FONTTOOBIG; /* font too big or page too small */

TCHAR *szCommDlgErr   = (TCHAR*) IDS_COMMDLGERR; /* common dialog error %x */
TCHAR *szLineError    = (TCHAR*) IDS_LINEERROR;   /* line number error        */
TCHAR *szLineTooLarge = (TCHAR*) IDS_LINETOOLARGE;/* line number out of range */
TCHAR *szFtAnsi       = (TCHAR*) IDS_FT_ANSI;
TCHAR *szFtUnicode    = (TCHAR*) IDS_FT_UNICODE;
TCHAR *szFtUnicodeBe  = (TCHAR*) IDS_FT_UNICODEBE;
TCHAR *szFtUtf8       = (TCHAR*) IDS_FT_UTF8;
TCHAR *szCurrentPage  = (TCHAR*) IDS_CURRENT_PAGE;

// strings for the status bar
TCHAR *szLineCol        = (TCHAR*) IDS_LINECOL;
TCHAR *szCompressedFile = (TCHAR*) IDS_COMPRESSED_FILE;  
TCHAR *szEncryptedFile  = (TCHAR*) IDS_ENCRYPTED_FILE;   
TCHAR *szHiddenFile     = (TCHAR*) IDS_HIDDEN_FILE;      
TCHAR *szOfflineFile    = (TCHAR*) IDS_OFFLINE_FILE;     
TCHAR *szReadOnlyFile   = (TCHAR*) IDS_READONLY_FILE;    
TCHAR *szSystemFile     = (TCHAR*) IDS_SYSTEM_FILE;      
TCHAR *szFile           = (TCHAR*) IDS_FILE;             


TCHAR **rgsz[CSTRINGS] = {
        &szDiskError,
        &szFNF,
        &szSCBC,
        &szUntitled,
        &szErrSpace,
        &szCFS,
        &szNpTitle,
        &szFTL,
        &szNN,
        &szCommDlgInitErr,
        &szPDIE,
        &szCP,
        &szNVF,
        &szCREATEERR,
        &szNoWW,
        &szMerge,
        &szHelpFile,
        &szAnsiText,
        &szAllFiles,
        &szOpenCaption,
        &szSaveCaption,
        &szCannotQuit,
        &szLoadDrvFail,
        &szACCESSDENY,
        &szErrUnicode,
        &szCommDlgErr,
        &szFontTooBig,
        &szLineError,
        &szLineTooLarge,
        &szFtAnsi,
        &szFtUnicode,
        &szFtUnicodeBe,
        &szFtUtf8,
        &szCurrentPage,
        &szHeader,
        &szFooter,
        &szLineCol,
        &szCompressedFile,
        &szEncryptedFile,
        &szHiddenFile,
        &szOfflineFile,
        &szReadOnlyFile,
        &szSystemFile,
        &szFile,
        &szLetters,
};


HANDLE   fp;          /* file pointer */


#if 0
VOID DisplayFont( LOGFONT* pf )
{
    TCHAR dbuf[100];

    ODS(TEXT("-----------------------\n"));
    wsprintf(dbuf,TEXT("lfHeight          %d\n"),pf->lfHeight); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWidth           %d\n"),pf->lfWidth ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfEscapement      %d\n"),pf->lfEscapement); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOrientation     %d\n"),pf->lfOrientation); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWeight          %d\n"),pf->lfWeight); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfItalic          %d\n"),pf->lfItalic); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfUnderLine       %d\n"),pf->lfUnderline); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfStrikeOut       %d\n"),pf->lfStrikeOut); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfCharSet         %d\n"),pf->lfCharSet); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOutPrecision    %d\n"),pf->lfOutPrecision); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfClipPrecision   %d\n"),pf->lfClipPrecision); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfQuality         %d\n"),pf->lfQuality); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfPitchAndFamily  %d\n"),pf->lfPitchAndFamily); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfFaceName        %s\n"),pf->lfFaceName); ODS(dbuf);

}
#endif

static TCHAR  szPath[MAX_PATH];

void FileDragOpen(void);
VOID NpResetMenu(HWND hWnd);
BOOL SignalCommDlgError(VOID);
VOID ReplaceSel( BOOL bView );

/* FreeGlobal, frees  all global memory allocated. */

void NEAR PASCAL FreeGlobal()
{
    if(g_PageSetupDlg.hDevMode)
    {
        GlobalFree(g_PageSetupDlg.hDevMode);
    }

    if(g_PageSetupDlg.hDevNames)
    {
        GlobalFree(g_PageSetupDlg.hDevNames);
    }

    g_PageSetupDlg.hDevMode=  NULL; // make sure they are zero for PrintDlg
    g_PageSetupDlg.hDevNames= NULL;
}

VOID PASCAL SetPageSetupDefaults( VOID )
{
    TCHAR szIMeasure[ 2 ];

    g_PageSetupDlg.lpfnPageSetupHook= PageSetupHookProc;
    g_PageSetupDlg.lpPageSetupTemplateName= MAKEINTRESOURCE(IDD_PAGESETUP);

    GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szIMeasure, 2 );

    g_PageSetupDlg.Flags= PSD_MARGINS  |
            PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGESETUPTEMPLATE;

    if (szIMeasure[ 0 ] == TEXT( '1' ))
    {
        //  English measure (in thousandths of inches).
        g_PageSetupDlg.Flags |= PSD_INTHOUSANDTHSOFINCHES;
        g_PageSetupDlg.rtMargin.top    = 1000;
        g_PageSetupDlg.rtMargin.bottom = 1000;
        g_PageSetupDlg.rtMargin.left   = 750;
        g_PageSetupDlg.rtMargin.right  = 750;
    }
    else
    {
        //  Metric measure (in hundreths of millimeters).
        g_PageSetupDlg.Flags |= PSD_INHUNDREDTHSOFMILLIMETERS;
        g_PageSetupDlg.rtMargin.top    = 2500;
        g_PageSetupDlg.rtMargin.bottom = 2500;
        g_PageSetupDlg.rtMargin.left   = 2000;
        g_PageSetupDlg.rtMargin.right  = 2000;
    }

}

/* Standard window size proc */
void NPSize (int cxNew, int cyNew)
{

    /* Invalidate the edit control window so that it is redrawn with the new
     * margins. Needed when comming up from iconic and when doing word wrap so
     * the new margins are accounted for.
     */

    InvalidateRect(hwndEdit, (LPRECT)NULL, TRUE);

    // the height of the edit window depends on whether the status bar is
    // displayed.
    MoveWindow (hwndEdit, 0, 0, cxNew, cyNew - (fStatus?dyStatus:0), TRUE);

}

// NpSaveDialogHookProc
//
// Common dialog hook procedure for handling
// the file type while saving.
//

const DWORD s_SaveAsHelpIDs[]=
    {
        IDC_FILETYPE, IDH_FILETYPE,
        IDC_ENCODING, IDH_FILETYPE,
        0, 0
    };

UINT_PTR APIENTRY NpSaveDialogHookProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    INT id;
    POINT pt;
    TCHAR* szSelect;        // selected type

    switch( msg )
    {
        case WM_INITDIALOG:
            // Warning: the order here must be the same as NP_FILETYPE

            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtAnsi );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicode );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicodeBe );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUtf8 );

            szSelect= szFtAnsi;         // default
            g_ftSaveAs= g_ftOpenedAs;   // default: save as same type as opened
            switch( g_ftSaveAs )
            {
                case FT_UNICODE:   szSelect= szFtUnicode;   break;
                case FT_UNICODEBE: szSelect= szFtUnicodeBe; break;
                case FT_UTF8:      szSelect= szFtUtf8;      break;
                default: break;
            }

            SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)szSelect );
            break;

        case WM_COMMAND:
            g_ftSaveAs= (NP_FILETYPE) SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_GETCURSEL, 0, 0 );
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle,
                      szHelpFile,
                      HELP_WM_HELP,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {
                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);
            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp( (HWND)   wParam,
                              szHelpFile,
                              HELP_CONTEXTMENU,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;
    }
    return( FALSE );
}


// NpOpenDialogHookProc
//
// Common dialog hook procedure for handling
// the file type while opening.
//

UINT_PTR APIENTRY NpOpenDialogHookProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    INT id;
    POINT pt;
    TCHAR* szSelect;        // selected type
    static TCHAR  szPrevFileName[MAX_PATH] = TEXT(""); 

    switch( msg )
    {
        case WM_INITDIALOG:
            // Warning: the order here must be the same as NP_FILETYPE

            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtAnsi );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicode );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicodeBe );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUtf8 );

            szSelect= szFtAnsi;         // default
            switch( g_ftOpenedAs )
            {
                case FT_UNICODE:   szSelect= szFtUnicode;   break;
                case FT_UNICODEBE: szSelect= szFtUnicodeBe; break;
                case FT_UTF8:      szSelect= szFtUtf8;      break;
                default: break;
            }

            // set the current filetype.
            SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)szSelect );
            break;

        case WM_COMMAND:
            g_ftOpenedAs= (NP_FILETYPE) SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_GETCURSEL, 0, 0 );
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle,
                      szHelpFile,
                      HELP_WM_HELP,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {
                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);
            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp( (HWND)   wParam,
                              szHelpFile,
                              HELP_CONTEXTMENU,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;

            
         case WM_NOTIFY:
         {
            LPOFNOTIFY pofn;
            TCHAR      szFileName[MAX_PATH]; 
            BYTE       szFileBuffer[BUFFER_TEST_SIZE];
            HANDLE     hFile;
            DWORD      dwBytesRead;
            
            // process the message when the file selection changes.
            pofn = (LPOFNOTIFY)lParam;
            switch (pofn->hdr.code)
            {
                case CDN_SELCHANGE:
                {                        
                    // get the filename.
                    if (CommDlg_OpenSave_GetFilePath(GetParent(hWnd), szFileName, sizeof(szFileName)/sizeof(TCHAR)) > 0)
                    {
                        // if same file as the previous file, don't do anything.
                        if (lstrcmpi(szFileName, szPrevFileName) == 0)
                            break;

                        // open the file.
                        hFile = CreateFile(szFileName,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                        if (hFile != INVALID_HANDLE_VALUE)
                        {
                            // if the file read fails, just quit.
                            if ( (ReadFile(hFile, szFileBuffer, BUFFER_TEST_SIZE, &dwBytesRead, NULL) <= 0) || dwBytesRead == 0)
                            {
                                CloseHandle(hFile);
                                break;
                            }

                            // determine the file type based on dwBytesRead bytes of the file.
                            g_ftOpenedAs = fDetermineFileType(szFileBuffer, dwBytesRead);

                            // set the dropdown filetype to the filetype we think based on the initial part of the file.
                            szSelect = szFtAnsi;         // default
                            switch( g_ftOpenedAs )
                            {
                                case FT_UNICODE:   szSelect= szFtUnicode;   break;
                                case FT_UNICODEBE: szSelect= szFtUnicodeBe; break;
                                case FT_UTF8:      szSelect= szFtUtf8;      break;
                                default: break;
                            }

                            SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)szSelect );            

                            // cleanup.
                            lstrcpy(szPrevFileName, szFileName);
                            CloseHandle(hFile);                           

                        }
                    }                                    

                    break;
                }
            }

         }
                    
    }
    return( FALSE );
}

// GotoAndScrollInView
//
// Put the cursor at the begining of a line, and scroll the
// editbox so the user can see it.
//
// If there is a failure, it just leaves the cursor where it is.
//

VOID GotoAndScrollInView( INT OneBasedLineNumber )
{
    UINT CharIndex;
    CharIndex= (UINT) SendMessage( hwndEdit,
                                   EM_LINEINDEX,
                                   OneBasedLineNumber-1,
                                   0 );
    if( CharIndex != (UINT) -1 )
    {
        SendMessage( hwndEdit, EM_SETSEL, CharIndex, CharIndex);
        SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
    }

}



/* ** Notepad command proc - called whenever notepad gets WM_COMMAND
      message.  wParam passed as cmd */
INT NPCommand(
    HWND     hwnd,
    WPARAM   wParam,
    LPARAM   lParam )
{
    HWND     hwndFocus;
    LONG     lSel;
    TCHAR    szNewName[MAX_PATH] = TEXT("");      /* New file name */
    FARPROC  lpfn;
    LONG     style;
    DWORD    rc;
    RECT     rcClient;

    switch (LOWORD(wParam))
    {
        case M_EXIT:
            PostMessage(hwnd, WM_CLOSE, 0, 0L);
            break;

        case M_NEW:
            New(TRUE);
            break;

        case M_OPEN:
            if (CheckSave(FALSE))
            {
                NP_FILETYPE  g_ftOldOpenedAs = g_ftOpenedAs;

                /* set up the variable fields of the OPENFILENAME struct.
                 * (the constant fields have been set in NPInit()
                 */
                OFN.lpstrFile         = szNewName;
                lstrcpy(szNewName, TEXT("*.txt") ); /* set default selection */
                OFN.lpstrTitle        = szOpenCaption;

                /* ALL non-zero long pointers must be defined immediately
                 * before the call, as the DS might move otherwise.
                 * 12 February 1991    clarkc
                 */
                OFN.lpstrFilter       = szOpenFilterSpec;
                OFN.lpstrDefExt       = TEXT("txt");
                /* Added OFN_FILEMUSTEXIST to eliminate problems in LoadFile.
                 * 12 February 1991    clarkc
                 */
                OFN.Flags          = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                                     OFN_EXPLORER         |
                                     OFN_ENABLESIZING     |
                                     OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

                OFN.nFilterIndex   = FILE_TEXT;
              
                // show encoding listbox
                OFN.lpTemplateName= TEXT("NpEncodingDialog");
                OFN.lpfnHook= NpOpenDialogHookProc;


                if( GetOpenFileName( (LPOPENFILENAME)&OFN ) )
                {
                   HANDLE oldfp= fp;                  

                   fp= CreateFile( szNewName,            // filename
                                   GENERIC_READ,         // access mode
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,                 // security descriptor
                                   OPEN_EXISTING,        // how to create
                                   FILE_ATTRIBUTE_NORMAL,// file attributes
                                   NULL);                // hnd to file attrs
                   /* Try to load the file and reset fp if failed */
                   if( !LoadFile( szNewName, g_ftOpenedAs ) )
                   {
                      fp= oldfp;
                      g_ftOpenedAs = g_ftOldOpenedAs;
                   }
                }
                else
                {
                    g_ftOpenedAs = g_ftOldOpenedAs;
                    SignalCommDlgError();
                }
            }
            break;

        case M_SAVE:
            /* set up the variable fields of the OPENFILENAME struct.
             * (the constant fields have been sel in NPInit()
             */
            g_ftSaveAs = g_ftOpenedAs;
            if( !fUntitled && SaveFile( hwndNP, szFileName, FALSE ) )
               break;

            /* fall through */

        case M_SAVEAS:

            OFN.lpstrFile       = szNewName;
            OFN.lpstrTitle      = szSaveCaption;
            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */
            OFN.Flags = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                        OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                        OFN_EXPLORER         |
                        OFN_ENABLESIZING     |
                        OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName= TEXT("NpEncodingDialog");
            OFN.lpfnHook= NpSaveDialogHookProc;

            /* ALL non-zero long pointers must be defined immediately
             * before the call, as the DS might move otherwise.
             * 12 February 1991    clarkc
             */
            OFN.lpstrFilter       = szSaveFilterSpec;
            OFN.lpstrDefExt       = TEXT("txt");

            if (!fUntitled)
            {
                lstrcpyn(szNewName, szFileName, MAX_PATH); /* set default selection */
            }
            else
            {
                lstrcpy (szNewName, TEXT("*.txt") );
            }

            fInSaveAsDlg = TRUE;

            OFN.nFilterIndex= FILE_TEXT;

            //
            // Do common dialog to save file
            //

            if (GetSaveFileName(&OFN))
            {

               if( SaveFile(hwnd, szNewName, TRUE) )
               {
                  lstrcpyn( szFileName, szNewName, MAX_PATH);
                  g_ftOpenedAs= g_ftSaveAs;
               }
            }
            else
            {
                SignalCommDlgError();
            }

            fInSaveAsDlg = FALSE;
            break;

        case M_SELECTALL:
            {
                HMENU    hMenu;

                hMenu = GetMenu(hwndNP);
                lSel = (LONG) SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, 0L);
                SendMessage (hwndEdit, EM_SETSEL, 0, lSel );
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
                EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_GRAYED);
                break;
            }

        case M_REPLACE:
            if( hDlgFind )
            {
               SetFocus( hDlgFind );
            }
            else
            {
               FR.Flags= FR_HIDEWHOLEWORD | FR_REPLACE;
               FR.lpstrReplaceWith= szReplace;
               FR.wReplaceWithLen= CCHKEYMAX;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = ReplaceText( &FR );
            }
            break;

        case M_FINDNEXT:
            if (szSearch[0])
            {
               Search(szSearch);
               break;
            }
            /* else fall thro' a,d bring up "find" dialog */

        case M_FIND:
            if (hDlgFind)
            {
               SetFocus(hDlgFind);
            }
            else
            {
               FR.Flags= FR_DOWN | FR_HIDEWHOLEWORD;
               FR.lpstrReplaceWith= NULL;
               FR.wReplaceWithLen= 0;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = FindText((LPFINDREPLACE)&FR);
            }
            break;

        case M_GOTO:
            {
                INT  Result;

                Result= (INT)DialogBox( hInstanceNP,
                                        MAKEINTRESOURCE(IDD_GOTODIALOG),
                                        hwndNP,
                                        GotoDlgProc );

                //
                // move cursor only if ok pressed and line number ok
                //

                if( Result == 0 )
                {
                    GotoAndScrollInView( lGotoLine );
                }
            }
            break;

        case M_ABOUT:
            ShellAbout(hwndNP,
                       szNN,
                       TEXT(""),
                       LoadIcon(hInstanceNP,
                                (LPTSTR)MAKEINTRESOURCE(ID_ICON)));

            break;

        case M_HELP:
            HtmlHelpA(GetDesktopWindow(), "notepad.chm", HH_DISPLAY_TOPIC, 0L);
            break;

        case M_CUT:
        case M_COPY:
        case M_CLEAR:
            lSel = (LONG)SendMessage (hwndEdit, EM_GETSEL, 0, 0L);
            if (LOWORD(lSel) == HIWORD(lSel))
               break;

        case M_PASTE:
            /* If notepad parent or edit window has the focus,
               pass command to edit window.
               make sure line resulting from paste will not be too long. */
            hwndFocus = GetFocus();
            if (hwndFocus == hwndEdit || hwndFocus == hwndNP)
            {
                PostMessage(hwndEdit, LOWORD(wParam), 0, 0);
            }
            break;

        case M_DATETIME:
            InsertDateTime(FALSE);
            break;

        case M_UNDO:
            SendMessage (hwndEdit, EM_UNDO, 0, 0L);
            break;

        case M_WW:
            style= (!fWrap) ? ES_STD : (ES_STD | WS_HSCROLL);
            if( NpReCreate( style ) )
            {
                fWrap= !fWrap;
            }
            else
            {
                MessageBox(hwndNP, szNoWW, szNN,
                           MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
            }

            // disable the status bar
            // Line numbers when wordwrap is on are very confusing for now.  Just turn them
            // off until we better understand what the user wants to see.
            if (fWrap)
            {
                HMENU hMenu;

                // Uncheck the StatusBar and remove it.
                fLastStatus= fStatus;      // remember for when wordwrap  gets turned off
                if( fStatus ) 
                {
                    SendMessage(hwnd, WM_COMMAND, M_STATUSBAR, 0L);
                }

                hMenu = GetMenu(hwndNP);
                CheckMenuItem (GetSubMenu(hMenu, 3), M_STATUSBAR, MF_UNCHECKED);
                EnableMenuItem(GetSubMenu(hMenu, 3), M_STATUSBAR, MF_GRAYED);
            }
            // enable the status bar
            else
            {
                HMENU hMenu;

                hMenu = GetMenu(hwndNP);
                EnableMenuItem(GetSubMenu(hMenu, 3), M_STATUSBAR, MF_ENABLED);

                // change the statusbar status to what it was before wordwrap was turned on
                if( fLastStatus ) 
                {
                   SendMessage( hwnd, WM_COMMAND, M_STATUSBAR, 0L);
                }
            }

            break;

        case M_STATUSBAR:

            // hide/show the statusbar and also redraw the edit window accordingly.
            GetClientRect(hwndNP, &rcClient);

            if ( fStatus )
            {
                fStatus = FALSE;
                ShowWindow ( hwndStatus, SW_HIDE );
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
            }
            else
            {
                fStatus = TRUE;
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
                UpdateStatusBar( TRUE );
                ShowWindow( hwndStatus, SW_SHOW );
            }
            break;

        case ID_EDIT:
            break;

        case M_PRINT:
            PrintIt( UseDialog );
            break;

        case M_PAGESETUP:
            TryPrintDlgAgain:
            
            if( PageSetupDlg(&g_PageSetupDlg) )
            {
                //  We know it's okay to copy these strings over...
                lstrcpy(chPageText[HEADER], chPageTextTemp[HEADER]);
                lstrcpy(chPageText[FOOTER], chPageTextTemp[FOOTER]);
            }
            else
            {
                rc= CommDlgExtendedError();

                if( rc == PDERR_PRINTERNOTFOUND ||
                    rc == PDERR_DNDMMISMATCH    ||
                    rc == PDERR_DEFAULTDIFFERENT )
                  {
                      FreeGlobal();
                      g_PageSetupDlg.hDevMode= g_PageSetupDlg.hDevNames= 0;
                      goto TryPrintDlgAgain;
                  }

                // Check for Dialog Failure

                SignalCommDlgError( );

            }
            break;

        case M_SETFONT:
        {
            CHOOSEFONT  cf;
            HFONT       hFontNew;
            HDC         hDisplayDC;     // display DC

            hDisplayDC= GetDC(NULL);    // try to get display DC
            if( !hDisplayDC )
                break;

            // calls the font chooser (in commdlg)
            // We set lfHeight; choosefont returns ipointsize
            //

            cf.lStructSize = sizeof(CHOOSEFONT);
            cf.hwndOwner = hwnd;
            cf.lpLogFont = &FontStruct;         // filled in by init
            FontStruct.lfHeight= -MulDiv(iPointSize,GetDeviceCaps(hDisplayDC,LOGPIXELSY),720);
 
            // We filter out useless stuff here
            // We tried CF_NOSCRIPTSEL, but the FE had fits.
            //    Even though it looks useless, it changes the font that gets mapped on FE builds.
            //    Even though we ignore the lfCharSet that gets returned, we have the "right"
            //    font according to the FE guys.  It might make sense to use lfCharSet to
            //    convert the ansi file when it is converted to Unicode, but this might be
            //    confusing.
 
            cf.Flags = CF_INITTOLOGFONTSTRUCT |
                       CF_SCREENFONTS         | 
                       CF_NOVERTFONTS         |
                       // CF_NOSCRIPTSEL         |  // windows bug# 7770 (April 10,2001)
                       0;
            cf.rgbColors = 0;                   // only if cf_effects
            cf.lCustData = 0;                   // for hook function
            cf.lpfnHook = (LPCFHOOKPROC) NULL;
            cf.lpTemplateName = (LPTSTR) NULL;
            cf.hInstance = NULL;
            cf.lpszStyle = NULL;                // iff cf_usestyle
            cf.nFontType = SCREEN_FONTTYPE;
            cf.nSizeMin  = 0;  // iff cf_limitsize
            cf.nSizeMax  = 0;  // iff cf_limitsize
            ReleaseDC( NULL, hDisplayDC );

            if( ChooseFont(&cf) )
            {
                SetCursor( hWaitCursor );        // may take some time
                
                hFontNew= CreateFontIndirect(&FontStruct);
                if( hFontNew )
                {
                   DeleteObject( hFont );
                   hFont= hFontNew;
                   SendMessage( hwndEdit, WM_SETFONT,
                               (WPARAM)hFont, MAKELPARAM(TRUE, 0));
                   iPointSize= cf.iPointSize;  // remember for printer
                }
                SetCursor( hStdCursor );
            }
            break;
        }

        default:
            return FALSE;
    }
    return TRUE;
}


// for some reason, this procedure tries to maintain
// a valid 'fp' even though I believe it does not need
// to be.
void FileDragOpen(void)
{
    HANDLE oldfp;

    oldfp= fp;       // remember in case of error

    if( CheckSave(FALSE) )
    {

         fp= CreateFile( szPath,               // filename
                         GENERIC_READ,         // access mode
                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                         NULL,                 // security descriptor
                         OPEN_EXISTING,        // how to create
                         FILE_ATTRIBUTE_NORMAL,// file attributes
                         NULL);                // hnd to file attrs

       if( fp == INVALID_HANDLE_VALUE )
       {
          AlertUser_FileFail( szPath );

          // Restore fp to original file.
          fp= oldfp;
       }
       /* Try to load the file and reset fp if failed */
       else if( !LoadFile( szPath, FT_UNKNOWN ) )
       {
           fp= oldfp;
       }
    }
}


/* Proccess file drop/drag options. */
void doDrop (WPARAM wParam, HWND hwnd)
{
   /* If user dragged/dropped a file regardless of keys pressed
    * at the time, open the first selected file from file manager. */

    if (DragQueryFile ((HANDLE)wParam, 0xFFFFFFFF, NULL, 0)) /* # of files dropped */
    {
       DragQueryFile ((HANDLE)wParam, 0, szPath, CharSizeOf(szPath));
       SetActiveWindow (hwnd);
       FileDragOpen();
    }
    DragFinish ((HANDLE)wParam);  /* Delete structure alocated for WM_DROPFILES*/
}

/* ** if notepad is dirty, check to see if user wants to save contents */
BOOL FAR CheckSave (BOOL fSysModal)
{
    INT    mdResult = IDOK;
    TCHAR  szNewName[MAX_PATH] = TEXT("");      /* New file name */
    TCHAR *pszFileName;

/* If it's untitled and there's no text, don't worry about it */
    if (fUntitled && !SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, (LPARAM)0))
        return (TRUE);

    if (SendMessage (hwndEdit, EM_GETMODIFY, 0, 0L))
    {
       if( fUntitled )
           pszFileName= szUntitled;
       else
           pszFileName= szFileName;

       // put up message box
       fInSaveAsDlg= TRUE;     // inform wm_queryendsession that we are trying to save

       mdResult= AlertBox( hwndNP, szNN, szSCBC, pszFileName,
       (WORD)((fSysModal ? MB_SYSTEMMODAL :
                           MB_APPLMODAL)|MB_YESNOCANCEL|MB_ICONEXCLAMATION));
       fInSaveAsDlg= FALSE;

       if( mdResult == IDYES )
       {
          if( fUntitled )
          {
             lstrcpy( szNewName, TEXT("*.txt") );
SaveFilePrompt:
             OFN.lpstrFile        = szNewName;
             OFN.lpstrTitle       = szSaveCaption;

            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */

            OFN.Flags = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                        OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                        OFN_EXPLORER         |
                        OFN_ENABLESIZING     |
                        OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName= TEXT("NpEncodingDialog");
            OFN.lpfnHook= NpSaveDialogHookProc;

            /* ALL non-zero long pointers must be defined immediately
             * before the call, as the DS might move otherwise.
             * 12 February 1991    clarkc
             */
             OFN.lpstrFilter       = szSaveFilterSpec;
             OFN.lpstrDefExt       = TEXT("txt");

             OFN.nFilterIndex= FILE_TEXT;

             //
             // Set dialog checkmark by current file type
             //

             fInSaveAsDlg = TRUE;
             if (GetSaveFileName(&OFN))
             {
                // since SaveFile() uses near ptr to name (obs.)
                lstrcpy(szNewName, OFN.lpstrFile);
                if( SaveFile(hwndNP, szNewName, TRUE) )
                {
                   lstrcpy(szFileName, szNewName);
                   g_ftOpenedAs= g_ftSaveAs;
                }
                else
                {      // Fixing close without saving file when disk-full
                   lstrcpy(szNewName, szFileName);
                   goto SaveFilePrompt;
                }
             }
             else
             {
                mdResult= IDCANCEL;       /* Don't exit Program */
                if( CommDlgExtendedError() )/* Dialog box failed, Lo-mem*/
                   DeepTrouble();
             }

             fInSaveAsDlg = FALSE;
          }
          else
          {
            // initialize the save type.
             g_ftSaveAs = g_ftOpenedAs;
             if( SaveFile(hwndNP, szFileName, FALSE) )
                return(TRUE);
             lstrcpy(szNewName, szFileName);
             goto SaveFilePrompt;
          }
       }
    }
    return (mdResult != IDCANCEL);
}


/* Notepad window class procedure */
LRESULT FAR NPWndProc(
        HWND       hwnd,
        UINT       message,
        WPARAM     wParam,
        LPARAM     lParam)
{
    RECT rc;
    LPFINDREPLACE lpfr;
    DWORD dwFlags;
    HANDLE hMenu;
    INT iParts[2];


    switch (message)
    {
/* If we're being run by Setup and it's the system menu, be certain that
 * the minimize menu item is disabled.  Note that hSysMenuSetup is only
 * initialized if Notepad is being run by Setup.  Don't use it outside
 * the fRunBySetup conditional!    28 June 1991    Clark Cyr
 */
        case WM_INITMENUPOPUP:
            if (fRunBySetup && HIWORD(lParam))
               EnableMenuItem(hSysMenuSetup,SC_MINIMIZE,MF_GRAYED|MF_DISABLED);
            break;

        case WM_SYSCOMMAND:
            if (fRunBySetup)
            {
                /* If we have been spawned by SlipUp we need to make sure the
                 * user doesn't minimize us or alt tab/esc away.
                 */
                if (wParam == SC_MINIMIZE ||
                    wParam == SC_NEXTWINDOW ||
                    wParam == SC_PREVWINDOW)
                    break;
            }
            DefWindowProc(hwnd, message, wParam, lParam);
            break;

        case WM_SETFOCUS:
            if (!IsIconic(hwndNP))
            {
               SetFocus(hwndEdit);
            }
            break;

        case WM_KILLFOCUS:
            SendMessage (hwndEdit, message, wParam, lParam);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_CLOSE:

            // Save any globals in the registry if need be

            SaveGlobals();

            if (CheckSave(FALSE))
            {
                /* Exit help */
                if(!WinHelp(hwndNP, (LPTSTR)szHelpFile, HELP_QUIT, 0))
                    DeepTrouble();

                DestroyWindow(hwndStatus);
                DestroyWindow(hwndNP);
                DeleteObject(hFont);
            }

            break;

        case WM_QUERYENDSESSION:
            if (fInSaveAsDlg)
            {
                MessageBeep (0);
                MessageBeep (0);
                MessageBox (hwndNP, szCannotQuit, szNN, MB_OK|MB_SYSTEMMODAL);
                return FALSE;
            }
            else
                return (CheckSave(TRUE));
            break;


        case WM_ACTIVATEAPP:
            if (wParam)
            {
            /* This causes the caret position to be at the end of the selection
             * but there's no way to ask where it was or set it if known.  This
             * will cause a caret change when the selection is made from bottom
             * to top.
             */
                if( dwCurrentSelectionStart != 0 || dwCurrentSelectionEnd != 0 )
                {
                   SendMessage( hwndEdit, EM_SETSEL,
                                dwCurrentSelectionStart,
                                dwCurrentSelectionEnd );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
                }
            }
            else
            {
                SendMessage( hwndEdit, EM_GETSEL,
                            (WPARAM) &dwCurrentSelectionStart,
                            (LPARAM) &dwCurrentSelectionEnd);
                if (dwCurrentSelectionStart == dwCurrentSelectionEnd)
                {
                    dwCurrentSelectionStart = 0L;
                    dwCurrentSelectionEnd = 0L;
                }
                else
                {
                   SendMessage (hwndEdit, EM_SETSEL, dwCurrentSelectionStart,
                                dwCurrentSelectionEnd);
                   SendMessage (hwndEdit, EM_SCROLLCARET, 0, 0);
                }
            }
            break;

        case WM_ACTIVATE:
            if ((LOWORD(wParam) == WA_ACTIVE       ||
                 LOWORD(wParam) == WA_CLICKACTIVE) &&
                !IsIconic(hwndNP)
               )
               {
                   // active doesn't always mean foreground (ntbug# 53048)
                   if( GetForegroundWindow() == hwndNP )
                   {
                       SetFocus(GetForegroundWindow());
                   }
               }
            break;

        case WM_SIZE:
            switch (wParam)
            {
                case SIZENORMAL:
                case SIZEFULLSCREEN:

                    // resize the status window.
                    SendMessage (hwndStatus, WM_SIZE, 0, 0L);
                    iParts[0] = 3 * (MAKEPOINTS(lParam).x)/4;
                    iParts[1] = -1;

                    // Divide the status window into two parts
                    SendMessage(hwndStatus, SB_SETPARTS, (WPARAM) sizeof(iParts)/sizeof(INT), (LPARAM) &iParts); 

                    NPSize(MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y);
                    break;

                case SIZEICONIC:
                    return (DefWindowProc(hwnd, message, wParam, lParam));
                    break;
                }
            break;

        case WM_INITMENU:
            NpResetMenu( hwnd );
            break;

        //
        // Some keyboards come with a "Search" button which the shell team
        // wanted us to handle.  See ntbug# 380067
        //

        case WM_APPCOMMAND:

            if( ( GET_APPCOMMAND_LPARAM(lParam) == APPCOMMAND_BROWSER_SEARCH ) ) 
            {
                NPCommand(hwnd, M_FIND, 0);
                break;
            }
            // otherwise fall through
 
        case WM_COMMAND:

            if ((HWND)(lParam) == hwndEdit &&
                (HIWORD(wParam) == EN_ERRSPACE ||
                 HIWORD(wParam) == EN_MAXTEXT))
            {
                if (dwEmSetHandle == SETHANDLEINPROGRESS)
                    dwEmSetHandle = SETHANDLEFAILED;
                else
                    DeepTrouble();
                return 0L;
            }

            if (!NPCommand(hwnd, wParam, lParam))
               return (DefWindowProc(hwnd, message, wParam, lParam));
            break;


        case WM_WININICHANGE:
            // Ignore for now.
            // If you put this back in, be sure it handles both
            // the metric change and the decimal change.
            //NpWinIniChange ();
            break;

        case WM_DROPFILES: /*case added 03/26/91 for file drag/drop support*/
            doDrop (wParam,hwnd);
            break;

        case PWM_CHECK_HKL: /* private message: corresponding to HKL change message */
            {
                LPARAM lParam = 0;

                if (PRIMARYLANGID(LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0))) == LANG_JAPANESE) {
                    /*
                     * If new current HKL is Japanese, handle the result string at once.
                     */
                    lParam = EIMES_GETCOMPSTRATONCE;
                }
                SendMessage(hwndEdit, EM_SETIMESTATUS, EMSIS_COMPOSITIONSTRING, lParam);
            }
            break;

        default:
            /* this can be a message from the modeless Find Text window */
            if (message == wFRMsg)
            {
                BOOL bStatus;    // true if found text

                lpfr = (LPFINDREPLACE)lParam;
                dwFlags = lpfr->Flags;

                fReverse = (dwFlags & FR_DOWN      ? FALSE : TRUE);
                fCase    = (dwFlags & FR_MATCHCASE ? TRUE  : FALSE);

                if( dwFlags & FR_FINDNEXT )
                {
                    SetCursor( hWaitCursor );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACE )
                {
                    //
                    // Replace current selection if it matches
                    // then highlight the next occurence of the string.
                    //

                    SetCursor( hWaitCursor );
                    ReplaceSel( TRUE );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACEALL )
                {
                   //
                   // The replace dialog doesn't allow reverse searches
                   // but just it cases it changes, for it to false.
                   //
                   if( fReverse )
                   {
                       fReverse= FALSE;
                   }

                   //
                   // Replace all occurances of text in the file
                   // starting from the top.  Reset the selection
                   // to the top of the file.
                   //
                   SetCursor( hWaitCursor );
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   do
                   {
                      ReplaceSel( FALSE );
                      bStatus= Search( szSearch );
                   }
                   while( bStatus );
                   SetCursor( hStdCursor );
                   //
                   // back to the top of the file.
                   //
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);
                   UpdateStatusBar( TRUE );

                }
                else if (dwFlags & FR_DIALOGTERM)
                    hDlgFind = NULL;   /* invalidate modeless window handle */
                break;
            }
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return (0L);
}

LPTSTR SkipProgramName (LPTSTR lpCmdLine)
{
    LPTSTR  p = lpCmdLine;
    BOOL    bInQuotes = FALSE;

    //
    // Skip executable name
    //
    for (p; *p; p = CharNext(p))
    {
       if ((*p == TEXT(' ') || *p == TEXT('\t')) && !bInQuotes)
          break;

       if (*p == TEXT('\"'))
          bInQuotes = !bInQuotes;
    }

    while (*p == TEXT(' ') || *p == TEXT('\t'))
       p++;

    return (p);
}

/* ** Main loop */

INT WINAPI WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR lpAnsiCmdLine,
   INT cmdShow)
{
    MSG msg;
    VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL) = NULL;
    LPTSTR lpCmdLine = GetCommandLine ();
    HWINEVENTHOOK hEventHook = NULL;


/* PenWindow registration must be before creating an edit class window.
 * Moved here, along with goto statement below for appropriate cleanup.
 *                 10 July 1991    ClarkC
 */
    if ((FARPROC) lpfnRegisterPenApp = GetProcAddress((HINSTANCE)(INT_PTR)(GetSystemMetrics(SM_PENWINDOWS)),
        "RegisterPenApp"))
        (*lpfnRegisterPenApp)(1, TRUE);

    if (!NPInit(hInstance, hPrevInstance, SkipProgramName (lpCmdLine), cmdShow))
    {
       msg.wParam = FALSE;
       goto UnRegisterPenWindows;
    }

    // set an event hook to get the cursor position! this event hook is used to update
    // the line & column position of the caret shown in the statusbar.
    hEventHook = SetWinEventHook(EVENT_OBJECT_LOCATIONCHANGE, EVENT_OBJECT_LOCATIONCHANGE, NULL, WinEventFunc, 
                                (DWORD) GetCurrentProcessId(), 0, WINEVENT_OUTOFCONTEXT);
 
    while (GetMessage((LPMSG)&msg, (HWND)NULL, 0, 0))
    {
        //
        // To handle IME status when active KL is changed.
        //
        if (msg.message == WM_INPUTLANGCHANGEREQUEST) {
            //
            // WM_INPUTLANGCHANGE will be *sent* to WndProc,
            // so there's no chance to catch WM_INPUTLANGCHANGE from the frame window.
            // Instead, we post the private message to check the active HKL later.
            //
            PostMessage(hwndNP, PWM_CHECK_HKL, 0, 0);
        }

        if (!hDlgFind || !IsDialogMessage(hDlgFind, &msg))
        {
            if (TranslateAccelerator(hwndNP, hAccel, (LPMSG)&msg) == 0)
            {
               TranslateMessage ((LPMSG)&msg);
               DispatchMessage ((LPMSG)&msg);
            }
        }
    }

    /* Clean up any global allocations */

    FreeGlobal();

    LocalFree( hEdit );

    if (hEventHook)
        UnhookWinEvent(hEventHook);

UnRegisterPenWindows:

    if (lpfnRegisterPenApp)
        (*lpfnRegisterPenApp)(1, FALSE);

    return (int)(msg.wParam);
}


// WinEventFunc is called whenever the location of the caret changes
// in the edit window. The function updates the statusbar with the current
// line number, column of the caret.  This event is called when the mouse is moved.
// If the caret moves without mouse input, the UpdateStatusBar is called.
//
// UpdateStatusBar( TRUE ) is called to force the display being changed.

static DWORD iLastCol;
static DWORD iLastLine;

VOID UpdateStatusBar( BOOL fForceStatus )
{
    DWORD SelStart, SelEnd;
    UINT  iLine, iCol;
    TCHAR szStatusText[128];

    // get the current caret position.
    SendMessage(hwndEdit,EM_GETSEL,(WPARAM) &SelStart,(WPARAM)&SelEnd);

    // the line numbers are 1 based instead 0 based. hence add 1.
    iLine = (UINT)SendMessage( hwndEdit, EM_LINEFROMCHAR, SelStart, 0 ) + 1;
    iCol = SelStart - (UINT)SendMessage( hwndEdit, EM_LINEINDEX, iLine-1, 0 ) + 1;

    // don't bother to update status if it hasn't changed
    if( fForceStatus || (iCol!=iLastCol) || (iLine!=iLastLine) )
    {
        // prepare and display the statusbar.
        // make sure you don't overflow the buffer boundary.
        _sntprintf(szStatusText, sizeof(szStatusText)/sizeof(TCHAR) -1, szLineCol, iLine, iCol);
        szStatusText[ sizeof(szStatusText)/sizeof(TCHAR) -1 ] = TEXT('\0');
        SetStatusBarText(szStatusText, 1);
            
    }

    iLastCol=  iCol;
    iLastLine= iLine;

};

VOID CALLBACK WinEventFunc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject,
                      LONG idChild, DWORD dwEventThread, DWORD dwmsEventTime)
{
    UpdateStatusBar( FALSE );

}


/* ** Set Window caption text */
void FAR SetTitle( TCHAR  *sz )
{
    TCHAR    szWindowText[MAX_PATH+50];
    TCHAR    szFileName[MAX_PATH];
    HANDLE   hFindFile;
    WIN32_FIND_DATA info;
    TCHAR    szStatusText[128] = TEXT("");
    DWORD    dwAttributes;

    // if "untitled" then don't do all this work...
    if( lstrcmp( sz, szUntitled ) == 0 )
    {
       lstrcpy( szWindowText, sz );
    }
    else
    {
       // get the attributes for file. these will be shown
       // in the status bar.
       dwAttributes = GetFileAttributes(sz);

       // Get real(file system) name for the file.
       hFindFile= FindFirstFile( sz, &info );

       if( hFindFile != INVALID_HANDLE_VALUE )
       {
          lstrcpy( szFileName, info.cFileName );
          FindClose( hFindFile );
       }
       else
          lstrcpy( szFileName, sz );

       GetFileTitle(szFileName, szWindowText, MAX_PATH);



       // Removed the left part of the status bar to show file properties.
       // The correct way to fix it is to make sure that the correct delimiters (like commas),
       // and correct order is used for various localized builds.
#ifdef UNUSED_STATUSBARCODE
       // prepare the status bar text and show 
       // if the file has any special properties (such as hidden, readonly etc.)

        if (dwAttributes & FILE_ATTRIBUTE_COMPRESSED)
            if ((lstrlen(szStatusText) + lstrlen(szCompressedFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)
                lstrcpy(szStatusText, szCompressedFile);

        if (dwAttributes & FILE_ATTRIBUTE_ENCRYPTED)   
            if ((lstrlen(szStatusText) + lstrlen(szEncryptedFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szEncryptedFile);

        if (dwAttributes & FILE_ATTRIBUTE_HIDDEN)
            if ((lstrlen(szStatusText) + lstrlen(szHiddenFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szHiddenFile);

        if (dwAttributes & FILE_ATTRIBUTE_OFFLINE)
            if ((lstrlen(szStatusText) + lstrlen(szOfflineFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szOfflineFile);

        if (dwAttributes & FILE_ATTRIBUTE_READONLY)
        {
            if ((lstrlen(szStatusText) + lstrlen(szReadOnlyFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szReadOnlyFile);
        }

        if (dwAttributes & FILE_ATTRIBUTE_SYSTEM)
            if ((lstrlen(szStatusText) + lstrlen(szSystemFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szSystemFile);

        // if the status did get updated by file properties
        if (*szStatusText != TEXT('\0'))
        {
            // get rid of the last comma
            szStatusText[lstrlen(szStatusText)-1] = TEXT(' ');

            if ((lstrlen(szStatusText) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)           
                lstrcat(szStatusText, szFile);
        }

#endif

    }

    // set the status bar. the Line and Col count is 1 initially for
    // the newly opened file as the caret position is at the first character.
    // SetStatusBarText(szStatusText, 0);
    _sntprintf(szStatusText, sizeof(szStatusText)/sizeof(TCHAR) -1, szLineCol, 1, 1);
    SetStatusBarText(szStatusText, 1);

    lstrcat(szWindowText, szNpTitle);
    SetWindowText(hwndNP, (LPTSTR)szWindowText);

}

/* ** Given filename which may or maynot include path, return pointer to
      filename (not including path part.) */
LPTSTR PASCAL far PFileInPath(
    LPTSTR sz)
{
    LPTSTR pch = sz;
    LPTSTR psz;

    /* Strip path/drive specification from name if there is one */
    /* Ripped out AnsiPrev calls.     21 March 1991  clarkc     */
    for (psz = sz; *psz; psz = CharNext(psz))
      {
        if ((*psz == TEXT(':')) || (*psz == TEXT('\\')))
            pch = psz;
      }

    if (pch != sz)   /* If found slash or colon, return the next character */
        pch++;       /* increment OK, pch not pointing to DB character     */

    return(pch);
}

/* ** Enable or disable menu items according to selection state
      This routine is called when user tries to pull down a menu. */

VOID NpResetMenu( HWND hwnd )
{
    LONG    lsel;
    INT     mfcc;   /* menuflag for cut, copy */
    BOOL    fCanUndo;
    HANDLE  hMenu;
    TCHAR   msgbuf[20];
    BOOL    fPaste= FALSE;
    UINT    uSelState;

    hMenu = GetMenu(hwndNP);

    // cut, copy and delete only get enabled if there is text selected.

    lsel = (LONG)SendMessage(hwndEdit, EM_GETSEL, 0, 0L);
    mfcc = LOWORD(lsel) == HIWORD(lsel) ? MF_GRAYED : MF_ENABLED;
    EnableMenuItem(GetSubMenu(hMenu, 1), M_CUT, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_COPY, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_CLEAR, mfcc);

    // check if the selectall is gray (that means the user has already
    // done select-all) and if the user has deselected - if so, time
    // to re-enable selectall menu.

    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if ((uSelState == MF_GRAYED) && (mfcc == MF_GRAYED))
    {
        EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
    }

    // paste is enabled if there is text in the clipboard

    if( OpenClipboard(hwnd) )
    {
        fPaste= IsClipboardFormatAvailable(CF_TEXT);
        CloseClipboard();
    }
    EnableMenuItem(GetSubMenu(hMenu, 1), M_PASTE, fPaste ? MF_ENABLED : MF_GRAYED);

    // enable 'goto' iff wordwrap is off;  MLE doesn't give good results if word wrap on

    EnableMenuItem(GetSubMenu(hMenu, 1), M_GOTO, fWrap ? MF_GRAYED : MF_ENABLED );

    // enable Undo only if editcontrol says we can do it.

    fCanUndo = (BOOL) SendMessage(hwndEdit, EM_CANUNDO, 0, 0L);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_UNDO, fCanUndo ? MF_ENABLED : MF_GRAYED);

    // check the word wrap item correctly

    CheckMenuItem(GetSubMenu(hMenu, 2), M_WW, fWrap ? MF_CHECKED : MF_UNCHECKED);

    // check the status bar

    CheckMenuItem (GetSubMenu(hMenu, 3), M_STATUSBAR, fStatus ? MF_CHECKED: MF_UNCHECKED );


}


void FAR NpWinIniChange(VOID)
{
   InitLocale ();
}

/* ** Scan sz1 for merge spec.    If found, insert string sz2 at that point.
      Then append rest of sz1 NOTE! Merge spec guaranteed to be two chars.
      returns TRUE if it does a merge, false otherwise. */
BOOL MergeStrings(
    TCHAR    *szSrc,
    TCHAR    *szMerge,
    TCHAR    *szDst)
    {
    register    TCHAR *pchSrc;
    register    TCHAR *pchDst;

    pchSrc = szSrc;
    pchDst = szDst;

    /* Find merge spec if there is one. */
    while ( *pchSrc != chMerge)
        {
        *pchDst++ = *pchSrc;

        /* If we reach end of string before merge spec, just return. */
        if (!*pchSrc++)
            return FALSE;

        }

    /* If merge spec found, insert sz2 there. (check for null merge string */
    if (szMerge)
        {
        while (*szMerge)
            *pchDst++ = *szMerge++;
        }

    /* Jump over merge spec */
    pchSrc++,pchSrc++;

    /* Now append rest of Src String */
    while (*pchDst++ = *pchSrc++);
    return TRUE;

    }

/* ** Post a message box */
INT FAR AlertBox(
    HWND    hwndParent,
    TCHAR    *szCaption,
    TCHAR    *szText1,
    TCHAR    *szText2,
    UINT     style)
{
    INT iResult;                      // result of function
    INT iAllocSize;                   // size needed for message
    TCHAR*  pszMessage;               // combined message

    // Allocate a message buffer assuming there will be a merge.
    // If we cannot do the allocation, tell the user something
    // related to the original problem. (not the allocation failure)
    // Then pray that MessageBox can get enough memory to actually work.

    iAllocSize= (lstrlen(szText1) + (szText2 ? lstrlen(szText2) : 0) + 1 ) * sizeof(TCHAR);

    pszMessage= (TCHAR*) LocalAlloc( LPTR, iAllocSize );

    if( pszMessage )
    {
        MergeStrings( szText1, szText2, pszMessage );
        iResult= MessageBox( hwndParent, pszMessage, szCaption, style );
        LocalFree( (HLOCAL) pszMessage );
    }
    else
    {
        iResult= MessageBox( hwndParent, szText1, szCaption, style );
    }

    return( iResult );
}

// SignalCommDlgError
//
// If a common dialog error occurred, put up reasonable message box.
//
// returns: TRUE if error occurred, FALSE if no error.
//

typedef struct tagMAPERROR
{
    DWORD   rc;            // return code from CommDlgExtendedError()
    PTCHAR* ppszMsg;       // text of message pointer
} MAPERROR;

// errors not in this list get generic "common dialog error %x" message.
static TCHAR* szNull= TEXT("");

MAPERROR maperror[]=
{
    CDERR_DIALOGFAILURE,  &szErrSpace,
    CDERR_INITIALIZATION, &szCommDlgInitErr,
    CDERR_MEMLOCKFAILURE, &szPDIE,
    CDERR_LOADSTRFAILURE, &szErrSpace,
    CDERR_FINDRESFAILURE, &szErrSpace,
    PDERR_LOADDRVFAILURE, &szLoadDrvFail,
    PDERR_GETDEVMODEFAIL, &szErrSpace,
    PDERR_NODEFAULTPRN,   &szNull,          // don't report; common dialog does already
};

BOOL SignalCommDlgError(VOID)
{
    DWORD rc;               // return code
    TCHAR* pszMsg;          // message
    INT    i;
    TCHAR  szBuf[200];      // just for common dialog failure

    rc= CommDlgExtendedError();

    // no failure - just return

    if( rc == 0 )
    {
        return FALSE;
    }

    // some sort of error - pick up message

    pszMsg= NULL;
    for( i=0; i< sizeof(maperror)/sizeof(maperror[0]); i++ )
    {
        if( rc == maperror[i].rc )
        {
            pszMsg= *maperror[i].ppszMsg;
        }
    }

    // if no known mapping - tell user the actual return code
    // this may be a bit confusing, but rare hopefully.

    if( !pszMsg )
    {
        _sntprintf(szBuf, sizeof(szBuf)/sizeof(TCHAR) -1, szCommDlgErr, rc);
        pszMsg= szBuf;
    }

    // popup if there is any message to give user

    if( *pszMsg )
    {
        MessageBox(hwndNP, pszMsg, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND);
    }

    return TRUE;

}

// ReplaceSel
//
// Replace the current selection with string from FR struct
// if the current selection matches our search string.
//
// MLE will show selection if bView is true.
//


VOID ReplaceSel( BOOL bView )
{
    DWORD StartSel;    // start of selected text
    DWORD EndSel;      // end of selected text

    HANDLE hEText;
    TCHAR* pStart;
    DWORD  ReplaceWithLength;  // length of replacement string
    DWORD  FindWhatLength;

    ReplaceWithLength= lstrlen(FR.lpstrReplaceWith);
    FindWhatLength= lstrlen(FR.lpstrFindWhat);

    SendMessage( hwndEdit, EM_GETSEL, (WPARAM) &StartSel, (LPARAM) &EndSel );
    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return;
    }

    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return;
    }

    if(  (EndSel-StartSel) == FindWhatLength )
    {
       if( (fCase &&
            !_tcsncmp(  FR.lpstrFindWhat, pStart+StartSel, FindWhatLength) ) ||
           (!fCase &&
           ( 2 == CompareString(LOCALE_USER_DEFAULT,
                  NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                  FR.lpstrFindWhat, FindWhatLength,
                  pStart+StartSel,  FindWhatLength ) ) ) )
        {
            SendMessage( hwndEdit, EM_REPLACESEL,
                         TRUE, (LPARAM) FR.lpstrReplaceWith);
            SendMessage( hwndEdit, EM_SETSEL,
                         StartSel, StartSel+ReplaceWithLength );

            if( bView )
            {
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
            }
        }
    }

    LocalUnlock( hEText );
}

// GotoDlgProc
//
// Handle the Goto Dialog window processing
//
// Returns:
//
// 1 if successfull
// 0 if not (cancelled)
//
// Modifies global lGotoLine
//

const DWORD s_GotoHelpIDs[] = {
    IDC_GOTO, IDH_GOTO,
    0, 0
};

#define GOTOBUFSIZE 100
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    TCHAR szBuf[GOTOBUFSIZE];
    UINT LineNum;
    DWORD SelStart, SelEnd;
    POINT pt;
    INT id;

    switch (message)
    {
        //
        // initialize input field to size of file
        //
        case WM_INITDIALOG:
            SendMessage(hwndEdit,EM_GETSEL,(WPARAM) &SelStart,(WPARAM)&SelEnd);

            // the line numbers are 1 based instead 0 based. hence add 1.
            LineNum= (UINT)SendMessage( hwndEdit, EM_LINEFROMCHAR, SelStart, 0 ) + 1;
            wsprintf(szBuf, TEXT("%d"), LineNum);
            SetDlgItemText( hDlg, IDC_GOTO, szBuf );
            SetFocus( hDlg );
            return TRUE;
            break;

        // context sensitive help.
        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;

        case WM_CONTEXTMENU:

            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;


        case WM_COMMAND:

            switch (LOWORD(wParam))
            {
                UINT CharIndex;

                case IDC_GOTO:
                    return TRUE;
                    break;

                case IDOK:
                    GetDlgItemText( hDlg, IDC_GOTO, szBuf, GOTOBUFSIZE );

                    // convert all unicode numbers to range L'0' to L'9'

                    FoldString( MAP_FOLDDIGITS, szBuf, -1, szBuf, GOTOBUFSIZE);
                    lGotoLine= _ttol( szBuf );

                    //
                    // see if valid line number
                    //

                    CharIndex= (UINT)SendMessage( hwndEdit,
                                            EM_LINEINDEX,
                                            lGotoLine-1,
                                            0);
                    if( lGotoLine > 0 && CharIndex != -1 )
                    {
                        EndDialog(hDlg, 0);  // successfull
                        return TRUE;
                    }

                    //
                    // Invalid line number
                    // warning user and set to reasonable value
                    //

                    MessageBox( hDlg, szLineTooLarge, szLineError, MB_OK );

                    LineNum= (UINT)SendMessage( hwndEdit, EM_GETLINECOUNT, 0, 0 );
                    wsprintf(szBuf, TEXT("%d"), LineNum);
                    SetDlgItemText( hDlg, IDC_GOTO, szBuf );
                    SetFocus( hDlg );
                    break;

                case IDCANCEL :
                    EndDialog(hDlg, 1 );   // cancelled
                    return TRUE;
                    break;

                default:

                    break;

            } // switch (wParam)

            break;

       default:

             break;

    } // switch (message)


    return FALSE;     // Didn't process a message


} // GotoDlgProc()


// This procedure looks at the iSize bytes pointed by lpFileContents and
// determines based on that the encoding of the file (Ansi, Unicode, Reverse Unicode, UTF8)


NP_FILETYPE fDetermineFileType(LPBYTE lpFileContents, UINT iSize)
{
    NP_FILETYPE ftFileType = FT_ANSI;
    LPTSTR szBuf = (LPTSTR) lpFileContents;

    if (iSize <= 1)
        return ftFileType;

    switch(*szBuf)        
    {
        // look for the standard BOMs.
        case BYTE_ORDER_MARK:
            ftFileType = FT_UNICODE;
            break;

        case REVERSE_BYTE_ORDER_MARK:
            ftFileType = FT_UNICODEBE;
            break;

        // UTF bom has 3 bytes.
        case BOM_UTF8_HALF:            
            if (iSize > 2 && ((BYTE) *((lpFileContents)+2) == BOM_UTF8_2HALF) )
            {
                ftFileType = FT_UTF8;
            }
            break;

        default:
            // Is the file unicode without BOM ?
            if (IsInputTextUnicode(lpFileContents, iSize))
            {
                ftFileType = FT_UNICODE;
            }      
            else
            {
                // Is the file UTF-8 even though it doesn't have UTF-8 BOM ?
                // BUGBUG: the iSize that we pass should be correct so that the string ends on the
                // boundary of an UTF8 character.
                if (IsTextUTF8(lpFileContents, iSize))
                {
                    ftFileType = FT_UTF8;
                }
                // well, it is most likely an ansi file.
                else
                {
                    ftFileType = FT_ANSI;
                }
            }
            break;
        }             

    return ftFileType;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\npinit.c ===
/*
 *   Notepad application
 *
 *      Copyright (C) 1984-1995 Microsoft Inc.
 *
 *      NPInit - One time init for notepad.
 *               Routines are in a separate segment.
 */

#include "precomp.h"


TCHAR chPageText[2][PT_LEN];    /* Strings to hold PageSetup items.        */
TCHAR chPageTextTemp[2][PT_LEN];
TCHAR szPrinterName[256];       /* String to hold printername for PrintTo verb */

static NP_FILETYPE fInitFileType;     /* file type override                      */
static INT fSaveWindowPositions=0;    /* true if we are to save window position  */

static INT g_WPtop,g_WPleft,g_WPDX,g_WPDY;   /* initial window positions          */

/* routines to handle saving and restoring information in the registry.
 *
 * SaveGlobals - saves interesting globals to the registry
 *
 * GetGlobals  - gets interesting globals from the registry
 *
 * Interesting Globals:
 *
 * FontStruct information include calculated pointsize
 * Codepage
 *
 * If we want to save PageSetup info, save the margins in some
 * units (cm for example) and convert on input and output.
 */

/* name of section to save into -- never internationalize */
#define OURKEYNAME TEXT("Software\\Microsoft\\Notepad")

// RegWriteInt - write an integer to the registry

VOID RegWriteInt( HKEY hKey, PTCHAR pszKey, INT iValue )
{
    RegSetValueEx( hKey, pszKey, 0, REG_DWORD, (BYTE*)&iValue, sizeof(INT) );
}

// RegWriteString - write a string to the registry

VOID RegWriteString( HKEY hKey, PTCHAR pszKey, PTCHAR pszValue )
{
    INT len;     // length of string with null in bytes

    len= (lstrlen( pszValue )+1) * sizeof(TCHAR);
    RegSetValueEx( hKey, pszKey, 0, REG_SZ, (BYTE*)pszValue, len );
}

// RegGetInt - Get integer from registry

DWORD RegGetInt( HKEY hKey, PTCHAR pszKey, DWORD dwDefault )
{
    DWORD dwResult= !ERROR_SUCCESS;
    LONG  lStatus= ERROR_SUCCESS;
    DWORD dwSize= sizeof(DWORD);
    DWORD dwType= 0;

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) &dwResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_DWORD )
    {
        dwResult= dwDefault;
    }
    return( dwResult );
}

// RegGetString - get string from registry

VOID RegGetString( HKEY hKey, PTCHAR pszKey, PTCHAR pszDefault, PTCHAR pszResult, INT iCharLen )
{
    LONG  lStatus= !ERROR_SUCCESS;
    DWORD dwSize;      // size of buffer
    DWORD dwType;

    dwSize= iCharLen * sizeof(TCHAR);

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) pszResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_SZ )
    {
        CopyMemory( pszResult, pszDefault, iCharLen*sizeof(TCHAR) );
    }
}


// lfHeight is calculated using PointSize
// lfWidth set by font mapper


VOID SaveGlobals(VOID)
{
    HKEY hKey;    // key to our registry root
    LONG lStatus; // status from RegCreateKey
    WINDOWPLACEMENT wp;

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        return;   // just return quietly
    }

    RegWriteInt( hKey, TEXT("lfEscapement"),     FontStruct.lfEscapement);
    RegWriteInt( hKey, TEXT("lfOrientation"),    FontStruct.lfOrientation);
    RegWriteInt( hKey, TEXT("lfWeight"),         FontStruct.lfWeight);
    RegWriteInt( hKey, TEXT("lfItalic"),         FontStruct.lfItalic);
    RegWriteInt( hKey, TEXT("lfUnderline"),      FontStruct.lfUnderline);
    RegWriteInt( hKey, TEXT("lfStrikeOut"),      FontStruct.lfStrikeOut);
    RegWriteInt( hKey, TEXT("lfCharSet"),        FontStruct.lfCharSet);
    RegWriteInt( hKey, TEXT("lfOutPrecision"),   FontStruct.lfOutPrecision);
    RegWriteInt( hKey, TEXT("lfClipPrecision"),  FontStruct.lfClipPrecision);
    RegWriteInt( hKey, TEXT("lfQuality"),        FontStruct.lfQuality);
    RegWriteInt( hKey, TEXT("lfPitchAndFamily"), FontStruct.lfPitchAndFamily);
    RegWriteInt( hKey, TEXT("iPointSize"),       iPointSize);
    RegWriteInt( hKey, TEXT("fWrap"),            fWrap);
    RegWriteInt( hKey, TEXT("StatusBar"),        fStatus);
    RegWriteInt( hKey, TEXT("fSaveWindowPositions"),fSaveWindowPositions );

    RegWriteString( hKey, TEXT("lfFaceName"), FontStruct.lfFaceName);

    RegWriteString( hKey, TEXT("szHeader"),  chPageText[HEADER] );
    RegWriteString( hKey, TEXT("szTrailer"), chPageText[FOOTER] );
    RegWriteInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
    RegWriteInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
    RegWriteInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
    RegWriteInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );

    RegWriteInt( hKey, TEXT("fMLE_is_broken"), fMLE_is_broken );

    wp.length= sizeof(wp);

    if( GetWindowPlacement( hwndNP, &wp ) )
    {
        RegWriteInt( hKey, TEXT("iWindowPosX"), wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosY"), wp.rcNormalPosition.top);
        RegWriteInt( hKey, TEXT("iWindowPosDX"), wp.rcNormalPosition.right - wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosDY"), wp.rcNormalPosition.bottom - wp.rcNormalPosition.top);
    }

    RegCloseKey( hKey );
}


// GetGlobals
//
// Pick up font information etc that may be saved in the registry.
//
// We are called pretty early in setup and don't have things like hwndNP valid yet.
//

VOID GetGlobals( VOID )
{
    LOGFONT lfDef;          // default logical font
    HFONT   hFont;          // standard font to use
    LONG    lStatus;        // status from RegCreateKey
    HKEY    hKey;           // key into registry

    //
    // quickly get a reasonable set of default parameters
    // for the default font if we need it.
    //

    hFont= GetStockObject( SYSTEM_FIXED_FONT );

    if ( hFont )
    {
        GetObject( hFont, sizeof(LOGFONT), &lfDef );
    }

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        hKey= NULL;   // later calls to RegGet... will return defaults
    }
    FontStruct.lfWidth= 0;



    FontStruct.lfEscapement=     (LONG)RegGetInt( hKey, TEXT("lfEscapement"),     lfDef.lfEscapement);
    FontStruct.lfOrientation=    (LONG)RegGetInt( hKey, TEXT("lfOrientation"),    lfDef.lfOrientation);
    FontStruct.lfWeight=         (LONG)RegGetInt( hKey, TEXT("lfWeight"),         lfDef.lfWeight);
    FontStruct.lfItalic=         (BYTE)RegGetInt( hKey, TEXT("lfItalic"),         lfDef.lfItalic);
    FontStruct.lfUnderline=      (BYTE)RegGetInt( hKey, TEXT("lfUnderline"),      lfDef.lfUnderline);
    FontStruct.lfStrikeOut=      (BYTE)RegGetInt( hKey, TEXT("lfStrikeOut"),      lfDef.lfStrikeOut);

    //
    // We have to preserve lfCharSet because some fonts (symbol, marlett) don't handle 
    // 0 (ANSI_CHARSET) or 1 (DEFAULT_CHARSET), and the font mapper will map to a 
    // different facename.  Later we will see if the CreateFont has the same FaceName
    // and get a more appropriate lfCharSet if need be.
    //

    FontStruct.lfCharSet=        (BYTE)RegGetInt( hKey, TEXT("lfCharSet"),        lfDef.lfCharSet);
    
    FontStruct.lfOutPrecision=   (BYTE)RegGetInt( hKey, TEXT("lfOutPrecision"),   lfDef.lfOutPrecision);
    FontStruct.lfClipPrecision=  (BYTE)RegGetInt( hKey, TEXT("lfClipPrecision"),  lfDef.lfClipPrecision);
    FontStruct.lfQuality=        (BYTE)RegGetInt( hKey, TEXT("lfQuality"),        lfDef.lfQuality);
    FontStruct.lfPitchAndFamily= (BYTE)RegGetInt( hKey, TEXT("lfPitchAndFamily"), lfDef.lfPitchAndFamily);

    //
    // If there is no FaceName in the registry, use the default "Lucida Console"
    // This will show off most of the glyphs except in the FE locales.
    // For FE, we can't font link fonts with the glyphs because they would have to have
    // the exact width as lucida console, or the console/csrss will AV (July 9, 1999)
    //

    RegGetString( hKey, TEXT("lfFaceName"), TEXT("Lucida Console"), FontStruct.lfFaceName, LF_FACESIZE);

    iPointSize= RegGetInt( hKey, TEXT("iPointSize"), 100);
    fWrap=      RegGetInt( hKey, TEXT("fWrap"),      0);
    fStatus=    RegGetInt( hKey, TEXT("StatusBar"),  0);
    fSaveWindowPositions= RegGetInt( hKey, TEXT("fSaveWindowPositions"), 0 );

    // if page settings not in registry, we will use defaults

    RegGetString( hKey, TEXT("szHeader"),  chPageText[HEADER], chPageText[HEADER], PT_LEN );
    RegGetString( hKey, TEXT("szTrailer"), chPageText[FOOTER], chPageText[FOOTER], PT_LEN );

    g_PageSetupDlg.rtMargin.top=    (LONG)RegGetInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
    g_PageSetupDlg.rtMargin.bottom= (LONG)RegGetInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
    g_PageSetupDlg.rtMargin.left=   (LONG)RegGetInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
    g_PageSetupDlg.rtMargin.right=  (LONG)RegGetInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );

    // if window positions in registry use them, otherwise us defaults

    g_WPtop=  RegGetInt( hKey, TEXT("iWindowPosY"),  CW_USEDEFAULT );
    g_WPleft= RegGetInt( hKey, TEXT("iWindowPosX"),  CW_USEDEFAULT );
    g_WPDX=   RegGetInt( hKey, TEXT("iWindowPosDX"), CW_USEDEFAULT );
    g_WPDY=   RegGetInt( hKey, TEXT("iWindowPosDY"), CW_USEDEFAULT );
    

    fMLE_is_broken= RegGetInt( hKey, TEXT("fMLE_is_broken"), FALSE );  // assume edit control works

    if( hKey )
    {
        RegCloseKey( hKey );
    }

}

/*
 * lstrncmpi( str1, str2, len )
 * compares two strings, str1 and str2, up
 * to length 'len' ignoring case.  If they
 * are equal, we will return 0.  Otherwise not 0.
 */

static
INT lstrncmpi( PTCHAR sz1, PTCHAR sz2 )
{
    TCHAR ch1, ch2;
    while( *sz1 )
    {
        ch1= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz1++ );
        ch2= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz2++ );
        if( ch1 != ch2 )
            return 1;
    }
    return 0;                // they are equal
}

static int NPRegister (HANDLE hInstance);

/* GetFileName
 *
 * Parse off filename from command line and put
 * into lpFileName
 */

LPTSTR GetFileName( LPTSTR lpFileName, LPTSTR lpCmdLine )
{
   LPTSTR lpTemp = lpFileName;
   HANDLE hFindFile;
   WIN32_FIND_DATA info;

   /*
   ** Allow for filenames surrounded by double and single quotes
   ** like in longfilenames.
   */
   if( *lpCmdLine == TEXT('\"') || *lpCmdLine == TEXT('\'') )
   {
      TCHAR chMatch = *lpCmdLine;
      DWORD dwSize=0;

      // Copy over filename
      while( *(++lpCmdLine) && (*lpCmdLine != chMatch) && (dwSize<MAX_PATH) )
      {
         *lpTemp++ = *lpCmdLine;
         dwSize++;
      }

      // NULL terminate the filename (no embedded quotes allowed in filenames)
      *lpTemp = TEXT('\0');
   }
   else
   {
      lstrcpyn(lpFileName, lpCmdLine,MAX_PATH);
   }

   /*
   ** Check to see if the unaltered filename exists.  If it does then don't
   ** append a default extension.
   */
   hFindFile= FindFirstFile( lpFileName, &info );

   if( hFindFile != INVALID_HANDLE_VALUE )
   {
      FindClose( hFindFile );
   }
   else
   {
      /*
      ** Add default extension and try again
      */
      AddExt( lpFileName );

      hFindFile= FindFirstFile( lpFileName, &info );

      if( hFindFile != INVALID_HANDLE_VALUE )
      {
         FindClose( hFindFile );
      }
   }

   // return the pointer to the end of the filename.
   return lpCmdLine;
}

/* SizeStrings - Get the total size of the resource strings   */
/* returns size in 'chars' or zero if failure                 */
/* we do this in case the international people really change  */
/* the size of resources.                                     */

/* Read all the strings into a buffer to size them.  Since we  */
/* don't know the maximum size of string resource, we may have */
/* to change the size of the read buffer.  This is done with   */
/* a simple doubling algorithm.                                */

INT SizeStrings(HANDLE hInstance)
{
    INT    iElementSize=280;  // current max size of string
    INT    total;             // total size of resources
    PTCHAR Buf;               // buffer to try putting resources into
    INT    ids;               // identifier number for resource
    INT    len;               // length of one resource

    while( 1 )   // keep looping til all strings can be read
    {
        if( !(Buf= LocalAlloc( LPTR, ByteCountOf(iElementSize) ) ) )
            return 0;    // failure
        for( ids=0, total=0; ids < CSTRINGS; ids++ )
        {
            len= LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), Buf, iElementSize );

            if( len >= iElementSize-1 )
            {
                #if DBG
                    ODS(TEXT("notepad: resource string too long!\n"));
                #endif
                break;
            }
            total += len+1;  // account for null terminator
        }
        LocalFree( Buf );
        if( ids >= CSTRINGS )
            break;
        iElementSize= iElementSize*2;
    }
    return( total );
}


/* InitStrings - Get all text strings from resource file */
BOOL InitStrings (HANDLE hInstance)
{
    TCHAR*   pch;
    INT      cchRemaining;
    INT      ids, cch;

    // allocate memory and lock it down forever.  we have pointers into it.
    // the localrealloc() function will not work well for freeing
    // unused memory because it may (and did) move memory.

    cchRemaining= SizeStrings( hInstance );
    if( !cchRemaining )
        return( FALSE );       // fail because we are out of memory

    pch= LocalAlloc( LPTR, ByteCountOf(cchRemaining) );
    if( !pch )
        return( FALSE );

    cchRemaining= (INT)LocalSize( pch ) / sizeof(TCHAR);
    if( cchRemaining == 0 )    // can't alloc memory - failure
        return( FALSE );

    for( ids = 0; ids < CSTRINGS; ids++ )
    {
       cch= 1 + LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), pch, cchRemaining );
       *rgsz[ids]= pch;
       pch += cch;

       if( cch > cchRemaining )   // should never happen
       {
           MessageBox( NULL, TEXT("Out of RC string space!!"),
                      TEXT("DEV Error!"), MB_OK);
           return( FALSE );
       }

       cchRemaining -= cch;
    }

    /* Get header and footer strings */

    lstrcpyn( chPageText[HEADER], szHeader, PT_LEN ); 
    lstrcpyn( chPageText[FOOTER], szFooter, PT_LEN ); 

    chMerge= *szMerge;
    return (TRUE);
}

/*
 * SkipBlanks( pszText )
 * skips blanks or tabs to either next character or EOL
 * returns pointer to same.
 */
PTCHAR SkipBlanks( PTCHAR pszText )
{
    while( *pszText == TEXT(' ') || *pszText == TEXT('\t') )
        pszText++;

    return pszText;
}


// if /.SETUP option exists in the command line process it.
BOOL ProcessSetupOption (LPTSTR lpszCmdLine)
{
    INT iSta= 0;
    /* Search for /.SETUP in the command line */
    if( !lstrncmpi( TEXT("/.SETUP"), lpszCmdLine ) )
    {
        fRunBySetup = TRUE;
        /* Save system menu handle for INITMENUPOPUP message */
        hSysMenuSetup =GetSystemMenu(hwndNP, FALSE);
        /* Allow exit on ^C, ^D and ^Z                      */
        /* Note that LoadAccelerators must be called before */
        /* TranslateAccelerator is called, true here        */
        hAccel = LoadAccelerators(hInstanceNP, TEXT("SlipUpAcc"));
        lpszCmdLine += 7;
    }
    else
        return FALSE;

    /* Don't offer a minimize button */
    SetWindowLong( hwndNP, GWL_STYLE,
                   WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                   WS_THICKFRAME |                  WS_MAXIMIZEBOX |
                   WS_VSCROLL    | WS_HSCROLL);

    /* skip blanks again to get to filename */
    lpszCmdLine= SkipBlanks( lpszCmdLine );

    if (*lpszCmdLine)
    {
        /* Get the filename. */
        GetFileName(szFileName, lpszCmdLine);

        fp= CreateFile( szFileName,             // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE, // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  //file attributes
                        NULL);                  // hnd of file attrs

        if( fp == INVALID_HANDLE_VALUE )
        {
           DWORD dwErr;

           // Check GetLastError to see why we failed
           dwErr = GetLastError ();
           switch (dwErr)
           {
              case ERROR_ACCESS_DENIED:
                 iSta= AlertBox( hwndNP, szNN, szACCESSDENY, szFileName,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONEXCLAMATION);
                 break;

              case ERROR_FILE_NOT_FOUND:
                 iSta= AlertBox(hwndNP, szNN, szFNF, szFileName,
                      MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONEXCLAMATION);
                 if( iSta == IDYES )
                 {
                    fp= CreateFile( szFileName,            // filename
                                    GENERIC_READ|GENERIC_WRITE,  // access
                                    FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                    NULL,                  // security descrp
                                    OPEN_ALWAYS,           // how to create
                                    FILE_ATTRIBUTE_NORMAL, // file attributes
                                    NULL);                 // hnd of file attrs
                 }
                 break;

              case ERROR_INVALID_NAME:
                 iSta= AlertBox( hwndNP, szNN, szNVF, szFileName,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONEXCLAMATION);
                 break;

              default:
                 iSta= AlertBox(hwndNP, szNN, szDiskError, szFileName,
                          MB_APPLMODAL | MB_OKCANCEL | MB_ICONEXCLAMATION);
                 break;
           }
        }

        if (fp == INVALID_HANDLE_VALUE)
           return (FALSE);
        LoadFile(szFileName, fInitFileType );    // load setup file
    }

    if( iSta == IDCANCEL )
       return( IDCANCEL );
    else
       return( IDYES );
}

/*
 * ProcessShellOptions(lpszCmdLine)
 *
 * If the command line has any options specified by the shell
 * process them.
 * Currently /P <filename> - prints the given file
 *           /PT "filename" "printer name" "Driver dll" "port"
 */
BOOL ProcessShellOptions (LPTSTR lpszCmdLine, int cmdShow)
{
    BOOL   bDefPrinter = TRUE;
    LPTSTR lpszAfterFileName;


    // Is it PrintTo ?
    if( lstrncmpi( TEXT("/PT"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+3 );
        bDefPrinter = FALSE;
    }
    // Or is it Print ?
    else if ( lstrncmpi( TEXT("/P"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+2 );
    }
    else
        return FALSE;

    if (!*lpszCmdLine)
       return FALSE;

    /* Added as per Bug #10923 declaring that the window should show up
     * and then the printing should begin.   29 July 1991  Clark Cyr
     */

    ShowWindow(hwndNP, cmdShow);

    /* Get the filename; have the pointer to the end of the filename */
    lpszAfterFileName= GetFileName (szFileName, lpszCmdLine) + 1;

    if (!bDefPrinter)
    {
        UINT index;
 
        /* extract the printer name from the command line. */
        if (!*lpszAfterFileName)
            return FALSE;

        lpszAfterFileName = SkipBlanks( lpszAfterFileName );

        /* (since we are passing multiple arguments here, the filename, */
        /* the printername have to be in quotes. */
        if( *lpszAfterFileName != TEXT('\"') )
            return FALSE;

        // Copy over printername
        lpszAfterFileName++;            // skip over quote 
        index= 0;
        while( *(lpszAfterFileName)              && 
               *lpszAfterFileName != TEXT('\"' ) &&
               (index+1 < sizeof(szPrinterName)/sizeof(szPrinterName[0]) ) )
        {
            szPrinterName[index++] = *lpszAfterFileName++;
        }

        // NULL terminate the printername (no embedded quotes allowed in printernames)
        szPrinterName[index] = TEXT('\0');
    }


    fp= CreateFile( szFileName,             // filename
                    GENERIC_READ,           // access mode
                    FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                    NULL,                   // security descriptor
                    OPEN_EXISTING,          // how to create
                    FILE_ATTRIBUTE_NORMAL,  // file attributes
                    NULL);                  // hnd of file attrs to copy

    if( fp == INVALID_HANDLE_VALUE )
    {
       TCHAR* pszMsg;

       // select reasonable error message based on GetLastError

       switch( GetLastError() )
       {
          case ERROR_ACCESS_DENIED:
          case ERROR_NETWORK_ACCESS_DENIED:
              pszMsg= szACCESSDENY;
              break;

          case ERROR_FILE_NOT_FOUND:
              pszMsg= szFNF;
              break;

          case ERROR_INVALID_NAME:
              pszMsg= szNVF;
              break;

          default:
              pszMsg= szDiskError;
              break;
       }

       AlertBox(hwndNP, szNN, pszMsg, szFileName,
                 MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
       return (TRUE);
    }

    /* load the file into the edit control */
    LoadFile( szFileName, fInitFileType );         // get print file


    /* print the file */

    if (bDefPrinter)
    {
        PrintIt( DoNotUseDialog );
    }
    else
    {
        PrintIt( NoDialogNonDefault );
    }


    return (TRUE);
}

/* CreateFilter
 *
 * Creates filters for GetOpenFileName.
 *
 */

VOID CreateFilter(PTCHAR szFilterSpec )
{
    PTCHAR pszFilterSpec;

    /* construct default filter string in the required format for
     * the new FileOpen and FileSaveAs dialogs
     * if you add to this, make sure CCHFILTERMAX is large enough.
     */

    // .txt first for compatibility
    pszFilterSpec= szFilterSpec;
    lstrcpy( pszFilterSpec, szAnsiText );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    lstrcpy( pszFilterSpec, TEXT("*.txt"));
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    // and last, all files
    lstrcpy( pszFilterSpec, szAllFiles );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.*") );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    *pszFilterSpec = TEXT('\0');

}

// EnumProc
//
// Callback function for EnumFonts
//
// Purpose: sets lfCharSet in passed logfont to a valid lfCharSet
//          and terminates enumeration.
//

int CALLBACK EnumProc( 
    LOGFONT*     pLf,
    TEXTMETRIC*  pTm,
    DWORD        dwType,
    LPARAM       lpData )
{

    ((LOGFONT*) lpData)-> lfCharSet= pLf->lfCharSet;

    return( 0 );  // stop enumeration
}


/* One time initialization */
INT FAR NPInit (HANDLE hInstance, HANDLE hPrevInstance,
                LPTSTR lpCmdLine, INT cmdShow)
{
    HDC    hDisplayDC;     /* screen DC                */
    RECT   rcT1;           /* for sizing edit window   */
    RECT   rcStatus;       /* rect for the status window */
    INT    iSta;
    WINDOWPLACEMENT wp;    /* structure to place window at the correct position */
    INT    iParts[2];
    HMENU  hMenu;          // handle to the menu.


    /* determine the message number to be used for communication with
     * Find dialog
     */
    if (!(wFRMsg = RegisterWindowMessage ((LPTSTR)FINDMSGSTRING)))
         return FALSE;
    if (!(wHlpMsg = RegisterWindowMessage ((LPTSTR)HELPMSGSTRING)))
         return FALSE;

    /* open a global DC to the display */

    hDisplayDC= GetDC(NULL